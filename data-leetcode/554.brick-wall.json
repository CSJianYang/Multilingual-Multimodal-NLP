[
    {
        "title": "Spiral Matrix",
        "question_content": "Given an m x n matrix, return all elements of the matrix in spiral order.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nExample 2:\n\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 10\n\t-100 <= matrix[i][j] <= 100",
        "solutions": [
            {
                "id": 20571,
                "title": "1-liner-in-python-ruby",
                "content": "Take the first row plus the spiral order of the rotated remaining matrix. Inefficient for large matrices, but here I got it accepted in 40 ms, one of the fastest Python submissions.\\n\\nPython:\\n\\n    def spiralOrder(self, matrix):\\n        return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])\\n\\nPython 3:\\n\\n    def spiralOrder(self, matrix):\\n        return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n\\nRuby:\\n```\\ndef spiral_order(matrix)\\n  (row = matrix.shift) ? row + spiral_order(matrix.transpose.reverse) : []\\nend\\n```\\nor\\n```\\ndef spiral_order(matrix)\\n  matrix[0] ? matrix.shift + spiral_order(matrix.transpose.reverse) : []\\nend\\n```\\n\\n### Visualization\\n\\nHere's how the matrix changes by always extracting the first row and rotating the remaining matrix counter-clockwise:\\n\\n        |1 2 3|      |6 9|      |8 7|      |4|  =>  |5|  =>  ||\\n        |4 5 6|  =>  |5 8|  =>  |5 4|  =>  |5|\\n        |7 8 9|      |4 7|\\n\\nNow look at the first rows we extracted:\\n\\n        |1 2 3|      |6 9|      |8 7|      |4|      |5|\\n\\nThose concatenated are the desired result.\\n\\n### Another visualization\\n```\\n  spiral_order([[1, 2, 3],\\n                [4, 5, 6],\\n                [7, 8, 9]])\\n\\n= [1, 2, 3] + spiral_order([[6, 9],\\n                            [5, 8],\\n                            [4, 7]])\\n\\n= [1, 2, 3] + [6, 9] + spiral_order([[8, 7],\\n                                     [5, 4]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + spiral_order([[4],\\n                                              [5]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + spiral_order([[5]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + spiral_order([])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + []\\n\\n= [1, 2, 3, 6, 9, 8, 7, 4, 5]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef spiral_order(matrix)\\n  (row = matrix.shift) ? row + spiral_order(matrix.transpose.reverse) : []\\nend\\n```\n```\\ndef spiral_order(matrix)\\n  matrix[0] ? matrix.shift + spiral_order(matrix.transpose.reverse) : []\\nend\\n```\n```\\n  spiral_order([[1, 2, 3],\\n                [4, 5, 6],\\n                [7, 8, 9]])\\n\\n= [1, 2, 3] + spiral_order([[6, 9],\\n                            [5, 8],\\n                            [4, 7]])\\n\\n= [1, 2, 3] + [6, 9] + spiral_order([[8, 7],\\n                                     [5, 4]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + spiral_order([[4],\\n                                              [5]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + spiral_order([[5]])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + spiral_order([])\\n\\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + []\\n\\n= [1, 2, 3, 6, 9, 8, 7, 4, 5]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 20599,
                "title": "super-simple-and-easy-to-understand-solution",
                "content": "This is a very simple and easy to understand solution. I traverse right and increment rowBegin, then traverse down and decrement colEnd, then I traverse left and decrement rowEnd, and finally I traverse up and increment colBegin.\\n\\nThe only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. If anyone can do the same thing without that check, please let me know!\\n\\nAny comments greatly appreciated.\\n\\n    public class Solution {\\n        public List<Integer> spiralOrder(int[][] matrix) {\\n            \\n            List<Integer> res = new ArrayList<Integer>();\\n            \\n            if (matrix.length == 0) {\\n                return res;\\n            }\\n            \\n            int rowBegin = 0;\\n            int rowEnd = matrix.length-1;\\n            int colBegin = 0;\\n            int colEnd = matrix[0].length - 1;\\n            \\n            while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n                // Traverse Right\\n                for (int j = colBegin; j <= colEnd; j ++) {\\n                    res.add(matrix[rowBegin][j]);\\n                }\\n                rowBegin++;\\n                \\n                // Traverse Down\\n                for (int j = rowBegin; j <= rowEnd; j ++) {\\n                    res.add(matrix[j][colEnd]);\\n                }\\n                colEnd--;\\n                \\n                if (rowBegin <= rowEnd) {\\n                    // Traverse Left\\n                    for (int j = colEnd; j >= colBegin; j --) {\\n                        res.add(matrix[rowEnd][j]);\\n                    }\\n                }\\n                rowEnd--;\\n                \\n                if (colBegin <= colEnd) {\\n                    // Traver Up\\n                    for (int j = rowEnd; j >= rowBegin; j --) {\\n                        res.add(matrix[j][colBegin]);\\n                    }\\n                }\\n                colBegin ++;\\n            }\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> spiralOrder(int[][] matrix) {\\n            \\n            List<Integer> res = new ArrayList<Integer>();\\n            \\n            if (matrix.length == 0) {\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 20573,
                "title": "a-concise-c-implementation-based-on-directions",
                "content": "When traversing the matrix in the spiral order, at any time we follow one out of the following four directions: RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n\\n0  1   2   3   4   5\\n    6   7   8   9   10\\n   11 12 13 14 15\\n\\nImagine a cursor starts off at (0, -1), i.e. the position at '0', then we can achieve the spiral order by doing the following:\\n\\n1. Go right 5 times \\n2. Go down 2 times\\n3. Go left 4 times\\n4. Go up 1 times.\\n5. Go right 3 times\\n6. Go down 0 times -> quit\\n  \\nNotice that the directions we choose always follow the order 'right->down->left->up', and for horizontal movements, the number of shifts follows:{5, 4, 3}, and vertical movements follows {2, 1, 0}. \\n\\nThus, we can make use of a direction matrix that records the offset for all directions, then an array of two elements that stores the number of shifts for horizontal and vertical movements, respectively. This way, we really just need one for loop instead of four.\\n\\nAnother good thing about this implementation is that: If later we decided to do spiral traversal on a different direction (e.g. Counterclockwise), then we only need to change the Direction matrix; the main loop does not need to be touched.\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<vector<int> > dirs{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        vector<int> res;\\n        int nr = matrix.size();     if (nr == 0) return res;\\n        int nc = matrix[0].size();  if (nc == 0) return res;\\n        \\n        vector<int> nSteps{nc, nr-1};\\n        \\n        int iDir = 0;   // index of direction.\\n        int ir = 0, ic = -1;    // initial position\\n        while (nSteps[iDir%2]) {\\n            for (int i = 0; i < nSteps[iDir%2]; ++i) {\\n                ir += dirs[iDir][0]; ic += dirs[iDir][1];\\n                res.push_back(matrix[ir][ic]);\\n            }\\n            nSteps[iDir%2]--;\\n            iDir = (iDir + 1) % 4;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "When traversing the matrix in the spiral order, at any time we follow one out of the following four directions: RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:\\n\\n0  1   2   3   4   5\\n    6   7   8   9   10\\n   11 12 13 14 15\\n\\nImagine a cursor starts off at (0, -1), i.e. the position at '0', then we can achieve the spiral order by doing the following:\\n\\n1. Go right 5 times \\n2. Go down 2 times\\n3. Go left 4 times\\n4. Go up 1 times.\\n5. Go right 3 times\\n6. Go down 0 times -> quit\\n  \\nNotice that the directions we choose always follow the order 'right->down->left->up', and for horizontal movements, the number of shifts follows:{5, 4, 3}, and vertical movements follows {2, 1, 0}. \\n\\nThus, we can make use of a direction matrix that records the offset for all directions, then an array of two elements that stores the number of shifts for horizontal and vertical movements, respectively. This way, we really just need one for loop instead of four.\\n\\nAnother good thing about this implementation is that: If later we decided to do spiral traversal on a different direction (e.g. Counterclockwise), then we only need to change the Direction matrix; the main loop does not need to be touched.\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<vector<int> > dirs{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        vector<int> res;\\n        int nr = matrix.size();     if (nr == 0) return res;\\n        int nc = matrix[0].size();  if (nc == 0) return res;\\n        \\n        vector<int> nSteps{nc, nr-1};\\n        \\n        int iDir = 0;   // index of direction.\\n        int ir = 0, ic = -1;    // initial position\\n        while (nSteps[iDir%2]) {\\n            for (int i = 0; i < nSteps[iDir%2]; ++i) {\\n                ir += dirs[iDir][0]; ic += dirs[iDir][1];\\n                res.push_back(matrix[ir][ic]);\\n            }\\n            nSteps[iDir%2]--;\\n            iDir = (iDir + 1) % 4;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20570,
                "title": "clean-java-readable-human-friendly-code",
                "content": "    public class Solution {\\n        public List<Integer> spiralOrder(int[][] matrix) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if(matrix.length == 0 || matrix[0].length == 0) return res;\\n            \\n            int top = 0;\\n            int bottom = matrix.length-1;\\n            int left = 0;\\n            int right = matrix[0].length-1;\\n            \\n            while(true){\\n                for(int i = left; i <= right; i++) res.add(matrix[top][i]);\\n                top++;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = top; i <= bottom; i++) res.add(matrix[i][right]);\\n                right--;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = right; i >= left; i--) res.add(matrix[bottom][i]);\\n                bottom--;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = bottom; i >= top; i--) res.add(matrix[i][left]);\\n                left++;\\n                if(left > right || top > bottom) break;\\n            }\\n            \\n            return res;\\n        }\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> spiralOrder(int[][] matrix) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if(matrix.length == 0 || matrix[0].length == 0) return res;\\n            \\n            int top = 0;\\n            int bottom = matrix.length-1;\\n            int left = 0;\\n            int right = matrix[0].length-1;\\n            \\n            while(true){\\n                for(int i = left; i <= right; i++) res.add(matrix[top][i]);\\n                top++;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = top; i <= bottom; i++) res.add(matrix[i][right]);\\n                right--;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = right; i >= left; i--) res.add(matrix[bottom][i]);\\n                bottom--;\\n                if(left > right || top > bottom) break;\\n                \\n                for(int i = bottom; i >= top; i--) res.add(matrix[i][left]);\\n                left++;\\n                if(left > right || top > bottom) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 978853,
                "title": "c-0ms-faster-than-100-easy-solution-with-proper-explanation",
                "content": "**Algorithm:**\\n*  First we will iterate in to first row from left to right push back all the elements into a vector. After iterating, we change the top to second row (top++).\\n*  Then we will iterate from **new top** to bottom and push back only right most elements of each row. After iterating, we change the right to second last column (right--).\\n*  Then we will iterate in bottom row from **right** to **left** and pushback all the elements from **new right** to left. After iterating, we change the bottom to second last row (bottom--).\\n*  Then we will iterate from **new bottom** to **new top** and push back only left most element. After iterating, we change the left to second column (left++).\\n*  Repeat all these steps until left = right **and** top = bottom.\\n\\n![image](https://assets.leetcode.com/users/images/03da4de5-eae8-4dd5-b82d-b33ab1f1eefc_1608447882.2876782.png)\\n\\nTake look at image for better understanding\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int left=0,right=m-1,bottom=n-1,top=0;\\n        int direction=1;\\n        vector<int> v;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction==1)\\n            {\\n                for(int i=left;i<=right;i++) v.push_back(matrix[top][i]);\\n                direction=2;\\n                top++;\\n            }\\n            \\n            else if(direction==2)\\n            {\\n                for(int i=top;i<=bottom;i++) v.push_back(matrix[i][right]);\\n                direction=3;\\n                right--;\\n            }\\n            \\n            else if(direction==3)\\n            {\\n                for(int i=right;i>=left;i--) v.push_back(matrix[bottom][i]);\\n                direction=4;\\n                bottom--;\\n            }\\n            \\n            else if(direction==4)\\n            {\\n                for(int i=bottom;i>=top;i--) v.push_back(matrix[i][left]);\\n                direction=1;\\n                left++;\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```\\n\\n**Upvote it** if you liked it!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int left=0,right=m-1,bottom=n-1,top=0;\\n        int direction=1;\\n        vector<int> v;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(direction==1)\\n            {\\n                for(int i=left;i<=right;i++) v.push_back(matrix[top][i]);\\n                direction=2;\\n                top++;\\n            }\\n            \\n            else if(direction==2)\\n            {\\n                for(int i=top;i<=bottom;i++) v.push_back(matrix[i][right]);\\n                direction=3;\\n                right--;\\n            }\\n            \\n            else if(direction==3)\\n            {\\n                for(int i=right;i>=left;i--) v.push_back(matrix[bottom][i]);\\n                direction=4;\\n                bottom--;\\n            }\\n            \\n            else if(direction==4)\\n            {\\n                for(int i=bottom;i>=top;i--) v.push_back(matrix[i][left]);\\n                direction=1;\\n                left++;\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394774,
                "title": "python-3-solution-for-spiral-matrix-one-of-the-most-easiest-you-will-never-forget",
                "content": "# UPVOTE \\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        if len(matrix) == 0:\\n            return res\\n        row_begin = 0\\n        col_begin = 0\\n        row_end = len(matrix)-1 \\n        col_end = len(matrix[0])-1\\n        while (row_begin <= row_end and col_begin <= col_end):\\n            for i in range(col_begin,col_end+1):\\n                res.append(matrix[row_begin][i])\\n            row_begin += 1\\n            for i in range(row_begin,row_end+1):\\n                res.append(matrix[i][col_end])\\n            col_end -= 1\\n            if (row_begin <= row_end):\\n                for i in range(col_end,col_begin-1,-1):\\n                    res.append(matrix[row_end][i])\\n                row_end -= 1\\n            if (col_begin <= col_end):\\n                for i in range(row_end,row_begin-1,-1):\\n                    res.append(matrix[i][col_begin])\\n                col_begin += 1\\n        return res\\n    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        if len(matrix) == 0:\\n            return res\\n        row_begin = 0\\n        col_begin = 0\\n        row_end = len(matrix)-1 \\n        col_end = len(matrix[0])-1\\n        while (row_begin <= row_end and col_begin <= col_end):\\n            for i in range(col_begin,col_end+1):\\n                res.append(matrix[row_begin][i])\\n            row_begin += 1\\n            for i in range(row_begin,row_end+1):\\n                res.append(matrix[i][col_end])\\n            col_end -= 1\\n            if (row_begin <= row_end):\\n                for i in range(col_end,col_begin-1,-1):\\n                    res.append(matrix[row_end][i])\\n                row_end -= 1\\n            if (col_begin <= col_end):\\n                for i in range(row_end,row_begin-1,-1):\\n                    res.append(matrix[i][col_begin])\\n                col_begin += 1\\n        return res\\n    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 20719,
                "title": "c-spiral-traverse",
                "content": "Traverse the matrix in the spiral order by keeping four variables: `u` for the uppermost row, `d` for the downmost row, `l` for the leftmost column and `r` for the rightmost column.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, u = 0, d = m - 1, l = 0, r = n - 1, p = 0;\\n        vector<int> order(m * n);\\n        while (u <= d && l <= r) {\\n            for (int col = l; col <= r; col++) {\\n                order[p++] = matrix[u][col];\\n            }\\n            if (++u > d) {\\n                break;\\n            }\\n            for (int row = u; row <= d; row++) {\\n                order[p++] = matrix[row][r];\\n            }\\n            if (--r < l) {\\n                break;\\n            }\\n            for (int col = r; col >= l; col--) {\\n                order[p++] = matrix[d][col];\\n            }\\n            if (--d < u) {\\n                break;\\n            }\\n            for (int row = d; row >= u; row--) {\\n                order[p++] = matrix[row][l];\\n            }\\n            if (l++ > r) {\\n                break;\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, u = 0, d = m - 1, l = 0, r = n - 1, p = 0;\\n        vector<int> order(m * n);\\n        while (u <= d && l <= r) {\\n            for (int col = l; col <= r; col++) {\\n                order[p++] = matrix[u][col];\\n            }\\n            if (++u > d) {\\n                break;\\n            }\\n            for (int row = u; row <= d; row++) {\\n                order[p++] = matrix[row][r];\\n            }\\n            if (--r < l) {\\n                break;\\n            }\\n            for (int col = r; col >= l; col--) {\\n                order[p++] = matrix[d][col];\\n            }\\n            if (--d < u) {\\n                break;\\n            }\\n            for (int row = d; row >= u; row--) {\\n                order[p++] = matrix[row][l];\\n            }\\n            if (l++ > r) {\\n                break;\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502600,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. I planned to give for next 10,000 Subscribers as well. If you\\'re interested **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution \\n\\n# Search \\uD83D\\uDC49 `Spiral Matrix by Tech Wired `\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\n- We will use a while loop to traverse the matrix in a clockwise spiral order.\\n- We will define four variables: left, right, top, bottom to represent the four boundaries of the current spiral.\\n- We will use four for loops to traverse each edge of the current spiral in clockwise order and add the elements to the result list.\\n- We will update the boundaries of the current spiral and continue the process until all elements have been traversed.\\n\\n# Intuition:\\n\\n- We start with the outermost layer of the matrix and traverse it in a clockwise spiral order, adding the elements to the result list.\\n- Then we move on to the next inner layer of the matrix and repeat the process until we have traversed all layers.\\n- To traverse each layer, we need to keep track of the four boundaries of the current spiral.\\n- We start at the top-left corner of the current spiral and move right until we hit the top-right corner.\\n- Then we move down to the bottom-right corner and move left until we hit the bottom-left corner.\\n- Finally, we move up to the top-left corner of the next spiral and repeat the process until we have traversed all elements in the matrix.\\n\\n\\n\\n\\n\\n```Python []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        rows, cols = len(matrix), len(matrix[0])\\n        top, bottom, left, right = 0, rows-1, 0, cols-1\\n        result = []\\n        \\n        while len(result) < rows * cols:\\n            for i in range(left, right+1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            \\n            for i in range(top, bottom+1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            \\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            \\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n        \\n        return result\\n\\n```\\n```Java []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return result;\\n        }\\n        \\n        int rows = matrix.length, cols = matrix[0].length;\\n        int left = 0, right = cols-1, top = 0, bottom = rows-1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        if (matrix.empty() || matrix[0].empty()) {\\n            return result;\\n        }\\n        \\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int left = 0, right = cols-1, top = 0, bottom = rows-1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                result.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\\n\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```Python []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        rows, cols = len(matrix), len(matrix[0])\\n        top, bottom, left, right = 0, rows-1, 0, cols-1\\n        result = []\\n        \\n        while len(result) < rows * cols:\\n            for i in range(left, right+1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            \\n            for i in range(top, bottom+1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            \\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            \\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n        \\n        return result\\n\\n```\n```Java []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return result;\\n        }\\n        \\n        int rows = matrix.length, cols = matrix[0].length;\\n        int left = 0, right = cols-1, top = 0, bottom = rows-1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        if (matrix.empty() || matrix[0].empty()) {\\n            return result;\\n        }\\n        \\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int left = 0, right = cols-1, top = 0, bottom = rows-1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                result.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999388,
                "title": "95-41-faster-solution",
                "content": "1 - pop the first row and store it in result\\n2 - rotate the remaining matrix\\n3 - jump to 1st step.\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0)\\n            matrix = (list(zip(*matrix)))[::-1]\\n        return result\\n```\\n\\nfor beginners who does not know the workings of zip here is explaination:\\n```\\nl = [1,2,3]\\nl2 = [4,5,6]\\nprint(list(zip(l,l2)))\\n#it will print [(1,4),(2,5),(3,6)]\\n```\\n\\nFor * (Star expression) here\\'s an example to understand\\n```\\ndef add(a,b):\\n\\treturn a+b\\nl = (2,3)\\nprint(add(*l))\\n```\\nIt basically unpacks the tuple and puts them as positional arguments in the function call.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0)\\n            matrix = (list(zip(*matrix)))[::-1]\\n        return result\\n```\n```\\nl = [1,2,3]\\nl2 = [4,5,6]\\nprint(list(zip(l,l2)))\\n#it will print [(1,4),(2,5),(3,6)]\\n```\n```\\ndef add(a,b):\\n\\treturn a+b\\nl = (2,3)\\nprint(add(*l))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466413,
                "title": "python-simulate-process-explained",
                "content": "Let us use coordinate `(x, y)` and direction of movement `(dx, dy)`. Each time when we reach point outside matrix we rotate. How we can rotate? We can either create array of rotations in advance or we can use the trick `dx, dy = -dy, dx`. Also how we understand it is time to rotate? We will write already visited elements with `*`, so when we see `*` or we go outside the grid, it is time to rotate.\\n\\n#### Complexity\\nIt is `O(mn)` both for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def spiralOrder(self, matrix):\\n        n, m = len(matrix[0]), len(matrix)\\n        x, y, dx, dy = 0, 0, 1, 0\\n        ans = []\\n        for _ in range(m*n):\\n            if not 0 <= x+dx < n or not 0 <= y+dy < m or matrix[y+dy][x+dx] == \"*\":\\n                dx, dy = -dy, dx\\n                \\n            ans.append(matrix[y][x])\\n            matrix[y][x] = \"*\"\\n            x, y = x + dx, y + dy\\n        \\n        return ans\\n``` \\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def spiralOrder(self, matrix):\\n        n, m = len(matrix[0]), len(matrix)\\n        x, y, dx, dy = 0, 0, 1, 0\\n        ans = []\\n        for _ in range(m*n):\\n            if not 0 <= x+dx < n or not 0 <= y+dy < m or matrix[y+dy][x+dx] == \"*\":\\n                dx, dy = -dy, dx\\n                \\n            ans.append(matrix[y][x])\\n            matrix[y][x] = \"*\"\\n            x, y = x + dx, y + dy\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20579,
                "title": "simple-python-solution-by-mutating-the-matrix",
                "content": "The con is mutating the matrix, if this is not allowed, we can make a deep copy of the matrix first. And of course it comes with the additional memory usage.\\n\\n      \\n    def spiralOrder(self, matrix):\\n        ret = []\\n        while matrix:\\n            ret += matrix.pop(0)\\n            if matrix and matrix[0]:\\n                for row in matrix:\\n                    ret.append(row.pop())\\n            if matrix:\\n                ret += matrix.pop()[::-1]\\n            if matrix and matrix[0]:\\n                for row in matrix[::-1]:\\n                    ret.append(row.pop(0))\\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "The con is mutating the matrix, if this is not allowed, we can make a deep copy of the matrix first. And of course it comes with the additional memory usage.\\n\\n      \\n    def spiralOrder(self, matrix):\\n        ret = []\\n        while matrix:\\n            ret += matrix.pop(0)\\n            if matrix and matrix[0]:\\n                for row in matrix:\\n                    ret.append(row.pop())\\n            if matrix:\\n                ret += matrix.pop()[::-1]\\n            if matrix and matrix[0]:\\n                for row in matrix[::-1]:\\n                    ret.append(row.pop(0))\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 3503000,
                "title": "day-404-brute-better-optimal-1-liner-0ms-100-python-java-c-explained",
                "content": "\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n![image.png](https://assets.leetcode.com/users/images/e0fa2719-73a2-4974-975c-bd971f7b11b4_1683602842.914548.png)\\n\\n# BRUTE\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force Approach:\\n\\nUse a stack and a 2D array to traverse the matrix in spiral order. It starts at the top-left corner of the matrix and pushes the coordinates onto the stack. It then pops the coordinates from the stack and checks if they are within the boundaries of the matrix and if they have been visited before. If they have not been visited, the value at that coordinate is added to the answer list and the coordinate is marked as visited. The program then checks the next coordinate in the direction of traversal (which is determined by the direction array) and pushes it onto the stack. If the next coordinate is out of bounds or has been visited before, the direction of traversal is changed by incrementing the index of the direction array. The program continues to pop coordinates from the stack until it is empty, at which point it returns the answer list.\\n\\n```java []\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n    int m = matrix.length;\\n    int n = matrix[0].length;\\n    List<Integer> answer = new ArrayList<>();\\n    int[][] direction = {{1,0}, {0,-1}, {-1,0}, {0,1}};\\n    int[][] visited = new int[m][n];\\n    for(int i = 0; i < m; i++) {\\n        Arrays.fill(visited[i], 0);\\n    }\\n    Consumer<int[]> traverse = (coord) -> {\\n        int index = 3;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(coord);\\n        while(!stack.isEmpty()) {\\n            coord = stack.pop();\\n            if(coord[0] >= m || coord[0] < 0 || coord[1] >= n || coord[1] < 0 || visited[coord[0]][coord[1]] == 1) {\\n                continue;\\n            }\\n            answer.add(matrix[coord[0]][coord[1]]);\\n            visited[coord[0]][coord[1]] = 1;\\n            int[] coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n            if(coord2[0] >= m || coord2[0] < 0 || coord2[1] >= n || coord2[1] < 0 || visited[coord2[0]][coord2[1]] == 1) {\\n                index = (index + 1) % 4;\\n            }\\n            coord2 = new int[]{coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n            stack.push(coord2);\\n        }\\n    };\\n    traverse.accept(new int[]{0,0});\\n    return answer;\\n}\\n```\\n```c++ []\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    int m = matrix.size();\\n    int n = matrix[0].size();\\n    vector<int> answer;\\n    vector<vector<int>> direction = {{1,0}, {0,-1}, {-1,0}, {0,1}};\\n    vector<vector<int>> visited(m, vector<int>(n, 0));\\n    function<void(vector<int>, int)> traverse = [&](vector<int> coord, int index) {\\n        if(coord[0] >= m || coord[0] < 0 || coord[1] >= n || coord[1] < 0 || visited[coord[0]][coord[1]] == 1) {\\n            return;\\n        }\\n        answer.push_back(matrix[coord[0]][coord[1]]);\\n        visited[coord[0]][coord[1]] = 1;\\n        vector<int> coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n        if(coord2[0] >= m || coord2[0] < 0 || coord2[1] >= n || coord2[1] < 0 || visited[coord2[0]][coord2[1]] == 1) {\\n            index = (index + 1) % 4;\\n        }\\n        coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n        traverse(coord2, index);\\n    };\\n    traverse({0,0}, 3);\\n    return answer;\\n}\\n```\\n```python []\\ndef spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n  m = len(matrix)\\n  n = len(matrix[0])\\n  answer = []\\n  direction = [[1,0],[0,-1],[-1,0],[0,1]]\\n  visited = []\\n  for i in range(m):\\n      visited.append([0]*n)\\n  def traverse(coord, index):\\n      if coord[0] >= m or coord[0] < 0 or coord[1] >= n or coord[0] < 0 or visited[coord[0]][coord[1]] == 1:\\n          return\\n      answer.append(matrix[coord[0]][coord[1]])\\n      visited[coord[0]][coord[1]] = 1\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      if coord2[0] >= m or coord2[0] < 0 or coord2[1] >= n or coord2[0] < 0 or visited[coord2[0]][coord2[1]] == 1:\\n          index = (index + 1) % 4\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      traverse(coord2, index)\\n  traverse([0,0],3)\\n  return answer\\n```\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# BETTER \\n\\nBetter Approach:\\n\\nThis approach uses four variables to keep track of the boundaries of the matrix and a variable to keep track of the direction of traversal. It starts at the top-left corner of the matrix and adds the value at that coordinate to the result list. It then checks the direction of traversal and increments or decrements the row or column index accordingly. If the index reaches a boundary, the boundary is updated and the direction of traversal is changed. The program continues to add values to the result list until it has added all the values in the matrix. Finally, it returns the result list. This approach is similar to the previous approaches, but it uses boundary variables and a character variable to keep track of the direction of traversal instead of a 2D array.\\n\\n\\n# Code\\n```java  []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int nrow = matrix.length;\\n        int ncol = matrix[0].length;\\n        int l_wall = -1, r_wall = ncol, u_wall = 0, d_wall = nrow;\\n        char direction = \\'r\\';\\n        List<Integer> result = new ArrayList<>();\\n        int i = 0, j = 0;\\n        while(result.size() < nrow * ncol) {\\n            result.add(matrix[i][j]);\\n            if(direction == \\'r\\') {\\n                j++;\\n                if(j == r_wall) {\\n                    r_wall--;\\n                    j = r_wall;\\n                    direction = \\'d\\';\\n                    i++;\\n                }\\n            }\\n            else if(direction == \\'d\\') {\\n                i++;\\n                if(i == d_wall) {\\n                    d_wall--;\\n                    i = d_wall;\\n                    direction = \\'l\\';\\n                    j--;\\n                }\\n            }\\n            else if(direction == \\'l\\') {\\n                j--;\\n                if(j == l_wall) {\\n                    l_wall++;\\n                    j = l_wall;\\n                    direction = \\'u\\';\\n                    i--;\\n                }\\n            }\\n            else if(direction == \\'u\\') {\\n                i--;\\n                if(i == u_wall) {\\n                    u_wall++;\\n                    i = u_wall;\\n                    direction = \\'r\\';\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int nrow = matrix.size();\\n        int ncol = matrix[0].size();\\n        int l_wall = -1, r_wall = ncol, u_wall = 0, d_wall = nrow;\\n        char direction = \\'r\\';\\n        vector<int> result;\\n        int i = 0, j = 0;\\n        while(result.size() < nrow * ncol) {\\n            result.push_back(matrix[i][j]);\\n            if(direction == \\'r\\') {\\n                j++;\\n                if(j == r_wall) {\\n                    r_wall--;\\n                    j = r_wall;\\n                    direction = \\'d\\';\\n                    i++;\\n                }\\n            }\\n            else if(direction == \\'d\\') {\\n                i++;\\n                if(i == d_wall) {\\n                    d_wall--;\\n                    i = d_wall;\\n                    direction = \\'l\\';\\n                    j--;\\n                }\\n            }\\n            else if(direction == \\'l\\') {\\n                j--;\\n                if(j == l_wall) {\\n                    l_wall++;\\n                    j = l_wall;\\n                    direction = \\'u\\';\\n                    i--;\\n                }\\n            }\\n            else if(direction == \\'u\\') {\\n                i--;\\n                if(i == u_wall) {\\n                    u_wall++;\\n                    i = u_wall;\\n                    direction = \\'r\\';\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n```PYTHON []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        nrow, ncol = len(matrix), len(matrix[0])\\n        l_wall, r_wall = -1, ncol\\n        u_wall, d_wall = 0, nrow\\n        direction = \\'r\\'\\n        result = []\\n        i, j = 0, 0\\n        while len(result) < nrow * ncol:\\n            result.append(matrix[i][j])\\n            if direction == \\'r\\':\\n                j += 1\\n                if j == r_wall:\\n                    r_wall -= 1\\n                    j = r_wall\\n                    direction = \\'d\\'\\n                    i += 1\\n            elif direction == \\'d\\':\\n                i += 1\\n                if i == d_wall:\\n                    d_wall -= 1\\n                    i = d_wall\\n                    direction = \\'l\\'\\n                    j -= 1\\n            elif direction == \\'l\\':\\n                j -= 1\\n                if j == l_wall:\\n                    l_wall += 1\\n                    j = l_wall\\n                    direction = \\'u\\'\\n                    i -= 1\\n            elif direction == \\'u\\':\\n                i -= 1\\n                if i == u_wall:\\n                    u_wall += 1\\n                    i = u_wall\\n                    direction = \\'r\\'\\n                    j += 1\\n        return result\\n```\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Optimal\\n\\nOptimal Approach:\\n\\nWe can further optimize the above approach by using a single loop to traverse the matrix in a spiral order. We start by initializing the top, bottom, left, and right pointers to the edges of the matrix. We then use a single loop to traverse the matrix in a spiral order by moving the pointers inward after each traversal. We continue this process until we have visited all elements of the matrix.\\n\\n\\n```JAVA []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0) {\\n            return result;\\n        }\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int top = 0, bottom = m - 1, left = 0, right = n - 1;\\n        while(top <= bottom && left <= right) {\\n            // Traverse right\\n            for(int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            // Traverse down\\n            for(int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            // Traverse left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            // Traverse up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        if(matrix.empty() || matrix[0].empty()) {\\n            return result;\\n        }\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int top = 0, bottom = m - 1, left = 0, right = n - 1;\\n        while(top <= bottom && left <= right) {\\n            // Traverse right\\n            for(int i = left; i <= right; i++) {\\n                result.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            // Traverse down\\n            for(int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            // Traverse left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    result.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            // Traverse up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n```PYTHON []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        if not matrix or not matrix[0]:\\n            return result\\n        m, n = len(matrix), len(matrix[0])\\n        top, bottom, left, right = 0, m - 1, 0, n - 1\\n        while top <= bottom and left <= right:\\n            # Traverse right\\n            for i in range(left, right + 1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            # Traverse down\\n            for i in range(top, bottom + 1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            # Traverse left\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            # Traverse up\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n        return result\\n```\\n\\n# ONE LINER \\n```PYTHON []\\ndef spiralOrder(self, matrix):\\n    return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])\\n```\\n```PYTHON3 []\\ndef spiralOrder(self, matrix):\\n    return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n```\\n```py []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0)  # pop the first row each time\\n            matrix = list(zip(*matrix))[::-1]  # left rotate matrix 90 degree each time\\n        return result\\n```\\n# how it works step by step.\\n\\nThe first line of the code checks if the matrix is not empty. If the matrix is empty, it returns an empty list. If the matrix is not empty, it proceeds with the traversal.\\n\\n##### \\u2022return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\nThe second line of the code uses a list comprehension to extract the first row of the matrix and add it to the result list. It then uses the pop() method to remove the first row from the matrix.\\n\\n##### \\u2022[*matrix.pop(0)]\\nThe third line of the code uses the zip() function to transpose the matrix and then reverses the order of the rows using slicing. This creates a new matrix that can be traversed in the next recursive call.\\n\\n##### \\u2022[*zip(*matrix)][::-1]\\nThe fourth line of the code uses recursion to traverse the new matrix in a spiral order. The result of the recursive call is added to the result list using the + operator.\\n\\n##### \\u2022self.spiralOrder([*zip(*matrix)][::-1])\\nFinally, the result list is returned.\\n\\n##### \\u2022return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\nusing recursive approach to traverse the matrix in a spiral order. It extracts the first row of the matrix, removes it from the matrix, transposes the matrix, and then reverses the order of the rows to create a new matrix that can be traversed in the next recursive call. The process continues until all elements of the matrix have been added to the result list.\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# DRY RUN\\n\\n\\n##### \\u2022\\tExample 1:\\n![image.png](https://assets.leetcode.com/users/images/38c304d2-83e3-4e4b-a5cb-23c57ff432fb_1683603361.7566543.png)\\n##### \\u2022\\tInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\\n##### \\u2022\\tOutput: [1,2,3,6,9,8,7,4,5]\\n##### \\u2022\\tStep-by-Step Explanation:\\n##### \\u2022\\tInitialize the result list as an empty list.\\n##### \\u2022\\tSet the top, bottom, left, and right pointers to the edges of the matrix. top = 0, bottom = 2, left = 0, right = 2.\\n##### \\u2022\\tTraverse the first row from left to right and add the elements to the result list. result = [1, 2, 3]. Increment the top pointer to 1.\\n##### \\u2022\\tTraverse the last column from top to bottom and add the elements to the result list. result = [1, 2, 3, 6, 9]. Decrement the right pointer to 1.\\n##### \\u2022\\tCheck if top <= bottom. Since it is true, traverse the last row from right to left and add the elements to the result list. result = [1, 2, 3, 6, 9, 8, 7]. Decrement the bottom pointer to 1.\\n##### \\u2022\\tCheck if left <= right. Since it is true, traverse the first column from bottom to top and add the elements to the result list. result = [1, 2, 3, 6, 9, 8, 7, 4, 5]. Increment the left pointer to 1.\\n##### \\u2022\\tCheck if top <= bottom. Since it is false, the traversal is complete. Return the result list.\\n##### \\u2022\\tExample 2:\\n![image.png](https://assets.leetcode.com/users/images/6d7fe5a8-721d-4475-b379-59bcb7e423ab_1683603351.6500404.png)\\n##### \\u2022\\tInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\\n##### \\u2022\\tOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\\n##### \\u2022\\tStep-by-Step Explanation:\\n##### \\u2022\\tInitialize the result list as an empty list.\\n##### \\u2022\\tSet the top, bottom, left, and right pointers to the edges of the matrix. top = 0, bottom = 2, left = 0, right = 3.\\n##### \\u2022\\tTraverse the first row from left to right and add the elements to the result list. result = [1, 2, 3, 4]. Increment the top pointer to 1.\\n##### \\u2022\\tTraverse the last column from top to bottom and add the elements to the result list. result = [1, 2, 3, 4, 8, 12]. Decrement the right pointer to 2.\\n##### \\u2022\\tCheck if top <= bottom. Since it is true, traverse the last row from right to left and add the elements to the result list. result = [1, 2, 3, 4, 8, 12, 11, 10, 9]. Decrement the bottom pointer to 1.\\n##### \\u2022\\tCheck if left <= right. Since it is true, traverse the first column from bottom to top and add the elements to the result list. result = [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]. Increment the left pointer to 1.\\n##### \\u2022\\tCheck if top <= bottom. Since it is false, the traversal is complete. Return the result list.\\n\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```java []\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n    int m = matrix.length;\\n    int n = matrix[0].length;\\n    List<Integer> answer = new ArrayList<>();\\n    int[][] direction = {{1,0}, {0,-1}, {-1,0}, {0,1}};\\n    int[][] visited = new int[m][n];\\n    for(int i = 0; i < m; i++) {\\n        Arrays.fill(visited[i], 0);\\n    }\\n    Consumer<int[]> traverse = (coord) -> {\\n        int index = 3;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(coord);\\n        while(!stack.isEmpty()) {\\n            coord = stack.pop();\\n            if(coord[0] >= m || coord[0] < 0 || coord[1] >= n || coord[1] < 0 || visited[coord[0]][coord[1]] == 1) {\\n                continue;\\n            }\\n            answer.add(matrix[coord[0]][coord[1]]);\\n            visited[coord[0]][coord[1]] = 1;\\n            int[] coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n            if(coord2[0] >= m || coord2[0] < 0 || coord2[1] >= n || coord2[1] < 0 || visited[coord2[0]][coord2[1]] == 1) {\\n                index = (index + 1) % 4;\\n            }\\n            coord2 = new int[]{coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n            stack.push(coord2);\\n        }\\n    };\\n    traverse.accept(new int[]{0,0});\\n    return answer;\\n}\\n```\n```c++ []\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    int m = matrix.size();\\n    int n = matrix[0].size();\\n    vector<int> answer;\\n    vector<vector<int>> direction = {{1,0}, {0,-1}, {-1,0}, {0,1}};\\n    vector<vector<int>> visited(m, vector<int>(n, 0));\\n    function<void(vector<int>, int)> traverse = [&](vector<int> coord, int index) {\\n        if(coord[0] >= m || coord[0] < 0 || coord[1] >= n || coord[1] < 0 || visited[coord[0]][coord[1]] == 1) {\\n            return;\\n        }\\n        answer.push_back(matrix[coord[0]][coord[1]]);\\n        visited[coord[0]][coord[1]] = 1;\\n        vector<int> coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n        if(coord2[0] >= m || coord2[0] < 0 || coord2[1] >= n || coord2[1] < 0 || visited[coord2[0]][coord2[1]] == 1) {\\n            index = (index + 1) % 4;\\n        }\\n        coord2 = {coord[0] + direction[index][0], coord[1] + direction[index][1]};\\n        traverse(coord2, index);\\n    };\\n    traverse({0,0}, 3);\\n    return answer;\\n}\\n```\n```python []\\ndef spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n  m = len(matrix)\\n  n = len(matrix[0])\\n  answer = []\\n  direction = [[1,0],[0,-1],[-1,0],[0,1]]\\n  visited = []\\n  for i in range(m):\\n      visited.append([0]*n)\\n  def traverse(coord, index):\\n      if coord[0] >= m or coord[0] < 0 or coord[1] >= n or coord[0] < 0 or visited[coord[0]][coord[1]] == 1:\\n          return\\n      answer.append(matrix[coord[0]][coord[1]])\\n      visited[coord[0]][coord[1]] = 1\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      if coord2[0] >= m or coord2[0] < 0 or coord2[1] >= n or coord2[0] < 0 or visited[coord2[0]][coord2[1]] == 1:\\n          index = (index + 1) % 4\\n      coord2 = [a + b for a, b in zip(coord, direction[index])]\\n      traverse(coord2, index)\\n  traverse([0,0],3)\\n  return answer\\n```\n```java  []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int nrow = matrix.length;\\n        int ncol = matrix[0].length;\\n        int l_wall = -1, r_wall = ncol, u_wall = 0, d_wall = nrow;\\n        char direction = \\'r\\';\\n        List<Integer> result = new ArrayList<>();\\n        int i = 0, j = 0;\\n        while(result.size() < nrow * ncol) {\\n            result.add(matrix[i][j]);\\n            if(direction == \\'r\\') {\\n                j++;\\n                if(j == r_wall) {\\n                    r_wall--;\\n                    j = r_wall;\\n                    direction = \\'d\\';\\n                    i++;\\n                }\\n            }\\n            else if(direction == \\'d\\') {\\n                i++;\\n                if(i == d_wall) {\\n                    d_wall--;\\n                    i = d_wall;\\n                    direction = \\'l\\';\\n                    j--;\\n                }\\n            }\\n            else if(direction == \\'l\\') {\\n                j--;\\n                if(j == l_wall) {\\n                    l_wall++;\\n                    j = l_wall;\\n                    direction = \\'u\\';\\n                    i--;\\n                }\\n            }\\n            else if(direction == \\'u\\') {\\n                i--;\\n                if(i == u_wall) {\\n                    u_wall++;\\n                    i = u_wall;\\n                    direction = \\'r\\';\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int nrow = matrix.size();\\n        int ncol = matrix[0].size();\\n        int l_wall = -1, r_wall = ncol, u_wall = 0, d_wall = nrow;\\n        char direction = \\'r\\';\\n        vector<int> result;\\n        int i = 0, j = 0;\\n        while(result.size() < nrow * ncol) {\\n            result.push_back(matrix[i][j]);\\n            if(direction == \\'r\\') {\\n                j++;\\n                if(j == r_wall) {\\n                    r_wall--;\\n                    j = r_wall;\\n                    direction = \\'d\\';\\n                    i++;\\n                }\\n            }\\n            else if(direction == \\'d\\') {\\n                i++;\\n                if(i == d_wall) {\\n                    d_wall--;\\n                    i = d_wall;\\n                    direction = \\'l\\';\\n                    j--;\\n                }\\n            }\\n            else if(direction == \\'l\\') {\\n                j--;\\n                if(j == l_wall) {\\n                    l_wall++;\\n                    j = l_wall;\\n                    direction = \\'u\\';\\n                    i--;\\n                }\\n            }\\n            else if(direction == \\'u\\') {\\n                i--;\\n                if(i == u_wall) {\\n                    u_wall++;\\n                    i = u_wall;\\n                    direction = \\'r\\';\\n                    j++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```PYTHON []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        nrow, ncol = len(matrix), len(matrix[0])\\n        l_wall, r_wall = -1, ncol\\n        u_wall, d_wall = 0, nrow\\n        direction = \\'r\\'\\n        result = []\\n        i, j = 0, 0\\n        while len(result) < nrow * ncol:\\n            result.append(matrix[i][j])\\n            if direction == \\'r\\':\\n                j += 1\\n                if j == r_wall:\\n                    r_wall -= 1\\n                    j = r_wall\\n                    direction = \\'d\\'\\n                    i += 1\\n            elif direction == \\'d\\':\\n                i += 1\\n                if i == d_wall:\\n                    d_wall -= 1\\n                    i = d_wall\\n                    direction = \\'l\\'\\n                    j -= 1\\n            elif direction == \\'l\\':\\n                j -= 1\\n                if j == l_wall:\\n                    l_wall += 1\\n                    j = l_wall\\n                    direction = \\'u\\'\\n                    i -= 1\\n            elif direction == \\'u\\':\\n                i -= 1\\n                if i == u_wall:\\n                    u_wall += 1\\n                    i = u_wall\\n                    direction = \\'r\\'\\n                    j += 1\\n        return result\\n```\n```JAVA []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0) {\\n            return result;\\n        }\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int top = 0, bottom = m - 1, left = 0, right = n - 1;\\n        while(top <= bottom && left <= right) {\\n            // Traverse right\\n            for(int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            // Traverse down\\n            for(int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            // Traverse left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            // Traverse up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        if(matrix.empty() || matrix[0].empty()) {\\n            return result;\\n        }\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int top = 0, bottom = m - 1, left = 0, right = n - 1;\\n        while(top <= bottom && left <= right) {\\n            // Traverse right\\n            for(int i = left; i <= right; i++) {\\n                result.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            // Traverse down\\n            for(int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            // Traverse left\\n            if(top <= bottom) {\\n                for(int i = right; i >= left; i--) {\\n                    result.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            // Traverse up\\n            if(left <= right) {\\n                for(int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```PYTHON []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        if not matrix or not matrix[0]:\\n            return result\\n        m, n = len(matrix), len(matrix[0])\\n        top, bottom, left, right = 0, m - 1, 0, n - 1\\n        while top <= bottom and left <= right:\\n            # Traverse right\\n            for i in range(left, right + 1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            # Traverse down\\n            for i in range(top, bottom + 1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            # Traverse left\\n            if top <= bottom:\\n                for i in range(right, left - 1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            # Traverse up\\n            if left <= right:\\n                for i in range(bottom, top - 1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n        return result\\n```\n```PYTHON []\\ndef spiralOrder(self, matrix):\\n    return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])\\n```\n```PYTHON3 []\\ndef spiralOrder(self, matrix):\\n    return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n```\n```py []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0)  # pop the first row each time\\n            matrix = list(zip(*matrix))[::-1]  # left rotate matrix 90 degree each time\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039684,
                "title": "python-solution-explained-step-by-step-with-illustrations",
                "content": "### \\u2705 Upvote if it helps! \\n\\n# Code :\\n```\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0) # 1\\n\\n            if matrix and matrix[0]: # 2 \\n                for line in matrix:\\n                    result.append(line.pop())\\n\\n            if matrix: # 3\\n                result += matrix.pop()[::-1]\\n\\n            if matrix and matrix[0]: # 4\\n                for line in matrix[::-1]:\\n                    result.append(line.pop(0))\\n        return result\\n```\\n\\n\\n# Step by step :\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s explain what\\'s inside the loop step by step with an example:\\n\\n\\n- **Initial state**:\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/7e17f951-0d27-4031-bd19-3cd94990a3df_1673513448.4431794.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n- **Step 1**:\\n```\\nresult += matrix.pop(0)\\n```\\nWe add the first line to the result and delete it from the initial matrix.\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/8e873cf6-0239-4ef2-b4c9-6373a546757d_1673513580.3806927.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n- **Step 2**:\\n```\\nfor line in matrix:\\n    result.append(line.pop())\\n```\\nWe iterate over the lines *(in green)* and we are popping the ***last*** item of each line (in red).\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/4c9c8a98-27c6-42ad-82fa-da8e309199ab_1673513719.533255.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n\\n\\n- **Step 3**:\\n```\\nresult += matrix.pop()[::-1]\\n```\\nWe add the last line in a reverse order.\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/4319c5be-0d19-41cf-9f51-3a1236c760fd_1673513818.7995842.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n\\n\\n\\n- **Step 4**:\\n```\\nfor line in matrix[::-1]:\\n    result.append(line.pop(0))\\n```\\nWe iterate over the lines and we are popping the ***first*** item of each line (in red).\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/ec967a82-1e5e-45cb-bba1-d3d70e7872e5_1673513878.5658035.png\" alt=\"drawing\" width=\"100\"/>\\n</p>\\n\\n\\n\\nWhen we escape the loop, it means that the matrix is empty and that we explored all cells.\\nWe cans then return the result.\\n\\n# **Upvote if it helps!** \\uD83D\\uDE00\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        result = []\\n        while matrix:\\n            result += matrix.pop(0) # 1\\n\\n            if matrix and matrix[0]: # 2 \\n                for line in matrix:\\n                    result.append(line.pop())\\n\\n            if matrix: # 3\\n                result += matrix.pop()[::-1]\\n\\n            if matrix and matrix[0]: # 4\\n                for line in matrix[::-1]:\\n                    result.append(line.pop(0))\\n        return result\\n```\n```\\nresult += matrix.pop(0)\\n```\n```\\nfor line in matrix:\\n    result.append(line.pop())\\n```\n```\\nresult += matrix.pop()[::-1]\\n```\n```\\nfor line in matrix[::-1]:\\n    result.append(line.pop(0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20656,
                "title": "ac-python-32ms-solution",
                "content": "    def spiralOrder(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return []\\n        ans = []\\n        m, n = len(matrix), len(matrix[0])\\n        u, d, l, r = 0, m - 1, 0, n - 1\\n        while l < r and u < d:\\n            ans.extend([matrix[u][j] for j in xrange(l, r)])\\n            ans.extend([matrix[i][r] for i in xrange(u, d)])\\n            ans.extend([matrix[d][j] for j in xrange(r, l, -1)])\\n            ans.extend([matrix[i][l] for i in xrange(d, u, -1)])\\n            u, d, l, r = u + 1, d - 1, l + 1, r - 1\\n        if l == r:\\n            ans.extend([matrix[i][r] for i in xrange(u, d + 1)])\\n        elif u == d:\\n            ans.extend([matrix[u][j] for j in xrange(l, r + 1)])\\n        return ans\\n\\n\\n    # 22 / 22 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 32 ms\\n    # 100%",
                "solutionTags": [],
                "code": "    def spiralOrder(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return []\\n        ans = []\\n        m, n = len(matrix), len(matrix[0])\\n        u, d, l, r = 0, m - 1, 0, n - 1\\n        while l < r and u < d:\\n            ans.extend([matrix[u][j] for j in xrange(l, r)])\\n            ans.extend([matrix[i][r] for i in xrange(u, d)])\\n            ans.extend([matrix[d][j] for j in xrange(r, l, -1)])\\n            ans.extend([matrix[i][l] for i in xrange(d, u, -1)])\\n            u, d, l, r = u + 1, d - 1, l + 1, r - 1\\n        if l == r:\\n            ans.extend([matrix[i][r] for i in xrange(u, d + 1)])\\n        elif u == d:\\n            ans.extend([matrix[u][j] for j in xrange(l, r + 1)])\\n        return ans\\n\\n\\n    # 22 / 22 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 32 ms\\n    # 100%",
                "codeTag": "Python3"
            },
            {
                "id": 651503,
                "title": "javascript-simple-and-clean",
                "content": "```\\nvar spiralOrder = function(matrix) {\\n  const res = []\\n  while(matrix.length){\\n    const first = matrix.shift()\\n    res.push(...first)\\n    for(const m of matrix){\\n      let val = m.pop()\\n      if(val)\\n        res.push(val)\\n        m.reverse()   \\n    }\\n    matrix.reverse()\\n  }\\n  return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spiralOrder = function(matrix) {\\n  const res = []\\n  while(matrix.length){\\n    const first = matrix.shift()\\n    res.push(...first)\\n    for(const m of matrix){\\n      let val = m.pop()\\n      if(val)\\n        res.push(val)\\n        m.reverse()   \\n    }\\n    matrix.reverse()\\n  }\\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468151,
                "title": "python-smart-simulate-by-marking-as-visited-clean-concise",
                "content": "**Idea**\\n- Initially, we move by the RIGHT direction.\\n- If we meet the boundary or we meet visited cell then we change to the next direction.\\n- Directions are in order [RIGHT, DOWN, LEFT, TOP].\\n- We iterate `m*n` times to add `m*n` cells to our anser.\\n- This problem **[59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)** is exactly the same, try to solve it yourself.\\n\\n![image](https://assets.leetcode.com/users/images/9d38605b-ab50-4a07-af35-d5aaa183a494_1631859060.3834043.png)\\n\\n\\n```python\\nclass Solution:\\n    def spiralOrder(self, matrix):\\n        m, n, VISITED = len(matrix), len(matrix[0]), 200\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c, d = 0, 0, 0\\n        ans = []\\n        for _ in range(m * n):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < m or not 0 <= nc < n or matrix[nr][nc] == VISITED:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n\\n            ans.append(matrix[r][c])\\n            matrix[r][c] = VISITED  # Mark as visited\\n            r, c = nr, nc\\n\\n        return ans\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 10` is number of rows, `N <= 10` is number of columns in the matrix.\\n- Extra space (without counting output as space): `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def spiralOrder(self, matrix):\\n        m, n, VISITED = len(matrix), len(matrix[0]), 200\\n        DIR = [0, 1, 0, -1, 0]  # (r + DIR[i], c + DIR[i+1]) corresponding to move [RIGHT, DOWN, LEFT, TOP]\\n        r, c, d = 0, 0, 0\\n        ans = []\\n        for _ in range(m * n):\\n            nr, nc = r + DIR[d], c + DIR[d+1]\\n            if not 0 <= nr < m or not 0 <= nc < n or matrix[nr][nc] == VISITED:  # If out of bound or already visited\\n                d = (d + 1) % 4  # Change next direction\\n                nr, nc = r + DIR[d], c + DIR[d+1]\\n\\n            ans.append(matrix[r][c])\\n            matrix[r][c] = VISITED  # Mark as visited\\n            r, c = nr, nc\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447082,
                "title": "python-96-simple-solution-w-explanation",
                "content": "# Intuition:\\nWe can think about the matrix as an onion. We will first spiral around the outermost layer, adding it to the result, then \"discard\" the outer layer. This leaves us with a new outermost layer which we haven\\'t examined yet, on which we repeat the process.\\n\\n# Algorithm:\\n- Keep track of **four pointers**: a left, right, up, and down pointer. This tells us which portion of the matrix we should be adding, since with every successive spiral it shrinks. We will **update these pointers to tell us which part of the array we haven\\'t looked at yet** (the box formed by these pointers). \\n- We will build our solution from four distinct movements: scanning **left -> right on the topmost row** we haven\\'t looked at, scanning **top -> bottom on the rightmost column**, scanning **right -> left on the bottommost row,** and **bottom -> top on the leftmost column.**\\n- First scan from **left to right.** The pointers are as follows:\\n```\\nL     R\\n|     |\\nv     v\\nx x x x <- T\\nx x x x\\nx x x x <- B\\n```\\nAfter adding the whole first row, **we move the top pointer down one row** to indicate that the first row has been examined.\\n- Next scan from top to bottom. The pointers are as follows:\\n```\\nL     R\\n|     |\\nv     v\\nx x x x \\nx x x x <- T\\nx x x x <- B\\n```\\nWe want to include all members of the R column between T and B (inclusive). Note that the **topmost member of the R column was already added** when scanning left -> right, so we don\\'t want a duplicate. After scanning this column, we **move the right pointer left one column** to indicate the R column was just added.\\n- Next scan from right to left. The pointers are as follows:\\n```\\nL   R\\n|   |\\nv   v\\nx x x x \\nx x x x <- T\\nx x x x <- B\\n```\\nWe want **all members of the B row between R and L inclusive**, since we already previously added the rightmost member. After adding this row, we **shift B up by one**.\\n- Lastly, scan from bottom to top. The pointers are as follows:\\n```\\nL   R\\n|   |\\nv   v\\nx x x x \\nx x x x <- T <- B\\nx x x x \\n```\\n\\nWe want **all members of the L column between T and B inclusive**. We then **move L right by one column** after adding.\\n- **Repeat these four steps**. Here are what the pointers look like over the next few iterations:\\n\\n```\\n  L R\\n  | |\\n  v v\\nx x x x \\nx x x x <- T <- B\\nx x x x \\n\\n  L R\\n  | |\\n  v v\\nx x x x \\nx x x x <- B\\nx x x x <- T\\n```\\n\\nAt this point, the top pointer is below the bottom pointer. This means we\\'ve spiraled through the whole matrix, there\\'s nothing left to examine, and we should stop repeating these steps. Note that we should be **checking before performing any one of these four steps that none of our pointers are overlapping** (i.e. L is bigger than R, or T is greater than B). In the code below, I check which direction we should be scanning by using **pattern matching**.\\n\\n# Final code solution:\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        l, r = 0, len(matrix[0]) - 1\\n        u, d = 0, len(matrix) - 1\\n        res = []\\n        step = 0\\n        while l <= r and u <= d:\\n            match (step % 4):\\n                case 0:\\n                    for i in range(l, r+1):\\n                        res.append(matrix[u][i])\\n                    u += 1\\n                case 1:\\n                    for i in range(u, d+1):\\n                        res.append(matrix[i][r])\\n                    r -= 1\\n                case 2:\\n                    for i in range(r, l-1, -1):\\n                        res.append(matrix[d][i])\\n                    d -= 1\\n                case 3:\\n                    for i in range(d, u-1, -1):\\n                        res.append(matrix[i][l])\\n                    l += 1\\n            step += 1\\n        return res\\n```\\n\\nI hope this was helpful! A +1 would be most appreciated if you liked my solution + explanation :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nL     R\\n|     |\\nv     v\\nx x x x <- T\\nx x x x\\nx x x x <- B\\n```\n```\\nL     R\\n|     |\\nv     v\\nx x x x \\nx x x x <- T\\nx x x x <- B\\n```\n```\\nL   R\\n|   |\\nv   v\\nx x x x \\nx x x x <- T\\nx x x x <- B\\n```\n```\\nL   R\\n|   |\\nv   v\\nx x x x \\nx x x x <- T <- B\\nx x x x \\n```\n```\\n  L R\\n  | |\\n  v v\\nx x x x \\nx x x x <- T <- B\\nx x x x \\n\\n  L R\\n  | |\\n  v v\\nx x x x \\nx x x x <- B\\nx x x x <- T\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        l, r = 0, len(matrix[0]) - 1\\n        u, d = 0, len(matrix) - 1\\n        res = []\\n        step = 0\\n        while l <= r and u <= d:\\n            match (step % 4):\\n                case 0:\\n                    for i in range(l, r+1):\\n                        res.append(matrix[u][i])\\n                    u += 1\\n                case 1:\\n                    for i in range(u, d+1):\\n                        res.append(matrix[i][r])\\n                    r -= 1\\n                case 2:\\n                    for i in range(r, l-1, -1):\\n                        res.append(matrix[d][i])\\n                    d -= 1\\n                case 3:\\n                    for i in range(d, u-1, -1):\\n                        res.append(matrix[i][l])\\n                    l += 1\\n            step += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20782,
                "title": "40-ms-python-solution-top-right-bottom-left-peeling-off-layers",
                "content": "    class Solution(object):\\n        def spiralOrder(self, matrix):\\n\\n            if matrix == []:\\n              return matrix\\n    \\n            l = 0\\n            r = len(matrix[0]) - 1\\n            t = 0\\n            b = len(matrix) - 1\\n    \\n            ret = []\\n            while l < r and t < b:\\n            \\t# top\\n            \\tfor i in range(l, r):\\n            \\t\\tret.append(matrix[t][i])\\n            \\t# right\\n            \\tfor i in range(t, b):\\n            \\t\\tret.append(matrix[i][r])\\n            \\t# bottom\\n            \\tfor i in range(r, l, -1):\\n            \\t\\tret.append(matrix[b][i])\\n            \\t# left\\n            \\tfor i in range(b, t, -1):\\n            \\t\\tret.append(matrix[i][l])\\n    \\n    \\t        l += 1\\n    \\t        r -= 1 \\n    \\t        t += 1\\n    \\t        b -= 1\\n    \\n    \\t    # single square\\n            if l == r and t == b:\\n            \\tret.append(matrix[t][l])\\n            # vertical line\\n           \\telif l == r:\\n           \\t\\tfor i in range(t, b + 1):\\n           \\t\\t\\tret.append(matrix[i][l])\\n           \\t# horizontal line\\n           \\telif t == b:\\n           \\t\\tfor i in range(l, r + 1):\\n           \\t\\t\\tret.append(matrix[t][i])\\n           \\treturn ret\\n\\nAny crits appreciated. Wondering about reducing the edge case checks at the end.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def spiralOrder(self, matrix):\\n\\n            if matrix == []:\\n              return matrix\\n    \\n            l = 0\\n            r = len(matrix[0]) - 1\\n            t = 0\\n            b = len(matrix) - 1\\n    \\n            ret = []\\n            while l < r and t < b:\\n            \\t# top\\n            \\tfor i in range(l, r):\\n            \\t\\tret.append(matrix[t][i])\\n            \\t# right\\n            \\tfor i in range(t, b):\\n            \\t\\tret.append(matrix[i][r])\\n            \\t# bottom\\n            \\tfor i in range(r, l, -1):\\n            \\t\\tret.append(matrix[b][i])\\n            \\t# left\\n            \\tfor i in range(b, t, -1):\\n            \\t\\tret.append(matrix[i][l])\\n    \\n    \\t        l += 1\\n    \\t        r -= 1 \\n    \\t        t += 1\\n    \\t        b -= 1\\n    \\n    \\t    # single square\\n            if l == r and t == b:\\n            \\tret.append(matrix[t][l])\\n            # vertical line\\n           \\telif l == r:\\n           \\t\\tfor i in range(t, b + 1):\\n           \\t\\t\\tret.append(matrix[i][l])\\n           \\t# horizontal line\\n           \\telif t == b:\\n           \\t\\tfor i in range(l, r + 1):\\n           \\t\\t\\tret.append(matrix[t][i])\\n           \\treturn ret\\n\\nAny crits appreciated. Wondering about reducing the edge case checks at the end.",
                "codeTag": "Java"
            },
            {
                "id": 3502674,
                "title": "c-java-optimal-solution-step-by-step-solution-beats-100-easy-to-understand",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nConsider the following 4x4 matrix as an example:\\n```\\n1  2  3  4\\n5  6  7  8\\n9  10 11 12\\n13 14 15 16\\n```\\nThe goal of the algorithm is to visit each element in the matrix in a clockwise spiral order, starting from the top-left corner and moving towards the center of the matrix.\\n\\nWe can visualize the spiral order traversal of the matrix as follows:\\n\\n```\\n1  2  3  4\\n5  6  7  8\\n9  10 11 12\\n13 14 15 16\\n```\\nIn the first step, we traverse the top row of the matrix from left to right:\\n```\\n1  2  3  4\\n   --------\\n```\\nIn the second step, we traverse the rightmost column of the matrix from top to bottom:\\n```\\n  |   3  4\\n  |   7  8\\n  |  11 12\\n1 |  15 16\\n  | \\n```\\nIn the third step, we traverse the bottom row of the matrix from right to left:\\n```\\n  |   3  4\\n  |   7  8\\n  |  11 12\\n1 |  15 16\\n  --------\\n```\\nIn the fourth step, we traverse the leftmost column of the matrix from bottom to top:\\n```\\n    2   3\\n    |   8\\n    |  12\\n1 --   16\\n    |\\n```\\nIn the fifth step, we traverse the second row of the matrix from left to right:\\n```\\n    2   3\\n    |   8\\n    |  12\\n---------   \\n1  5   6  7\\n```\\nIn the sixth step, we traverse the second-to-last column of the matrix from top to bottom:\\n```\\n    2 |  3\\n    | | 12\\n    | |   \\n---- | --   \\n1  5 | 6  7\\n    | |\\n```\\nIn the seventh step, we traverse the bottom row of the matrix from left to right:\\n\\n```\\n    2 |  3\\n    | | 12\\n---- | ----   \\n1  5  9 10 11\\n       |\\n```\\nIn the eighth step, we traverse the second-to-last column of the matrix from bottom to top:\\n```\\n    2 |    \\n---- | ----   \\n1  5 | 9 10 11\\n    | | 12\\n    | |\\n```\\nIn the ninth and final step, we traverse the third row of the matrix from right to left:\\n```\\n    --    \\n1  5  9  6 \\n    | |    \\n    | | 12 \\n    --    \\n```\\nAt this point, we have visited all the elements in the matrix in spiral order, and the traversal is complet\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# -----------------------------------------------------\\n# PLEASE UPVOTE IF IT HELPS YOU\\n# -----------------------------------------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int>ans;\\n        int row=matrix.size();\\n        int col =matrix[0].size();\\n        int count =0;\\n        int total =row*col;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=row-1;\\n        int endingcol=col-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                ans.push_back(matrix[startingrow][i]);\\n                count++;\\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n                ans.push_back(matrix[i][endingcol]);\\n                count++;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                ans.push_back(matrix[endingrow][i]);\\n                count++;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                ans.push_back(matrix[i][startingcol]);\\n                count++;\\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n# java code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<>();\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int count = 0;\\n        int total = m * n;\\n        int startingRow = 0;\\n        int endingRow = m - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count < total) {\\n            // Traverse top row from left to right\\n            for (int i = startingCol; count < total && i <= endingCol; i++) {\\n                ans.add(matrix[startingRow][i]);\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Traverse right column from top to bottom\\n            for (int i = startingRow; count < total && i <= endingRow; i++) {\\n                ans.add(matrix[i][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // Traverse bottom row from right to left\\n            for (int i = endingCol; count < total && i >= startingCol; i--) {\\n                ans.add(matrix[endingRow][i]);\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // Traverse left column from bottom to top\\n            for (int i = endingRow; count < total && i >= startingRow; i--) {\\n                ans.add(matrix[i][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n1  2  3  4\\n5  6  7  8\\n9  10 11 12\\n13 14 15 16\\n```\n```\\n1  2  3  4\\n5  6  7  8\\n9  10 11 12\\n13 14 15 16\\n```\n```\\n1  2  3  4\\n   --------\\n```\n```\\n  |   3  4\\n  |   7  8\\n  |  11 12\\n1 |  15 16\\n  | \\n```\n```\\n  |   3  4\\n  |   7  8\\n  |  11 12\\n1 |  15 16\\n  --------\\n```\n```\\n    2   3\\n    |   8\\n    |  12\\n1 --   16\\n    |\\n```\n```\\n    2   3\\n    |   8\\n    |  12\\n---------   \\n1  5   6  7\\n```\n```\\n    2 |  3\\n    | | 12\\n    | |   \\n---- | --   \\n1  5 | 6  7\\n    | |\\n```\n```\\n    2 |  3\\n    | | 12\\n---- | ----   \\n1  5  9 10 11\\n       |\\n```\n```\\n    2 |    \\n---- | ----   \\n1  5 | 9 10 11\\n    | | 12\\n    | |\\n```\n```\\n    --    \\n1  5  9  6 \\n    | |    \\n    | | 12 \\n    --    \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int>ans;\\n        int row=matrix.size();\\n        int col =matrix[0].size();\\n        int count =0;\\n        int total =row*col;\\n        \\n        //// all index \\n        \\n        int startingrow=0;\\n        int startingcol=0;\\n        int endingrow=row-1;\\n        int endingcol=col-1;\\n        \\n        while(count<total)\\n        {\\n            for(int i=startingcol;count<total && i<=endingcol; i++)\\n            {\\n                ans.push_back(matrix[startingrow][i]);\\n                count++;\\n            }\\n            startingrow++;\\n            \\n            for(int i=startingrow;count<total && i<=endingrow; i++)\\n            {\\n                ans.push_back(matrix[i][endingcol]);\\n                count++;\\n            }\\n            endingcol--;\\n            \\n            for(int i=endingcol;count<total && i>=startingcol; i--)\\n            {\\n                ans.push_back(matrix[endingrow][i]);\\n                count++;\\n            }\\n            endingrow--;\\n            \\n            for(int i=endingrow;count<total && i>=startingrow; i--)\\n            {\\n                ans.push_back(matrix[i][startingcol]);\\n                count++;\\n            }\\n            startingcol++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<>();\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int count = 0;\\n        int total = m * n;\\n        int startingRow = 0;\\n        int endingRow = m - 1;\\n        int startingCol = 0;\\n        int endingCol = n - 1;\\n        \\n        while (count < total) {\\n            // Traverse top row from left to right\\n            for (int i = startingCol; count < total && i <= endingCol; i++) {\\n                ans.add(matrix[startingRow][i]);\\n                count++;\\n            }\\n            startingRow++;\\n            \\n            // Traverse right column from top to bottom\\n            for (int i = startingRow; count < total && i <= endingRow; i++) {\\n                ans.add(matrix[i][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n            \\n            // Traverse bottom row from right to left\\n            for (int i = endingCol; count < total && i >= startingCol; i--) {\\n                ans.add(matrix[endingRow][i]);\\n                count++;\\n            }\\n            endingRow--;\\n            \\n            // Traverse left column from bottom to top\\n            for (int i = endingRow; count < total && i >= startingRow; i--) {\\n                ans.add(matrix[i][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20606,
                "title": "very-easy-to-understand-python-solution",
                "content": "    def spiralOrder(self, matrix):\\n        res = []\\n        if not matrix:\\n            return []\\n        i,j,di,dj = 0,0,0,1\\n        m, n = len(matrix),len(matrix[0])\\n        for v in xrange(m * n):\\n            res.append(matrix[i][j])\\n            matrix[i][j] = ''\\n            if matrix[(i+di)%m][(j+dj)%n] == '':\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def spiralOrder(self, matrix):\\n        res = []\\n        if not matrix:\\n            return []\\n        i,j,di,dj = 0,0,0,1\\n        m, n = len(matrix),len(matrix[0])\\n        for v in xrange(m * n):\\n            res.append(matrix[i][j])\\n            matrix[i][j] = ''\\n            if matrix[(i+di)%m][(j+dj)%n] == '':\\n                di, dj = dj, -di\\n            i += di\\n            j += dj\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1511476,
                "title": "java-tc-o-m-n-sc-o-1-optimized-solution-using-switch-case",
                "content": "**Using Switch-Case**\\n\\n```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(M*N). Every element is visited once.\\n *\\n * Space Complexity: O(1) excluding the result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Right\\n                    for (int i = left; i <= right; i++) {\\n                        result.add(matrix[top][i]);\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result.add(matrix[i][right]);\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Left\\n                    for (int i = right; i >= left; i--) {\\n                        result.add(matrix[bottom][i]);\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Top\\n                    for (int i = bottom; i >= top; i--) {\\n                        result.add(matrix[i][left]);\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Without using Switch-Case**\\n\\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(M*N). Every element is visited once.\\n *\\n * Space Complexity: O(1) excluding the result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Spiral Matrix question on LeetCode:\\n- [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/discuss/1511479/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Multiple-optimized-ways-to-solve-this-question)\\n- [885. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/discuss/1511489/Java-or-TC:-O(max(R-C)2)-or-SC:-O(1)-or-Simulating-a-Spiral-Walk)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```java\\n/**\\n * Using Switch-Case: Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(M*N). Every element is visited once.\\n *\\n * Space Complexity: O(1) excluding the result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n        int dir = 0;\\n\\n        while (top <= bottom && left <= right) {\\n            switch (dir) {\\n                case 0: // Right\\n                    for (int i = left; i <= right; i++) {\\n                        result.add(matrix[top][i]);\\n                    }\\n                    top++;\\n                    break;\\n                case 1: // Down\\n                    for (int i = top; i <= bottom; i++) {\\n                        result.add(matrix[i][right]);\\n                    }\\n                    right--;\\n                    break;\\n                case 2: // Left\\n                    for (int i = right; i >= left; i--) {\\n                        result.add(matrix[bottom][i]);\\n                    }\\n                    bottom--;\\n                    break;\\n                case 3: // Top\\n                    for (int i = bottom; i >= top; i--) {\\n                        result.add(matrix[i][left]);\\n                    }\\n                    left++;\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Traverse Right -> Down -> Left -> Up\\n *\\n * Time Complexity: O(M*N). Every element is visited once.\\n *\\n * Space Complexity: O(1) excluding the result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return result;\\n        }\\n\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n\\n        while (top <= bottom && left <= right) {\\n            for (int i = left; i <= right; i++) {\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            for (int i = top; i <= bottom; i++) {\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            if (top <= bottom) {\\n                for (int i = right; i >= left; i--) {\\n                    result.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20778,
                "title": "0ms-c-solution-take-turns-to-move-in-4-directions",
                "content": "    class Solution {\\n    public:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector <int> res;        \\n        int rowSize = matrix.size();\\n        if (rowSize==0) return res;\\n        int colSize = matrix[0].size();\\n        int lb=0,rb=colSize-1,ub=0,db=rowSize-1;// left bound, right bound, up bound, down bound;\\n        int direction = 0;\\n        int col=0,row=0;\\n        while (lb<=rb && ub<=db){\\n            res.push_back(matrix[row][col]);\\n            switch (direction){\\n                case 0:  //  right\\n                    if (col>=rb) {direction = 1;row=row+1;ub++;} else col=col+1;\\n                    break;\\n                case 1: // down\\n                    if (row>=db) {direction = 2;col=col-1;rb--;} else row=row+1;\\n                    break;\\n                case 2: // left\\n                    if (col<=lb) {direction = 3;row=row-1;db--;} else col=col-1;\\n                    break;\\n                default:  // up\\n                    if (row<=ub) {direction = 0;col=col+1;lb++;} else row=row-1;\\n            }\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector <int> res;        \\n        int rowSize = matrix.size();\\n        if (rowSize==0) return res;\\n        int colSize = matrix[0].size();\\n        int lb=0,rb=colSize-1,ub=0,db=rowSize-1;// left bound, right bound, up bound, down bound;\\n        int direction = 0;\\n        int col=0,row=0;\\n        while (lb<=rb && ub<=db){\\n            res.push_back(matrix[row][col]);\\n            switch (direction){\\n                case 0:  //  right\\n                    if (col>=rb) {direction = 1;row=row+1;ub++;}",
                "codeTag": "Java"
            },
            {
                "id": 1333700,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int left = 0;\\n        int right = matrix[0].size()-1;\\n        int top = 0;\\n        int bottom = matrix.size()-1;\\n        vector<int> res;\\n        int i;\\n        while(left <= right and top <= bottom) {\\n            // traverse from left to right in the top row\\n            for(i = left; i <= right; i++) {\\n                res.push_back(matrix[top][i]);\\n            }\\n            // now that top row is done,decrement the top pointer\\n            top++;\\n            // traverse from top to bottom in the rightmost column\\n            for(i = top; i <= bottom; i++) {\\n                res.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            if(left > right || top > bottom) break;\\n            // traverse from right to left in the bottom row\\n            for(i = right; i >= left; i--) {\\n                res.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            // // traverse from bottom to top in the left most column\\n            for(i=bottom; i >= top; i--) {\\n                res.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int left = 0;\\n        int right = matrix[0].size()-1;\\n        int top = 0;\\n        int bottom = matrix.size()-1;\\n        vector<int> res;\\n        int i;\\n        while(left <= right and top <= bottom) {\\n            // traverse from left to right in the top row\\n            for(i = left; i <= right; i++) {\\n                res.push_back(matrix[top][i]);\\n            }\\n            // now that top row is done,decrement the top pointer\\n            top++;\\n            // traverse from top to bottom in the rightmost column\\n            for(i = top; i <= bottom; i++) {\\n                res.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            if(left > right || top > bottom) break;\\n            // traverse from right to left in the bottom row\\n            for(i = right; i >= left; i--) {\\n                res.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            // // traverse from bottom to top in the left most column\\n            for(i=bottom; i >= top; i--) {\\n                res.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20821,
                "title": "an-iterative-python-solution",
                "content": "The idea is to peel the the matrix layer by layer.\\n\\n    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @return a list of integers\\n        # 9:27\\n        def spiralOrder(self, matrix):\\n            result = []\\n            \\n            while matrix and matrix[0]:\\n                if matrix[0]:\\n                    result += matrix.pop(0)\\n                \\n                if matrix and matrix[0]:\\n                    for row in matrix:\\n                        result.append(row.pop())\\n                \\n                if matrix and matrix[-1]:\\n                    result += matrix.pop()[::-1]\\n    \\n                if matrix and matrix[0]:\\n                    for row in matrix[::-1]:\\n                        result.append(row.pop(0))\\n            \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is to peel the the matrix layer by layer.\\n\\n    class Solution:\\n        # @param matrix, a list of lists of integers\\n        # @return a list of integers\\n        # 9:27\\n        def spiralOrder(self, matrix):\\n            result = []\\n            \\n            while matrix and matrix[0]:\\n                if matrix[0]:\\n                    result += matrix.pop(0)\\n                \\n                if matrix and matrix[0]:\\n                    for row in matrix:\\n                        result.append(row.pop())\\n                \\n                if matrix and matrix[-1]:\\n                    result += matrix.pop()[::-1]\\n    \\n                if matrix and matrix[0]:\\n                    for row in matrix[::-1]:\\n                        result.append(row.pop(0))\\n            \\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 2689004,
                "title": "simple-4-pointers-time-complexity-space-complexity-explanation",
                "content": "Time Complexity - Time taken to cover row * column elements is O(row * column) = O(N).\\nSpace Complexity - Since we do not use any extra space, space taken is O(1).\\nExplanation - We fix four pointers - left, right, top, bottom which we use to traverse the matrix.\\nAfter moving in one direction, we change our direction to traverse cyclically.\\nOn traversing the top row, we increment top. On traversing the right row, we decrement right.\\nOn traversing the bottom row, we decrement bottom. On traversing the left row, we increment left.\\ndirection 1 - left to right\\ndirection 2 - top to bottom\\ndirection 3 - right to left\\ndirection 4 - bottom to top\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix){\\n        int row = matrix.size(), col = matrix[0].size(), left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size() - 1, direction = 1;\\n        vector<int> order;\\n        \\n        while(order.size() < row * col)\\n        {\\n            switch(direction){\\n                case 1:\\n                    for(int i = left; i <= right; i++) order.push_back(matrix[top][i]);\\n                    direction = 2;\\n                    top++;\\n                    break;\\n                    \\n                case 2:\\n                    for(int i = top; i <= bottom; i++) order.push_back(matrix[i][right]);\\n                    direction = 3;\\n                    right--;\\n                    break;\\n                    \\n                case 3:\\n                    for(int i = right;i >= left; i--) order.push_back(matrix[bottom][i]);\\n                    direction = 4;\\n                    bottom--;\\n                    break;\\n                    \\n                case 4:\\n                    for(int i = bottom; i >= top; i--) order.push_back(matrix[i][left]);\\n                    direction = 1;\\n                    left++;\\n                    break;\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix){\\n        int row = matrix.size(), col = matrix[0].size(), left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size() - 1, direction = 1;\\n        vector<int> order;\\n        \\n        while(order.size() < row * col)\\n        {\\n            switch(direction){\\n                case 1:\\n                    for(int i = left; i <= right; i++) order.push_back(matrix[top][i]);\\n                    direction = 2;\\n                    top++;\\n                    break;\\n                    \\n                case 2:\\n                    for(int i = top; i <= bottom; i++) order.push_back(matrix[i][right]);\\n                    direction = 3;\\n                    right--;\\n                    break;\\n                    \\n                case 3:\\n                    for(int i = right;i >= left; i--) order.push_back(matrix[bottom][i]);\\n                    direction = 4;\\n                    bottom--;\\n                    break;\\n                    \\n                case 4:\\n                    for(int i = bottom; i >= top; i--) order.push_back(matrix[i][left]);\\n                    direction = 1;\\n                    left++;\\n                    break;\\n            }\\n        }\\n        return order;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20773,
                "title": "elegant-and-fast-java-solution-240ms",
                "content": "        public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> spiralList = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0) return spiralList;\\n        \\n        // declare indices\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n        \\n        while(true){\\n            // 1. print top row\\n            for(int j=left; j <=right;j++){\\n                spiralList.add(matrix[top][j]);\\n            }\\n            top++;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;\\n            \\n            // 2. print rightmost column\\n            for(int i=top; i <= bottom; i++){\\n                spiralList.add(matrix[i][right]);\\n            }\\n            right--;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;\\n                \\n            // 3. print bottom row\\n            for(int j=right; j >=left; j--){\\n                spiralList.add(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;    \\n                \\n            // 4. print leftmost column\\n            for(int i=bottom; i >= top; i--){\\n                spiralList.add(matrix[i][left]);\\n            }\\n            left++;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;    \\n        }// end while true\\n        \\n        return spiralList;\\n    }\\n    \\n    private boolean boundriesCrossed(int left,int right,int bottom,int top){\\n        if(left>right || bottom<top)\\n            return true;\\n        else\\n            return false;\\n    }",
                "solutionTags": [],
                "code": "        public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> spiralList = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0) return spiralList;\\n        \\n        // declare indices\\n        int top = 0;\\n        int bottom = matrix.length - 1;\\n        int left = 0;\\n        int right = matrix[0].length - 1;\\n        \\n        while(true){\\n            // 1. print top row\\n            for(int j=left; j <=right;j++){\\n                spiralList.add(matrix[top][j]);\\n            }\\n            top++;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;\\n            \\n            // 2. print rightmost column\\n            for(int i=top; i <= bottom; i++){\\n                spiralList.add(matrix[i][right]);\\n            }\\n            right--;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;\\n                \\n            // 3. print bottom row\\n            for(int j=right; j >=left; j--){\\n                spiralList.add(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;    \\n                \\n            // 4. print leftmost column\\n            for(int i=bottom; i >= top; i--){\\n                spiralList.add(matrix[i][left]);\\n            }\\n            left++;\\n            if(boundriesCrossed(left,right,bottom,top))\\n                break;    \\n        }// end while true\\n        \\n        return spiralList;\\n    }\\n    \\n    private boolean boundriesCrossed(int left,int right,int bottom,int top){\\n        if(left>right || bottom<top)\\n            return true;\\n        else\\n            return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1721823,
                "title": "python-dfs-recursion-faster-than-90",
                "content": "This is a simple python recursive code. We use the helper function to recurse through the matrix and append the elements onto the matrix.\\n\\nThe helper has one base conditions - If the row or columns are outside the boundary, or if value = \\'#\\'\\n\\nThen we append the element onto the matrix and set the matrix value to #. We do this to avoid revisiting the nodes.\\n\\nThe if statement controls when the cursor needs to start going right. Else it will recurse in the wrong direction as shown in the image below.\\n\\nFinally, the four recursive statements basically goes all the way right, all the way down, all the way left and all the way up. Given that we are at (row, col), where row is the row index, and col is the column index.\\n\\tmove right: (row, col + 1)\\n\\tmove downwards: (row + 1, col)\\n\\tmove left: (row, col - 1)\\n\\tmove upwards: (row - 1, col)\\n\\n![image](https://assets.leetcode.com/users/images/c41afd0f-2473-4269-9319-4f56c84713af_1643212545.6249688.jpeg)\\n\\nPS: Please go easy on me, I just started problem solving coding a month back. I might be inefficient.\\n\\n\\n```\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = [] \\n        self.helper(matrix,0,0,res)\\n        return res\\n        \\n        \\n    def helper(self,matrix,i,j,res):\\n        if i < 0 or i >= len(matrix) or j < 0 or j>=len(matrix[0]) or matrix[i][j] == \\'#\\':  return\\n        \\n        res.append(matrix[i][j])\\n        matrix[i][j] = \\'#\\'\\n        \\n        #are we going up? - yes? then go till one value greater than i\\n\\t\\t#example -> when we are in the outer boundary of the matrix, i = 0\\n\\t\\t# so go up (use this loop to increment j) until we reach (0,1) or (i, i+1)\\n        if j+1>=i:\\n            self.helper(matrix,i,j+1,res)\\n        self.helper(matrix,i+1,j,res)\\n        self.helper(matrix,i,j-1,res)\\n        self.helper(matrix,i-1,j,res)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "This is a simple python recursive code. We use the helper function to recurse through the matrix and append the elements onto the matrix.\\n\\nThe helper has one base conditions - If the row or columns are outside the boundary, or if value = \\'#\\'\\n\\nThen we append the element onto the matrix and set the matrix value to #. We do this to avoid revisiting the nodes.\\n\\nThe if statement controls when the cursor needs to start going right. Else it will recurse in the wrong direction as shown in the image below.\\n\\nFinally, the four recursive statements basically goes all the way right, all the way down, all the way left and all the way up. Given that we are at (row, col), where row is the row index, and col is the column index.\\n\\tmove right: (row, col + 1)\\n\\tmove downwards: (row + 1, col)\\n\\tmove left: (row, col - 1)\\n\\tmove upwards: (row - 1, col)\\n\\n![image](https://assets.leetcode.com/users/images/c41afd0f-2473-4269-9319-4f56c84713af_1643212545.6249688.jpeg)\\n\\nPS: Please go easy on me, I just started problem solving coding a month back. I might be inefficient.\\n\\n\\n```\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = [] \\n        self.helper(matrix,0,0,res)\\n        return res\\n        \\n        \\n    def helper(self,matrix,i,j,res):\\n        if i < 0 or i >= len(matrix) or j < 0 or j>=len(matrix[0]) or matrix[i][j] == \\'#\\':  return\\n        \\n        res.append(matrix[i][j])\\n        matrix[i][j] = \\'#\\'\\n        \\n        #are we going up? - yes? then go till one value greater than i\\n\\t\\t#example -> when we are in the outer boundary of the matrix, i = 0\\n\\t\\t# so go up (use this loop to increment j) until we reach (0,1) or (i, i+1)\\n        if j+1>=i:\\n            self.helper(matrix,i,j+1,res)\\n        self.helper(matrix,i+1,j,res)\\n        self.helper(matrix,i,j-1,res)\\n        self.helper(matrix,i-1,j,res)",
                "codeTag": "Python3"
            },
            {
                "id": 3438545,
                "title": "the-most-difficult-solution",
                "content": "# Approach\\nThis is an obfuscated recursive solution, the essence of the challenge was not to use letters and numbers when solving.I spent about 2 hours to solve the problem.\\n> Not all of the code written is required to complete the task, I forgot to remove the capital letters.\\n\\n# Complexity\\n- Time complexity:\\n> Beats ~35% of users in execution speed\\n\\n- Space complexity:\\n> This is very strange, but in terms of memory costs, this solution is better than the solutions of ~93% of users.\\n\\n# Code\\n```\\n_=[\\n    (![]+[])[-~[]],\\n    ({}+[])[-~[]+-~[]],\\n    ({}+[])[-~[]<<-~[]<<-~[]|-~[]],\\n    ([][[]]+[])[-~[]<<-~[]],\\n    ([][[]]+[])[-~[]<<-~[]|-~[]],\\n    (![]+[])[+[]],,,\\n    (-~[]/+[]+[])[-~[]<<-~[]|-~[]],\\n    ({}+[])[-~[]<<-~[]|-~[]],,\\n    (![]+[])[-~[]+-~[]],,\\n    ([][[]]+[])[-~[]],\\n    ({}+[])[-~[]],,,\\n    (!![]+[])[-~[]],\\n    (![]+[])[-~[]<<-~[]|-~[]],\\n    (!![]+[])[+[]],\\n    ([][[]]+[])[+[]],,,,\\n    (-~[]/+[]+[])[(-~[]<<-~[]<<-~[]<<-~[])+~[]]\\n];\\n\\n$_= _[-~[]+-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+-~[]+[]+ +[]]+\\n    _[-~[]+-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]];\\n\\n_[-~[]+-~[]+[]+(-~[])] = (\"\"[$_]+[])[-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])];\\n\\n_[-~[]+[]+(-~[]+-~[])] = ((+[])[$_]+[])[-~[]+[]+-~[]];\\n\\n_$= _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n    _[+[]]+\\n    _[-~[]+[]+(-~[]+-~[])]+\\n    _[-~[]<<-~[]<<-~[]];\\n\\n\\n_[(-~[]<<-~[]<<-~[])+(-~[]+-~[])] = / /[$_][_$][-~[]+-~[]];\\n_[-~[]+-~[]+[]+(-~[]<<-~[]|-~[])] = / /[$_][_$][-~[]<<-~[]<<-~[]];\\n_[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])] = / /[$_][_$][-~[]<<-~[]<<-~[]|-~[]];\\n\\n_[(-~[]<<-~[]<<-~[]<<-~[])+~[]] = (-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[])\\n                                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                  (-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]));\\n\\n_[-~[]<<-~[]<<-~[]<<-~[]<<-~[]] = (+(-~[]+-~[]+[]+((-~[]<<-~[]<<-~[])+(-~[]+-~[]))))\\n                                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                  (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]);\\n\\n_[-~[]+-~[]+[]+(-~[]+-~[])] = (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[])\\n                              [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                              (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]);\\n         \\n_[-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])] = (+(-~[]+-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])))\\n                                          [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                          (+(-~[]+-~[]+-~[]+[]+((-~[]<<-~[]<<-~[])+(-~[]+-~[]))));\\n\\n_[-~[]+[]+ +[]] = (+(-~[]+-~[]+[]+(+[])))\\n                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                  (+(-~[]+-~[]+[]+(-~[])));\\n\\n[][$_][$_](\"_$_=_=>\"+\\n    _[-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[+[]]+\"(_)\"\\n)();\\n\\n[][$_][$_](\"$__=_=>\"+/ /[$_][_$]+\"(\\\\\"[^\"+[][$_][_$][+[]]+\"-\"+_$_(_[-~[]+-~[]+-~[]])[+[]]+\"]+\\\\\",\\\\\"\"+_[(-~[]<<-~[]<<-~[])+(-~[]+-~[])]+\"\\\\\")\")();\\n\\n[][$_][$_](\"__$=($_,_$)=>$_+_$_(_$+_$+_$)\")();\\n\\n__$ = [\\n        _[+[]],\\n        _[-~[]],\\n        _[-~[]+-~[]],\\n        _[-~[]+-~[]+-~[]],\\n        _[-~[]<<-~[]<<-~[]],\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])],\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]],\\n        -~[]+[],\\n        (-~[]+-~[])+[],\\n        (-~[]<<-~[]<<-~[])+[],\\n        (-~[]<<-~[]<<-~[]|-~[])+[],\\n        (-~[]<<-~[]<<-~[]<<-~[])+[],\\n        \".\",\"+\",\"-\",\"(\",\"?\"\\n    ][\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+-~[]]+\\n        _[-~[]+-~[]+[]+ +[]]+\\n        _[-~[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]\\n    ](__$,\"\");\\n\\n__$=__$[\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]+[]+-~[]]+\\n        _[+[]]+\\n        _[-~[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]\\n    ]($__(),\"\");\\n\\n[][$_][$_](\"$__=_=>\"+\\n    [][$_][_$]+\"[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n        _[-~[]+[]+(-~[]+-~[])]\\n    +\"\\\\\"](\"+\\n        _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+[]+(-~[]+-~[])]+\" \"+\\n        \"\"[$_][_$][+[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\"(\\\\\"\"+\\n        __$+[][$_][_$][+[]]\\n    +\"\\\\\"))[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]\\n    +\"\\\\\"]()\"\\n)();\\n\\n__ = $__();\\n\\n[][$_][$_](\"_$_=_=>_[\\\\\"\"+ \\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]+-~[]+[]+(-~[])]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]<<-~[]<<-~[]]+\\n\"\\\\\"]()\")();\\n\\n[][$_][$_](\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[+[]]+\\n    _[-~[]+[]+-~[]]+\\n    {}[$_][_$][+[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+-~[]+-~[]]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    \"=_=($_,_$=[])=>$_[\\\\\"\"+\\n        _[-~[]+[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n        _[(-~[]<<-~[]<<-~[])+(-~[]+-~[])]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n    \"\\\\\"]?(_$[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]+-~[]+[]+ +[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n    \"\\\\\"](...$_[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"]()),$_[\\\\\"\"+\\n        _[-~[]+[]+(-~[]+-~[])]+\\n        _[+[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"](\"+\\n        \"$__$=_=>_$[\\\\\"\"+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n            _[-~[]+-~[]+[]+ +[]]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n            _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n        \"\\\\\"](_[\\\\\"\"+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        \"\\\\\"]())\"\\n    +\"),$_[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+[]+(-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n    \"\\\\\"]()[\\\\\"\"+\\n        _[-~[]+[]+(-~[]+-~[])]+\\n        _[+[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"](_$_), _($_,_$)): _$[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\"\\\\\"]((_)=>_!==\"+[][[]]+\")\"\\n)()\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n_=[\\n    (![]+[])[-~[]],\\n    ({}+[])[-~[]+-~[]],\\n    ({}+[])[-~[]<<-~[]<<-~[]|-~[]],\\n    ([][[]]+[])[-~[]<<-~[]],\\n    ([][[]]+[])[-~[]<<-~[]|-~[]],\\n    (![]+[])[+[]],,,\\n    (-~[]/+[]+[])[-~[]<<-~[]|-~[]],\\n    ({}+[])[-~[]<<-~[]|-~[]],,\\n    (![]+[])[-~[]+-~[]],,\\n    ([][[]]+[])[-~[]],\\n    ({}+[])[-~[]],,,\\n    (!![]+[])[-~[]],\\n    (![]+[])[-~[]<<-~[]|-~[]],\\n    (!![]+[])[+[]],\\n    ([][[]]+[])[+[]],,,,\\n    (-~[]/+[]+[])[(-~[]<<-~[]<<-~[]<<-~[])+~[]]\\n];\\n\\n$_= _[-~[]+-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+-~[]+[]+ +[]]+\\n    _[-~[]+-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]];\\n\\n_[-~[]+-~[]+[]+(-~[])] = (\"\"[$_]+[])[-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])];\\n\\n_[-~[]+[]+(-~[]+-~[])] = ((+[])[$_]+[])[-~[]+[]+-~[]];\\n\\n_$= _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n    _[+[]]+\\n    _[-~[]+[]+(-~[]+-~[])]+\\n    _[-~[]<<-~[]<<-~[]];\\n\\n\\n_[(-~[]<<-~[]<<-~[])+(-~[]+-~[])] = / /[$_][_$][-~[]+-~[]];\\n_[-~[]+-~[]+[]+(-~[]<<-~[]|-~[])] = / /[$_][_$][-~[]<<-~[]<<-~[]];\\n_[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])] = / /[$_][_$][-~[]<<-~[]<<-~[]|-~[]];\\n\\n_[(-~[]<<-~[]<<-~[]<<-~[])+~[]] = (-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[])\\n                                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                  (-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]));\\n\\n_[-~[]<<-~[]<<-~[]<<-~[]<<-~[]] = (+(-~[]+-~[]+[]+((-~[]<<-~[]<<-~[])+(-~[]+-~[]))))\\n                                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                  (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]);\\n\\n_[-~[]+-~[]+[]+(-~[]+-~[])] = (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[])\\n                              [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                              (-~[]<<-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]);\\n         \\n_[-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])] = (+(-~[]+-~[]+-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])))\\n                                          [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                                          (+(-~[]+-~[]+-~[]+[]+((-~[]<<-~[]<<-~[])+(-~[]+-~[]))));\\n\\n_[-~[]+[]+ +[]] = (+(-~[]+-~[]+[]+(+[])))\\n                  [_[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+_[-~[]+[]+(-~[]<<-~[]<<-~[])]+\"\"[$_][_$]]\\n                  (+(-~[]+-~[]+[]+(-~[])));\\n\\n[][$_][$_](\"_$_=_=>\"+\\n    _[-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n    _[+[]]+\"(_)\"\\n)();\\n\\n[][$_][$_](\"$__=_=>\"+/ /[$_][_$]+\"(\\\\\"[^\"+[][$_][_$][+[]]+\"-\"+_$_(_[-~[]+-~[]+-~[]])[+[]]+\"]+\\\\\",\\\\\"\"+_[(-~[]<<-~[]<<-~[])+(-~[]+-~[])]+\"\\\\\")\")();\\n\\n[][$_][$_](\"__$=($_,_$)=>$_+_$_(_$+_$+_$)\")();\\n\\n__$ = [\\n        _[+[]],\\n        _[-~[]],\\n        _[-~[]+-~[]],\\n        _[-~[]+-~[]+-~[]],\\n        _[-~[]<<-~[]<<-~[]],\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])],\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]],\\n        -~[]+[],\\n        (-~[]+-~[])+[],\\n        (-~[]<<-~[]<<-~[])+[],\\n        (-~[]<<-~[]<<-~[]|-~[])+[],\\n        (-~[]<<-~[]<<-~[]<<-~[])+[],\\n        \".\",\"+\",\"-\",\"(\",\"?\"\\n    ][\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+-~[]]+\\n        _[-~[]+-~[]+[]+ +[]]+\\n        _[-~[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]\\n    ](__$,\"\");\\n\\n__$=__$[\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]+[]+-~[]]+\\n        _[+[]]+\\n        _[-~[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]\\n    ]($__(),\"\");\\n\\n[][$_][$_](\"$__=_=>\"+\\n    [][$_][_$]+\"[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n        _[-~[]+[]+(-~[]+-~[])]\\n    +\"\\\\\"](\"+\\n        _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+[]+(-~[]+-~[])]+\" \"+\\n        \"\"[$_][_$][+[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\"(\\\\\"\"+\\n        __$+[][$_][_$][+[]]\\n    +\"\\\\\"))[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]\\n    +\"\\\\\"]()\"\\n)();\\n\\n__ = $__();\\n\\n[][$_][$_](\"_$_=_=>_[\\\\\"\"+ \\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]+-~[]+[]+(-~[])]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]<<-~[]<<-~[]]+\\n\"\\\\\"]()\")();\\n\\n[][$_][$_](\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n    _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[+[]]+\\n    _[-~[]+[]+-~[]]+\\n    {}[$_][_$][+[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    _[-~[]+-~[]+-~[]]+\\n    _[-~[]<<-~[]<<-~[]]+\\n    _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n    \"=_=($_,_$=[])=>$_[\\\\\"\"+\\n        _[-~[]+[]+-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+(-~[]+-~[]+-~[])]+\\n        _[(-~[]<<-~[]<<-~[])+(-~[]+-~[])]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n    \"\\\\\"]?(_$[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]+-~[]+[]+ +[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n    \"\\\\\"](...$_[\\\\\"\"+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"]()),$_[\\\\\"\"+\\n        _[-~[]+[]+(-~[]+-~[])]+\\n        _[+[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"](\"+\\n        \"$__$=_=>_$[\\\\\"\"+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n            _[-~[]+-~[]+[]+ +[]]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n            _[(-~[]<<-~[]<<-~[]<<-~[])+~[]]+\\n        \"\\\\\"](_[\\\\\"\"+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[])]+\\n            _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n        \"\\\\\"]())\"\\n    +\"),$_[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]+-~[]+[]+(-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n    \"\\\\\"]()[\\\\\"\"+\\n        _[-~[]+[]+(-~[]+-~[])]+\\n        _[+[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]|-~[])]+\\n    \"\\\\\"](_$_), _($_,_$)): _$[\\\\\"\"+\\n        _[-~[]<<-~[]<<-~[]|-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]]+\\n        _[-~[]+[]+-~[]]+\\n        _[-~[]+[]+(-~[]<<-~[]<<-~[]<<-~[]|-~[])]+\\n        _[-~[]<<-~[]<<-~[]]+\\n        _[-~[]<<-~[]<<-~[]<<-~[]<<-~[]|-~[]]+\"\\\\\"]((_)=>_!==\"+[][[]]+\")\"\\n)()\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 716854,
                "title": "c-best-solution-easy-and-short-logic-100-3",
                "content": "```\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n        cout.tie(NULL); \\n         vector<int>ret;\\n        int m=matrix.size();   \\n          if(m==0)\\n            return ret;\\n        int n=matrix[0].size();  \\n        vector<int>res(m*n);  \\n        int r=0,c=0,cnt=0; \\n        while(r<m && c<n)\\n        {\\n            for(int i=c;i<n;i++)\\n                res[cnt++]=matrix[r][i];\\n            r++;\\n            for(int j=r;j<m;j++)\\n                res[cnt++]=matrix[j][n-1]; \\n            n--; \\n            if(r<m)\\n            {\\n                for(int i=n-1;i>=c;i--)\\n                    res[cnt++]=matrix[m-1][i];\\n                m--; \\n            }\\n              if(c<n)\\n              {\\n                  for(int j=m-1;j>=r;j--)\\n                      res[cnt++]=matrix[j][c]; \\n                  c++;\\n              }\\n        } \\n        return res;\\n    } \\n\\t``` \\n\\tIf you like my solution please Upvote.Jai Hind.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n        cout.tie(NULL); \\n         vector<int>ret;\\n        int m=matrix.size();   \\n          if(m==0)\\n            return ret;\\n        int n=matrix[0].size();  \\n        vector<int>res(m*n);  \\n        int r=0,c=0,cnt=0; \\n        while(r<m && c<n)\\n        {\\n            for(int i=c;i<n;i++)\\n                res[cnt++]=matrix[r][i];\\n            r++;\\n            for(int j=r;j<m;j++)\\n                res[cnt++]=matrix[j][n-1]; \\n            n--; \\n            if(r<m)\\n            {\\n                for(int i=n-1;i>=c;i--)\\n                    res[cnt++]=matrix[m-1][i];\\n                m--; \\n            }\\n              if(c<n)\\n              {\\n                  for(int j=m-1;j>=r;j--)\\n                      res[cnt++]=matrix[j][c]; \\n                  c++;\\n              }\\n        } \\n        return res;\\n    } \\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 517536,
                "title": "simple-java-dfs-solution",
                "content": "```\\nclass Solution {\\n    boolean[][] visited;\\n    List<Integer> res;\\n    \\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0) return new ArrayList<>();\\n        \\n        visited = new boolean[matrix.length][matrix[0].length];\\n        res = new ArrayList<>();\\n        dfs(0, 0, matrix, false);\\n        return res;\\n    }\\n    \\n    public void dfs(int y, int x, int[][] matrix, boolean goingUp) {\\n        if(y < 0 || y >= matrix.length || x < 0 || x >= matrix[y].length || visited[y][x]) return;\\n        res.add(matrix[y][x]);\\n        visited[y][x] = true;\\n        \\n        if(goingUp) {\\n            dfs(y - 1, x, matrix, true);\\n        }\\n        \\n        dfs(y, x + 1, matrix, false);\\n        dfs(y + 1, x, matrix, false);\\n        dfs(y, x - 1, matrix, false);\\n        dfs(y - 1, x, matrix, true);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][] visited;\\n    List<Integer> res;\\n    \\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0) return new ArrayList<>();\\n        \\n        visited = new boolean[matrix.length][matrix[0].length];\\n        res = new ArrayList<>();\\n        dfs(0, 0, matrix, false);\\n        return res;\\n    }\\n    \\n    public void dfs(int y, int x, int[][] matrix, boolean goingUp) {\\n        if(y < 0 || y >= matrix.length || x < 0 || x >= matrix[y].length || visited[y][x]) return;\\n        res.add(matrix[y][x]);\\n        visited[y][x] = true;\\n        \\n        if(goingUp) {\\n            dfs(y - 1, x, matrix, true);\\n        }\\n        \\n        dfs(y, x + 1, matrix, false);\\n        dfs(y + 1, x, matrix, false);\\n        dfs(y, x - 1, matrix, false);\\n        dfs(y - 1, x, matrix, true);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502927,
                "title": "c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn",
                "content": "> Note: These solutions are different from other brute force with 4 for loops. I have tried to do it in single for loop without modifying the input marking visited. Follow the images to understand.\\n\\n# Intuition\\n\\n## Hint 1\\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\\nIt\\'s all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\\n\\n## Hint 2\\n![image.png](https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png)\\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\\n\\n## Hint 3\\nLet $[r,c]$ be the current cell and the next cell is given as $[r\\',c\\'] = [r + dr, c + dc]$.\\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\\n| Index | Direction | $dr$ | $dc$ |\\n| :-- | :-- | :--: | :--: |\\n| 0 | Right | 0 | 1 |\\n| 1 | Down | 1 | 0 |\\n| 2 | Left | 0 | -1 |\\n| 3 | Up | -1 | 0 |\\n\\nChange in direction of traversal is $Right \\\\rightarrow Down \\\\rightarrow Left \\\\rightarrow Up \\\\rightarrow ...$\\n\\n## Hint 4\\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - I (Recursion) [Accepted]***\\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \\n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\\n\\n`total` is the area of one spiral, `total = area of outer rectangle - area of inner rectangle (if it exists)`.\\n\\n**C++**\\n```\\nclass Solution {\\nprivate:\\n    vector<int> result;\\n\\n    void spiral(vector<vector<int>>& matrix, int r1, int r2, int c1, int c2) {\\n        int r12 = r2 - r1 + 1, c12 = c2 - c1 + 1;\\n        if (r12 <= 0 || c12 <= 0) {\\n            return;\\n        }\\n        int total = r12 * c12, dir = 0;\\n        if (r12 > 2 && c12 > 2) { // if inner rectangle exists\\n            total -= (r12 - 2) * (c12 - 2);\\n        }\\n        vector<int> curr = {r1, c1}; // curr = {r, c}\\n        vector<vector<int>> limit = {{r1, c2}, {r2, c2}, {r2, c1}, {r1 + 1, c1}}, // boundaries\\n        dCurr = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // dcurr = {dr, dc}\\n        for (int j = 0; j < total; j++) {\\n            result.push_back(matrix[curr[0]][curr[1]]);\\n            if (curr == limit[dir]) { // change direction\\n                dir = (dir + 1) % 4;\\n            }\\n            curr = {curr[0] + dCurr[dir][0], curr[1] + dCurr[dir][1]}; // next cell\\n        }\\n        spiral(matrix, r1 + 1, r2 - 1, c1 + 1, c2 - 1);\\n    }\\n\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        spiral(matrix, 0, matrix.size() - 1, 0, matrix[0].size() - 1);\\n        return result;\\n    }\\n};\\n```\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - II (Iteration) [Accepted]***\\nWell, if you don\\'t want to use recursion, everything was alright for one spiral above. But for next spiral, boundaries will change. Can we calculate how will they change?\\n\\nTake the matrix from Hint 4\\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\\n\\nThe new sub-matrix and next spiral\\'s boundaries will be\\n![image.png](https://assets.leetcode.com/users/images/e054d689-e8fc-424a-8272-62876a53e5fa_1683605169.4419448.png)\\n\\nNotice how the boundaries changed?\\n![image.png](https://assets.leetcode.com/users/images/1a51b53c-f22b-4a83-b86e-810e927bd4dd_1683605580.8317032.png)\\n\\nBoundaries change as\\n\\n| Index | Direction | Boundary | Change | New Boundary |\\n| :-- | :-- | :-- | :-- | :-- |\\n| 0 | Right | $[0,n-1]$ | $[1,-1]$ | $[1,n-2]$ |\\n| 1 | Down | $[m-1,n-1]$ | $[-1,-1]$ | $[m-2,n-2]$ |\\n| 2 | Left | $[m-1,0]$ | $[-1,1]$ | $[m-2,1]$ |\\n| 3 | Up | $[1,0]$ | $[1,1]$ | $[2,1]$ |\\n\\nNow these changes are constant. That is why it is a spiral.\\n![image.png](https://assets.leetcode.com/users/images/63891d0f-cedd-44df-9366-04e1b9c7812c_1683607300.7183905.png)\\n\\nBoundaries change by $[[1,-1], [-1,-1], [-1,1], [1,1]]$\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size(), dir = 0; // direction\\n        vector<int> result(m * n), curr = {0, 0}; // {r, c}\\n        vector<vector<int>> limit = {{0, n - 1}, {m - 1, n - 1}, {m - 1, 0}, {1, 0}}, // boundaries\\n        dCurr = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}, // {dr, dc}\\n        dLimit = {{1, -1}, {-1, -1}, {-1, 1}, {1, 1}}; // change in boundaries\\n        for (int i = 0; i < m * n; i++) {\\n            result[i] = matrix[curr[0]][curr[1]];\\n            if (curr == limit[dir]) { // change direction\\n                limit[dir] = {limit[dir][0] + dLimit[dir][0], limit[dir][1] + dLimit[dir][1]}; // change boundary\\n                dir = (dir + 1) % 4;\\n            }\\n            curr = {curr[0] + dCurr[dir][0], curr[1] + dCurr[dir][1]};\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n---\\n\\n# Complexity\\n- Time complexity: $O(mn)$\\n- Space complexity: $O(mn)$\\n\\n---\\n\\nFor any mistakes / suggestions / questions, please do comment below \\uD83D\\uDC47\\nUpvote if helps!",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> result;\\n\\n    void spiral(vector<vector<int>>& matrix, int r1, int r2, int c1, int c2) {\\n        int r12 = r2 - r1 + 1, c12 = c2 - c1 + 1;\\n        if (r12 <= 0 || c12 <= 0) {\\n            return;\\n        }\\n        int total = r12 * c12, dir = 0;\\n        if (r12 > 2 && c12 > 2) { // if inner rectangle exists\\n            total -= (r12 - 2) * (c12 - 2);\\n        }\\n        vector<int> curr = {r1, c1}; // curr = {r, c}\\n        vector<vector<int>> limit = {{r1, c2}, {r2, c2}, {r2, c1}, {r1 + 1, c1}}, // boundaries\\n        dCurr = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // dcurr = {dr, dc}\\n        for (int j = 0; j < total; j++) {\\n            result.push_back(matrix[curr[0]][curr[1]]);\\n            if (curr == limit[dir]) { // change direction\\n                dir = (dir + 1) % 4;\\n            }\\n            curr = {curr[0] + dCurr[dir][0], curr[1] + dCurr[dir][1]}; // next cell\\n        }\\n        spiral(matrix, r1 + 1, r2 - 1, c1 + 1, c2 - 1);\\n    }\\n\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        spiral(matrix, 0, matrix.size() - 1, 0, matrix[0].size() - 1);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size(), dir = 0; // direction\\n        vector<int> result(m * n), curr = {0, 0}; // {r, c}\\n        vector<vector<int>> limit = {{0, n - 1}, {m - 1, n - 1}, {m - 1, 0}, {1, 0}}, // boundaries\\n        dCurr = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}, // {dr, dc}\\n        dLimit = {{1, -1}, {-1, -1}, {-1, 1}, {1, 1}}; // change in boundaries\\n        for (int i = 0; i < m * n; i++) {\\n            result[i] = matrix[curr[0]][curr[1]];\\n            if (curr == limit[dir]) { // change direction\\n                limit[dir] = {limit[dir][0] + dLimit[dir][0], limit[dir][1] + dLimit[dir][1]}; // change boundary\\n                dir = (dir + 1) % 4;\\n            }\\n            curr = {curr[0] + dCurr[dir][0], curr[1] + dCurr[dir][1]};\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226384,
                "title": "1-approach-for-your-interview",
                "content": "```\\nvar spiralOrder = function(matrix) {\\n    \\n         \\n    let r = matrix.length, c=matrix[0].length;\\n    let [left, right, top, bottom] = [0, c-1, 0, r-1];\\n\\n    let arr = [];\\n\\n    while(left<=right && top <= bottom){\\n        for(let i=left; i<=right; i++) arr.push(matrix[top][i])\\n        top++;\\n\\n\\n        for(let i=top; i<=bottom; i++) arr.push(matrix[i][right])\\n        right--;\\n\\n\\n        if(top<=bottom){               // condition 1\\n            for(let i=right; i>=left; i--) arr.push(matrix[bottom][i])\\n            bottom--;\\n        }\\n      \\n\\n        if(left<=right){               // condition 2\\n            for(let i=bottom; i>=top; i--) arr.push(matrix[i][left])\\n            left++;\\n        }\\n      \\n        \\n\\n    }\\n\\n\\n    return arr\\n\\n};\\n```\\n\\n\\ncondition 1 and condition2 will look suspecious/confusing to you, if you dont dry run.\\ndo dry run, and understand !",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spiralOrder = function(matrix) {\\n    \\n         \\n    let r = matrix.length, c=matrix[0].length;\\n    let [left, right, top, bottom] = [0, c-1, 0, r-1];\\n\\n    let arr = [];\\n\\n    while(left<=right && top <= bottom){\\n        for(let i=left; i<=right; i++) arr.push(matrix[top][i])\\n        top++;\\n\\n\\n        for(let i=top; i<=bottom; i++) arr.push(matrix[i][right])\\n        right--;\\n\\n\\n        if(top<=bottom){               // condition 1\\n            for(let i=right; i>=left; i--) arr.push(matrix[bottom][i])\\n            bottom--;\\n        }\\n      \\n\\n        if(left<=right){               // condition 2\\n            for(let i=bottom; i>=top; i--) arr.push(matrix[i][left])\\n            left++;\\n        }\\n      \\n        \\n\\n    }\\n\\n\\n    return arr\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20793,
                "title": "7-lines-recursive-python-solution-5-lines-solution-w-o-recursion",
                "content": "(1). Initial\\n\\n>1, 2, 3\\n\\n>4, 5, 6\\n\\n>7, 8, 9\\n\\n(2). The first row, [1, 2, 3], is used\\n\\n>4, 5, 6\\n\\n>7, 8, 9\\n\\n(3). Rotate the rest into:\\n\\n>6, 9\\n\\n>5, 8\\n\\n> 4, 7\\n\\n(4). Use the first row after rotation. Got [1, 2, 3, 6, 9, ... ] and just keep going !\\n\\n    def spiralOrder(self, matrix):\\n\\n        result = []\\n\\n        def helper(mat):\\n            if mat:\\n                result.extend(mat[0])\\n                helper(self.rotate_counter(mat[1:]))\\n\\n        helper(matrix)\\n        return result\\n\\n    def rotate_counter(self, mat):\\n        return zip(*mat)[::-1]\\n\\np.s. I isolate the rotation function for readability.                 \\np.s. fixed the redundancy & added a while-loop version under the suggestion of StefanPochmann\\n\\n    def spiralOrder(self, matrix):    #a while-loop version\\n\\n        result = []\\n\\n        while matrix:\\n            result.extend(matrix.pop(0))\\n            matrix = zip(*matrix)[::-1]    #rotate the remaining matrix counter-clockwise\\n            \\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "(1). Initial\\n\\n>1, 2, 3\\n\\n>4, 5, 6\\n\\n>7, 8, 9\\n\\n(2). The first row, [1, 2, 3], is used\\n\\n>4, 5, 6\\n\\n>7, 8, 9\\n\\n(3). Rotate the rest into:\\n\\n>6, 9\\n\\n>5, 8\\n\\n> 4, 7\\n\\n(4). Use the first row after rotation. Got [1, 2, 3, 6, 9, ... ] and just keep going !\\n\\n    def spiralOrder(self, matrix):\\n\\n        result = []\\n\\n        def helper(mat):\\n            if mat:\\n                result.extend(mat[0])\\n                helper(self.rotate_counter(mat[1:]))\\n\\n        helper(matrix)\\n        return result\\n\\n    def rotate_counter(self, mat):\\n        return zip(*mat)[::-1]\\n\\np.s. I isolate the rotation function for readability.                 \\np.s. fixed the redundancy & added a while-loop version under the suggestion of StefanPochmann\\n\\n    def spiralOrder(self, matrix):    #a while-loop version\\n\\n        result = []\\n\\n        while matrix:\\n            result.extend(matrix.pop(0))\\n            matrix = zip(*matrix)[::-1]    #rotate the remaining matrix counter-clockwise\\n            \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 3173516,
                "title": "best-c-solution-ever-matrix-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can simply solve this question using matrix. We will traverse the whole matrix spirally and store the output and return it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here we are visiting every element of the matrix ones which creates the time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant space. Extra space is only allocated for the Array(ans) of size N*M, however the output does not count towards the space complexity.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here we are\\n    visiting every element of the matrix ones which creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Array(ans) of size N*M, \\n    however the output does not count towards the space complexity.\\n\\n    Solved using Matrix.    \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int numberOfRows = matrix.size();\\n        int numberOfColumns = matrix[0].size();\\n        int totalElements = numberOfRows * numberOfColumns;\\n        int rowStart = 0;\\n        int colStart = 0;\\n        int rowEnd = numberOfRows-1;\\n        int colEnd = numberOfColumns-1;\\n        vector<int> ans;\\n        int count = 0;\\n        while(count < totalElements){\\n            for(int i=colStart; i<=colEnd && count < totalElements; i++){\\n                ans.push_back(matrix[rowStart][i]);\\n                count++;\\n            }\\n            rowStart++; \\n            for(int i=rowStart; i<=rowEnd && count < totalElements; i++){\\n                ans.push_back(matrix[i][colEnd]);\\n                count++;\\n            }\\n            colEnd--;\\n            for(int i=colEnd; i>=colStart && count < totalElements; i--){\\n                ans.push_back(matrix[rowEnd][i]);\\n                count++;\\n            }\\n            rowEnd--;\\n            for(int i=rowEnd; i>=rowStart && count < totalElements; i--){\\n                ans.push_back(matrix[i][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n###### ***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here we are\\n    visiting every element of the matrix ones which creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Array(ans) of size N*M, \\n    however the output does not count towards the space complexity.\\n\\n    Solved using Matrix.    \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int numberOfRows = matrix.size();\\n        int numberOfColumns = matrix[0].size();\\n        int totalElements = numberOfRows * numberOfColumns;\\n        int rowStart = 0;\\n        int colStart = 0;\\n        int rowEnd = numberOfRows-1;\\n        int colEnd = numberOfColumns-1;\\n        vector<int> ans;\\n        int count = 0;\\n        while(count < totalElements){\\n            for(int i=colStart; i<=colEnd && count < totalElements; i++){\\n                ans.push_back(matrix[rowStart][i]);\\n                count++;\\n            }\\n            rowStart++; \\n            for(int i=rowStart; i<=rowEnd && count < totalElements; i++){\\n                ans.push_back(matrix[i][colEnd]);\\n                count++;\\n            }\\n            colEnd--;\\n            for(int i=colEnd; i>=colStart && count < totalElements; i--){\\n                ans.push_back(matrix[rowEnd][i]);\\n                count++;\\n            }\\n            rowEnd--;\\n            for(int i=rowEnd; i>=rowStart && count < totalElements; i--){\\n                ans.push_back(matrix[i][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930808,
                "title": "easiest-programmer-friendly-code-with-comments-intution-and-complexity-analysis",
                "content": "**Intution:**\\n->Create an empty list to store the answer.\\n->Remove **Top Row** from matrix and insert into answer list.\\n->Remove **Rightmost Column** from matrix and insert into answer list.\\n->Remove **Bottom Row** from matrix and insert into answer list (in reverse order as sprial is expected to go from right to left in bottom-most row).\\n->Remove **Leftmost Column** from matrix and insert into answers list (In reverse order, as the spiral is expected to go from bottom to top in left-most row).\\n->Repeat this process unless the length of matrix becomes 0.\\n\\n**Complexity Analysis:**\\nTime Complexity:\\nO(n x m)\\nSpace complexity:\\nO( n x m)\\n\\n(*where m is number of rows and n is number of columns*)\\n\\n**Code:**\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        ans=[]\\n        while len(matrix): #Process would be repeated unless the length of matrix becomes zero.\\n            try: # Exception handling, in case the pop operation on empty matrix is performed.\\n                ans+=matrix.pop(0) #Removing Top Row from matrix and inserting into answer list.\\n                ans+=[i.pop() for i in matrix] #Removing Rightmost Column from matrix and inserting into answer list.\\n                ans+=matrix.pop()[::-1] #Removing Bottom Row from matrix and inserting into answer list in reverse order.\\n                ans+=[i.pop(0) for i in matrix][::-1] #Removing Leftmost Column from matrix and inserting into answers list in reverse order.\\n            except:\\n                break\\n        return ans\\n```\\n**PLEASE UPVOTE FOR MOTIVATING ME TO CONTINUE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        ans=[]\\n        while len(matrix): #Process would be repeated unless the length of matrix becomes zero.\\n            try: # Exception handling, in case the pop operation on empty matrix is performed.\\n                ans+=matrix.pop(0) #Removing Top Row from matrix and inserting into answer list.\\n                ans+=[i.pop() for i in matrix] #Removing Rightmost Column from matrix and inserting into answer list.\\n                ans+=matrix.pop()[::-1] #Removing Bottom Row from matrix and inserting into answer list in reverse order.\\n                ans+=[i.pop(0) for i in matrix][::-1] #Removing Leftmost Column from matrix and inserting into answers list in reverse order.\\n            except:\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672856,
                "title": "c-solution-using-4-pointers-with-explanations-time-complexity-o-n-2",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we have to do 4 types of traversal to get the spiral matrix.\\n    1. First row from left to right.\\n    2. Last column from top to down.\\n    3. Last row from right to left.\\n    4. First column from down to top.\\n- We will take 4 pointers: ***top, down, left, right*** & 1 counter ***count*** to select the traversal type.\\n    - If ***count=0,*** we will traverse a row from left to right & increase count value.\\n    - If ***count=1,*** we will traverse a column from top to down & increase count value.\\n    - If ***count=2,*** we will traverse a row from right to left & increase count value.\\n    - If ***count=3,*** we will traverse a column from down to top & will make ***count=0*** to repeat the traversal again.\\n- We\\u2019ll repeat the process until ***top<=down && left<=right.***\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int n= matrix[0].size(), m= matrix.size();\\n        \\n        int top=0,down=m-1,left=0,right=n-1, count=0;\\n        \\n        while(top<=down && left<=right){\\n            if(count==0){\\n                for(int i=left; i<=right; i++)\\n                    ans.push_back(matrix[top][i]);\\n                top++; count++;\\n            }\\n            else if(count==1){\\n                for(int i=top; i<=down; i++)\\n                    ans.push_back(matrix[i][right]);\\n                right--; count++;\\n            }\\n            else if(count==2){\\n                for(int i=right; i>=left; i--)\\n                    ans.push_back(matrix[down][i]);\\n                down--; count++;\\n            }\\n            else if(count==3){\\n                for(int i=down; i>=top; i--)\\n                    ans.push_back(matrix[i][left]);\\n                left++; count=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int n= matrix[0].size(), m= matrix.size();\\n        \\n        int top=0,down=m-1,left=0,right=n-1, count=0;\\n        \\n        while(top<=down && left<=right){\\n            if(count==0){\\n                for(int i=left; i<=right; i++)\\n                    ans.push_back(matrix[top][i]);\\n                top++; count++;\\n            }\\n            else if(count==1){\\n                for(int i=top; i<=down; i++)\\n                    ans.push_back(matrix[i][right]);\\n                right--; count++;\\n            }\\n            else if(count==2){\\n                for(int i=right; i>=left; i--)\\n                    ans.push_back(matrix[down][i]);\\n                down--; count++;\\n            }\\n            else if(count==3){\\n                for(int i=down; i>=top; i--)\\n                    ans.push_back(matrix[i][left]);\\n                left++; count=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271889,
                "title": "c-four-pointer-solution-o-n-easy-to-understand",
                "content": "Using \\n1) Four variables : top, bottom, right, and left.\\n2) Direction : 0,1, 2, 3\\n\\t0 -  left to right\\n\\t1 - top to bottom\\n\\t2 - right to left\\n\\t3 - bottom to top\\n\\n![image](https://assets.leetcode.com/users/images/d537f740-bab3-4274-b94f-9efbe33798c6_1623671124.918477.png)\\n\\nTime Complexity : O(n)\\n\\n\\n```\\n\\n     vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> spiral; // to store the resulting array\\n\\t\\t\\n\\t\\t//initializing top, bottom, left and right\\n        int top = 0;\\n        int bottom = matrix.size() - 1;\\n        int left = 0;\\n        int right = matrix[0].size() - 1;\\n\\t\\t\\n\\t\\t//initializing direction\\n        int direction = 0; \\n\\n        while(top <= bottom && left <= right){\\n\\t\\t\\t\\n\\t\\t\\t\\n            if(direction == 0){\\n\\t\\t\\t\\t//left -> right\\n                for(int i = left; i <= right; i++){\\n                    spiral.push_back(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            else if(direction == 1){\\n\\t\\t\\t\\t//top -> bottom\\n                for(int i = top; i <= bottom; i++){\\n                    spiral.push_back(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            else if(direction == 2){\\n\\t\\t\\t\\t//right -> left\\n                for(int i = right; i >= left; i--){\\n                    spiral.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            else if(direction == 3){\\n\\t\\t\\t\\t//bottom -> top\\n                for(int i = bottom; i >= top; i--){\\n                    spiral.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//increment the value of direction\\n            direction = (direction + 1) % 4;\\n\\n\\n        }\\n\\n        return spiral;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n\\n     vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> spiral; // to store the resulting array\\n\\t\\t\\n\\t\\t//initializing top, bottom, left and right\\n        int top = 0;\\n        int bottom = matrix.size() - 1;\\n        int left = 0;\\n        int right = matrix[0].size() - 1;\\n\\t\\t\\n\\t\\t//initializing direction\\n        int direction = 0; \\n\\n        while(top <= bottom && left <= right){\\n\\t\\t\\t\\n\\t\\t\\t\\n            if(direction == 0){\\n\\t\\t\\t\\t//left -> right\\n                for(int i = left; i <= right; i++){\\n                    spiral.push_back(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            else if(direction == 1){\\n\\t\\t\\t\\t//top -> bottom\\n                for(int i = top; i <= bottom; i++){\\n                    spiral.push_back(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            else if(direction == 2){\\n\\t\\t\\t\\t//right -> left\\n                for(int i = right; i >= left; i--){\\n                    spiral.push_back(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            else if(direction == 3){\\n\\t\\t\\t\\t//bottom -> top\\n                for(int i = bottom; i >= top; i--){\\n                    spiral.push_back(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//increment the value of direction\\n            direction = (direction + 1) % 4;\\n\\n\\n        }\\n\\n        return spiral;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329836,
                "title": "go-solution-tc-o-m-n",
                "content": "```go\\nfunc spiralOrder(matrix [][]int) []int {\\n\\tif matrix == nil || len(matrix) == 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tresult := make([]int, 0)\\n\\ttop, bottom, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1\\n\\n\\tfor {\\n\\t\\t// right\\n\\t\\tfor i := left; i <= right; i++ {\\n\\t\\t\\tresult = append(result, matrix[top][i])\\n\\t\\t}\\n\\t\\ttop++\\n\\t\\tif top > bottom {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// down\\n\\t\\tfor i := top; i <= bottom; i++ {\\n\\t\\t\\tresult = append(result, matrix[i][right])\\n\\t\\t}\\n\\t\\tright--\\n\\t\\tif left > right {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// left\\n\\t\\tfor i := right; i >= left; i-- {\\n\\t\\t\\tresult = append(result, matrix[bottom][i])\\n\\t\\t}\\n\\t\\tbottom--\\n\\t\\tif top > bottom {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// up\\n\\t\\tfor i := bottom; i >= top; i-- {\\n\\t\\t\\tresult = append(result, matrix[i][left])\\n\\t\\t}\\n\\t\\tleft++\\n\\t\\tif left > right {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go",
                    "Matrix"
                ],
                "code": "```go\\nfunc spiralOrder(matrix [][]int) []int {\\n\\tif matrix == nil || len(matrix) == 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tresult := make([]int, 0)\\n\\ttop, bottom, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1\\n\\n\\tfor {\\n\\t\\t// right\\n\\t\\tfor i := left; i <= right; i++ {\\n\\t\\t\\tresult = append(result, matrix[top][i])\\n\\t\\t}\\n\\t\\ttop++\\n\\t\\tif top > bottom {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// down\\n\\t\\tfor i := top; i <= bottom; i++ {\\n\\t\\t\\tresult = append(result, matrix[i][right])\\n\\t\\t}\\n\\t\\tright--\\n\\t\\tif left > right {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// left\\n\\t\\tfor i := right; i >= left; i-- {\\n\\t\\t\\tresult = append(result, matrix[bottom][i])\\n\\t\\t}\\n\\t\\tbottom--\\n\\t\\tif top > bottom {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// up\\n\\t\\tfor i := bottom; i >= top; i-- {\\n\\t\\t\\tresult = append(result, matrix[i][left])\\n\\t\\t}\\n\\t\\tleft++\\n\\t\\tif left > right {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 146248,
                "title": "javascript-solution",
                "content": "```\\nvar spiralOrder = function(matrix) {\\n    var spiralArray = [];\\n    if (matrix.length === 0) {\\n        return spiralArray;\\n    }\\n    var rowBegin = 0;\\n    var rowEnd = matrix.length - 1;\\n    var colBegin = 0;\\n    var colEnd = matrix[0].length - 1;\\n    \\n    while (colBegin <= colEnd && rowBegin <= rowEnd) {\\n        for (var i = colBegin; i <= colEnd; i++) {\\n            spiralArray.push(matrix[rowBegin][i]);\\n        }\\n        rowBegin++;\\n        for (var i = rowBegin; i <= rowEnd; i++) {\\n            spiralArray.push(matrix[i][colEnd]);\\n        }\\n        colEnd--;\\n        if (rowBegin <= rowEnd) {\\n            for (var i = colEnd; i >= colBegin; i --) {\\n                spiralArray.push(matrix[rowEnd][i]);\\n            }\\n        }\\n        rowEnd--;\\n        if (colBegin <= colEnd) {\\n            for (var i = rowEnd; i >= rowBegin; i--) {\\n                spiralArray.push(matrix[i][colBegin]);\\n            }\\n        }\\n        colBegin++;\\n    }\\n    return spiralArray;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar spiralOrder = function(matrix) {\\n    var spiralArray = [];\\n    if (matrix.length === 0) {\\n        return spiralArray;\\n    }\\n    var rowBegin = 0;\\n    var rowEnd = matrix.length - 1;\\n    var colBegin = 0;\\n    var colEnd = matrix[0].length - 1;\\n    \\n    while (colBegin <= colEnd && rowBegin <= rowEnd) {\\n        for (var i = colBegin; i <= colEnd; i++) {\\n            spiralArray.push(matrix[rowBegin][i]);\\n        }\\n        rowBegin++;\\n        for (var i = rowBegin; i <= rowEnd; i++) {\\n            spiralArray.push(matrix[i][colEnd]);\\n        }\\n        colEnd--;\\n        if (rowBegin <= rowEnd) {\\n            for (var i = colEnd; i >= colBegin; i --) {\\n                spiralArray.push(matrix[rowEnd][i]);\\n            }\\n        }\\n        rowEnd--;\\n        if (colBegin <= colEnd) {\\n            for (var i = rowEnd; i >= rowBegin; i--) {\\n                spiralArray.push(matrix[i][colBegin]);\\n            }\\n        }\\n        colBegin++;\\n    }\\n    return spiralArray;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20874,
                "title": "an-easy-to-understand-solution",
                "content": "This solution use a most left up point and a most right bottom point to act as limiters, and traverse around directly. I think it's quite easy to understand.\\n\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new LinkedList<Integer>();\\n        if (matrix == null) return list;\\n        int m = matrix.length;\\n        if (m == 0) return list;\\n        int n = matrix[0].length;\\n        int x0 = 0, y0 = 0; // most left up point\\n        int x1 = m-1, y1 = n-1; // most right bottom point\\n        int x = 0, y = 0;\\n        while(x0 < x1 && y0 < y1) {\\n            x = x0; // after one loop, (x, y) goes back to original position, must set them 'forward'\\n            y = y0;\\n            // traverse around\\n            while (y < y1) list.add(matrix[x][y++]);\\n            while (x < x1) list.add(matrix[x++][y]);\\n            while (y > y0) list.add(matrix[x][y--]);\\n            while (x > x0) list.add(matrix[x--][y]);\\n            // move limiters to center\\n            x0++; \\n            y0++;\\n            x1--;\\n            y1--;\\n        }\\n        x = x0;\\n        y = y0;\\n        // deal with one row or col left case\\n        if (x0 == x1 && y0 <= y1) {\\n            while (y <= y1) list.add(matrix[x][y++]);\\n        } else if (y0 == y1 && x0 <= x1) {\\n            while (x <= x1) list.add(matrix[x++][y]);\\n        }\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "This solution use a most left up point and a most right bottom point to act as limiters, and traverse around directly. I think it's quite easy to understand.\\n\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new LinkedList<Integer>();\\n        if (matrix == null) return list;\\n        int m = matrix.length;\\n        if (m == 0) return list;\\n        int n = matrix[0].length;\\n        int x0 = 0, y0 = 0; // most left up point\\n        int x1 = m-1, y1 = n-1; // most right bottom point\\n        int x = 0, y = 0;\\n        while(x0 < x1 && y0 < y1) {\\n            x = x0; // after one loop, (x, y) goes back to original position, must set them 'forward'\\n            y = y0;\\n            // traverse around\\n            while (y < y1) list.add(matrix[x][y++]);\\n            while (x < x1) list.add(matrix[x++][y]);\\n            while (y > y0) list.add(matrix[x][y--]);\\n            while (x > x0) list.add(matrix[x--][y]);\\n            // move limiters to center\\n            x0++; \\n            y0++;\\n            x1--;\\n            y1--;\\n        }\\n        x = x0;\\n        y = y0;\\n        // deal with one row or col left case\\n        if (x0 == x1 && y0 <= y1) {\\n            while (y <= y1) list.add(matrix[x][y++]);\\n        } else if (y0 == y1 && x0 <= x1) {\\n            while (x <= x1) list.add(matrix[x++][y]);\\n        }\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3502677,
                "title": "explained-with-images-simple-traversal",
                "content": "![image](https://assets.leetcode.com/users/images/f9e648a8-69ec-46c2-9915-559359fb3ab1_1683593610.2674944.jpeg)\\n![image](https://assets.leetcode.com/users/images/11ff19f5-dd6c-42d9-b8a4-77dbfcd5b17a_1683593602.4515886.jpeg)\\n\\n## CODE\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int lowRow = 0, highRow = m - 1;\\n        int lowCol = 0, highCol = n - 1;\\n        int i, j;\\n        vector<int>ans;\\n        while(lowRow <= highRow && lowCol <= highCol)\\n        {\\n            //===================================================================\\n            //TOP-LEFT to TOP-RIGHT\\n            i = lowRow; j = lowCol;\\n            while(j <= highCol)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                j++;\\n            }\\n            lowRow++; //increment the lowRow, we will not use it now\\n            //===================================================================\\n            //TOP-RIGHT to BOTTOM-RIGHT\\n            j = highCol; i = lowRow;\\n            while(i <= highRow)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                i++;\\n            }\\n            highCol--; //decrement the highCol, we will not use it now\\n            //====================================================================\\n            //BOTTOM-RIGHT to BOTTOM-LEFT\\n            //WE COULD EVEN VANISH THE MATRIX IN MIDWAY\\n            if (lowRow > highRow || lowCol > highCol) break;  //***IMPORTANT*****\\n            i = highRow; j = highCol;\\n            while(j >= lowCol)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                j--;\\n            }\\n            highRow--; //decrement the highRow, we will not use it now\\n            //=====================================================================\\n            //BOTTOM-LEFT to TOP-LEFT\\n            j = lowCol; i = highRow;\\n            while(i >= lowRow)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                i--;\\n            }\\n            lowCol++; //decrement the lowCol, we will not use it now\\n            //=========================================================================\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int lowRow = 0, highRow = m - 1;\\n        int lowCol = 0, highCol = n - 1;\\n        int i, j;\\n        vector<int>ans;\\n        while(lowRow <= highRow && lowCol <= highCol)\\n        {\\n            //===================================================================\\n            //TOP-LEFT to TOP-RIGHT\\n            i = lowRow; j = lowCol;\\n            while(j <= highCol)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                j++;\\n            }\\n            lowRow++; //increment the lowRow, we will not use it now\\n            //===================================================================\\n            //TOP-RIGHT to BOTTOM-RIGHT\\n            j = highCol; i = lowRow;\\n            while(i <= highRow)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                i++;\\n            }\\n            highCol--; //decrement the highCol, we will not use it now\\n            //====================================================================\\n            //BOTTOM-RIGHT to BOTTOM-LEFT\\n            //WE COULD EVEN VANISH THE MATRIX IN MIDWAY\\n            if (lowRow > highRow || lowCol > highCol) break;  //***IMPORTANT*****\\n            i = highRow; j = highCol;\\n            while(j >= lowCol)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                j--;\\n            }\\n            highRow--; //decrement the highRow, we will not use it now\\n            //=====================================================================\\n            //BOTTOM-LEFT to TOP-LEFT\\n            j = lowCol; i = highRow;\\n            while(i >= lowRow)\\n            {\\n                ans.push_back(matrix[i][j]);\\n                i--;\\n            }\\n            lowCol++; //decrement the lowCol, we will not use it now\\n            //=========================================================================\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738729,
                "title": "solution-swift-spiral-matrix-test-cases",
                "content": "```swift\\nclass Solution {\\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n        guard !(matrix.isEmpty) else { return [] }\\n        \\n        var result: [Int] = []\\n        var rBegin = 0, rEnd = matrix.count - 1\\n        var cBegin = 0, cEnd = matrix[0].count - 1\\n        \\n        while rBegin <= rEnd && cBegin <= cEnd {\\n            // Traverse right\\n            for i in stride(from: cBegin, to: cEnd + 1, by: 1) {\\n                result.append(matrix[rBegin][i])\\n            }\\n            rBegin += 1\\n            \\n            // Traverse down\\n            for i in stride(from: rBegin, to: rEnd + 1, by: 1) {\\n                result.append(matrix[i][cEnd])\\n            }\\n            cEnd -= 1\\n            \\n            // Traverse left\\n            if rBegin <= rEnd {\\n                for i in stride(from: cEnd, to: cBegin - 1, by: -1) {\\n                    result.append(matrix[rEnd][i])\\n                }\\n            }\\n            rEnd -= 1\\n            \\n            // Traverse up\\n            if cBegin <= cEnd {\\n                for i in stride(from: rEnd, to: rBegin - 1, by: -1) {\\n                    result.append(matrix[i][cBegin])\\n                }\\n            }\\n            cBegin += 1\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.spiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n        XCTAssertEqual(value, [1,2,3,6,9,8,7,4,5])\\n    }\\n    \\n    func test1() {\\n        let value = solution.spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\\n        XCTAssertEqual(value, [1,2,3,4,8,12,11,10,9,5,6,7])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n        guard !(matrix.isEmpty) else { return [] }\\n        \\n        var result: [Int] = []\\n        var rBegin = 0, rEnd = matrix.count - 1\\n        var cBegin = 0, cEnd = matrix[0].count - 1\\n        \\n        while rBegin <= rEnd && cBegin <= cEnd {\\n            // Traverse right\\n            for i in stride(from: cBegin, to: cEnd + 1, by: 1) {\\n                result.append(matrix[rBegin][i])\\n            }\\n            rBegin += 1\\n            \\n            // Traverse down\\n            for i in stride(from: rBegin, to: rEnd + 1, by: 1) {\\n                result.append(matrix[i][cEnd])\\n            }\\n            cEnd -= 1\\n            \\n            // Traverse left\\n            if rBegin <= rEnd {\\n                for i in stride(from: cEnd, to: cBegin - 1, by: -1) {\\n                    result.append(matrix[rEnd][i])\\n                }\\n            }\\n            rEnd -= 1\\n            \\n            // Traverse up\\n            if cBegin <= cEnd {\\n                for i in stride(from: rEnd, to: rBegin - 1, by: -1) {\\n                    result.append(matrix[i][cBegin])\\n                }\\n            }\\n            cBegin += 1\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.spiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n        XCTAssertEqual(value, [1,2,3,6,9,8,7,4,5])\\n    }\\n    \\n    func test1() {\\n        let value = solution.spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\\n        XCTAssertEqual(value, [1,2,3,4,8,12,11,10,9,5,6,7])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801834,
                "title": "python-o-m-n-by-simulation-w-visualization",
                "content": "**Hint**:\\n\\nSpiral path can be view as combination of four kinds of traversal, \\nincluding go right \\u2192, go down \\u2193, go left \\u2190, and go up \\u2191.\\n\\n---\\n\\n**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/images/78685e35-1ec7-4561-b689-a7e6db013dfd_1597909617.491446.png)\\n\\n---\\n\\n**Implementation** by iteration:\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        if not matrix or not matrix[0]:\\n            # Quick response for empty matrix\\n            return []\\n        \\n        left, right = 0, len(matrix[0])-1\\n        top, bottom = 0, len(matrix)-1\\n        \\n        spiral_path = []\\n        \\n        # Go with spiral shape and record the path\\n        while True:\\n            \\n            # Top side and go right \\u2192\\n            spiral_path.extend( matrix[top][x] for x in range(left, right+1) )\\n            top += 1\\n            \\n            if top > bottom: break \\n            \\n            # Right side and go down \\u2193\\n            spiral_path.extend( matrix[y][right] for y in range(top, bottom+1) )\\n            right -= 1\\n            \\n            if left > right: break \\n            \\n            # Bottom side and go left \\u2190\\n            spiral_path.extend( matrix[bottom][x] for x in range(right, left-1, -1) )\\n            bottom -= 1\\n            \\n            if top > bottom: break \\n            \\n            # Left side and go up \\u2191\\n            spiral_path.extend( matrix[y][left] for y in range(bottom, top-1, -1) )\\n            left += 1\\n            \\n            if left > right: break\\n        \\n        return spiral_path\\n```\\n\\n---\\n\\nShare another interesting implementation by matrix transpose with python built-in zip( ... ) function.\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n\\n        spiral_path = []\\n        \\n        while matrix:\\n            \\n            # pop the top-most row\\n            spiral_path.extend( matrix.pop(0) )\\n            \\n            # get the upside-down of matrix transpose\\n            matrix = [ *zip(*matrix) ][::-1]\\n        \\n        return spiral_path\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official doscs about zip( ... )](https://docs.python.org/3/library/functions.html#zip)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        if not matrix or not matrix[0]:\\n            # Quick response for empty matrix\\n            return []\\n        \\n        left, right = 0, len(matrix[0])-1\\n        top, bottom = 0, len(matrix)-1\\n        \\n        spiral_path = []\\n        \\n        # Go with spiral shape and record the path\\n        while True:\\n            \\n            # Top side and go right \\u2192\\n            spiral_path.extend( matrix[top][x] for x in range(left, right+1) )\\n            top += 1\\n            \\n            if top > bottom: break \\n            \\n            # Right side and go down \\u2193\\n            spiral_path.extend( matrix[y][right] for y in range(top, bottom+1) )\\n            right -= 1\\n            \\n            if left > right: break \\n            \\n            # Bottom side and go left \\u2190\\n            spiral_path.extend( matrix[bottom][x] for x in range(right, left-1, -1) )\\n            bottom -= 1\\n            \\n            if top > bottom: break \\n            \\n            # Left side and go up \\u2191\\n            spiral_path.extend( matrix[y][left] for y in range(bottom, top-1, -1) )\\n            left += 1\\n            \\n            if left > right: break\\n        \\n        return spiral_path\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n\\n        spiral_path = []\\n        \\n        while matrix:\\n            \\n            # pop the top-most row\\n            spiral_path.extend( matrix.pop(0) )\\n            \\n            # get the upside-down of matrix transpose\\n            matrix = [ *zip(*matrix) ][::-1]\\n        \\n        return spiral_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388871,
                "title": "simple-recursion-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        // Check for edge cases for the matrix\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return new ArrayList<Integer>();\\n        \\n        List<Integer> res = new ArrayList<Integer>();\\n        // Run our recursion starting with the first and last eligible rows and the first and last eligible columns\\n        spiralOut(res, matrix, 0, matrix.length - 1, 0, matrix[0].length - 1);\\n        return res;\\n    }\\n    \\n    private void spiralOut(List<Integer> res, int[][] m, int r1, int r2, int c1, int c2){\\n        // Return if we\\'ve exhausted all values to the point of invalid indices\\n        if(r1 > r2 || c1 > c2) return;\\n        \\n        // TOP ROW: left to right\\n        for(int c = c1; c <= c2; c++) res.add(m[r1][c]);\\n        \\n        // RIGHT COLUMN: top to bottom\\n        for(int r = r1 + 1; r <= r2; r++) res.add(m[r][c2]);\\n        \\n        // Return if we\\'ve processed the last row/column because we\\'d otherwise repeat values\\n        if(r1 == r2 || c1 == c2) return;\\n        \\n        // BOTTOM ROW: right to left\\n        for(int c = c2 - 1; c >= c1; c--) res.add(m[r2][c]);\\n        \\n        // LEFT COLUMN: bottom to top\\n        for(int r = r2 - 1; r >= r1 + 1; r--) res.add(m[r][c1]);\\n        \\n        // Recursion through the inner matrix\\n        spiralOut(res, m, r1 + 1, r2 - 1, c1 + 1, c2 - 1);\\n    }\\n}\\n```\\n\\nIf you imagine a spiral traversal of a matrix, the traversal of the inner matrix once you peel back the outmost 1 layer of the matrix is the same regardless of that outermost layer. Therefore, we can break the problem down to traversing the outermost layer, recording it, and then doing the same thing for the inner matrix. When we traverse the outermost layer, we have to be careful not the repeat the very last value from the last row/column as the first value in our current row/column.\\n\\nNote that if there are an odd number of rows or columns for the last matrix/layer, you must be careful not to double-count.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        // Check for edge cases for the matrix\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return new ArrayList<Integer>();\\n        \\n        List<Integer> res = new ArrayList<Integer>();\\n        // Run our recursion starting with the first and last eligible rows and the first and last eligible columns\\n        spiralOut(res, matrix, 0, matrix.length - 1, 0, matrix[0].length - 1);\\n        return res;\\n    }\\n    \\n    private void spiralOut(List<Integer> res, int[][] m, int r1, int r2, int c1, int c2){\\n        // Return if we\\'ve exhausted all values to the point of invalid indices\\n        if(r1 > r2 || c1 > c2) return;\\n        \\n        // TOP ROW: left to right\\n        for(int c = c1; c <= c2; c++) res.add(m[r1][c]);\\n        \\n        // RIGHT COLUMN: top to bottom\\n        for(int r = r1 + 1; r <= r2; r++) res.add(m[r][c2]);\\n        \\n        // Return if we\\'ve processed the last row/column because we\\'d otherwise repeat values\\n        if(r1 == r2 || c1 == c2) return;\\n        \\n        // BOTTOM ROW: right to left\\n        for(int c = c2 - 1; c >= c1; c--) res.add(m[r2][c]);\\n        \\n        // LEFT COLUMN: bottom to top\\n        for(int r = r2 - 1; r >= r1 + 1; r--) res.add(m[r][c1]);\\n        \\n        // Recursion through the inner matrix\\n        spiralOut(res, m, r1 + 1, r2 - 1, c1 + 1, c2 - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20820,
                "title": "python-easy-to-understand-solution-left-right-top-down",
                "content": "        \\n    def spiralOrder(self, matrix):\\n        if not matrix:\\n            return []\\n        left, right, top, down, res = 0, len(matrix[0])-1, 0, len(matrix)-1, []\\n        while left <= right and top <= down:\\n            res.extend(matrix[top][left:right+1]) # left to right\\n            top += 1 \\n            for i in xrange(top, down+1): # top to down\\n                res.append(matrix[i][right])\\n            right -= 1\\n            if top <= down:\\n                res.extend(matrix[down][left:right+1][::-1]) # right to left\\n                down -= 1\\n            if left <= right:\\n                for i in xrange(down, top-1, -1): # bottom to up\\n                    res.append(matrix[i][left])\\n                left += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def spiralOrder(self, matrix):\\n        if not matrix:\\n            return []\\n        left, right, top, down, res = 0, len(matrix[0])-1, 0, len(matrix)-1, []\\n        while left <= right and top <= down:\\n            res.extend(matrix[top][left:right+1]) # left to right\\n            top += 1 \\n            for i in xrange(top, down+1): # top to down\\n                res.append(matrix[i][right])\\n            right -= 1\\n            if top <= down:\\n                res.extend(matrix[down][left:right+1][::-1]) # right to left\\n                down -= 1\\n            if left <= right:\\n                for i in xrange(down, top-1, -1): # bottom to up\\n                    res.append(matrix[i][left])\\n                left += 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3503965,
                "title": "beats-99-with-s-complexity",
                "content": "![image.png](https://assets.leetcode.com/users/images/6f9a92fd-ef1f-4b6a-bb86-2cda2c03d332_1683620171.7653453.png)\\n\\n# Institution\\n\\nStoring each element of `matrix` to the `bag` in spiral order.\\n> Seeker of Miracle\\n\\n# Approach\\n![image.png](https://assets.leetcode.com/users/images/0c451fb0-afab-4115-b88c-0361d9a34db1_1683619789.227738.png)\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(X*Y) - where X is Length of X axis in matrix field, Y is Length of Y axis in matrix field\\n\\n- Space complexity:O(X*Y) - where X is Length of X axis in matrix field, Y is Length of Y axis in matrix field\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n   \\n    const yLength = matrix.length, xLength = matrix[0].length;\\n    let y=0, x=0, count=0, area= xLength * yLength, bag=[];\\n\\n    while(count<area)\\n    {\\n        for(let i=x; count<area && i<xLength-x; i++)\\n        {\\n            bag.push(matrix[y][i])\\n            count++;\\n        }\\n        y++;\\n        for(let i=y; count<area && i<yLength-y+1; i++)\\n        {\\n            bag.push(matrix[i][(xLength-1) - x])\\n            count++;\\n        }\\n        x++;\\n\\n        for(let i= (xLength-1) - x; count<area && i>=x-1; i--)\\n        {\\n            bag.push(matrix[(yLength-1) - (y-1)][i])\\n            count++;\\n        }\\n\\n        for(let i= (yLength-1) - y; count<area && i>=y; i--)\\n        {\\n            bag.push(matrix[i][x-1])\\n            count++;\\n        }\\n\\n    }\\n    return bag\\n};\\n```\\n*I am happy if you leave your comments below as advise in order to improve my code*",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    // MATRIX[Y][X]\\n    //    ---------\\n    //Y0 | 1  2  3 |\\n    //Y1 | 4  5  6 |\\n    //Y2 | 7  8  9 |\\n    //    ---------\\n    //     X0 X1 X2\\n   \\n    const yLength = matrix.length, xLength = matrix[0].length;\\n    let y=0, x=0, count=0, area= xLength * yLength, bag=[];\\n\\n    while(count<area)\\n    {\\n        for(let i=x; count<area && i<xLength-x; i++)\\n        {\\n            bag.push(matrix[y][i])\\n            count++;\\n        }\\n        y++;\\n        for(let i=y; count<area && i<yLength-y+1; i++)\\n        {\\n            bag.push(matrix[i][(xLength-1) - x])\\n            count++;\\n        }\\n        x++;\\n\\n        for(let i= (xLength-1) - x; count<area && i>=x-1; i--)\\n        {\\n            bag.push(matrix[(yLength-1) - (y-1)][i])\\n            count++;\\n        }\\n\\n        for(let i= (yLength-1) - y; count<area && i>=y; i--)\\n        {\\n            bag.push(matrix[i][x-1])\\n            count++;\\n        }\\n\\n    }\\n    return bag\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2779082,
                "title": "100-beats-0ms-c-fastest",
                "content": "\\n# Approach\\nTraverse the matrix in the spiral order by keeping four variables: rs for the first row, re for the last row, cs for the first column and ce for the last column.\\n# Complexity\\n- Time complexity: 0(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>res;\\n        if(matrix.size() == 0) \\n        return res;\\n        int rs = 0, re = matrix.size() - 1, cs = 0, ce = matrix[0].size() - 1;\\n        while(rs <= re && cs <= ce)\\n        {\\n            for(int i = cs; i <= ce; i++) \\n             res.push_back(matrix[rs][i]);\\n            rs++;\\n            for(int i = rs; i <= re; i++) \\n             res.push_back(matrix[i][ce]);\\n            ce--;\\n            for(int i = ce; i >= cs && rs <= re; i--) \\n             res.push_back(matrix[re][i]);\\n            re--;\\n            for(int i = re; i >= rs && cs <= ce; i--) \\n             res.push_back(matrix[i][cs]);\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>res;\\n        if(matrix.size() == 0) \\n        return res;\\n        int rs = 0, re = matrix.size() - 1, cs = 0, ce = matrix[0].size() - 1;\\n        while(rs <= re && cs <= ce)\\n        {\\n            for(int i = cs; i <= ce; i++) \\n             res.push_back(matrix[rs][i]);\\n            rs++;\\n            for(int i = rs; i <= re; i++) \\n             res.push_back(matrix[i][ce]);\\n            ce--;\\n            for(int i = ce; i >= cs && rs <= re; i--) \\n             res.push_back(matrix[re][i]);\\n            re--;\\n            for(int i = re; i >= rs && cs <= ce; i--) \\n             res.push_back(matrix[i][cs]);\\n            cs++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692290,
                "title": "fully-detailed-concise-and-clear-python-solution",
                "content": "Note: for each part that I\\'m explaining I\\'ll be referencing the relevant line in the code [*Line k*]. The code snippet is enumerated.\\n\\nMy solution approaches this problem one step at a time - simulating a walk over a spiral path. \\n\\n#### **Simulation details:**\\nThere are only 4 movement directions: \\n1. Right or `(row, col) + (0, 1)`: moving across the same row to the *next* column\\n2. Down or `(row, col) + (1, 0)`: moving across the same column to the *next* row\\n3. Left or `(row, col) + (0, -1)`: moving across the same row to the *previous* column\\n4. Up or `(row, col) + (-1, 0)`: moving across the same column to the *previous* row\\n\\nWe start at cell `(0,0)` and move to right with step pattern `(0,1)` [*Lines 5-6*], and we add each cell we visit to the `path` list [*Line 9*]. However, when we encounter a border or a visited cell, we need to change direction. Whenever we change direction we keep walking in that direction until again we encounter any of the obstacles (broder or visited cell).\\n\\n**Visited:** I indicate that a cell has been visited by changing its value to `120` [*Line 10*](but this could be any number not in the range of possible values `-100 <= num <= 100`. You can also achieve this by maintaining a set or anything data structure of your choice. But my method avoids using up extra space. [*Line 13 third conditional*]\\n\\n**Border:** This is rather intuitive, you should have to check if the new row and new col fall within the boundaries of the matrix. [*Lines 12, Line 13 first two conditionals*]\\n\\t\\n**Changing directions:** This follows a fixed pattern (at a right angle and clockwise). So we can follow the order above (from 1 to 4 and back to 1 in a loop). Achieving this in code can simply be done by recognizing the mathematical pattern. If you have a (simple) background in linear algebra, this can be understood as finding the transformation matrix for a clockwise 90 degrees rotation. But you don\\'t really need linear algebra. Notice that in transitioning from one step pattern to the next we do:\\n     `(x, y) => (y, -x)`\\n\\t  `(0,1)  => (1,0) => (0,-1) => (-1,0) => (0,1) => . . .`\\n\\t\\nThus, we change the pattern everytime the conditions at Line 13 aren\\'t satisfied. And we use our pattern above to change direction and move to the next cell according to the new pattern. [*Lines 15-18*]\\n\\n**Terminate the loop:** we already know what the final length of the path is - the number of cells in the matrix [*Line 3*]. So we terminate the loop when `len(path)` becomes equal to this size. [*Line 8*]\\n\\n\\n```\\n1. class Solution:\\n2.     def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n3.         size = len(matrix) * len(matrix[0])\\n4.         path = []\\n5.         cell = [0,0]\\n6.         step = [0,1]\\n7.         \\n8.         while len(path) < size:\\n9.             path.append(matrix[cell[0]][cell[1]])\\n10.            matrix[cell[0]][cell[1]] = 120\\n11.            # next cell\\n12.            nrow, ncol = cell[0]+step[0], cell[1]+step[1]\\n13.            if (0 <= nrow < len(matrix)) and (0 <= ncol < len(matrix[0])) and (matrix[nrow][ncol]) != 120:\\n14.                cell[0], cell[1] = nrow, ncol\\n15.            else:\\n16.                 # change direction (90 degrees clockwise)\\n17.                 step[0], step[1] = step[1], -step[0]\\n18.                 cell[0], cell[1] = cell[0]+step[0], cell[1]+step[1]\\n19.                \\n20.        return path\\n```\\n\\n\\nBelow I use `n` to indicate the size of the input rather than the number of rows (you could replace `n` with `nxm`).\\n\\n***Time complexity:*** O(n) \\nSince this is a simulation we only visit each cell once, and for each cell we perform a constant number of operations, and there are `n` cells.\\n\\n***Space complexity:*** O(n)\\nBecause we populate the `path` array with all n cell values.\\n\\n\\n**Notes:**\\n1. We can improve performance by initializing the `path` array to its final size (since we already know that it will contain `n` values). This way we can help Python avoid the continuous reallocation of the entire array after every few appends. ([Read more here](http://https://rednafi.github.io/reflections/pre-allocated-lists-in-python.html)). We would also have to keep a counter to keep track of the last inserted index.\\n2. Please suggest any performance or implementation improvements that you can think of.\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\n1. class Solution:\\n2.     def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n3.         size = len(matrix) * len(matrix[0])\\n4.         path = []\\n5.         cell = [0,0]\\n6.         step = [0,1]\\n7.         \\n8.         while len(path) < size:\\n9.             path.append(matrix[cell[0]][cell[1]])\\n10.            matrix[cell[0]][cell[1]] = 120\\n11.            # next cell\\n12.            nrow, ncol = cell[0]+step[0], cell[1]+step[1]\\n13.            if (0 <= nrow < len(matrix)) and (0 <= ncol < len(matrix[0])) and (matrix[nrow][ncol]) != 120:\\n14.                cell[0], cell[1] = nrow, ncol\\n15.            else:\\n16.                 # change direction (90 degrees clockwise)\\n17.                 step[0], step[1] = step[1], -step[0]\\n18.                 cell[0], cell[1] = cell[0]+step[0], cell[1]+step[1]\\n19.                \\n20.        return path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912519,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n        let count = (matrix.count + 1) / 2 \\n        let row = matrix.count\\n        let col = matrix[0].count\\n        var res: [Int] = []\\n        \\n        for i in 0..<count {\\n            \\n            for j in i..<col - i - 1 {\\n                let x = i\\n                let y = j\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<row - i - 1 {\\n                let x = j\\n                let y = col - i - 1\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<col - i - 1 {\\n                let x = row - i - 1\\n                let y = col - j - 1\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<row - i - 1 {\\n                let x = row - j - 1\\n                let y = i\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            if res.count == row * col { break }\\n        }\\n        \\n        if res.count == row * col - 1 {\\n            res.append(matrix[row / 2][col / 2])\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n        let count = (matrix.count + 1) / 2 \\n        let row = matrix.count\\n        let col = matrix[0].count\\n        var res: [Int] = []\\n        \\n        for i in 0..<count {\\n            \\n            for j in i..<col - i - 1 {\\n                let x = i\\n                let y = j\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<row - i - 1 {\\n                let x = j\\n                let y = col - i - 1\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<col - i - 1 {\\n                let x = row - i - 1\\n                let y = col - j - 1\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            for j in i..<row - i - 1 {\\n                let x = row - j - 1\\n                let y = i\\n                res.append(matrix[x][y])\\n                if res.count == row * col { break }\\n            }\\n            \\n            if res.count == row * col { break }\\n        }\\n        \\n        if res.count == row * col - 1 {\\n            res.append(matrix[row / 2][col / 2])\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954443,
                "title": "python-dfs",
                "content": "It looked simple dfs traversal at first but it fails when matrix is greater than size 3. \\nThanx to https://leetcode.com/problems/spiral-matrix/discuss/517536/Simple-Java-DFS-Solution, I found the trick.\\n\\n```\\n        ans = []\\n        seen = set()\\n        def dfs(row,col, isUp):\\n            if row < len(matrix) and row >= 0 and col < len(matrix[0]) and col >= 0 and (row,col) not in seen:\\n                seen.add((row,col))\\n                ans.append(matrix[row][col])\\n                if isUp:\\n                    dfs(row-1,col,True)\\n                dfs(row,col+1,False)\\n                dfs(row+1,col,False)\\n                dfs(row,col-1,False)\\n                dfs(row-1,col,True)\\n        dfs(0,0, False)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n        ans = []\\n        seen = set()\\n        def dfs(row,col, isUp):\\n            if row < len(matrix) and row >= 0 and col < len(matrix[0]) and col >= 0 and (row,col) not in seen:\\n                seen.add((row,col))\\n                ans.append(matrix[row][col])\\n                if isUp:\\n                    dfs(row-1,col,True)\\n                dfs(row,col+1,False)\\n                dfs(row+1,col,False)\\n                dfs(row,col-1,False)\\n                dfs(row-1,col,True)\\n        dfs(0,0, False)\\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 925789,
                "title": "easy-js-solution",
                "content": "```\\nvar spiralOrder = function(matrix) {\\n    if (matrix.length == 0) return [];\\n    \\n    let res = [];\\n    let row1 = 0, col1 = 0, row2 = matrix.length-1, col2 = matrix[0].length-1;\\n    \\n    while (row1 <= row2 && col1 <= col2) {\\n        // upper perimeter\\n        for (let col = col1; col <= col2; col++) {\\n            res.push(matrix[row1][col]);    \\n        }\\n        // right perimeter\\n        for (let row = row1+1; row <= row2; row++) {\\n            res.push(matrix[row][col2]);\\n        }\\n        if (row1 < row2 && col1 < col2) {\\n            // bottom perimeter\\n            for (let col = col2-1; col >= col1; col--) {\\n                res.push(matrix[row2][col]);\\n            }\\n            // left perimeter\\n            for (let row = row2-1; row > row1; row--) {\\n                res.push(matrix[row][col1]);\\n            }    \\n        }\\n        \\n        row1++, col1++, row2--, col2--;\\n    }\\n    \\n    return res;\\n    \\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spiralOrder = function(matrix) {\\n    if (matrix.length == 0) return [];\\n    \\n    let res = [];\\n    let row1 = 0, col1 = 0, row2 = matrix.length-1, col2 = matrix[0].length-1;\\n    \\n    while (row1 <= row2 && col1 <= col2) {\\n        // upper perimeter\\n        for (let col = col1; col <= col2; col++) {\\n            res.push(matrix[row1][col]);    \\n        }\\n        // right perimeter\\n        for (let row = row1+1; row <= row2; row++) {\\n            res.push(matrix[row][col2]);\\n        }\\n        if (row1 < row2 && col1 < col2) {\\n            // bottom perimeter\\n            for (let col = col2-1; col >= col1; col--) {\\n                res.push(matrix[row2][col]);\\n            }\\n            // left perimeter\\n            for (let row = row2-1; row > row1; row--) {\\n                res.push(matrix[row][col1]);\\n            }    \\n        }\\n        \\n        row1++, col1++, row2--, col2--;\\n    }\\n    \\n    return res;\\n    \\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 496148,
                "title": "python3-easy-to-understand-solution-with-comments",
                "content": "I was considering element by element operation at the beginning, but gave up after trying for 30 mins. If modifying the input matrix is OK, the code can be much easier by popping the elements in the right order and append. After some optimization, only the resulting array/list and a single variable is used. It seems to me that this is easy to remember/understand and come up in interviews. Please leave a comment or upvote if you find the post helpful :)\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        turn = 0\\n        \\n        while len(matrix) != 0 and len(matrix[0]) != 0:\\n            if turn % 4 == 0: # need to pop first row\\n                res += matrix.pop(0)\\n                \\n            if turn % 4 == 1: # need to pop last column\\n                for i in range(len(matrix)):\\n                    res.append(matrix[i].pop())\\n\\n            if turn % 4 == 2: # need to pop last row and reverse\\n                res += matrix.pop()[::-1]\\n                \\n            if turn % 4 == 3: # need to pop first column and reverse\\n                for i in range(len(matrix))[::-1]:\\n                    res.append(matrix[i].pop(0))\\n\\n            turn += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        turn = 0\\n        \\n        while len(matrix) != 0 and len(matrix[0]) != 0:\\n            if turn % 4 == 0: # need to pop first row\\n                res += matrix.pop(0)\\n                \\n            if turn % 4 == 1: # need to pop last column\\n                for i in range(len(matrix)):\\n                    res.append(matrix[i].pop())\\n\\n            if turn % 4 == 2: # need to pop last row and reverse\\n                res += matrix.pop()[::-1]\\n                \\n            if turn % 4 == 3: # need to pop first column and reverse\\n                for i in range(len(matrix))[::-1]:\\n                    res.append(matrix[i].pop(0))\\n\\n            turn += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316519,
                "title": "simple-javascript-solution-with-pop-shift-recursion-beat-86",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    if (matrix.length === 0) return [];\\n    if (matrix[0].length === 0) return [];\\n    \\n    let result = [];\\n    // ADD FIRST ROW\\n    result = result.concat(matrix.shift());\\n    \\n    // ADD LAST COL\\n    for (let i=0; i<matrix.length-1; i++){\\n        result.push(matrix[i].pop());\\n    }\\n    \\n    // ADD LAST ROW\\n    const lastRow = matrix.pop();\\n    if (lastRow) result = result.concat(lastRow.reverse());\\n\\n    // ADD FIRST COL\\n    for (let i=matrix.length-1; i>=0; i--){\\n        if (matrix[i].length) result.push(matrix[i].shift());\\n    }\\n    \\n    return result.concat(spiralOrder(matrix));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    if (matrix.length === 0) return [];\\n    if (matrix[0].length === 0) return [];\\n    \\n    let result = [];\\n    // ADD FIRST ROW\\n    result = result.concat(matrix.shift());\\n    \\n    // ADD LAST COL\\n    for (let i=0; i<matrix.length-1; i++){\\n        result.push(matrix[i].pop());\\n    }\\n    \\n    // ADD LAST ROW\\n    const lastRow = matrix.pop();\\n    if (lastRow) result = result.concat(lastRow.reverse());\\n\\n    // ADD FIRST COL\\n    for (let i=matrix.length-1; i>=0; i--){\\n        if (matrix[i].length) result.push(matrix[i].shift());\\n    }\\n    \\n    return result.concat(spiralOrder(matrix));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20811,
                "title": "23-line-clear-and-simple-c-solution",
                "content": "    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> res;\\n        if (matrix.empty()) return res;\\n        const int nx[] = {0, 1, 0, -1};\\n        const int ny[] = {1, 0, -1, 0};\\n        int x = 0, y = -1;\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0;\\n        \\n        while (m > 0 && n>0) {\\n            int k;\\n            if (i%2 == 0) k = n, m--;\\n            else k = m, n--;\\n                \\n            while (k--) {\\n                x += nx[i]; y += ny[i];\\n                res.push_back(matrix[x][y]);\\n            }\\n            \\n            i = (i+1)%4; //direction\\n        }\\n        \\n        return res;\\n    }\\n\\nvariable i control the direction of next movement, nx and ny holds the offset of next step",
                "solutionTags": [],
                "code": "    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> res;\\n        if (matrix.empty()) return res;\\n        const int nx[] = {0, 1, 0, -1};\\n        const int ny[] = {1, 0, -1, 0};\\n        int x = 0, y = -1;\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0;\\n        \\n        while (m > 0 && n>0) {\\n            int k;\\n            if (i%2 == 0) k = n, m--;\\n            else k = m, n--;\\n                \\n            while (k--) {\\n                x += nx[i]; y += ny[i];\\n                res.push_back(matrix[x][y]);\\n            }\\n            \\n            i = (i+1)%4; //direction\\n        }\\n        \\n        return res;\\n    }\\n\\nvariable i control the direction of next movement, nx and ny holds the offset of next step",
                "codeTag": "Unknown"
            },
            {
                "id": 3503174,
                "title": "100-beats-c-easy-to-undestand",
                "content": "sr : starting of row\\ner : end of row\\nsc : starting of row\\nec : end of columns\\n\\n{first traverse first row increment starting row by one\\nsecond traversal for insert last columns decrement last columns by 1\\nthird time insert last row decrement last row by one\\nfourth time insert first row increment 1st column by row}\\n    repeat these all four steps untill sr <= er && sc <= ec.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int sr = 0, sc = 0, er = mat.size()-1,ec = mat[0].size()-1,i;\\n        vector<int> v;\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v.push_back(mat[sr][i]);\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v.push_back(mat[i][ec]);\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v.push_back(mat[er][i]);\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v.push_back(mat[i][sc]);\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int sr = 0, sc = 0, er = mat.size()-1,ec = mat[0].size()-1,i;\\n        vector<int> v;\\n        while(sr<=er && sc <= ec){\\n            for(i = sc; i <= ec && sr<=er; i++){\\n                v.push_back(mat[sr][i]);\\n            }\\n            sr++;\\n            for(i = sr; i <= er &&  sc<=ec; i++){\\n                v.push_back(mat[i][ec]);\\n            }\\n            ec--;\\n            for(i = ec; i >= sc &&  sr<=er; i--){\\n                v.push_back(mat[er][i]);\\n            }\\n            er--;\\n            for(i = er; i >= sr && sc<=ec; i--){\\n                v.push_back(mat[i][sc]);\\n            }\\n            sc++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493023,
                "title": "super-logic-with-left-right-top-bottom-pointers-two-logics",
                "content": "# 1. Python3 Solution:\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        list1=[]\\n        left=0\\n        right=len(matrix[0])-1\\n        top=0\\n        bottom=len(matrix)-1\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            for i in range(top,bottom+1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if len(list1)==(len(matrix)*len(matrix[0])):\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n```\\n\\n\\n# 2. Python3 Solution\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        list1=[]\\n        left=0\\n        right=len(matrix[0])-1\\n        top=0\\n        bottom=len(matrix)-1\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            for i in range(top,bottom+1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if left>right or top>bottom:\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n  ```\\n  # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        list1=[]\\n        left=0\\n        right=len(matrix[0])-1\\n        top=0\\n        bottom=len(matrix)-1\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            for i in range(top,bottom+1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if len(list1)==(len(matrix)*len(matrix[0])):\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        list1=[]\\n        left=0\\n        right=len(matrix[0])-1\\n        top=0\\n        bottom=len(matrix)-1\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            for i in range(top,bottom+1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if left>right or top>bottom:\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3337983,
                "title": "easy-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing four pointers top , left , right , bottom\\nEach variable placed as their name suggest top = 0 , left = 0 , right = n-1 , bottom =m-1\\n- first we travels from left to right increasing top since top layer is already saved in our vector\\n- Then we travel from new top to bottom then decreasing right\\n- Then we travel from new right to left decreasing bottom \\n- Then we finally travel from bottom to top and increasing left\\n- this we have to do in while loop until our answer vector is not equal to original size of matrix\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int top = 0 , left = 0 ;\\n        int bot = matrix.size() - 1 , right = matrix[0].size()-1;\\n        int n = matrix.size() , m = matrix[0].size();\\n        vector<int>ans;\\n        int cnt = 0 ;\\n        while( ans.size() < n*m)\\n        {\\n            cnt++;\\n            if( left <= right)\\n            {\\n                for(int i = left ;i<= right ;i++ )\\n                {\\n                    ans.push_back( matrix[top][i]);\\n                }\\n                top++;\\n\\n            }\\n            if( top <= bot and ans.size() < n*m )\\n            {\\n                 for(int i = top ;i<=bot ;i++ )\\n                {\\n                    ans.push_back( matrix[i][right]);\\n                }\\n                right--;\\n\\n            }\\n\\n            if( right >= left and ans.size() < n*m ) \\n            {\\n                for(int i = right ;i>=left ;i-- )\\n                {\\n                    ans.push_back( matrix[bot][i]);\\n\\n                }\\n                bot--;\\n\\n            }\\n            if( bot >= top and ans.size() < n*m)\\n            {\\n                for(int i = bot ;i>= top ;i--)\\n                {\\n                    ans.push_back(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n            }\\n          \\n        }\\n        cout<<cnt;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int top = 0 , left = 0 ;\\n        int bot = matrix.size() - 1 , right = matrix[0].size()-1;\\n        int n = matrix.size() , m = matrix[0].size();\\n        vector<int>ans;\\n        int cnt = 0 ;\\n        while( ans.size() < n*m)\\n        {\\n            cnt++;\\n            if( left <= right)\\n            {\\n                for(int i = left ;i<= right ;i++ )\\n                {\\n                    ans.push_back( matrix[top][i]);\\n                }\\n                top++;\\n\\n            }\\n            if( top <= bot and ans.size() < n*m )\\n            {\\n                 for(int i = top ;i<=bot ;i++ )\\n                {\\n                    ans.push_back( matrix[i][right]);\\n                }\\n                right--;\\n\\n            }\\n\\n            if( right >= left and ans.size() < n*m ) \\n            {\\n                for(int i = right ;i>=left ;i-- )\\n                {\\n                    ans.push_back( matrix[bot][i]);\\n\\n                }\\n                bot--;\\n\\n            }\\n            if( bot >= top and ans.size() < n*m)\\n            {\\n                for(int i = bot ;i>= top ;i--)\\n                {\\n                    ans.push_back(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n            }\\n          \\n        }\\n        cout<<cnt;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1774250,
                "title": "4-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        int row= matrix.size(),col = matrix[0].size();\\n        int top =0,right = col-1,left = 0,bottom = row-1;\\n        vector<int> ans;\\n        while(left<=right and top<=bottom){\\n            // trversing from left to right\\n            // increase the top\\n            for(int i=left;i<=right;i++)\\n                ans.push_back(matrix[top][i]);\\n            top++;\\n            //traversing from top to bottom\\n            // decremnt right\\n            for(int i=top;i<=bottom;i++)\\n                ans.push_back(matrix[i][right]);\\n            right--;\\n            // traversing  right to left\\n            // decremnt the bottom\\n            if(left<=right){\\n                for(int i=right;i>=left;i--)\\n                    ans.push_back(matrix[bottom][i]);\\n                bottom--;\\n            }\\n            // traversing from bottom to top\\n            // incerament the left\\n            if(top<=bottom){\\n                for(int i =bottom;i>=top;i--)\\n                    ans.push_back(matrix[i][left]);\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        int row= matrix.size(),col = matrix[0].size();\\n        int top =0,right = col-1,left = 0,bottom = row-1;\\n        vector<int> ans;\\n        while(left<=right and top<=bottom){\\n            // trversing from left to right\\n            // increase the top\\n            for(int i=left;i<=right;i++)\\n                ans.push_back(matrix[top][i]);\\n            top++;\\n            //traversing from top to bottom\\n            // decremnt right\\n            for(int i=top;i<=bottom;i++)\\n                ans.push_back(matrix[i][right]);\\n            right--;\\n            // traversing  right to left\\n            // decremnt the bottom\\n            if(left<=right){\\n                for(int i=right;i>=left;i--)\\n                    ans.push_back(matrix[bottom][i]);\\n                bottom--;\\n            }\\n            // traversing from bottom to top\\n            // incerament the left\\n            if(top<=bottom){\\n                for(int i =bottom;i>=top;i--)\\n                    ans.push_back(matrix[i][left]);\\n                left++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188627,
                "title": "javascript-recursive",
                "content": "``` \\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix, result = []) {\\n     // Write your code here, and\\n      // return your final answer.\\n      if (matrix.length === 0) {\\n        return result\\n\\n      }\\n\\t\\n\\tfor (var i = 0; i < matrix.length; i++) {\\n\\t\\tvar current = matrix[i]\\n\\t \\tif (i === 0) {\\n\\t \\t\\tresult = result.concat(current);\\n\\t \\t} else {\\n\\t \\t  var last = current.pop();\\n\\t \\t\\tif (!last) {\\n\\t \\t\\t\\treturn result\\n\\t \\t\\t}\\n\\t \\t\\tresult.push(last)\\n\\t \\t\\tcurrent.reverse()\\n\\t \\t} \\n \\t}\\n\\t\\n\\tmatrix.shift()\\n \\treturn spiralOrder(matrix.reverse(), result)\\n};\\n\\n```",
                "solutionTags": [],
                "code": "``` \\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix, result = []) {\\n     // Write your code here, and\\n      // return your final answer.\\n      if (matrix.length === 0) {\\n        return result\\n\\n      }\\n\\t\\n\\tfor (var i = 0; i < matrix.length; i++) {\\n\\t\\tvar current = matrix[i]\\n\\t \\tif (i === 0) {\\n\\t \\t\\tresult = result.concat(current);\\n\\t \\t} else {\\n\\t \\t  var last = current.pop();\\n\\t \\t\\tif (!last) {\\n\\t \\t\\t\\treturn result\\n\\t \\t\\t}\\n\\t \\t\\tresult.push(last)\\n\\t \\t\\tcurrent.reverse()\\n\\t \\t} \\n \\t}\\n\\t\\n\\tmatrix.shift()\\n \\treturn spiralOrder(matrix.reverse(), result)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504302,
                "title": "c-fully-explained-easy-to-understand",
                "content": "# Intuition\\n**step1)** go from  left-top corner to right most cell of  row 0.\\n**step2)** go from right-top corner to right-bottom cell of **column n-1**\\n **step3)** go from right-bottom corner to left cell of column 0 .\\n**step4)** go left-bottom cell to up .\\nrepeate it untill   **c1<=c2 and r1<=r2** where **c1=0,c2=matrix[0].size()-1;**\\n             __________________________________________and  **r1=0,r2=matrix.size()-1;**\\n\\n# PLEASE upvote to motivate me more \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int c1=0,c2=matrix[0].size()-1;\\n        int r1=0,r2=matrix.size()-1;\\n\\n        while(c1<=c2 && r1<=r2){\\n            for(int c=c1;c<=c2;++c){ //from left to right\\n                ans.push_back(matrix[r1][c]);\\n            }\\n            for(int r=r1+1;r<=r2;++r){ // from right top to bottom\\n                ans.push_back(matrix[r][c2]);\\n            }\\n            if(r1<r2 && c1<c2){\\n              for(int c=c2-1;c>=c1;--c){ //from bottom right to bottom left\\n                  ans.push_back(matrix[r2][c]);\\n              }\\n              for(int r=r2-1;r>r1;--r){ //from left bottom to left up\\n                  ans.push_back(matrix[r][c1]);\\n              }\\n            }\\n\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n# Time Complexity :- O(m * n)\\n where m is the number of rows and n is the number of columns in the matrix. This is because the code iterates over each element in the matrix exactly once in the worst case.\\n\\n# Space Complexity :-O(m * n). \\nThis is because the code creates a vector of size m * n to store the output spiral order of the matrix.\\n\\n\\n![begging.jpg](https://assets.leetcode.com/users/images/b3a7e1db-c49f-4e61-ae82-e02eed7f4f46_1683626459.056374.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int c1=0,c2=matrix[0].size()-1;\\n        int r1=0,r2=matrix.size()-1;\\n\\n        while(c1<=c2 && r1<=r2){\\n            for(int c=c1;c<=c2;++c){ //from left to right\\n                ans.push_back(matrix[r1][c]);\\n            }\\n            for(int r=r1+1;r<=r2;++r){ // from right top to bottom\\n                ans.push_back(matrix[r][c2]);\\n            }\\n            if(r1<r2 && c1<c2){\\n              for(int c=c2-1;c>=c1;--c){ //from bottom right to bottom left\\n                  ans.push_back(matrix[r2][c]);\\n              }\\n              for(int r=r2-1;r>r1;--r){ //from left bottom to left up\\n                  ans.push_back(matrix[r][c1]);\\n              }\\n            }\\n\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998924,
                "title": "super-easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(Row x Colums)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n         List<Integer> res = new ArrayList<Integer>();\\n        int startRow =0;\\n        int endRow = matrix.length-1;\\n        int startCol = 0;\\n        int endCol =  matrix[0].length-1;\\n\\n        while(startRow<=endRow && startCol <= endCol){\\n            //top\\n            for(int j=startCol; j<=endCol; j++){\\n                res.add(matrix[startRow][j]);\\n            }\\n            // right\\n            for(int i=startRow+1; i<=endRow; i++){\\n                res.add(matrix[i][endCol]);\\n            }\\n            // bottom\\n            for(int j= endCol-1; j>=startCol; j--){\\n                if(startRow==endRow){\\n                    break;\\n                }\\n                res.add(matrix[endRow][j]);\\n            }\\n            // left\\n            for(int i=endRow-1; i>=startRow+1; i--){\\n                if(startCol==endCol){\\n                    break;\\n                }\\n                res.add(matrix[i][startCol]);\\n            }\\n            startCol++;\\n            startRow++;\\n            endCol--;\\n            endRow--;\\n\\n              \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n         List<Integer> res = new ArrayList<Integer>();\\n        int startRow =0;\\n        int endRow = matrix.length-1;\\n        int startCol = 0;\\n        int endCol =  matrix[0].length-1;\\n\\n        while(startRow<=endRow && startCol <= endCol){\\n            //top\\n            for(int j=startCol; j<=endCol; j++){\\n                res.add(matrix[startRow][j]);\\n            }\\n            // right\\n            for(int i=startRow+1; i<=endRow; i++){\\n                res.add(matrix[i][endCol]);\\n            }\\n            // bottom\\n            for(int j= endCol-1; j>=startCol; j--){\\n                if(startRow==endRow){\\n                    break;\\n                }\\n                res.add(matrix[endRow][j]);\\n            }\\n            // left\\n            for(int i=endRow-1; i>=startRow+1; i--){\\n                if(startCol==endCol){\\n                    break;\\n                }\\n                res.add(matrix[i][startCol]);\\n            }\\n            startCol++;\\n            startRow++;\\n            endCol--;\\n            endRow--;\\n\\n              \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145118,
                "title": "swift-solution",
                "content": "```\\nfunc spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n\\tguard  !matrix.isEmpty else {\\n\\t\\treturn []\\n\\t}\\n\\tvar top = 0\\n\\tvar bottom = matrix.count - 1\\n\\tvar left = 0\\n\\tvar right = matrix[0].count - 1\\n\\tlet count = matrix.count * matrix[0].count\\n\\tvar arr = [Int]()\\n\\twhile arr.count < count {\\n\\n\\t\\tfor i in stride(from: left, to: right+1, by: 1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[top][i])\\n\\t\\t}\\n\\t\\ttop += 1\\n\\t\\tfor i in stride(from: top, to: bottom+1, by: 1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[i][right])\\n\\t\\t}\\n\\t\\tright -= 1\\n\\t\\tfor i in stride(from: right, to: left-1, by: -1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[bottom][i])\\n\\t\\t}\\n\\t\\tbottom -= 1\\n\\t\\tfor i in stride(from: bottom, to: top-1, by: -1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[i][left])\\n\\t\\t}\\n\\t\\tleft += 1\\n\\t}\\n\\treturn arr\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc spiralOrder(_ matrix: [[Int]]) -> [Int] {\\n\\tguard  !matrix.isEmpty else {\\n\\t\\treturn []\\n\\t}\\n\\tvar top = 0\\n\\tvar bottom = matrix.count - 1\\n\\tvar left = 0\\n\\tvar right = matrix[0].count - 1\\n\\tlet count = matrix.count * matrix[0].count\\n\\tvar arr = [Int]()\\n\\twhile arr.count < count {\\n\\n\\t\\tfor i in stride(from: left, to: right+1, by: 1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[top][i])\\n\\t\\t}\\n\\t\\ttop += 1\\n\\t\\tfor i in stride(from: top, to: bottom+1, by: 1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[i][right])\\n\\t\\t}\\n\\t\\tright -= 1\\n\\t\\tfor i in stride(from: right, to: left-1, by: -1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[bottom][i])\\n\\t\\t}\\n\\t\\tbottom -= 1\\n\\t\\tfor i in stride(from: bottom, to: top-1, by: -1) where arr.count < count {\\n\\t\\t\\tarr.append(matrix[i][left])\\n\\t\\t}\\n\\t\\tleft += 1\\n\\t}\\n\\treturn arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435612,
                "title": "python3-try-except",
                "content": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:  \\n        ans = []\\n        while True:\\n            try: \\n                ans += matrix.pop(0) #take top row\\n                ans += [i.pop() for i in matrix] #take right col\\n                ans += matrix.pop()[::-1] #take bottom row,\\n                ans += [i.pop(0) for i in matrix][::-1] #take left col\\n            except IndexError: #when matrix is emptied mission is complete\\n                return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:  \\n        ans = []\\n        while True:\\n            try: \\n                ans += matrix.pop(0) #take top row\\n                ans += [i.pop() for i in matrix] #take right col\\n                ans += matrix.pop()[::-1] #take bottom row,\\n                ans += [i.pop(0) for i in matrix][::-1] #take left col\\n            except IndexError: #when matrix is emptied mission is complete\\n                return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055455,
                "title": "spiral-matrix-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks for a list of integers representing a spiral order traversal of a given 2D matrix. My intuition for this code is to simulate the spiral traversal pattern by moving through the matrix in four directions: right, down, left, and up, while updating the boundaries of the submatrix. In conlusion I move from the outermost boundary towards the center until there are no more elements left to traverse.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach for traversing a 2D matrix in a spiral order involves a systematic step-by-step process:\\n\\n1. Initialization: Start with key variables:\\nstart_row as 0 for the starting row.\\nend_row as n - 1 (n is the number of rows) for the ending row.\\nstart_col at 0 for the starting column.\\nend_col as m - 1 (m is the number of columns) for the ending column.\\nCreate an empty list called integerList to store spiral order elements.\\n2. Spiral Traversal Loop: Utilize a loop to visit all elements.\\n\\n3. Traverse Top Row (left to right): In the loop, move along the top row left to right:\\nUse a for loop with j from start_col to end_col.\\nAdd arr[start_row][j] to integerList.\\n\\n4. Traverse Right Column (top to bottom): Proceed to the rightmost column from top to bottom:\\n      Use a for loop with i from start_row + 1 to end_row.\\n      Add arr[i][end_col] to integerList.\\n\\n5. Traverse Bottom Row (right to left) if needed: If multiple rows are left (start_row < end_row), navigate the bottom row right to left:\\nEmploy a for loop with j from end_col - 1 to start_col.\\nAppend arr[end_row][j] to integerList.\\n\\n6. Traverse Left Column (bottom to top) if needed: If multiple columns are left (start_col < end_col), travel the leftmost column from bottom to top:\\nUse a for loop with i from end_row - 1 to start_row + 1.\\nAdd arr[i][start_col] to integerList.\\n\\n7. Update Boundaries: After one spiral loop, adjust start_col, start_row (inward movement), and end_col, end_row (boundary reduction).\\n\\n8. Repeat Steps 3-7: Continue these steps until all matrix elements are visited.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn terms of complexity, the time complexity is O(n * m) since each element is visited once, where \\'n\\' is the number of rows and \\'m\\' is the number of columns.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(n * m) because \\'integerList\\' stores all matrix elements in spiral order.\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] arr) {\\n        List<Integer> integerList = new ArrayList<>();\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int start_row = 0;\\n        int end_row = n - 1;\\n        int start_col = 0;\\n        int end_col = m - 1;\\n\\n        while (start_row <= end_row && start_col <= end_col) {\\n            // printing top elements\\n            for (int j = start_col; j <= end_col; j++) {\\n                integerList.add(arr[start_row][j]);\\n            }\\n\\n            // printing right elements\\n            for (int i = start_row + 1; i <= end_row; i++) {\\n                integerList.add(arr[i][end_col]);\\n            }\\n\\n            // printing bottom elements\\n            if (start_row < end_row) {\\n                for (int j = end_col - 1; j >= start_col; j--) {\\n                    integerList.add(arr[end_row][j]);\\n                }\\n            }\\n\\n            // printing left elements\\n            if (start_col < end_col) {\\n                for (int i = end_row - 1; i >= start_row + 1; i--) {\\n                    integerList.add(arr[i][start_col]);\\n                }\\n            }\\n\\n            start_col++;\\n            start_row++;\\n            end_col--;\\n            end_row--;\\n        }\\n\\n        return integerList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] arr) {\\n        List<Integer> integerList = new ArrayList<>();\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int start_row = 0;\\n        int end_row = n - 1;\\n        int start_col = 0;\\n        int end_col = m - 1;\\n\\n        while (start_row <= end_row && start_col <= end_col) {\\n            // printing top elements\\n            for (int j = start_col; j <= end_col; j++) {\\n                integerList.add(arr[start_row][j]);\\n            }\\n\\n            // printing right elements\\n            for (int i = start_row + 1; i <= end_row; i++) {\\n                integerList.add(arr[i][end_col]);\\n            }\\n\\n            // printing bottom elements\\n            if (start_row < end_row) {\\n                for (int j = end_col - 1; j >= start_col; j--) {\\n                    integerList.add(arr[end_row][j]);\\n                }\\n            }\\n\\n            // printing left elements\\n            if (start_col < end_col) {\\n                for (int i = end_row - 1; i >= start_row + 1; i--) {\\n                    integerList.add(arr[i][start_col]);\\n                }\\n            }\\n\\n            start_col++;\\n            start_row++;\\n            end_col--;\\n            end_row--;\\n        }\\n\\n        return integerList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502854,
                "title": "python-well-explained",
                "content": "# Approach\\n\\nThe optimized solution is a more efficient implementation of the same algorithm used in the original solution. Instead of using pop(0) to extract the first row of the matrix, we use four variables top, bottom, left, right to keep track of the boundaries of the matrix, and use loops to traverse the matrix in a spiral order.\\n\\nThe while loop iterates until top <= bottom and left <= right, which means that we have not yet traversed the entire matrix. Inside the loop, we use four for loops to traverse the matrix in a spiral order.\\n\\nThe first for loop traverses from left to right on the top row of the matrix, appending each element to the result list. Then, we increment top to exclude the top row from future iterations.\\n\\nThe second for loop traverses from top to bottom on the right column of the matrix, appending each element to the result list. Then, we decrement right to exclude the right column from future iterations.\\n\\nThe third for loop traverses from right to left on the bottom row of the matrix, appending each element to the result list. Then, we decrement bottom to exclude the bottom row from future iterations.\\n\\nThe fourth for loop traverses from bottom to top on the left column of the matrix, appending each element to the result list. Then, we increment left to exclude the left column from future iterations.\\n\\nWe continue this process until we have traversed the entire matrix.\\n\\n# Complexity\\n- Time complexity:\\n-\\nThe time complexity of the optimized solution is O(m * n) or O(n^2), where m and n are the number of rows and columns of the matrix, respectively. This is because we visit each element of the matrix once.\\n\\n- Space complexity:\\nThe space complexity of the optimized solution is O(1), since we only use constant extra space to store the result list and the boundary variables.\\n\\n#Algorithm\\n\\nWe can efficiently traverse the matrix in a spiral order by keeping track of the boundaries of the matrix using four variables top, bottom, left, right, and using loops to traverse the matrix in a spiral order. \\n\\n# Code\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        result = []\\n        top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1\\n        \\n        while top <= bottom and left <= right:\\n            # Traverse right\\n            for i in range(left, right+1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            \\n            # Traverse down\\n            for i in range(top, bottom+1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            \\n            # Traverse left\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            \\n            # Traverse up\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        result = []\\n        top, bottom, left, right = 0, len(matrix)-1, 0, len(matrix[0])-1\\n        \\n        while top <= bottom and left <= right:\\n            # Traverse right\\n            for i in range(left, right+1):\\n                result.append(matrix[top][i])\\n            top += 1\\n            \\n            # Traverse down\\n            for i in range(top, bottom+1):\\n                result.append(matrix[i][right])\\n            right -= 1\\n            \\n            # Traverse left\\n            if top <= bottom:\\n                for i in range(right, left-1, -1):\\n                    result.append(matrix[bottom][i])\\n                bottom -= 1\\n            \\n            # Traverse up\\n            if left <= right:\\n                for i in range(bottom, top-1, -1):\\n                    result.append(matrix[i][left])\\n                left += 1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557262,
                "title": "python-faster-than-97-short-and-simple-solution-with-comments",
                "content": "You have to do four operations to solve this:\\n- remove the top row\\n- remove the right row\\n- remove the bottom row\\n- remove the left row\\nand repeat until the matrix is empty.\\nwhen you remove a row, append all it\\'s element in a array and that\\'s the answer.\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = list()\\n        while len(matrix) > 0:\\n            try:\\n                result += matrix.pop(0) #remove the first nested list (top row)\\n                result += [x.pop(-1) for x in matrix] #remove every last element of the lists (right row)\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n                result += matrix.pop(-1)[::-1] #remove last nested list in reverse order (bottom row)\\n                result += [x.pop(0) for x in matrix][::-1] #remove every last element of the lists (left row)\\n            except:\\n                break #if at any moment the matrix is empty, break the loop and return the result array\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        result = list()\\n        while len(matrix) > 0:\\n            try:\\n                result += matrix.pop(0) #remove the first nested list (top row)\\n                result += [x.pop(-1) for x in matrix] #remove every last element of the lists (right row)\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n                result += matrix.pop(-1)[::-1] #remove last nested list in reverse order (bottom row)\\n                result += [x.pop(0) for x in matrix][::-1] #remove every last element of the lists (left row)\\n            except:\\n                break #if at any moment the matrix is empty, break the loop and return the result array\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600651,
                "title": "simple-java-solution-with-some-helpful-comments",
                "content": "\\n```\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix.length==0) {\\n            return Collections.EMPTY_LIST;\\n        }\\n        List<Integer> cells = new ArrayList<>();\\n       int top = 0;\\n       int bottom =matrix.length-1;\\n        int left = 0;\\n        int right = matrix[0].length-1;\\n\\t\\t//loop while still in the matrix boundries \\n        while(top <= bottom && left <= right){\\n\\n           //move right\\n            for(int i = left; i<= right; i++){\\n                cells.add(matrix[top][i]);\\n            }\\n            \\n            //Set the top row pointer down to the next row\\n            top++;\\n            //\\n            //Move down\\n            for(int i = top; i<= bottom; i++){\\n                cells.add(matrix[i][right]);\\n            }\\n            //Move column pointer to left\\n            right--;\\n           \\n            //Move left\\n            if(top <= bottom){\\n                for(int i = right; i>= left; i--){\\n                    cells.add(matrix[bottom][i]);\\n                }\\n            }\\n            //Set bottom row pointer to next row up\\n            bottom--;\\n            //move up\\n            if(left <= right){\\n                for(int i = bottom; i>= top; i--){\\n                    cells.add(matrix[i][left]);\\n                }\\n            }\\n            //set left coulmn pointer to next column to the right\\n            left++;\\n        }\\n\\n        return cells;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix.length==0) {\\n            return Collections.EMPTY_LIST;\\n        }\\n        List<Integer> cells = new ArrayList<>();\\n       int top = 0;\\n       int bottom =matrix.length-1;\\n        int left = 0;\\n        int right = matrix[0].length-1;\\n\\t\\t//loop while still in the matrix boundries \\n        while(top <= bottom && left <= right){\\n\\n           //move right\\n            for(int i = left; i<= right; i++){\\n                cells.add(matrix[top][i]);\\n            }\\n            \\n            //Set the top row pointer down to the next row\\n            top++;\\n            //\\n            //Move down\\n            for(int i = top; i<= bottom; i++){\\n                cells.add(matrix[i][right]);\\n            }\\n            //Move column pointer to left\\n            right--;\\n           \\n            //Move left\\n            if(top <= bottom){\\n                for(int i = right; i>= left; i--){\\n                    cells.add(matrix[bottom][i]);\\n                }\\n            }\\n            //Set bottom row pointer to next row up\\n            bottom--;\\n            //move up\\n            if(left <= right){\\n                for(int i = bottom; i>= top; i--){\\n                    cells.add(matrix[i][left]);\\n                }\\n            }\\n            //set left coulmn pointer to next column to the right\\n            left++;\\n        }\\n\\n        return cells;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20615,
                "title": "c-solutions-to-spiral-matrix-1-and-2-nearly-the-same",
                "content": "Here is Spiral Matrix 1 - build a list from the matrix\\n\\n```\\n    public IList<int> SpiralOrder(int[,] matrix) {\\n        int top = 0;\\n        int left = 0;\\n        int bottom = matrix.GetLength(0) - 1;\\n        int right = matrix.GetLength(1) - 1;\\n        \\n        IList<int> list = new List<int>();\\n        int direction = 0;\\n        \\n        while (right >= left && bottom >= top)\\n        {\\n            if (direction == 0) // top\\n            {\\n                for (int i = left; i <= right; i++) list.Add(matrix[top, i]);\\n                top++;\\n            }\\n            else if (direction == 1) // right\\n            {\\n                for (int i = top; i <= bottom; i++) list.Add(matrix[i, right]);\\n                right--;\\n            }\\n            else if (direction == 2) // bottom\\n            {\\n                for (int i = right; i >= left; i--) list.Add(matrix[bottom, i]);\\n                bottom--;\\n            }\\n            else if (direction == 3) // left\\n            {\\n                for (int i = bottom; i >= top; i--) list.Add(matrix[i, left]);\\n                left++;\\n            }\\n            \\n            direction = (direction + 1) % 4;\\n        }\\n        \\n        return list;\\n    }\\n```\\n\\nHere is Spiral Matrix 2 - build the matrix from a list.  The only difference is that instead of capturing the matrix element you set the matrix element, the iteration is the same.\\n```\\n    public int[,] GenerateMatrix(int n) \\n    {\\n        int[,] matrix = new int[n,n];\\n        int top = 0;\\n        int left = 0;\\n        int bottom = matrix.GetLength(0) - 1;\\n        int right = matrix.GetLength(1) - 1;\\n        \\n        int direction = 0;\\n        int num = 1;\\n        \\n        while (right >= left && bottom >= top)\\n        {\\n            if (direction == 0) // top\\n            {\\n                for (int i = left; i <= right; i++, num++) matrix[top, i] = num;\\n                top++;\\n            }\\n            else if (direction == 1) // right\\n            {\\n                for (int i = top; i <= bottom; i++, num++) matrix[i, right] = num;\\n                right--;\\n            }\\n            else if (direction == 2) // bottom\\n            {\\n                for (int i = right; i >= left; i--, num++) matrix[bottom, i] = num;\\n                bottom--;\\n            }\\n            else if (direction == 3) // left\\n            {\\n                for (int i = bottom; i >= top; i--, num++) matrix[i, left] = num;\\n                left++;\\n            }\\n            \\n            direction = (direction + 1) % 4;\\n        }\\n        \\n        return matrix;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<int> SpiralOrder(int[,] matrix) {\\n        int top = 0;\\n        int left = 0;\\n        int bottom = matrix.GetLength(0) - 1;\\n        int right = matrix.GetLength(1) - 1;\\n        \\n        IList<int> list = new List<int>();\\n        int direction = 0;\\n        \\n        while (right >= left && bottom >= top)\\n        {\\n            if (direction == 0) // top\\n            {\\n                for (int i = left; i <= right; i++) list.Add(matrix[top, i]);\\n                top++;\\n            }\\n            else if (direction == 1) // right\\n            {\\n                for (int i = top; i <= bottom; i++) list.Add(matrix[i, right]);\\n                right--;\\n            }\\n            else if (direction == 2) // bottom\\n            {\\n                for (int i = right; i >= left; i--) list.Add(matrix[bottom, i]);\\n                bottom--;\\n            }\\n            else if (direction == 3) // left\\n            {\\n                for (int i = bottom; i >= top; i--) list.Add(matrix[i, left]);\\n                left++;\\n            }\\n            \\n            direction = (direction + 1) % 4;\\n        }\\n        \\n        return list;\\n    }\\n```\n```\\n    public int[,] GenerateMatrix(int n) \\n    {\\n        int[,] matrix = new int[n,n];\\n        int top = 0;\\n        int left = 0;\\n        int bottom = matrix.GetLength(0) - 1;\\n        int right = matrix.GetLength(1) - 1;\\n        \\n        int direction = 0;\\n        int num = 1;\\n        \\n        while (right >= left && bottom >= top)\\n        {\\n            if (direction == 0) // top\\n            {\\n                for (int i = left; i <= right; i++, num++) matrix[top, i] = num;\\n                top++;\\n            }\\n            else if (direction == 1) // right\\n            {\\n                for (int i = top; i <= bottom; i++, num++) matrix[i, right] = num;\\n                right--;\\n            }\\n            else if (direction == 2) // bottom\\n            {\\n                for (int i = right; i >= left; i--, num++) matrix[bottom, i] = num;\\n                bottom--;\\n            }\\n            else if (direction == 3) // left\\n            {\\n                for (int i = bottom; i >= top; i--, num++) matrix[i, left] = num;\\n                left++;\\n            }\\n            \\n            direction = (direction + 1) % 4;\\n        }\\n        \\n        return matrix;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20791,
                "title": "c-concise-solution",
                "content": "        \\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        if (matrix.empty())\\n            return {};\\n        vector<int> res;\\n        int left, right, top, down, index;\\n        left = top = 0, down = matrix.size()-1, right = matrix[0].size()-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res.push_back(matrix[top][j]);\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res.push_back(matrix[i][right]);\\n            right--;\\n            if (top <= down) {\\n                for(int j = right; j >= left; j--)\\n                    res.push_back(matrix[down][j]);\\n                down--;\\n            }\\n            if (left <= right) {\\n                for (int i = down; i >= top; i--)\\n                    res.push_back(matrix[i][left]);\\n                left++;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        if (matrix.empty())\\n            return {};\\n        vector<int> res;\\n        int left, right, top, down, index;\\n        left = top = 0, down = matrix.size()-1, right = matrix[0].size()-1;\\n        while (left <= right && top <= down) {\\n            for (unsigned int j = left; j <= right; j++)\\n                res.push_back(matrix[top][j]);\\n            top++;\\n            for (unsigned int i = top; i <= down; i++)\\n                res.push_back(matrix[i][right]);\\n            right--;\\n            if (top <= down) {\\n                for(int j = right; j >= left; j--)\\n                    res.push_back(matrix[down][j]);\\n                down--;\\n            }\\n            if (left <= right) {\\n                for (int i = down; i >= top; i--)\\n                    res.push_back(matrix[i][left]);\\n                left++;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3506264,
                "title": "java-spiral-matrix",
                "content": "\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> answ = new ArrayList<>();\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] != -200) {\\n                    answ.add(matrix[x][y]);\\n                    matrix[x][y] = -200;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> answ = new ArrayList<>();\\n        int move[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int x = 0;\\n        int y = -1;\\n        int i = 0;\\n        boolean finish = false;\\n        while (!finish) {\\n            finish = true;\\n            while (true) {\\n                int tmpX = x;\\n                int tmpY = y;\\n                if (x + move[i % 4][0] < matrix.length && x + move[i % 4][0] > -1) x += move[i % 4][0];\\n                if (y + move[i % 4][1] < matrix[0].length && y + move[i % 4][1] > -1) y += move[i % 4][1];\\n                if (x < matrix.length && y < matrix[0].length && matrix[x][y] != -200) {\\n                    answ.add(matrix[x][y]);\\n                    matrix[x][y] = -200;\\n                    finish = false;\\n                }\\n                else {\\n                    x = tmpX;\\n                    y = tmpY;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284606,
                "title": "3-the-most-efficient-python-solution-with-short-explanation",
                "content": "#   Sulution #1\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        while matrix:\\n            res.extend(matrix.pop(0))\\n            if matrix and matrix[0]:\\n                res.extend([row.pop() for row in matrix])\\n            if matrix:\\n                res.extend(matrix.pop()[::-1])\\n            if matrix and matrix[0]:\\n                res.extend([row.pop(0) for row in matrix][::-1])\\n        return res\\n```\\n- Create an empty list called res to store the result.\\n\\n- Enter a while loop that will continue as long as there are still rows in the matrix. This loop will iterate over the matrix in a clockwise spiral order, appending the elements to res.\\n\\n- Append the first row of the matrix to res using the extend method of lists. This removes the first row from the matrix using pop(0).\\n\\n- Check if the matrix is not empty and if the first row of the matrix is not empty. If this is true, then iterate over each row in the matrix and append the last element of each row to res using a list comprehension. This removes the last element from each row using pop().\\n\\n- Check if the matrix is not empty. If this is true, then append the last row of the matrix to res in reverse order using the extend method and a slice that reverses the order of the row ([::-1]). This removes the last row from the matrix using pop().\\n\\n- Check if the matrix is not empty and if the first row of the matrix is not empty. If this is true, then iterate over each row in the matrix in reverse order and append the first element of each row to res using a list comprehension. This removes the first element from each row using pop(0).\\n\\n- Return the res list containing all the elements of the matrix in a clockwise spiral order.\\n\\n\\n# Sulution #2\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        while matrix:\\n            res += matrix.pop(0)\\n            matrix = [*zip(*matrix)][::-1]\\n        return res\\n```\\n- res = []: Initialize an empty list called res to store the result.\\n\\n- while matrix:: Loop through the matrix while it is not empty.\\n\\n- res += matrix.pop(0): Append the first row of the matrix to res and remove it from the matrix.\\n\\n- matrix = [*zip(*matrix)][::-1]: Transpose the matrix (convert rows to columns and columns to rows), reverse the order of the rows, and assign it back to matrix. This effectively rotates the matrix counterclockwise by 90 degrees.\\n\\n- return res: Return the final result.\\n\\n\\n# Sulution #3\\n\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n```\\n- If the matrix is empty or None, return an empty list.\\n\\n- Take the first row of the matrix using \"matrix.pop(0)\" and convert it to a list using [*] operator. This represents the top row of the spiral.\\n\\n- Transpose the remaining matrix using \"zip(*matrix)\" which effectively rotates the matrix clockwise by 90 degrees.\\n\\n- Reverse the order of the rows of the transposed matrix using [::-1] operator. This ensures that the next row to be traversed is the one adjacent to the bottom row of the original matrix.\\n\\n- Recursively call the \"spiralOrder\" method on the transposed and reversed matrix.\\n\\n- Concatenate the top row of the original matrix with the result of the recursive call to get the final spiral order traversal of the matrix.\\n\\n- Return the list of integers representing the spiral order traversal of the matrix.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        while matrix:\\n            res.extend(matrix.pop(0))\\n            if matrix and matrix[0]:\\n                res.extend([row.pop() for row in matrix])\\n            if matrix:\\n                res.extend(matrix.pop()[::-1])\\n            if matrix and matrix[0]:\\n                res.extend([row.pop(0) for row in matrix][::-1])\\n        return res\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        while matrix:\\n            res += matrix.pop(0)\\n            matrix = [*zip(*matrix)][::-1]\\n        return res\\n```\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466651,
                "title": "c-spiral-traverse-clean-concise",
                "content": "We just need to move right and increment rowBegin, then slide down and decrease colEnd, then traverse left and descend rowEnd, and finally sideways up and increase colBegin.\\n\\nWhen going left or up, must check if the row or column still exists or not to avoid duplication.\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>> &matrix) {\\n        vector<int> result;\\n        int rowBegin, colBegin, rowEnd, colEnd;\\n        rowBegin = colBegin = 0, rowEnd = matrix.size() - 1, colEnd = matrix[0].size() - 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            for (int j = colBegin; j <= colEnd; j++)  // Traverse Right\\n                result.push_back(matrix[rowBegin][j]);\\n            \\n            for (int i = ++rowBegin; i <= rowEnd; i++) // Traverse Down\\n                result.push_back(matrix[i][colEnd]);\\n            \\n            for (int j = --colEnd; rowBegin <= rowEnd && j >= colBegin; j--) // Traverse Left\\n                result.push_back(matrix[rowEnd][j]);\\n            \\n            for (int i = --rowEnd; colBegin <= colEnd && i >= rowBegin; i--) // Traver Up\\n                result.push_back(matrix[i][colBegin]);\\n            \\n            colBegin++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>> &matrix) {\\n        vector<int> result;\\n        int rowBegin, colBegin, rowEnd, colEnd;\\n        rowBegin = colBegin = 0, rowEnd = matrix.size() - 1, colEnd = matrix[0].size() - 1;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            for (int j = colBegin; j <= colEnd; j++)  // Traverse Right\\n                result.push_back(matrix[rowBegin][j]);\\n            \\n            for (int i = ++rowBegin; i <= rowEnd; i++) // Traverse Down\\n                result.push_back(matrix[i][colEnd]);\\n            \\n            for (int j = --colEnd; rowBegin <= rowEnd && j >= colBegin; j--) // Traverse Left\\n                result.push_back(matrix[rowEnd][j]);\\n            \\n            for (int i = --rowEnd; colBegin <= colEnd && i >= rowBegin; i--) // Traver Up\\n                result.push_back(matrix[i][colBegin]);\\n            \\n            colBegin++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867810,
                "title": "python-code-easy-to-understand-with-comments",
                "content": "```\\n\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n\\n        res = []\\n\\n        h = len(matrix)\\n        if h < 1:\\n            return res\\n        w = len(matrix[0])\\n\\n        # pointers we will use to iterate round the matrix\\n        top = 0\\n        bottom = h - 1\\n        left = 0\\n        right = w - 1\\n\\n        while top <= bottom and left <= right:\\n\\n            # TOP section: left to right\\n            l = left\\n            while l <= right:  # and left <= right: <-- we will never reach that condition\\n                res.append(matrix[top][l])\\n                l += 1\\n            # move lower\\n            # because: added all from the top area\\n            top += 1\\n\\n            # RIGHT section: top to bottom\\n            t = top\\n            while t <= bottom:  # and top <= bottom: <-- we will never reach that condition\\n                res.append(matrix[t][right])\\n                t += 1\\n            # move pointer to the left\\n            # done with right-most section\\n            right -= 1\\n\\n            # BOTTOM section: right to left\\n            # on the last of the spiral, char: right = left, therefore, r = left\\n            # so the while loop might run again\\n            r = right\\n            while r >= left and top <= bottom:\\n                res.append(matrix[bottom][r])\\n                r -= 1\\n            bottom -= 1\\n\\n            # LEFT section: bottom to top\\n            # on the last of the spiral, char: bottom = top, therefore, b = top\\n            # so the while loop might run again\\n            # that\\'s why we have the extra condition\\n            b = bottom\\n            while b >= top and left <= right:\\n                res.append(matrix[b][left])\\n                b -= 1\\n            left += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n\\n        res = []\\n\\n        h = len(matrix)\\n        if h < 1:\\n            return res\\n        w = len(matrix[0])\\n\\n        # pointers we will use to iterate round the matrix\\n        top = 0\\n        bottom = h - 1\\n        left = 0\\n        right = w - 1\\n\\n        while top <= bottom and left <= right:\\n\\n            # TOP section: left to right\\n            l = left\\n            while l <= right:  # and left <= right: <-- we will never reach that condition\\n                res.append(matrix[top][l])\\n                l += 1\\n            # move lower\\n            # because: added all from the top area\\n            top += 1\\n\\n            # RIGHT section: top to bottom\\n            t = top\\n            while t <= bottom:  # and top <= bottom: <-- we will never reach that condition\\n                res.append(matrix[t][right])\\n                t += 1\\n            # move pointer to the left\\n            # done with right-most section\\n            right -= 1\\n\\n            # BOTTOM section: right to left\\n            # on the last of the spiral, char: right = left, therefore, r = left\\n            # so the while loop might run again\\n            r = right\\n            while r >= left and top <= bottom:\\n                res.append(matrix[bottom][r])\\n                r -= 1\\n            bottom -= 1\\n\\n            # LEFT section: bottom to top\\n            # on the last of the spiral, char: bottom = top, therefore, b = top\\n            # so the while loop might run again\\n            # that\\'s why we have the extra condition\\n            b = bottom\\n            while b >= top and left <= right:\\n                res.append(matrix[b][left])\\n                b -= 1\\n            left += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210241,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n     let res = [];\\n    \\n     if (matrix.length == 0) {\\n            return res;\\n        }  \\n    \\n    let rowBegin =0;\\n    let rowEnd = matrix.length -1;\\n    let colBegin =0;\\n    let colEnd = matrix[0].length -1;\\n    \\n    while(rowBegin <= rowEnd && colBegin <= colEnd) {\\n        //right\\n        for(let i=colBegin;i<=colEnd;i++){\\n            res.push(matrix[rowBegin][i])\\n        }\\n        ++rowBegin;\\n        //bottom\\n        for(let i=rowBegin ;i<=rowEnd;i++) {\\n            res.push(matrix[i][colEnd])\\n        }\\n        --colEnd;\\n        //scan bottom right to left\\n        if (rowBegin <= rowEnd) {\\n            for(let i=colEnd; i>=colBegin;i--) {\\n                res.push(matrix[rowEnd][i])\\n            }\\n        }\\n        --rowEnd;\\n        //scan left to top\\n        if(colBegin <= colEnd){\\n             for(let i=rowEnd;i>= rowBegin; i--){\\n                res.push(matrix[i][colBegin])\\n            }\\n        }   \\n        ++colBegin;\\n     }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n     let res = [];\\n    \\n     if (matrix.length == 0) {\\n            return res;\\n        }  \\n    \\n    let rowBegin =0;\\n    let rowEnd = matrix.length -1;\\n    let colBegin =0;\\n    let colEnd = matrix[0].length -1;\\n    \\n    while(rowBegin <= rowEnd && colBegin <= colEnd) {\\n        //right\\n        for(let i=colBegin;i<=colEnd;i++){\\n            res.push(matrix[rowBegin][i])\\n        }\\n        ++rowBegin;\\n        //bottom\\n        for(let i=rowBegin ;i<=rowEnd;i++) {\\n            res.push(matrix[i][colEnd])\\n        }\\n        --colEnd;\\n        //scan bottom right to left\\n        if (rowBegin <= rowEnd) {\\n            for(let i=colEnd; i>=colBegin;i--) {\\n                res.push(matrix[rowEnd][i])\\n            }\\n        }\\n        --rowEnd;\\n        //scan left to top\\n        if(colBegin <= colEnd){\\n             for(let i=rowEnd;i>= rowBegin; i--){\\n                res.push(matrix[i][colBegin])\\n            }\\n        }   \\n        ++colBegin;\\n     }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20877,
                "title": "concise-solution-in-java",
                "content": "After each iteration the scope of each for loop is reduced. The if condition before the two last loops is to avoid duplicates.\\n\\n\\n     public List<Integer> spiralOrder(int[][] mtx) {\\n        List<Integer> ret=new LinkedList<>();\\n        if(mtx.length==0)return ret;\\n        int m=mtx.length;\\n        int n=mtx[0].length;\\n        int min=Math.min(m,n);\\n        for(int b=0;b<Math.ceil(min/2.);b++){\\n            for(int a=b;a<n-b;a++)ret.add(mtx[b][a]);\\n            for(int a=b+1;a<m-b;a++)ret.add(mtx[a][n-b-1]);\\n            if(b!=m-b-1)for(int a=n-b-2;a>=b;a--)ret.add(mtx[m-b-1][a]);\\n            if(n-b-1!=b)for(int a=m-b-2;a>b;a--)ret.add(mtx[a][b]);\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "After each iteration the scope of each for loop is reduced. The if condition before the two last loops is to avoid duplicates.\\n\\n\\n     public List<Integer> spiralOrder(int[][] mtx) {\\n        List<Integer> ret=new LinkedList<>();\\n        if(mtx.length==0)return ret;\\n        int m=mtx.length;\\n        int n=mtx[0].length;\\n        int min=Math.min(m,n);\\n        for(int b=0;b<Math.ceil(min/2.);b++){\\n            for(int a=b;a<n-b;a++)ret.add(mtx[b][a]);\\n            for(int a=b+1;a<m-b;a++)ret.add(mtx[a][n-b-1]);\\n            if(b!=m-b-1)for(int a=n-b-2;a>=b;a--)ret.add(mtx[m-b-1][a]);\\n            if(n-b-1!=b)for(int a=m-b-2;a>b;a--)ret.add(mtx[a][b]);\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3857175,
                "title": "iterative-c-approach",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION**\\n# Approach\\nInitialize variables:\\n\\nn is the number of rows in the matrix.\\nm is the number of columns in the matrix.\\nstartrow, startcol, endrow, and endcol are pointers to represent the boundaries of the current spiral.\\ntotal is the total number of elements in the matrix (n * m).\\ncount is used to keep track of the number of elements added to the result vector ans.\\nUse a while loop that runs as long as count is less than total, indicating that not all elements have been traversed yet.\\n\\nTraverse the matrix in four steps:\\na. Starting row: Traverse from left to right in the current startrow from startcol to endcol.\\nb. Ending column: Traverse from top to bottom in the current endcol from startrow to endrow.\\nc. Ending row: Traverse from right to left in the current endrow from endcol to startcol.\\nd. Starting column: Traverse from bottom to top in the current startcol from endrow to startrow.\\n\\nAfter each step, update the corresponding boundary (startrow, startcol, endrow, endcol) to move towards the center of the matrix. Also, increment the count by the number of elements traversed in that step.\\n\\nRepeat the above steps until all elements are traversed (count == total).\\n\\nReturn the ans vector containing the spiral order traversal of the matrix.\\n\\nNote: The code assumes that the input matrix is non-empty and a valid 2D matrix (i.e., all rows have the same number of elements). If the input matrix is empty or has different-sized rows, the code might encounter undefined behavior.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n         vector<int>ans;\\n        int m = matrix[0].size();\\n        int startrow=0;\\n        int startcol=0;\\n        int endrow=n-1;\\n        int endcol=m-1;\\n        int total=n*m;\\n        int count =0;\\n        while(count<total)\\n        {\\n            // starting row \\n            for(int i = startcol; count<total && i<=endcol;i++)\\n            {\\n                ans.push_back(matrix[startrow][i]);\\n                count++;\\n            }\\n            startrow++;\\n            // ending col\\n            for(int i = startrow; count<total && i<=endrow;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            // ending row\\n            for(int i = endcol; count<total && i>=startcol;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;\\n            }\\n            endrow--;\\n            // starting col\\n            for(int i = endrow; count<total && i>=startrow;i--)\\n            {\\n                ans.push_back(matrix[i][startcol]);\\n                count++;\\n            }\\n            startcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n         vector<int>ans;\\n        int m = matrix[0].size();\\n        int startrow=0;\\n        int startcol=0;\\n        int endrow=n-1;\\n        int endcol=m-1;\\n        int total=n*m;\\n        int count =0;\\n        while(count<total)\\n        {\\n            // starting row \\n            for(int i = startcol; count<total && i<=endcol;i++)\\n            {\\n                ans.push_back(matrix[startrow][i]);\\n                count++;\\n            }\\n            startrow++;\\n            // ending col\\n            for(int i = startrow; count<total && i<=endrow;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            // ending row\\n            for(int i = endcol; count<total && i>=startcol;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;\\n            }\\n            endrow--;\\n            // starting col\\n            for(int i = endrow; count<total && i>=startrow;i--)\\n            {\\n                ans.push_back(matrix[i][startcol]);\\n                count++;\\n            }\\n            startcol++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516257,
                "title": "easy-java-solution-with-proper-explanation-beats-100-in-tc",
                "content": "![Screenshot 2023-05-12 at 18.46.26.png](https://assets.leetcode.com/users/images/16dbbe6b-5966-43be-ab4c-cc1dea8d1275_1683897410.5314755.png)\\n\\n\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize four variables: l, r, t, b, representing the start and end indices of the rows and columns of the submatrix we are currently traversing.\\n2. Traverse the top row from left to right, incrementing the column index  at each step. When the traversal reaches the last column, update the t variable to move down to the next row.\\n3. Traverse the right column from top to bottom, decrementing the row index at each step. When the traversal reaches the last row, update the r variable to move to the next column.\\n4. Traverse the bottom row from right to left, decrementing the column index at each step. When the traversal reaches the first column, update the b variable to move up to the next row.\\n5. Traverse the left column from bottom to top, incrementing the row index at each step. When the traversal reaches the first row, update the l variable to move to the next column.\\n\\nRepeat steps 2-5 until all elements have been traversed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] arr) {\\n        List<Integer> res = new ArrayList<>();\\n        int b = arr.length, r = arr[0].length;\\n        int t = 0, l = 0, size = b*r;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                res.add(arr[t][i]);\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                res.add(arr[i][r-1]);\\n            }\\n            r--;\\n            if(res.size()>=size){\\n                break;\\n            }\\n            for (int i = r-1; i >= l; i--) {\\n                res.add(arr[b-1][i]);\\n            }\\n            b--;\\n            if(res.size()>=size)\\n                break;\\n            for (int i = b-1; i >= t; i--) {\\n                res.add(arr[i][l]);\\n            }\\n            l++;\\n            if(res.size()>=size)\\n                break;\\n\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] arr) {\\n        List<Integer> res = new ArrayList<>();\\n        int b = arr.length, r = arr[0].length;\\n        int t = 0, l = 0, size = b*r;\\n        while(t<=b && l<=r){\\n            for (int i = l; i < r; i++) {\\n                res.add(arr[t][i]);\\n            }\\n            t++;\\n            for (int i = t; i < b; i++) {\\n                res.add(arr[i][r-1]);\\n            }\\n            r--;\\n            if(res.size()>=size){\\n                break;\\n            }\\n            for (int i = r-1; i >= l; i--) {\\n                res.add(arr[b-1][i]);\\n            }\\n            b--;\\n            if(res.size()>=size)\\n                break;\\n            for (int i = b-1; i >= t; i--) {\\n                res.add(arr[i][l]);\\n            }\\n            l++;\\n            if(res.size()>=size)\\n                break;\\n\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507927,
                "title": "easy-understandable-approach",
                "content": "# Easy understandable APPROACH:-\\n**T.C =O(N)**\\n# Approach:-\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int strow=0;\\n        int stcol=0;\\n        int endrow=row-1;\\n        int endcol=col-1;\\n        int total=row*col;\\n        int count =0;      // to count no. of elements \\n        \\n        while(count<total)\\n        {\\n\\t\\t   // for first traverse from top of matrix i.e. from left to right   \\n            for(int i=stcol;count<total &&  i<=endcol;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++;\\n            }\\n            strow++;   // once row gets traversed increased the startRow by 1 so that it could come to next index\\n\\t\\t\\t\\n\\t\\t\\t// for traversing last column to continue spiral rotation in a matrix i.e. from top to bottom\\n            for(int i=strow;count<total && i<=endrow;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;  // once the last column gets pushed in the ans vector decrement it by 1 so that it could point to just before wala column\\n\\t\\t\\t // for traversing from right to left in a last row\\n            for(int i=endcol;count<total && i>=stcol;i--)\\n            {\\n              ans.push_back(matrix[endrow][i]);\\n                  count++;\\n            }\\n            endrow--; // decreament endRow by 1 so that it could reach above wala row\\n            for(int i=endrow;count<total && i>=strow;i--)\\n            {\\n              ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;  //increament the startingcol by 1 \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/c163df13-909e-4fed-8d68-49d19e1a2080_1683706705.6780376.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int strow=0;\\n        int stcol=0;\\n        int endrow=row-1;\\n        int endcol=col-1;\\n        int total=row*col;\\n        int count =0;      // to count no. of elements \\n        \\n        while(count<total)\\n        {\\n\\t\\t   // for first traverse from top of matrix i.e. from left to right   \\n            for(int i=stcol;count<total &&  i<=endcol;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++;\\n            }\\n            strow++;   // once row gets traversed increased the startRow by 1 so that it could come to next index\\n\\t\\t\\t\\n\\t\\t\\t// for traversing last column to continue spiral rotation in a matrix i.e. from top to bottom\\n            for(int i=strow;count<total && i<=endrow;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;  // once the last column gets pushed in the ans vector decrement it by 1 so that it could point to just before wala column\\n\\t\\t\\t // for traversing from right to left in a last row\\n            for(int i=endcol;count<total && i>=stcol;i--)\\n            {\\n              ans.push_back(matrix[endrow][i]);\\n                  count++;\\n            }\\n            endrow--; // decreament endRow by 1 so that it could reach above wala row\\n            for(int i=endrow;count<total && i>=strow;i--)\\n            {\\n              ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;  //increament the startingcol by 1 \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503815,
                "title": "beginner-friendly-simple-fastest-c-explanation-optimal-solution-beats-100",
                "content": "# Intuition\\nThe most optimal solution to this problem is the most simple and the most basic. We need to traverse the entire matrix in a spiral order. Starting from the top-left to the bottom-right and then the vice-versa.\\n\\n# Explanation\\n-> We need to iterate through the matrix until all the elements of the matrix are appended to the array. For this, we use the concept of nested loops.\\n1) The first loop traverses from the top-left corner to the top-right corner, incrementing the top at the end.\\n2) The second loop traverses from the top-right corner to the bottom-right corner, decrementing the right at the end.\\n3) The third loop traverses from the bottom-right corner to the bottom-left corner, decrementing the bottom at the end.\\n4) The last loop traverses from the bottom-left corner to the top-left corner, incrementing the left at the end.\\n\\n-> If at any instance, the size of the array is equal than the size of the matrix, we return the resultant array.\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size(),top=0,left=0,right=m-1,\\n        bottom=n-1;\\n        vector<int> v;\\n        while(v.size()!=m*n){\\n            for(int i=left;v.size()!=m*n and i<=right;i++){\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            for(int i=top;v.size()!=m*n and i<=bottom;i++){\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int i=right;v.size()!=m*n and i>=left;i--){\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            for(int i=bottom;v.size()!=m*n and i>=top;i--){\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size(),top=0,left=0,right=m-1,\\n        bottom=n-1;\\n        vector<int> v;\\n        while(v.size()!=m*n){\\n            for(int i=left;v.size()!=m*n and i<=right;i++){\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            for(int i=top;v.size()!=m*n and i<=bottom;i++){\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int i=right;v.size()!=m*n and i>=left;i--){\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            for(int i=bottom;v.size()!=m*n and i>=top;i--){\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502615,
                "title": "short-easy-clean-solution-w-clear-explanation-bfs-o-nm-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTo print the resulting matrix, we can simply simulate procedure for this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nEssentially, we want to switch to the next direction anytime that we can\\'t keep going in the existing direction. I.e: Going out of bounds or revisiting a cell. Therefore, we can run a BFS with preset direction orderings. Everytime, we attempt to go in our current direction, and if we can\\'t, we try the next directoin until we can continue in that new direction. The directions is ordered by Right, Down, Left, and Up to simulate the ordering the problem wants for the spiral matrix.\\n\\n# Complexity\\n- Time complexity: O(NM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(NM)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        Queue<Pos> q = new LinkedList<>();\\n        q.add(new Pos(0, 0, 0));\\n\\n        int[] dx = {0, 1, 0, -1};\\n        int[] dy = {1, 0, -1, 0};\\n        ans.add(matrix[0][0]);\\n        matrix[0][0] = 101;\\n        while (!q.isEmpty()) {\\n            Pos p = q.poll();\\n            int i = p.i;\\n            int j = p.j;\\n            \\n            for (int k = p.dir; k < p.dir + 4; k++) {\\n                int ix = k % 4;\\n                int ni = i + dx[ix];\\n                int nj = j + dy[ix];\\n                if (ni < 0 || ni >= matrix.length || nj < 0 || nj >= matrix[0].length) continue;\\n                if (matrix[ni][nj] == 101) continue;\\n                ans.add(matrix[ni][nj]);\\n                matrix[ni][nj] = 101;\\n                q.add(new Pos(ni, nj, ix));\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    class Pos {\\n        int i, j, dir;\\n        public Pos(int a, int b, int d) {\\n            i = a; j = b; dir = d;\\n        }\\n    }\\n}\\n```\\n\\n\\nPlease consider upvoting :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Breadth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        Queue<Pos> q = new LinkedList<>();\\n        q.add(new Pos(0, 0, 0));\\n\\n        int[] dx = {0, 1, 0, -1};\\n        int[] dy = {1, 0, -1, 0};\\n        ans.add(matrix[0][0]);\\n        matrix[0][0] = 101;\\n        while (!q.isEmpty()) {\\n            Pos p = q.poll();\\n            int i = p.i;\\n            int j = p.j;\\n            \\n            for (int k = p.dir; k < p.dir + 4; k++) {\\n                int ix = k % 4;\\n                int ni = i + dx[ix];\\n                int nj = j + dy[ix];\\n                if (ni < 0 || ni >= matrix.length || nj < 0 || nj >= matrix[0].length) continue;\\n                if (matrix[ni][nj] == 101) continue;\\n                ans.add(matrix[ni][nj]);\\n                matrix[ni][nj] = 101;\\n                q.add(new Pos(ni, nj, ix));\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    class Pos {\\n        int i, j, dir;\\n        public Pos(int a, int b, int d) {\\n            i = a; j = b; dir = d;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284596,
                "title": "one-line-python-solution-beats-89-91-88-11",
                "content": "enjoy\\n# Code\\n```\\nclass Solution:\\n    def spiralOrder(self, x: List[List[int]]) -> List[int]:\\n        \\n        return x and [*x.pop(0)] + self.spiralOrder([*zip(*x)][::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, x: List[List[int]]) -> List[int]:\\n        \\n        return x and [*x.pop(0)] + self.spiralOrder([*zip(*x)][::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120847,
                "title": "97-fast-javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/WgYpGizBdUo\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    let arr = []\\n    let r = matrix.length;\\n    let c = matrix[0].length;\\n    let direction = 0;\\n    let left = 0;\\n    let right = c-1;\\n    let bottom = 0;\\n    let top = r-1;\\n\\n    while(arr.length<r*c){\\n        if(direction == 0){\\n            for(let i = left; i<=right; i++){\\n                arr.push(matrix[bottom][i])\\n            }\\n            bottom++\\n            direction++\\n        }\\n        else if(direction == 1){\\n            for(let i = bottom; i<=top; i++){\\n                arr.push(matrix[i][right])\\n            }\\n            right--\\n            direction++\\n        }\\n        else if(direction == 2){\\n            for(let i = right; i>=left;i--){\\n                arr.push(matrix[top][i])\\n            }\\n            top--\\n            direction++\\n        }\\n        else if(direction==3){\\n            for(let i =top; i>=bottom; i--){\\n                arr.push(matrix[i][left])\\n            }\\n            left++\\n            direction++\\n        }\\n        if(direction == 4) direction = 0;\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    let arr = []\\n    let r = matrix.length;\\n    let c = matrix[0].length;\\n    let direction = 0;\\n    let left = 0;\\n    let right = c-1;\\n    let bottom = 0;\\n    let top = r-1;\\n\\n    while(arr.length<r*c){\\n        if(direction == 0){\\n            for(let i = left; i<=right; i++){\\n                arr.push(matrix[bottom][i])\\n            }\\n            bottom++\\n            direction++\\n        }\\n        else if(direction == 1){\\n            for(let i = bottom; i<=top; i++){\\n                arr.push(matrix[i][right])\\n            }\\n            right--\\n            direction++\\n        }\\n        else if(direction == 2){\\n            for(let i = right; i>=left;i--){\\n                arr.push(matrix[top][i])\\n            }\\n            top--\\n            direction++\\n        }\\n        else if(direction==3){\\n            for(let i =top; i>=bottom; i--){\\n                arr.push(matrix[i][left])\\n            }\\n            left++\\n            direction++\\n        }\\n        if(direction == 4) direction = 0;\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3046949,
                "title": "fastest-efficient-c-solution",
                "content": "**When you look at the title of the problem and visualise the test cases (and also come to know that this problem is asked in the interview rounds of many different fortune companies), it might look like ->**\\n\\n![spiral.png](https://assets.leetcode.com/users/images/1b952ff1-d211-447d-953f-f797c8dce488_1673638972.7788875.png)\\n\\n***Hypnotised right ? Don\\'t Worry, I got your back.***\\n# HAVE PATIENCE AND JUST PLAY WITH THE LOOPS FOR A WHILE WITH ME AND ITS DONE!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        //declared startrow,startcol and initialised them with 0\\n        int startrow=0;\\n        int startcol=0;\\n\\n        //declared end row and assigned it the size of the row of the matrix\\n        int endrow = matrix.size()-1;\\n\\n        //declared end column and assigned it the size of the column of the matrix\\n        int endcol = matrix[0].size()-1;\\n\\n        //declared a vector named ans of integer datatype\\n        vector<int> ans;\\n\\n        //now traverse the matrix spirally \\n        while(startrow<=endrow && startcol<=endcol){\\n            //from left to right\\n            for(int i=startcol;i<=endcol;++i){   \\n                ans.push_back(matrix[startrow][i]); \\n            }\\n            startrow++;\\n\\n            //from top to bottom\\n            for(int i=startrow;i<=endrow;++i){  \\n                ans.push_back(matrix[i][endcol]);\\n            }\\n            endcol--;\\n            \\n            ////if startrow is not less than or equal to endrow OR startcol is not less than or equal to endcol then break the loop and return (this could be easily visualised by taking different\\n            if((startrow>endrow) || (startcol>endcol)){\\n                break;\\n            }\\n\\n            //from right to left\\n            for(int i=endcol;i>=startcol;--i){ \\n                ans.push_back(matrix[endrow][i]);\\n            }\\n            endrow--;\\n\\n            //from bottom to top\\n            for(int i=endrow;i>=startrow;--i){ \\n                ans.push_back(matrix[i][startcol]);\\n            }\\n            startcol++;\\n\\n        }\\n\\n        //return the vector\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n# HAPPY CODING!\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        //declared startrow,startcol and initialised them with 0\\n        int startrow=0;\\n        int startcol=0;\\n\\n        //declared end row and assigned it the size of the row of the matrix\\n        int endrow = matrix.size()-1;\\n\\n        //declared end column and assigned it the size of the column of the matrix\\n        int endcol = matrix[0].size()-1;\\n\\n        //declared a vector named ans of integer datatype\\n        vector<int> ans;\\n\\n        //now traverse the matrix spirally \\n        while(startrow<=endrow && startcol<=endcol){\\n            //from left to right\\n            for(int i=startcol;i<=endcol;++i){   \\n                ans.push_back(matrix[startrow][i]); \\n            }\\n            startrow++;\\n\\n            //from top to bottom\\n            for(int i=startrow;i<=endrow;++i){  \\n                ans.push_back(matrix[i][endcol]);\\n            }\\n            endcol--;\\n            \\n            ////if startrow is not less than or equal to endrow OR startcol is not less than or equal to endcol then break the loop and return (this could be easily visualised by taking different\\n            if((startrow>endrow) || (startcol>endcol)){\\n                break;\\n            }\\n\\n            //from right to left\\n            for(int i=endcol;i>=startcol;--i){ \\n                ans.push_back(matrix[endrow][i]);\\n            }\\n            endrow--;\\n\\n            //from bottom to top\\n            for(int i=endrow;i>=startrow;--i){ \\n                ans.push_back(matrix[i][startcol]);\\n            }\\n            startcol++;\\n\\n        }\\n\\n        //return the vector\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760215,
                "title": "java-100-faster-time-compexity-o-m-n",
                "content": "# Intuition\\nPlease upvote if you find it useful\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int i, k = 0, l = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        int m = matrix.length, n = matrix[0].length;\\n        /*  k - starting row index\\n        m - ending row index\\n        l - starting column index\\n        n - ending column index\\n        i - iterator\\n        */\\n \\n        while (k < m && l < n) {\\n            // Print the first row from the remaining rows\\n            for (i = l; i < n; ++i) {\\n                ans.add(matrix[k][i] );\\n            }\\n            k++;\\n \\n            // Print the last column from the remaining\\n            // columns\\n            for (i = k; i < m; ++i) {\\n                ans.add(matrix[i][n - 1] );\\n            }\\n            n--;\\n \\n            // Print the last row from the remaining rows */\\n            if (k < m) {\\n                for (i = n - 1; i >= l; --i) {\\n                    ans.add(matrix[m - 1][i]);\\n                }\\n                m--;\\n            }\\n \\n            // Print the first column from the remaining\\n            // columns */\\n            if (l < n) {\\n                for (i = m - 1; i >= k; --i) {\\n                    ans.add(matrix[i][l]);\\n                }\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int i, k = 0, l = 0;\\n        List<Integer> ans = new ArrayList<>();\\n        int m = matrix.length, n = matrix[0].length;\\n        /*  k - starting row index\\n        m - ending row index\\n        l - starting column index\\n        n - ending column index\\n        i - iterator\\n        */\\n \\n        while (k < m && l < n) {\\n            // Print the first row from the remaining rows\\n            for (i = l; i < n; ++i) {\\n                ans.add(matrix[k][i] );\\n            }\\n            k++;\\n \\n            // Print the last column from the remaining\\n            // columns\\n            for (i = k; i < m; ++i) {\\n                ans.add(matrix[i][n - 1] );\\n            }\\n            n--;\\n \\n            // Print the last row from the remaining rows */\\n            if (k < m) {\\n                for (i = n - 1; i >= l; --i) {\\n                    ans.add(matrix[m - 1][i]);\\n                }\\n                m--;\\n            }\\n \\n            // Print the first column from the remaining\\n            // columns */\\n            if (l < n) {\\n                for (i = m - 1; i >= k; --i) {\\n                    ans.add(matrix[i][l]);\\n                }\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681064,
                "title": "java-100-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list=new ArrayList<>();\\n        int left=0,right=matrix[0].length;\\n        int top=0,bottom=matrix.length;\\n        while(left<right && top<bottom){\\n        for(int i=left;i<right;i++){\\n            list.add(matrix[top][i]);\\n        }\\n        top+=1;\\n        for(int i=top;i<bottom;i++){\\n            list.add(matrix[i][right-1]);\\n        }\\n        right-=1;\\n         if (!(left<right && top<bottom)){\\n                break;\\n            }\\n        for(int i=right-1;i>left;i--){\\n            list.add(matrix[bottom-1][i]);\\n        }\\n        bottom-=1;\\n        for(int i=bottom;i>=top;i--){\\n            list.add(matrix[i][left]);\\n        }\\n        left+=1;\\n    }\\n        return list;\\n    }\\n    \\n}\\n```\\n**Pls upvote if u like it**",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list=new ArrayList<>();\\n        int left=0,right=matrix[0].length;\\n        int top=0,bottom=matrix.length;\\n        while(left<right && top<bottom){\\n        for(int i=left;i<right;i++){\\n            list.add(matrix[top][i]);\\n        }\\n        top+=1;\\n        for(int i=top;i<bottom;i++){\\n            list.add(matrix[i][right-1]);\\n        }\\n        right-=1;\\n         if (!(left<right && top<bottom)){\\n                break;\\n            }\\n        for(int i=right-1;i>left;i--){\\n            list.add(matrix[bottom-1][i]);\\n        }\\n        bottom-=1;\\n        for(int i=bottom;i>=top;i--){\\n            list.add(matrix[i][left]);\\n        }\\n        left+=1;\\n    }\\n        return list;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477682,
                "title": "easy-java-solution-0ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        int top = 0,left = 0,bottom = matrix.length -1,right = matrix[0].length -1;\\n        while(top <= bottom && left <= right){\\n\\t\\t\\t//Top Row\\n            for(int i = left ; i <= right ; i++){\\n                al.add(matrix[top][i]);\\n            }\\n            top++;\\n\\t\\t\\t//Right Column\\n            for(int i = top ; i <= bottom; i++){\\n                al.add(matrix[i][right]);\\n            }\\n            right--;\\n\\t\\t\\t//Bottom Row\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    al.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\t\\t\\t//Left Column\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    al.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        int top = 0,left = 0,bottom = matrix.length -1,right = matrix[0].length -1;\\n        while(top <= bottom && left <= right){\\n\\t\\t\\t//Top Row\\n            for(int i = left ; i <= right ; i++){\\n                al.add(matrix[top][i]);\\n            }\\n            top++;\\n\\t\\t\\t//Right Column\\n            for(int i = top ; i <= bottom; i++){\\n                al.add(matrix[i][right]);\\n            }\\n            right--;\\n\\t\\t\\t//Bottom Row\\n            if(top <= bottom){\\n                for(int i = right; i >= left; i --){\\n                    al.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\t\\t\\t//Left Column\\n            if(left <= right){\\n                for(int i = bottom; i >= top; i --){\\n                    al.add(matrix[i][left]);\\n                }\\n                left++;\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467152,
                "title": "c-simple-solution-using-for-loops-with-comments-for-understanding",
                "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int> output;\\n        int l1=matrix.size();\\n        int l2=matrix[0].size();\\n        \\n        int top,bottom,left,right;\\n        // top and bottom are used to keep the count of rows.\\n        top = 0;\\n        bottom = l1-1;\\n        \\n        // left and right are used to keep count of the columns.\\n        left = 0;\\n        right = l2-1;\\n        \\n        //int length = matrix.size()*matrix[0].size(); //total no.of elements that needs to be present in the output\\n        \\n        while(top<=bottom && left<=right && output.size()<l1*l2)\\n        {\\n            for(int j=left; j<=right; j++) //traversal of top row\\n            { output.push_back(matrix[top][j]);}\\n            \\n            \\n            top++; //increment of top by 1\\n            \\n            for(int i=top; i<=bottom; i++) //traversal of last column\\n            { output.push_back(matrix[i][right]);}\\n            \\n             right--;//decrement of right by 1\\n            \\n            for(int j=right; top<=bottom && j>=left; j--) //traversal of last row\\n            {output.push_back(matrix[bottom][j]);}\\n            \\n             bottom--;//decrement of bottom by 1\\n            \\n            for(int i=bottom; left<=right && i>=top; i--) //traversal of first column\\n            {  output.push_back(matrix[i][left]);}\\n            \\n            left++; //increment of left by 1\\n            \\n            // after this the process again repeats..\\n        }\\n        \\n        return output;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int> output;\\n        int l1=matrix.size();\\n        int l2=matrix[0].size();\\n        \\n        int top,bottom,left,right;\\n        // top and bottom are used to keep the count of rows.\\n        top = 0;\\n        bottom = l1-1;\\n        \\n        // left and right are used to keep count of the columns.\\n        left = 0;\\n        right = l2-1;\\n        \\n        //int length = matrix.size()*matrix[0].size(); //total no.of elements that needs to be present in the output\\n        \\n        while(top<=bottom && left<=right && output.size()<l1*l2)\\n        {\\n            for(int j=left; j<=right; j++) //traversal of top row\\n            { output.push_back(matrix[top][j]);}",
                "codeTag": "Java"
            },
            {
                "id": 20830,
                "title": "simple-structed-java-solution-with-o-m-n-complexity",
                "content": "The idea is the same as the solution on [programcreek][1]. \\nCode is long, but the idea and structure is simple.\\nFeast yourself!\\n\\n    public class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if (matrix.length == 0) return list;\\n        \\n        int m = matrix.length; //width\\n        int n = matrix[0].length; //height\\n        int x = 0, y = 0;\\n        \\n        while (m > 0 && n > 0) {\\n            //If there is only one row or one column, then just put this row/column into the list\\n            if (m == 1) {\\n                for (int i = 0; i < n; i++) {\\n                    list.add(matrix[x][y++]);\\n                }\\n                break;\\n            } else if (n == 1) {\\n                for (int i = 0; i < m; i++) {\\n                    list.add(matrix[x++][y]);\\n                }\\n                break;\\n            }\\n            \\n            //left to right\\n            for (int i = 0; i < n - 1; i++) {\\n                list.add(matrix[x][y++]);\\n            } \\n            \\n            //up to down\\n            for (int i = 0; i < m - 1; i++) {\\n                list.add(matrix[x++][y]);\\n            }\\n            \\n            //right to left\\n            for (int i = 0; i < n - 1; i++) {\\n                list.add(matrix[x][y--]);\\n            } \\n            \\n            //down to up\\n            for (int i = 0; i < m - 1; i++) {\\n                list.add(matrix[x--][y]);\\n            }\\n            \\n            m = m - 2;\\n            n = n - 2;\\n            x++;\\n            y++;\\n        }\\n        return list;\\n    }\\n}\\n\\n\\n  [1]: http://www.programcreek.com/2013/01/leetcode-spiral-matrix-java/",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if (matrix.length == 0) return list;\\n        \\n        int m = matrix.length; //width\\n        int n = matrix[0].length; //height\\n        int x = 0, y = 0;\\n        \\n        while (m > 0 && n > 0) {\\n            //If there is only one row or one column, then just put this row/column into the list\\n            if (m == 1) {\\n                for (int i = 0; i < n; i++) {\\n                    list.add(matrix[x][y++]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4047753,
                "title": "intuitive-c-recursive-approach-for-beginners",
                "content": "# Intuition\\nIdentify the pattern, specifically when the change in direction will occur\\n\\nPLEASE UPVOTE IF YOU FIND THIS HELPFUL\\n\\n# Approach\\nUnderstand the factors to consider:\\n- Position of element\\n- Direction currently moved\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(1) if global vector not considered\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int x,y;\\n    vector<vector<int>> arr;\\n    vector<int> vec;\\n\\n    void solve(int i,int j,int dir){\\n        if(arr[i][j]==-101) return;\\n        vec.push_back(arr[i][j]);\\n        cout<<arr[i][j]<<endl;\\n        arr[i][j]=-101;\\n        if(j<y && ((dir==0 && arr[i][j+1]!=-101) || (dir==3 && (i==0 || arr[i-1][j]==-101)))) solve(i,j+1,0);\\n        else if(i<x && ((dir==1 && arr[i+1][j]!=-101) || (dir==0 && (j==y || arr[i][j+1]==-101)))) solve(i+1,j,1);\\n        else if(j>0 && ((dir==2 && arr[i][j-1]!=-101) || (dir==1 && (i==x || arr[i+1][j]==-101)))) solve(i,j-1,2);\\n        else if(i>0 && ((dir==3 && arr[i-1][j]!=-101) || (dir==2 && (j==0 || arr[i][j-1]==-101)))) solve(i-1,j,3);\\n    }\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        arr=matrix;\\n        x=arr.size()-1;\\n        y=arr[0].size()-1;\\n        solve(0,0,0);\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x,y;\\n    vector<vector<int>> arr;\\n    vector<int> vec;\\n\\n    void solve(int i,int j,int dir){\\n        if(arr[i][j]==-101) return;\\n        vec.push_back(arr[i][j]);\\n        cout<<arr[i][j]<<endl;\\n        arr[i][j]=-101;\\n        if(j<y && ((dir==0 && arr[i][j+1]!=-101) || (dir==3 && (i==0 || arr[i-1][j]==-101)))) solve(i,j+1,0);\\n        else if(i<x && ((dir==1 && arr[i+1][j]!=-101) || (dir==0 && (j==y || arr[i][j+1]==-101)))) solve(i+1,j,1);\\n        else if(j>0 && ((dir==2 && arr[i][j-1]!=-101) || (dir==1 && (i==x || arr[i+1][j]==-101)))) solve(i,j-1,2);\\n        else if(i>0 && ((dir==3 && arr[i-1][j]!=-101) || (dir==2 && (j==0 || arr[i][j-1]==-101)))) solve(i-1,j,3);\\n    }\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        arr=matrix;\\n        x=arr.size()-1;\\n        y=arr[0].size()-1;\\n        solve(0,0,0);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3503991,
                "title": "100-fast-solution-of-spiral-matrix-problem-2-d-array",
                "content": "# Intuition\\n\\n\\n# Approach\\n. first of all initialise row, column and total [i.e, row*column]\\n. then intialise the indeces of starting row, starting column,     ending row and ending column.\\n\\n     1. Print the starting row\\n     2. Print the ending column\\n     3. Print the ending row\\n     4. Print the starting column\\n     \\n. After that push back the matrix[row][column] for all the above iterations by cheching count < total of the matrix and then simply increment the count value\\n\\n# Complexity\\n- Time complexity: O(nm) [i.e, n = row and m = column]\\n\\n\\n- Space complexity: O(nm)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int cnt = 0;\\n        int total = row*col;\\n        \\n        //index initialisation\\n        int sR = 0;  // starting row\\n        int sC = 0;  // starting column\\n        int eR = row -1;  // ending row\\n        int eC = col-1;   // ending column\\n\\n        while(cnt < total){\\n\\n            //printing starting row\\n            for(int index = sC; cnt < total && index <= eC; index++){\\n               ans.push_back(matrix[sR][index]);\\n               cnt++;\\n            }\\n            sR++;\\n\\n            //printing ending column\\n            for(int index = sR; cnt < total && index <= eR; index++){\\n               ans.push_back(matrix[index][eC]);\\n               cnt++;\\n            }\\n            eC--;\\n\\n            //printing ending row\\n            for(int index = eC; cnt < total && index >= sC; index--){\\n               ans.push_back(matrix[eR][index]);\\n               cnt++;\\n            }\\n            eR--;\\n\\n            //printing starting column\\n            for(int index = eR; cnt < total && index >= sR; index--){\\n               ans.push_back(matrix[index][sC]);\\n               cnt++;\\n            }\\n            sC++;\\n       }\\n\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int cnt = 0;\\n        int total = row*col;\\n        \\n        //index initialisation\\n        int sR = 0;  // starting row\\n        int sC = 0;  // starting column\\n        int eR = row -1;  // ending row\\n        int eC = col-1;   // ending column\\n\\n        while(cnt < total){\\n\\n            //printing starting row\\n            for(int index = sC; cnt < total && index <= eC; index++){\\n               ans.push_back(matrix[sR][index]);\\n               cnt++;\\n            }\\n            sR++;\\n\\n            //printing ending column\\n            for(int index = sR; cnt < total && index <= eR; index++){\\n               ans.push_back(matrix[index][eC]);\\n               cnt++;\\n            }\\n            eC--;\\n\\n            //printing ending row\\n            for(int index = eC; cnt < total && index >= sC; index--){\\n               ans.push_back(matrix[eR][index]);\\n               cnt++;\\n            }\\n            eR--;\\n\\n            //printing starting column\\n            for(int index = eR; cnt < total && index >= sR; index--){\\n               ans.push_back(matrix[index][sC]);\\n               cnt++;\\n            }\\n            sC++;\\n       }\\n\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503117,
                "title": "java-easy-solution-beginner-friendly-step-by-step-procees-concise-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart with the outermost layer of the matrix and then move inward towards the center. To traverse each layer in a spiral order, we make use of four pointers - top, bottom, left, and right. We start at the top-left corner of the matrix and move towards the right until we reach the top-right corner. Then, we move downwards towards the bottom-right corner, then towards the bottom-left corner, and finally towards the top-left corner. We repeat this process for each layer until we reach the center of the matrix\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize four pointers - l (left), r (right), t (top), and b (bottom) to represent the boundaries of the current layer of the matrix being traversed.\\n- While the top and bottom boundaries do not cross each other and the left and right boundaries do not cross each other, do the following:\\na. Traverse the top boundary from left to right and add the elements to the result list.\\nb. Traverse the right boundary from top to bottom and add the elements to the result list.\\nc. Traverse the bottom boundary from right to left and add the elements to the result list.\\nd. Traverse the left boundary from bottom to top and add the elements to the result list.\\ne. Update the pointers to move to the next layer of the matrix.\\n- Return the result list.\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> l1 = new ArrayList<Integer>();\\n        //left\\n        int l=0,b=matrix.length-1,r=matrix[0].length-1,t=0;\\n        while(l<=r || t<=b){\\n                if(t<=b){\\n                    for(int i=l;i<=r;i++)\\n                    l1.add(matrix[t][i]);\\n                    t++;\\n                }\\n                if(l<=r){\\n                    for(int i=t;i<=b;i++)\\n                    l1.add(matrix[i][r]);\\n                    r--;\\n                }\\n                if(t<=b){\\n                    for(int i=r;i>=l;i--)\\n                    l1.add(matrix[b][i]);\\n                    b--;\\n                }\\n                if(l<=r){\\n                    for(int i=b;i>=t;i--)\\n                    l1.add(matrix[i][l]);\\n                    l++;\\n                }\\n        }\\n        return l1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> l1 = new ArrayList<Integer>();\\n        //left\\n        int l=0,b=matrix.length-1,r=matrix[0].length-1,t=0;\\n        while(l<=r || t<=b){\\n                if(t<=b){\\n                    for(int i=l;i<=r;i++)\\n                    l1.add(matrix[t][i]);\\n                    t++;\\n                }\\n                if(l<=r){\\n                    for(int i=t;i<=b;i++)\\n                    l1.add(matrix[i][r]);\\n                    r--;\\n                }\\n                if(t<=b){\\n                    for(int i=r;i>=l;i--)\\n                    l1.add(matrix[b][i]);\\n                    b--;\\n                }\\n                if(l<=r){\\n                    for(int i=b;i>=t;i--)\\n                    l1.add(matrix[i][l]);\\n                    l++;\\n                }\\n        }\\n        return l1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163347,
                "title": "c-solution-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First we will iterate in to first row from left to right push back all the elements into a vector. After iterating, we change the top to second row (top++).\\n- Then we will iterate from new top to bottom and push back only right most elements of each row. After iterating, we change the right to second last column (right--).\\n- Then we will iterate in bottom row from right to left and pushback all the elements from new right to left. After iterating, we change the bottom to second last row (bottom--).\\n- Then we will iterate from new bottom to new top and push back only left most element. After iterating, we change the left to second column (left++).\\n- Repeat all these steps until left = right and top = bottom.\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int top=0,bottom=matrix.size()-1,right=matrix[0].size()-1,left=0,direction=0;\\n        vector<int>res;\\n        while(top<=bottom and left<=right)\\n        {\\n            if(direction==0){\\n\\n                for(int i=left;i<=right;i++)\\n                res.push_back(matrix[top][i]);\\n                top++;\\n            }\\n            else if(direction==1){\\n\\n                for(int i=top;i<=bottom;i++)\\n                res.push_back(matrix[i][right]);\\n                right--;\\n            }\\n            else if(direction==2){\\n\\n                for(int i=right;i>=left;i--)\\n                res.push_back(matrix[bottom][i]);\\n                bottom--;\\n            }\\n            else if(direction==3){\\n\\n                for(int i=bottom;i>=top;i--)\\n                res.push_back(matrix[i][left]);\\n                left++;\\n            }\\n            direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int top=0,bottom=matrix.size()-1,right=matrix[0].size()-1,left=0,direction=0;\\n        vector<int>res;\\n        while(top<=bottom and left<=right)\\n        {\\n            if(direction==0){\\n\\n                for(int i=left;i<=right;i++)\\n                res.push_back(matrix[top][i]);\\n                top++;\\n            }\\n            else if(direction==1){\\n\\n                for(int i=top;i<=bottom;i++)\\n                res.push_back(matrix[i][right]);\\n                right--;\\n            }\\n            else if(direction==2){\\n\\n                for(int i=right;i>=left;i--)\\n                res.push_back(matrix[bottom][i]);\\n                bottom--;\\n            }\\n            else if(direction==3){\\n\\n                for(int i=bottom;i>=top;i--)\\n                res.push_back(matrix[i][left]);\\n                left++;\\n            }\\n            direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161179,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int left = 0;\\n        int top = 0;\\n        int right = matrix[0].size() - 1;\\n        int bottom = matrix.size() - 1;\\n        \\n        vector<int> result;\\n        \\n        while (top <= bottom && left <= right) {\\n            for (int j = left; j <= right; j++) {\\n                result.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int j = right; j >= left; j--) {\\n                    result.push_back(matrix[bottom][j]);\\n                }\\n            }\\n            bottom--;\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n            }\\n            left++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = matrix[0]\\n        cur_i, cur_j = 0, len(matrix[0]) - 1\\n        dist_x, dist_y = -(len(matrix[0]) - 1), len(matrix) - 1\\n        step_x, step_y = -1, 1\\n        while True:\\n            if dist_y == 0:\\n                break\\n            else:\\n                for i in range(0, dist_y, step_y):\\n                    cur_i += step_y\\n                    res.append(matrix[cur_i][cur_j])\\n                dist_y = -dist_y + step_y\\n                step_y *= -1\\n            if dist_x == 0:\\n                break\\n            else:\\n                for i in range(0, dist_x, step_x):\\n                    cur_j += step_x\\n                    res.append(matrix[cur_i][cur_j])\\n                dist_x = -dist_x + step_x\\n                step_x *= -1\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int rb = 0;\\n        int re = matrix.length - 1;\\n        int cb = 0;\\n        int ce = matrix[0].length - 1;\\n\\n        while (rb <= re && cb <= ce) {\\n            for (int j = cb; j <= ce; j++) {\\n                list.add(matrix[rb][j]);\\n            }\\n            rb++;\\n\\n            for (int i = rb; i <= re; i++) {\\n                list.add(matrix[i][ce]);\\n            }\\n            ce--;\\n\\n            if (rb <= re) {\\n                for (int j = ce; j >= cb; j--) {\\n                    list.add(matrix[re][j]);\\n                }\\n            }\\n            re--;\\n\\n            if (cb <= ce) {\\n                for (int i = re; i >= rb; i--) {\\n                    list.add(matrix[i][cb]);\\n                }\\n            }\\n            cb++;\\n        }\\n\\n        return list;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int left = 0;\\n        int top = 0;\\n        int right = matrix[0].size() - 1;\\n        int bottom = matrix.size() - 1;\\n        \\n        vector<int> result;\\n        \\n        while (top <= bottom && left <= right) {\\n            for (int j = left; j <= right; j++) {\\n                result.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                result.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if (top <= bottom) {\\n                for (int j = right; j >= left; j--) {\\n                    result.push_back(matrix[bottom][j]);\\n                }\\n            }\\n            bottom--;\\n            \\n            if (left <= right) {\\n                for (int i = bottom; i >= top; i--) {\\n                    result.push_back(matrix[i][left]);\\n                }\\n            }\\n            left++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = matrix[0]\\n        cur_i, cur_j = 0, len(matrix[0]) - 1\\n        dist_x, dist_y = -(len(matrix[0]) - 1), len(matrix) - 1\\n        step_x, step_y = -1, 1\\n        while True:\\n            if dist_y == 0:\\n                break\\n            else:\\n                for i in range(0, dist_y, step_y):\\n                    cur_i += step_y\\n                    res.append(matrix[cur_i][cur_j])\\n                dist_y = -dist_y + step_y\\n                step_y *= -1\\n            if dist_x == 0:\\n                break\\n            else:\\n                for i in range(0, dist_x, step_x):\\n                    cur_j += step_x\\n                    res.append(matrix[cur_i][cur_j])\\n                dist_x = -dist_x + step_x\\n                step_x *= -1\\n        return res\\n```\n```Java []\\nclass Solution {\\n\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int rb = 0;\\n        int re = matrix.length - 1;\\n        int cb = 0;\\n        int ce = matrix[0].length - 1;\\n\\n        while (rb <= re && cb <= ce) {\\n            for (int j = cb; j <= ce; j++) {\\n                list.add(matrix[rb][j]);\\n            }\\n            rb++;\\n\\n            for (int i = rb; i <= re; i++) {\\n                list.add(matrix[i][ce]);\\n            }\\n            ce--;\\n\\n            if (rb <= re) {\\n                for (int j = ce; j >= cb; j--) {\\n                    list.add(matrix[re][j]);\\n                }\\n            }\\n            re--;\\n\\n            if (cb <= ce) {\\n                for (int i = re; i >= rb; i--) {\\n                    list.add(matrix[i][cb]);\\n                }\\n            }\\n            cb++;\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108009,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<int> SpiralOrder(int[][] matrix) {\\n        var width = matrix[0].Length;\\n        var height = matrix.Length;\\n        var lenght = width * height;\\n\\n        var result = new List<int>(lenght);\\n        var x = 0;\\n        var y = 0;\\n        var dy = 1;\\n        var dx = 1;\\n\\n        while(result.Count < lenght)\\n        {\\n            result.Add(matrix[y][x]);\\n\\n            if (y == dy - 1 && x < width - dx)\\n            {\\n                x++;\\n            }\\n            else if (x == width - dx && y < height - dy)\\n            {\\n                y++;\\n            }\\n            else if (x > dx - 1)\\n            {\\n                x--;\\n            }\\n            else if (y > dy)\\n            {\\n                y--;\\n                if (y == dy && x == dx - 1)\\n                {\\n                    dx++;\\n                    dy++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> SpiralOrder(int[][] matrix) {\\n        var width = matrix[0].Length;\\n        var height = matrix.Length;\\n        var lenght = width * height;\\n\\n        var result = new List<int>(lenght);\\n        var x = 0;\\n        var y = 0;\\n        var dy = 1;\\n        var dx = 1;\\n\\n        while(result.Count < lenght)\\n        {\\n            result.Add(matrix[y][x]);\\n\\n            if (y == dy - 1 && x < width - dx)\\n            {\\n                x++;\\n            }\\n            else if (x == width - dx && y < height - dy)\\n            {\\n                y++;\\n            }\\n            else if (x > dx - 1)\\n            {\\n                x--;\\n            }\\n            else if (y > dy)\\n            {\\n                y--;\\n                if (y == dy && x == dx - 1)\\n                {\\n                    dx++;\\n                    dy++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100997,
                "title": "beats-100-o-n-n-each-approach-full-explained-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to print a pattern in spiral order, which means we have to make a circular round like a spiral.generally matrix problems are solved in n*n complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find the size of matrix and for column, find the length of any row.\\n2. declare variables like startingCol=0, endingCol= length -1, startingRow=0, endingRow= length-1.\\n3. first we will print first row, by moving from startingCol to endingcol. and increase startingrow by 1, so that we can print next row in second iteration.\\n4. then, we will print last column, by moving from startingrow to endingrow and decrease endingCol by 1 so that we can to next inner col.\\n5. then we will print last row, by moving from endingCol to startingcol. and decrease endingRow by 1, so that we can move to  next inner row in next iteration.\\n6. then  we will print first col, by moving from endingRow to startingrow, and increase startingCol by 1, so that we can move to next col in next iteration.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& nums) {\\n        int row= nums.size();\\n        int col= nums[0].size();\\n        int end= row*col -1, count=0;\\n        vector<int>v;\\n        int startingRow=0, startingCol=0,endingRow= row-1, endingCol= col-1;\\n\\n        while(count<= end)\\n        {\\n            for first row\\n            for(int i= startingCol;count <= end && i<= endingCol;i++)\\n            {\\n                v.push_back(nums[startingRow][i]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            //last column \\n            for(int i= startingRow;count <= end && i<= endingRow;i++)\\n            {\\n                v.push_back(nums[i][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // last row\\n            for(int i= endingCol;count <= end && i>=startingCol;i--)\\n            {\\n                v.push_back(nums[endingRow][i]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            first column \\n            for(int i= endingRow;count <= end && i>= startingRow;i--)\\n            {\\n                v.push_back(nums[i][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& nums) {\\n        int row= nums.size();\\n        int col= nums[0].size();\\n        int end= row*col -1, count=0;\\n        vector<int>v;\\n        int startingRow=0, startingCol=0,endingRow= row-1, endingCol= col-1;\\n\\n        while(count<= end)\\n        {\\n            for first row\\n            for(int i= startingCol;count <= end && i<= endingCol;i++)\\n            {\\n                v.push_back(nums[startingRow][i]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            //last column \\n            for(int i= startingRow;count <= end && i<= endingRow;i++)\\n            {\\n                v.push_back(nums[i][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // last row\\n            for(int i= endingCol;count <= end && i>=startingCol;i--)\\n            {\\n                v.push_back(nums[endingRow][i]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            first column \\n            for(int i= endingRow;count <= end && i>= startingRow;i--)\\n            {\\n                v.push_back(nums[i][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094313,
                "title": "best-solution",
                "content": "#\\n\\n# Complexity\\n- Time complexity:\\n$$O(R*C)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector <int> ans;\\n        int R = matrix.size(), C = matrix[0].size();\\n        int t = 0, r = C - 1, b = R - 1, l = 0;\\n        while (t <= b && l <= r) {\\n            for (int i = l; i <= r; i++) \\n                ans.push_back(matrix[t][i]);\\n            t++;\\n            for (int j = t; j <= b; j++) \\n                ans.push_back(matrix[j][r]);\\n            r--;\\n            if (t <= b) {\\n                for (int m = r; m >= l; m--) \\n                ans.push_back(matrix[b][m]);\\n            b--;\\n            }\\n            if (l <= r) {\\n                for (int n = b; n >= t; n--) \\n                ans.push_back(matrix[n][l]);\\n            l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector <int> ans;\\n        int R = matrix.size(), C = matrix[0].size();\\n        int t = 0, r = C - 1, b = R - 1, l = 0;\\n        while (t <= b && l <= r) {\\n            for (int i = l; i <= r; i++) \\n                ans.push_back(matrix[t][i]);\\n            t++;\\n            for (int j = t; j <= b; j++) \\n                ans.push_back(matrix[j][r]);\\n            r--;\\n            if (t <= b) {\\n                for (int m = r; m >= l; m--) \\n                ans.push_back(matrix[b][m]);\\n            b--;\\n            }\\n            if (l <= r) {\\n                for (int n = b; n >= t; n--) \\n                ans.push_back(matrix[n][l]);\\n            l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785141,
                "title": "simple-java-solution-using-switch-case-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        \\n        List<Integer> res = new ArrayList<Integer>(); \\n        if (matrix.length == 0) {\\n            return res;\\n        }\\n        \\n        int rowStart = 0;\\n        int rowEnd = matrix.length-1;\\n        int colStart = 0;\\n        int colEnd = matrix[0].length - 1;\\n        int direction = 0;\\n    \\n    while(rowStart <= rowEnd && colStart <= colEnd) {\\n        switch(direction) {      \\n            case 0:   \\n                for(int j = colStart; j <= colEnd; j++)           //Right\\n                    res.add(matrix[rowStart][j]);\\n                rowStart++;\\n                break;\\n            case 1:                                              //Down\\n                for(int j = rowStart; j <=rowEnd; j++) \\n                    res.add(matrix[j][colEnd])    ;\\n                colEnd--;\\n                break;\\n            case 2:\\n                for(int j = colEnd; j >= colStart; j --)          //Left\\n                    res.add(matrix[rowEnd][j]);            \\n                rowEnd--;\\n                break;\\n            case 3:\\n                for(int j = rowEnd; j >= rowStart; j--)           //up\\n                    res.add(matrix[j][colStart]);\\n                colStart++;  \\n                break;\\n        }                                   \\n        direction = (direction+1)%4;                                                            \\n    }   \\n    return res;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        \\n        List<Integer> res = new ArrayList<Integer>(); \\n        if (matrix.length == 0) {\\n            return res;\\n        }\\n        \\n        int rowStart = 0;\\n        int rowEnd = matrix.length-1;\\n        int colStart = 0;\\n        int colEnd = matrix[0].length - 1;\\n        int direction = 0;\\n    \\n    while(rowStart <= rowEnd && colStart <= colEnd) {\\n        switch(direction) {      \\n            case 0:   \\n                for(int j = colStart; j <= colEnd; j++)           //Right\\n                    res.add(matrix[rowStart][j]);\\n                rowStart++;\\n                break;\\n            case 1:                                              //Down\\n                for(int j = rowStart; j <=rowEnd; j++) \\n                    res.add(matrix[j][colEnd])    ;\\n                colEnd--;\\n                break;\\n            case 2:\\n                for(int j = colEnd; j >= colStart; j --)          //Left\\n                    res.add(matrix[rowEnd][j]);            \\n                rowEnd--;\\n                break;\\n            case 3:\\n                for(int j = rowEnd; j >= rowStart; j--)           //up\\n                    res.add(matrix[j][colStart]);\\n                colStart++;  \\n                break;\\n        }                                   \\n        direction = (direction+1)%4;                                                            \\n    }   \\n    return res;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554377,
                "title": "spiral-matrix-easiest-approach",
                "content": "\\n\\n    class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans= new ArrayList<>();\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        int total = row * col;\\n        int count = 0;\\n\\n        // initialise the indexes;\\n\\t\\t\\n        int startRow = 0;\\n        int endCol = col - 1;\\n        int endRow = row - 1;\\n        int startCol = 0;\\n\\n        while(count < total){\\n\\n            //print startRow\\n            for(int idx = startCol; count < total && idx <= endCol; idx++){\\n                ans.add(matrix[startRow][idx]);\\n                count++;\\n            }\\n            startRow++;\\n\\n            // print lastCol\\n            for(int idx = startRow; count < total && idx <= endRow; idx++){\\n                ans.add(matrix[idx][endCol]);\\n                count++;\\n            }\\n            endCol--;\\n\\n            // print lastRow\\n\\n            for(int idx = endCol; count < total && idx >= startCol; idx--){\\n                ans.add(matrix[endRow][idx]);\\n                count++;\\n            }\\n            endRow--;\\n\\n            // print firstCol\\n\\n            for(int idx = endRow; count < total && idx >= startRow; idx--){\\n                ans.add(matrix[idx][startCol]);\\n                count++;\\n            }\\n            startCol++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans= new ArrayList<>();\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        int total = row * col;\\n        int count = 0;\\n\\n        // initialise the indexes;\\n\\t\\t\\n        int startRow = 0;\\n        int endCol = col - 1;\\n        int endRow = row - 1;\\n        int startCol = 0;\\n\\n        while(count < total){\\n\\n            //print startRow\\n            for(int idx = startCol; count < total && idx <= endCol; idx++){\\n                ans.add(matrix[startRow][idx]);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1970215,
                "title": "java-100-fasteest-with-best-explanation",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n           List<Integer> list= new ArrayList<>();\\n        if(matrix.length==0){\\n            return list;\\n        }\\n        int rowBegin=0;\\n        int rowEnd= matrix.length-1;\\n        int colBegin= 0;\\n        int colEnd= matrix[0].length-1;\\n        \\n        \\n       \\n        while(rowBegin<= rowEnd && colBegin<= colEnd){\\n         \\n            // printing 1,2,3\\n            for(int i= colBegin; i<=colEnd; i++){\\n                list.add(matrix[rowBegin][i]);\\n            }\\n            \\n            //moving downward\\n            rowBegin++;\\n            \\n            //printing last element of 1st row that is we are printing 6 and than travsing to downward\\n            for(int i= rowBegin; i<=rowEnd; i++){\\n                list.add(matrix[i][colEnd]);\\n            }\\n           \\n            //know for traversing towards left side\\n            colEnd--;\\n            \\n            //traversing towards left side of in last row\\n            if(rowBegin<=rowEnd){\\n                for(int i= colEnd; i>=colBegin; i--){\\n                    list.add(matrix[rowEnd][i]);\\n                } \\n            }\\n            \\n            //than traversing upward from last row\\n            rowEnd--;\\n            \\n            // traversing to right side again\\n            if(colBegin<=colEnd){\\n                for(int i=rowEnd; i>=rowBegin; i--){\\n                    list.add(matrix[i][colBegin]);\\n                }\\n            }\\n            colBegin++;\\n        }\\n        return list;\\n    }\\n}\\n```// if you feel that you understood please UPVOTE .  IT gives me motivation to do more",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n           List<Integer> list= new ArrayList<>();\\n        if(matrix.length==0){\\n            return list;\\n        }\\n        int rowBegin=0;\\n        int rowEnd= matrix.length-1;\\n        int colBegin= 0;\\n        int colEnd= matrix[0].length-1;\\n        \\n        \\n       \\n        while(rowBegin<= rowEnd && colBegin<= colEnd){\\n         \\n            // printing 1,2,3\\n            for(int i= colBegin; i<=colEnd; i++){\\n                list.add(matrix[rowBegin][i]);\\n            }\\n            \\n            //moving downward\\n            rowBegin++;\\n            \\n            //printing last element of 1st row that is we are printing 6 and than travsing to downward\\n            for(int i= rowBegin; i<=rowEnd; i++){\\n                list.add(matrix[i][colEnd]);\\n            }\\n           \\n            //know for traversing towards left side\\n            colEnd--;\\n            \\n            //traversing towards left side of in last row\\n            if(rowBegin<=rowEnd){\\n                for(int i= colEnd; i>=colBegin; i--){\\n                    list.add(matrix[rowEnd][i]);\\n                } \\n            }\\n            \\n            //than traversing upward from last row\\n            rowEnd--;\\n            \\n            // traversing to right side again\\n            if(colBegin<=colEnd){\\n                for(int i=rowEnd; i>=rowBegin; i--){\\n                    list.add(matrix[i][colBegin]);\\n                }\\n            }\\n            colBegin++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941436,
                "title": "spiral-matrix-c-simple-solution",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        vector<int> res;\\n        \\n        int left=0;\\n        int right=n-1;\\n        int upper=0;\\n        int lower=m-1;\\n        \\n        while(left<=right && upper<=lower){\\n            for(int i=left;i<=right;i++){\\n                 res.push_back(matrix[upper][i]);\\n            }\\n            upper++;\\n            if(upper>lower)break;\\n            \\n            for(int i=upper;i<=lower;i++){\\n             res.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            if(left>right)break;\\n            \\n            for(int i=right;i>=left;i--){\\n                res.push_back(matrix[lower][i]);\\n            }\\n            lower--;\\n            if(upper>lower)break;\\n            \\n            for(int i=lower;i>=upper;i--){\\n                res.push_back(matrix[i][left]);\\n            }\\n            left++;\\n            if(left>right)break;\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        vector<int> res;\\n        \\n        int left=0;\\n        int right=n-1;\\n        int upper=0;\\n        int lower=m-1;\\n        \\n        while(left<=right && upper<=lower){\\n            for(int i=left;i<=right;i++){\\n                 res.push_back(matrix[upper][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1908016,
                "title": "c-naive-approach-a-very-basic-thinking",
                "content": "* The idea is to maintain **4 boolean variables right, down, left, up** which will tell us in which direction to move. \\n* There are **4 integer variables rowStart, rowEnd, colStart, colEnd** to specify constrains for moving in single direction. After moving in any direction update these variables to move in another direction.\\n* The **index** variable will be incremented at each time so that **r*c** matrix cells will be stored in linear array\\n* Adjust the constrains based upon direction of traversing n these values can be used in **while condition**\\n\\t* After traversing in horitanzal direction from left to right **rowStart** will increment by one\\n\\t* After  traversing in horitanzal direction from right to left **rowEnd** will decrement by one\\n\\t* After traversing in vertical direction from top to bottom **colEnd** will decrement by one\\n\\t* After traversing in vertical direction from bottom to top **colStart** will increment by one\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        vector<int> ans(r*c);\\n        \\n        int rows = 0, cols = 0, rowe = r-1, cole = c-1;\\n        \\n        int index = 0;\\n        bool right = true, down = false, left = false, up = false;\\n        while((rows<=rowe) && (cols<=cole)){\\n            \\n            if(right){\\n                for(int col=cols; col<=cole; col++){\\n                    ans[index++] = matrix[rows][col];\\n                }\\n                rows++; \\n                right = false, down = true;\\n            }\\n            else if(down){\\n                for(int ri=rows; ri<=rowe; ri++){\\n                    ans[index++] = matrix[ri][cole];\\n                }\\n                cole--; \\n                down = false, left = true;\\n            }\\n            else if(left){\\n                for(int ci=cole; ci>=cols; ci--){\\n                    ans[index++] = matrix[rowe][ci];\\n                }\\n                rowe--;\\n                left = false, up = true;\\n            }\\n            else if(up){\\n                for(int ri=rowe; ri>=rows; ri--){\\n                    ans[index++] = matrix[ri][cols];\\n                }\\n                cols++;\\n                up = false, right = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        vector<int> ans(r*c);\\n        \\n        int rows = 0, cols = 0, rowe = r-1, cole = c-1;\\n        \\n        int index = 0;\\n        bool right = true, down = false, left = false, up = false;\\n        while((rows<=rowe) && (cols<=cole)){\\n            \\n            if(right){\\n                for(int col=cols; col<=cole; col++){\\n                    ans[index++] = matrix[rows][col];\\n                }\\n                rows++; \\n                right = false, down = true;\\n            }\\n            else if(down){\\n                for(int ri=rows; ri<=rowe; ri++){\\n                    ans[index++] = matrix[ri][cole];\\n                }\\n                cole--; \\n                down = false, left = true;\\n            }\\n            else if(left){\\n                for(int ci=cole; ci>=cols; ci--){\\n                    ans[index++] = matrix[rowe][ci];\\n                }\\n                rowe--;\\n                left = false, up = true;\\n            }\\n            else if(up){\\n                for(int ri=rowe; ri>=rows; ri--){\\n                    ans[index++] = matrix[ri][cols];\\n                }\\n                cols++;\\n                up = false, right = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782596,
                "title": "java-solution-easy-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int tne=matrix.length*matrix[0].length;\\n        int rowmin=0, colmin=0, colmax=matrix[0].length-1, rowmax=matrix.length-1;\\n        int count=0;\\n        List<Integer> ans=new ArrayList<>();\\n        while(count<tne){\\n            //top wall\\n            for(int i=colmin; i<=colmax && count<tne; i++){\\n                ans.add(matrix[rowmin][i]);\\n                count++;\\n            }\\n            rowmin++;\\n            \\n            //right wall\\n              for(int i=rowmin; i<=rowmax && count<tne; i++){\\n                ans.add(matrix[i][colmax]);\\n                  count++;\\n            }\\n            colmax--;\\n            \\n            //bottom wall\\n            for(int i=colmax; i>=colmin && count<tne; i--){\\n                ans.add(matrix[rowmax][i]);\\n                count++;\\n                \\n            }\\n            rowmax--;\\n            \\n            //left wall\\n            for(int i=rowmax; i>=rowmin && count<tne;i--){\\n                ans.add(matrix[i][colmin]);\\n                count++;\\n            }\\n            colmin++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int tne=matrix.length*matrix[0].length;\\n        int rowmin=0, colmin=0, colmax=matrix[0].length-1, rowmax=matrix.length-1;\\n        int count=0;\\n        List<Integer> ans=new ArrayList<>();\\n        while(count<tne){\\n            //top wall\\n            for(int i=colmin; i<=colmax && count<tne; i++){\\n                ans.add(matrix[rowmin][i]);\\n                count++;\\n            }\\n            rowmin++;\\n            \\n            //right wall\\n              for(int i=rowmin; i<=rowmax && count<tne; i++){\\n                ans.add(matrix[i][colmax]);\\n                  count++;\\n            }\\n            colmax--;\\n            \\n            //bottom wall\\n            for(int i=colmax; i>=colmin && count<tne; i--){\\n                ans.add(matrix[rowmax][i]);\\n                count++;\\n                \\n            }\\n            rowmax--;\\n            \\n            //left wall\\n            for(int i=rowmax; i>=rowmin && count<tne;i--){\\n                ans.add(matrix[i][colmin]);\\n                count++;\\n            }\\n            colmin++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648434,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "\\n```java []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int left = 0, right = matrix[0].length-1, top = 0, bottom = matrix.length-1;\\n        int len = matrix.length*matrix[0].length;\\n        while(list.size() < len){\\n            for(int i=left; i<=right && list.size() < len; i++) list.add(matrix[top][i]);\\n            top++;\\n            for(int i=top; i<=bottom && list.size() < len; i++) list.add(matrix[i][right]);\\n            right--;\\n            for(int i=right; i>=left && list.size() < len; i--) list.add(matrix[bottom][i]);\\n            bottom--;\\n            for(int i=bottom; i>=top && list.size() < len; i--) list.add(matrix[i][left]);\\n            left++;\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\n```javascript []\\nvar spiralOrder = function(matrix) {\\n    let arr = []\\n    let left = 0, right = matrix[0].length-1, top = 0, bottom = matrix.length-1\\n    let len = matrix.length*matrix[0].length\\n    while(arr.length < len){\\n        for(let i=left; i<=right && arr.length < len; i++)  arr.push(matrix[top][i])\\n        top++  \\n        for(let i=top; i<=bottom && arr.length < len; i++) arr.push(matrix[i][right])\\n        right--\\n        for(let i=right; i>=left && arr.length < len; i--) arr.push(matrix[bottom][i])\\n        bottom--\\n        for(let i=bottom; i>=top && arr.length < len; i--) arr.push(matrix[i][left])\\n        left++\\n    }\\n    return arr\\n};\\n```\\n\\n```python []\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        arr = []\\n        left, right, top, bottom = 0, len(matrix[0])-1, 0, len(matrix)-1\\n        n = len(matrix) * len(matrix[0])\\n        while len(arr) < n :\\n            for i in range(left, right+1):\\n                if len(arr) < n:\\n                    arr.append(matrix[top][i])\\n            top += 1\\n            for i in range(top, bottom+1): \\n                if len(arr) < n:\\n                    arr.append(matrix[i][right])\\n            right -= 1\\n            for i in reversed(range(left, right+1)):\\n                if len(arr) < n:\\n                    arr.append(matrix[bottom][i])\\n            bottom -= 1\\n            for i in reversed(range(top, bottom+1)):\\n                if len(arr) < n:\\n                    arr.append(matrix[i][left])\\n            left += 1\\n        return arr\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int left = 0, right = matrix[0].length-1, top = 0, bottom = matrix.length-1;\\n        int len = matrix.length*matrix[0].length;\\n        while(list.size() < len){\\n            for(int i=left; i<=right && list.size() < len; i++) list.add(matrix[top][i]);\\n            top++;\\n            for(int i=top; i<=bottom && list.size() < len; i++) list.add(matrix[i][right]);\\n            right--;\\n            for(int i=right; i>=left && list.size() < len; i--) list.add(matrix[bottom][i]);\\n            bottom--;\\n            for(int i=bottom; i>=top && list.size() < len; i--) list.add(matrix[i][left]);\\n            left++;\\n        }\\n        return list;\\n    }\\n}\\n```\n```javascript []\\nvar spiralOrder = function(matrix) {\\n    let arr = []\\n    let left = 0, right = matrix[0].length-1, top = 0, bottom = matrix.length-1\\n    let len = matrix.length*matrix[0].length\\n    while(arr.length < len){\\n        for(let i=left; i<=right && arr.length < len; i++)  arr.push(matrix[top][i])\\n        top++  \\n        for(let i=top; i<=bottom && arr.length < len; i++) arr.push(matrix[i][right])\\n        right--\\n        for(let i=right; i>=left && arr.length < len; i--) arr.push(matrix[bottom][i])\\n        bottom--\\n        for(let i=bottom; i>=top && arr.length < len; i--) arr.push(matrix[i][left])\\n        left++\\n    }\\n    return arr\\n};\\n```\n```python []\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        arr = []\\n        left, right, top, bottom = 0, len(matrix[0])-1, 0, len(matrix)-1\\n        n = len(matrix) * len(matrix[0])\\n        while len(arr) < n :\\n            for i in range(left, right+1):\\n                if len(arr) < n:\\n                    arr.append(matrix[top][i])\\n            top += 1\\n            for i in range(top, bottom+1): \\n                if len(arr) < n:\\n                    arr.append(matrix[i][right])\\n            right -= 1\\n            for i in reversed(range(left, right+1)):\\n                if len(arr) < n:\\n                    arr.append(matrix[bottom][i])\\n            bottom -= 1\\n            for i in reversed(range(top, bottom+1)):\\n                if len(arr) < n:\\n                    arr.append(matrix[i][left])\\n            left += 1\\n        return arr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312879,
                "title": "c-faster-than-100-0ms-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        int top=0,down=n-1,left=0,right=m-1;\\n        int d=0;\\n        vector<int>v;\\n        while((down>=top)&&(left<=right))\\n        {\\n            if(d==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    v.push_back(arr[top][i]);\\n                }\\n                d=1;\\n                top++;\\n            }\\n            else if(d==1)\\n            {\\n                for(int i=top;i<=down;i++)\\n                {\\n                    v.push_back(arr[i][right]);\\n                }\\n                d=2;\\n                right--;\\n            }\\n            else if(d==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                    v.push_back(arr[down][i]);\\n                }\\n                d=3;\\n                down--;\\n            }\\n            else if(d==3)\\n            {\\n                for(int i=down;i>=top;i--)\\n                {\\n                    v.push_back(arr[i][left]);\\n                }\\n                d=0;\\n                left++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n**Please help to UPVOTE if this post is useful for you.**\\n\\n**If you have any questions, feel free to comment below.**\\n\\n**HAPPY CODING :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        int m=arr[0].size();\\n        int top=0,down=n-1,left=0,right=m-1;\\n        int d=0;\\n        vector<int>v;\\n        while((down>=top)&&(left<=right))\\n        {\\n            if(d==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    v.push_back(arr[top][i]);\\n                }\\n                d=1;\\n                top++;\\n            }\\n            else if(d==1)\\n            {\\n                for(int i=top;i<=down;i++)\\n                {\\n                    v.push_back(arr[i][right]);\\n                }\\n                d=2;\\n                right--;\\n            }\\n            else if(d==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                    v.push_back(arr[down][i]);\\n                }\\n                d=3;\\n                down--;\\n            }\\n            else if(d==3)\\n            {\\n                for(int i=down;i>=top;i--)\\n                {\\n                    v.push_back(arr[i][left]);\\n                }\\n                d=0;\\n                left++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143712,
                "title": "simple-c-solution-faster-than-100-using-4-pointers",
                "content": "* Just keep 4 pointers column start(cs), column end(ce), row start(rs), row start(re).\\n* Make the boundaries smaller after iterating through the current boundary corresponding to cs, ce, rs, re.\\n* **Dont forget to consider the cases where you travel forward and backward on the same row or column leading to duplicate entries.:**\\n\\t\\t\\n\\n```\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n\\t\\t\\tint n=matrix.size(),m=matrix[0].size();\\n        int rs=0,re=n-1,ce=m-1,cs=0;\\n        \\n        while(rs<=re and cs<=ce){\\n            for(int l=cs;l<=ce;l++){\\n                ans.push_back(matrix[rs][l]);\\n            }\\n            for(int k=rs+1;k<=re;k++){\\n                ans.push_back(matrix[k][ce]);    \\n            }\\n            for(int l=ce-1;l>=cs;l--){\\n                if(rs!=re) ans.push_back(matrix[re][l]);\\n            }\\n            for(int k=re-1;k>rs;k--){\\n                if(cs!=ce) ans.push_back(matrix[k][cs]);    \\n            }\\n            rs++;\\n            re--;\\n            ce--;\\n            cs++;\\n        }\\n        \\n        return ans;        \\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "* Just keep 4 pointers column start(cs), column end(ce), row start(rs), row start(re).\\n* Make the boundaries smaller after iterating through the current boundary corresponding to cs, ce, rs, re.\\n* **Dont forget to consider the cases where you travel forward and backward on the same row or column leading to duplicate entries.:**\\n\\t\\t\\n\\n```\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n\\t\\t\\tint n=matrix.size(),m=matrix[0].size();\\n        int rs=0,re=n-1,ce=m-1,cs=0;\\n        \\n        while(rs<=re and cs<=ce){\\n            for(int l=cs;l<=ce;l++){\\n                ans.push_back(matrix[rs][l]);\\n            }\\n            for(int k=rs+1;k<=re;k++){\\n                ans.push_back(matrix[k][ce]);    \\n            }\\n            for(int l=ce-1;l>=cs;l--){\\n                if(rs!=re) ans.push_back(matrix[re][l]);\\n            }\\n            for(int k=re-1;k>rs;k--){\\n                if(cs!=ce) ans.push_back(matrix[k][cs]);    \\n            }\\n            rs++;\\n            re--;\\n            ce--;\\n            cs++;\\n        }\\n        \\n        return ans;        \\n        \\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 600768,
                "title": "1-liner-javascript",
                "content": "One liner:\\n\\n```js\\nfunction spiral(m) {\\n  return m.shift().concat(m.length ? spiral(m[0].map((_,i) => m.map(x => x[i])).reverse()) : [])\\n}\\n```\\n\\nthe same code but expanded:\\n\\n```js\\nfunction spiral(matrix) {\\n  if (!matrix.length) return matrix;\\n  const firstRow = matrix.shift();\\n  const transponsed = matrix[0].map((a, i) => {\\n    return matrix.map(row => row[i]);\\n  });\\n  const rotated = transponsed.reverse(); // rotated 90*\\n  return firstRow.concat(spiral(rotated));\\n}\\n```\\n\\nthe same logic but in diagram:\\n\\n```\\n|1 2 3|      |6 9|      |8 7|      |4|  =>  |5|  =>  ||\\n|4 5 6|  =>  |5 8|  =>  |5 4|  =>  |5|\\n|7 8 9|      |4 7|\\n\\n// rows extracted:\\n\\n|1 2 3|      |6 9|      |8 7|      |4|      |5|\\n```\\n\\nthe same logic but in english:\\n\\n1. Remove the first row and add it to the answer\\n2. Rotate the reminder of the matrix 90* counter clockwise\\n3. Repeat step 1 and 2 until there\\'s no more rows",
                "solutionTags": [],
                "code": "```js\\nfunction spiral(m) {\\n  return m.shift().concat(m.length ? spiral(m[0].map((_,i) => m.map(x => x[i])).reverse()) : [])\\n}\\n```\n```js\\nfunction spiral(matrix) {\\n  if (!matrix.length) return matrix;\\n  const firstRow = matrix.shift();\\n  const transponsed = matrix[0].map((a, i) => {\\n    return matrix.map(row => row[i]);\\n  });\\n  const rotated = transponsed.reverse(); // rotated 90*\\n  return firstRow.concat(spiral(rotated));\\n}\\n```\n```\\n|1 2 3|      |6 9|      |8 7|      |4|  =>  |5|  =>  ||\\n|4 5 6|  =>  |5 8|  =>  |5 4|  =>  |5|\\n|7 8 9|      |4 7|\\n\\n// rows extracted:\\n\\n|1 2 3|      |6 9|      |8 7|      |4|      |5|\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 423891,
                "title": "java-o-mn-recursive-and-iterative-solutions-with-explanation-and-comments",
                "content": "**Recursive**\\n1) We can use four pointers, all at the corners. Left, Right, Top, Bottom. \\n2) Go from left ---> right on top  row. Increase top row index.\\n3) Go from top --> bottom on last column. Decrease right index.\\n4) Go from right ---> left on bottom column. Decrease bottom pointer. Don\\'t forget to make sure that top and bottom pointers have not crossed each other. Since top has moved in bullet 2.\\n5) Go from bottom --> top. Increase left pointer. Don\\'t forget to make sure that left and right pointers have not crossed each other. Since right has moved in bullet 3.\\n6) The remaining matrix is subproblem of original matrix. Hence recurse/iterate till pointers are not crossing.\\n\\nTime Complexity: O(mn). We are visiting every cell only once.\\nSpace Complexity: O(1) iff we ignore the recursive stack space.\\n\\nFor interviews and DS Algo tips you can follow me on https://twitter.com/Jaspind07199761\\nor connect on https://www.linkedin.com/in/jaspindersingh1/\\n\\n\\n\\n```\\nclass Solution {\\n    List<Integer> result=new ArrayList<>();\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix.length == 0) return result;\\n        helper(matrix, 0, matrix[0].length - 1, 0, matrix.length - 1);\\n        return result;\\n    }\\n    public void helper(int[][] matrix, int left, int right, int top, int bottom){\\n        // Base case : If pointers cross each other terminate\\n        if(left > right || top > bottom) return;\\n        // top row\\n        for(int i = left; i <= right; i++){\\n            result.add(matrix[top][i]);\\n        }\\n        top++;\\n        //right column\\n        for(int i = top; i <= bottom; i++){\\n            result.add(matrix[i][right]);\\n        }\\n        right--;\\n        // We need to check top <= bottom because original position of top has increased\\n        if(top <= bottom){\\n              //Bottom row\\n            for(int i = right; i >= left; i--){\\n                result.add(matrix[bottom][i]);\\n            }\\n        }\\n        bottom--;\\n           // We need to check left <= right because original position of left has changed\\n        if(left <= right){\\n              //left column\\n            for(int i = bottom; i >= top; i--){\\n                result.add(matrix[i][left]);\\n            }\\n        }\\n        left++;\\n        helper(matrix,left, right, top, bottom); \\n    }\\n}\\n```\\n\\n**Iterative Solution**\\n\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List <Integer> result = new ArrayList<>();\\n         if(matrix.length == 0) return result;\\n        int left = 0;\\n        int top = 0;\\n        int right = matrix[0].length - 1;\\n        int bottom = matrix.length - 1;\\n        while (left <= right && top <= bottom){\\n            // Top row \\n            for(int i = left; i <= right; i++){\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            // right column \\n            for(int i = top; i <= bottom; i++){\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if(top <= bottom){\\n               for(int i = right; i >= left; i--){\\n                    result.add(matrix[bottom][i]);\\n                } \\n            }\\n            bottom--;\\n            if(left <= right){\\n               for(int i = bottom; i >= top; i--){\\n                    result.add(matrix[i][left]);\\n                }  \\n            }\\n            left++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> result=new ArrayList<>();\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if(matrix.length == 0) return result;\\n        helper(matrix, 0, matrix[0].length - 1, 0, matrix.length - 1);\\n        return result;\\n    }\\n    public void helper(int[][] matrix, int left, int right, int top, int bottom){\\n        // Base case : If pointers cross each other terminate\\n        if(left > right || top > bottom) return;\\n        // top row\\n        for(int i = left; i <= right; i++){\\n            result.add(matrix[top][i]);\\n        }\\n        top++;\\n        //right column\\n        for(int i = top; i <= bottom; i++){\\n            result.add(matrix[i][right]);\\n        }\\n        right--;\\n        // We need to check top <= bottom because original position of top has increased\\n        if(top <= bottom){\\n              //Bottom row\\n            for(int i = right; i >= left; i--){\\n                result.add(matrix[bottom][i]);\\n            }\\n        }\\n        bottom--;\\n           // We need to check left <= right because original position of left has changed\\n        if(left <= right){\\n              //left column\\n            for(int i = bottom; i >= top; i--){\\n                result.add(matrix[i][left]);\\n            }\\n        }\\n        left++;\\n        helper(matrix,left, right, top, bottom); \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List <Integer> result = new ArrayList<>();\\n         if(matrix.length == 0) return result;\\n        int left = 0;\\n        int top = 0;\\n        int right = matrix[0].length - 1;\\n        int bottom = matrix.length - 1;\\n        while (left <= right && top <= bottom){\\n            // Top row \\n            for(int i = left; i <= right; i++){\\n                result.add(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            // right column \\n            for(int i = top; i <= bottom; i++){\\n                result.add(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            if(top <= bottom){\\n               for(int i = right; i >= left; i--){\\n                    result.add(matrix[bottom][i]);\\n                } \\n            }\\n            bottom--;\\n            if(left <= right){\\n               for(int i = bottom; i >= top; i--){\\n                    result.add(matrix[i][left]);\\n                }  \\n            }\\n            left++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389896,
                "title": "scala-solution-with-detailed-explanations",
                "content": "This question is very like [RotateImage](https://leetcode.com/problems/rotate-image/), we can reuse the function.\\n\\nConsider this problem can be convert to get the first line, then rotate the matrix counterclockwise.\\nFor Example.\\n```\\n1 2 3              4 5 6              6 9\\n4 5 6  => [1,2,3]  7 8 9   => [1,2,3] 5 8  =>  [1,2,3,6,9] 5 8  => [1,2,3,6,9] 8 7 =>\\n7 8 9                                 4 7                  4 7                 5 4\\n\\n[1,2,3,6,9,8,7] 5 4 => [1,2,3,6,9,8,7] 4 => [1,2,3,6,9,8,7,4] 5 => [1,2,3,6,9,8,7,4,5]\\n                                       5\\n```\\n\\nHow can we rotate the matrix counterclockwise? Well, a trivial solution is rotate it clockwise three times,\\n\\nAnother way is to first transpose it and then reverse it.\\n```\\n4 5 6   =>  4 7  =>  6 9\\n7 8 9       5 8      5 8\\n            6 9      4 7\\n```\\n\\nThen just implement it\\n```scala\\nobject SpiralMatrix {\\n\\n  /** RunTime Info:\\n    * 244ms, 44MB\\n    *\\n    * @param matrix input matrix\\n    * @return matrix elements in spiral order\\n    */\\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {\\n    def snail(xs: List[List[Int]]): List[Int] = xs match {\\n      case Nil => Nil\\n      case x :: xs => x ++ snail(xs.transpose.reverse)\\n    }\\n\\n    snail(matrix.toList.map(_.toList))\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1 2 3              4 5 6              6 9\\n4 5 6  => [1,2,3]  7 8 9   => [1,2,3] 5 8  =>  [1,2,3,6,9] 5 8  => [1,2,3,6,9] 8 7 =>\\n7 8 9                                 4 7                  4 7                 5 4\\n\\n[1,2,3,6,9,8,7] 5 4 => [1,2,3,6,9,8,7] 4 => [1,2,3,6,9,8,7,4] 5 => [1,2,3,6,9,8,7,4,5]\\n                                       5\\n```\n```\\n4 5 6   =>  4 7  =>  6 9\\n7 8 9       5 8      5 8\\n            6 9      4 7\\n```\n```scala\\nobject SpiralMatrix {\\n\\n  /** RunTime Info:\\n    * 244ms, 44MB\\n    *\\n    * @param matrix input matrix\\n    * @return matrix elements in spiral order\\n    */\\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {\\n    def snail(xs: List[List[Int]]): List[Int] = xs match {\\n      case Nil => Nil\\n      case x :: xs => x ++ snail(xs.transpose.reverse)\\n    }\\n\\n    snail(matrix.toList.map(_.toList))\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 371800,
                "title": "python-simple-solution",
                "content": "```python\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        firstRow, firstCol = 0, 0\\n        rows, cols = len(matrix), len(matrix[0])\\n        result = []\\n\\n        while rows > 0 and cols > 0:\\n            lastRow = firstRow + rows - 1\\n            lastCol = firstCol + cols - 1\\n\\n            # Top left to right\\n            for i in range(cols):\\n                result.append(matrix[firstRow][firstCol + i])\\n            # Right top to bottom\\n            for i in range(1, rows):\\n                result.append(matrix[firstRow + i][lastCol])\\n            # Bottom right to left\\n            for i in range(1, cols):\\n                if firstRow != lastRow:\\n                    result.append(matrix[lastRow][lastCol - i])\\n            # Left bottom to top\\n            for i in range(1, rows - 1):\\n                if firstCol != lastCol:\\n                    result.append(matrix[lastRow - i][firstCol])\\n\\n            # Next layer\\n            firstRow += 1\\n            firstCol += 1\\n            rows -= 2\\n            cols -= 2\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n\\n        firstRow, firstCol = 0, 0\\n        rows, cols = len(matrix), len(matrix[0])\\n        result = []\\n\\n        while rows > 0 and cols > 0:\\n            lastRow = firstRow + rows - 1\\n            lastCol = firstCol + cols - 1\\n\\n            # Top left to right\\n            for i in range(cols):\\n                result.append(matrix[firstRow][firstCol + i])\\n            # Right top to bottom\\n            for i in range(1, rows):\\n                result.append(matrix[firstRow + i][lastCol])\\n            # Bottom right to left\\n            for i in range(1, cols):\\n                if firstRow != lastRow:\\n                    result.append(matrix[lastRow][lastCol - i])\\n            # Left bottom to top\\n            for i in range(1, rows - 1):\\n                if firstCol != lastCol:\\n                    result.append(matrix[lastRow - i][firstCol])\\n\\n            # Next layer\\n            firstRow += 1\\n            firstCol += 1\\n            rows -= 2\\n            cols -= 2\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286639,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n  if (matrix.length == 0) {\\n    return [];\\n  }\\n  let result = [];\\n  let rowStart = 0;\\n  let rowEnd = matrix.length - 1;\\n  let colStart = 0;\\n  let colEnd = matrix[0].length - 1;\\n  while (true) {\\n    // top\\n    for (let i = colStart; i <= colEnd; i++) {\\n      result.push(matrix[rowStart][i]);\\n    }\\n    rowStart++;\\n    if (rowStart > rowEnd) {\\n      return result;\\n    }\\n    // right\\n    for (let i = rowStart; i <= rowEnd; i++) {\\n      result.push(matrix[i][colEnd]);\\n    }\\n    colEnd--;\\n    if (colEnd < colStart) {\\n      return result;\\n    }\\n    // bottom\\n    for (let i = colEnd; i >= colStart; i--) {\\n      result.push(matrix[rowEnd][i]);\\n    }\\n    rowEnd--;\\n    if (rowEnd < rowStart) {\\n      return result;\\n    }\\n    // left\\n    for (let i = rowEnd; i >= rowStart; i--) {\\n      result.push(matrix[i][colStart]);\\n    }\\n    colStart++;\\n    if (colStart > colEnd) {\\n      return result;\\n    }\\n  }\\n  return result;\\n};\\nconsole.log(\\n  spiralOrder([[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13], [14, 15, 16]])\\n);\\nconsole.log(spiralOrder([[7], [9], [6]]));\\nconsole.log(spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]));\\nconsole.log(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]));\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n  if (matrix.length == 0) {\\n    return [];\\n  }\\n  let result = [];\\n  let rowStart = 0;\\n  let rowEnd = matrix.length - 1;\\n  let colStart = 0;\\n  let colEnd = matrix[0].length - 1;\\n  while (true) {\\n    // top\\n    for (let i = colStart; i <= colEnd; i++) {\\n      result.push(matrix[rowStart][i]);\\n    }\\n    rowStart++;\\n    if (rowStart > rowEnd) {\\n      return result;\\n    }\\n    // right\\n    for (let i = rowStart; i <= rowEnd; i++) {\\n      result.push(matrix[i][colEnd]);\\n    }\\n    colEnd--;\\n    if (colEnd < colStart) {\\n      return result;\\n    }\\n    // bottom\\n    for (let i = colEnd; i >= colStart; i--) {\\n      result.push(matrix[rowEnd][i]);\\n    }\\n    rowEnd--;\\n    if (rowEnd < rowStart) {\\n      return result;\\n    }\\n    // left\\n    for (let i = rowEnd; i >= rowStart; i--) {\\n      result.push(matrix[i][colStart]);\\n    }\\n    colStart++;\\n    if (colStart > colEnd) {\\n      return result;\\n    }\\n  }\\n  return result;\\n};\\nconsole.log(\\n  spiralOrder([[2, 3, 4], [5, 6, 7], [8, 9, 10], [11, 12, 13], [14, 15, 16]])\\n);\\nconsole.log(spiralOrder([[7], [9], [6]]));\\nconsole.log(spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]));\\nconsole.log(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]));\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279629,
                "title": "java-clean-solution",
                "content": "```\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0) return new ArrayList<>();\\n        int left = 0, right = matrix[0].length - 1;\\n        int top = 0, bottom = matrix.length - 1;\\n        List<Integer> ret = new ArrayList<>();\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; ++i) ret.add(matrix[top][i]);\\n            for (int i = ++top; i <= bottom; ++i) ret.add(matrix[i][right]);\\n            // bug - 1 => avoid duplicates collected;\\n            if (top > bottom) break;\\n            for (int i = --right; i >= left; --i) ret.add(matrix[bottom][i]);\\n            if (left > right) break;\\n            for (int i = --bottom; i >= top; --i) ret.add(matrix[i][left]);\\n            left++;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0) return new ArrayList<>();\\n        int left = 0, right = matrix[0].length - 1;\\n        int top = 0, bottom = matrix.length - 1;\\n        List<Integer> ret = new ArrayList<>();\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; ++i) ret.add(matrix[top][i]);\\n            for (int i = ++top; i <= bottom; ++i) ret.add(matrix[i][right]);\\n            // bug - 1 => avoid duplicates collected;\\n            if (top > bottom) break;\\n            for (int i = --right; i >= left; --i) ret.add(matrix[bottom][i]);\\n            if (left > right) break;\\n            for (int i = --bottom; i >= top; --i) ret.add(matrix[i][left]);\\n            left++;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197782,
                "title": "scala-solution",
                "content": "```\\nobject Solution {\\n    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = { \\n        def dfs(mx: Array[Array[Int]]): List[Int] = mx match {\\n            case mx if mx.isEmpty => List()\\n            case mx if mx.length == 1 => mx.head.toList\\n            case _ => mx.head.toList ::: spiralOrder(mx.tail.transpose.reverse) \\n        }\\n        dfs(matrix)\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = { \\n        def dfs(mx: Array[Array[Int]]): List[Int] = mx match {\\n            case mx if mx.isEmpty => List()\\n            case mx if mx.length == 1 => mx.head.toList\\n            case _ => mx.head.toList ::: spiralOrder(mx.tail.transpose.reverse) \\n        }\\n        dfs(matrix)\\n    }    \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 110805,
                "title": "only-11-lines-very-simple-python-solution",
                "content": "```  \\n def spiralOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m=len(matrix)\\n        rec=[]\\n        if m==1:\\n            return matrix[0]\\n        if m>1:\\n            while len(matrix)>0:\\n                rec+=matrix[0]\\n                matrix.remove(matrix[0])\\n                matrix=map(list,zip(*matrix))\\n                matrix.reverse()\\n        return  rec   ```",
                "solutionTags": [],
                "code": "```  \\n def spiralOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m=len(matrix)\\n        rec=[]\\n        if m==1:\\n            return matrix[0]\\n        if m>1:\\n            while len(matrix)>0:\\n                rec+=matrix[0]\\n                matrix.remove(matrix[0])\\n                matrix=map(list,zip(*matrix))\\n                matrix.reverse()\\n        return  rec   ```",
                "codeTag": "Python3"
            },
            {
                "id": 20746,
                "title": "my-intuitive-java-solution-very-easy-to-avoid-edge-cases",
                "content": "- In order to coding directly and semantically, use four variables as ___walls___: `l`, `r`, `t`, `b`.\\n\\nAttached is my AC code:\\n\\n    public class Solution {\\n      public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ret=  new ArrayList<Integer>();\\n        if(matrix.length==0 || matrix[0].length==0) return ret;\\n        int b = matrix.length-1, r = matrix[0].length-1, t=0,l=0;\\n        while(t<=b && l<=r){\\n          //Right\\n          for(int j=l;j<=r;j++)\\n            ret.add(matrix[t][j]);\\n          t++;\\n          //Down\\n          for(int i=t;i<=b;i++)\\n            ret.add(matrix[i][r]);\\n          r--;\\n          //Left\\n          for(int j=r;j>=l && t<=b;j--)\\n            ret.add(matrix[b][j]);\\n          b--;\\n          //Up\\n          for(int i=b;i>=t && l<=r;i--)\\n            ret.add(matrix[i][l]);\\n          l++;\\n        }\\n        return ret;\\n      }\\n    }\\n\\n- WA: forget to check `t<=b` and `l<=r` when going left and up.\\n- AC then.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ret=  new ArrayList<Integer>();\\n        if(matrix.length==0 || matrix[0].length==0) return ret;\\n        int b = matrix.length-1, r = matrix[0].length-1, t=0,l=0;\\n        while(t<=b && l<=r){\\n          //Right\\n          for(int j=l;j<=r;j++)\\n            ret.add(matrix[t][j]);\\n          t++;\\n          //Down\\n          for(int i=t;i<=b;i++)\\n            ret.add(matrix[i][r]);\\n          r--;\\n          //Left\\n          for(int j=r;j>=l && t<=b;j--)\\n            ret.add(matrix[b][j]);\\n          b--;\\n          //Up\\n          for(int i=b;i>=t && l<=r;i--)\\n            ret.add(matrix[i][l]);\\n          l++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20712,
                "title": "straightforward-java-solution",
                "content": "    public class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return list;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int left = 0, right = col-1;\\n        int top = 0, bottom = row-1;\\n        while(true){\\n            for(int i = left; i<=right; i++){\\n                list.add(matrix[top][i]);\\n            }\\n            top++;\\n            if(top > bottom) break;\\n            for(int i = top; i<=bottom; i++){\\n                list.add(matrix[i][right]);\\n            }\\n            right--;\\n            if(right < left) break;\\n            for(int i = right; i>=left; i--){\\n                list.add(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            if(bottom < top) break;\\n            for(int i = bottom; i>=top; i--){\\n                list.add(matrix[i][left]);\\n            }\\n            left++;\\n            if(left > right) break;\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return list;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int left = 0, right = col-1;\\n        int top = 0, bottom = row-1;\\n        while(true){\\n            for(int i = left; i<=right; i++){\\n                list.add(matrix[top][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 20825,
                "title": "simple-java-solution",
                "content": "\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {return res;}\\n        int left = 0, right = matrix[0].length - 1;\\n        int top = 0, bottom = matrix.length - 1;\\n        int tag = 0, row = top, col = left;\\n        // int m = 0;\\n        for (int m = 0; m < matrix.length * matrix[0].length; m++) {\\n            if (tag == 0) {\\n                res.add(matrix[row][col]);\\n                if (col == right) {\\n                    tag = 1;\\n                    top++;\\n                    row = top;\\n                } else {col++;}\\n            } else if (tag == 1) {\\n                res.add(matrix[row][col]);\\n                if (row == bottom) {\\n                    tag = 2;\\n                    right--;\\n                    col = right;\\n                } else {row++;}\\n            } else if (tag == 2) {\\n                res.add(matrix[row][col]);\\n                if (col == left) {\\n                    tag = 3;\\n                    bottom--;\\n                    row = bottom;\\n                } else {col--;}\\n            } else {\\n                res.add(matrix[row][col]);\\n                if (row == top) {\\n                    tag = 0;\\n                    left++;\\n                    col = left;\\n                } else {row--;}\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (matrix.length == 0 || matrix[0].length == 0) {return res;}\\n        int left = 0, right = matrix[0].length - 1;\\n        int top = 0, bottom = matrix.length - 1;\\n        int tag = 0, row = top, col = left;\\n        // int m = 0;\\n        for (int m = 0; m < matrix.length * matrix[0].length; m++) {\\n            if (tag == 0) {\\n                res.add(matrix[row][col]);\\n                if (col == right) {\\n                    tag = 1;\\n                    top++;\\n                    row = top;\\n                } else {col++;}\\n            } else if (tag == 1) {\\n                res.add(matrix[row][col]);\\n                if (row == bottom) {\\n                    tag = 2;\\n                    right--;\\n                    col = right;\\n                } else {row++;}\\n            } else if (tag == 2) {\\n                res.add(matrix[row][col]);\\n                if (col == left) {\\n                    tag = 3;\\n                    bottom--;\\n                    row = bottom;\\n                } else {col--;}\\n            } else {\\n                res.add(matrix[row][col]);\\n                if (row == top) {\\n                    tag = 0;\\n                    left++;\\n                    col = left;\\n                } else {row--;}\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3986119,
                "title": "o-n-m-solution-using-direction-variables",
                "content": "Each time we hit the border, change the direction. Borders will be adjusted based on parsed elements.\\n\\n```\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        res = []\\n        m, n = len(matrix), len(matrix[0])\\n        # initial borders\\n        top, right, bottom, left = 0, n-1, m-1, 0\\n        # direction\\n        horizontal, vertical = 1, 0\\n        # start\\n        i, j = 0, 0\\n        \\n        while len(res) < m*n:\\n            res.append(matrix[i][j])\\n            \\n            if (i,j) == (top,right) and horizontal == 1:\\n                horizontal, vertical = 0, 1\\n                top += 1\\n            elif (i,j) == (bottom,right) and vertical == 1:\\n                horizontal, vertical = -1, 0\\n                right -= 1\\n            elif (i,j) == (top,left) and vertical == -1:\\n                horizontal, vertical = 1, 0\\n                left += 1\\n            elif (i,j) == (bottom,left) and horizontal == -1:\\n                horizontal, vertical = 0, -1\\n                bottom -= 1\\n            \\n            i += vertical\\n            j += horizontal\\n               \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "Each time we hit the border, change the direction. Borders will be adjusted based on parsed elements.\\n\\n```\\nclass Solution(object):\\n    def spiralOrder(self, matrix):\\n        res = []\\n        m, n = len(matrix), len(matrix[0])\\n        # initial borders\\n        top, right, bottom, left = 0, n-1, m-1, 0\\n        # direction\\n        horizontal, vertical = 1, 0\\n        # start\\n        i, j = 0, 0\\n        \\n        while len(res) < m*n:\\n            res.append(matrix[i][j])\\n            \\n            if (i,j) == (top,right) and horizontal == 1:\\n                horizontal, vertical = 0, 1\\n                top += 1\\n            elif (i,j) == (bottom,right) and vertical == 1:\\n                horizontal, vertical = -1, 0\\n                right -= 1\\n            elif (i,j) == (top,left) and vertical == -1:\\n                horizontal, vertical = 1, 0\\n                left += 1\\n            elif (i,j) == (bottom,left) and horizontal == -1:\\n                horizontal, vertical = 0, -1\\n                bottom -= 1\\n            \\n            i += vertical\\n            j += horizontal\\n               \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3516947,
                "title": "very-easy-c-solution-with-explanation-easy-to-understand",
                "content": "/*question bhot asan h bs khre h hme matrix print krni h kuch iss form me jo picture lgi hui h sbse\\nphle hum iss matrix me kya krre h sbse phle hum print kra re h apni starting row then print kra re h end column then print krare h end row then print kra re h start column abb jb bhi koi print hoga hum update krdenge for rx hmara koi row print hua start row abb usko update kdenge startrow++ abb kyuki first element aa chuka h array ka upar photo me dekhe to 3 aa chuka h to abb three nhi chaiye isleye hi yo update kie start row ab  kya bn gai h 2 yani abb 3 na print hoke 6 se printing shuru hogi \\n\\nasse hi jb hum start row or end col print krdenge hum end col ko bhi kya krdenge ++ krdenge to abb 9 ek hi bar print hoga jb hum end row ko print krre honge  jo hmara endcolumn se shuru hui h or kha tk gai h starting column tk starting column to thik h 0 ha pr end column hme kya krrdia -- krke abb 9 na print hoke 8 hi print hoga */\\n\\n\\n\\nclass Solution {    \\npublic:\\n\\n        \\n\\t\\tvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count = 0;\\n        int total = row*col;\\n        \\n        // index used to travel the 2d array \\n        \\n        int startrow = 0;\\n        int endrow = row-1;\\n        int startcol = 0;\\n        int endcol = col-1;\\n        \\n        while(count<total)\\n        {\\n            \\n            // print starting row \\n            for(int index = startcol; count<total && index<=endcol; index++ )\\n            {\\n                 ans.push_back(matrix[startrow][index]);\\n                count++;\\n            }\\n            startrow++;\\n             // print ending colunm \\n            for(int index = startrow; count<total && index<=endrow; index++ )\\n            {\\n                 ans.push_back(matrix[index][endcol]);\\n                 count++;\\n            }\\n            endcol--;\\n            \\n             // print ending row \\n            for(int index = endcol; count<total && index>=startcol; index-- )\\n            {\\n                 ans.push_back(matrix[endrow][index]);\\n                 count++;\\n            }\\n            endrow--;\\n              // print starting  colunm \\n            for(int index = endrow; count<total && index>= startrow; index-- )\\n            {\\n                 ans.push_back(matrix[index][startcol]);\\n                 count++;\\n            }\\n            startcol++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "class Solution {    \\npublic:\\n\\n        \\n\\t\\tvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count = 0;\\n        int total = row*col;\\n        \\n        // index used to travel the 2d array \\n        \\n        int startrow = 0;\\n        int endrow = row-1;\\n        int startcol = 0;\\n        int endcol = col-1;\\n        \\n        while(count<total)\\n        {\\n            \\n            // print starting row \\n            for(int index = startcol; count<total && index<=endcol; index++ )\\n            {\\n                 ans.push_back(matrix[startrow][index]);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3507949,
                "title": "super-solution-using-two-pointer-python3",
                "content": "\\n# Superb Logic Using 2 pointer Python\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        left=0\\n        right=n-1\\n        top=0\\n        bottom=m-1\\n        list1 = []\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1,1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            \\n            for i in range(top,bottom+1,1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if len(list1)==m*n:\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        left=0\\n        right=n-1\\n        top=0\\n        bottom=m-1\\n        list1 = []\\n        while left<=right and top<=bottom:\\n            for i in range(left,right+1,1):\\n                list1.append(matrix[top][i])\\n            top+=1\\n            \\n            for i in range(top,bottom+1,1):\\n                list1.append(matrix[i][right])\\n            right-=1\\n            if len(list1)==m*n:\\n                break\\n            for i in range(right,left-1,-1):\\n                list1.append(matrix[bottom][i])\\n            bottom-=1\\n            for i in range(bottom,top-1,-1):\\n                list1.append(matrix[i][left])\\n            left+=1\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507932,
                "title": "java-beats-100-time-oms-easiest-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nLinear\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        int left=0, bottom=matrix.length-1, right=matrix[0].length-1, top=0;\\n        while(left<=right || top<=bottom){\\n                if(top<=bottom){\\n                    for(int i=left;i<=right;i++)\\n                    ans.add(matrix[top][i]);\\n                    top++;\\n                }\\n                if(left<=right){\\n                    for(int i=top;i<=bottom;i++)\\n                    ans.add(matrix[i][right]);\\n                    right--;\\n                }\\n                if(top<=bottom){\\n                    for(int i=right;i>=left;i--)\\n                    ans.add(matrix[bottom][i]);\\n                    bottom--;\\n                }\\n                if(left<=right){\\n                    for(int i=bottom;i>=top;i--)\\n                    ans.add(matrix[i][left]);\\n                    left++;\\n                }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        int left=0, bottom=matrix.length-1, right=matrix[0].length-1, top=0;\\n        while(left<=right || top<=bottom){\\n                if(top<=bottom){\\n                    for(int i=left;i<=right;i++)\\n                    ans.add(matrix[top][i]);\\n                    top++;\\n                }\\n                if(left<=right){\\n                    for(int i=top;i<=bottom;i++)\\n                    ans.add(matrix[i][right]);\\n                    right--;\\n                }\\n                if(top<=bottom){\\n                    for(int i=right;i>=left;i--)\\n                    ans.add(matrix[bottom][i]);\\n                    bottom--;\\n                }\\n                if(left<=right){\\n                    for(int i=bottom;i>=top;i--)\\n                    ans.add(matrix[i][left]);\\n                    left++;\\n                }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507231,
                "title": "explained-with-code-in-c-and-python",
                "content": "# Intuition\\nStart with a **pen paper approach** to **traverse the matrix**. A clear understanding of **nav**igating through the **rows and columns** in important to understand and solve these type of questions.\\n\\n# Approach\\nThere are basically 4 steps to this problem:\\n1. Move from `left to right` for the `first row`, `increment top`\\n2. Move from `top to bottom` for the `right column`, `decrement right`\\n3. Move from `right to left` for the `bottom row`, `decrement bottom`\\n4. Move from `bottom to top` for the `left column`, `increment left` \\n\\nIterate these steps until there are **no rows and columns**, you can do this by checking if `top <= bottom` and `left <= right`\\n\\nRemember that, in Python ranges are not inclusive, i.e., the end is not considered. Therefore, you have to either add 1 or subtract 1 to consider the entire range of the rows and columns.\\n\\n# Complexity\\n- Time complexity: O(n X m)\\n- Space complexity: O(n X m)\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        # Intialize the 4 directions of the matrix\\n        top = 0\\n        bottom = len(matrix) - 1\\n        right = len(matrix[0]) - 1\\n        left = 0\\n        \\n        # Create an array to store the resultant array\\n        res = []\\n\\n        # Iterate until you have no rows and columns\\n        while top <= bottom and left <= right:\\n\\n            # Since Python ranges are not inclusive, we have to consider adding or substracting 1 to allow complete matrix ranges. \\n\\n            # Iterate from left to right\\n            # We have the top as constant as the row number\\n            for i in range(left, right + 1):\\n                res.append(matrix[top][i])\\n            # Now, we can move to the next row\\n            # Increment top by 1 to move to the next row\\n            top += 1\\n            \\n            # Iterate from top to bottom\\n            # We have right as the constant column number\\n            for i in range(top, bottom + 1):\\n                res.append(matrix[i][right])\\n            # Now, we can elimiate the right column\\n            # Decrement right by 1 to move to the previous column\\n            right -= 1\\n\\n            # In case where we have no more rows to print, \\n            # We need to check if the top is still less than or equal to bottom\\n            if top <= bottom: \\n                # Iterate from right to left\\n                # We have the bottom as constant as the row number\\n                for i in range(right, left - 1, -1):\\n                    res.append(matrix[bottom][i])\\n                # Now, we can elimiate the bottom row\\n                # Decrement right by 1 to move to the previous row  \\n                bottom -= 1\\n\\n            # In case where we have no more columns to print, \\n            # We need to check if the left is still less than or equal to right\\n            if left <= right:\\n                # Iterate from bottom to top\\n                # We have the left as constant as the column number\\n                for i in range(bottom, top - 1, -1):\\n                    res.append(matrix[i][left])\\n                # Now, we can elimiate the left column\\n                # Increment left by 1 to move to the next column  \\n                left += 1\\n\\n        return res\\n```\\n``` C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    // Initialize the 4 directions of the matrix\\n    int top = 0;\\n    int bottom = matrixSize - 1;\\n    int right = *matrixColSize - 1;\\n    int left = 0;\\n\\n    // Create an array to store the resultant array\\n    int *res = (int*)malloc(matrixSize * (*matrixColSize) * sizeof(int));\\n    *returnSize = 0;\\n\\n    // Iterate until you have no rows and columns\\n    while (top <= bottom && left <= right) {\\n        // Iterate from left to right\\n        // We have the top as constant as the row number\\n        for (int i = left; i <= right; i++) {\\n            res[(*returnSize)++] = matrix[top][i];\\n        }\\n        // Now, we can move to the next row\\n        // Increment top by 1 to move to the next row\\n        top++;\\n\\n        // Iterate from top to bottom\\n        // We have right as the constant column number\\n        for (int i = top; i <= bottom; i++) {\\n            res[(*returnSize)++] = matrix[i][right];\\n        }\\n        // Now, we can eliminate the right column\\n        // Decrement right by 1 to move to the previous column\\n        right--;\\n\\n        // In case where we have no more rows to print,\\n        // We need to check if the top is still less than or equal to bottom\\n        if (top <= bottom) {\\n            // Iterate from right to left\\n            // We have the bottom as constant as the row number\\n            for (int i = right; i >= left; i--) {\\n                res[(*returnSize)++] = matrix[bottom][i];\\n            }\\n            // Now, we can eliminate the bottom row\\n            // Decrement bottom by 1 to move to the previous row\\n            bottom--;\\n        }\\n\\n        // In case where we have no more columns to print,\\n        // We need to check if the left is still less than or equal to right\\n        if (left <= right) {\\n            // Iterate from bottom to top\\n            // We have left as constant as the column number\\n            for (int i = bottom; i >= top; i--) {\\n                res[(*returnSize)++] = matrix[i][left];\\n            }\\n            // Now, we can eliminate the left column\\n            // Increment left by 1 to move to the next column\\n            left++;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        # Intialize the 4 directions of the matrix\\n        top = 0\\n        bottom = len(matrix) - 1\\n        right = len(matrix[0]) - 1\\n        left = 0\\n        \\n        # Create an array to store the resultant array\\n        res = []\\n\\n        # Iterate until you have no rows and columns\\n        while top <= bottom and left <= right:\\n\\n            # Since Python ranges are not inclusive, we have to consider adding or substracting 1 to allow complete matrix ranges. \\n\\n            # Iterate from left to right\\n            # We have the top as constant as the row number\\n            for i in range(left, right + 1):\\n                res.append(matrix[top][i])\\n            # Now, we can move to the next row\\n            # Increment top by 1 to move to the next row\\n            top += 1\\n            \\n            # Iterate from top to bottom\\n            # We have right as the constant column number\\n            for i in range(top, bottom + 1):\\n                res.append(matrix[i][right])\\n            # Now, we can elimiate the right column\\n            # Decrement right by 1 to move to the previous column\\n            right -= 1\\n\\n            # In case where we have no more rows to print, \\n            # We need to check if the top is still less than or equal to bottom\\n            if top <= bottom: \\n                # Iterate from right to left\\n                # We have the bottom as constant as the row number\\n                for i in range(right, left - 1, -1):\\n                    res.append(matrix[bottom][i])\\n                # Now, we can elimiate the bottom row\\n                # Decrement right by 1 to move to the previous row  \\n                bottom -= 1\\n\\n            # In case where we have no more columns to print, \\n            # We need to check if the left is still less than or equal to right\\n            if left <= right:\\n                # Iterate from bottom to top\\n                # We have the left as constant as the column number\\n                for i in range(bottom, top - 1, -1):\\n                    res.append(matrix[i][left])\\n                # Now, we can elimiate the left column\\n                # Increment left by 1 to move to the next column  \\n                left += 1\\n\\n        return res\\n```\n``` C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){\\n    // Initialize the 4 directions of the matrix\\n    int top = 0;\\n    int bottom = matrixSize - 1;\\n    int right = *matrixColSize - 1;\\n    int left = 0;\\n\\n    // Create an array to store the resultant array\\n    int *res = (int*)malloc(matrixSize * (*matrixColSize) * sizeof(int));\\n    *returnSize = 0;\\n\\n    // Iterate until you have no rows and columns\\n    while (top <= bottom && left <= right) {\\n        // Iterate from left to right\\n        // We have the top as constant as the row number\\n        for (int i = left; i <= right; i++) {\\n            res[(*returnSize)++] = matrix[top][i];\\n        }\\n        // Now, we can move to the next row\\n        // Increment top by 1 to move to the next row\\n        top++;\\n\\n        // Iterate from top to bottom\\n        // We have right as the constant column number\\n        for (int i = top; i <= bottom; i++) {\\n            res[(*returnSize)++] = matrix[i][right];\\n        }\\n        // Now, we can eliminate the right column\\n        // Decrement right by 1 to move to the previous column\\n        right--;\\n\\n        // In case where we have no more rows to print,\\n        // We need to check if the top is still less than or equal to bottom\\n        if (top <= bottom) {\\n            // Iterate from right to left\\n            // We have the bottom as constant as the row number\\n            for (int i = right; i >= left; i--) {\\n                res[(*returnSize)++] = matrix[bottom][i];\\n            }\\n            // Now, we can eliminate the bottom row\\n            // Decrement bottom by 1 to move to the previous row\\n            bottom--;\\n        }\\n\\n        // In case where we have no more columns to print,\\n        // We need to check if the left is still less than or equal to right\\n        if (left <= right) {\\n            // Iterate from bottom to top\\n            // We have left as constant as the column number\\n            for (int i = bottom; i >= top; i--) {\\n                res[(*returnSize)++] = matrix[i][left];\\n            }\\n            // Now, we can eliminate the left column\\n            // Increment left by 1 to move to the next column\\n            left++;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3507111,
                "title": "c-using-only-single-extra-variable-clean-and-simple",
                "content": "Take a single variable for offset, and then traverse the matrix like you would for the outermost edges and increment the offset each iteration.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> ans;\\n        int st = 0;\\n        int sz = m * n;\\n        while (ans.size() < sz) {\\n            for (int i = st; ans.size() < sz && i < n - st; i++) {\\n                ans.push_back(mat[st][i]);\\n            }\\n            for (int i = st + 1; ans.size() < sz && i < m - st; i++) {\\n                ans.push_back(mat[i][n - st - 1]);\\n            }\\n            for (int i = n - 2 - st; ans.size() < sz && i >= st; i--) {\\n                ans.push_back(mat[m - 1 - st][i]);\\n            }\\n            for (int i = m - 2 - st; ans.size() < sz && i >= st + 1; i--) {\\n                ans.push_back(mat[i][st]);\\n            }\\n            st++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> ans;\\n        int st = 0;\\n        int sz = m * n;\\n        while (ans.size() < sz) {\\n            for (int i = st; ans.size() < sz && i < n - st; i++) {\\n                ans.push_back(mat[st][i]);\\n            }\\n            for (int i = st + 1; ans.size() < sz && i < m - st; i++) {\\n                ans.push_back(mat[i][n - st - 1]);\\n            }\\n            for (int i = n - 2 - st; ans.size() < sz && i >= st; i--) {\\n                ans.push_back(mat[m - 1 - st][i]);\\n            }\\n            for (int i = m - 2 - st; ans.size() < sz && i >= st + 1; i--) {\\n                ans.push_back(mat[i][st]);\\n            }\\n            st++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506091,
                "title": "c-easy-solution-understand-and-try",
                "content": "# Intuition\\n-> It is a simple simulation problem, just need to define the direction and operations of the directions. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> There will be total of 4 directions to move and the loop will continue till the condition reaches that left bound is lesser than right bound and top bound is lesser than lower bound of the matrix boundries limit.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        if (matrix.empty()) {\\n            return ans; // Return empty vector if matrix is empty\\n        }\\n        int dir=0;\\n        int right=matrix[0].size()-1,left=0,top=0,bottom=matrix.size()-1;\\n        while(bottom>=top && right>=left)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                ans.push_back(matrix[top][i]);\\n                }\\n                dir=1;\\n                top++;\\n            }\\n             else if (dir==1)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                ans.push_back(matrix[i][right]);\\n                }\\n                dir=2;\\n                right--;\\n            }\\n            else if(dir==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                 ans.push_back(matrix[bottom][i]);\\n                }\\n                dir=3;\\n                bottom--;\\n            }\\n            else if(dir==3)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                ans.push_back(matrix[i][left]);\\n                }\\n                left++;\\n                dir=0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        if (matrix.empty()) {\\n            return ans; // Return empty vector if matrix is empty\\n        }\\n        int dir=0;\\n        int right=matrix[0].size()-1,left=0,top=0,bottom=matrix.size()-1;\\n        while(bottom>=top && right>=left)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                ans.push_back(matrix[top][i]);\\n                }\\n                dir=1;\\n                top++;\\n            }\\n             else if (dir==1)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                ans.push_back(matrix[i][right]);\\n                }\\n                dir=2;\\n                right--;\\n            }\\n            else if(dir==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                 ans.push_back(matrix[bottom][i]);\\n                }\\n                dir=3;\\n                bottom--;\\n            }\\n            else if(dir==3)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                ans.push_back(matrix[i][left]);\\n                }\\n                left++;\\n                dir=0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503432,
                "title": "c-solution-easy-to-understand-100-beat",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    vector<int> list;\\n\\n    int rowTop = 0;\\n    int rowBottom = matrix.size() - 1;\\n    int columnLeft = 0;\\n    int columnRight = matrix[0].size() - 1;\\n\\n    int direction = 0; \\n\\n    while (rowTop <= rowBottom && columnLeft <= columnRight) {\\n        if (direction == 0) {\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                list.push_back(matrix[rowTop][i]);\\n            }\\n            rowTop++;\\n            direction = (direction + 1) % 4;\\n        } else if (direction == 1) {\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                list.push_back(matrix[i][columnRight]);\\n            }\\n            columnRight--;\\n            direction = (direction + 1) % 4;\\n        } else if (direction == 2) {\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                list.push_back(matrix[rowBottom][i]);\\n            }\\n            rowBottom--;\\n            direction = (direction + 1) % 4;\\n        } else {\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                list.push_back(matrix[i][columnLeft]);\\n            }\\n            columnLeft++;\\n            direction = (direction + 1) % 4;\\n        }\\n    }\\n    return list;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    vector<int> list;\\n\\n    int rowTop = 0;\\n    int rowBottom = matrix.size() - 1;\\n    int columnLeft = 0;\\n    int columnRight = matrix[0].size() - 1;\\n\\n    int direction = 0; \\n\\n    while (rowTop <= rowBottom && columnLeft <= columnRight) {\\n        if (direction == 0) {\\n            for (int i = columnLeft; i <= columnRight; i++) {\\n                list.push_back(matrix[rowTop][i]);\\n            }\\n            rowTop++;\\n            direction = (direction + 1) % 4;\\n        } else if (direction == 1) {\\n            for (int i = rowTop; i <= rowBottom; i++) {\\n                list.push_back(matrix[i][columnRight]);\\n            }\\n            columnRight--;\\n            direction = (direction + 1) % 4;\\n        } else if (direction == 2) {\\n            for (int i = columnRight; i >= columnLeft; i--) {\\n                list.push_back(matrix[rowBottom][i]);\\n            }\\n            rowBottom--;\\n            direction = (direction + 1) % 4;\\n        } else {\\n            for (int i = rowBottom; i >= rowTop; i--) {\\n                list.push_back(matrix[i][columnLeft]);\\n            }\\n            columnLeft++;\\n            direction = (direction + 1) % 4;\\n        }\\n    }\\n    return list;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503387,
                "title": "c-beats-100-dfs-clean-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool isValidIndex(int i, int j, int n, int m){\\n    return (i>=0 and j>=0 and i<n and j<m);\\n}\\n\\nvector<pair<int,int>> moves = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\nvoid dfs(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &vis, vector<int> &ans,int n, int m, bool up){\\n    if(!isValidIndex(i,j,n,m) or vis[i][j]) return;\\n    vis[i][j]=1;\\n    ans.push_back(matrix[i][j]);    \\n    if(up) dfs(i-1,j,matrix,vis,ans,n,m,true);\\n    for(auto x:moves){\\n        int newI=i+x.first;\\n        int newJ=j+x.second;\\n        if((x.first==-1 and x.second==0))\\n        dfs(newI,newJ,matrix,vis,ans,n,m,true);\\n        else dfs(newI,newJ,matrix,vis,ans,n,m,false);  \\n    }\\n} \\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> ans;\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        dfs(0,0,matrix,vis,ans,n,m,false);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool isValidIndex(int i, int j, int n, int m){\\n    return (i>=0 and j>=0 and i<n and j<m);\\n}\\n\\nvector<pair<int,int>> moves = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\nvoid dfs(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &vis, vector<int> &ans,int n, int m, bool up){\\n    if(!isValidIndex(i,j,n,m) or vis[i][j]) return;\\n    vis[i][j]=1;\\n    ans.push_back(matrix[i][j]);    \\n    if(up) dfs(i-1,j,matrix,vis,ans,n,m,true);\\n    for(auto x:moves){\\n        int newI=i+x.first;\\n        int newJ=j+x.second;\\n        if((x.first==-1 and x.second==0))\\n        dfs(newI,newJ,matrix,vis,ans,n,m,true);\\n        else dfs(newI,newJ,matrix,vis,ans,n,m,false);  \\n    }\\n} \\n\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> ans;\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        dfs(0,0,matrix,vis,ans,n,m,false);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502873,
                "title": "check-on-boundary-and-visited-positions-single-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe sequence of direction change is (right, bottom, left, up). And this happens on encounter **boundary** and **visited position**.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the value of martix is between -100~100, just mark every visited position to 1000. Every time we check next position is boundary or visited position? Change direction when true, otherwise keep original. Repeat this until we collect all elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> ans;        \\n        \\n        int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int currDir = 0;\\n        int currR= 0, currC = 0;\\n        // loop until collect all elements\\n        while(ans.size() < m*n) {            \\n            ans.push_back(matrix[currR][currC]);\\n            matrix[currR][currC] = 1000;  // mark visited\\n            int nextR = currR + dir[currDir][0];\\n            int nextC = currC + dir[currDir][1];\\n            // change direction when encounter invalid cases\\n            if(nextR < 0 || nextR >= m || nextC< 0 || nextC >=n || matrix[nextR][nextC] == 1000) \\n                currDir = (currDir+1)%4;                            \\n            currR += dir[currDir][0];\\n            currC += dir[currDir][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> ans;        \\n        \\n        int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int currDir = 0;\\n        int currR= 0, currC = 0;\\n        // loop until collect all elements\\n        while(ans.size() < m*n) {            \\n            ans.push_back(matrix[currR][currC]);\\n            matrix[currR][currC] = 1000;  // mark visited\\n            int nextR = currR + dir[currDir][0];\\n            int nextC = currC + dir[currDir][1];\\n            // change direction when encounter invalid cases\\n            if(nextR < 0 || nextR >= m || nextC< 0 || nextC >=n || matrix[nextR][nextC] == 1000) \\n                currDir = (currDir+1)%4;                            \\n            currR += dir[currDir][0];\\n            currC += dir[currDir][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502617,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    int startingRow=0;\\n    int endingRow=matrix.size()-1;\\n    int startingCol=0;\\n    int endingCol=matrix[0].size()-1;\\n    vector<int> ans;\\n    int total=matrix.size()*matrix[0].size();\\n    int count=0;\\n    while(count<total)\\n    {\\n        //starting row\\n        for(int i=startingCol;i<=endingCol&&count<total;i++)\\n        {\\n            ans.push_back(matrix[startingRow][i]);\\n            count++;\\n        }\\n        startingRow++;\\n        //ending column\\n        for(int i=startingRow;i<=endingRow&&count<total;i++)\\n        {\\n            ans.push_back(matrix[i][endingCol]);\\n            count++;\\n        }\\n        endingCol--;\\n        //ending row\\n        for(int i=endingCol;i>=startingCol&&count<total;i--)\\n        {\\n            ans.push_back(matrix[endingRow][i]);\\n            count++;\\n        }\\n        endingRow--;\\n        //starting column\\n        for(int i=endingRow;i>=startingRow&&count<total;i--)\\n        {\\n            ans.push_back(matrix[i][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n    int startingRow=0;\\n    int endingRow=matrix.size()-1;\\n    int startingCol=0;\\n    int endingCol=matrix[0].size()-1;\\n    vector<int> ans;\\n    int total=matrix.size()*matrix[0].size();\\n    int count=0;\\n    while(count<total)\\n    {\\n        //starting row\\n        for(int i=startingCol;i<=endingCol&&count<total;i++)\\n        {\\n            ans.push_back(matrix[startingRow][i]);\\n            count++;\\n        }\\n        startingRow++;\\n        //ending column\\n        for(int i=startingRow;i<=endingRow&&count<total;i++)\\n        {\\n            ans.push_back(matrix[i][endingCol]);\\n            count++;\\n        }\\n        endingCol--;\\n        //ending row\\n        for(int i=endingCol;i>=startingCol&&count<total;i--)\\n        {\\n            ans.push_back(matrix[endingRow][i]);\\n            count++;\\n        }\\n        endingRow--;\\n        //starting column\\n        for(int i=endingRow;i>=startingRow&&count<total;i--)\\n        {\\n            ans.push_back(matrix[i][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502597,
                "title": "java-simulation-beats-100-20-lines",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public List<Integer> spiralOrder(int[][] matrix) {\\n    int m = matrix.length - 1, n = matrix[0].length;\\n    int x = 0, y = 0;\\n    var list = new ArrayList<Integer>();\\n\\n    while (true) {\\n      if (n == 0) break;\\n      for (var i=0; i<n; i++, y++) list.add(matrix[x][y]);\\n      x++; y--; n--;\\n\\n      if (m == 0) break;\\n      for (var i=0; i<m; i++, x++) list.add(matrix[x][y]);\\n      y--; x--; m--;\\n\\n      if (n == 0) break;\\n      for (var i=0; i<n; i++, y--) list.add(matrix[x][y]);\\n      x--; y++; n--;\\n\\n      if (m == 0) break;\\n      for(var i=0; i<m; i++, x--) list.add(matrix[x][y]);\\n      y++; x++; m--;\\n    }\\n    return list;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  public List<Integer> spiralOrder(int[][] matrix) {\\n    int m = matrix.length - 1, n = matrix[0].length;\\n    int x = 0, y = 0;\\n    var list = new ArrayList<Integer>();\\n\\n    while (true) {\\n      if (n == 0) break;\\n      for (var i=0; i<n; i++, y++) list.add(matrix[x][y]);\\n      x++; y--; n--;\\n\\n      if (m == 0) break;\\n      for (var i=0; i<m; i++, x++) list.add(matrix[x][y]);\\n      y--; x--; m--;\\n\\n      if (n == 0) break;\\n      for (var i=0; i<n; i++, y--) list.add(matrix[x][y]);\\n      x--; y++; n--;\\n\\n      if (m == 0) break;\\n      for(var i=0; i<m; i++, x--) list.add(matrix[x][y]);\\n      y++; x++; m--;\\n    }\\n    return list;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502594,
                "title": "daily-leetcoding-challenge-may-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Set Up Boundaries\n\n  \n**Approach 2:** Mark Visited Elements\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/spiral-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3474923,
                "title": "python-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        left, right, top, bottom = 0, len(matrix[0])-1, 0, len(matrix)-1\\n        res = []\\n\\n        while left<=right and top<=bottom:\\n\\n            for i in range(left, right+1):\\n                res.append(matrix[top][i])\\n            top += 1\\n\\n            for i in range(top, bottom+1):\\n                res.append(matrix[i][right])\\n            right -= 1\\n\\n            if left>right or top>bottom:\\n                break\\n            \\n            for i in range(right, left-1, -1):\\n                res.append(matrix[bottom][i])\\n            bottom -= 1\\n\\n            for i in range(bottom, top-1, -1):\\n                res.append(matrix[i][left])\\n            left += 1\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        left, right, top, bottom = 0, len(matrix[0])-1, 0, len(matrix)-1\\n        res = []\\n\\n        while left<=right and top<=bottom:\\n\\n            for i in range(left, right+1):\\n                res.append(matrix[top][i])\\n            top += 1\\n\\n            for i in range(top, bottom+1):\\n                res.append(matrix[i][right])\\n            right -= 1\\n\\n            if left>right or top>bottom:\\n                break\\n            \\n            for i in range(right, left-1, -1):\\n                res.append(matrix[bottom][i])\\n            bottom -= 1\\n\\n            for i in range(bottom, top-1, -1):\\n                res.append(matrix[i][left])\\n            left += 1\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284609,
                "title": "one-line-python-solution-with-screenshots",
                "content": "![Screenshot 2023-03-11 at 16.10.07.png](https://assets.leetcode.com/users/images/fd7f120e-b8e5-444a-bc53-84fa4a6a184b_1678547485.512829.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralOrder(self, x: List[List[int]]) -> List[int]:\\n        \\n        return x and [*x.pop(0)] + self.spiralOrder([*zip(*x)][::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, x: List[List[int]]) -> List[int]:\\n        \\n        return x and [*x.pop(0)] + self.spiralOrder([*zip(*x)][::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076748,
                "title": "java-optimal-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int left = 0, top = 0, bottom = matrix.length-1, right = matrix[0].length-1;\\n        List<Integer> list = new ArrayList<>();\\n\\n        while(top <= bottom && left <= right){\\n\\n            for(int i=left; i<=right; i++)\\n               list.add(matrix[top][i]);\\n            top++;\\n\\n            for(int i=top; i<=bottom; i++)\\n                list.add(matrix[i][right]);\\n            right--;\\n\\n            if (top <= bottom){\\n            for(int i=right; i>=left; i--)\\n                list.add(matrix[bottom][i]);\\n            bottom--;\\n            }\\n\\n            if (left <= right){\\n            for(int i=bottom; i>=top; i--)\\n                list.add(matrix[i][left]);\\n            left++;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int left = 0, top = 0, bottom = matrix.length-1, right = matrix[0].length-1;\\n        List<Integer> list = new ArrayList<>();\\n\\n        while(top <= bottom && left <= right){\\n\\n            for(int i=left; i<=right; i++)\\n               list.add(matrix[top][i]);\\n            top++;\\n\\n            for(int i=top; i<=bottom; i++)\\n                list.add(matrix[i][right]);\\n            right--;\\n\\n            if (top <= bottom){\\n            for(int i=right; i>=left; i--)\\n                list.add(matrix[bottom][i]);\\n            bottom--;\\n            }\\n\\n            if (left <= right){\\n            for(int i=bottom; i>=top; i--)\\n                list.add(matrix[i][left]);\\n            left++;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991623,
                "title": "super-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row_start=0,col_start=0,row_end=matrix.size()-1,col_end=matrix[0].size()-1;\\n        vector<int> ans;\\n\\n        while(row_start<=row_end && col_start<=col_end){\\n            for(int col=col_start; col<=col_end;col++){\\n                ans.push_back(matrix[row_start][col]);\\n            }\\n            row_start++;\\n             for(int row=row_start; row<=row_end;row++){\\n                ans.push_back(matrix[row][col_end]);\\n            }\\n            col_end--;\\n             for(int col=col_end; col>=col_start && row_start <= row_end;col--){\\n                ans.push_back(matrix[row_end][col]);\\n            }\\n            row_end--;\\n             for(int row=row_end; row>=row_start  && col_start <= col_end;row--){\\n                ans.push_back(matrix[row][col_start]);\\n            }\\n            col_start++;\\n        }\\n        \\n        return ans;\\n        \\n         vector<int>res;\\n        if(matrix.size() == 0) return res;\\n        int minR = 0, maxR = matrix.size() - 1, minC = 0, maxC = matrix[0].size() - 1;\\n        while(minR <= maxR && minC <= maxC){\\n            for(int i = minC; i <= maxC; i++) res.push_back(matrix[minR][i]);\\n            minR++;\\n            for(int i = minR; i <= maxR; i++) res.push_back(matrix[i][maxC]);\\n            maxC--;\\n            for(int i = maxC; i >= minC && minR <= maxR; i--) res.push_back(matrix[maxR][i]);\\n            maxR--;\\n            for(int i = maxR; i >= minR && minC <= maxC; i--) res.push_back(matrix[i][minC]);\\n            minC++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row_start=0,col_start=0,row_end=matrix.size()-1,col_end=matrix[0].size()-1;\\n        vector<int> ans;\\n\\n        while(row_start<=row_end && col_start<=col_end){\\n            for(int col=col_start; col<=col_end;col++){\\n                ans.push_back(matrix[row_start][col]);\\n            }\\n            row_start++;\\n             for(int row=row_start; row<=row_end;row++){\\n                ans.push_back(matrix[row][col_end]);\\n            }\\n            col_end--;\\n             for(int col=col_end; col>=col_start && row_start <= row_end;col--){\\n                ans.push_back(matrix[row_end][col]);\\n            }\\n            row_end--;\\n             for(int row=row_end; row>=row_start  && col_start <= col_end;row--){\\n                ans.push_back(matrix[row][col_start]);\\n            }\\n            col_start++;\\n        }\\n        \\n        return ans;\\n        \\n         vector<int>res;\\n        if(matrix.size() == 0) return res;\\n        int minR = 0, maxR = matrix.size() - 1, minC = 0, maxC = matrix[0].size() - 1;\\n        while(minR <= maxR && minC <= maxC){\\n            for(int i = minC; i <= maxC; i++) res.push_back(matrix[minR][i]);\\n            minR++;\\n            for(int i = minR; i <= maxR; i++) res.push_back(matrix[i][maxC]);\\n            maxC--;\\n            for(int i = maxC; i >= minC && minR <= maxR; i--) res.push_back(matrix[maxR][i]);\\n            maxR--;\\n            for(int i = maxR; i >= minR && minC <= maxC; i--) res.push_back(matrix[i][minC]);\\n            minC++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681041,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        out = []\\n        while matrix:\\n            out+=matrix.pop(0)\\n            if matrix:\\n                for i in range(len(matrix)-1):\\n                    if len(matrix[i])!=0:\\n                        out.append(matrix[i].pop())\\n            if matrix:\\n                out+=matrix.pop()[::-1]\\n            if matrix:\\n                for i in range(1,len(matrix)+1 ):\\n                    if len(matrix[-i])!=0:\\n                        out.append(matrix[-i].pop(0))\\n            \\n        return out\\n```\\n***DO UPVOTE***",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        out = []\\n        while matrix:\\n            out+=matrix.pop(0)\\n            if matrix:\\n                for i in range(len(matrix)-1):\\n                    if len(matrix[i])!=0:\\n                        out.append(matrix[i].pop())\\n            if matrix:\\n                out+=matrix.pop()[::-1]\\n            if matrix:\\n                for i in range(1,len(matrix)+1 ):\\n                    if len(matrix[-i])!=0:\\n                        out.append(matrix[-i].pop(0))\\n            \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665398,
                "title": "javascript-simple-and-easy-beginner-friendly",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    \\n    if(matrix.length==0){\\n            return null ;\\n        }\\n        \\n        let rows=matrix.length;\\n        let cols=matrix[0].length;\\n        let col=0,row=0;\\n        let count=0;\\n        let max=rows*cols;\\n        \\n        let mat = [];\\n        \\n        while(count<max){\\n            \\n            for(let i=col;count<max && i<cols;++i){\\n                mat.push(matrix[row][i]);\\n                count++;\\n                }\\n            row++;\\n            \\n            for(let i=row; count<max && i<rows;++i){\\n               mat.push(matrix[i][cols-1]);\\n                count++;\\n            }\\n            cols--;\\n            \\n            for(let i=cols-1; count<max && i>=col;--i){\\n               mat.push(matrix[rows-1][i]);\\n                count++;\\n            }\\n            rows--;\\n            \\n            for(let i=rows-1;count<max && i>=row;--i){\\n              mat.push(matrix[i][col]);\\n                count++;\\n            }\\n            col++;\\n        }\\n        \\n        return mat;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar spiralOrder = function(matrix) {\\n    \\n    if(matrix.length==0){\\n            return null ;\\n        }\\n        \\n        let rows=matrix.length;\\n        let cols=matrix[0].length;\\n        let col=0,row=0;\\n        let count=0;\\n        let max=rows*cols;\\n        \\n        let mat = [];\\n        \\n        while(count<max){\\n            \\n            for(let i=col;count<max && i<cols;++i){\\n                mat.push(matrix[row][i]);\\n                count++;\\n                }\\n            row++;\\n            \\n            for(let i=row; count<max && i<rows;++i){\\n               mat.push(matrix[i][cols-1]);\\n                count++;\\n            }\\n            cols--;\\n            \\n            for(let i=cols-1; count<max && i>=col;--i){\\n               mat.push(matrix[rows-1][i]);\\n                count++;\\n            }\\n            rows--;\\n            \\n            for(let i=rows-1;count<max && i>=row;--i){\\n              mat.push(matrix[i][col]);\\n                count++;\\n            }\\n            col++;\\n        }\\n        \\n        return mat;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485559,
                "title": "kotlin-iterative-simulation",
                "content": "```\\nclass Solution {\\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\\n        val list = mutableListOf<Int>()\\n        var t = 0\\n        var l = 0\\n        var b = matrix.size - 1\\n        var r = matrix[0].size - 1\\n        var dir = 0\\n        while (t <= b && l <= r) {\\n            if (dir == 0) {\\n                for (i in l until r + 1) {\\n                    list.add(matrix[l][i])\\n                }\\n                t++\\n            } else if (dir == 1) {\\n                for (i in t until b + 1) {\\n                    list.add(matrix[i][r])\\n                }\\n                r--\\n            } else if (dir == 2) {\\n                for (i in r downTo l) {\\n                    list.add(matrix[b][i])\\n                }\\n                b--\\n            } else if (dir == 3) {\\n                for (i in b downTo t) {\\n                    list.add(matrix[i][l])\\n                }\\n                l++\\n            }\\n            dir = (dir + 1) % 4\\n            \\n        }\\n        return list\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\\n        val list = mutableListOf<Int>()\\n        var t = 0\\n        var l = 0\\n        var b = matrix.size - 1\\n        var r = matrix[0].size - 1\\n        var dir = 0\\n        while (t <= b && l <= r) {\\n            if (dir == 0) {\\n                for (i in l until r + 1) {\\n                    list.add(matrix[l][i])\\n                }\\n                t++\\n            } else if (dir == 1) {\\n                for (i in t until b + 1) {\\n                    list.add(matrix[i][r])\\n                }\\n                r--\\n            } else if (dir == 2) {\\n                for (i in r downTo l) {\\n                    list.add(matrix[b][i])\\n                }\\n                b--\\n            } else if (dir == 3) {\\n                for (i in b downTo t) {\\n                    list.add(matrix[i][l])\\n                }\\n                l++\\n            }\\n            dir = (dir + 1) % 4\\n            \\n        }\\n        return list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334019,
                "title": "very-simple-dynamic-programming-0ms-java",
                "content": "# **Dynamic Programming Solution (Java)**\\n## Concept\\nThis solution is built around dynamic programming. We know from the problem description that all numbers `x` in the matrix will be `-100 < x < 100`. We leverage this knowledge to denote that `final int VISITED = 101;` in the matrix. Then, we set a direction that the traversal is going, starting with `\"left\"`.\\n\\n## For-Loop Logic\\nThe next assumption we can make is about the loop. My initial thought was to use a while loop, but there would be multiple conditions to track in the while-loop conditional. To simplify this, we can see that traversing every number in the matrix will be `n x m` iterations, where `n = matrix height` and `m = matrix width`. We should never need to re-traverse a part of the matrix, so we can safely set this as the upper bound of the for-loop.\\n\\n## Switch-Statement\\nOnce we are inside the for-loop, we use a switch statement combined with if-statements to check first what direction we\\'re going then if we have reached the end of the unvisited portion of that respective row or column. If we have reached the end of the unvisited section of that row or column, then we switch directions and increment x or y in that direction.\\n\\n### Note:\\nI decided to put the the logic that adds numbers to the solution list and marks the index in the matrix as visited before the switch statement so that it wouldn\\'t have to be duplicated in each case. This is why the else-branches need to begin the traversal for the next direction. That way numbers don\\'t get double-printed.\\n\\n```\\nclass Solution {\\n    final int VISITED = 101; // We know that all numbers x in the matrix will be -100 < x < 100\\n    \\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        String direction = \"right\";\\n        List<Integer> solution = new ArrayList<Integer>();\\n        int y = 0;\\n        int x = 0;\\n        \\n        for (int i = 0; i < matrix.length * matrix[0].length; i++) {\\n            solution.add(matrix[y][x]);\\n            matrix[y][x] = VISITED;\\n            switch (direction) {\\n                case \"right\":\\n                    if ((x + 1) < matrix[0].length && matrix[y][x + 1] != VISITED) {\\n                        x++;\\n                    }\\n                    else {\\n                        y++;\\n                        direction = \"down\";\\n                    }\\n                    break;\\n                case \"left\":\\n                    if ((x - 1) >= 0 && matrix[y][x - 1] != VISITED) {\\n                        x--;\\n                    }\\n                    else {\\n                        y--;\\n                        direction = \"up\";\\n                    }\\n                    break;\\n                case \"up\":\\n                    if ((y - 1) >= 0 && matrix[y - 1][x] != VISITED) {\\n                        y--;\\n                    }\\n                    else {\\n                        x++;\\n                        direction = \"right\";\\n                    }\\n                    break;\\n                case \"down\":\\n                    if ((y + 1) < matrix.length && matrix[y + 1][x] != VISITED) {\\n                        y++;\\n                    }\\n                    else {\\n                        x--;\\n                        direction = \"left\";\\n                    }\\n                    break;\\n            }\\n        }\\n        return solution;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    final int VISITED = 101; // We know that all numbers x in the matrix will be -100 < x < 100\\n    \\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        String direction = \"right\";\\n        List<Integer> solution = new ArrayList<Integer>();\\n        int y = 0;\\n        int x = 0;\\n        \\n        for (int i = 0; i < matrix.length * matrix[0].length; i++) {\\n            solution.add(matrix[y][x]);\\n            matrix[y][x] = VISITED;\\n            switch (direction) {\\n                case \"right\":\\n                    if ((x + 1) < matrix[0].length && matrix[y][x + 1] != VISITED) {\\n                        x++;\\n                    }\\n                    else {\\n                        y++;\\n                        direction = \"down\";\\n                    }\\n                    break;\\n                case \"left\":\\n                    if ((x - 1) >= 0 && matrix[y][x - 1] != VISITED) {\\n                        x--;\\n                    }\\n                    else {\\n                        y--;\\n                        direction = \"up\";\\n                    }\\n                    break;\\n                case \"up\":\\n                    if ((y - 1) >= 0 && matrix[y - 1][x] != VISITED) {\\n                        y--;\\n                    }\\n                    else {\\n                        x++;\\n                        direction = \"right\";\\n                    }\\n                    break;\\n                case \"down\":\\n                    if ((y + 1) < matrix.length && matrix[y + 1][x] != VISITED) {\\n                        y++;\\n                    }\\n                    else {\\n                        x--;\\n                        direction = \"left\";\\n                    }\\n                    break;\\n            }\\n        }\\n        return solution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280721,
                "title": "stuck-like-me-this-may-help-you",
                "content": "Hello, everyone \\n     This is pretty simple question at first but at time of execution it may become trickier\\n\\t Here are some tips which can help you to understand better.\\n1.  Most important is having good and relatable variable name such as we are related to row & column in term of matrix. So, give variable names like \\n**row_begin, row_end, col_begin, col_end.**\\ngiving a names like top, down, start and etc. is okay but it\\'s good to have names like above.\\n2. As shown in diagram we have to traverse thorugh all element and to traverse we have to move right, down, left, up so to traverse accordingly we have to col_begin++,row_begin++,col_end--,row_end-- respectively for desired result.\\n3. having proper condition also hleps a lot. \\nwe\\'ll end our while loop when our row_begin and col_begin reach their limits simultaneously\\n4. Increament & decreament row & col according to need.\\nrest we\\'ll see in code\\n\\nCode: \\n```\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int  m = matrix.length-1;\\n        int n = matrix[0].length-1;\\n        int row_begin = 0, col_begin = 0, row_end = m, col_end = n;\\n        while(row_begin <= row_end && col_begin <= col_end){  // setting our condition\\n            for(int i = col_begin; i <= col_end ; i++){      // this for loop will initiate from 0 and will go till 2\\n                list.add(matrix[row_begin][i]);                // list = [ 1,2,3] , remaining [[4,5,6],[7,8,9]]\\n            }\\n            row_begin++;                                              // increamenting row by 1\\n            for(int i = row_begin; i <= row_end ; i++){    // i = 1 till i = 2 because we only need 2 remaining element from end column.\\n                list.add(matrix[i][col_end]);                     // list contains, list = [ 1,2,3,6,9], remaining [[4,5],[7,8]\\n            }\\n            col_end--;                                                   // decreasing our col cause we have to traverse left\\n            if(row_begin <= row_end){                            // if row_begin is greater than 2 than condition won\\'t work\\n                for(int i = col_end; i >= col_begin  ; i--){      // i = 1 till i = 0 \\n                list.add(matrix[row_end][i]);                   // list [1,2,3,6,9,8,7] remaining [[ 4,5]]\\n            }\\n            }\\n            row_end--;                                                  //  decresing rowend will get us upwards\\n            if(col_begin <= col_end){                                \\n                for(int i =row_end; i >= row_begin ; i--){      // i = 1 till i = 0\\n                list.add(matrix[i][colb_egin]);                     // list [ 1,2,3,6,9,8,7,4] remaining [[5]]\\n            }\\n            }\\n            col_begin++;                                               // Increamenting col will give us remaining element and our while loop \\n\\t\\t\\t                                                           // won\\'t break cause colbegin has not exided it\\'s limit yet.\\n        }\\n      return list;\\n    }\\n```\\ni hope this helps you.\\nthanks!\\nKeep grinding!!",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\npublic List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int  m = matrix.length-1;\\n        int n = matrix[0].length-1;\\n        int row_begin = 0, col_begin = 0, row_end = m, col_end = n;\\n        while(row_begin <= row_end && col_begin <= col_end){  // setting our condition\\n            for(int i = col_begin; i <= col_end ; i++){      // this for loop will initiate from 0 and will go till 2\\n                list.add(matrix[row_begin][i]);                // list = [ 1,2,3] , remaining [[4,5,6],[7,8,9]]\\n            }\\n            row_begin++;                                              // increamenting row by 1\\n            for(int i = row_begin; i <= row_end ; i++){    // i = 1 till i = 2 because we only need 2 remaining element from end column.\\n                list.add(matrix[i][col_end]);                     // list contains, list = [ 1,2,3,6,9], remaining [[4,5],[7,8]\\n            }\\n            col_end--;                                                   // decreasing our col cause we have to traverse left\\n            if(row_begin <= row_end){                            // if row_begin is greater than 2 than condition won\\'t work\\n                for(int i = col_end; i >= col_begin  ; i--){      // i = 1 till i = 0 \\n                list.add(matrix[row_end][i]);                   // list [1,2,3,6,9,8,7] remaining [[ 4,5]]\\n            }\\n            }\\n            row_end--;                                                  //  decresing rowend will get us upwards\\n            if(col_begin <= col_end){                                \\n                for(int i =row_end; i >= row_begin ; i--){      // i = 1 till i = 0\\n                list.add(matrix[i][colb_egin]);                     // list [ 1,2,3,6,9,8,7,4] remaining [[5]]\\n            }\\n            }\\n            col_begin++;                                               // Increamenting col will give us remaining element and our while loop \\n\\t\\t\\t                                                           // won\\'t break cause colbegin has not exided it\\'s limit yet.\\n        }\\n      return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2056320,
                "title": "easy-c-solution",
                "content": "\\tHere,       dir=0 -> left to right\\n\\t\\t\\t    dir=1 -> top to bottom\\n\\t\\t\\t    dir=2 -> right to left\\n\\t\\t\\t    dir=3 -> bottom to top\\n\\n```\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\tvector<int> ans;\\n\\tint dir = 0;\\n\\tint n = matrix.size();\\n\\tint top = 0, bottom = n - 1, left = 0, right = matrix[0].size() - 1;\\n\\twhile (top <= bottom && left<=right) {\\n\\t\\tif (dir == 0) {\\n\\t\\t\\tfor (int i = left; i <= right; ++i) {\\n\\t\\t\\t\\tans.push_back(matrix[top][i]);\\n\\t\\t\\t}\\n                top++;\\n\\t\\t}\\n\\t\\tif (dir == 1) {\\n\\t\\t\\tfor (int i = top; i <= bottom; ++i) {\\n\\t\\t\\t\\tans.push_back(matrix[i][right]);\\n\\t\\t\\t}\\n                right--;\\n\\t\\t}\\n\\t\\tif (dir == 2) {\\n\\t\\t\\tfor (int i = right; i >= left; --i) {\\n\\t\\t\\t\\tans.push_back(matrix[bottom][i]);\\n\\t\\t\\t}\\n                bottom--;\\n\\t\\t}\\n\\t\\tif (dir == 3) {\\n\\t\\t\\tfor (int i = bottom; i >= top; --i) {\\n\\t\\t\\t\\tans.push_back(matrix[i][left]);\\n\\t\\t\\t}\\n                left++;\\n\\t\\t}\\n\\t\\tdir = (dir + 1) % 4;\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\tvector<int> ans;\\n\\tint dir = 0;\\n\\tint n = matrix.size();\\n\\tint top = 0, bottom = n - 1, left = 0, right = matrix[0].size() - 1;\\n\\twhile (top <= bottom && left<=right) {\\n\\t\\tif (dir == 0) {\\n\\t\\t\\tfor (int i = left; i <= right; ++i) {\\n\\t\\t\\t\\tans.push_back(matrix[top][i]);\\n\\t\\t\\t}\\n                top++;\\n\\t\\t}\\n\\t\\tif (dir == 1) {\\n\\t\\t\\tfor (int i = top; i <= bottom; ++i) {\\n\\t\\t\\t\\tans.push_back(matrix[i][right]);\\n\\t\\t\\t}\\n                right--;\\n\\t\\t}\\n\\t\\tif (dir == 2) {\\n\\t\\t\\tfor (int i = right; i >= left; --i) {\\n\\t\\t\\t\\tans.push_back(matrix[bottom][i]);\\n\\t\\t\\t}\\n                bottom--;\\n\\t\\t}\\n\\t\\tif (dir == 3) {\\n\\t\\t\\tfor (int i = bottom; i >= top; --i) {\\n\\t\\t\\t\\tans.push_back(matrix[i][left]);\\n\\t\\t\\t}\\n                left++;\\n\\t\\t}\\n\\t\\tdir = (dir + 1) % 4;\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031219,
                "title": "simplest-c-solution",
                "content": "```\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count = 0;\\n        int total = row*col;\\n        int startingRow = 0;\\n        int startingCol = 0;\\n        int endingRow = row - 1;\\n        int endingCol = col - 1;\\n        while(count < total)\\n        {\\n            for(int index = startingCol; index <= endingCol && count < total; index++)\\n            {\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n             for(int index = startingRow; index <= endingRow && count < total; index++)\\n            {\\n                ans.push_back(matrix[index][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n             for(int index = endingCol; index >= startingCol && count < total; index--)\\n            {\\n                ans.push_back(matrix[endingRow][index]);\\n                count++;\\n            }\\n            endingRow--;\\n             for(int index = endingRow; index >= startingRow && count < total; index--)\\n            {\\n                ans.push_back(matrix[index][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count = 0;\\n        int total = row*col;\\n        int startingRow = 0;\\n        int startingCol = 0;\\n        int endingRow = row - 1;\\n        int endingCol = col - 1;\\n        while(count < total)\\n        {\\n            for(int index = startingCol; index <= endingCol && count < total; index++)\\n            {\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n             for(int index = startingRow; index <= endingRow && count < total; index++)\\n            {\\n                ans.push_back(matrix[index][endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n             for(int index = endingCol; index >= startingCol && count < total; index--)\\n            {\\n                ans.push_back(matrix[endingRow][index]);\\n                count++;\\n            }\\n            endingRow--;\\n             for(int index = endingRow; index >= startingRow && count < total; index--)\\n            {\\n                ans.push_back(matrix[index][startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1955739,
                "title": "200-easiest-solution",
                "content": "spiralOrder = function(matrix) {\\n    const result = [];\\n    let top =0;\\n    let left =0;\\n    let bottom = matrix.length-1;\\n    let right = matrix[0].length-1;\\n    const size = matrix.length * matrix[0].length;\\n    \\n    while( result.length<size ){\\n        for( let i = left ; i<= right && result.length<size ; i++ ){\\n            result.push(matrix[top][i]);\\n        }\\n        top++;\\n        \\n        for( let i = top ; i <= bottom && result.length<size ; i++ ){\\n            result.push(matrix[i][right]);\\n        }\\n        right--;\\n        \\n        for( let i = right ; i>= left && result.length<size ; i-- ){\\n            result.push(matrix[bottom][i]);\\n        }\\n        bottom--;\\n        \\n        for( let i = bottom ; i>= top && result.length<size ; i-- ){\\n            result.push(matrix[i][left])\\n        }\\n        left++;\\n            \\n    }\\n    return result;",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "spiralOrder = function(matrix) {\\n    const result = [];\\n    let top =0;\\n    let left =0;\\n    let bottom = matrix.length-1;\\n    let right = matrix[0].length-1;\\n    const size = matrix.length * matrix[0].length;\\n    \\n    while( result.length<size ){\\n        for( let i = left ; i<= right && result.length<size ; i++ ){\\n            result.push(matrix[top][i]);\\n        }\\n        top++;\\n        \\n        for( let i = top ; i <= bottom && result.length<size ; i++ ){\\n            result.push(matrix[i][right]);\\n        }\\n        right--;\\n        \\n        for( let i = right ; i>= left && result.length<size ; i-- ){\\n            result.push(matrix[bottom][i]);\\n        }\\n        bottom--;\\n        \\n        for( let i = bottom ; i>= top && result.length<size ; i-- ){\\n            result.push(matrix[i][left])\\n        }\\n        left++;\\n            \\n    }\\n    return result;",
                "codeTag": "Unknown"
            },
            {
                "id": 1941703,
                "title": "c-matrix-easy-understanding-beats-100",
                "content": "# C++ Code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int row=mat.size(), col=mat[0].size();\\n        \\n        vector<int> ans;\\n        \\n        int top=0,down=row-1;//pointer for our ROW\\n        int left=0,right=col-1;//pointers for our COLUMN\\n        \\n        int dir=0;//helps us in knowing in which direction to traverse\\n        \\n        //dirx: 0->left to right, 1->top to down\\n        //2->right to left  3->down to top\\n        while(top<=down && left<=right){\\n            \\n            if(dir == 0){\\n                for(int i=left; i<=right; i++) //L->R\\n                    ans.push_back(mat[top][i]);\\n                \\n                top += 1;     \\n            }\\n            \\n            else if(dir == 1){//T->D\\n                for(int i=top;i<=down;i++)\\n                    ans.push_back(mat[i][right]);\\n                \\n                right -= 1;\\n            }\\n            \\n            else if(dir == 2){//R->L\\n                for(int i=right; i >= left; i--)\\n                    ans.push_back(mat[down][i]);\\n                \\n                down -= 1;\\n            }\\n            \\n            else if(dir == 3){//D->T\\n                for(int i=down; i>= top ; i--)\\n                    ans.push_back(mat[i][left]);\\n                \\n                left += 1;\\n            }\\n            \\n            //change dirxn \\n            dir = (dir + 1)%4;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote, if this solution been any help to you!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& mat) {\\n        int row=mat.size(), col=mat[0].size();\\n        \\n        vector<int> ans;\\n        \\n        int top=0,down=row-1;//pointer for our ROW\\n        int left=0,right=col-1;//pointers for our COLUMN\\n        \\n        int dir=0;//helps us in knowing in which direction to traverse\\n        \\n        //dirx: 0->left to right, 1->top to down\\n        //2->right to left  3->down to top\\n        while(top<=down && left<=right){\\n            \\n            if(dir == 0){\\n                for(int i=left; i<=right; i++) //L->R\\n                    ans.push_back(mat[top][i]);\\n                \\n                top += 1;     \\n            }\\n            \\n            else if(dir == 1){//T->D\\n                for(int i=top;i<=down;i++)\\n                    ans.push_back(mat[i][right]);\\n                \\n                right -= 1;\\n            }\\n            \\n            else if(dir == 2){//R->L\\n                for(int i=right; i >= left; i--)\\n                    ans.push_back(mat[down][i]);\\n                \\n                down -= 1;\\n            }\\n            \\n            else if(dir == 3){//D->T\\n                for(int i=down; i>= top ; i--)\\n                    ans.push_back(mat[i][left]);\\n                \\n                left += 1;\\n            }\\n            \\n            //change dirxn \\n            dir = (dir + 1)%4;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941255,
                "title": "java-simple-and-easy-to-understand-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int rStart = 0, rEnd = matrix.length-1;\\n        int cStart = 0, cEnd = matrix[0].length-1;\\n        while (rStart <= rEnd && cStart <= cEnd) {\\n            for (int c = cStart; c <= cEnd; c++) list.add(matrix[rStart][c]);\\n            for (int r = rStart + 1; r <= rEnd; r++) list.add(matrix[r][cEnd]);\\n            if (rStart < rEnd && cStart < cEnd) {\\n                for (int c = cEnd - 1; c > cStart; c--) list.add(matrix[rEnd][c]);\\n                for (int r = rEnd; r > rStart; r--) list.add(matrix[r][cStart]);\\n            }\\n            rStart++; rEnd--; cStart++; cEnd--;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> list = new ArrayList<>();\\n        int rStart = 0, rEnd = matrix.length-1;\\n        int cStart = 0, cEnd = matrix[0].length-1;\\n        while (rStart <= rEnd && cStart <= cEnd) {\\n            for (int c = cStart; c <= cEnd; c++) list.add(matrix[rStart][c]);\\n            for (int r = rStart + 1; r <= rEnd; r++) list.add(matrix[r][cEnd]);\\n            if (rStart < rEnd && cStart < cEnd) {\\n                for (int c = cEnd - 1; c > cStart; c--) list.add(matrix[rEnd][c]);\\n                for (int r = rEnd; r > rStart; r--) list.add(matrix[r][cStart]);\\n            }\\n            rStart++; rEnd--; cStart++; cEnd--;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801118,
                "title": "accepted-in-6ms-easy-fast-and-simple-solution-with-comments",
                "content": "### \\u2714 Spiral Matrix  | C++ | Medium Level | Easy, Fast and Simple | 6ms \\n\\n<br>\\nThis is a very simple and easy to understand solution. I traverse right and increment startRow, then traverse down and decrement endColumn, then I traverse left and decrement endRow, and finally I traverse up and increment startColumn.\\n\\nThe edge case here is that when I traverse left or up I have to check whether the row or column is already taken to prevent duplicates.\\n\\nAny comments greatly appreciated. Please Upvote if you liked the solution :)\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        // Take a vector to store spiral matrix.\\n        vector<int> v;\\n        \\n        // Take row and column size.\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        // Take 4 variable for itteration through rows and columns.\\n        int startRow = 0;\\n        int endRow = n - 1;\\n        int startColumn = 0;\\n        int endColumn = m - 1;\\n        \\n        // For boundary checking in rows and columns\\n        while(startRow <= endRow && startColumn <= endColumn){\\n            \\n            // Storing starting row.\\n            for(int column = startColumn; column <= endColumn; column++){\\n                v.push_back(matrix[startRow][column]);\\n            }\\n            \\n            // Storing ending column(Leaving first elemnet which is already taken in starting row)\\n            for(int row = startRow + 1; row <= endRow; row++){\\n                v.push_back(matrix[row][endColumn]);\\n            }\\n            \\n            // Stroring ending row(Leaving last elemnet which is already taken in ending column)\\n            for(int column = endColumn - 1; column >= startColumn; column--){\\n                \\n                // Avoiding Repeating same row twice.\\n                if(startRow == endRow){\\n                    break;\\n                }\\n                \\n                v.push_back(matrix[endRow][column]);\\n            }\\n            \\n            // Storing starting column(Leaving first and last elemnet which is already taken in starting row and ending row)\\n            for(int row = endRow - 1; row >= startRow + 1; row--){\\n                \\n                // Avoiding Repeating same column twice.\\n                if(startColumn == endColumn){\\n                    break;\\n                }\\n                \\n                v.push_back(matrix[row][startColumn]);\\n            }\\n            \\n            // Increment the start row and start column. \\n            // Decrement the end row and end column.\\n            startRow++;\\n            endColumn--;\\n            endRow--;\\n            startColumn++;\\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        // Take a vector to store spiral matrix.\\n        vector<int> v;\\n        \\n        // Take row and column size.\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        // Take 4 variable for itteration through rows and columns.\\n        int startRow = 0;\\n        int endRow = n - 1;\\n        int startColumn = 0;\\n        int endColumn = m - 1;\\n        \\n        // For boundary checking in rows and columns\\n        while(startRow <= endRow && startColumn <= endColumn){\\n            \\n            // Storing starting row.\\n            for(int column = startColumn; column <= endColumn; column++){\\n                v.push_back(matrix[startRow][column]);\\n            }\\n            \\n            // Storing ending column(Leaving first elemnet which is already taken in starting row)\\n            for(int row = startRow + 1; row <= endRow; row++){\\n                v.push_back(matrix[row][endColumn]);\\n            }\\n            \\n            // Stroring ending row(Leaving last elemnet which is already taken in ending column)\\n            for(int column = endColumn - 1; column >= startColumn; column--){\\n                \\n                // Avoiding Repeating same row twice.\\n                if(startRow == endRow){\\n                    break;\\n                }\\n                \\n                v.push_back(matrix[endRow][column]);\\n            }\\n            \\n            // Storing starting column(Leaving first and last elemnet which is already taken in starting row and ending row)\\n            for(int row = endRow - 1; row >= startRow + 1; row--){\\n                \\n                // Avoiding Repeating same column twice.\\n                if(startColumn == endColumn){\\n                    break;\\n                }\\n                \\n                v.push_back(matrix[row][startColumn]);\\n            }\\n            \\n            // Increment the start row and start column. \\n            // Decrement the end row and end column.\\n            startRow++;\\n            endColumn--;\\n            endRow--;\\n            startColumn++;\\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767656,
                "title": "simple-java-loops",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> answer = new ArrayList<>();\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int rep = 0;\\n        while(answer.size()<m*n){\\n            boundaryAdder(matrix,answer,rep,m-rep-1,rep,n-rep-1);\\n            rep++;\\n        }\\n        return answer;\\n    }\\n    public void boundaryAdder(int[][] matrix,List<Integer> answer,int row1,int row2,int col1,int col2){\\n        for(int i=col1;i<=col2;i++) answer.add(matrix[row1][i]);\\n        if(row1==row2) return;\\n        for(int i=row1+1;i<=row2;i++) answer.add(matrix[i][col2]);\\n        if(col1==col2) return;\\n        for(int i=col2-1;i>=col1;i--) answer.add(matrix[row2][i]);\\n        for(int i=row2-1;i>row1;i--) answer.add(matrix[i][col1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> answer = new ArrayList<>();\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int rep = 0;\\n        while(answer.size()<m*n){\\n            boundaryAdder(matrix,answer,rep,m-rep-1,rep,n-rep-1);\\n            rep++;\\n        }\\n        return answer;\\n    }\\n    public void boundaryAdder(int[][] matrix,List<Integer> answer,int row1,int row2,int col1,int col2){\\n        for(int i=col1;i<=col2;i++) answer.add(matrix[row1][i]);\\n        if(row1==row2) return;\\n        for(int i=row1+1;i<=row2;i++) answer.add(matrix[i][col2]);\\n        if(col1==col2) return;\\n        for(int i=col2-1;i>=col1;i--) answer.add(matrix[row2][i]);\\n        for(int i=row2-1;i>row1;i--) answer.add(matrix[i][col1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756575,
                "title": "python-simple-using-loops",
                "content": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        rowStart, rowEnd = 0, len(matrix)-1\\n        colStart, colEnd = 0, len(matrix[0])-1\\n        ans = []\\n        while rowStart<=rowEnd and colStart<=colEnd:\\n            for i in range(colStart, colEnd+1):\\n                ans.append(matrix[rowStart][i])\\n            for i in range(rowStart+1, rowEnd+1):\\n                ans.append(matrix[i][colEnd])\\n            for i in range(colEnd-1, colStart-1, -1):\\n                if rowEnd>rowStart:\\n                    ans.append(matrix[rowEnd][i])\\n            for i in range(rowEnd-1, rowStart, -1):\\n                if colEnd>colStart:\\n                    ans.append(matrix[i][colStart])\\n            rowStart += 1\\n            rowEnd -= 1\\n            colStart += 1\\n            colEnd -= 1 \\n        return ans\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        rowStart, rowEnd = 0, len(matrix)-1\\n        colStart, colEnd = 0, len(matrix[0])-1\\n        ans = []\\n        while rowStart<=rowEnd and colStart<=colEnd:\\n            for i in range(colStart, colEnd+1):\\n                ans.append(matrix[rowStart][i])\\n            for i in range(rowStart+1, rowEnd+1):\\n                ans.append(matrix[i][colEnd])\\n            for i in range(colEnd-1, colStart-1, -1):\\n                if rowEnd>rowStart:\\n                    ans.append(matrix[rowEnd][i])\\n            for i in range(rowEnd-1, rowStart, -1):\\n                if colEnd>colStart:\\n                    ans.append(matrix[i][colStart])\\n            rowStart += 1\\n            rowEnd -= 1\\n            colStart += 1\\n            colEnd -= 1 \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654416,
                "title": "iterative-keep-trying-to-go-right-then-down-then-left-and-then-top-until-all-neighbours-visited",
                "content": "The idea I got it from DFS but it is certainly not a DFS.\\nHere is the idea, I will start to keep trying to go right till it is possible and it is not visited, hence I will keep marking each cell as visited as well by setting the value to 101 as in constraint max value can a cell hold is -100 to 100.\\nThen to go down and then to left and right, untill it is not possible. and I will repeat these steps until I find a cell whose all neighbours are visited.\\n\\nHere is the code in C#:\\nTime Complexity O(mn) as I am visiting each cellonly once.\\nSpace Complexity O(mn) as adding all the numbers in result List object.\\n\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n        int m = matrix.Length, n = matrix[0].Length;\\n        IList<int> result = new List<int>();\\n        \\n        int i = 0, j = 0;\\n        while(true){\\n            //check if all sides are visited\\n            if((j < n-1 && matrix[i][j+1] != 101) //instead of 101 we can make it int.MaxValue or int.MinValue\\n               || (i < m-1 && matrix[i+1][j] != 101) \\n               || (j > 0 && matrix[i][j-1] != 101) \\n               || (i > 0 && matrix[i-1][j] != 101)){\\n                //do nothing\\n            }\\n            else\\n                break;\\n            \\n            //keep going right\\n            while(j < n-1 && matrix[i][j+1] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                j++;\\n            }\\n            \\n            //keep going down\\n            while(i < m-1 && matrix[i+1][j] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                i++;\\n            }\\n            \\n            //keep going left\\n            while(j > 0 && matrix[i][j-1] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                j--;\\n            }\\n            \\n            //keep going up\\n            while(i > 0 && matrix[i-1][j] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                i--;\\n            }\\n        }\\n        \\n        result.Add(matrix[i][j]);\\n        return result;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Matrix",
                    "Simulation",
                    "Iterator"
                ],
                "code": "```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n        int m = matrix.Length, n = matrix[0].Length;\\n        IList<int> result = new List<int>();\\n        \\n        int i = 0, j = 0;\\n        while(true){\\n            //check if all sides are visited\\n            if((j < n-1 && matrix[i][j+1] != 101) //instead of 101 we can make it int.MaxValue or int.MinValue\\n               || (i < m-1 && matrix[i+1][j] != 101) \\n               || (j > 0 && matrix[i][j-1] != 101) \\n               || (i > 0 && matrix[i-1][j] != 101)){\\n                //do nothing\\n            }\\n            else\\n                break;\\n            \\n            //keep going right\\n            while(j < n-1 && matrix[i][j+1] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                j++;\\n            }\\n            \\n            //keep going down\\n            while(i < m-1 && matrix[i+1][j] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                i++;\\n            }\\n            \\n            //keep going left\\n            while(j > 0 && matrix[i][j-1] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                j--;\\n            }\\n            \\n            //keep going up\\n            while(i > 0 && matrix[i-1][j] != 101){\\n                result.Add(matrix[i][j]);\\n                matrix[i][j] = 101;\\n                i--;\\n            }\\n        }\\n        \\n        result.Add(matrix[i][j]);\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640217,
                "title": "understandable-golang-solution-beats-100",
                "content": "There are no special tricks for this problem, we have to traverse the matrix repeatedly in the order of (right, down, left, up). While traversing, we need to keep track of the boundaries of each direction. Namely, top, left, right, bottom boundaries. For example, the top boundary is initialized to 0; after traversing the first row of the matrix, we need to increment the top boundary by 1 so that when we traverse the matrix in the up direction later on, we don\\'t reach the first row which we\\'ve already visited.  \\n\\nTo keep track of the direction we are going, we can have an array that contains 4 values: 0, 1, 2, 3. Each value represents a direction. We can use an incremental variable `round` to tell us which direction we need to go next. `spDir[round%4]` does this job because we are going in 4 directions repeatedly. For example, when `round=0` we are going right, when `round=4` we are going right again.  \\n\\nThe __ending condition__ is when top boundary exceeds bottom boundary or left boundary exceeds right boundary. That said, the solution can be broken down into the following steps:  \\n1. initialize a direction array `spDir` that holds 4 directions represented as integers (0,1,2,3)\\n2. initialize the four boundaries\\n3. initialize a result array(or slice in golang)\\n4. create a for-loop to traverse the matrix in spiral order until the ending condition is met\\n5. Inside the loop, create a simple switch case to determine which direction we are traversing. Update the corresponding boundaries after each iteration.\\n\\n```\\nconst (\\n    right = iota\\n    down\\n    left\\n    up\\n)\\n\\nfunc spiralOrder(matrix [][]int) []int {\\n    m, n := len(matrix), len(matrix[0])\\n    result := []int{}\\n    spDir := []int{right, down, left, up}\\n    // initialize the 4 boundaries\\n    l, r, t, b := 0, n-1, 0, m-1\\n    // traverse the matrix in spiral order\\n    for round := 0; l <= r && t <= b; round++ {\\n        // in each round, we traverse in 1 direction\\n        switch spDir[round%4] {\\n            case 0:\\n                // traverse in right direction\\n                for i, j := l, t; i <= r; i++ {\\n                    result = append(result, matrix[j][i])\\n                }\\n                t++\\n            case 1:\\n                // traverse in down direction\\n                for i, j := r, t; j <= b; j++ {\\n                    result = append(result, matrix[j][i])\\n                }\\n                r--\\n            case 2:\\n                // traverse in left direction\\n                for i, j := r, b; i >= l; i-- {\\n                    result = append(result, matrix[j][i])\\n                }\\n                b--\\n            case 3:\\n                // traverse in up direction\\n                for i, j := l, b; j >= t; j-- {\\n                    result = append(result, matrix[j][i])\\n                }\\n                l++\\n        }\\n    }\\n    return result\\n}\\n```\\n\\nI hope this solution is understandable, feel free to leave a comment if you have any questions.",
                "solutionTags": [],
                "code": "```\\nconst (\\n    right = iota\\n    down\\n    left\\n    up\\n)\\n\\nfunc spiralOrder(matrix [][]int) []int {\\n    m, n := len(matrix), len(matrix[0])\\n    result := []int{}\\n    spDir := []int{right, down, left, up}\\n    // initialize the 4 boundaries\\n    l, r, t, b := 0, n-1, 0, m-1\\n    // traverse the matrix in spiral order\\n    for round := 0; l <= r && t <= b; round++ {\\n        // in each round, we traverse in 1 direction\\n        switch spDir[round%4] {\\n            case 0:\\n                // traverse in right direction\\n                for i, j := l, t; i <= r; i++ {\\n                    result = append(result, matrix[j][i])\\n                }\\n                t++\\n            case 1:\\n                // traverse in down direction\\n                for i, j := r, t; j <= b; j++ {\\n                    result = append(result, matrix[j][i])\\n                }\\n                r--\\n            case 2:\\n                // traverse in left direction\\n                for i, j := r, b; i >= l; i-- {\\n                    result = append(result, matrix[j][i])\\n                }\\n                b--\\n            case 3:\\n                // traverse in up direction\\n                for i, j := l, b; j >= t; j-- {\\n                    result = append(result, matrix[j][i])\\n                }\\n                l++\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1530816,
                "title": "java-code-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        int left = 0, top = 1, item = 0;\\n        int right = matrix[0].length;\\n        int bottom = matrix.length;\\n        int nItems = right * bottom;\\n        right--; bottom--; // Getting the max index positions\\n        \\n        // Traverse all items in the matrix until the traversed item count == total no. of items in the matrix\\n        while(item < nItems){\\n            // Traverse right from left margin to right margin\\n            for(int i=left; i<= right && item < nItems; i++){\\n                result.add(matrix[left][i]);\\n                item++;\\n            }\\n\\n            // Traverse down from top margin to bottom margin\\n            for(int i=top; i <= bottom && item < nItems; i++){\\n                result.add(matrix[i][right]);\\n                item++;\\n            }\\n\\n            // Traverse left from right margin to left margin\\n            for(int i=right-1; i >= left && item < nItems; i--){\\n                result.add(matrix[bottom][i]);\\n                item++;\\n            }            \\n\\n            // Traverse up from bottom margin to top margin\\n            for(int i=bottom-1; i >= top && item < nItems; i--){\\n                result.add(matrix[i][left]);\\n                item++;\\n            }            \\n            left++; // incrementing as we are going from left to right\\n            top++;  // incrementing as we are going from top to bottom\\n            right--; // decrementing as we are going from right to left \\n            bottom--; // decrementing as we are going from bottom to top\\n        }\\n        return result;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        List<Integer> result = new ArrayList<>();\\n        int left = 0, top = 1, item = 0;\\n        int right = matrix[0].length;\\n        int bottom = matrix.length;\\n        int nItems = right * bottom;\\n        right--; bottom--; // Getting the max index positions\\n        \\n        // Traverse all items in the matrix until the traversed item count == total no. of items in the matrix\\n        while(item < nItems){\\n            // Traverse right from left margin to right margin\\n            for(int i=left; i<= right && item < nItems; i++){\\n                result.add(matrix[left][i]);\\n                item++;\\n            }\\n\\n            // Traverse down from top margin to bottom margin\\n            for(int i=top; i <= bottom && item < nItems; i++){\\n                result.add(matrix[i][right]);\\n                item++;\\n            }\\n\\n            // Traverse left from right margin to left margin\\n            for(int i=right-1; i >= left && item < nItems; i--){\\n                result.add(matrix[bottom][i]);\\n                item++;\\n            }            \\n\\n            // Traverse up from bottom margin to top margin\\n            for(int i=bottom-1; i >= top && item < nItems; i--){\\n                result.add(matrix[i][left]);\\n                item++;\\n            }            \\n            left++; // incrementing as we are going from left to right\\n            top++;  // incrementing as we are going from top to bottom\\n            right--; // decrementing as we are going from right to left \\n            bottom--; // decrementing as we are going from bottom to top\\n        }\\n        return result;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467727,
                "title": "c-single-pass-4-pointer-solution-explained-100-time-95-space",
                "content": "Nice problem and I wanted to give myself the extra challenge to solve it without marking the visited cells in any way, even in place.\\n\\nWe can think at this problem in this way:\\n* we can start running through the first row, then we mark it as taken;\\n* then we go down the last colummn and we mark it too;\\n* now we do the last row (in reverse order) and we mark it;\\n* time to go up through the first column, up to its penultimate element (we took it when we started with the last row);\\n* rinse and repeat, until you have taken all the cells just once.\\n\\nNow, in order to make it work without marking the explored cells in any way, we will need 4 pointers and a few more variables:\\n* `lmtLeft`, `lmtRight`, `lmtUp` and `lmtDown` will limit our exploration of the matrix, being initialised to the indexes of the first and last columns before we start the main loop;\\n* `i` is our iterator to write in `res`;\\n* `tot` is the overall amount of elements in the matrix, obtained by multipling `lmtRight` and `lmtDown` right before reducing them by `1` to match the indexes of the last column and row, respectively;\\n* `res` is our accumulator variable, already created at the right size, to avoid reallocations.\\n\\nWe will then create an infinite loop and:\\n* go right, with `x` going from `lmtLeft` to `lmtRight`, using `lmtUp` as `y`, right before increasing it, and write in `res` advancing `i`;\\n* check if we are done writing in `res` (`i == tot`), in which case we `break`;\\n* go down, with `y` going from `lmtUp` to `lmtDown`, using `lmtRight` as x`, right before decreasing it, and write in `res` advancing `i`;\\n* check if we are done writing in `res` (`i == tot`), in which case we `break`;\\n* go left, with `x` going from `lmRight` to `lmtLeft`, using `lmtDown` as `y`, right before decreasing it, and write in `res` advancing `i`;\\n* check if we are done writing in `res` (`i == tot`), in which case we `break`;\\n* go up, with `y` going from `lmtDown` to `lmtUp`, using `lmtLeft` as `x`, right before increasing it, and write in `res` advancing `i`;\\n* check if we are done writing in `res` (`i == tot`), in which case we `break`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& arr) {\\n        // support variables\\n        int lmtLeft = 0, lmtRight = arr[0].size(), lmtUp = 0, lmtDown = arr.size(), i = 0, tot = lmtRight-- * lmtDown--;\\n        vector<int> res(tot);\\n        while (true) {\\n            // going right\\n            for (int x = lmtLeft, y = lmtUp++; x <= lmtRight; x++) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going down\\n            for (int y = lmtUp, x = lmtRight--; y <= lmtDown; y++) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going left\\n            for (int x = lmtRight, y = lmtDown--; x >= lmtLeft; x--) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going up\\n            for (int y = lmtDown, x = lmtLeft++; y >= lmtUp; y--) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& arr) {\\n        // support variables\\n        int lmtLeft = 0, lmtRight = arr[0].size(), lmtUp = 0, lmtDown = arr.size(), i = 0, tot = lmtRight-- * lmtDown--;\\n        vector<int> res(tot);\\n        while (true) {\\n            // going right\\n            for (int x = lmtLeft, y = lmtUp++; x <= lmtRight; x++) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going down\\n            for (int y = lmtUp, x = lmtRight--; y <= lmtDown; y++) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going left\\n            for (int x = lmtRight, y = lmtDown--; x >= lmtLeft; x--) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n            // going up\\n            for (int y = lmtDown, x = lmtLeft++; y >= lmtUp; y--) res[i++] = arr[y][x];\\n            if (i == tot) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1701423,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887881,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887763,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887710,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1776798,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887790,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887838,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1838682,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1565249,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1571130,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1701423,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887881,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887763,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887710,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1776798,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887790,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1887838,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1838682,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1565249,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1571130,
                "content": [
                    {
                        "username": "user4990pi",
                        "content": "Truly hate this question "
                    },
                    {
                        "username": "crsland",
                        "content": "I literally just got asked to code a solution for this at an Interview, BS! Not only that, they gave me 20 min max\\nThese types of questions you either know it or don\\'t, very very hard to infer in 20 minutes under pressure.\\n"
                    },
                    {
                        "username": "jwonz",
                        "content": "[@mshoosterman](/mshoosterman) It\\'s actually super easy if you\\'ve done any game development.. it\\'s a simple agent traveling a grid."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question would be a nightmare on an interview. Its a truly easy question, but keeping track of your transversal makes it nearly a hard. "
                    },
                    {
                        "username": "meow_power",
                        "content": "we hate it:)"
                    },
                    {
                        "username": "FrozenHearth",
                        "content": "I agree. This shouldn\\'t even be a medium."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Just Completed My 100 Day\\'s Streak \\uD83D\\uDE0A"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good job bro !! u r inspiring :)\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "you get the 100 days badge with 100 days strike sending solutions or 100 days sending solutions but not in strike"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\n![image.png](https://assets.leetcode.com/users/images/b05a7500-de79-473f-9be4-4c5df6294f83_1683594102.628307.png)\nIt's all nice until a boundary comes and we need to change the direction of traversal. Can you track those boundaries for each direction?\n\n# Hint 2\n<details>\n<summary>Click to See</summary>\n<br/>\n<img src=\"https://assets.leetcode.com/users/images/ce7e309f-7977-4bca-94f8-9b42ec6798bf_1683595355.2647583.png\" alt=\"Boundaries Image\">\n</details>\n\nSo, the initial boundaries are $[[0,n-1],[m-1,n-1],[m-1,0],[1,0]]$.\nWhen we reach a boundary, change the direction of traversal by $90^o$ clockwise.\n\n# Hint 3\nLet $[r,c]$ be the current cell and the next cell is given as $[r',c'] = [r + dr, c + dc]$.\nHere, $dr$ and $dc$ are the respective changes in row and column for different directions given as:\n| Index | Direction | $dr$ | $dc$ |\n| :-- | :-- | :--: | :--: |\n| 0 | Right | 0 | 1 |\n| 1 | Down | 1 | 0 |\n| 2 | Left | 0 | -1 |\n| 3 | Up | -1 | 0 |\n\nChange in direction of traversal is $Right - Down - Left - Up$\n\n# Hint 4\n![image.png](https://assets.leetcode.com/users/images/6db646e6-7fcd-4672-9ebf-5ad24c1b8466_1683596857.2943535.png)\nSuppose we have completed one spiral and standing at $8$. Now, we have the same problem but for a smaller matrix ($matrix[1...m-2][1...n-2]$). Recursion can be used.\n\n# Hint 5\nCreate a generalized version of the sub-matrix ($matrix[r_1 ... r_2][c_1 ... c_2]$) as \n![image.png](https://assets.leetcode.com/users/images/37e13048-8064-4d7f-ab60-15f0ec113529_1683597332.3357146.png)\nBoundaries will be $[[r_1,c_2],[r_2,c_2],[r_2,c_1],[r_1 + 1,c_1]]$.\nLet $f(matrix[r_1 ... r_2][c_1 ... c_2])$ calculates for one spiral.\nRecursively call on $f(matrix[r_1 + 1 ... r_2 - 1][c_1 + 1 ... c_2 - 1])$.\n\n---\n\nNote: Final solution: [Click](https://leetcode.com/problems/spiral-matrix/solutions/3502927/c-image-explanation-recursion-and-single-for-loop-solutions-time-o-mn/). If you've done the recursion one, check my solution for an iterative approach with single for loop explained with images. It is different from 4 for loops solution, also without modifying input.\nUpvote if helps!"
                    },
                    {
                        "username": "__no_name__",
                        "content": "thanks, I was able to figure it out after reading hint 4 :)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Let\\'s hit down arrow on the solutions posted here so it won\\'t show on the first page."
                    },
                    {
                        "username": "alexfromapex",
                        "content": "Why is there no example of an even-numbered height? How are we supposed to know what is expected?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "bro, take an example start from top left corner and drow the spiral\\n1 2 3 4\\n5 6 7 8\\n8 7 6 5\\n4 3 2 1\\n\\nsol ==>  1->2->3->4->8->5->1->2->3->4->8->5->6->7->6->7\\n"
                    },
                    {
                        "username": "wafsinc",
                        "content": "[@jwonz](/jwonz) Some of the people on this site are truly exceptional."
                    },
                    {
                        "username": "jwonz",
                        "content": "It\\'s a spiral that must cover all elements.. fairly obvious."
                    },
                    {
                        "username": "kevinchung0921",
                        "content": "I solved this years ago by 70 lines, today I use 20+ lines.\\n[My simple idea](https://leetcode.com/problems/spiral-matrix/solutions/3502873/check-on-boundary-and-visited-positions-single-loop/)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Great minds think alike!!\\nI solved this one last night in a very similar way: https://leetcode.com/submissions/detail/947045943/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "This is a very classic problem, which is not easy to write well and requires handling various boundary conditions. I have seen many solutions, and from these solutions, I can see the level of programming proficiency. Some solutions are concise and clear, while others are complex and disgusting."
                    },
                    {
                        "username": "mochiball",
                        "content": "[@psionl0](/psionl0) There is in real interviews though. They care about code quality as well "
                    },
                    {
                        "username": "psionl0",
                        "content": "It is hardly surprising that some solutions are more obfuscated than others. The only thing that matters is getting your code to work. There are no bonus points for improving your formatting."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "If you see mine you\\'ll straight up vomit lol."
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "don\\'t like these kinda questions man... Cannot seem to visualize properly"
                    },
                    {
                        "username": "ariamab",
                        "content": "I have the same problem, but the breakdown on this dynamic programming video changed everything https://www.youtube.com/watch?v=oBt53YbR9Kk"
                    },
                    {
                        "username": "jwonz",
                        "content": "That\\'s why you need them, so you can practice."
                    },
                    {
                        "username": "jinhui2",
                        "content": "I tested my code on my own machine and it works fine. However, after submitting my code to leetcode, the result always says Runtime Error without any details. I don't know why this happens."
                    },
                    {
                        "username": "ABHI_606",
                        "content": "questions on leetcode has a specific time bound which our machine doesnt have..so try to write code within that time range"
                    },
                    {
                        "username": "shivamtiwari2112",
                        "content": "[@himanshu_arya](/himanshu_arya) It happens because our machine is not bounded to solve within defined time limit."
                    },
                    {
                        "username": "himanshu_arya",
                        "content": "Bro, It is happening with me as well. I spent hours to solve it and my code works on my machine but here it shows runtime error without giving the test case which is occurring this problem."
                    },
                    {
                        "username": "willianantunes",
                        "content": "It happens with me sometimes. I just refresh the page or something like this, then the submitted code works again."
                    },
                    {
                        "username": "clourstare",
                        "content": "Last executed input: \\t[]  ,so  what i should return ?    I know it's empty,but I really don't kown how to deal"
                    },
                    {
                        "username": "zaidsidd360",
                        "content": "If matrix is empty or null, just return an empty list."
                    },
                    {
                        "username": "19dce130",
                        "content": "constraints"
                    }
                ]
            },
            {
                "id": 1970961,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 2009964,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1887883,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1852970,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1722555,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1574198,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1569810,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1922205,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1888085,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1888001,
                "content": [
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "I took literally 1 whole day to find a solution and it was worth it , the feeling is good"
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am slapping whoever's face that is gonna give me this question during an interview\n"
                    },
                    {
                        "username": "kausachan",
                        "content": "logical thinking: left the chat"
                    },
                    {
                        "username": "PentaMa",
                        "content": "Not a difficult problem, but super annoying to debug"
                    },
                    {
                        "username": "mdarif77630",
                        "content": "very easy way to solve spiral matrix \\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector<int> ans;\\n\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int count = 0;\\n        int total = row*col;\\n\\n        // index initialisation\\n        int startingRow = 0;\\n        int startingCol = 0;\\n\\n        int endingRow = row-1;\\n        int endingCol = col-1;\\n\\n        while(count < total){\\n\\n            // print starting row\\n\\n            for(int index = startingCol; count < total && index <= endingCol; index++){\\n                ans.push_back(matrix[startingRow] [index]);\\n                count++;\\n            }\\n            startingRow++;\\n\\n            // print ending col\\n            for(int index = startingRow; count < total && index<=endingRow; index++){\\n                ans.push_back(matrix[index] [endingCol]);\\n                count++;\\n            }\\n            endingCol--;\\n\\n            // print ending row\\n\\n            for(int index = endingCol; count < total && index>=startingCol; index-- ){\\n                ans.push_back(matrix[endingRow] [index]);\\n                count++;\\n            }\\n            endingRow--;\\n\\n            //print starting col\\n\\n            for(int index = endingRow; count < total && index >= startingRow; index--){\\n                ans.push_back(matrix[index] [startingCol]);\\n                count++;\\n            }\\n            startingCol++;\\n        }\\n        return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "pddxt_",
                        "content": "you\\'ve copied this code from code help..try to optimize your code or please make your own solution instead of flexing your pseudo intelligence"
                    },
                    {
                        "username": "aditya_2021",
                        "content": "https://codinexercies.blogspot.com/2020/08/spiral-order-matrix.html"
                    },
                    {
                        "username": "YTP27",
                        "content": "![image](https://assets.leetcode.com/users/ytp27/image_1584395351.png)\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "screw you. nobody wants to see this garbage "
                    },
                    {
                        "username": "batmandude101",
                        "content": "stop doing this, man. discussions is for discussion "
                    },
                    {
                        "username": "nalinnishant",
                        "content": "why you post answer in discussion section? we already know that you are pro .... use the solution section to post your answer"
                    },
                    {
                        "username": "jhonatasassumpcao",
                        "content": "`import numpy`\\n`matriz = np.ravel([[1,2,3],[4,5,6],[7,8,9]])`\\n"
                    },
                    {
                        "username": "Debjit2000",
                        "content": "//Java Solution `your inline code...your inline code...`\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        ArrayList<Integer>list=new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) {\\n            return list;\\n        }\\n        int rows=matrix.length;\\n        int colms=matrix[0].length;\\n        int top=0,bottom=rows-1,left=0,right=colms-1;\\n        while(top<=bottom&&left<=right)\\n        {\\n            if(top<=bottom)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    list.add(matrix[top][i]);\\n                }\\n                top++;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    list.add(matrix[i][right]);\\n                }\\n                right--;\\n            }\\n            if(top<=bottom)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                        list.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n            if(left<=right)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                        list.add(matrix[i][left]);\\n\\n                }\\n                left++;\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Here should be at least 3 example and at least 1 of them should be even numbered row/col so that we can understand how to approach and what to do."
                    },
                    {
                        "username": "swati_dubey",
                        "content": "[@jwonz](/jwonz) Yes you are right, when I tried for first time, I got confused. I gave it some more time and when I solved it, I realised that there is no need of extra example of even numbered row/col."
                    },
                    {
                        "username": "jwonz",
                        "content": "Why do you need that? The even numbered situation does not change anything; how else do you think a spiral could go in that situation?"
                    }
                ]
            },
            {
                "id": 1887415,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1855205,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1765957,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1741777,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1887823,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 2030141,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 2024943,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1997584,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1988102,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1987768,
                "content": [
                    {
                        "username": "natitati",
                        "content": "Nice question. Enjoyed solving it."
                    },
                    {
                        "username": "pijgom",
                        "content": "The boundary checking is killing me "
                    },
                    {
                        "username": "prathamvarshney18",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> a;\\n        int l=0,t=0,r=matrix[0].size()-1,b=matrix.size()-1;\\n        int c=0;\\n        while(t<=b&&l<=r){\\n            if(c==0){\\n            for(int i=l;i<=r;i++){             \\n                a.push_back(matrix[t][i]);\\n            }\\n            t++;\\n            c=1;\\n            }\\n            else if(c==1){\\n                for(int i=t;i<=b;i++){             \\n                a.push_back(matrix[i][r]);\\n                }\\n                c=2;\\n                r--;\\n            }\\n            else if(c==2){\\n                for(int i=r;i>=l;i--){              \\n                a.push_back(matrix[b][i]);\\n            }\\n                c=3;\\n            }\\n            else if(c==3){\\n                for(int i=b;i>=t;i++){              \\n                a.push_back(matrix[i][l]);\\n            }\\n                c=0;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n\\nAnyone help me to find the error in this code\\n\\nLine 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\nConsole\\n"
                    },
                    {
                        "username": "ggyao2003",
                        "content": "as of 01/04/2023, the leetcode seems to have some trouble. My previously correct answers (run in 2022/10 and 2022/03) got TLE. "
                    },
                    {
                        "username": "jpecoraro342",
                        "content": "Yea, there is definitely something wrong with the execution environment for this right now (Java). My code isn't returning when I'm telling it to, but it works fine when testing locally. Very bizarre."
                    },
                    {
                        "username": "anwendeng",
                        "content": "The problem is not difficult to solve. Basically, find out the outermost elements, go inward layer by layer, and update the values ​​of the four variables firstRow, lastRow, firstCol, and lastCol  which represent the boundaries. But in the end, we must consider the different situations of firstRow, lastRow, firstCol, and lastCol carefully.\nIn implementation, it becomes \n===================\nwhile(firstRow<lastRow && firstCol<lastCol){...\n}\n if (firstRow>lastRow || firstCol>lastCol) {...}\nif ( firstRow==lastRow && firstCol<=lastCol){...}\nelse if ( firstCol==lastCol && firstRow<=lastRow ){...}"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/spiral-matrix/solutions/3503169/beats-100-c-solution-with-debug-couts/"
                    },
                    {
                        "username": "21ucs154",
                        "content": "#include<iostream>\\t\\n#include<vector>\\t\\nusing namespace std;\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int count =0;\\n        vector<int>ans;\\n        int startcol = 0;\\n        int startrow= 0;\\n        int endcol = col-1;\\n        int endrow = row-1;\\n\\n        \\n        int total = row*col;\\n        while (count<total)\\n        {\\n          for(int index = startcol; count<total&&index<endcol;index++)\\n          {\\n              ans.push_back(matrix[startrow][index]);\\n             \\n              count++;\\n          }\\n           startrow++;\\n\\n          for(int index = startrow;count<total&&index<endrow;index++)\\n          {\\n              ans.push_back(matrix[index][endcol]);\\n              \\n              count++;\\n          }\\n          endcol--;\\n           for(int index = endcol; count<total&&index>startcol;index--)\\n          {\\n              ans.push_back(matrix[endrow][index]);\\n              \\n              count++;\\n          }\\n          endrow--;\\n             for(int index = endrow; count<total&&index>startrow;index--)\\n          {\\n              ans.push_back(matrix[index][startcol]);\\n            \\n              count++;\\n          }\\n           startcol++;\\n\\n        \\n        }\\n        return ans;\\n  }\\n};\\n///why is the above code showing the error \\'\"time limit exceeded\" how to resolve it "
                    },
                    {
                        "username": "Mouli_123",
                        "content": "Initial taught, Need to cover all directions in a matrix.left--->right,top------>bottom,right------->left,bottom--------->top.\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "No i can\\'t come up with this question in the interview."
                    },
                    {
                        "username": "Sudipta2003",
                        "content": "vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int>ans;\\n        int count=0;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int total=row*col;\\n        int strow=0,stcol=0,endrow=row-1,endcol=col-1;\\n        while(count<total)\\n        {\\n            for(int i=stcol;i<=endcol && count<total;i++)\\n            {\\n                ans.push_back(matrix[strow][i]);\\n                count++; \\n            }\\n            strow++;\\n            for(int i=strow;i<=endrow && count<total;i++)\\n            {\\n                ans.push_back(matrix[i][endcol]);\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;i>=stcol && count<total;i--)\\n            {\\n                ans.push_back(matrix[endrow][i]);\\n                count++;  \\n            }\\n            endrow--;\\n            for(int i=endrow;i>=strow && count<total;i--)\\n            {\\n                ans.push_back(matrix[i][stcol]);\\n                count++;\\n            }\\n            stcol++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "How do people figure this out in interviews without having done the question before.. ?"
                    }
                ]
            },
            {
                "id": 1909933,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1894062,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1891718,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1889722,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1888486,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1888449,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1888379,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1888260,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1887855,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1887792,
                "content": [
                    {
                        "username": "tilekuulun2606",
                        "content": ":smile"
                    },
                    {
                        "username": "user6785cX",
                        "content": "whats wrong with this code\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> ans;\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int count = 0 ;\n        int total = col * row ;\n        \n\n        int startingRow = 0;\n        int startingCol = 0;\n        int endingRow = row - 1;\n        int endingCol = col - 1;\n\n        while( count <  total){\n\n            for(int i = startingCol ; i <= endingCol ;i++){\n                ans.push_back(matrix[startingRow][i]);\n                count++;\n            }\n\n            startingRow++;\n\n            for(int i = startingRow ; i <= endingRow ;i++){\n                ans.push_back(matrix[i][endingCol]);\n                count++;\n            }\n\n            endingCol--;\n\n\n            for(int i = endingCol ; i >=  startingCol ;i--){\n                ans.push_back(matrix[endingRow][i]);\n                count++;\n            }\n\n            endingRow--;\n\n            for(int i = endingRow ; i >=  startingRow ;i--){\n                ans.push_back(matrix[i][startingCol]);\n                count++;\n            }\n\n            startingCol++;\n\n        }\n\nreturn ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "quant_physicist",
                        "content": "DFS is your best friend here..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "This one breake my rode, I miss my strike path looking for  a formule to transform 2D matrix to 1D matrix and with spiral complexity. I fail but I solve the problem. I hope any one understand my code and send me some sugestions to improve!!!\\n```\\n public IList<int> SpiralOrder(int[][] matrix) {\\n         int i = 0, m = matrix.Length, n = matrix[0].Length, x = 0, y = 0, s = 0;\\n            int[] ans = new int[m * n];\\n            ans[i] = matrix[y][x];\\n\\n            while (i < ans.Length - 1)\\n            {\\n                 if (x < n)\\n                {\\n                    while (x < n - 1)\\n                    {\\n                        x++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    n = n - 1;\\n                }\\n                if (y < m)\\n                {\\n                    while (y < m - 1)\\n                    {\\n                        y++;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                    m = m - 1;\\n                }\\n                if (x > s && i < ans.Length - 1)\\n                {\\n                    while (x > s)\\n                    {\\n                        x--;\\n                        i++;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (y > s && i < ans.Length - 1)\\n                {\\n                    while (y > s + 1)\\n                    {\\n                        i++;\\n                        y--;\\n                        ans[i] = matrix[y][x];\\n                    }\\n                }\\n                if (s < n) s++;\\n            }\\n            return ans;\\n    }\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nMy suggestion to improve is to read the rules carefully.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "What they wanna show by hiding the Editorial section🙄\nWe already hate this question."
                    },
                    {
                        "username": "pradheep03",
                        "content": "Before starting to implement the solution, it is important to clearly understand the problem requirements and visualize the spiral traversal of the matrix. It can be helpful to draw a few example matrices and walk through the spiral traversal by hand, noting the pattern of traversal.\\n\\nIt is also useful to keep track of the current boundaries of the spiral traversal using the top, bottom, left, and right pointers. These pointers help us keep track of which rows and columns have already been traversed and which ones are left to traverse.\\n\\nFinally, it is important to handle edge cases, such as when the input matrix is empty or contains only one row or column, to ensure that the algorithm runs correctly for all inputs."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Was able to get a solution but my code looks like you dropped a grenade in a gas plant ;("
                    },
                    {
                        "username": "eduard92",
                        "content": "I am really really not in the mood for this..."
                    },
                    {
                        "username": "dasrupal",
                        "content": "count the total number of elements\\n\\nmaintain four variable rowStart,rowEnd, colStart,colEnd intialise to start and end of row or column respectively\\nin one iteration,\\ntraverse 1 row (left to right), 1 col(up to down), 1row(right to left) then 1 col(bottom to up), store each element in a vector\\ndo this till the number of elements is greater than 0\\nlike wise change the above four variables\\n\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Same GENRE as yesterday\\'s problem of the day"
                    }
                ]
            },
            {
                "id": 1887768,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1887746,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1887668,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1868532,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1847295,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1836522,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1819792,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1818373,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1809851,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1801116,
                "content": [
                    {
                        "username": "Jateq",
                        "content": "todays task is far from 2014, ayo"
                    },
                    {
                        "username": "natitati",
                        "content": "I just did this yesterday lol"
                    },
                    {
                        "username": "lakpareek",
                        "content": "So the matrix week it is(hate em)"
                    },
                    {
                        "username": "adsalian",
                        "content": " class Solution:\n\n\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        grid = matrix\n        unwound_grid = []\n        grid_col_size = len(grid[0])\n        grid_row_size = len(grid)\n        inset = 0\n\n\n        def traverse_once(grid, inset):\n            \"\"\"\n            Returns one full \"layer\" of a grid like an onion\n\n            grid = a list of lists representing the grid\n            inset = which \"layer\" to unroll, 0 represents the outer layer.\n            \"\"\"\n            col_size = len(grid[0])\n            row_size = len(grid)\n            return_list = []\n\n            # first row\n            for step in range(inset, (col_size - inset)):\n                return_list.append(grid[inset][step])\n\n            # down last column\n            for step in range((inset+1), (row_size - inset)):\n                return_list.append(grid[step][col_size - inset - 1])\n\n            # bottom row in reverse order\n            for step in range((col_size - inset - 2), inset, -1):\n                return_list.append(grid[row_size - inset-1][step])\n\n            # up first column\n            for step in range((row_size - inset - 1), inset, -1):\n                return_list.append(grid[step][inset])\n            \n\n            return return_list\n\n        while grid_col_size - inset > 0 and grid_row_size - inset > 0:\n            unwound_grid.extend(traverse_once(grid, inset))\n            inset += 1\n\n        return unwound_grid\n        \n\n\nWhy is this failing for value when matrix =  [[2,5,8],[4,0,-1]]? How can i resolve this ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aman3091",
                        "content": "where i am wrong please tell me \\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right&&top<=bottom){\\n            for(int j=left;j<=right;j++){\\n                ans.push_back(matrix[top][j]);\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                ans.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            for(int j=right;j>=left;j--){\\n                ans.push_back(matrix[bottom][j]);\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--){\\n                ans.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are wrong in posting your solution here.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arjun_50",
                        "content": "class Solution:\\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\\n        k=[]\\n        cnt=0\\n        m,n=len(matrix),len(matrix[0])\\n        rs,re,cs,ce=0,m-1,0,n-1\\n        while cnt!=(m*n):\\n            for i in range(cs,ce+1):\\n                k.append(matrix[rs][i])\\n                cnt+=1\\n            rs+=1\\n            for i in range(rs,re+1):\\n                k.append(matrix[i][ce])\\n                cnt+=1\\n            ce-=1\\n            for i in range(ce,cs,-1):\\n                k.append(matrix[re][i])\\n                cnt+=1\\n            for i in range(re,rs,-1):\\n                k.append(matrix[i][cs])\\n                cnt+=1\\n            cs+=1\\n            re-=1\\n        return k\\n\\n            \\n\\n        i am getting time limit exceeded ,can anyone help me out?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You can read the rules. Hope they will help you.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "To define a generator\\n```\\ndef dirs():\\n  while True:\\n    yield 0\\n    yield 1\\n    yield 2\\n    yield 3\\ng = dirs()\\nnext(g)\\n```"
                    },
                    {
                        "username": "asdf_ghjk",
                        "content": "trying to figure out how can i fix my code to give correct output for every test case, can anyone help:\\n\\nclass Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int minI =0, maxI = matrix.length -1;\\n        int minJ =0, maxJ = matrix[0].length -1;\\n        ArrayList<Integer> list = new ArrayList<>();\\n    while(minI <= maxI || minJ <=maxJ){\\n        for(int i =minJ; i<=maxJ; i++){\\n            list.add(matrix[minI][i]);\\n        }\\n        for(int i =minI +1; i<=maxI; i++){\\n            list.add(matrix[i][maxJ]);\\n        }\\n        for(int i = maxJ -1; i>=minJ; i--){\\n            list.add(matrix[maxI][i]);\\n        }\\n        for(int i = maxI -1; i > minI ; i--){\\n            list.add(matrix[i][minJ]);\\n        }\\n        minI++; minJ++; maxI--; maxJ--;\\n    }\\n    return list;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jossotriv",
                        "content": "confused if this is a recursion problem"
                    },
                    {
                        "username": "user5534RK",
                        "content": " private void util(List<Integer> list, int[][] matrix, boolean[][] visited, int i, int j){\\n        list.add(matrix[i][j]);\\n        visited[i][j] = true;\\n        //matrix[i][j] = -101;\\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int[] pt: directions){\\n            int dx = i+pt[0];\\n            int dy = j+pt[1];\\n            if(!checkOutofBounds(dx, dy, matrix, visited)){\\n                util(list, matrix, visited, dx, dy);\\n            }\\n            \\n        }\\n    }\\n\\nNot trying to give out a solution just want to know why it is not working. Tried using dfs to solve this but it keeps breaking at 4 by 4 matrix. I am not sure why. I tried looking at solutions to see what I\\'m missing but they seem the same. Would you all be able to help me find what I am missing?"
                    }
                ]
            },
            {
                "id": 1785122,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1776289,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1750116,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1739912,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1733482,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1725119,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1722701,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1722694,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1721474,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1721237,
                "content": [
                    {
                        "username": "Aditya_Babu_Kesharwani",
                        "content": "TRY THIS || CPP\\n\\nclass Solution {\\npublic:\\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\\nint r= matrix.size();\\nint c= matrix[0].size();\\n\\nint count =0;\\nint total =r*c;\\n\\n\\nint startRow=0;\\nint endRow = r-1;\\nint startCol =0;\\nint endCol = c-1;\\n\\nvector<int> ans;\\n\\nwhile(count<total){\\n\\n    // traverse in top row;\\n\\n    for(int index = startCol;count<total && index<=endCol; index++ ){\\n        ans.push_back(matrix[startRow][index]);\\n        count++;\\n    }\\n        \\n    startRow++;\\n\\n    \\n    for(int index = startRow ;count<total && index<=endRow; index++ ){\\n        ans.push_back(matrix[index][endCol]);\\n        count++;\\n    }\\n\\n    endCol--;\\n\\n    \\n    for(int index = endCol ;count<total && index>=startCol; index-- ){\\n        ans.push_back(matrix[endRow][index]);\\n        count++;\\n    }\\n\\n    endRow--;\\n\\n//ok\\n\\n    for(int index = endRow ;count<total && index>=startRow; index-- ){\\n        ans.push_back(matrix[index][startCol]);\\n        count++;\\n    }\\n    startCol++;\\n\\n   \\n\\n  \\n    \\n} \\n\\nreturn ans;\\n}\\n\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shishir_kumar_jha",
                        "content": "Hi If u want do DSA along connect with me @ shishirkj on telegram "
                    },
                    {
                        "username": "ankush920",
                        "content": "simple approach with clean code ( try it ) for hints.\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int m = matrix.size();\\n         int n = matrix[0].size();\\n\\n         if(n==0||m==0)\\n         {\\n              return {};\\n         }\\nvector<int>ans;\\n\\n         int val = m*n ;\\n         int count=0;\\n         int uprow = 0 ;\\n         int lefcol =0; \\n         int rigcol=n-1;\\n         int dowrow=m-1;\\n\\n         while(count<val)\\n         {\\n\\n             if(count<val)\\n\\n           { for(int i =lefcol; i<=rigcol ;i++)\\n            {\\n                 ans.push_back(matrix[uprow][i]) ;\\n\\n               count++;  \\n            }  \\n             uprow++;\\n         }\\n\\n\\n               if(count<val)\\n          {\\n             for(int j =uprow; j<=dowrow ;j++)\\n            {\\n                 ans.push_back(matrix[j][rigcol] );\\n                 count++;\\n            }  \\n            rigcol--;\\n            \\n         }\\n\\n\\n             if(count<val)\\n           \\n           {  for(int i =rigcol; i>=lefcol ;i--)\\n            {\\n\\n                   ans.push_back( matrix[dowrow][i]); \\n                count++;\\n                 \\n            }  \\n            \\n            dowrow--; }\\n\\n\\n\\n             if(count<val)\\n             {\\n             for(int i =dowrow; i>=uprow ;i--)\\n            {\\n                 ans.push_back(matrix[i][lefcol]);\\n                count++; \\n            }  \\n            lefcol++;\\n             }\\n\\n\\n         }\\n\\n     return ans;   \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nSimple rules, try them.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kneeknee",
                        "content": "Getting an error outside of my code for go `Line 64: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)`"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/spiral-matrix/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to return all elements of a matrix in spiral order in Swift is O(n), where n is the number of elements in the matrix. This is because the function processes each element in the matrix exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores all elements of the matrix in the result array. The space complexity is not affected by the size of the matrix, only by the number of elements in it.\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion.\\n\\n In the worst case, when the matrix is a single column or row, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    },
                    {
                        "username": "sau_rabh_s_7",
                        "content": "why show wrong ans ..?\\nplease check....\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int> ans;\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n\\n       int count  = 0;\\n       int total = row*col;\\n\\n       // index initialsation\\n       int startingrow = 0;\\n       int startingcol = 0;\\n       int endingrow = row-1;\\n       int endingcol = col-1;\\n\\n       while(count<total){\\n           // print starting row.\\n           for(int index= startingcol; count<total && index<=endingcol; index++){\\n               ans.push_back(matrix[startingrow] [index]);\\n               count++;\\n           }\\n           startingrow++;\\n\\n           //print ending column.\\n            for(int index= startingrow; count<total && index<=endingrow; index++){\\n               ans.push_back(matrix[index][endingcol]);\\n               count++;\\n           }\\n           endingcol--;\\n\\n           //proint ending row.\\n            for(int index= endingcol; count<total && index>=startingcol; index--){\\n               ans.push_back(matrix[endingrow] [index]);\\n               count++;\\n           }\\n           endingrow--;\\n\\n           // print  starting column.\\n            for(int index= startingrow; count<total && index>=startingrow; index--){\\n               ans.push_back(matrix[index] [startingcol]);\\n               count++;\\n           }\\n           startingcol++;\\n       } \\n       return ans; \\n    }\\n};"
                    },
                    {
                        "username": "Gaurav2503",
                        "content": "in the last for loop of printing the starting colm it should be start with the index ending row some thing like this \\n // print  starting column.\\n        for(int index= ******ENDINGROW*****; count<total && index>=startingrow; index--){\\n           ans.push_back(matrix[index] [startingcol]);\\n           count++;\\n\\nit edit it in the start and in capital case hope it will help you \\uD83D\\uDE0A "
                    },
                    {
                        "username": "princethet",
                        "content": "mine is showing time limit exceeded"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run it in leetcode\\nanyone knows why...\\n\\n```pyhton\\ndef spiralOrder(matrix):\\n    for i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n                row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]])\\n```"
                    },
                    {
                        "username": "devilcool1985",
                        "content": "I can run this code in vscode\\nbut I can\\'t run in on leetcode\\nany one knows what is the difference\\n\\n\\n `    \\ndef spiralOrder(matrix):\\nfor i in range(len(matrix)-1,-1,-1):\\n        row = []\\n        for j in range(len(matrix[i])):\\n                print(j,i,matrix[j][i])\\n   row.append(matrix[j][i])\\n        matrix_new.append(row)\\n    matrix = matrix_new\\n    print(matrix)\\n    return [1]\\n\\nspiralOrder([[1,2,3],[4,5,6],[7,8,9]]).`"
                    },
                    {
                        "username": "Gun2902",
                        "content": "###y its give run timw error\\n\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n\\n        vector <int> ans;\\n        int row= matrix.size();\\n        int col= matrix[0].size();\\n        int count=0;\\n        int total= row*col;\\n        // index initialisation\\n        int startingRow= 0;\\n        int startingCol= 0;\\n        int endingRow= row-1;\\n        int endingCol=col-1;\\n\\n        while(count<total){\\n\\n            //printing starting row\\n            for(int index =startingCol; count<total && index<= endingCol; index++){\\n                ans.push_back(matrix[startingRow][index]);\\n                count++;\\n            }\\n            startingRow++;\\n        //printing ending column\\n        for(int index= startingRow; count<total && index<= endingRow; index++){\\n            ans.push_back(matrix[index][endingCol]);\\n            count++;\\n\\n        }\\n        endingCol--;\\n        // printing ending row\\n        for(int index= endingCol; count<total && index<=startingCol; index--){\\n            ans.push_back(matrix[endingRow][index]);\\n            count++;\\n        }\\n        endingRow--;\\n        //printing starting column\\n        for(int index= endingRow; count<total && index<= startingRow; index--){\\n            ans.push_back(matrix[index][startingCol]);\\n            count++;\\n        }\\n        startingCol++;\\n    }\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "princethet",
                        "content": "same here bro"
                    },
                    {
                        "username": "sanyam46",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \\n    {\\n        vector<int>res;\\n        int startrow = 0;\\n      int endrow = matrix.size()-1;\\n      int startcol = 0;\\n      int endcol = matrix[0].size()-1;\\n\\n      while(startrow<=endrow && startcol<=endcol)\\n      {\\n          \\n          \\n          for(int i=startcol; i<= endcol; i++)\\n          {\\n            res.push_back(matrix[startrow][i]);\\n            \\n          }\\n          startrow++;\\n          for(int i=startrow; i<=endrow; i++)\\n          {\\n            res.push_back(matrix[i][endcol]);\\n            \\n          }\\n          endcol--;\\n          if(endrow>startrow)\\n          {\\n          for(int i=endcol; i>=startcol; i--)\\n          {\\n            res.push_back(matrix[endrow][i]);\\n           \\n          }\\n          endrow--;\\n          }\\n           if(endcol>startcol)\\n           {\\n          for(int i=endrow; i>=startrow; i--)\\n          {\\n            res.push_back(matrix[i][startcol]);\\n            \\n          }\\n          startcol++;\\n           }\\n      }\\n      return res;\\n    }\\n    };\\n\\n\\n\\n\\n\\n\\nCan anyone help .......19 testcases passed, 4 left"
                    }
                ]
            },
            {
                "id": 1720720,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715567,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1709115,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1703586,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1687690,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1684579,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1680122,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1648695,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809611,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1732819,
                "content": [
                    {
                        "username": "printerpro00",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n         int r= matrix.size();\\n    int c= matrix[0].size();\\n\\n    int count =0;\\n    int total =r*c;\\n\\n\\n    int startRow=0;\\n    int endRow = r-1;\\n    int startCol =0;\\n    int endCol = c-1;\\n\\n    vector<int> ans;\\n\\n    while(count<total){\\n\\n        // traverse in top row;\\n\\n        for(int index = startCol;count<total && index<=endCol; index++ ){\\n            ans.push_back(matrix[startRow][index]);\\n            count++;\\n        }\\n            \\n        startRow++;\\n\\n        \\n        for(int index = startRow ;count<total && index<=endRow; index++ ){\\n            ans.push_back(matrix[index][endCol]);\\n            count++;\\n        }\\n\\n        endCol--;\\n\\n        \\n        for(int index = endCol ;count<total && index>=startCol; index-- ){\\n            ans.push_back(matrix[endRow][index]);\\n            count++;\\n        }\\n\\n        endRow--;\\n\\n    //ok\\n\\n        for(int index = endRow ;count<total && index>=startRow; index-- ){\\n            ans.push_back(matrix[index][startCol]);\\n            count++;\\n        }\\n        startCol++;\\n\\n       \\n\\n      \\n        \\n    } \\n\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Spaceshark",
                        "content": "why does my annoying code keep adding rows and columns when i multiply them.  \n`int rows = matrix.length;`\n`int columns = matrix[0].length;`\n`int len = rows * columns;`\n`System.out.println(\"numterms \" + len);`\nfor the sample input of a 3x3 matrix, it returns 6 instead of 9. WHY"
                    },
                    {
                        "username": "guobao2",
                        "content": "I have a simple Java implementation that beats 100%"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Why is this solution not accepted?\\n\\n `class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int numberElements = m*n;\\n        \\n        Set<Integer> spiral = new LinkedHashSet<>();\\n\\n        // Add first element\\n        spiral.add(matrix[0][0]);\\n        \\n        enum Direction {\\n            RIGHT,\\n            DOWN,\\n            LEFT,\\n            UP\\n        }\\n\\n        Direction direction = Direction.RIGHT; // Current direction\\n        int row = 0;\\n        int col = 0;\\n        \\n        while (spiral.size() < numberElements) {\\n            if (direction == Direction.RIGHT) {\\n                // Check if reached top right or already seen element\\n                if (col == m - 1|| spiral.contains(matrix[row][col+1])) {\\n                    direction = Direction.DOWN;\\n                    continue;\\n                }\\n\\n                spiral.add(matrix[row][++col]);\\n\\n            }  else if (direction == Direction.DOWN) {\\n                // Check if reached bottom right or already seen element\\n                if (row == n - 1 || spiral.contains(matrix[row + 1][col])) {\\n                    direction = Direction.LEFT;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[++row][col]);\\n\\n            } else if (direction == Direction.LEFT) {\\n                // Check if reached bottom left or already seen element\\n                if (col == 0 || spiral.contains(matrix[row][col - 1])) {\\n                    direction = Direction.UP;\\n                    continue;\\n                }\\n                \\n                spiral.add(matrix[row][--col]);\\n                \\n            } else  {\\n                \\n                // Check if reached bottom left or already seen element\\n                if (row == 0 || spiral.contains(matrix[row - 1][col])) {\\n                    direction = Direction.RIGHT;\\n                    continue;\\n                }\\n    \\n                spiral.add(matrix[--row][col]);\\n                \\n            }\\n        }\\n        return new ArrayList<Integer>(spiral);\\n    }\\n}`"
                    },
                    {
                        "username": "leetcodeonly",
                        "content": "Nvm doesnt work with matrix having duplicate values"
                    },
                    {
                        "username": "anasbarian007",
                        "content": "class Solution {\\n    public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int m = matrix.length , n = matrix[0].length;\\n        int minrow = 0 , mincol = 0;\\n        int maxrow = m-1 , maxcol = n - 1;\\n        int totelem = m * n , count = 0;\\n\\n        while(count < totelem)\\n        {\\n            // MinRow;\\n            for(int i = mincol; i <= maxcol && count < totelem; i++)\\n            {\\n                list.add(matrix[minrow][i]);\\n                count++;\\n            }\\n            minrow++;\\n\\n            //MaxCol;\\n            for(int i = minrow; i <= maxrow && count < totelem; i++)\\n            {\\n                list.add(matrix[i][maxcol]);\\n                count++;\\n            }\\n            maxcol--;\\n\\n            //MaxRow;\\n            for(int i = maxcol; i >= mincol && count < totelem; i--)\\n            {\\n                list.add(matrix[maxrow][i]);\\n                count++;\\n            }\\n            maxrow--;\\n\\n            //MinCol;\\n            for(int i = maxrow; i >= minrow && count < totelem; i--)\\n            {\\n                list.add(matrix[i][mincol]);\\n                count++;\\n            }\\n            mincol++;\\n        }\\n        return list;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n        vector<int> result;\n\n        int left = 0;\n        int right = matrix[0].size() - 1;\n        int top = 0;\n        int bottom = matrix.size() - 1;\n\n        while(left <= right and top <= bottom)\n        {\n            for(int i=left; i<=right; i++)\n            {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n\n            for(int i=top; i<=bottom; i++)\n            {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n\n            if(top <= bottom)\n            {\n                for(int i=right; i>=left; i--)\n                {\n                    result.push_back(matrix[bottom][i]);\n                }\n            }\n            bottom--;\n\n            if(left <= right)\n            {\n                for(int i=bottom; i>=top; i--)\n                {\n                    result.push_back(matrix[i][left]);\n                }\n            }\n            left++;\n        }\n        return result;\n    }"
                    },
                    {
                        "username": "s3mi0tics",
                        "content": "Why cant we just return an array of type int? It seems like all the solutions require a List<Integer>?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can. In fact, they are expecting you to return an array of type int. Try returning a linked list and your answer will be rejected."
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/spiral-matrix-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "vedD",
                        "content": "JAVA SOLUTION 100% Beats ` \\n     public List<Integer> spiralOrder(int[][] matrix) {\\n\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        int top = 0 ;\\n\\t    int bottom = n-1;\\n\\t    int right = m-1;\\n\\t    int left = 0;\\n\\n\\n\\n        while(top<=bottom && left<=right){\\n\\n\\n            for(int i = left ; i<=right ;i++){\\n                arr.add(matrix[top][i]);\\n                \\n            }\\n\\n            top++;\\n\\n\\n\\n            for(int i  = top ;i<=bottom;i++ ){\\n                arr.add(matrix[i][right]);\\n            }\\n\\n            right--;\\n\\n\\n            if(top<=bottom){\\n\\n                for(int i = right;i>=left;i--){\\n                    arr.add(matrix[bottom][i]);\\n                }\\n                bottom--;\\n            }\\n\\n\\n            if(left<=right){\\n\\n                for(int i = bottom;i>=top;i--){\\n                    arr.add(matrix[i][left]);\\n                }\\n\\n                left++;\\n\\n\\n            }\\n        }\\n\\n\\n        return arr;\\n\\t    \\n\\n\\n\\n\\n\\n    }`\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Musaddik_Khan009",
                        "content": "class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n       vector<int>ans; \\n\\n       int row = matrix.size();\\n       int col = matrix[0].size();\\n       \\n       int total = row * col; \\n       int count = 0; \\n\\n       int rowStart = 0; \\n       int rowEnd = row - 1; \\n    \\n       int colStart= 0; \\n       int colEnd = col - 1; \\n\\n        while(count < total){\\n         // Printing Starting Row \\n            for(int Index = colStart; count < total && Index <= colEnd; Index++){\\n                ans.push_back(matrix[rowStart][Index]);\\n                count++;\\n            }\\n        // Printing Ending Coloumn\\n            rowStart++;\\n             for(int Index  = rowStart; count < total && Index <= rowEnd; Index++){\\n                ans.push_back(matrix[Index][colEnd]);\\n                count++;\\n            }\\n            // Printing Ending Row\\n            colEnd--;\\n            for(int Index =colEnd; count < total && Index >= colStart; Index--){\\n                ans.push_back(matrix[rowEnd][Index]);\\n                count++;\\n            }\\n            rowEnd--;\\n            //Printing Starting Coloumne \\n            for(int Index =rowEnd; count < total && Index >= rowStart; Index--){\\n                ans.push_back(matrix[Index][colStart]);\\n                count++;\\n            }\\n            colStart++;\\n\\n        }\\n\\n    return ans; \\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Minimum in Rotated Sorted Array II",
        "question_content": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,4,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,4]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,4,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> that may contain <strong>duplicates</strong>, return <em>the minimum element of this array</em>.</p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,3,5]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,2,0,1]\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\">Find Minimum in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n\n<p>&nbsp;</p>\n",
        "solutions": [
            {
                "id": 48808,
                "title": "my-pretty-simple-code-to-solve-it",
                "content": "    class Solution {\\n    public:\\n        int findMin(vector<int> &num) {\\n            int lo = 0;\\n            int hi = num.size() - 1;\\n            int mid = 0;\\n            \\n            while(lo < hi) {\\n                mid = lo + (hi - lo) / 2;\\n                \\n                if (num[mid] > num[hi]) {\\n                    lo = mid + 1;\\n                }\\n                else if (num[mid] < num[hi]) {\\n                    hi = mid;\\n                }\\n                else { // when num[mid] and num[hi] are same\\n                    hi--;\\n                }\\n            }\\n            return num[lo];\\n        }\\n    };\\n\\nWhen num[mid] == num[hi], we couldn't sure the position of minimum in mid's left or right, so just let upper bound reduce one.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findMin(vector<int> &num) {\\n            int lo = 0;\\n            int hi = num.size() - 1;\\n            int mid = 0;\\n            \\n            while(lo < hi) {\\n                mid = lo + (hi - lo) / 2;\\n                \\n                if (num[mid] > num[hi]) {\\n                    lo = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 167981,
                "title": "beats-100-binary-search-with-explanations",
                "content": "**Logical Thought**\\nWe assert the loop invariant is the index of  the minimum, `min`, is within the range `[lo, hi]`.\\n1) Before the loop, `min` is in `[0, nums.length - 1]`. To satisfy the invariant, `lo = 0, hi = nums.length - 1`\\n2) If we guess `mi`, \\nif `nums[mi] > nums[hi]`, `min` should be always in `[mi + 1, hi]` (explained in **Essence**). To satisfy the invariant, `lo = mi + 1`;\\nelse if `nums[mi] < nums[lo]`, min should be always in `[lo + 1, mi]` (explained in **Essence**), to satisfy the assertion, `hi = mi, lo = lo + 1`;\\nelse (`nums[lo] <= nums[mi] <= nums[hi]`) min should be always nums[lo].\\n3) After the loop, lo = hi, min should be in `[lo, lo]`, to satisfy the assertion, `min = lo`.\\n\\n**Essence**\\nIf we split the array with mi into [lo, mi] and [mi, hi]. If [lo, mi] is not sorted, since we detect [lo, mi] is not sorted by nums[lo] > nums[mi] so nums[lo] cannot be min, `min` must be within `(lo, mi]`. If [mi, hi] is not sorted, `min` must be within `(mi, hi]` - since we detect [mi, hi] is not sorted by nums[mi] > nums[hi], nums[mi] cannot be min. If they are both sorted, `nums[lo]` is the min.\\nThere are 4 kinds of relationship among num[lo], nums[mi], nums[hi]\\n```\\nnums[lo] <= nums[mi] <= nums[hi], min is nums[lo]\\nnums[lo] > nums[mi] <= nums[hi], (lo, mi] is not sorted, min is inside\\nnums[lo] <= nums[mi] > nums[hi], (mi, hi] is not sorted, min is inside\\nnums[lo] > nums[mi] > nums[hi], impossible\\n```\\n**Code**\\n```\\n    public int findMin(int[] nums) {\\n        \\n        int lo = 0, hi = nums.length - 1;\\n        while (lo < hi) {\\n            int mi = lo + (hi - lo) / 2;\\n            if (nums[mi] > nums[hi]) { \\n                lo = mi + 1;\\n            }\\n            else if (nums[mi] < nums[lo]) { \\n                hi = mi;\\n                lo++;\\n            }\\n            else { // nums[lo] <= nums[mi] <= nums[hi] \\n                hi--;\\n            }\\n        }\\n        \\n        return nums[lo];\\n    }\\n```\\nI appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)",
                "solutionTags": [],
                "code": "```\\nnums[lo] <= nums[mi] <= nums[hi], min is nums[lo]\\nnums[lo] > nums[mi] <= nums[hi], (lo, mi] is not sorted, min is inside\\nnums[lo] <= nums[mi] > nums[hi], (mi, hi] is not sorted, min is inside\\nnums[lo] > nums[mi] > nums[hi], impossible\\n```\n```\\n    public int findMin(int[] nums) {\\n        \\n        int lo = 0, hi = nums.length - 1;\\n        while (lo < hi) {\\n            int mi = lo + (hi - lo) / 2;\\n            if (nums[mi] > nums[hi]) { \\n                lo = mi + 1;\\n            }\\n            else if (nums[mi] < nums[lo]) { \\n                hi = mi;\\n                lo++;\\n            }\\n            else { // nums[lo] <= nums[mi] <= nums[hi] \\n                hi--;\\n            }\\n        }\\n        \\n        return nums[lo];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48849,
                "title": "stop-wasting-your-time-it-most-likely-has-to-be-o-n",
                "content": "There is no faster way than O(n) to solve an input like \"1 1 1 1 1 0 1 1 1 1 1 1 1 1\".  Binary search won't work in this case as your nums[start] == nums[mid] == nums[end], which half would you discard then?  In other words, you have to examine all elements. With that being said, this is probably the only way to solve it.  Run time: <big>6ms</big>.  Not bad at all.\\n\\n<pre><code>\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int min = nums[0];\\n        for (int val : nums)\\n        {\\n            if (min > val)\\n            {\\n                min = val;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n};\\n</code></pre>",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int min = nums[0];\\n        for (int val : nums)\\n        {\\n            if (min > val)\\n            {\\n                min = val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1535534,
                "title": "beats-100-binary-search-with-clear-explanation",
                "content": "First, we take \\n**low** (lo) as 0\\n**high** (hi) as nums.length-1\\n\\nBy default, if **nums[lo]<nums[hi]** then we return nums[lo] because the array was never rotated, or is rotated **n** times\\n\\nAfter entering while loop, we check\\n **if** nums[mid] > nums[hi] **=>** lo = mid + 1 because the minimum element is in the **right** half of the array\\n**else if** nums[mid] < nums[hi] **=>** hi = mid because the minimum element is in the **left** half of the array\\n**else** **=>**  hi-- dealing with **duplicate** values\\nthen we **return** nums[hi]\\n\\n\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int lo = 0, hi = nums.length - 1;\\n        \\n        if (nums[lo] < nums[hi]) return nums[lo];\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (nums[mid] > nums[hi]) {\\n                lo = mid + 1;\\n            } else if (nums[mid] < nums[hi]) {\\n                hi = mid;\\n            } else {\\n                hi--;\\n            }\\n        }\\n        \\n        return nums[hi];\\n    }\\n}\\n```\\n\\nUpvoting helps a lot, Thank You \\u2665",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int lo = 0, hi = nums.length - 1;\\n        \\n        if (nums[lo] < nums[hi]) return nums[lo];\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (nums[mid] > nums[hi]) {\\n                lo = mid + 1;\\n            } else if (nums[mid] < nums[hi]) {\\n                hi = mid;\\n            } else {\\n                hi--;\\n            }\\n        }\\n        \\n        return nums[hi];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48908,
                "title": "clean-python-solution",
                "content": "Find Minimum in Rotated Sorted Array I----**no duplicate** ----O(logN)\\n\\n    class Solution(object):\\n    def findMin(self, nums):\\n        lo, hi = 0, len(nums) - 1\\n        while lo < hi:\\n            mid = lo + (hi -lo) / 2\\n            if nums[mid] > nums[hi]:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return nums[lo] \\n\\nFind Minimum in Rotated Sorted Array II----**contain duplicates**----O(logN)~O(N)\\n\\n    class Solution(object):\\n    def findMin(self, nums):\\n        lo, hi = 0, len(nums) - 1\\n        while lo < hi:\\n            mid = lo + (hi -lo) / 2\\n            if nums[mid] > nums[hi]:\\n                lo = mid + 1\\n            else:\\n                hi = mid if nums[hi] != nums[mid] else hi - 1\\n        return nums[lo]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Find Minimum in Rotated Sorted Array I----**no duplicate** ----O(logN)\\n\\n    class Solution(object):\\n    def findMin(self, nums):\\n        lo, hi = 0, len(nums) - 1\\n        while lo < hi:\\n            mid = lo + (hi -lo) / 2\\n            if nums[mid] > nums[hi]:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return nums[lo] \\n\\nFind Minimum in Rotated Sorted Array II----**contain duplicates**----O(logN)~O(N)\\n\\n    class Solution(object):\\n    def findMin(self, nums):\\n        lo, hi = 0, len(nums) - 1\\n        while lo < hi:\\n            mid = lo + (hi -lo) / 2\\n            if nums[mid] > nums[hi]:\\n                lo = mid + 1\\n            else:\\n                hi = mid if nums[hi] != nums[mid] else hi - 1\\n        return nums[lo]",
                "codeTag": "Java"
            },
            {
                "id": 48810,
                "title": "super-simple-and-clean-java-binary-search",
                "content": "    \\n    public int findMin(int[] nums) {\\n    \\t int l = 0, r = nums.length-1;\\n    \\t while (l < r) {\\n    \\t\\t int mid = (l + r) / 2;\\n    \\t\\t if (nums[mid] < nums[r]) {\\n    \\t\\t\\t r = mid;\\n    \\t\\t } else if (nums[mid] > nums[r]){\\n    \\t\\t\\t l = mid + 1;\\n    \\t\\t } else {  \\n    \\t\\t\\t r--;  //nums[mid]=nums[r] no idea, but we can eliminate nums[r];\\n    \\t\\t }\\n    \\t }\\n    \\t return nums[l];\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "    \\n    public int findMin(int[] nums) {\\n    \\t int l = 0, r = nums.length-1;\\n    \\t while (l < r) {\\n    \\t\\t int mid = (l + r) / 2;\\n    \\t\\t if (nums[mid] < nums[r]) {\\n    \\t\\t\\t r = mid;\\n    \\t\\t } else if (nums[mid] > nums[r]){\\n    \\t\\t\\t l = mid + 1;\\n    \\t\\t } else {  \\n    \\t\\t\\t r--;  //nums[mid]=nums[r] no idea, but we can eliminate nums[r];\\n    \\t\\t }\\n    \\t }\\n    \\t return nums[l];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48817,
                "title": "one-simple-and-clear-method-with-o-1-space-and-worst-o-n-time",
                "content": "    class Solution {\\n    public:\\n        int findMin(vector<int> &num) {\\n            if(num.empty())\\n                return 0;\\n            int i=0,j=num.size()-1;\\n            while(i<j)\\n            {\\n                int mid=(i+j)/2;\\n                if(num[j]<num[mid]){\\n                    i=mid+1;\\n                }\\n                else if(num[mid]<num[j]){\\n                    j=mid;\\n                }\\n                else{//num[mid]==num[j]\\n                    if(num[i]==num[mid]){//linear complexity\\n                        i++;\\n                        j--;\\n                    }\\n                    else\\n                        j=mid;\\n                }\\n            }\\n            return num[j];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findMin(vector<int> &num) {\\n            if(num.empty())\\n                return 0;\\n            int i=0,j=num.size()-1;\\n            while(i<j)\\n            {\\n                int mid=(i+j)/2;\\n                if(num[j]<num[mid]){\\n                    i=mid+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 48815,
                "title": "only-two-more-lines-code-on-top-of-the-solution-for-part-i",
                "content": "    public class Solution {\\n        public int findMin(int[] nums) {\\n            if (nums == null || nums.length == 0) {\\n                return Integer.MIN_VALUE;\\n            }\\n            \\n            int start = 0, end = nums.length - 1;\\n            \\n            //only need to add the following while loop on top of the solution \\n            //for Part I\\n            //if two line segments have overlap, remove the overlap.\\n            //so, the problem can be solved as Part I\\n            while (nums[end] == nums[start] && end > start) {\\n                end--;\\n            }\\n            \\n            while (start < end) {\\n                //if the linear monotonically increasing in [start, end]\\n                if (nums[start] < nums[end]) {\\n                    return nums[start];\\n                }\\n                \\n                int mid = start + (end - start) / 2;\\n                if (nums[mid] >= nums[start]) {\\n                    start = mid + 1;\\n                }\\n                else {\\n                    end = mid;\\n                }\\n            }\\n            \\n            return nums[start];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int findMin(int[] nums) {\\n            if (nums == null || nums.length == 0) {\\n                return Integer.MIN_VALUE;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 754100,
                "title": "python-dfs-binary-search-explained",
                "content": "The idea is to use Binary Search, but here we can have equal numbers, so sometimes we need to find our minimum not in one half, but in two halves. Let us consider several possible cases of values `start`, `mid` and `end`.\\n\\n1. `nums[start]` < `nums[mid]` < `nums[end]`, for example `0, 10, 20`. In this case we need to search only in left half, data is not shifted.\\n2. `nums[mid]` < `nums[end]` < `nums[start]`, for example `20, 0, 10`. In this case data is shifted and we need to search in left half.\\n3. `nums[end]` < `nums[start]` < `nums[mid]`, for example `10, 20, 0`. In this case data is shifted and we need to search in right half.\\n4. `nums[end]` = `nums[mid]`, it this case we need to check the value of `nums[start]`, and strictly speaking we not always need to search in two halves, but I check in both for simplicity of code.\\n\\n**Complexity**: time complexity is `O(log n)` if there are no duplicates in `nums`. If there are duplicates, then complexity can be potentially `O(n)`, for cases like `1,1,1,...,1,2,1,1,....1,1`. Additional space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def findMin(self, nums):\\n        def bin_dfs(start, end):\\n            if end - start <=  1:\\n                self.Min = min(nums[start], nums[end], self.Min)\\n                return\\n\\n            mid = (start + end)//2\\n            if nums[end] <= nums[mid]:\\n                bin_dfs(mid + 1, end)\\n            if nums[end] >= nums[mid]:\\n                bin_dfs(start, mid)\\n        \\n        self.Min = float(\"inf\")\\n        bin_dfs(0, len(nums) - 1)\\n        return self.Min\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums):\\n        def bin_dfs(start, end):\\n            if end - start <=  1:\\n                self.Min = min(nums[start], nums[end], self.Min)\\n                return\\n\\n            mid = (start + end)//2\\n            if nums[end] <= nums[mid]:\\n                bin_dfs(mid + 1, end)\\n            if nums[end] >= nums[mid]:\\n                bin_dfs(start, mid)\\n        \\n        self.Min = float(\"inf\")\\n        bin_dfs(0, len(nums) - 1)\\n        return self.Min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48883,
                "title": "c-binary-linear-search",
                "content": "> Would allow duplicates affect the run-time complexity? How and why?\\n\\nYes, suppose an array `[0,1,1,1,1]` is rotated to `[1,0,1,1,1]` and `[1,1,1,0,1]`. In these two cases, `nums[l] == nums[m] == nums[r]`, but in the first case, the minimum is in the left while in the right in the second case. When all `nums[l]`, `nums[m]` and `nums[r]` are equal, we will have no idea which half to move on. In this case, a linear search from `l` to `r` is necessary and the time complexity becomes `O(n)`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r && nums[l] > nums[r]) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] > nums[m + 1]) {\\n                return nums[m + 1];\\n            }\\n            if (nums[m] > nums[r]) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return findMin(nums, l, r);\\n    }\\nprivate:\\n    int findMin(vector<int>& nums, int l, int r) {\\n        int mini = nums[l++];\\n        while (l <= r) {\\n            mini = min(mini, nums[l++]);\\n        }\\n        return mini;\\n    }\\n};\\n```\\n\\nThe above codes can be shortened as shown in [this post](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/48808/My-pretty-simple-code-to-solve-it).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] > nums[r]) {\\n                l = m + 1;\\n            } else if (nums[m] < nums[r]) {\\n                r = m;\\n            } else {\\n                r--;\\n            }\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r && nums[l] > nums[r]) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] > nums[m + 1]) {\\n                return nums[m + 1];\\n            }\\n            if (nums[m] > nums[r]) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return findMin(nums, l, r);\\n    }\\nprivate:\\n    int findMin(vector<int>& nums, int l, int r) {\\n        int mini = nums[l++];\\n        while (l <= r) {\\n            mini = min(mini, nums[l++]);\\n        }\\n        return mini;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] > nums[r]) {\\n                l = m + 1;\\n            } else if (nums[m] < nums[r]) {\\n                r = m;\\n            } else {\\n                r--;\\n            }\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373747,
                "title": "python-binary-search-compare-to-153",
                "content": "The problem 154 is harder than 153. \\n\\nAt first , we need to solve 153 ( no duplicate exists in the array )\\n\\n153.Find Minimum in Rotated Sorted Array:\\n\\nThese problems give no clear target , we can use ```nums[r]``` as judgement condition  \\nIt is very easy to find\\uFF1A\\n>if nums[mid] > nums[r]: # [3,4,5,1,2]\\n>l = mid+1 # min exist on the right side of the middle value\\n\\n>if nums[mid] < nums[r]: # [1,2,3,4,5] ,[4,5,1,2,3]\\n>r = mid # min exist on the left side of the middle value ( inclue middle value)\\n\\n>if nums[mid] == nums[r]: # Invalid\\n\\nCombining these conditions\\uFF1A\\n```python\\n# 153. Find Minimum in Rotated Sorted Array\\ndef findMin(self, nums: List[int]) -> int:\\n    l, r = 0, len(nums)-1\\n    while l < r:\\n        mid = (l+r)//2\\n        if nums[mid] > nums[r]:\\n            l = mid+1\\n        else:\\n            r = mid\\n    return nums[l]\\n```\\n\\n---------------------------------------\\n\\n154.Find Minimum in Rotated Sorted Array II:\\n\\nSame idea with 153\\n\\nIt is very easy to find\\uFF1A\\n>if nums[mid] > nums[r]: # [3,4,5,1,2]\\n>l = mid+1 # min exists on the right side of the middle value\\n\\n>if nums[mid] < nums[r]: # [1,2,3,4,5] ,[4,5,1,2,3]\\n>r = mid # min exists on the left side of the middle value ( inclue middle value)\\n\\nHere are the different parts\\uFF1A\\n\\n```python\\nif nums[mid] == nums[r]: # valid\\n\\tif nums[mid] == nums[l]: # [10, 5, 10, 10, 10] or [10, 10, 10, 5, 10] \\n\\t\\tl = l+1 # or r = r-1 # min could be on either side\\uFF0Cwe just narrow the interval\\n\\telif nums[l] < nums[mid]:  # [1, 5, 10, 10, 10]  \\n\\t\\tr = mid-1\\n\\telse:# [20, 5, 10, 10, 10]  or [20, 10, 10, 10, 10]\\n\\t\\tr = mid\\n```\\n\\nCombining these conditions\\uFF1A\\n```python\\n\\t# 154. Find Minimum in Rotated Sorted Array II\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)//2\\n\\t\\t\\t# condition for 154\\n            if nums[mid] == nums[r]:\\n                if nums[mid] == nums[l]:\\n                    l = l+1 # or r = r-1\\n                elif nums[l] < nums[mid] :  \\n\\t                r = mid-1\\n                else:\\n                    r = mid\\n\\t\\t\\t# same as 153\\n            elif nums[mid] > nums[r]:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return nums[l]\\n```\\n\\nWe can combine the judgment conditions in the loop, and choose a larger interval when we combine\\n\\n```python\\n\\t# 154. Find Minimum in Rotated Sorted Array II\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)//2\\n            if nums[mid] == nums[r]:\\n                if nums[mid] == nums[l]:\\n                    l = l+1 # or r = r-1\\n                else:\\n                    r = mid\\n            elif nums[mid] > nums[r]:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return nums[l]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```nums[r]```\n```python\\n# 153. Find Minimum in Rotated Sorted Array\\ndef findMin(self, nums: List[int]) -> int:\\n    l, r = 0, len(nums)-1\\n    while l < r:\\n        mid = (l+r)//2\\n        if nums[mid] > nums[r]:\\n            l = mid+1\\n        else:\\n            r = mid\\n    return nums[l]\\n```\n```python\\nif nums[mid] == nums[r]: # valid\\n\\tif nums[mid] == nums[l]: # [10, 5, 10, 10, 10] or [10, 10, 10, 5, 10] \\n\\t\\tl = l+1 # or r = r-1 # min could be on either side\\uFF0Cwe just narrow the interval\\n\\telif nums[l] < nums[mid]:  # [1, 5, 10, 10, 10]  \\n\\t\\tr = mid-1\\n\\telse:# [20, 5, 10, 10, 10]  or [20, 10, 10, 10, 10]\\n\\t\\tr = mid\\n```\n```python\\n\\t# 154. Find Minimum in Rotated Sorted Array II\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)//2\\n\\t\\t\\t# condition for 154\\n            if nums[mid] == nums[r]:\\n                if nums[mid] == nums[l]:\\n                    l = l+1 # or r = r-1\\n                elif nums[l] < nums[mid] :  \\n\\t                r = mid-1\\n                else:\\n                    r = mid\\n\\t\\t\\t# same as 153\\n            elif nums[mid] > nums[r]:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return nums[l]\\n```\n```python\\n\\t# 154. Find Minimum in Rotated Sorted Array II\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)//2\\n            if nums[mid] == nums[r]:\\n                if nums[mid] == nums[l]:\\n                    l = l+1 # or r = r-1\\n                else:\\n                    r = mid\\n            elif nums[mid] > nums[r]:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return nums[l]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 187624,
                "title": "one-liner-python-code-beats-98-challenge-me",
                "content": "Talk is cheap, show you the code:\\n```\\nclass Solution:\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return min(nums)\\n```\\nSupposed there is a zero in \\'[1,1,1,1,1\\u2026.,1] \\'. The time complexity has to be O(n). \\nDon`t waste your life on this problem. It only serves as follow-up of conception, i.e. idea. No code, bruh. \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return min(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045959,
                "title": "100-faster-solution-c-binary-search",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<j){\\n            int mid=(i+j)/2;\\n            if(nums[mid]>nums[j]){\\n                i=mid+1;\\n            }else j--;\\n        }return nums[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<j){\\n            int mid=(i+j)/2;\\n            if(nums[mid]>nums[j]){\\n                i=mid+1;\\n            }else j--;\\n        }return nums[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535790,
                "title": "java-linear-soln-binary-search-explained",
                "content": "**Approach 1st**\\n\\n**Idea**\\nAssume the array is circular and find an index having element smaller then the previous ones! else return the arr[0] as it might be that all elements are same!!\\n\\n**Time Complexity**\\nO(n)\\n\\n````\\nclass Solution {\\n    public int findMin(int[] arr) {\\n       \\n        int i,n=arr.length;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i==n-1)\\n            {\\n                if(arr[i]>arr[0])\\n                    return arr[0];\\n            }\\n            else\\n            {\\n                if(arr[i]>arr[i+1])\\n                    return arr[i+1];\\n            }\\n        }\\n        return arr[0];\\n    }\\n}\\n````\\n\\n**Approach 2nd**\\n\\n**Idea**\\nUsing Binary Search\\n\\n**Starting** ->\\n**If arr[i]<arr[j]** is true that mean array is not rotated even once!!!\\n\\n**During Binary Search Algorithm**->\\n**if arr[mid]> arr[j] then i=mid+1** is true that mean min element is at right side of the array and why i=mid+1 because arr[mid] can not be the answer that why we increase it by one!!\\n\\n**else if(arr[mid]<arr[j]) then j=mid** is true that mean min element is at left side of the array and why j=mid beacuse arr[mid] can be the answer as it smaller then arr[j]!!!\\n\\n**else i.e arr[mid]==arr[j] then j--** means that min element is at left side only as this condition if(arr[mid>arr[j]]) was failed so that why we reduce left index by one!!!\\n\\n**Why we are returning arr[j]?** \\n\\nBecause at j will contain index of smallest element -> **How?**\\nSee carefully we are storing j=mid when arr[mid]<arr[j] and this mid will always have element smaller then jth index so j=mid!!!\\nAnd in case of i we storing i=mid+1 when arr[mid]>arr[j] and this mid will never have the smallest element and if mid+1 contains the smallest elements then in next iterate it will manage by second condition i.e if(arr[i]<arr[j]) then j=mid!!!\\n\\n**Time Complexity**\\nO(n) In considering all elements are same \\n\\n````\\nclass Solution {\\n    public int findMin(int[] arr) {\\n       \\n        int i=0,j=arr.length-1;\\n        if(arr[i]<arr[j])\\n            return arr[i];\\n        while(i<j)\\n        {\\n            int mid=i+(j-i)/2;\\n            if(arr[mid]>arr[j])\\n                i=mid+1;\\n            else  if(arr[mid]<arr[j])\\n                j=mid;\\n            else \\n                j--;\\n        }\\n        return arr[j];\\n    }\\n}\\n````\\nIf this post was helpful then please **upvote** my solution :))\\nI hope I gave all reason how things are working if you still have doubts then please let me know:))",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nclass Solution {\\n    public int findMin(int[] arr) {\\n       \\n        int i,n=arr.length;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i==n-1)\\n            {\\n                if(arr[i]>arr[0])\\n                    return arr[0];\\n            }\\n            else\\n            {\\n                if(arr[i]>arr[i+1])\\n                    return arr[i+1];\\n            }\\n        }\\n        return arr[0];\\n    }\\n}\\n```\n````\\nclass Solution {\\n    public int findMin(int[] arr) {\\n       \\n        int i=0,j=arr.length-1;\\n        if(arr[i]<arr[j])\\n            return arr[i];\\n        while(i<j)\\n        {\\n            int mid=i+(j-i)/2;\\n            if(arr[mid]>arr[j])\\n                i=mid+1;\\n            else  if(arr[mid]<arr[j])\\n                j=mid;\\n            else \\n                j--;\\n        }\\n        return arr[j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754028,
                "title": "c-4-solution-including-binary-search-o-log-n-o-n-o-n-log-n",
                "content": "1. Most Elegant  ```[ binary Search ]```\\n    ```Time Complexcity O(log N)```\\nOne Thing To Notice If All The Elements Into That Array are going to be Same Then It\\'s Also take ```O( N ) ``` Time **:(** <- Credit ``@dhrigasi`` for this \\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> &num) {\\n        int l = 0,r = num.size() - 1,mid = 0;\\n        while(l < r) {\\n            mid = l + (r - l) / 2;           \\n            if (num[mid] > num[r]) l = mid + 1;\\n            else if (num[mid] < num[r]) r = mid;\\n            else r--;\\n        }\\n        return num[l];\\n    }\\n};\\n```\\n2.One Pass\\n    ```Time Complexcity O( N )```\\n```\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int mine = INT_MAX;\\n        for(int no:nums)mine=min(mine,no);\\n        return mine;\\n    }\\n};\\n```\\n3. Using STL\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        return *min_element(begin(nums),end(nums));\\n    }\\n};\\n```\\n4. Doing Sort\\n\\n    ```Time Complexcity O(N log N)```\\n```\\npublic:\\n    int findMin(vector<int>& nums) {\\n         sort(nums.begin(),nums.end());\\n         return nums[0];\\n    }\\n};\\n```\\nPlease **UpVote** If You Like \\n**Happy Coding :)**\\n",
                "solutionTags": [],
                "code": "```[ binary Search ]```\n```Time Complexcity O(log N)```\n```O( N ) ```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> &num) {\\n        int l = 0,r = num.size() - 1,mid = 0;\\n        while(l < r) {\\n            mid = l + (r - l) / 2;           \\n            if (num[mid] > num[r]) l = mid + 1;\\n            else if (num[mid] < num[r]) r = mid;\\n            else r--;\\n        }\\n        return num[l];\\n    }\\n};\\n```\n```Time Complexcity O( N )```\n```\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int mine = INT_MAX;\\n        for(int no:nums)mine=min(mine,no);\\n        return mine;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        return *min_element(begin(nums),end(nums));\\n    }\\n};\\n```\n```Time Complexcity O(N log N)```\n```\\npublic:\\n    int findMin(vector<int>& nums) {\\n         sort(nums.begin(),nums.end());\\n         return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48812,
                "title": "my-c-solution-24ms-is-there-any-better-solution",
                "content": "    class Solution {\\n    public:\\n    int findMin(vector<int> &num) {\\n        int start = 0;\\n        int end = num.size()-1;\\n        int mid;\\n        while(start<end){\\n            if(num[start]<num[end])\\n            break;\\n            mid = start+(end-start)/2;\\n            if(num[mid]>num[end]){\\n                start = mid+1;\\n            }\\n            else if(num[mid]==num[end]){\\n                start++;\\n                end--;\\n            }\\n            else\\n            end= mid;\\n        }\\n        return num[start];\\n     }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int findMin(vector<int> &num) {\\n        int start = 0;\\n        int end = num.size()-1;\\n        int mid;\\n        while(start<end){\\n            if(num[start]<num[end])\\n            break;\\n            mid = start+(end-start)/2;\\n            if(num[mid]>num[end]){\\n                start = mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1132193,
                "title": "four-problems-all-in-one-concept",
                "content": "Four similar problems with similar concept to solve\\n[33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n\\t\\tN=len(nums)\\n        start=0\\n        end=N-1\\n        while start<=end:\\n            mid=(start+end)//2\\n            if target==nums[mid]:\\n                return mid\\n            # first half order\\n            if nums[mid]>=nums[start]:\\n                if nums[mid]>target>=nums[start]:\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n            # second half order\\n            else:\\n                if nums[mid]<target<=nums[end]:\\n                    start=mid+1\\n                else:\\n                    end=mid-1\\n        return -1\\n```\\n[81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        N=len(nums)\\n        start=0\\n        end=N-1\\n        while start<=end:\\n            mid=(start+end)//2\\n            if nums[mid]==target:\\n                return True\\n\\t\\t\\t# add this line to handle duplicate\\n            while nums[start]==nums[mid] and start<mid:\\n                start=start+1\\n            if nums[start]<=nums[mid]:\\n                if nums[start]<=target<nums[mid]:\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n            else:\\n                if nums[mid]<target<=nums[end]:\\n                    start=mid+1\\n                else:\\n                    end=mid-1\\n```\\n[153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        N=len(nums)\\n        start=0\\n        end=N-1\\n        while start<end:\\n            mid=(start+end)//2\\n            if nums[mid]>nums[end]:\\n                start=mid+1\\n            else:\\n                end=mid\\n        return nums[start]\\n```\\n[154. Find Minimum in Rotated Sorted Array II](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        N=len(nums)\\n        start=0\\n        end=N-1\\n        while start<end:\\n            mid=(start+end)//2\\n\\t\\t\\t# add this line to handle duplicate\\n            while nums[mid]==nums[end] and mid<end:\\n                end-=1\\n            if nums[mid]>nums[end]:\\n                start=mid+1\\n            else:\\n                end=mid\\n        return nums[start]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n\\t\\tN=len(nums)\\n        start=0\\n        end=N-1\\n        while start<=end:\\n            mid=(start+end)//2\\n            if target==nums[mid]:\\n                return mid\\n            # first half order\\n            if nums[mid]>=nums[start]:\\n                if nums[mid]>target>=nums[start]:\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n            # second half order\\n            else:\\n                if nums[mid]<target<=nums[end]:\\n                    start=mid+1\\n                else:\\n                    end=mid-1\\n        return -1\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> bool:\\n        N=len(nums)\\n        start=0\\n        end=N-1\\n        while start<=end:\\n            mid=(start+end)//2\\n            if nums[mid]==target:\\n                return True\\n\\t\\t\\t# add this line to handle duplicate\\n            while nums[start]==nums[mid] and start<mid:\\n                start=start+1\\n            if nums[start]<=nums[mid]:\\n                if nums[start]<=target<nums[mid]:\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n            else:\\n                if nums[mid]<target<=nums[end]:\\n                    start=mid+1\\n                else:\\n                    end=mid-1\\n```\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        N=len(nums)\\n        start=0\\n        end=N-1\\n        while start<end:\\n            mid=(start+end)//2\\n            if nums[mid]>nums[end]:\\n                start=mid+1\\n            else:\\n                end=mid\\n        return nums[start]\\n```\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        N=len(nums)\\n        start=0\\n        end=N-1\\n        while start<end:\\n            mid=(start+end)//2\\n\\t\\t\\t# add this line to handle duplicate\\n            while nums[mid]==nums[end] and mid<end:\\n                end-=1\\n            if nums[mid]>nums[end]:\\n                start=mid+1\\n            else:\\n                end=mid\\n        return nums[start]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529323,
                "title": "java-tc-o-n-2-sc-o-1-optimal-binary-search-w-early-exit-followup",
                "content": "**Optimal Binary Search w/ Early Exit**\\n\\n```java\\n/**\\n * Optimal Binary Search w/ Early Exit\\n *\\n * Time Complexity:\\n * Worst Case: O(N/2). If all nums are same.\\n * This will reduce to log(N) in there are no duplicates\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 1 || nums[0] < nums[len - 1]) {\\n            return nums[0];\\n        }\\n        if (len == 2) {\\n            return Math.min(nums[0], nums[1]);\\n        }\\n\\n        int start = 0;\\n        int end = len - 1;\\n\\n        while (start < end) {\\n            if (nums[start] < nums[end]) {\\n                return nums[start];\\n            }\\n\\n            int mid = start + (end - start) / 2;\\n\\n            while (start < mid && nums[start] == nums[mid] && nums[mid] == nums[end]) {\\n                start++;\\n                end--;\\n            }\\n            if (nums[mid] <= nums[end]) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return nums[start];\\n    }\\n}\\n```\\n\\n---\\n**Follow-Up: Return the minimum value at the correct minimum value index**\\n\\n```java\\n/**\\n * Follow-Up: Return the minimum value at the correct minimum value index\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 1 || nums[0] < nums[len - 1]) {\\n            return nums[0];\\n        }\\n\\n        int start = 0;\\n        int end = len - 1;\\n\\n        while (start < end) {\\n            if (nums[start] < nums[end]) {\\n                return nums[start];\\n            }\\n\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums[mid] < nums[end]) {\\n                end = mid;\\n            } else if (nums[mid] > nums[start]) {\\n                start = mid + 1;\\n            } else {\\n                if (nums[end - 1] > nums[end]) {\\n                    return nums[end];\\n                }\\n                end--; // End cannot be pivot anymore\\n            }\\n        }\\n\\n        return nums[start];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Rotated Sorted Array questions on LeetCode:\\n- [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1529302/Java-or-TC:-O(logN)-or-SC:-O(1)-or-Modified-Binary-Search-optimal-solution)\\n- [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/1529305/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Modified-Binary-Search-optimal-solution)\\n- [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1529313/Java-or-TC:-O(logN)-or-SC:-O(1)-or-Optimal-Binary-Search-with-Early-Exit)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\n/**\\n * Optimal Binary Search w/ Early Exit\\n *\\n * Time Complexity:\\n * Worst Case: O(N/2). If all nums are same.\\n * This will reduce to log(N) in there are no duplicates\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 1 || nums[0] < nums[len - 1]) {\\n            return nums[0];\\n        }\\n        if (len == 2) {\\n            return Math.min(nums[0], nums[1]);\\n        }\\n\\n        int start = 0;\\n        int end = len - 1;\\n\\n        while (start < end) {\\n            if (nums[start] < nums[end]) {\\n                return nums[start];\\n            }\\n\\n            int mid = start + (end - start) / 2;\\n\\n            while (start < mid && nums[start] == nums[mid] && nums[mid] == nums[end]) {\\n                start++;\\n                end--;\\n            }\\n            if (nums[mid] <= nums[end]) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return nums[start];\\n    }\\n}\\n```\n```java\\n/**\\n * Follow-Up: Return the minimum value at the correct minimum value index\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 1 || nums[0] < nums[len - 1]) {\\n            return nums[0];\\n        }\\n\\n        int start = 0;\\n        int end = len - 1;\\n\\n        while (start < end) {\\n            if (nums[start] < nums[end]) {\\n                return nums[start];\\n            }\\n\\n            int mid = start + (end - start) / 2;\\n\\n            if (nums[mid] < nums[end]) {\\n                end = mid;\\n            } else if (nums[mid] > nums[start]) {\\n                start = mid + 1;\\n            } else {\\n                if (nums[end - 1] > nums[end]) {\\n                    return nums[end];\\n                }\\n                end--; // End cannot be pivot anymore\\n            }\\n        }\\n\\n        return nums[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48828,
                "title": "python-solution-worst-case-o-n",
                "content": "\\n    def findMin(self, nums):\\n        beg = 0\\n        end = len(nums)-1\\n        while beg <= end:\\n            while beg < end and nums[beg] == nums[beg + 1]:\\n                beg += 1\\n            while end > beg and nums[end] == nums[end - 1]:\\n                end -= 1\\n            if beg == end:\\n                return nums[beg]\\n            \\n            mid = (beg+end)/2\\n            if nums[mid] > nums[end]:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n            \\n                \\n        return nums[beg]",
                "solutionTags": [],
                "code": "\\n    def findMin(self, nums):\\n        beg = 0\\n        end = len(nums)-1\\n        while beg <= end:\\n            while beg < end and nums[beg] == nums[beg + 1]:\\n                beg += 1\\n            while end > beg and nums[end] == nums[end - 1]:\\n                end -= 1\\n            if beg == end:\\n                return nums[beg]\\n            \\n            mid = (beg+end)/2\\n            if nums[mid] > nums[end]:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n            \\n                \\n        return nums[beg]",
                "codeTag": "Python3"
            },
            {
                "id": 1716342,
                "title": "for-those-comfortable-with-left-right-as-opposed-to-left-right",
                "content": "153. Find Minimum in Rotated Sorted Array\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums.length == 1 || nums[0] < nums[nums.length - 1]){\\n            return nums[0];\\n        }\\n        \\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            \\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\\n                return nums[mid];\\n            }\\n            \\n            if(nums[mid] > nums[right]){\\n                left = mid + 1;\\n            }else{\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\n154. Find Minimum in Rotated Sorted Array II\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n\\t    while (left < nums.length && nums[left] == nums[right]) {\\n\\t\\t    left++;\\n\\t    }\\n\\n\\t    if (left == nums.length){\\n            return nums[right];\\n        }\\n\\n\\t    if (nums[left] < nums[right]){\\n            return nums[left];\\n        }\\n\\n\\t    while (left <= right) {\\n\\t\\t    int mid = left + (right - left) / 2;\\n            \\n\\t\\t    if (mid > 0 && nums[mid - 1] > nums[mid]){\\n               \\treturn nums[mid]; \\n            }\\n\\t\\t    \\n           if(nums[mid] > nums[right]){\\n                left = mid + 1;\\n            }else{\\n                right = mid - 1;\\n            }\\n\\t    }\\n        \\n\\t    return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums.length == 1 || nums[0] < nums[nums.length - 1]){\\n            return nums[0];\\n        }\\n        \\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            \\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\\n                return nums[mid];\\n            }\\n            \\n            if(nums[mid] > nums[right]){\\n                left = mid + 1;\\n            }else{\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n\\t    while (left < nums.length && nums[left] == nums[right]) {\\n\\t\\t    left++;\\n\\t    }\\n\\n\\t    if (left == nums.length){\\n            return nums[right];\\n        }\\n\\n\\t    if (nums[left] < nums[right]){\\n            return nums[left];\\n        }\\n\\n\\t    while (left <= right) {\\n\\t\\t    int mid = left + (right - left) / 2;\\n            \\n\\t\\t    if (mid > 0 && nums[mid - 1] > nums[mid]){\\n               \\treturn nums[mid]; \\n            }\\n\\t\\t    \\n           if(nums[mid] > nums[right]){\\n                left = mid + 1;\\n            }else{\\n                right = mid - 1;\\n            }\\n\\t    }\\n        \\n\\t    return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021979,
                "title": "c-using-binary-search-much-efficient",
                "content": "Here time complexity of the solution will be log(n).\\nApproach : I use binary search to know which segment have the lower value.\\nAt first - I check if mid value is less than right value than the lowest value is left to mid, thatswhy I make right = mid.\\nSecond - if mid value and right value is same there may be a solution left to right-1.for example - 3,3,31,3. for this reason I do, right = right-1;\\nElse : if mid value is greater, than right. it is easy to define that our minimum value must be mid to right.\\n\\nNote : If helpful, please upvote, for any query comment below.\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0, right = nums.size()-1;\\n        while(left < right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] < nums[right])right = mid;\\n            else if(nums[mid] == nums[right])right--;\\n            else left = mid+1;\\n        }\\n        return nums[left];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0, right = nums.size()-1;\\n        while(left < right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] < nums[right])right = mid;\\n            else if(nums[mid] == nums[right])right--;\\n            else left = mid+1;\\n        }\\n        return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944708,
                "title": "simple-java-solution-almost-100-beat",
                "content": "\\n```\\nclass Solution {\\n    public int findMin(int[] FJH) \\n        {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = FJH.length - 1;\\n\\t\\t\\twhile (left < right)\\n\\t\\t\\t{\\t\\t\\t\\n\\t\\t\\t\\tint mid = left+(right-left) / 2;\\n\\t\\t\\t\\tif (FJH[mid] > FJH[right] ) {\\n\\t\\t\\t\\t\\tleft=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (FJH[mid] < FJH[right]) {\\n\\t\\t\\t\\t\\tright = mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n                right--;\\n\\t\\t\\t}\\n\\t\\t\\treturn FJH[left];\\n\\t\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] FJH) \\n        {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = FJH.length - 1;\\n\\t\\t\\twhile (left < right)\\n\\t\\t\\t{\\t\\t\\t\\n\\t\\t\\t\\tint mid = left+(right-left) / 2;\\n\\t\\t\\t\\tif (FJH[mid] > FJH[right] ) {\\n\\t\\t\\t\\t\\tleft=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (FJH[mid] < FJH[right]) {\\n\\t\\t\\t\\t\\tright = mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n                right--;\\n\\t\\t\\t}\\n\\t\\t\\treturn FJH[left];\\n\\t\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381095,
                "title": "easiest-solution-valid-for-both-duplicate-and-non-duplicate",
                "content": "Time complexity: O(log(n))\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& n) {\\n        int s=0,l=n.size();\\n        int e =l-1;\\n        while(s<e){\\n            int m = s+(e-s)/2;\\n            if(n[m] > n[e]) s=m+1;          // left side has small values (rotated array)\\n            else if(n[m] < n[e]) e=m;       // right side has small value (not rotated)\\n            else e--;                       // mid value equal to end move towards small\\n        }\\n        return n[s];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& n) {\\n        int s=0,l=n.size();\\n        int e =l-1;\\n        while(s<e){\\n            int m = s+(e-s)/2;\\n            if(n[m] > n[e]) s=m+1;          // left side has small values (rotated array)\\n            else if(n[m] < n[e]) e=m;       // right side has small value (not rotated)\\n            else e--;                       // mid value equal to end move towards small\\n        }\\n        return n[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208724,
                "title": "154-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem is an extension of the previous problem. Since the array can contain duplicates, we need to add extra logic to handle the cases where we have duplicates at both ends.\\n\\nOne way to solve this is to keep track of the start and end indices of the current window. At each iteration, we compute the midpoint of the window and compare it with the endpoints. If the midpoint is greater than the start or end, we know that the minimum element is in the second half of the window. If the midpoint is less than the start or end, we know that the minimum element is in the first half of the window. However, if the midpoint is equal to the start or end, we can\\'t make this determination and we need to shrink the window by one.\\n\\nHere\\'s the algorithm in more detail:\\n\\n1. Initialize start and end pointers to the first and last elements of the array, respectively.\\n\\n2. While the start pointer is less than the end pointer:\\n\\na. Compute the midpoint of the current window as (start + end) // 2.\\n\\nb. If the midpoint is greater than the start or end, the minimum element is in the second half of the window, so set start to midpoint + 1.\\n\\nc. If the midpoint is less than the start or end, the minimum element is in the first half of the window, so set end to midpoint.\\n\\nd. Otherwise, the midpoint is equal to the start or end, so we can\\'t make this determination. Shrink the window by one by decrementing end.\\n\\n3. When the loop terminates, the start pointer points to the minimum element, so return nums[start].\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        start, end = 0, len(nums) - 1\\n\\n        while start < end:\\n            mid = (start + end) // 2\\n\\n            if nums[mid] > nums[end]:\\n                start = mid + 1\\n            elif nums[mid] < nums[start]:\\n                end = mid\\n            else:\\n                end -= 1\\n\\n        return nums[start]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        start, end = 0, len(nums) - 1\\n\\n        while start < end:\\n            mid = (start + end) // 2\\n\\n            if nums[mid] > nums[end]:\\n                start = mid + 1\\n            elif nums[mid] < nums[start]:\\n                end = mid\\n            else:\\n                end -= 1\\n\\n        return nums[start]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535892,
                "title": "c-0ms-memory-92-5-one-line-simple-and-optimal-solution-using-binary-search",
                "content": "**One Line Solution**\\n```\\n\\tint findMin(vector<int>& nums) {\\n        return *min_element(nums.begin(),nums.end());\\n    }\\n```\\n**Simple Solution**\\nDivide and Conquer approach *(RunTime : 58 ms & Memory Usage : 92.75%)*\\n```\\n\\tint solve(vector<int>&nums,int l,int r){\\n\\t\\tif(l==r-1||l==r)\\n\\t\\t\\treturn min(nums[l],nums[r]);\\n\\n\\t\\tint mid = l+(r-l)/2; // finding middle\\n\\t\\t\\n\\t\\treturn min(solve(nums,l,mid),solve(nums,mid,r)); //return min element in both side;\\n\\t}\\n    int findMin(vector<int>& nums) {\\n        return solve(nums,0,nums.size()-1);   \\n    }\\n```\\n**Optimal Solution**\\nUsing binary search approach *( RunTime : 0ms & Memory Usage : 92.5% )*\\n\\n```\\n int findMin(vector<int>& nums) {\\n        \\n        int l = 0, r = nums.size()-1;\\n        \\n        if(nums[l]<nums[r]) // already sorted (0 rotation)\\n            return nums[0]; // return first element\\n    \\n        while(l<r)\\n        {\\n            int mid = l + (r-l)/2; // finding middle\\n            \\n            if(nums[mid]>nums[r]){\\n                l = mid + 1;\\n            }\\n            else if(nums[l]>nums[mid]){\\n                r = mid;\\n            }\\n            else{\\n                r--; //overcome duplicate elements\\n            }\\n        }\\n        return nums[r];   \\n    }\\n```\\n\\nBy \\uD83D\\uDC93 JS",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\tint findMin(vector<int>& nums) {\\n        return *min_element(nums.begin(),nums.end());\\n    }\\n```\n```\\n\\tint solve(vector<int>&nums,int l,int r){\\n\\t\\tif(l==r-1||l==r)\\n\\t\\t\\treturn min(nums[l],nums[r]);\\n\\n\\t\\tint mid = l+(r-l)/2; // finding middle\\n\\t\\t\\n\\t\\treturn min(solve(nums,l,mid),solve(nums,mid,r)); //return min element in both side;\\n\\t}\\n    int findMin(vector<int>& nums) {\\n        return solve(nums,0,nums.size()-1);   \\n    }\\n```\n```\\n int findMin(vector<int>& nums) {\\n        \\n        int l = 0, r = nums.size()-1;\\n        \\n        if(nums[l]<nums[r]) // already sorted (0 rotation)\\n            return nums[0]; // return first element\\n    \\n        while(l<r)\\n        {\\n            int mid = l + (r-l)/2; // finding middle\\n            \\n            if(nums[mid]>nums[r]){\\n                l = mid + 1;\\n            }\\n            else if(nums[l]>nums[mid]){\\n                r = mid;\\n            }\\n            else{\\n                r--; //overcome duplicate elements\\n            }\\n        }\\n        return nums[r];   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48827,
                "title": "solution-in-c-well-explained",
                "content": "### Solution\\nIn a rotate array, there will be a position where the `sequence changes`, no longer ascending and that number will be the minimum we are searching for. Accordingly, we can adopt binary searching to find it out and the key will be that `sequence change`. Let's suppose `l` and `r` will be the start and the end of the array and `m` is the middle between them.\\n\\n- First, if `nums[m] > nums[r]` then the `sequence change` number will be between m and r.\\n- Second, if `nums[m] < nums[r]`, then the `sequence change` number will be between l and m.\\n- Third, if there exist duplicates and result in `nums[m]==nums[r]` then we will not know that that `sequence change` number but one thing for sure, `nums[r]` will not be the minimum so we can just move the `r` backward to eliminate `nums[r]` by `r--`, which can then be able to terminate the searching properly.\\n\\nThe third part is the essential, which delicately handle the duplicates and terminate the searching elegantly.\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        while(l < r){\\n            int m = l+((r-l)>>1);\\n            if(nums[m] < nums[r]) r = m;\\n            else if(nums[m] > nums[r]) l = m+1;\\n            else r--;\\n        }\\n        return nums[l];\\n    }\\n};\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        while(l < r){\\n            int m = l+((r-l)>>1);\\n            if(nums[m] < nums[r]) r = m;\\n            else if(nums[m] > nums[r]) l = m+1;\\n            else r--;\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482682,
                "title": "beats-100-explained-with-example-easy",
                "content": "\\n\\n# Approach\\nwe are using Binary search\\nso we found our \\'mid\\' . for example our array is [2, 2, 2, 0, 1]\\nhere \\'low\\' \\'mid\\' and \\'high\\' are [(L)2, 2, 2(M), 0, 1(H)]\\n\\nif our \\'mid\\' (which is 2) bigger then our \\'high\\'( 1) we can say that our lowest value is right side of our array.\\nbecause array is in ascending order. normally \\'high\\' value should be bigger then midbin.if not then there is the lowest value. [*, *, *(M), 0, 1(H)]\\nso our low should be now low= mid+1;\\n\\nif mid is smaller then high value then the lowest value is on left side(including mid) .so high=mid;\\n [(L)2, 0, 2(M), 4, 6(H)]\\n\\n\\nnow the array element can have duplicate value ;\\nsuppose the array is  [2(L), 2, 2(M), 2, 0, 1, 2(H)]\\nnow our mid and High value are same .we can not come up with any decesion by it so we reduce our high to next value.\\n [2, 2, 2, 2(M), 0, 1(H), 2] after high--;\\n\\nnow we can continue our process\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n      int low=0,mid,high=nums.size()-1;\\n\\n      while(low<high){\\n          mid=low+(high-low)/2;\\n          if(nums[mid]==nums[high]){  //if mid and high is same\\n              high--;\\n          }\\n          else if(nums[mid]>nums[high]){  //if mid is bigger then high\\n              low=mid+1;\\n          }\\n          else{  //if mid is smaller then high\\n              high=mid;\\n          }\\n      } \\n      return nums[low]; \\n    }\\n};\\n```\\n# please upvote :(",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n      int low=0,mid,high=nums.size()-1;\\n\\n      while(low<high){\\n          mid=low+(high-low)/2;\\n          if(nums[mid]==nums[high]){  //if mid and high is same\\n              high--;\\n          }\\n          else if(nums[mid]>nums[high]){  //if mid is bigger then high\\n              low=mid+1;\\n          }\\n          else{  //if mid is smaller then high\\n              high=mid;\\n          }\\n      } \\n      return nums[low]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536790,
                "title": "c-simple-and-short-solution-o-logn-tc-o-1-sc",
                "content": "**Time Complexity:** O(logn) average, O(n) worst case\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int r = nums.size()-1, l = 0, mid;\\n        while (l <= r) {\\n            mid = l + (r - l) / 2;\\n            if (nums[mid] > nums[r]) l = mid + 1;\\n            else if (nums[mid] < nums[r]) r = mid;\\n            else r--;\\n        }\\n        return nums[l];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int r = nums.size()-1, l = 0, mid;\\n        while (l <= r) {\\n            mid = l + (r - l) / 2;\\n            if (nums[mid] > nums[r]) l = mid + 1;\\n            else if (nums[mid] < nums[r]) r = mid;\\n            else r--;\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320810,
                "title": "python-solution-using-binary-search",
                "content": "```\\n\\'\\'\\'\\n    Time Complexity: O(n)\\n    Avg. Time Complexity: O(log n)\\n    Space Complexity: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            elif nums[mid] < nums[high]:\\n                high = mid\\n            elif nums[low] < nums[mid]:\\n                high = mid - 1\\n            else:\\n                high -= 1\\n        return nums[low]\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\'\\'\\'\\n    Time Complexity: O(n)\\n    Avg. Time Complexity: O(log n)\\n    Space Complexity: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            elif nums[mid] < nums[high]:\\n                high = mid\\n            elif nums[low] < nums[mid]:\\n                high = mid - 1\\n            else:\\n                high -= 1\\n        return nums[low]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48997,
                "title": "my-accepted-java-code",
                "content": "The runtime is O(n). I don't think it can be faster\\n\\n    public int findMin(int[] num) {\\n            if(num == null || num.length == 0) {\\n                return -1; // should throw an exception, not sure if leetcode supports it\\n            }\\n            int l = 0;\\n            int r = num.length-1;\\n            while(l < r) {\\n                if(num[l] < num[r]) {\\n                    return num[l];\\n                }\\n                int m = l + (r-l)/2;\\n                if(num[l] > num[m]) {\\n                    r = m;\\n                } else if(num[l] < num[m]) {\\n                    l = m+1;\\n                } else { // num[l] == num[m]\\n                    if(num[l] == num[r]) {\\n                        l++;\\n                        r--;\\n                    } else { // only the num[l] == num[m] >  num[r] case left\\n                        l = m+1;\\n                    }\\n                }\\n            }\\n            return num[l];\\n        }",
                "solutionTags": [],
                "code": "The runtime is O(n). I don't think it can be faster\\n\\n    public int findMin(int[] num) {\\n            if(num == null || num.length == 0) {\\n                return -1; // should throw an exception, not sure if leetcode supports it\\n            }\\n            int l = 0;\\n            int r = num.length-1;\\n            while(l < r) {\\n                if(num[l] < num[r]) {\\n                    return num[l];\\n                }\\n                int m = l + (r-l)/2;\\n                if(num[l] > num[m]) {\\n                    r = m;\\n                } else if(num[l] < num[m]) {\\n                    l = m+1;\\n                } else { // num[l] == num[m]\\n                    if(num[l] == num[r]) {\\n                        l++;\\n                        r--;\\n                    } else { // only the num[l] == num[m] >  num[r] case left\\n                        l = m+1;\\n                    }\\n                }\\n            }\\n            return num[l];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3287150,
                "title": "java-solution-0-ms-solution-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can approach the solution by using Two Pointers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we take `min` as `Integer.MAX_VALUE` then we traverse the array `nums` using two pointers `low` and `high` which we set as `0` and `nums.length - 1`.\\n\\nwhen `low <= high` , we check if the value of low is less than the value of min then we update min as `nums[low]`.\\nsame with the value of high is less than the value of the min then wee update the min as `nums[high]`.\\n\\nthen we **increase** the low pointer and **decrease** the high pointer.\\n\\nat the end of the array we will be having the `min` value.\\n\\nThank You for your patience reading.\\n\\nIf you have any query, comment below.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int low = 0;\\n        int high = nums.length-1;\\n        int min = Integer.MAX_VALUE;\\n\\n        while(low <= high){\\n            if(nums[low] < min) min = nums[low];\\n            if(nums[high] < min) min = nums[high];\\n            low++;\\n            high--;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int low = 0;\\n        int high = nums.length-1;\\n        int min = Integer.MAX_VALUE;\\n\\n        while(low <= high){\\n            if(nums[low] < min) min = nums[low];\\n            if(nums[high] < min) min = nums[high];\\n            low++;\\n            high--;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754148,
                "title": "java-easiest-way-with-explanation",
                "content": "Tip: also work for 153. Find Minimum in Rotated Sorted Array\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        //here we do binary search but in worst case it is O(n) (when all elements are same)\\n        \\n        int low=0;\\n        int high=nums.length-1;\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            \\n            //compare mid element to find in which direction we have to move to find the min element\\n            if(nums[mid]<nums[high]){  //means min element lies in the left part\\n                high=mid;   \\n            }\\n            \\n            else if(nums[mid]>nums[high]){  //means min element lies in right part\\n                low=mid+1;\\n            }\\n            \\n            else{  //when element at mid and element at high are equal\\n                high--;\\n            }\\n            \\n        }\\n        return nums[low];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        //here we do binary search but in worst case it is O(n) (when all elements are same)\\n        \\n        int low=0;\\n        int high=nums.length-1;\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            \\n            //compare mid element to find in which direction we have to move to find the min element\\n            if(nums[mid]<nums[high]){  //means min element lies in the left part\\n                high=mid;   \\n            }\\n            \\n            else if(nums[mid]>nums[high]){  //means min element lies in right part\\n                low=mid+1;\\n            }\\n            \\n            else{  //when element at mid and element at high are equal\\n                high--;\\n            }\\n            \\n        }\\n        return nums[low];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195333,
                "title": "easy-to-understand-javascript-solution-with-recursion",
                "content": "```\\n// gotcha: [2,1,2,2,2]\\n// the repeats could wrap around the whole array, such that, left, mid, right are all the same\\n// so because arr[left] === arr[mid] === arr[right], the only thing we can do is shave off\\n// one element one at a time, not knowing when a non-duplicate will be seen\\n\\n// so [2,1,2,2,2] becomes [1,2,2,2]\\n// arr[left] no longer equals arr[mid], but then arr[mid] === arr[right]\\n\\n// so we shave off elements from the right..\\n// [1,2,2,2] => ...zzz.... becomes => [1,2]\\n\\n// and we\\'re done!\\n\\nvar findMin = function(nums) {\\n    if(!nums || !nums.length ) return -1;\\n    return binarySearch(nums, { left: 0, right: nums.length-1 });\\n};\\n\\nfunction binarySearch(arr, { left, right }){\\n    if( left>=right ) return arr[left]; // we have ended at one element\\n    \\n    let mid = Math.floor((left+right)/2);\\n    \\n    // if left element = mid element, it means everyhting in between is also useless... right?\\n    if( left!==mid && arr[left]===arr[mid]){\\n        // but because there could be a min between left and mid, we can\\'t just drop everything between left<->mid...\\n        // return binarySearch(arr, { left:mid, right}) <-- SO THIS IS WRONG!!!\\n        \\n        // instead we only drop 1 element at a time\\n        return binarySearch(arr, {left: left+1, right});\\n    }\\n    \\n    // same logic as above\\n    if( right !== mid && arr[mid]===arr[right] ){\\n        return binarySearch(arr, { left, right:right-1})\\n    }\\n    \\n    // check whether right side is increasing, if so, we know its useless, and should only look to the left\\n    const isMidToRightAscending\\n        = arr[right] > arr[mid];\\n    \\n    if(isMidToRightAscending){\\n        // but note that for [3,1,2], mid could still contain element, so dont use right=mid-1\\n        return binarySearch(arr, { left, right: mid});\\n    }\\n    \\n    return binarySearch(arr, {left: mid+1, right});\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// gotcha: [2,1,2,2,2]\\n// the repeats could wrap around the whole array, such that, left, mid, right are all the same\\n// so because arr[left] === arr[mid] === arr[right], the only thing we can do is shave off\\n// one element one at a time, not knowing when a non-duplicate will be seen\\n\\n// so [2,1,2,2,2] becomes [1,2,2,2]\\n// arr[left] no longer equals arr[mid], but then arr[mid] === arr[right]\\n\\n// so we shave off elements from the right..\\n// [1,2,2,2] => ...zzz.... becomes => [1,2]\\n\\n// and we\\'re done!\\n\\nvar findMin = function(nums) {\\n    if(!nums || !nums.length ) return -1;\\n    return binarySearch(nums, { left: 0, right: nums.length-1 });\\n};\\n\\nfunction binarySearch(arr, { left, right }){\\n    if( left>=right ) return arr[left]; // we have ended at one element\\n    \\n    let mid = Math.floor((left+right)/2);\\n    \\n    // if left element = mid element, it means everyhting in between is also useless... right?\\n    if( left!==mid && arr[left]===arr[mid]){\\n        // but because there could be a min between left and mid, we can\\'t just drop everything between left<->mid...\\n        // return binarySearch(arr, { left:mid, right}) <-- SO THIS IS WRONG!!!\\n        \\n        // instead we only drop 1 element at a time\\n        return binarySearch(arr, {left: left+1, right});\\n    }\\n    \\n    // same logic as above\\n    if( right !== mid && arr[mid]===arr[right] ){\\n        return binarySearch(arr, { left, right:right-1})\\n    }\\n    \\n    // check whether right side is increasing, if so, we know its useless, and should only look to the left\\n    const isMidToRightAscending\\n        = arr[right] > arr[mid];\\n    \\n    if(isMidToRightAscending){\\n        // but note that for [3,1,2], mid could still contain element, so dont use right=mid-1\\n        return binarySearch(arr, { left, right: mid});\\n    }\\n    \\n    return binarySearch(arr, {left: mid+1, right});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905734,
                "title": "100-easy-fast-clean-java-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\nclass Solution \\n{\\n  public int findMin(int[] nums)\\n {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        while(s < e)\\n        {\\n            int mid = s + (e - s) / 2;\\n            if(nums[mid] > nums[e] )\\n            s = mid + 1;\\n            else if(nums[mid] < nums[e])\\n            e = mid;\\n            else\\n            e--;\\n        }\\n        return nums[s];\\n  }\\n}\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/01e7658d-b730-4c28-a274-8a0531011fc4_1691954121.9730253.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n  public int findMin(int[] nums)\\n {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        while(s < e)\\n        {\\n            int mid = s + (e - s) / 2;\\n            if(nums[mid] > nums[e] )\\n            s = mid + 1;\\n            else if(nums[mid] < nums[e])\\n            e = mid;\\n            else\\n            e--;\\n        }\\n        return nums[s];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821030,
                "title": "binary-search-beats-100-brute-optimized-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlog(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[0];\\n        \\n    }\\n}\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Linear Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] n) {\\n    int min = Integer.MAX_VALUE;\\n\\n    for(int i=0;i<n.length;i++){\\n        min =Math.min(min,n[i]);\\n    }\\n    return min;\\n        \\n    }\\n}\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever u see these two word i.e \"sorted\" and \"find\" means u have to use Binary search\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we are going to check if low ,mid and high are equal or not if they are equal then update the low and high and then again check the condition ,if they are not equal move to next step. \\n2. We are going to find the sorted half of the array\\n3. Store the minimum element from that sorted part and eliminate that part\\n4. Now do the same process with the remaing array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] n) {\\n\\n        int low=0;\\n        int high =n.length-1;\\n        int min = Integer.MAX_VALUE;\\n        \\n\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n\\n            if(n[mid]==n[low] && n[high]==n[mid]){\\n                min = Math.min(min,n[low]);\\n                high = high-1;\\n                low=low+1;\\n                continue;\\n            }\\n            if(n[low]<=n[mid]){\\n                min=Math.min(min,n[low]);\\n                low=mid+1;\\n            }\\n            else{\\n                min=Math.min(min,n[mid]);\\n                high =mid-1;\\n            }\\n        }\\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[0];\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMin(int[] n) {\\n    int min = Integer.MAX_VALUE;\\n\\n    for(int i=0;i<n.length;i++){\\n        min =Math.min(min,n[i]);\\n    }\\n    return min;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMin(int[] n) {\\n\\n        int low=0;\\n        int high =n.length-1;\\n        int min = Integer.MAX_VALUE;\\n        \\n\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n\\n            if(n[mid]==n[low] && n[high]==n[mid]){\\n                min = Math.min(min,n[low]);\\n                high = high-1;\\n                low=low+1;\\n                continue;\\n            }\\n            if(n[low]<=n[mid]){\\n                min=Math.min(min,n[low]);\\n                low=mid+1;\\n            }\\n            else{\\n                min=Math.min(min,n[mid]);\\n                high =mid-1;\\n            }\\n        }\\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713705,
                "title": "beats-95-c-solution-binary-search-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Here in my solution i used binary search to solve this question considering these four cases :\\n\\n 1st case : when mid element is greater then larger then we will find in right part so i have done small = mid + 1;\\n\\n 2nd case : when mid element is smaller then the larger then we have to make end = mid .. as mid element can be the smallest.\\n\\n 3rd case : when larger element is repeated then we done large = large -1.\\n\\n 4th case (important case)  : now we used else {start ++}\\nthis we done to tackle the case when suppose our array is \\n[3,4,5,1,3] and suppose start is at 0th index and end is at 4th index \\nso to tackle this case we used 4th case (when nums[mid] == nums[large]\\nand nums[large] != nums[large-1] ) thats why we done start ++ in this case.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(logn)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int small = 0;\\n     int large = nums.size() - 1;\\n      int mid = small + ( large - small)/2;\\n     while(small < large)\\n     {\\n      if( nums[mid] > nums[large] )\\n      {\\n          small = mid + 1;\\n      }\\n      else if ( nums[mid] < nums[large])\\n     {\\n         large = mid;\\n     }\\n    \\n     else if(nums[large] == nums[large - 1])\\n     {\\n         large --;\\n     }\\n     else{\\n         small++;\\n     }\\n     mid = small + (large - small)/2;\\n     }\\n     return nums[small];\\n        \\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int small = 0;\\n     int large = nums.size() - 1;\\n      int mid = small + ( large - small)/2;\\n     while(small < large)\\n     {\\n      if( nums[mid] > nums[large] )\\n      {\\n          small = mid + 1;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 3590057,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int m=nums[0];\\n        for(auto x:nums){\\n            m=min(m,x);\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int m=nums[0];\\n        for(auto x:nums){\\n            m=min(m,x);\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445822,
                "title": "very-very-easy-sol-using-linear-search-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing linear search\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int min = nums[0];\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if(nums[i] < min)\\n            {\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int min = nums[0];\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if(nums[i] < min)\\n            {\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151562,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findMin(int[] FJH) \\n        {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = FJH.length - 1;\\n\\t\\t\\twhile (left < right)\\n\\t\\t\\t{\\t\\t\\t\\n\\t\\t\\t\\tint mid = left+(right-left) / 2;\\n\\t\\t\\t\\tif (FJH[mid] > FJH[right] ) {\\n\\t\\t\\t\\t\\tleft=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (FJH[mid] < FJH[right]) {\\n\\t\\t\\t\\t\\tright = mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n                right--;\\n\\t\\t\\t}\\n\\t\\t\\treturn FJH[left];\\n\\t\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] FJH) \\n        {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = FJH.length - 1;\\n\\t\\t\\twhile (left < right)\\n\\t\\t\\t{\\t\\t\\t\\n\\t\\t\\t\\tint mid = left+(right-left) / 2;\\n\\t\\t\\t\\tif (FJH[mid] > FJH[right] ) {\\n\\t\\t\\t\\t\\tleft=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (FJH[mid] < FJH[right]) {\\n\\t\\t\\t\\t\\tright = mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n                right--;\\n\\t\\t\\t}\\n\\t\\t\\treturn FJH[left];\\n\\t\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584942,
                "title": "python-faster-than-99-96-well-explained",
                "content": "\\n##### Code\\n<iframe src=\"https://leetcode.com/playground/Rg6pMzmV/shared\" frameBorder=\"0\" width=\"700\" height=\"450\"></iframe>\\n\\n##### Understanding\\nUse **Binary Search** to find the minimum value in the rotated sorted array.\\n\\n```\\n# Find mid value\\nmid = left + ((right - left) >> 1)`\\n```\\n* Here we are using because bit shifting because `mid = left + (right - left) // 2` is slower and `(right - left) >> 1` is equal to `(right - left) // 2`.\\n```\\n# To filter duplicate values\\nif nums[left] == nums[mid] == nums[right]:\\n\\tleft += 1\\n\\tright -= 1\\n```\\n* If left, mid and right values are same then we increment left and decrement right value.\\n```\\nelif nums[mid] > nums[right]:\\n\\tleft = mid + 1\\n```\\n*  Else if mid is greater than right then change the left value to `mid + 1`.\\n\\t*  Because it means mid is in the rotation index\\n```\\nelse:\\n\\tright = mid\\n```\\n* Else mid is in the sorted ascending index\\n\\n##### Screenshot\\n![image](https://assets.leetcode.com/users/images/7d674d39-3ab9-408b-909b-ee926c135501_1663356896.4798899.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n# Find mid value\\nmid = left + ((right - left) >> 1)`\\n```\n```\\n# To filter duplicate values\\nif nums[left] == nums[mid] == nums[right]:\\n\\tleft += 1\\n\\tright -= 1\\n```\n```\\nelif nums[mid] > nums[right]:\\n\\tleft = mid + 1\\n```\n```\\nelse:\\n\\tright = mid\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236596,
                "title": "cpp-code-easy-to-understand-binary-search-o-ms-100-faster-6-liner-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        // lets try using binary serach \\n        int low = 0 , high = nums.size() - 1 ;\\n        while ( low < high ){\\n            int mid = ( low + high ) >> 1;\\n            \\n            if ( nums.at(mid) > nums.at(high)) low = mid + 1;         \\n            else if ( nums.at(mid) < nums.at(low )) high = mid ;\\n            else high -- ;\\n        }\\n        \\n        return nums.at(low);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        // lets try using binary serach \\n        int low = 0 , high = nums.size() - 1 ;\\n        while ( low < high ){\\n            int mid = ( low + high ) >> 1;\\n            \\n            if ( nums.at(mid) > nums.at(high)) low = mid + 1;         \\n            else if ( nums.at(mid) < nums.at(low )) high = mid ;\\n            else high -- ;\\n        }\\n        \\n        return nums.at(low);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613031,
                "title": "very-easy-binary-search-code-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n      int start = 0 , end = nums.size() - 1;\\n        \\n        while(start < end){\\n            \\n            int mid = start + (end - start)/2;\\n            \\n            if(nums[mid] > nums[end]) \\n                start = mid + 1;\\n            else if(nums[mid] < nums[start]){\\n                end = mid;\\n                start++;\\n            }\\n            else\\n                end--;\\n                \\n        }\\n        \\n        return nums[start];\\n         \\n    }\\n};\\n\\nExplanation:- In three ways every testcase can be formed\\n\\t\\t\\t\\t\\t\\t1. all elements in that testcase will be different eg. [1,2,3,4] or [3,4,5,1,2]\\n\\t\\t\\t\\t\\t\\t2. all elements in testcase will be same eg.[3,3,3,,3] or [7,7,7,7]\\n\\t\\t\\t\\t\\t\\t3. testcase can be formed of duplicates and distinct elements eg. [1,1,1,0,1,1,1] or [2,3,0,1,2,2]\\n\\t\\n\\twe can handle first and second senario very easily problem arises when program hits third test case scenario\\n\\t\\n\\tlets make algorithm very easy....\\n\\t\\n\\t\\tif arr[mid] > arr[end] and it is rotated than its 100 percent clear that we are going to find result min in range\\n\\t\\t[mid + 1 , end]\\n\\t\\t\\n\\t\\tif arr[mid] < arr[start] and it is rotated than its also clear that result min is going to lie in range [start++ , mid]\\n\\t\\t\\n\\t\\timportant query : why not arr[mid] < arr[end]  look at this testcase [3,3,3,3,1,3,3,3] so we will get mid element \\n\\t\\tas 3 only and with respect to our code we will go on doing end = mid -1 and we will never get result and will\\n\\t\\tcome out of while loop that reason;\\n\\t\\t\\n\\t\\tnow why start++ : if we do start = mid + 1 then and input is [2,0,1,1,1,1,1,2,2,2] we are going to enter in other\\n\\t\\thalf of array which donot contains our ans\\n\\t\\t\\n\\t\\tsame reason for why end--;\\n\\t\\t\\n\\t\\tif loved the explanation make sure to upvote.....\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n      int start = 0 , end = nums.size() - 1;\\n        \\n        while(start < end){\\n            \\n            int mid = start + (end - start)/2;\\n            \\n            if(nums[mid] > nums[end]) \\n                start = mid + 1;\\n            else if(nums[mid] < nums[start]){\\n                end = mid;\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1475711,
                "title": "java-intuitive-solution-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n        int start=0, end = nums.length-1;\\n        \\n        while(start < end){\\n            int mid = start + (end - start) / 2;\\n            // When right half is sorted\\n            if (nums[mid] < nums[end])\\n                end = mid; // Bcoz mid can be our min value\\n            // When left half is sorted\\n            else if (nums[mid] > nums[end])\\n                start = mid + 1;\\n            // When can\\'t determine which half is sorted\\n            else\\n                end--;\\n        }\\n        return nums[end]; // or nums[start] as both start and end will point to same\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n        int start=0, end = nums.length-1;\\n        \\n        while(start < end){\\n            int mid = start + (end - start) / 2;\\n            // When right half is sorted\\n            if (nums[mid] < nums[end])\\n                end = mid; // Bcoz mid can be our min value\\n            // When left half is sorted\\n            else if (nums[mid] > nums[end])\\n                start = mid + 1;\\n            // When can\\'t determine which half is sorted\\n            else\\n                end--;\\n        }\\n        return nums[end]; // or nums[start] as both start and end will point to same\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265948,
                "title": "java-100-0ms-explanations",
                "content": "**1. Where will the `minimum` value appear ?**\\n- Depending on how many times the array has been rotated \\n1. If the array has been rotated *length* times (aka no rotation), the minimum is on the *leftmost*.\\n\\t- nums[left]\\n2. If the arry has been rotated other number of times, the minimum is at the rotation point.\\n\\t- denoted as nums[R]\\n- This leads us to find the rotation point. -> which is the same as [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)\\n\\n**2. What patterns we can use if an array (with duplicates) is `sorted`?**\\n- `nums[left] <= nums[mid] <= nums[right] `AND nums[left], nums[right], nums[mid] are not completely the same (IMPORTANT) \\n- This hints us to use *boundary value comparison*. \\n\\n**3. How do we approach the solution?**\\n- we first want to check the three boundaries, nums[left], nums[right], nums[mid], and see if they are of the same value, \\n\\t- if so, we can not determine which half is sorted, and have to use linear search \\n\\t- e.g. [2, 2, 2, 2, 1, 2]\\n\\n- otherwise, we check if one side is sorted\\n\\t- rotation points disturbs the patterns nums[left] <= nums[mid] <= nums[right] if it exists, but still one half of the list will remain sorted \\n- `nums[left] <= nums[mid]` means left half is sorted \\n\\t- left = mid + 1, because we know `mid` will not be the minimum as nums[left] can possibly be smaller or equal\\n- ` nums[mid] <= nums[right]` means right half is sorted \\n\\t- right = mid, nums[mid] could be the minimum so it needs to be included for next check \\n\\t- [4,5,1,2,3]\\n\\n```\\npublic int findMin(int[] nums) {\\n\\tif (nums == null || nums.length == 0) return 0; \\n\\n\\tint left = 0, right = nums.length - 1, mid;\\n\\n\\twhile (left < right) {\\n\\t\\tmid = (right - left) / 2 + left; \\n\\n\\t\\t// linear search if all 3 boundaries are of the SAME value\\n\\t\\tif (nums[left] == nums[mid] && nums[mid] == nums[right]) {\\n\\t\\t\\treturn linearSearch(nums, left, right); \\n\\t\\t} else if (nums[left] <= nums[mid]) {\\n\\t\\t\\t// left half is sorted \\n\\t\\t\\tif (nums[mid] <= nums[right]) {\\n\\t\\t\\t\\t// whole array is sorted \\n\\t\\t\\t\\treturn nums[left]; \\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// search right half \\n\\t\\t\\t\\tleft = mid + 1; \\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// right half is sorted, search left half\\n\\t\\t\\tright = mid; \\n\\t\\t}\\n\\t}\\n\\n\\treturn nums[left]; \\n}\\n\\n// linear search and returns min value \\nprivate int linearSearch(int[] nums, int left, int right) {\\n\\tint minVal = Integer.MAX_VALUE; \\n\\tfor (int i = left; i <= right; i++) {\\n\\t\\tminVal = Math.min(nums[i], minVal);\\n\\t}\\n\\treturn minVal;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\npublic int findMin(int[] nums) {\\n\\tif (nums == null || nums.length == 0) return 0; \\n\\n\\tint left = 0, right = nums.length - 1, mid;\\n\\n\\twhile (left < right) {\\n\\t\\tmid = (right - left) / 2 + left; \\n\\n\\t\\t// linear search if all 3 boundaries are of the SAME value\\n\\t\\tif (nums[left] == nums[mid] && nums[mid] == nums[right]) {\\n\\t\\t\\treturn linearSearch(nums, left, right); \\n\\t\\t} else if (nums[left] <= nums[mid]) {\\n\\t\\t\\t// left half is sorted \\n\\t\\t\\tif (nums[mid] <= nums[right]) {\\n\\t\\t\\t\\t// whole array is sorted \\n\\t\\t\\t\\treturn nums[left]; \\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// search right half \\n\\t\\t\\t\\tleft = mid + 1; \\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// right half is sorted, search left half\\n\\t\\t\\tright = mid; \\n\\t\\t}\\n\\t}\\n\\n\\treturn nums[left]; \\n}\\n\\n// linear search and returns min value \\nprivate int linearSearch(int[] nums, int left, int right) {\\n\\tint minVal = Integer.MAX_VALUE; \\n\\tfor (int i = left; i <= right; i++) {\\n\\t\\tminVal = Math.min(nums[i], minVal);\\n\\t}\\n\\treturn minVal;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 754027,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1,res;\\n        while(l < r) {\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] > nums[r]) {\\n                l = mid + 1;\\n            } else if(nums[mid] < nums[r]) {\\n                r = mid;\\n            } else {\\n                r--;\\n            }\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size() - 1,res;\\n        while(l < r) {\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] > nums[r]) {\\n                l = mid + 1;\\n            } else if(nums[mid] < nums[r]) {\\n                r = mid;\\n            } else {\\n                r--;\\n            }\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613620,
                "title": "c-o-log-n-o-n-worst-case-explained-with-diagram",
                "content": "![image](https://assets.leetcode.com/users/sonugiri/image_1588626155.png)\\n\\n```\\nint findMin(vector<int>& nums) {\\n    int l = 0, r = nums.size() - 1;\\n    while( l < r ) {\\n        int m = l + (r - l) / 2;\\n        if( nums[m] > nums[r] ) {\\n            l = m + 1;\\n        } else if( nums[m] < nums[r] ) {\\n            r = m;\\n        } else {\\n            r--;\\n        }\\n    }\\n    return nums[l];\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint findMin(vector<int>& nums) {\\n    int l = 0, r = nums.size() - 1;\\n    while( l < r ) {\\n        int m = l + (r - l) / 2;\\n        if( nums[m] > nums[r] ) {\\n            l = m + 1;\\n        } else if( nums[m] < nums[r] ) {\\n            r = m;\\n        } else {\\n            r--;\\n        }\\n    }\\n    return nums[l];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479742,
                "title": "java-binary-search-100-time-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n    int left = 0;\\n    int right = nums.length - 1;\\n    \\n        while (left < right)    \\n        {\\n            int mid = left + (right-left)/2;   \\n                        \\n             if (nums[mid] > nums[right]) left = mid + 1;\\n            else if (nums[mid] == nums[right]) right--;\\n            else if (nums[mid] < nums[right])  right = mid;\\n                \\n        }\\n        \\n        return nums[left];\\n}\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n    int left = 0;\\n    int right = nums.length - 1;\\n    \\n        while (left < right)    \\n        {\\n            int mid = left + (right-left)/2;   \\n                        \\n             if (nums[mid] > nums[right]) left = mid + 1;\\n            else if (nums[mid] == nums[right]) right--;\\n            else if (nums[mid] < nums[right])  right = mid;\\n                \\n        }\\n        \\n        return nums[left];\\n}\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453724,
                "title": "very-simple-c-beats-most-c-submissions-with-comments",
                "content": "The idea is to make the first number as the pivot and keep scanning for lower numbers. Note, if the mid and the last are the same, then the binary search will for that part will turn into a linear scan. But after the equal match you can continue binary searching if the mid and r are not the same.\\n```\\n\\npublic class Solution {\\n    public int FindMin(int[] arr) {\\n        // Pick the first one as pivot.\\n        int minSoFar = arr[0];\\n        int l = 0;\\n        int r = arr.Length - 1;\\n        while(l <= r)\\n        {\\n            int mid = (l +r)/2;\\n            \\n            if(arr[mid] < minSoFar)\\n            {\\n                minSoFar = arr[mid];\\n            }\\n            \\n            // If the value is the same you can only move one. \\n            if(arr[mid] == arr[r])\\n            {\\n                r = r -1;\\n            }\\n            else\\n                // Look for rotation\\n            if(arr[mid] < arr[r])\\n            {\\n                r = mid -1;    \\n            }\\n            else\\n            {\\n                l = mid +1; \\n            }\\n        }\\n        return minSoFar;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int FindMin(int[] arr) {\\n        // Pick the first one as pivot.\\n        int minSoFar = arr[0];\\n        int l = 0;\\n        int r = arr.Length - 1;\\n        while(l <= r)\\n        {\\n            int mid = (l +r)/2;\\n            \\n            if(arr[mid] < minSoFar)\\n            {\\n                minSoFar = arr[mid];\\n            }\\n            \\n            // If the value is the same you can only move one. \\n            if(arr[mid] == arr[r])\\n            {\\n                r = r -1;\\n            }\\n            else\\n                // Look for rotation\\n            if(arr[mid] < arr[r])\\n            {\\n                r = mid -1;    \\n            }\\n            else\\n            {\\n                l = mid +1; \\n            }\\n        }\\n        return minSoFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329627,
                "title": "c-85-99-beat-o-n-average-case-o-log-n-lewptie-lewpz-koderz-kamp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        int aMid = 0;\\n        \\n        while (aLo < aHi) {\\n            if (nums[aLo] == nums[aHi]) {\\n                aHi--;\\n            } else {\\n                aMid = (aLo + aHi) >> 1;\\n                if (nums[aMid] > nums[aHi]) {\\n                    aLo = aMid + 1;\\n                } else {\\n                    aHi = aMid;\\n                }\\n            }\\n        }\\n        \\n        return nums[aLo];\\n    }\\n};\\n```\\n\\nThis is the same as the solution with no duplicates.\\n\\nThe main difficulty comes in the following form:\\n\\n[3, 3, 3, 0, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\\n\\nThere\\'s no way to tell where the loop rotation starts by examining lo, mid, and hi. Therefore we just constrict our bounds whenever we run into this situation. There\\'s no way to \"guess\" where the real rotation might begin, so we just do it in linear time.\\n\\nHere is an alternative loop construction:\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        int aMid = 0;\\n        \\n        while (aLo < aHi) {\\n            \\n            while (aLo < aHi && nums[aLo] == nums[aHi]) {\\n                aHi--;\\n            } \\n            \\n            if (aLo < aHi) {\\n                aMid = (aLo + aHi) >> 1;\\n                if (nums[aMid] > nums[aHi]) {\\n                    aLo = aMid + 1;\\n                } else {\\n                    aHi = aMid;\\n                }\\n            }\\n        }\\n        \\n        return nums[aLo];\\n    }\\n};\\n```\\n\\nThis does one more comparison per loop, so I prefer the top way. Same speed class though. UR Pik.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        int aMid = 0;\\n        \\n        while (aLo < aHi) {\\n            if (nums[aLo] == nums[aHi]) {\\n                aHi--;\\n            } else {\\n                aMid = (aLo + aHi) >> 1;\\n                if (nums[aMid] > nums[aHi]) {\\n                    aLo = aMid + 1;\\n                } else {\\n                    aHi = aMid;\\n                }\\n            }\\n        }\\n        \\n        return nums[aLo];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        int aMid = 0;\\n        \\n        while (aLo < aHi) {\\n            \\n            while (aLo < aHi && nums[aLo] == nums[aHi]) {\\n                aHi--;\\n            } \\n            \\n            if (aLo < aHi) {\\n                aMid = (aLo + aHi) >> 1;\\n                if (nums[aMid] > nums[aHi]) {\\n                    aLo = aMid + 1;\\n                } else {\\n                    aHi = aMid;\\n                }\\n            }\\n        }\\n        \\n        return nums[aLo];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48885,
                "title": "simple-c-binary-search-solution-with-explanation",
                "content": "I see most other posts compare `nums[m]` with `nums[r]` instead, which is nice and neat! However, I used `nums[l]` here in the first place, but it works as well, just a different perspective here. \\n\\nWhen `nums[l] == nums[m]`, the minimum could be in range `[l, m]` (e.g. `[1,0,1,1,1]`) or `[m + 1, r]` (e.g. `[1,1,1,0,1]`), so we can eliminate the bigger end, here we move 1 step instead of cut off half range, so worst case can make it linear.\\n\\nWhen `nums[l] < nums[m]`, we use `nums[r]` to tell if `[l, r]` (e.g. `[0, 1, 2, 3, 4]`) is a pure increasing sub-array (minimum is `nums[l]`) or includes a rotated point(minimum is in `(l, r]`, e.g. `[4,5,6,1,2]`). If it's not pure increasing, we pick the right half, otherwise, we pick the left half. Here, we can cut off half range.\\n\\nWhen `nums[l] > nums[m]`, the minimum should be in the left half (e.g. `[2,0,1,1,1]`). Here, we can cut off half range as well.\\n\\nSo worst case would be O(n), e.g. [1,1,1,1,1,1,1,1,..........1,1]\\n\\n    class Solution {\\n    public:\\n        int findMin(vector<int>& nums) {\\n            if(!nums.size()) return -1;\\n            int l = 0, r = nums.size() - 1;\\n            \\n            while(l < r){\\n                int m = l + (r - l) / 2;\\n                if(nums[l] == nums[m]){\\n                    nums[r] >= nums[m] ? r-- : l++; // could go linear\\n                }\\n                else if(nums[l] < nums[m]){\\n                    nums[r] < nums[m] ? l = m + 1 : r = m;\\n                }else r = m;\\n            }\\n            \\n            return nums[l];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int findMin(vector<int>& nums) {\\n            if(!nums.size()) return -1;\\n            int l = 0, r = nums.size() - 1;\\n            \\n            while(l < r){\\n                int m = l + (r - l) / 2;\\n                if(nums[l] == nums[m]){\\n                    nums[r] >= nums[m] ? r-- : l++; // could go linear\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3702310,
                "title": "c-binary-search-unique-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n\\n       int n=nums.size();\\n       int low=0;\\n       int high=n-1;\\n       int ans=INT_MAX;\\n\\n       while(low<=high){\\n\\n           int mid=low+(high-low)/2;\\n\\n           if(nums[low]==nums[high]){\\n               ans=min(nums[low],ans);\\n               low++;\\n\\n           }\\n          else if(nums[mid]<=nums[high]){\\n               ans=min(nums[mid],ans);\\n               high=mid-1;\\n           }\\n           else{\\n               ans=min(nums[low],ans);\\n               low=mid+1;\\n           }\\n           \\n       }\\n\\n       return ans;\\n\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n\\n       int n=nums.size();\\n       int low=0;\\n       int high=n-1;\\n       int ans=INT_MAX;\\n\\n       while(low<=high){\\n\\n           int mid=low+(high-low)/2;\\n\\n           if(nums[low]==nums[high]){\\n               ans=min(nums[low],ans);\\n               low++;\\n\\n           }\\n          else if(nums[mid]<=nums[high]){\\n               ans=min(nums[mid],ans);\\n               high=mid-1;\\n           }\\n           else{\\n               ans=min(nums[low],ans);\\n               low=mid+1;\\n           }\\n           \\n       }\\n\\n       return ans;\\n\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506964,
                "title": "java-solution-for-find-minimum-in-rotated-sorted-array-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code aims to find the minimum element in a rotated sorted array by using a recursive approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code starts by calling the overloaded method findMin(nums, 0, nums.length-1) to initiate the recursive process.\\n- In the recursive method, several base cases are checked:\\n1. If right is equal to left, it means the subarray has only one element, so the minimum is the element at left.\\n2. If right is equal to left + 1, it means the subarray has two elements, so the minimum is the smaller of the two elements.\\n3. If nums[right] is greater than nums[left], it means the subarray is already sorted, and the minimum is the element at left.\\n4. If nums[right] is equal to nums[left], it means the subarray has repeated elements, and the minimum is searched by calling the recursive method with left incremented by 1.\\n5. If none of the above conditions is met, the array is rotated, and the method proceeds with finding the minimum recursively.\\n- The middle index is calculated as (right-left)/2 + left.\\n- If nums[middle] is greater than or equal to nums[left], it means the minimum lies to the right of the middle. The method calls itself with middle as the new left index.\\n- If nums[middle] is less than nums[left], it means the minimum lies to the left of the middle. The method calls itself with middle as the new right index.\\n- The method repeats steps 3-5 until the minimum element is found.\\nFinally, the minimum element is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this recursive solution is O(log n) because it uses a binary search approach to find the minimum element. The array is divided in half at each step, reducing the search space.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(log n) due to the recursive calls. In the worst case, the maximum number of recursive calls is proportional to the logarithm of the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        return findMin(nums, 0, nums.length-1);\\n    }\\n    public int findMin(int[] nums, int left, int right)\\n    {\\n        if(right==left)\\n        {\\n            return nums[left];\\n        }\\n        if(right == left +1)\\n        {\\n            return Math.min(nums[left], nums[right]);\\n        }\\n        // 3 3 1 3 3 3\\n        int middle = (right-left)/2 + left;\\n        // already sorted\\n        if(nums[right] > nums[left])\\n        {\\n            return nums[left];\\n            //right shift one\\n        }\\n        else if(nums[right] == nums[left])\\n        {\\n            return findMin(nums, left+1, right);\\n            //go right\\n        }\\n        else if(nums[middle] >= nums[left])\\n        {\\n            return findMin(nums, middle, right);\\n        }\\n        else\\n        {\\n            return findMin(nums, left, middle);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        return findMin(nums, 0, nums.length-1);\\n    }\\n    public int findMin(int[] nums, int left, int right)\\n    {\\n        if(right==left)\\n        {\\n            return nums[left];\\n        }\\n        if(right == left +1)\\n        {\\n            return Math.min(nums[left], nums[right]);\\n        }\\n        // 3 3 1 3 3 3\\n        int middle = (right-left)/2 + left;\\n        // already sorted\\n        if(nums[right] > nums[left])\\n        {\\n            return nums[left];\\n            //right shift one\\n        }\\n        else if(nums[right] == nums[left])\\n        {\\n            return findMin(nums, left+1, right);\\n            //go right\\n        }\\n        else if(nums[middle] >= nums[left])\\n        {\\n            return findMin(nums, middle, right);\\n        }\\n        else\\n        {\\n            return findMin(nums, left, middle);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248775,
                "title": "93-95-beats-c-beginner-friendly-just-one-line-code-quick-hack-for-this-question",
                "content": "# Intuition\\nJust return the minimum from the given array.\\n\\n# Approach\\nYou can travel through the array and can return the minimum, or can use **min_element(nums.begin(), nums.end())* to get the minimum from the given vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        return *min_element(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        return *min_element(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142920,
                "title": "easy-c-solution-binary-search-linear-search-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using Linear Search (Brute Force).\\n2. Using Binary Search (Optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N),  because we traversed over all the elements in the array, which has allowed us to\\n    achieve a linear time complexity.\\n\\n    Space Complexity : O(1), the algorithm itself takes constant space but the program as a whole takes linear\\n    space because of storing the input array.\\n\\n    Using Array + Linear Search. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int minimum = nums[0];\\n        for(int i=1; i<n; i++){\\n            minimum = min(nums[i], minimum);\\n        }\\n        return minimum;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                return nums[i+1];\\n            }\\n        }\\n        return nums[0];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : Since we are using a binary search algorithm and reducing the search space by half, the\\n    average time complexity is O(logN), but in the worst case if all the elements are equal then complexity is \\n    O(N).\\n\\n    Space Complexity : O(1), this approach takes also constant time but the program as a whole takes O(N) space\\n    because of the space required to store the input.\\n\\n    Using Array + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low < high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] < nums[high]){\\n                high = mid;\\n            }\\n            else if(nums[mid] > nums[high]){\\n                low = mid+1;\\n            }\\n            else{\\n                high-=1;\\n            }\\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N),  because we traversed over all the elements in the array, which has allowed us to\\n    achieve a linear time complexity.\\n\\n    Space Complexity : O(1), the algorithm itself takes constant space but the program as a whole takes linear\\n    space because of storing the input array.\\n\\n    Using Array + Linear Search. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int minimum = nums[0];\\n        for(int i=1; i<n; i++){\\n            minimum = min(nums[i], minimum);\\n        }\\n        return minimum;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                return nums[i+1];\\n            }\\n        }\\n        return nums[0];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : Since we are using a binary search algorithm and reducing the search space by half, the\\n    average time complexity is O(logN), but in the worst case if all the elements are equal then complexity is \\n    O(N).\\n\\n    Space Complexity : O(1), this approach takes also constant time but the program as a whole takes O(N) space\\n    because of the space required to store the input.\\n\\n    Using Array + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low < high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] < nums[high]){\\n                high = mid;\\n            }\\n            else if(nums[mid] > nums[high]){\\n                low = mid+1;\\n            }\\n            else{\\n                high-=1;\\n            }\\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991497,
                "title": "python3-solution-binary-search-approach-super-easy-to-read",
                "content": "```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        while (left < right):\\n            mid = left + (right - left) // 2\\n            if (nums[mid] < nums[right]):\\n                right = mid\\n            elif (nums[mid] > nums[right]):\\n                left = mid + 1\\n            else: \\n                right -= 1\\n        return nums[left]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        while (left < right):\\n            mid = left + (right - left) // 2\\n            if (nums[mid] < nums[right]):\\n                right = mid\\n            elif (nums[mid] > nums[right]):\\n                left = mid + 1\\n            else: \\n                right -= 1\\n        return nums[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960031,
                "title": "easy-understanding-binary-search-solution-faster-than-100",
                "content": "# Intuition\\n ## Plz upvote if you find this useful\\n# > This problem is similar to find minimum in rotated and sorted array(153).\\nthe only difference is that in this problem duplicate element can come.\\nAs array is sorted so we can think something like binary search.\\n\\n# Approach````\\ncode\\n````\\nTake strating index s=0,ending index=size of array -1.\\n\\nEvery time we\\'ll be checking if the nums[mid]>nums[e], then we can say that our minimum element will be in left part i.e s=mid+1.\\n\\nElse we\\'ll check if num[mid]<nums[e] then we can find minimum element in right part. But here we are initialising e=mid because there might be case in which our nums[mid]=minimum element.\\n\\n If we do e=mid-1,we\\'ll end up searching in the wrong part.\\nBut wait nums may contain duplictes so if nums[mid]==nums[e] then we simply decrease e i.e e-- to tackle duplicates.\\n\\n# Complexity\\n- Time complexity:\\nlog n\\n\\n- Space complexity:\\no(1) constant space\\n\\n# Code\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0,e=nums.size()-1,mid=(s+e)/2;\\n        while(s<e){\\n            if(nums[mid]>nums[e]) //min ele in left part\\n                s=mid+1;\\n            else if(nums[mid]<nums[e]) //min element in right part\\n                e=mid;\\n            else // to remove duplicates  elemnt\\n            e--;\\n            mid=(s+e)/2; //updting **Bold**mid\\n        }\\n        return nums[s];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "````\\ncode\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2935077,
                "title": "simple-java-sol",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n         int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == nums[right]) while(nums[mid]==nums[right] && mid<right)right--;\\n            if (nums[mid] > nums[right]) left = mid + 1;\\n            else right = mid;\\n        }\\n     \\n        return nums[left];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n         int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == nums[right]) while(nums[mid]==nums[right] && mid<right)right--;\\n            if (nums[mid] > nums[right]) left = mid + 1;\\n            else right = mid;\\n        }\\n     \\n        return nums[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882958,
                "title": "python-two-approaches-explained",
                "content": "Thanks to Neetcode https://www.youtube.com/watch?v=nIVW4P8b1VA\\n\\n\\nFirst, let\\'s understand how can we find minimum in a rotated sorted array. Since array was sorted before it is rotated, it means we can make use of Binary Search here.\\n\\n    Consider an example -> [2,2,2,0,1]\\n\\nWhen we use Binary Search, then we will get start element as \"2\", end element as \"1\" and mid element as \"2\"\\n\\nNow, if you look closely, since the array is rotated, it is divided into two parts. One is [2,2,2] and the other is [0,1] because initially the array as [0,1,2,2,2]\\n\\nAnd the elements in left part will always be bigger than all the elements in the right part. \\n\\nThis means, what we want to check is whether \"mid\" element belongs to left subarray or right subarray. if it belongs to the \"left\" subarray,then we know we will not find minimum on left side of mid. But if it belongs to the right subarray, then it means, we will find the minimum on the left side of mid.\\n\\n    \"mid\" will belong to left subarray if nums[mid] >= nums[start]\\n\\nHere, we see \"start\" and \"mid\" are the same i.e., \"2\". And since nums[mid] >= nums[start], So, we will move towards the right side for the smaller element. Before that, we will also check if \"mid\" is smaller than the previous smaller element (initially, we assume the first element is the smallest, just like how it is in case of a sorted array that is not rotated).\\n\\nWhy are we checking if mid is smaller than previous minimum? Because suppose we have this test case [2,2,0,1,1]. In this case, in the first iteration itself, we will get \"mid\" element as 0 which is the minimum so we do not want to lose track of it when we move to left or right side.\\n\\nAnyways, continuing with our example - [2,2,2,0,1], the start element = 0 and end element = 1. We see that here, start element itself is smaller than end element which means there is no need to even go to the right side. Since start is smaller than end, that means, either the previous mid element was the minimum, or the \"start\" element is the minimum. We simply return whatever is smaller.\\n\\nSo here, we will return 0 as the minimum element.\\n\\nHence, for every mid, we will also check if it is smaller than previous mid or not and update our minimum element accordingly. And after that, we move to either left or right side of mid.\\n\\n\\n## 1. APPROACH #1 - FIRST REMOVE THE DUPLICATES\\n\\nSince this problem asks us to decrease the operations as much as possible, this is not the best solution. But basically, we wil remove the duplicates and it then becomes \"[Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)\" problem.\\n\\n    def findMin(self, nums: List[int]) -> int:\\n        # To remove the duplicates but keep the order\\n        nums = list(dict.fromkeys(nums))\\n\\n        minimum = nums[0]\\n\\n        n = len(nums)\\n\\n        # We can search for the minimum element using Binary Search\\n        start = 0\\n        end = n - 1\\n\\n        while start <= end:\\n            # If the \"start\" element is smaller than \"end\"\\n            if nums[start] < nums[end]: return min(minimum, nums[start])\\n\\n            mid = start + (end - start) // 2\\n\\n            # IF this mid value is smaller than previous minimum we found\\n            # Then update the minimum\\n            minimum = min(minimum, nums[mid])\\n\\n            # Is this \"mid\" value part of left sorted subarray or right sorted subarray?\\n            # If this is part of the left sorted subarray, we will find minimum on right side\\n            if nums[mid] >= nums[start]: start = mid + 1\\n            # Otherwise, we will find the minimum on the left side\\n            else: end = mid - 1\\n        \\n        return minimum\\n\\n## 2. APPROACH #2 - SIMPLY USE BINARY SEARCH WITH A LITTLE TWEAK\\n\\nIf you use the same code as above (without removing duplicates), then you will see 187/193 test cases are getting passed. \\n\\nOne test case that is failing is [10,1,10,10,10]. So, let\\'s see how to fix that.\\n\\n    [10,1,10,10,10]\\n\\n    start = 10\\n    end = 10\\n    mid = 10\\n\\n    Did you see the problem? All the pointers have same element.\\n\\n    So, as per above code\\'s logic, \\n    since mid >= start, we should move to right side. \\n\\n    But this means, we will lose the actual minimum element \\n    which is \"1\".\\n\\nIn this case, the minimum can be anywhere. It can be on right of mid or on the left of mid.Here, it is on the left side of mid but if we had [3,3,0,3] then it would\\'ve been on the right side of mid.\\n\\nSo, to avoid any issues with any test case, we can do one of two things ->\\n\\n    Either Increment \"start\" pointer by 1\\n    Either Decrement \"end\" pointer by 1\\n\\nBecause what this will do is that in next iteration, either \"start\" element may be different than other two, or \"end\" might be different than other two, or the new \"mid\" might be different than other two. Because we want not all three to be the same as in that case, we cannot decide which way to move - left or right.\\n\\n\\n\\n    def findMin(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        minimum = nums[0]\\n\\n        # We can search for the minimum element using Binary Search\\n        start = 0\\n        end = n - 1\\n\\n        while start <= end:\\n            # If the \"start\" element is smaller than \"end\"\\n            if nums[start] < nums[end]: return min(minimum, nums[start])\\n\\n            mid = start + (end - start) // 2\\n\\n            # IF this mid value is smaller than previous minimum we found\\n            # Then update the minimum\\n            minimum = min(minimum, nums[mid])\\n\\n            # If start, end and mid are all same e.g. if [3,3,0,3] is the test case\\n            # Then, we will simply decrement end pointer\\n            if nums[start] == nums[mid] == nums[end]: end -= 1\\n            # Otherwise, we check\\n            # Is this \"mid\" value part of left sorted subarray or right sorted subarray?\\n            # If this is part of the left sorted subarray, we will find minimum on right side\\n            elif nums[mid] >= nums[start]: start = mid + 1\\n            # Otherwise, we will find the minimum on the left side\\n            else: end = mid - 1\\n\\n        return minimum\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Thanks to Neetcode https://www.youtube.com/watch?v=nIVW4P8b1VA\\n\\n\\nFirst, let\\'s understand how can we find minimum in a rotated sorted array. Since array was sorted before it is rotated, it means we can make use of Binary Search here.\\n\\n    Consider an example -> [2,2,2,0,1]\\n\\nWhen we use Binary Search, then we will get start element as \"2\", end element as \"1\" and mid element as \"2\"\\n\\nNow, if you look closely, since the array is rotated, it is divided into two parts. One is [2,2,2] and the other is [0,1] because initially the array as [0,1,2,2,2]\\n\\nAnd the elements in left part will always be bigger than all the elements in the right part. \\n\\nThis means, what we want to check is whether \"mid\" element belongs to left subarray or right subarray. if it belongs to the \"left\" subarray,then we know we will not find minimum on left side of mid. But if it belongs to the right subarray, then it means, we will find the minimum on the left side of mid.\\n\\n    \"mid\" will belong to left subarray if nums[mid] >= nums[start]\\n\\nHere, we see \"start\" and \"mid\" are the same i.e., \"2\". And since nums[mid] >= nums[start], So, we will move towards the right side for the smaller element. Before that, we will also check if \"mid\" is smaller than the previous smaller element (initially, we assume the first element is the smallest, just like how it is in case of a sorted array that is not rotated).\\n\\nWhy are we checking if mid is smaller than previous minimum? Because suppose we have this test case [2,2,0,1,1]. In this case, in the first iteration itself, we will get \"mid\" element as 0 which is the minimum so we do not want to lose track of it when we move to left or right side.\\n\\nAnyways, continuing with our example - [2,2,2,0,1], the start element = 0 and end element = 1. We see that here, start element itself is smaller than end element which means there is no need to even go to the right side. Since start is smaller than end, that means, either the previous mid element was the minimum, or the \"start\" element is the minimum. We simply return whatever is smaller.\\n\\nSo here, we will return 0 as the minimum element.\\n\\nHence, for every mid, we will also check if it is smaller than previous mid or not and update our minimum element accordingly. And after that, we move to either left or right side of mid.\\n\\n\\n## 1. APPROACH #1 - FIRST REMOVE THE DUPLICATES\\n\\nSince this problem asks us to decrease the operations as much as possible, this is not the best solution. But basically, we wil remove the duplicates and it then becomes \"[Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)\" problem.\\n\\n    def findMin(self, nums: List[int]) -> int:\\n        # To remove the duplicates but keep the order\\n        nums = list(dict.fromkeys(nums))\\n\\n        minimum = nums[0]\\n\\n        n = len(nums)\\n\\n        # We can search for the minimum element using Binary Search\\n        start = 0\\n        end = n - 1\\n\\n        while start <= end:\\n            # If the \"start\" element is smaller than \"end\"\\n            if nums[start] < nums[end]: return min(minimum, nums[start])\\n\\n            mid = start + (end - start) // 2\\n\\n            # IF this mid value is smaller than previous minimum we found\\n            # Then update the minimum\\n            minimum = min(minimum, nums[mid])\\n\\n            # Is this \"mid\" value part of left sorted subarray or right sorted subarray?\\n            # If this is part of the left sorted subarray, we will find minimum on right side\\n            if nums[mid] >= nums[start]: start = mid + 1\\n            # Otherwise, we will find the minimum on the left side\\n            else: end = mid - 1\\n        \\n        return minimum\\n\\n## 2. APPROACH #2 - SIMPLY USE BINARY SEARCH WITH A LITTLE TWEAK\\n\\nIf you use the same code as above (without removing duplicates), then you will see 187/193 test cases are getting passed. \\n\\nOne test case that is failing is [10,1,10,10,10]. So, let\\'s see how to fix that.\\n\\n    [10,1,10,10,10]\\n\\n    start = 10\\n    end = 10\\n    mid = 10\\n\\n    Did you see the problem? All the pointers have same element.\\n\\n    So, as per above code\\'s logic, \\n    since mid >= start, we should move to right side. \\n\\n    But this means, we will lose the actual minimum element \\n    which is \"1\".\\n\\nIn this case, the minimum can be anywhere. It can be on right of mid or on the left of mid.Here, it is on the left side of mid but if we had [3,3,0,3] then it would\\'ve been on the right side of mid.\\n\\nSo, to avoid any issues with any test case, we can do one of two things ->\\n\\n    Either Increment \"start\" pointer by 1\\n    Either Decrement \"end\" pointer by 1\\n\\nBecause what this will do is that in next iteration, either \"start\" element may be different than other two, or \"end\" might be different than other two, or the new \"mid\" might be different than other two. Because we want not all three to be the same as in that case, we cannot decide which way to move - left or right.\\n\\n\\n\\n    def findMin(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        minimum = nums[0]\\n\\n        # We can search for the minimum element using Binary Search\\n        start = 0\\n        end = n - 1\\n\\n        while start <= end:\\n            # If the \"start\" element is smaller than \"end\"\\n            if nums[start] < nums[end]: return min(minimum, nums[start])\\n\\n            mid = start + (end - start) // 2\\n\\n            # IF this mid value is smaller than previous minimum we found\\n            # Then update the minimum\\n            minimum = min(minimum, nums[mid])\\n\\n            # If start, end and mid are all same e.g. if [3,3,0,3] is the test case\\n            # Then, we will simply decrement end pointer\\n            if nums[start] == nums[mid] == nums[end]: end -= 1\\n            # Otherwise, we check\\n            # Is this \"mid\" value part of left sorted subarray or right sorted subarray?\\n            # If this is part of the left sorted subarray, we will find minimum on right side\\n            elif nums[mid] >= nums[start]: start = mid + 1\\n            # Otherwise, we will find the minimum on the left side\\n            else: end = mid - 1\\n\\n        return minimum\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2741332,
                "title": "java-simple-solution-faster-than-100-without-binary-search",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] < nums[nums.length - 1]){\\n            return nums[0];\\n        }\\n        \\n        if(nums.length == 1)\\n            return nums[0];\\n        \\n        if(nums[nums.length - 1] < nums[nums.length-2])\\n            return nums[nums.length - 1];\\n        for(int i = 0; i < nums.length-1; i++){\\n            if(nums[i] > nums[i+1])\\n                return nums[i+1];\\n        }\\n    \\n        return nums[0];\\n    }\\n}\\n```\\n***UP-VOTE IF HELPFUL***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] < nums[nums.length - 1]){\\n            return nums[0];\\n        }\\n        \\n        if(nums.length == 1)\\n            return nums[0];\\n        \\n        if(nums[nums.length - 1] < nums[nums.length-2])\\n            return nums[nums.length - 1];\\n        for(int i = 0; i < nums.length-1; i++){\\n            if(nums[i] > nums[i+1])\\n                return nums[i+1];\\n        }\\n    \\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544495,
                "title": "nested-binary-search-3ms-beats-97",
                "content": "**In worst case we do a nested binary search on both halves of the array.**\\n\\nIe.. At any **index** if we **cannot** determine where the **minimum** element might be? we do a binary search on **both left** and **right halves** in a recursive manner since both the halves are still sorted.\\n\\nAverage case : O(LogN)\\nWorst Case O(N*logN), since there can be O(N) calls and every call take O(LogN) time **(MORE INSIGHT NEEDED!!!)**\\n\\n\\tint helper(vector<int> &nums, int lo, int hi) {\\n        if (lo>hi) return INT_MAX;\\n        if (lo==hi) return nums[lo];\\n\\t\\t\\n        while (lo < hi) {           \\n            int mid = (lo + hi) / 2;\\n            \\n            if (nums[mid] == nums[0]) {\\n                return min(helper(nums, lo, mid), helper(nums, mid+1, hi));\\n            }\\n            if (nums[mid] > nums[0]) lo = mid+1;\\n            else hi = mid;\\n        } \\n        return nums[lo];\\n    }\\n        \\n    int findMin(vector<int>& nums) {      \\n        if (nums[0] < nums.back()) return nums[0];\\n        return helper(nums, 0, nums.size()-1);\\n    }",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "**In worst case we do a nested binary search on both halves of the array.**\\n\\nIe.. At any **index** if we **cannot** determine where the **minimum** element might be? we do a binary search on **both left** and **right halves** in a recursive manner since both the halves are still sorted.\\n\\nAverage case : O(LogN)\\nWorst Case O(N*logN), since there can be O(N) calls and every call take O(LogN) time **(MORE INSIGHT NEEDED!!!)**\\n\\n\\tint helper(vector<int> &nums, int lo, int hi) {\\n        if (lo>hi) return INT_MAX;\\n        if (lo==hi) return nums[lo];\\n\\t\\t\\n        while (lo < hi) {           \\n            int mid = (lo + hi) / 2;\\n            \\n            if (nums[mid] == nums[0]) {\\n                return min(helper(nums, lo, mid), helper(nums, mid+1, hi));\\n            }\\n            if (nums[mid] > nums[0]) lo = mid+1;\\n            else hi = mid;\\n        } \\n        return nums[lo];\\n    }\\n        \\n    int findMin(vector<int>& nums) {      \\n        if (nums[0] < nums.back()) return nums[0];\\n        return helper(nums, 0, nums.size()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2515934,
                "title": "beginner-binary-search-template-to-solve-both-153-154",
                "content": "[153 : Find Minimum in Rotated Sorted Array (Without Duplicates)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)\\n\\nTC => O(LogN)\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n\\t\\n        int low = 0, high = nums.length-1, min = nums[0];\\n        \\n        while(low<=high) {\\n            // to handle the case when array is already sorted\\n            if(nums[low]<nums[high]) { // not putting <= because the array contains unique elements\\n                min = Math.min(min,nums[low]);\\n                break;\\n            }\\n\\n            int mid = low + (high-low)/2;\\n\\n            min = Math.min(min,nums[mid]);\\n            \\n            if(nums[mid]>=nums[high]) // doing >= because of the edge case when mid and low points at the same index\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```\\n\\n[154: Find Minimum in Rotated Sorted Array II (With Duplicates)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)\\n\\nCan use the same code as above with just minor change that we will move high pointer when element at mid and element at high are equal and we can\\'t decide which side to move in the binary search.\\n\\nTC => O(LogN) in avergage case. O(N) in worst case.\\n\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n        int low = 0, high = nums.length-1, min = nums[0];\\n        \\n        while(low<=high) {\\n            \\n            if(nums[low]<nums[high]) {\\n                min = Math.min(min,nums[low]);\\n                break;\\n            }\\n            \\n            int mid = low + (high-low)/2;\\n            \\n            min = Math.min(min,nums[mid]);\\n            \\n            if(nums[mid]>nums[high])\\n                low = mid+1;\\n            \\n            else if(nums[mid]<nums[high])\\n                high = mid-1;\\n            \\n            else  // case when nums[mid]==nums[high]\\n                high--;  // here is the change\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n\\t\\n        int low = 0, high = nums.length-1, min = nums[0];\\n        \\n        while(low<=high) {\\n            // to handle the case when array is already sorted\\n            if(nums[low]<nums[high]) { // not putting <= because the array contains unique elements\\n                min = Math.min(min,nums[low]);\\n                break;\\n            }\\n\\n            int mid = low + (high-low)/2;\\n\\n            min = Math.min(min,nums[mid]);\\n            \\n            if(nums[mid]>=nums[high]) // doing >= because of the edge case when mid and low points at the same index\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n        int low = 0, high = nums.length-1, min = nums[0];\\n        \\n        while(low<=high) {\\n            \\n            if(nums[low]<nums[high]) {\\n                min = Math.min(min,nums[low]);\\n                break;\\n            }\\n            \\n            int mid = low + (high-low)/2;\\n            \\n            min = Math.min(min,nums[mid]);\\n            \\n            if(nums[mid]>nums[high])\\n                low = mid+1;\\n            \\n            else if(nums[mid]<nums[high])\\n                high = mid-1;\\n            \\n            else  // case when nums[mid]==nums[high]\\n                high--;  // here is the change\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420963,
                "title": "easy-1-line-solution-using-stl",
                "content": "**Easy 1  line solution using STL in c++**\\n\\n**Runtime : 6 ms\\nMemory :  12.1 MB**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355729,
                "title": "c-multiple-solutions-diffrent-approaches",
                "content": "**Codes are available in comments **",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2190991,
                "title": "must-see-easy-to-understand-meyhod-pure-binay-search-short-code",
                "content": "This code is same as (**Find minimum in rotated array 1** )only **one line** is added to avoid duplicate\\nEasy to understand \\nif \\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n    int n = nums.size();\\n \\n\\n    int low = 0, high = n-1;\\n    while(low<high) {\\n\\n        int mid = (low+high)>>1;\\n        \\n        if(nums[high]==nums[mid])high--;//for avoiding duplicate\\n        \\n        else if (nums[high] < nums[mid])//this means our ans is not present in left side \\n            low = mid+1;\\n        else\\n            high = mid; //May be mid is our ans \\n    }\\n        \\n        return nums[low];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n    int n = nums.size();\\n \\n\\n    int low = 0, high = n-1;\\n    while(low<high) {\\n\\n        int mid = (low+high)>>1;\\n        \\n        if(nums[high]==nums[mid])high--;//for avoiding duplicate\\n        \\n        else if (nums[high] < nums[mid])//this means our ans is not present in left side \\n            low = mid+1;\\n        else\\n            high = mid; //May be mid is our ans \\n    }\\n        \\n        return nums[low];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094822,
                "title": "simple-o-logn-solution-using-binary-search-o-n-worst-case-c",
                "content": "```\\n\\t\\tint n = nums.size();\\n        int low = 0 , high = n - 1;\\n\\n        while(low < high){\\n        \\tint mid = low + (high-low)/2;\\n        \\tif(nums[mid] < nums[high]){\\n        \\t\\thigh = mid;\\n        \\t}else if(nums[mid] > nums[high]){\\n        \\t\\tlow = mid + 1;\\n        \\t}else high--;\\n        }\\n        return nums[low];\\n\\t\\t\\n\\t//please upvote if found useful :-)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\t\\tint n = nums.size();\\n        int low = 0 , high = n - 1;\\n\\n        while(low < high){\\n        \\tint mid = low + (high-low)/2;\\n        \\tif(nums[mid] < nums[high]){\\n        \\t\\thigh = mid;\\n        \\t}else if(nums[mid] > nums[high]){\\n        \\t\\tlow = mid + 1;\\n        \\t}else high--;\\n        }\\n        return nums[low];\\n\\t\\t\\n\\t//please upvote if found useful :-)",
                "codeTag": "Unknown"
            },
            {
                "id": 1891028,
                "title": "python3-simple-binary-search-skip-duplicates",
                "content": "```\\n# time: avg O(log n), worst O(n)\\n# space: O(1)\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            # skip duplicates\\n            while left < mid and nums[left] == nums[mid]:\\n                left += 1\\n            while right > mid and nums[right] == nums[mid]:\\n                right -= 1\\n            \\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return nums[left]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n# time: avg O(log n), worst O(n)\\n# space: O(1)\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            # skip duplicates\\n            while left < mid and nums[left] == nums[mid]:\\n                left += 1\\n            while right > mid and nums[right] == nums[mid]:\\n                right -= 1\\n            \\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return nums[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841667,
                "title": "easy-to-understand-java-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length ==1){\\n            return nums[0];\\n        }\\n        int piv = pivot(nums);\\n        return nums[piv+1];\\n    }\\n    public int pivot(int[] arr){\\n        int piv =0;\\n        int start =0;\\n        int end = arr.length-1;\\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(mid<end && arr[mid]>arr[mid+1]){\\n                piv = mid;\\n                break;\\n            }\\n            else if(mid>start && arr[mid]<arr[mid-1]){\\n                piv = mid-1;\\n                break;\\n            }\\n            else if(start<end && arr[start]==arr[start+1]){\\n                start++;\\n            }\\n            else if(start<end && arr[end]==arr[end-1]){\\n                end--;\\n            }\\n            else if(arr[start]>arr[mid]){\\n                end = mid-1;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return piv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length ==1){\\n            return nums[0];\\n        }\\n        int piv = pivot(nums);\\n        return nums[piv+1];\\n    }\\n    public int pivot(int[] arr){\\n        int piv =0;\\n        int start =0;\\n        int end = arr.length-1;\\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(mid<end && arr[mid]>arr[mid+1]){\\n                piv = mid;\\n                break;\\n            }\\n            else if(mid>start && arr[mid]<arr[mid-1]){\\n                piv = mid-1;\\n                break;\\n            }\\n            else if(start<end && arr[start]==arr[start+1]){\\n                start++;\\n            }\\n            else if(start<end && arr[end]==arr[end-1]){\\n                end--;\\n            }\\n            else if(arr[start]>arr[mid]){\\n                end = mid-1;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return piv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840831,
                "title": "c-solution-faster-using-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        int low=0, high=nums.size()-1;\\n        while(low<=high) {\\n            long long int mid=low+(high-low)/2;\\n            if(mid!=0 && nums[mid]<nums[mid-1])\\n                return nums[mid];\\n            else if(nums[low]<=nums[mid] && nums[high]<nums[mid])\\n                  low=mid+1;\\n            else if(nums[high]==nums[mid])\\n                high--;\\n            else\\n                  high=mid-1;\\n        }\\n     return nums[0];\\n    }\\n};\\n// if(find helpful) {\\n    do upvote(); // thanks\\n\\t}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        int low=0, high=nums.size()-1;\\n        while(low<=high) {\\n            long long int mid=low+(high-low)/2;\\n            if(mid!=0 && nums[mid]<nums[mid-1])\\n                return nums[mid];\\n            else if(nums[low]<=nums[mid] && nums[high]<nums[mid])\\n                  low=mid+1;\\n            else if(nums[high]==nums[mid])\\n                high--;\\n            else\\n                  high=mid-1;\\n        }\\n     return nums[0];\\n    }\\n};\\n// if(find helpful) {\\n    do upvote(); // thanks\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837407,
                "title": "c-using-stl-function-simple-one-line-code",
                "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[0];\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1586223,
                "title": "beats-100-binary-search-worst-case-o-n-simple-code",
                "content": "Just added two lines in the previous version of this question. \\n\\nMinimum in Rotated Sorted Array \\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n=nums.length;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            int mid=i+(j-i)/2;\\n            if(nums[j]<nums[mid]) i=mid+1;\\n            else j=mid;\\n        }\\n        return nums[i];\\n    }\\n}\\n```\\nMinimum in Rotated Sorted Array II\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n=nums.length;\\n        int i=0,j=n-1;\\n        while(i<j){\\n\\t\\t\\n            while(i+1<n && nums[i]==nums[i+1]) i++;\\n            while(j-1>=0 && nums[j-1]==nums[j]) j--;\\n\\t\\t\\t\\n            int mid=i+(j-i)/2;\\n            if(nums[j]<nums[mid]) i=mid+1;\\n            else j=mid;\\n        }\\n        return nums[i];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n=nums.length;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            int mid=i+(j-i)/2;\\n            if(nums[j]<nums[mid]) i=mid+1;\\n            else j=mid;\\n        }\\n        return nums[i];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n=nums.length;\\n        int i=0,j=n-1;\\n        while(i<j){\\n\\t\\t\\n            while(i+1<n && nums[i]==nums[i+1]) i++;\\n            while(j-1>=0 && nums[j-1]==nums[j]) j--;\\n\\t\\t\\t\\n            int mid=i+(j-i)/2;\\n            if(nums[j]<nums[mid]) i=mid+1;\\n            else j=mid;\\n        }\\n        return nums[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270763,
                "title": "very-very-simple-extremely-simple-1-line-java-code-0ms-code",
                "content": "```\\nclass Solution {public int findMin(int[] nums) {int a = Integer.MAX_VALUE;for(int i =0;i<nums.length;i++){a = Math.min(nums[i],a);}return a;}}\\n```\\n![image](https://assets.leetcode.com/users/images/f39930d3-0d05-49fa-8bd3-e9d5374b2ee6_1623630251.759159.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {public int findMin(int[] nums) {int a = Integer.MAX_VALUE;for(int i =0;i<nums.length;i++){a = Math.min(nums[i],a);}return a;}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181687,
                "title": "binary-search-100-time-and-compare-using-the-lower-bound",
                "content": "Most of these answers are great but comparing the right most element with nums[mid] is not intuitive to me. \\nSo I choose to check if elements between left and right are rotated or not in the loop. If not, then the left element is the smallest one. \\n\\n```\\npublic int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            if (nums[left] < nums[right]) return nums[left];\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > nums[left]) {\\n                left = mid + 1;\\n            } else if (nums[mid] < nums[left]){\\n                right = mid;\\n            } else {\\n                left++;\\n            }\\n        }\\n        return nums[left];\\n    }\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "Most of these answers are great but comparing the right most element with nums[mid] is not intuitive to me. \\nSo I choose to check if elements between left and right are rotated or not in the loop. If not, then the left element is the smallest one. \\n\\n```\\npublic int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            if (nums[left] < nums[right]) return nums[left];\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > nums[left]) {\\n                left = mid + 1;\\n            } else if (nums[mid] < nums[left]){\\n                right = mid;\\n            } else {\\n                left++;\\n            }\\n        }\\n        return nums[left];\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1023868,
                "title": "divide-conquer-explanation-visual-python",
                "content": "***TLDR ( Explanation + Visual below code snippet)*** This problem is almost identical to problem [Leetcode 153 Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/582964/4-Solutions-Including-Divide-and-Conquer-Binary-Search-(%2B-Follow-Up)) except duplicates are now allowed. Using the [same approach as in 153](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/582964/4-Solutions-Including-Divide-and-Conquer-Binary-Search-(%2B-Follow-Up)) we get ```O(N)```  in the worst case, which is when the array is mostly duplicates. To counter act this we can apply our ***divide and conquer strategy*** in a way that more closely resembles ***binary search*** than our previous approach to achieve a ```O(Log N) ``` runtime in the worst case.\\n\\n```python \\n    def findMin(self, nums: List[int]) -> int:\\n        return self.find_min(nums, 0, len(nums)-1)\\n        \\n    def find_min(self, nums, low, high):\\n        mid = (low + high)//2\\n        if low == high: return nums[low]\\n        if nums[low] < nums[high]: return nums[low]\\n        \\n        if nums[mid] > nums[low]:\\n            return self.find_min(nums, mid + 1, high)\\n        elif nums[mid] < nums[low]:\\n            return self.find_min(nums, low, mid)\\n        else:\\n            return min(self.find_min(nums, mid + 1, high), self.find_min(nums, low, mid))\\n```\\n\\n* * * \\n### Overview \\n* * * \\n\\nif you do not know how to sovle the version of this problem where all elements are unique using the ***divide & conquer strategy*** [read here](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1022263/divide-conquer-explanation-visual-python)\\n\\nThe problem is our solution for  [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1022263/divide-conquer-explanation-visual-python) becomes inefficient if we allow for duplicates.\\n\\nTo see why this is the case let us breifly review our approach; both code & intuition \\n\\n```python\\n\\ndef findMin(self, nums: List[int]) -> int:\\n  return self.find_min(nums, 0, len(nums) - 1)\\n\\ndef find_min(self, nums, lo, hi):\\n\\tprint(nums[lo:hi+1])\\n\\tif lo >= hi: return nums[lo]\\n\\tif nums[lo] <= nums[hi]: return nums[lo]\\n\\tmid = (lo + hi)//2\\n\\n\\tleft = self.find_min(nums, lo, mid)\\n\\tright = self.find_min(nums, mid + 1, hi)\\n\\treturn min(left, right);\\n\\n```\\n* * * \\nRecall this approach uses the ***divide & conquer strategy***\\n\\nThe ***divide & conquer strategy*** says\\n* if a problem is ***small*** solve it directly \\n* if a problem is ***large*** break it down (***divide***) until it is ***small***\\n\\t* a problem is large  if it is ***NOT small***\\n* combine (***conquer***) all smaller solutions \\n\\nThis is the approach we took in [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1022263/divide-conquer-explanation-visual-python)\\n\\n* The problem is ***small***  when the block of elements is ***sorted***, because it is trivial (meaning we can solve directly) to find the ***minimum***,  the ***mimimum*** is always the first element.\\n\\n* the problem  is large when the block of elements is ***not sorted*** we divide the array into two halves (***left*** and ***right***) and attempt to solve the subproblems in both halves.  \\n\\n* we can combine solutions to subproblems by taking the ***min(left, right)***\\n* * * \\nFor an array of unique integers this is not a problem, but observe what happens when we try an array of mostly duplicates. \\n\\n![image](https://assets.leetcode.com/users/images/41b2590c-5f1c-438c-8ac1-83bd19399420_1611008295.9720004.png)\\n\\nOur worst case is now ```O(N)```, but we need to ensure our runtime never drops below  ```O(Log N)```\\nHow can we optimize this ?\\n\\n* * * \\n### Optimization \\n* * * \\n\\nNotice when the problem is large and we divide the problem into two subproblems ***left*** and ***right*** and solve them both even though the minimum can only exist in one side. \\n\\n![image](https://assets.leetcode.com/users/images/523c1de2-7189-44cb-b9b1-b13e3e3bf829_1611018174.900272.png)\\n\\nThis is the ***heart of the inefficiency***, we are solving subproblems that could never lead to the correct solution.\\n* * * \\n\\nif at each stage we only choose to the side where the minimum lies we can improve our overall runtime to ```O(Log N)``` (except in the case where the entire array is the same value. \\n\\n*  if ```arr[mid] > arr[low]``` the min must lie on the right \\n* if ```arr[mid] < arr[low]``` the min must lie on the left.\\n*  if ```arr[low] == arr[mid]``` there is no way to know which side min lies on so we go left and go right\\n* * * \\n\\nApplying this to an example with duplicates \\n\\n![image](https://assets.leetcode.com/users/images/de590164-9427-4f6e-8eef-be5e5fbcd0ca_1611011312.8194568.png)\\n\\nthis solution gives rise to the following code \\n\\n```python \\ndef findMin(self, nums: List[int]) -> int:\\n        return self.find_min(nums, 0, len(nums)-1)\\n         \\n    def find_min(self, nums, low, high):\\n        mid = (low + high)//2\\n        if low == high: return nums[low]\\n        if nums[low] < nums[high]: return nums[low]\\n        \\n        if nums[mid] < nums[low]:\\n            return self.find_min(nums, low, mid)\\n        elif nums[mid] > nums[low]:\\n            return self.find_min(nums, mid + 1, high)\\n        else:\\n            return min(self.find_min(nums, mid + 1, high), self.find_min(nums, low, mid))\\n```\\ncode courtesy of [junhaowanggg](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/582964/4-Solutions-Including-Divide-and-Conquer-Binary-Search-(%2B-Follow-Up))",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```O(N)```\n```O(Log N) ```\n```python \\n    def findMin(self, nums: List[int]) -> int:\\n        return self.find_min(nums, 0, len(nums)-1)\\n        \\n    def find_min(self, nums, low, high):\\n        mid = (low + high)//2\\n        if low == high: return nums[low]\\n        if nums[low] < nums[high]: return nums[low]\\n        \\n        if nums[mid] > nums[low]:\\n            return self.find_min(nums, mid + 1, high)\\n        elif nums[mid] < nums[low]:\\n            return self.find_min(nums, low, mid)\\n        else:\\n            return min(self.find_min(nums, mid + 1, high), self.find_min(nums, low, mid))\\n```\n```python\\n\\ndef findMin(self, nums: List[int]) -> int:\\n  return self.find_min(nums, 0, len(nums) - 1)\\n\\ndef find_min(self, nums, lo, hi):\\n\\tprint(nums[lo:hi+1])\\n\\tif lo >= hi: return nums[lo]\\n\\tif nums[lo] <= nums[hi]: return nums[lo]\\n\\tmid = (lo + hi)//2\\n\\n\\tleft = self.find_min(nums, lo, mid)\\n\\tright = self.find_min(nums, mid + 1, hi)\\n\\treturn min(left, right);\\n\\n```\n```O(N)```\n```O(Log N)```\n```O(Log N)```\n```arr[mid] > arr[low]```\n```arr[mid] < arr[low]```\n```arr[low] == arr[mid]```\n```python \\ndef findMin(self, nums: List[int]) -> int:\\n        return self.find_min(nums, 0, len(nums)-1)\\n         \\n    def find_min(self, nums, low, high):\\n        mid = (low + high)//2\\n        if low == high: return nums[low]\\n        if nums[low] < nums[high]: return nums[low]\\n        \\n        if nums[mid] < nums[low]:\\n            return self.find_min(nums, low, mid)\\n        elif nums[mid] > nums[low]:\\n            return self.find_min(nums, mid + 1, high)\\n        else:\\n            return min(self.find_min(nums, mid + 1, high), self.find_min(nums, low, mid))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 821468,
                "title": "four-similar-problems",
                "content": "## [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)\\n\\nCompare `nums[mid]` with `nums[r]`:\\n\\n```C++\\nint findMin(vector<int>& nums) {\\n    int n = nums.size();\\n    if (nums[0] < nums[n-1]) return nums[0];\\n\\n    int l = 0, r = n-1;\\n    while (l < r) {\\n        int m = l + ((r - l) >> 1);\\n        if (nums[m] >= nums[r])\\n            l = m+1;\\n        else\\n            r = m;\\n    }\\n\\n    return nums[r];\\n}\\n```\\n- You can also compare with `nums[0]`, or `nums[n-1]`. The change is easy.\\n- However, you cannot compare with `nums[l]`. The reason is explained [here](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/821400/Explanation-on-comparing-with-upper-bound).\\n\\n<br />\\n\\n## [154. Find Minimum in Rotated Sorted Array II](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)\\n\\nWith duplicates, we need one more case: \\n\\n```C++\\nint findMin(vector<int>& nums) {\\n    int n = nums.size();\\n    if (nums[0] < nums[n-1]) return nums[0];\\n\\n    int l = 0, r = n-1;\\n    while (l < r) {\\n        int m = l + ((r - l) >> 1);\\n        if (nums[m] > nums[r]) {\\n\\t\\t\\tl = m+1;\\n\\t\\t} else if (nums[m] < nums[r]) {\\n\\t\\t\\tr = m;\\n\\t\\t} else {\\n\\t\\t\\t// Method 1\\n\\t\\t\\t// r--;\\n\\n\\t\\t\\t// Method 2\\n\\t\\t\\tint minVal = INT_MAX;\\n\\t\\t\\tfor (int i = l; i <= r; i++) {\\n\\t\\t\\t\\tminVal = min(minVal, nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn minVal;\\n\\t\\t}\\n    }\\n\\n    return nums[r];\\n}\\n```\\n\\nWe cannot compare with `nums[0]` or `nums[l]`. The reason is explained [here](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/821400/Explanation-on-comparing-with-upper-bound).\\n\\n<br />\\n\\n## [33. Search Minimum in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)\\nUse solution to Leetcode 153 in `getPivotIndex`. \\n```C++\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int l = 0, r = n-1;\\n        \\n        if (nums[0] > nums[n-1]) {\\n            // Determine pivot\\n            int pivotIndex = getPivotIndex(nums);\\n            \\n            if (nums[pivotIndex] <= target && target <= nums[n-1])\\n                l = pivotIndex;\\n            else if (nums[0] <= target && target <= nums[pivotIndex-1])\\n                r = pivotIndex-1;\\n            else\\n                return -1;\\n        }\\n        \\n        // normal binary search\\n        while (l <= r) {\\n            int m = l + ((r-l) >> 1);\\n            if (nums[m] == target)\\n                return m;\\n            else if (nums[m] > target)\\n                r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int getPivotIndex(vector<int>& nums) {\\n        // Assume nums is rotated\\n        int n = nums.size();\\n        int l = 0, r = n-1;\\n        while (l < r) {\\n            int m = ((r - l) >> 1) + l;\\n            if (nums[m] >= nums[0])\\n                l = m+1;\\n            else\\n                r = m;\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\n<br />\\n\\n## [81. Search Minimum in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)\\nUse solution to Leetcode 154 in `getPivotIndex`. Note that the solution itself doesn\\'t give the exact index of the pivot. Read the comment.  \\n```C++\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        if (nums.empty()) return false;\\n        \\n        // determine pivot\\n        int n = nums.size();\\n        int l = 0, r = n-1;\\n        \\n        if (nums[0] >= nums[n-1]) {\\n            // Determine pivot\\n            int pivotIndex = getPivotIndex(nums);\\n            cout << pivotIndex << endl;\\n            \\n            if (nums[pivotIndex] <= target && target <= nums[n-1])\\n                l = pivotIndex;\\n            else if (nums[0] <= target && pivotIndex > 0 && target <= nums[pivotIndex-1])\\n                r = pivotIndex-1;\\n            else\\n                return false;\\n        }\\n        \\n        // normal binary search\\n        while (l <= r) {\\n            int m = l + ((r-l) >> 1);\\n            if (nums[m] == target)\\n                return true;\\n            else if (nums[m] > target)\\n                r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getPivotIndex(vector<int>& nums) {\\n        // Assume nums is rotated\\n        int n = nums.size();\\n        int l = 0, r = n-1;\\n        while (l < r) {\\n            int m = ((r - l) >> 1) + l;\\n            if (nums[m] > nums[r]) {\\n                l = m+1;\\n            } else if (nums[m] < nums[r]) {\\n                r = m;\\n            } else {\\n                // Method 1\\n                // https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/48808/My-pretty-simple-code-to-solve-it/48840\\n                /*\\n                if (nums[r-1] > nums[r]) {\\n                    break;\\n                }\\n                r--;\\n                */\\n                \\n                // Method 2: linear search\\n                for (int i = l; i <= r; i++)\\n                    if (i-1 >= 0 && nums[i-1] > nums[i])\\n                        return i;\\n                \\n                // All values the same in nums[l..r]\\n                return r;\\n            }\\n                \\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nint findMin(vector<int>& nums) {\\n    int n = nums.size();\\n    if (nums[0] < nums[n-1]) return nums[0];\\n\\n    int l = 0, r = n-1;\\n    while (l < r) {\\n        int m = l + ((r - l) >> 1);\\n        if (nums[m] >= nums[r])\\n            l = m+1;\\n        else\\n            r = m;\\n    }\\n\\n    return nums[r];\\n}\\n```\n```C++\\nint findMin(vector<int>& nums) {\\n    int n = nums.size();\\n    if (nums[0] < nums[n-1]) return nums[0];\\n\\n    int l = 0, r = n-1;\\n    while (l < r) {\\n        int m = l + ((r - l) >> 1);\\n        if (nums[m] > nums[r]) {\\n\\t\\t\\tl = m+1;\\n\\t\\t} else if (nums[m] < nums[r]) {\\n\\t\\t\\tr = m;\\n\\t\\t} else {\\n\\t\\t\\t// Method 1\\n\\t\\t\\t// r--;\\n\\n\\t\\t\\t// Method 2\\n\\t\\t\\tint minVal = INT_MAX;\\n\\t\\t\\tfor (int i = l; i <= r; i++) {\\n\\t\\t\\t\\tminVal = min(minVal, nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn minVal;\\n\\t\\t}\\n    }\\n\\n    return nums[r];\\n}\\n```\n```C++\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int l = 0, r = n-1;\\n        \\n        if (nums[0] > nums[n-1]) {\\n            // Determine pivot\\n            int pivotIndex = getPivotIndex(nums);\\n            \\n            if (nums[pivotIndex] <= target && target <= nums[n-1])\\n                l = pivotIndex;\\n            else if (nums[0] <= target && target <= nums[pivotIndex-1])\\n                r = pivotIndex-1;\\n            else\\n                return -1;\\n        }\\n        \\n        // normal binary search\\n        while (l <= r) {\\n            int m = l + ((r-l) >> 1);\\n            if (nums[m] == target)\\n                return m;\\n            else if (nums[m] > target)\\n                r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int getPivotIndex(vector<int>& nums) {\\n        // Assume nums is rotated\\n        int n = nums.size();\\n        int l = 0, r = n-1;\\n        while (l < r) {\\n            int m = ((r - l) >> 1) + l;\\n            if (nums[m] >= nums[0])\\n                l = m+1;\\n            else\\n                r = m;\\n        }\\n        return r;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        if (nums.empty()) return false;\\n        \\n        // determine pivot\\n        int n = nums.size();\\n        int l = 0, r = n-1;\\n        \\n        if (nums[0] >= nums[n-1]) {\\n            // Determine pivot\\n            int pivotIndex = getPivotIndex(nums);\\n            cout << pivotIndex << endl;\\n            \\n            if (nums[pivotIndex] <= target && target <= nums[n-1])\\n                l = pivotIndex;\\n            else if (nums[0] <= target && pivotIndex > 0 && target <= nums[pivotIndex-1])\\n                r = pivotIndex-1;\\n            else\\n                return false;\\n        }\\n        \\n        // normal binary search\\n        while (l <= r) {\\n            int m = l + ((r-l) >> 1);\\n            if (nums[m] == target)\\n                return true;\\n            else if (nums[m] > target)\\n                r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getPivotIndex(vector<int>& nums) {\\n        // Assume nums is rotated\\n        int n = nums.size();\\n        int l = 0, r = n-1;\\n        while (l < r) {\\n            int m = ((r - l) >> 1) + l;\\n            if (nums[m] > nums[r]) {\\n                l = m+1;\\n            } else if (nums[m] < nums[r]) {\\n                r = m;\\n            } else {\\n                // Method 1\\n                // https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/48808/My-pretty-simple-code-to-solve-it/48840\\n                /*\\n                if (nums[r-1] > nums[r]) {\\n                    break;\\n                }\\n                r--;\\n                */\\n                \\n                // Method 2: linear search\\n                for (int i = l; i <= r; i++)\\n                    if (i-1 >= 0 && nums[i-1] > nums[i])\\n                        return i;\\n                \\n                // All values the same in nums[l..r]\\n                return r;\\n            }\\n                \\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 821400,
                "title": "explanation-on-comparing-with-upper-bound",
                "content": "Why we compare `nums[mid]` with `nums[right]`, instead of `nums[0]` or `nums[left]`?\\n\\n<br />\\n\\n\\n### Compare `nums[mid]` and `nums[0]`?\\n\\nI guess you want to try `nums[0]` because in Leetcode 153, when the array doesn\\'t contain duplicates, the solution compares with `nums[0]`. When the array contains no duplicate, comparing with `nums[0]` is enough to determine the position of `nums[mid]`. However, this\\'s not the case when the array contains duplicate. \\n\\nConsider sorted array `[0, 1, 1, 1, 1]`. You can get rotated array `[1, 1, 1, 0, 1]` and `[1, 0, 1, 1, 1]`. At the first iteration, you would have `left` = 0, `right` = 4, `mid` = 2. For the 1st array, `nums[mid] == nums[0]` and `nums[mid]` is on the left-half, so you normally don\\'t want to move `left`; while for the 2nd array, `nums[mid]` is on the right half, so you normally don\\'t want to more `right`. As we see, comparing with `nums[0]` doesn\\'t give enough information when the array contains duplicate.\\n\\n\\n\\n<br />\\n\\n### Compare `nums[mid]` and `nums[left]`?\\n\\nThis question can be considered as a general form of Leetcode 153, where the array doesn\\'t contains duplicate. In other words, Leetcode 153 is a simpler form of this question. We can understand why we don\\'t compare `nums[mid]` with `nums[left]`, by considering the simpler form.\\n\\nWhen the array doesn\\'t contain duplicate:\\n\\n```c++\\nint l = 0, r = n-1;\\nwhile (l < r) {\\n\\tint m = (l + r) / 2;\\n\\tif (nums[m] > ???)\\n\\t\\tl = m + 1;\\n\\telse\\n\\t\\tr = m;\\n}\\n```\\n\\nConsider two cases: \\n\\n- `left`, `mid` are on the left half of the rotated array, while `right` is on the right half. `nums[m] > nums[l]`. Should move `left`.\\n\\n    ```\\n     [2, 3, 4, 5, 6, 0, 1]\\n      l        m        r\\n    ```\\n\\n- `left`, `mid`, `right` are all on the right half of the rotated array. `nums[m] > nums[l]`. Should move `right`.\\n\\n    ```\\n     [6, 0, 1, 2, 3, 4, 5]\\n         l     m        r\\n    ```\\n\\nAgain, comparing with `nums[left]` doesn\\'t give enough information even in the simpler form (when the array doesn\\'t contain dupulicates). So it wouldn\\'t work in the general form of the question (this question).\\n\\n",
                "solutionTags": [],
                "code": "```c++\\nint l = 0, r = n-1;\\nwhile (l < r) {\\n\\tint m = (l + r) / 2;\\n\\tif (nums[m] > ???)\\n\\t\\tl = m + 1;\\n\\telse\\n\\t\\tr = m;\\n}\\n```\n```\\n     [2, 3, 4, 5, 6, 0, 1]\\n      l        m        r\\n    ```\n```\\n     [6, 0, 1, 2, 3, 4, 5]\\n         l     m        r\\n    ```",
                "codeTag": "Unknown"
            },
            {
                "id": 779701,
                "title": "python3-easy-solution-with-explanation",
                "content": "* This solution is basically like finding the pivot in rotated sorted array.\\n* The only complication is if there is a case like [1,2,3,4,1,1] where the same element is appearing at the beginning and at the end.\\n* To combat this, we preprocess the array by just decrementing the right pointer by 1 till the first and the last element are not equal. Then we perform binary search.\\n* In my code, the first while loop takes care of it. The second while loop finds the pivot index. Just returning the nums of pivot index.\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        lo, hi = 0, len(nums) - 1\\n        while hi > 0 and nums[0] == nums[hi]:\\n            hi -= 1\\n        while lo < hi:\\n            mid = lo + hi >> 1\\n            if nums[mid] > nums[hi]:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return nums[lo]\\n```\\nRuntime: 52 ms, faster than 85.98% of Python3 online submissions for Find Minimum in Rotated Sorted Array II.\\nMemory Usage: 14.4 MB, less than 23.93% of Python3 online submissions for Find Minimum in Rotated Sorted Array II.",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        lo, hi = 0, len(nums) - 1\\n        while hi > 0 and nums[0] == nums[hi]:\\n            hi -= 1\\n        while lo < hi:\\n            mid = lo + hi >> 1\\n            if nums[mid] > nums[hi]:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return nums[lo]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758389,
                "title": "python-solution-faster-than-99-less-memory-than-100",
                "content": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if not nums:\\n            return float(\\'inf\\')\\n        low = 0\\n        high = len(nums) - 1\\n        while low <= high:\\n            if low == high:\\n                return nums[low]\\n            mid = low + (high - low) // 2\\n            ele = nums[mid]\\n            if ele > nums[high]:\\n                low = mid + 1\\n            elif ele == nums[high]:\\n                if ele != nums[low]:\\n                    if nums[mid - 1] > ele:\\n                        return ele\\n                    high = mid - 1\\n                else:\\n                    return min(self.findMin(nums[ : mid]), self.findMin(nums[mid + 1 : ]))\\n            else:\\n                if mid == 0 or nums[mid - 1] > ele:\\n                    return ele\\n                high = mid - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if not nums:\\n            return float(\\'inf\\')\\n        low = 0\\n        high = len(nums) - 1\\n        while low <= high:\\n            if low == high:\\n                return nums[low]\\n            mid = low + (high - low) // 2\\n            ele = nums[mid]\\n            if ele > nums[high]:\\n                low = mid + 1\\n            elif ele == nums[high]:\\n                if ele != nums[low]:\\n                    if nums[mid - 1] > ele:\\n                        return ele\\n                    high = mid - 1\\n                else:\\n                    return min(self.findMin(nums[ : mid]), self.findMin(nums[mid + 1 : ]))\\n            else:\\n                if mid == 0 or nums[mid - 1] > ele:\\n                    return ele\\n                high = mid - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755081,
                "title": "javascript-beats-100-runtime-binary-search",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMin = function(nums) {\\n    let lo = 0;\\n    let hi = nums.length - 1;\\n    let mid = 0;\\n        \\n        while(lo < hi) {\\n            mid = lo + Math.floor((hi - lo) / 2);\\n            \\n            if (nums[mid] > nums[hi]) {\\n                lo = mid + 1;\\n            }\\n            else if (nums[mid] < nums[hi]) {\\n                hi = mid;\\n            }\\n            else {\\n                hi--;\\n            }\\n        }\\n        return nums[lo];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMin = function(nums) {\\n    let lo = 0;\\n    let hi = nums.length - 1;\\n    let mid = 0;\\n        \\n        while(lo < hi) {\\n            mid = lo + Math.floor((hi - lo) / 2);\\n            \\n            if (nums[mid] > nums[hi]) {\\n                lo = mid + 1;\\n            }\\n            else if (nums[mid] < nums[hi]) {\\n                hi = mid;\\n            }\\n            else {\\n                hi--;\\n            }\\n        }\\n        return nums[lo];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 754264,
                "title": "point-of-this-question",
                "content": "Although most people can see that the trivial solution to this problem is simply travesing the array ```nums``` and returning the minimum element, this is not what is problem is trying to test. The whole point of this problem is to explain why ```O(n)``` is indeed the worst case time complexity for any deterministic algorithm that solves this problem.\\n\\nNotice that the question contains a link to the first part of the problem, which I encourage everyone to solve. Once you solve that, you\\'ll notice that the solution depends on the fact that all elements are distinct so that you can update the boundaries during binary search.\\n\\nThis question is the follow-up to that question where the interviewer expects you to answer if your solution will fall apart in presence of duplicates within the array. To answer this, you can think in terms of an adversary which takes any deterministic algorithm as input, and produces ```nums``` as an output such that the input algorithm will suffer the worst case time. Let me illustrate this with help of an example.\\n\\nLet\\'s say \\n```nums_left = [2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]``` and\\n```nums_right = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2]```.\\n```nums_all = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]```.\\n\\nAny deterministic algorithm based on binary search should be able to break a tie the case when ```nums[left] == nums[mid] == nums[right]```. Note that all the arrays above satisfy this condition in the first iteration of the loop. Whatever be the tie breaking strategy for the input deterministic algorithm, you can create ```nums``` such that the algorithm checks the index of item ```0``` at the very end, hence making the worst case runtime of ```O(n)```.\\n\\nHope this helps.\\n",
                "solutionTags": [],
                "code": "```nums```\n```O(n)```\n```nums```\n```nums_left = [2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]```\n```nums_right = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2]```\n```nums_all = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]```\n```nums[left] == nums[mid] == nums[right]```\n```nums```\n```0```\n```O(n)```",
                "codeTag": "Unknown"
            },
            {
                "id": 543256,
                "title": "java-code-1-liner",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[0];  \\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findMin(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[0];  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 324946,
                "title": "rust-4ms-binary-search-o-n",
                "content": "```\\nimpl Solution {\\n    pub fn find_min(nums: Vec<i32>) -> i32 {\\n        if nums.is_empty() {\\n            return 0;\\n        }\\n\\n        let (mut l, mut r) = (0, nums.len() - 1);\\n        while l < r {\\n            let mid = l + ((r - l) >> 1);\\n            if nums[mid] > nums[r] {\\n                l = mid + 1;\\n            } else if nums[mid] < nums[r] {\\n                r = mid;\\n            } else {\\n                r -= 1;  // special case\\n            }\\n        }\\n        nums[l]\\n    }\\n}\\n```\\n\\nIt\\'s almost the same like [Rust, 0ms, binary search](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/324713/rust-0ms-binary-search), which is a solution for [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/).\\nThe only tricky part is that, when `nums[mid] == nums[r]`, you can\\'t deside how to change the interval, except shrink the right with `r -= 1`. If this seems confusing for you, think about a extremely case `[1, 1, 1, 0, 1]` and `[1, 0, 1, 1, 1]`, at this case, you can\\'t decide which is the next interval only by `nums[mid]` and `nums[r]`. All you can make sure is, if `nums[r]` is the answer, so is `nums[mid]`. So shinking interval with `r -= 1` won\\'t break the invariant: The answer is in interval [l, r].",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn find_min(nums: Vec<i32>) -> i32 {\\n        if nums.is_empty() {\\n            return 0;\\n        }\\n\\n        let (mut l, mut r) = (0, nums.len() - 1);\\n        while l < r {\\n            let mid = l + ((r - l) >> 1);\\n            if nums[mid] > nums[r] {\\n                l = mid + 1;\\n            } else if nums[mid] < nums[r] {\\n                r = mid;\\n            } else {\\n                r -= 1;  // special case\\n            }\\n        }\\n        nums[l]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48882,
                "title": "5-lines-of-easy-c-implementation",
                "content": "    class Solution {\\n    public:\\n        int findMin(vector<int>& nums) {\\n            int start=0, end=nums.size()-1;\\n            while(end>start){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]>nums[end])  start=mid+1;\\n                else if(nums[mid]<nums[end]) end=mid;\\n                else end--;\\n            }\\n            return nums[end];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findMin(vector<int>& nums) {\\n            int start=0, end=nums.size()-1;\\n            while(end>start){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]>nums[end])  start=mid+1;\\n                else if(nums[mid]<nums[end]) end=mid;\\n                else end--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48972,
                "title": "accepted-solution-and-time-complexity",
                "content": "First, what is the best time complexity for this problem?\\n\\nI have the following solution, which is accepted. But, I\\u2018m not sure about the time complexity.\\nBasically, compare num[mid] with num[high]. if num[mid] > num[high], the minimum should be in the right half; if num[mid] < num[high], the minimum should be in the left half. if num[mid]==num[high]. the minimum can be in either half. However, what is the time complexity of this solution? I think it is not O(lg n). \\n\\n\\n\\n\\npublic class Solution {\\n\\n    public int findMin(int[] num) {\\n        int low = 0; \\n        int high = num.length -1;\\n        if (num.length == 1)\\n            return num[0];\\n        \\n        return findMin(num, low, high);\\n        \\n    }\\n    public int findMin(int[] num, int low, int high) {\\n        if (low == high)\\n            return num[low];\\n        \\n        int mid = (low + high)/2;\\n        if (num[mid] < num[high]) {\\n            return findMin(num, low, mid);\\n        } else if (num[mid] > num[high]) {\\n            return findMin(num, mid + 1, high);\\n        } else { // num[mid] == num[high] \\n            // in this case, the minimal element can be on either side.\\n            int minLeft = findMin(num, low, mid);\\n            int minRight = findMin(num, mid+1, high);\\n            \\n            return Math.min(minLeft, minRight);\\n        }\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int findMin(int[] num) {\\n        int low = 0; \\n        int high = num.length -1;\\n        if (num.length == 1)\\n            return num[0];\\n        \\n        return findMin(num, low, high);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4007021,
                "title": "find-minimum-in-rotated-sorted-array-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    int n = nums.size();\\n    int start = 0;\\n    int end = n - 1;\\n\\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n        int prev = (mid + n - 1) % n;\\n        int next = (mid + 1) % n;\\n\\n        if (nums[mid] < nums[next] && nums[mid] < nums[prev])\\n            return nums[mid];\\n\\n        if (nums[mid] == nums[start] && nums[mid] == nums[end]) {\\n            start++;\\n            end--;\\n        } else if (nums[end] >= nums[mid]) { \\n            end = mid ;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n\\n    return nums[start];\\n}\\n\\n        \\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    int n = nums.size();\\n    int start = 0;\\n    int end = n - 1;\\n\\n    while (start < end) {\\n        int mid = start + (end - start) / 2;\\n        int prev = (mid + n - 1) % n;\\n        int next = (mid + 1) % n;\\n\\n        if (nums[mid] < nums[next] && nums[mid] < nums[prev])\\n            return nums[mid];\\n\\n        if (nums[mid] == nums[start] && nums[mid] == nums[end]) {\\n            start++;\\n            end--;\\n        } else if (nums[end] >= nums[mid]) { \\n            end = mid ;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n\\n    return nums[start];\\n}\\n\\n        \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961686,
                "title": "only-3-line-code-of-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    int n=nums.size(),s=0,e=n-1;\\n       while(s<e)\\n       {\\n        int  mid=s+(e-s)/2 ;\\n         if(nums[mid]>nums[e])  s=mid+1; \\n         else  if(nums[mid]<nums[e])  e=mid;\\n         else \\n         e--;\\n       }\\n       return nums[s];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    int n=nums.size(),s=0,e=n-1;\\n       while(s<e)\\n       {\\n        int  mid=s+(e-s)/2 ;\\n         if(nums[mid]>nums[e])  s=mid+1; \\n         else  if(nums[mid]<nums[e])  e=mid;\\n         else \\n         e--;\\n       }\\n       return nums[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934828,
                "title": "c-solution-easy-to-understand-o-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            int mid = (i+j)/2;\\n            if(nums[mid]==nums[i] && nums[mid]==nums[j] ){\\n                i++;\\n                j--;\\n            }\\n            else if(nums[mid] > nums[j]) i = mid+1;\\n            else j=mid;\\n        }\\n        return nums[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            int mid = (i+j)/2;\\n            if(nums[mid]==nums[i] && nums[mid]==nums[j] ){\\n                i++;\\n                j--;\\n            }\\n            else if(nums[mid] > nums[j]) i = mid+1;\\n            else j=mid;\\n        }\\n        return nums[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847111,
                "title": "striver-approach-0-log-n-0-1-clean-and-self-explaining-code-comment-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- sorted and search --> binary search \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- for a mid in the array their is always one part is sorted and one part is not sorted reference to mid .( beacuse if mid lie in the \\nrotated part of array then it is sorted for rotated part and not for non-rotated part and if it will not lie in the rotated portion then \\nvice -versa happen )\\n- for sorted part it will check minimum ( first element of the sorted portion ) element with the answer and switch to non-sorted part \\n|\\n|\\n- for duplicate case mean if (mid == low == high) then shrink the range  from low (low++) and high(high--) \\nbut before  that check is this duplicate your answer or not (check that element is minimum element of array or not ) \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# O(log(N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> arr ) {\\n     int n= arr.size();\\n int i = 0 , j = n-1; \\n\\n\\nint minima = arr[0]; //  answer variable \\n\\n//-----binary Search --------//\\nwhile( i<=j){\\n\\t int mid = (i+j)/2; \\n     \\nif( arr[i] == arr[mid] and arr[mid]== arr[j] ){\\n    minima = min(minima , arr[mid]); // checking is this my answer or not \\n      j--; \\n      i++;\\n      continue;\\n}\\n\\n\\n// ---left sorted -----------//\\t \\nif( arr[i] <= arr[mid]){\\n\\nminima = min(minima , arr[i]);\\ni= mid+1;\\n}\\n\\n//------------right sorted ----------//\\nelse {\\n\\tminima = min(minima , arr[mid]);\\n    j= mid-1; \\n}\\n}\\n\\nreturn minima ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> arr ) {\\n     int n= arr.size();\\n int i = 0 , j = n-1; \\n\\n\\nint minima = arr[0]; //  answer variable \\n\\n//-----binary Search --------//\\nwhile( i<=j){\\n\\t int mid = (i+j)/2; \\n     \\nif( arr[i] == arr[mid] and arr[mid]== arr[j] ){\\n    minima = min(minima , arr[mid]); // checking is this my answer or not \\n      j--; \\n      i++;\\n      continue;\\n}\\n\\n\\n// ---left sorted -----------//\\t \\nif( arr[i] <= arr[mid]){\\n\\nminima = min(minima , arr[i]);\\ni= mid+1;\\n}\\n\\n//------------right sorted ----------//\\nelse {\\n\\tminima = min(minima , arr[mid]);\\n    j= mid-1; \\n}\\n}\\n\\nreturn minima ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839770,
                "title": "minimum-rotated-array-ii-o-logn-javascript-runtime-95-45-meaningful-vars",
                "content": "Time Complexity: O(LogN)\\nSpace Complexity: O(1)\\n\\n```\\nvar findMin = function(nums) {\\n    if (nums.length === 1) {\\n        return nums[0];\\n    }\\n\\n    if (nums.length === 2) {\\n        if (nums[0] > nums[1]) {\\n            return nums[1];\\n        }\\n        return nums[0];\\n    }\\n\\n    const middleIndex = Math.floor(nums.length / 2);\\n    const middleNumber = nums[middleIndex];\\n    const lastNumber = nums[nums.length - 1];\\n\\n    if (middleNumber > lastNumber) {\\n        return findMin(nums.splice(middleIndex));\\n    } else {\\n        if (middleNumber === lastNumber) {\\n            return Math.min(findMin(nums.slice(middleIndex)), findMin(nums.slice(0, middleIndex)));\\n        }\\n        return findMin(nums.splice(0, middleIndex + 1));\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/b5ab1abd-aaa2-422d-9d48-6d56daabed5c_1690741001.9584672.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar findMin = function(nums) {\\n    if (nums.length === 1) {\\n        return nums[0];\\n    }\\n\\n    if (nums.length === 2) {\\n        if (nums[0] > nums[1]) {\\n            return nums[1];\\n        }\\n        return nums[0];\\n    }\\n\\n    const middleIndex = Math.floor(nums.length / 2);\\n    const middleNumber = nums[middleIndex];\\n    const lastNumber = nums[nums.length - 1];\\n\\n    if (middleNumber > lastNumber) {\\n        return findMin(nums.splice(middleIndex));\\n    } else {\\n        if (middleNumber === lastNumber) {\\n            return Math.min(findMin(nums.slice(middleIndex)), findMin(nums.slice(0, middleIndex)));\\n        }\\n        return findMin(nums.splice(0, middleIndex + 1));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839412,
                "title": "beats-93-48-beginner-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,high=n-1;\\n        int mini=INT_MAX;\\n        if(n==1)return nums[0];\\n        while(low<=high)\\n        {\\n            int mid=(low)+(high-low)/2;\\n            if(nums[low]==nums[mid] && nums[mid]==nums[high])\\n            {\\n                 mini=min(mini,nums[low]);\\n                low++;\\n                high--;\\n                continue;\\n            }\\n            if(nums[low]<=nums[mid])//Left is sorted\\n            {\\n                mini=min(mini,nums[low]);\\n                low=mid+1;\\n            }else{//right is sorted\\n                if(nums[mid]<=nums[high])\\n                {\\n                    mini=min(mini,nums[mid]);\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,high=n-1;\\n        int mini=INT_MAX;\\n        if(n==1)return nums[0];\\n        while(low<=high)\\n        {\\n            int mid=(low)+(high-low)/2;\\n            if(nums[low]==nums[mid] && nums[mid]==nums[high])\\n            {\\n                 mini=min(mini,nums[low]);\\n                low++;\\n                high--;\\n                continue;\\n            }\\n            if(nums[low]<=nums[mid])//Left is sorted\\n            {\\n                mini=min(mini,nums[low]);\\n                low=mid+1;\\n            }else{//right is sorted\\n                if(nums[mid]<=nums[high])\\n                {\\n                    mini=min(mini,nums[mid]);\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759259,
                "title": "binary-search-readable-code",
                "content": "\\u2B50\\uFE0F Answers are available for everyone, but those who learn it, make the difference \\u2B50\\uFE0F\\n\\n`If My Answer Helps You Please Upvote Otherwise Don\\'t !!!`\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply check using Binary search and eliminate that half part which is sorted \\n`(left->mid)` OR `(mid->high)` and check in another half in next process.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo Binary Search..\\n1) Consider there are all unique elements, then these conditions will be used :\\n```\\n            if(nums[low] < nums[high]){ // Already Full Length Sorted\\n                // No need to make it into two parts\\n                ans = min(ans, nums[low]); // Just take answer\\n                break; // get out of the process\\n            }\\n            if(nums[low]<=nums[mid]){ // left part sorted\\n                ans = min(ans, nums[low]); // take the minimum\\n                low = mid + 1; // move to right part\\n            }\\n            else{ // right part sorted\\n                ans = min(ans, nums[mid]); // take minimum\\n                high = mid - 1; // move to left part\\n            }\\n```\\n2) Now, this will work for duplicates also, but it will fail at one condition where, \\n`values at low, mid and at high, all are equal.`\\nfor that case we can simply just first do `ans = min(ans, nums[low])`\\nand after that just shift `low` and `high` by 1 index, ans repeat the process again:\\n```\\n            if(nums[low] == nums[high] && nums[high] == nums[mid]){\\n                ans = min(ans, nums[low]);\\n                low++;\\n                high--;\\n                continue;\\n            }\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n-1;\\n        int ans = INT_MAX;\\n        while(low<=high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[low] == nums[high] && nums[high] == nums[mid]){\\n                ans = min(ans, nums[low]);\\n                low++;\\n                high--;\\n                continue;\\n            }\\n            if(nums[low] < nums[high]){\\n                ans = min(ans, nums[low]);\\n                break;\\n            }\\n            if(nums[low]<=nums[mid]){\\n                ans = min(ans, nums[low]);\\n                low = mid + 1;\\n            }\\n            else{\\n                ans = min(ans, nums[mid]);\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n            if(nums[low] < nums[high]){ // Already Full Length Sorted\\n                // No need to make it into two parts\\n                ans = min(ans, nums[low]); // Just take answer\\n                break; // get out of the process\\n            }\\n            if(nums[low]<=nums[mid]){ // left part sorted\\n                ans = min(ans, nums[low]); // take the minimum\\n                low = mid + 1; // move to right part\\n            }\\n            else{ // right part sorted\\n                ans = min(ans, nums[mid]); // take minimum\\n                high = mid - 1; // move to left part\\n            }\\n```\n```\\n            if(nums[low] == nums[high] && nums[high] == nums[mid]){\\n                ans = min(ans, nums[low]);\\n                low++;\\n                high--;\\n                continue;\\n            }\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n-1;\\n        int ans = INT_MAX;\\n        while(low<=high){\\n            int mid = low + (high - low) / 2;\\n            if(nums[low] == nums[high] && nums[high] == nums[mid]){\\n                ans = min(ans, nums[low]);\\n                low++;\\n                high--;\\n                continue;\\n            }\\n            if(nums[low] < nums[high]){\\n                ans = min(ans, nums[low]);\\n                break;\\n            }\\n            if(nums[low]<=nums[mid]){\\n                ans = min(ans, nums[low]);\\n                low = mid + 1;\\n            }\\n            else{\\n                ans = min(ans, nums[mid]);\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700946,
                "title": "two-liner-easy-solution-java-solution",
                "content": "# Intuition\\neasy Solution in which First -- Sort the Array by using the `Arrays.sort()` and then Second -- return the minimum element that will on first 0 index. return that value. \\n\\n# Approach\\nSorting Approach \\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(log n)\\n\\nDo upvote Please \\xA9\\uD83D\\uDC4D\\uD83D\\uDE80\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668533,
                "title": "easy-c-o-log-n-beats-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nin this will do same like to find minimum in sorted arrary 1 just we have to manage duplicate by increasing index of low or decreasing index of high\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif we rotate an array and if its mid is greater than last element than its compulsory that the smaller element will be after mid point only , else before mid \\nand for duplicates will increase low while next element is same.also same for high\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: O(log n)  \\n- if all element same then O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n         int low = 0 ;\\n        int high = nums.size()-1;\\n        while (low < high){\\n            int mid = low + (high - low)/2;\\n            if (nums[mid] > nums[high]){\\n                low = mid + 1 ;\\n            }\\n            else if(nums[mid]<nums[high])\\n            high = mid ;\\n            else if(nums[high]==nums[high-1])\\n            high--;\\n            else\\n            low++;\\n        }\\n        return\\xA0nums[low];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n         int low = 0 ;\\n        int high = nums.size()-1;\\n        while (low < high){\\n            int mid = low + (high - low)/2;\\n            if (nums[mid] > nums[high]){\\n                low = mid + 1 ;\\n            }\\n            else if(nums[mid]<nums[high])\\n            high = mid ;\\n            else if(nums[high]==nums[high-1])\\n            high--;\\n            else\\n            low++;\\n        }\\n        return\\xA0nums[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519823,
                "title": "efficient-binary-search-approach-easy-to-understand-code",
                "content": "# Intuition\\nIn a sorted array, finding a value is a simple task thanks to binary search. However, in a rotated sorted array, the task becomes a bit more challenging. Additionally, the problem statement suggests that the array could include duplicates, adding yet another layer of complexity.\\n\\n# Approach\\nThis solution takes advantage of binary search, while handling the complications introduced by the rotation and the duplicates.\\n\\nThe binary search strategy here is slightly modified from the traditional method to handle the rotation. The rotation splits the sorted array into two sorted segments. If the middle element is greater than the last element, the minimum value must be in the second half of the array. If the middle element is less than the last element, the minimum value must be in the first half.\\n\\nDuplicates are dealt with by incrementing the start index and decrementing the end index whenever a duplicate is encountered. This way, even when the array is full of duplicates, we can efficiently reduce the search space.\\n\\n# Complexity\\n- Time complexity:\\nThe worst-case scenario is when all elements are duplicates, and in that case, the time complexity is O(n). However, if there are no duplicates or if duplicates are evenly distributed, this approach performs far better than a linear scan.\\n\\n- Space complexity:\\nThe space complexity is O(1) since only 3 integers are initalised to hold the positions\\n\\n# Code\\n```\\nclass Solution {\\n    public static int findMin(int[] nums) {\\n        int high = nums.length - 1;\\n        int low = 0;\\n        int mid = high / 2;\\n        while (low < high) {\\n            if (nums[mid] > nums[high]) {\\n                low = mid + 1;\\n                mid = low + (high - low) / 2;\\n            } else if (nums[mid] < nums[high]) {\\n                high = mid;\\n                mid = low + (high - low) / 2;\\n            } else {\\n                // Drop duplicates and try again\\n                if (nums[mid] == nums[high])\\n                    high--;\\n                if (nums[mid] == nums[low])\\n                    low++;\\n                mid = low + (high - low) / 2;\\n            }\\n        }\\n        return nums[mid];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int findMin(int[] nums) {\\n        int high = nums.length - 1;\\n        int low = 0;\\n        int mid = high / 2;\\n        while (low < high) {\\n            if (nums[mid] > nums[high]) {\\n                low = mid + 1;\\n                mid = low + (high - low) / 2;\\n            } else if (nums[mid] < nums[high]) {\\n                high = mid;\\n                mid = low + (high - low) / 2;\\n            } else {\\n                // Drop duplicates and try again\\n                if (nums[mid] == nums[high])\\n                    high--;\\n                if (nums[mid] == nums[low])\\n                    low++;\\n                mid = low + (high - low) / 2;\\n            }\\n        }\\n        return nums[mid];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490608,
                "title": "easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust plot a rough graph for a rotated sorted array using 2 lines and observe a test case like 2,2,2,0,1,1,1,1 \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is just a addition to the version 1 of this problem where we need to handle the case for duplicate elements so while returning the minimum element\\'s index we need to handle that case carefully based on the observation from the graph...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint f(vector<int>&a)\\n{\\n    int s=0;\\n    int e=a.size()-1;\\n\\n\\n    int mid=s+(e-s)/2;\\n\\n    while(s<e)\\n    {\\n        if(a[mid]>a[e])\\n        {\\n            s=mid+1;\\n        }\\n        else if(a[mid]==a[e])\\n        {\\n            e--;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n        mid=s+(e-s)/2;\\n    }\\n\\n    return e;\\n}\\n    int findMin(vector<int>& nums) {\\n        int minidx=f(nums);\\n\\n        return nums[minidx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint f(vector<int>&a)\\n{\\n    int s=0;\\n    int e=a.size()-1;\\n\\n\\n    int mid=s+(e-s)/2;\\n\\n    while(s<e)\\n    {\\n        if(a[mid]>a[e])\\n        {\\n            s=mid+1;\\n        }\\n        else if(a[mid]==a[e])\\n        {\\n            e--;\\n        }\\n        else\\n        {\\n            e=mid;\\n        }\\n        mid=s+(e-s)/2;\\n    }\\n\\n    return e;\\n}\\n    int findMin(vector<int>& nums) {\\n        int minidx=f(nums);\\n\\n        return nums[minidx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410082,
                "title": "very-easy-java-solution-beats-100-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int s=0;\\n        int e=nums.length-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n           \\n            if(nums[m]>nums[e]){\\n                s=m+1;\\n            }\\n            else if(nums[e]<nums[s]){\\n                e=m;\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n    \\n\\n```\\nUpvote if you like it \\uD83D\\uDE0A\\n\\u2B06\\uFE0F\\n\\u2B06\\uFE0F",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int s=0;\\n        int e=nums.length-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n           \\n            if(nums[m]>nums[e]){\\n                s=m+1;\\n            }\\n            else if(nums[e]<nums[s]){\\n                e=m;\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362790,
                "title": "java-code-o-log-n-m-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn+m) m for inside while loop\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int low = 0, high = nums.length - 1;\\n        int mid = 0;\\n        int value = Integer.MAX_VALUE;\\n        while(low <= high) {\\n            mid = low + (high - low) / 2;\\n            value = Math.min(value, nums[mid]);\\n\\n            if (nums[low] >= nums[mid] && nums[mid] > nums[high])\\n                low = mid + 1;\\n            else if (nums[low] < nums[mid] && nums[mid] <= nums[high]) \\n                high = mid - 1;\\n            else if (nums[low] <= nums[mid] && nums[mid] > nums[high]) \\n                low = mid + 1;\\n            else {\\n                int left = mid - 1, right = mid + 1;\\n                while (left >= 0 && right < nums.length && nums[left] == nums[right]) {\\n                    left--;\\n                    right++;\\n                }\\n                if (left >= 0 && right < nums.length && nums[left] < nums[right])\\n                    high = mid - 1;\\n                else \\n                    low = mid + 1;\\n            }      \\n        }\\n        return value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int low = 0, high = nums.length - 1;\\n        int mid = 0;\\n        int value = Integer.MAX_VALUE;\\n        while(low <= high) {\\n            mid = low + (high - low) / 2;\\n            value = Math.min(value, nums[mid]);\\n\\n            if (nums[low] >= nums[mid] && nums[mid] > nums[high])\\n                low = mid + 1;\\n            else if (nums[low] < nums[mid] && nums[mid] <= nums[high]) \\n                high = mid - 1;\\n            else if (nums[low] <= nums[mid] && nums[mid] > nums[high]) \\n                low = mid + 1;\\n            else {\\n                int left = mid - 1, right = mid + 1;\\n                while (left >= 0 && right < nums.length && nums[left] == nums[right]) {\\n                    left--;\\n                    right++;\\n                }\\n                if (left >= 0 && right < nums.length && nums[left] < nums[right])\\n                    high = mid - 1;\\n                else \\n                    low = mid + 1;\\n            }      \\n        }\\n        return value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300321,
                "title": "minimum-in-a-rotated-sorted-array-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n    int n=nums.size();\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start<end)\\n    {\\n        int mid=start+(end-start)/2;\\n        if(nums[mid]>nums[end])\\n            start=mid+1;\\n        else if(nums[mid]<nums[end])\\n            end=mid;\\n        else\\n            end--;\\n    }\\n    return nums[start];\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n    int n=nums.size();\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start<end)\\n    {\\n        int mid=start+(end-start)/2;\\n        if(nums[mid]>nums[end])\\n            start=mid+1;\\n        else if(nums[mid]<nums[end])\\n            end=mid;\\n        else\\n            end--;\\n    }\\n    return nums[start];\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295238,
                "title": "beats-100-in-o-n-time-o-1-space",
                "content": "# Intuition\\nYaha pe hmm 2 pointer approach ka use karenge pivot find karne ke liye and wahi mera answer hoga.\\n\\nPivot:Jaha se mera array ka order change hoga ussi ko pivot element bolte hai.\\n\\n# Approach\\nsabse pehle hmm ek answer variable lenge jisme me hmm array ka first element store karadenge ye issliye karenge suppose ki mera array rotated hi nhi hua then mere answer jo hoga wo array ka first element hoga obvious si baat hai ab aage dekte hai kaise karenge.\\n\\n1.hmm start variable lenge jisme hmm array ka first index assign kar denge.\\n2.Hmm ek end variable lenge jisme hmm array ka last index store kara denge.\\nand now hmm while loop chalaenge jab tak mera s jo hai ese bada nhi hojata.\\n3.agar mera nums[start] mera nums[end] se bada hai then mera pivot left me hoga but hmm ye bhi check karenge kahi mera nums[e] jo hai wo kahi pivot tho nhi hai that why hmm check karte hai ki nums[e]<nums[e-1] it means e pe order change ho rha hai that why we return nums[e]\\nbecause iske pehle and baad me sab maximum hai.\\n\\nagar s>e hojaega then mujhe pivot nhi mila matlab rotation nhi hua hai\\n\\nso for this in last we return ans because hmme pivot nhi mila maatlab rotation nhi hua matlab minimum number nums[0] hoga jo ki ans me store hai.\\n\\nUsing the above approach you can find in O(n) time. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        int ans=nums[0];\\n        while(s<=e){\\n            if(nums[s]>=nums[e]){\\n                if(e-1>=0 && nums[e]<nums[e-1])\\n                    return nums[e];\\n                e--;\\n            }\\n            else\\n            s++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        int ans=nums[0];\\n        while(s<=e){\\n            if(nums[s]>=nums[e]){\\n                if(e-1>=0 && nums[e]<nums[e-1])\\n                    return nums[e];\\n                e--;\\n            }\\n            else\\n            s++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293342,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n    int n=nums.size();\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start<end)\\n    {\\n        int mid=start+(end-start)/2;\\n        if(nums[mid]>nums[end])\\n            start=mid+1;\\n        else if(nums[mid]<nums[end])\\n            end=mid;\\n        else\\n            end--;\\n    }\\n    return nums[start];\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n    int n=nums.size();\\n    int start=0;\\n    int end=nums.size()-1;\\n    while(start<end)\\n    {\\n        int mid=start+(end-start)/2;\\n        if(nums[mid]>nums[end])\\n            start=mid+1;\\n        else if(nums[mid]<nums[end])\\n            end=mid;\\n        else\\n            end--;\\n    }\\n    return nums[start];\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105137,
                "title": "not-a-binary-search-but-beats-90-in-run-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int id=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(i+1==nums.size()){\\n                if(nums[i]>nums[0])\\n                    id=0;\\n                    break;\\n            }\\n            else if(nums[i]>nums[i+1]){\\n                id=i+1;\\n                break;\\n            }\\n        }\\n        return nums[id];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int id=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(i+1==nums.size()){\\n                if(nums[i]>nums[0])\\n                    id=0;\\n                    break;\\n            }\\n            else if(nums[i]>nums[i+1]){\\n                id=i+1;\\n                break;\\n            }\\n        }\\n        return nums[id];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875733,
                "title": "80-faster-easy-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int i = 0, j = nums.size()-1,mid;\\n        while(i<j){\\n            mid = ((j-i)>>1)+i;\\n            if(nums[mid]>nums[j]){\\n                i = mid+1;\\n            }else{\\n                j--;\\n            }\\n        }\\n        return nums[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int i = 0, j = nums.size()-1,mid;\\n        while(i<j){\\n            mid = ((j-i)>>1)+i;\\n            if(nums[mid]>nums[j]){\\n                i = mid+1;\\n            }else{\\n                j--;\\n            }\\n        }\\n        return nums[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713999,
                "title": "easyest-solution",
                "content": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            if(nums[i]<nums[i-1]):\\n                return nums[i]\\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            if(nums[i]<nums[i-1]):\\n                return nums[i]\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668876,
                "title": "binary-search-revised-question-easy-solution",
                "content": "**AN UPVOTE WILL BE HIGHLY APPRECIATED**\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& a){\\n    int n=a.size();\\n    int l=0,h=n-1,res=INT_MAX;\\n    while(l<=h){\\n        int mid=(l+h)/2;\\n        if(a[l]==a[h]){\\n            res=min(res,a[l]);\\n            l++;\\n            h--;\\n        }\\n        else if(a[l]<=a[mid]){\\n            if(a[mid]==a[l]){\\n                res=min(res,a[mid]);\\n                l=mid+1;\\n            }\\n            else{\\n                res=min(res,a[l]);\\n                l=mid+1;\\n            }\\n        }\\n        else{\\n            res=min(res,a[mid]);\\n            h=mid-1;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& a){\\n    int n=a.size();\\n    int l=0,h=n-1,res=INT_MAX;\\n    while(l<=h){\\n        int mid=(l+h)/2;\\n        if(a[l]==a[h]){\\n            res=min(res,a[l]);\\n            l++;\\n            h--;\\n        }\\n        else if(a[l]<=a[mid]){\\n            if(a[mid]==a[l]){\\n                res=min(res,a[mid]);\\n                l=mid+1;\\n            }\\n            else{\\n                res=min(res,a[l]);\\n                l=mid+1;\\n            }\\n        }\\n        else{\\n            res=min(res,a[mid]);\\n            h=mid-1;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603525,
                "title": "easy-c-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l=0, h=nums.size()-1;\\n        while(l<h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]<nums[h]) h=m;\\n            else if(nums[m]>nums[h]) l=m+1;\\n            else --h;\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l=0, h=nums.size()-1;\\n        while(l<h){\\n            int m = l + (h-l)/2;\\n            if(nums[m]<nums[h]) h=m;\\n            else if(nums[m]>nums[h]) l=m+1;\\n            else --h;\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526279,
                "title": "c-solution-using-binary-search",
                "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        if(nums[0]<nums[nums.size()-1])\\n            return nums[0];\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[e])\\n                s= mid+1;\\n                else if(nums[mid]<nums[s])\\n                    e=mid;\\n            else\\n                e--;\\n        }\\n        return nums[s];\\n    }\\n};\\n\\n\\n Explanation:-\\n*  if nums[0] is lesser than nums[nums.size()-1] then return nums[0];\\n*  if nums[mid] is greater than nums[e] then s=mid+1 .\\n*  else if nums[mid] is lesser than nums[s] then e=mid;\\n*  else any other condition will happen then e=e-1;\\n*  when whole while loop exceute then return nums[s];\\n\\nTime Complexity: O(logn)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        if(nums[0]<nums[nums.size()-1])\\n            return nums[0];\\n        int s=0;\\n        int e=nums.size()-1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]>nums[e])\\n                s= mid+1;\\n                else if(nums[mid]<nums[s])\\n                    e=mid;\\n            else\\n                e--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2218677,
                "title": "two-pointer-binary-search-multiple-solutions",
                "content": "class Solution {\\npublic:\\n\\nDo upvote If you like it.\\n    \\n\\t\\n\\tint findMin(vector<int>& nums) {\\n        \\n\\t\\t//TWO POINTER APPROACH  TIME COMPLEXITY :- O(N/2)\\n\\t\\t\\n\\t\\tint res = INT_MAX;\\n        int start = 0, end = nums.size()-1;\\n        while(start <= end)\\n        {\\n            res = min(res, min(nums[start], nums[end]));\\n            start++;\\n            end--;\\n        }\\n        return  res;\\n        \\n        \\n\\t\\t//BINARY SEARCH APPROACH  TIME COMPLEXITY :- O(logn)\\n\\t\\t\\n        int start = 0 , end = nums.size()-1;\\n        while(start <= end)\\n        {\\n            int mid = start+(end-start)/2;\\n            if(nums[mid] > nums[end])\\n            {\\n                start = mid+1;\\n            }\\n            else \\n            {\\n                if(nums[mid] == nums[end])\\n                {\\n                    end--;\\n                }\\n                else\\n                {\\n                    end = mid;\\n                }\\n            }\\n        }\\n        return nums[start];\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\nDo upvote If you like it.\\n    \\n\\t\\n\\tint findMin(vector<int>& nums) {\\n        \\n\\t\\t//TWO POINTER APPROACH  TIME COMPLEXITY :- O(N/2)\\n\\t\\t\\n\\t\\tint res = INT_MAX;\\n        int start = 0, end = nums.size()-1;\\n        while(start <= end)\\n        {\\n            res = min(res, min(nums[start], nums[end]));\\n            start++;\\n            end--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2087295,
                "title": "binary-search-explained-python",
                "content": "```\\nclass Solution:\\n    def findMin(self, a: List[int]) -> int:\\n        \\n        def solve(l,h):\\n            while l<h:\\n                m=(l+h)//2\\n                \\n                if a[m]<a[m-1]:\\n                    return a[m]\\n                \\n                elif a[m]>a[h-1]:\\n                    l=m+1\\n                \\n                elif a[m]<a[h-1]:\\n                    h=m\\n                \\n                else:\\n                \\n                    if len(set(a[l:m+1]))==1:\\n                        return min(a[m],solve(m+1,h))\\n                    \\n                    else:\\n                        return min(a[m],solve(l,m))\\n            \\n            return a[min(l,len(a)-1)]\\n        \\n        return solve(0,len(a))\\n```\\n\\n![image](https://assets.leetcode.com/users/images/24716cdd-0859-4feb-a348-cf171927133b_1653742669.1068199.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, a: List[int]) -> int:\\n        \\n        def solve(l,h):\\n            while l<h:\\n                m=(l+h)//2\\n                \\n                if a[m]<a[m-1]:\\n                    return a[m]\\n                \\n                elif a[m]>a[h-1]:\\n                    l=m+1\\n                \\n                elif a[m]<a[h-1]:\\n                    h=m\\n                \\n                else:\\n                \\n                    if len(set(a[l:m+1]))==1:\\n                        return min(a[m],solve(m+1,h))\\n                    \\n                    else:\\n                        return min(a[m],solve(l,m))\\n            \\n            return a[min(l,len(a)-1)]\\n        \\n        return solve(0,len(a))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963139,
                "title": "c-o-logn-binary-search-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n == 1 || nums[0] < nums[n-1]){\\n            return nums[0];\\n        }\\n\\n        int s = 0;\\n        int e = n-1;\\n        int mid = s + ((e-s)/2);\\n\\n        while(s < e){\\n            \\n            if(nums[mid] == nums[s] && nums[mid] == nums[e]){\\n                s++;\\n                e--;\\n            }\\n            else if(nums[mid] > nums[e]){\\n                s = mid+1;\\n            }\\n            else if(nums[mid] <= nums[e]){\\n                e = mid;\\n            }\\n\\n            mid = s + ((e-s)/2);\\n        }\\n\\n        return nums[s];\\n    }\\n\\t\\n\\tif(Like_the_solution){\\n\\t\\thit_up_vote;\\n\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n == 1 || nums[0] < nums[n-1]){\\n            return nums[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1910872,
                "title": "c-solution-with-o-1-time-complexity-o-1",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int findMin(vector<int>& nums) \\n    {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        int min =*min_element(nums.begin(),nums.end()); \\n        return min ;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893695,
                "title": "find-minimum-in-rotated-sorted-array-ii-solution-java",
                "content": "class Solution {\\n  public int findMin(int[] nums) {\\n    int l = 0;\\n    int r = nums.length - 1;\\n\\n    while (l < r) {\\n      final int m = l + (r - l) / 2;\\n      if (nums[m] == nums[r])\\n        --r;\\n      else if (nums[m] < nums[r])\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return nums[l];\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n  public int findMin(int[] nums) {\\n    int l = 0;\\n    int r = nums.length - 1;\\n\\n    while (l < r) {\\n      final int m = l + (r - l) / 2;\\n      if (nums[m] == nums[r])\\n        --r;\\n      else if (nums[m] < nums[r])\\n        r = m;\\n      else\\n        l = m + 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1839712,
                "title": "c-clean-easy-binary-search",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findMin(vector<int>& nums) {\\n\\t\\t\\tint high = nums.size()-1,low = 0;\\n\\t\\t\\twhile(low<high){\\n\\t\\t\\t\\tint mid = low+(high-low)/2;\\n\\t\\t\\t\\tif(nums[high]==nums[mid])\\n\\t\\t\\t\\t\\thigh=high-1;\\n\\t\\t\\t\\telse if(nums[high]>nums[mid])\\n\\t\\t\\t\\t\\thigh=mid;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlow=mid+1;\\n\\t\\t\\t}\\n\\t\\t\\treturn nums[low];\\n\\t\\t}\\n\\t};\\n\\t\\n\\tTC = O(N)\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findMin(vector<int>& nums) {\\n\\t\\t\\tint high = nums.size()-1,low = 0;\\n\\t\\t\\twhile(low<high){\\n\\t\\t\\t\\tint mid = low+(high-low)/2;\\n\\t\\t\\t\\tif(nums[high]==nums[mid])\\n\\t\\t\\t\\t\\thigh=high-1;\\n\\t\\t\\t\\telse if(nums[high]>nums[mid])\\n\\t\\t\\t\\t\\thigh=mid;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlow=mid+1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1779729,
                "title": "100-faster-soolution-with-peak-element",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int peak = peak(nums);\\n        if(peak == -1 || peak == nums.length-1){\\n            return nums[0];\\n        }\\n        else return nums[peak+1];\\n    }\\n    \\n    public int peak(int[] arr){\\n        int s=0,e=arr.length-1;\\n        while(s<e){\\n            int m = s+(e-s)/2;\\n            if(m<e && arr[m]>arr[m+1] ){\\n                return m;\\n            }\\n            else if(m>s && arr[m]<arr[m-1]){\\n                return m-1;\\n            }\\n            else if(arr[m] == arr[s] && arr[m] == arr[e]){\\n                if(s<e && arr[s]>arr[s+1]){\\n                    return s;\\n                }\\n                s++;\\n                 if(e>s && arr[e]< arr[e-1]){\\n                    return e;\\n                }\\n                e--;\\n            }\\n            else if(arr[s]<arr[m] || arr[m]==arr[s] && arr[m]>arr[e]){\\n                s = m+1;\\n            }\\n            else e = m-1;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```\\n\\nUpvote will be appriciated",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int peak = peak(nums);\\n        if(peak == -1 || peak == nums.length-1){\\n            return nums[0];\\n        }\\n        else return nums[peak+1];\\n    }\\n    \\n    public int peak(int[] arr){\\n        int s=0,e=arr.length-1;\\n        while(s<e){\\n            int m = s+(e-s)/2;\\n            if(m<e && arr[m]>arr[m+1] ){\\n                return m;\\n            }\\n            else if(m>s && arr[m]<arr[m-1]){\\n                return m-1;\\n            }\\n            else if(arr[m] == arr[s] && arr[m] == arr[e]){\\n                if(s<e && arr[s]>arr[s+1]){\\n                    return s;\\n                }\\n                s++;\\n                 if(e>s && arr[e]< arr[e-1]){\\n                    return e;\\n                }\\n                e--;\\n            }\\n            else if(arr[s]<arr[m] || arr[m]==arr[s] && arr[m]>arr[e]){\\n                s = m+1;\\n            }\\n            else e = m-1;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777381,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\n     public int findMin(int[] nums) {\\n        \\n        if(nums[0] < nums[nums.length-1] || nums.length == 1)\\n            return nums[0];\\n        \\n        int idx = findMaxIdx(nums, 0, nums.length-1, nums.length);\\n        \\n        if(idx == -1) // Means all the elements in the array is similar.\\n            return nums[0];\\n         \\n        return nums[idx];\\n    }\\n    \\n    public int findMaxIdx(int nums[], int l, int r, int n)\\n    {\\n        if(l > r)\\n            return -1;\\n        \\n        int m = l+(r-l)/2;\\n        if(m+1 < n)\\n        {\\n            if(nums[m+1] < nums[m])\\n                return m+1;\\n        }\\n        \\n        int idx = findMaxIdx(nums, l, m-1, n);\\n        if(idx != -1)\\n            return idx;\\n        idx = findMaxIdx(nums, m+1, r, n);\\n            \\n        return idx;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int findMin(int[] nums) {\\n        \\n        if(nums[0] < nums[nums.length-1] || nums.length == 1)\\n            return nums[0];\\n        \\n        int idx = findMaxIdx(nums, 0, nums.length-1, nums.length);\\n        \\n        if(idx == -1) // Means all the elements in the array is similar.\\n            return nums[0];\\n         \\n        return nums[idx];\\n    }\\n    \\n    public int findMaxIdx(int nums[], int l, int r, int n)\\n    {\\n        if(l > r)\\n            return -1;\\n        \\n        int m = l+(r-l)/2;\\n        if(m+1 < n)\\n        {\\n            if(nums[m+1] < nums[m])\\n                return m+1;\\n        }\\n        \\n        int idx = findMaxIdx(nums, l, m-1, n);\\n        if(idx != -1)\\n            return idx;\\n        idx = findMaxIdx(nums, m+1, r, n);\\n            \\n        return idx;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775469,
                "title": "c-0ms-solution-binary-search-with-slight-modification",
                "content": "**Note : In some cases the time complexity is not O(logn)**\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size(),l=0,r=n-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(nums[m]>nums[r]) l=m+1;\\n            else if(nums[r]==nums[m]) r--;\\n            else r=m;\\n        }\\n        return nums[l];\\n    }\\n};\\n```\\n\\n**Please upvote :)**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size(),l=0,r=n-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(nums[m]>nums[r]) l=m+1;\\n            else if(nums[r]==nums[m]) r--;\\n            else r=m;\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751279,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(logN)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nint findMin(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        while(low < high)\\n        {\\n            int mid = (low + high) >> 1;\\n            \\n            if(arr[mid] == arr[low] && arr[mid] == arr[high])\\n            {\\n                low++;\\n                \\n                high--;\\n            }\\n            \\n            else if(arr[mid] > arr[high])\\n            {\\n                low = mid + 1;\\n            }\\n            \\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n        \\n        return arr[low];\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nint findMin(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        while(low < high)\\n        {\\n            int mid = (low + high) >> 1;\\n            \\n            if(arr[mid] == arr[low] && arr[mid] == arr[high])\\n            {\\n                low++;\\n                \\n                high--;\\n            }\\n            \\n            else if(arr[mid] > arr[high])\\n            {\\n                low = mid + 1;\\n            }\\n            \\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n        \\n        return arr[low];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676465,
                "title": "python-solution-in-log-n-time-complexity-using-binary-search",
                "content": "Please upvote if you find it helpful thanks.\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        ans=5000\\n        start=0\\n        end=len(nums)-1\\n        if nums[0]<nums[end] or end==0:\\n            return nums[0]\\n        while start<=end:\\n            mid=(start+end)//2\\n            if mid>0 and mid<len(nums)-1:\\n                if nums[mid]<nums[mid+1] and nums[mid]<nums[mid-1]:\\n                    return nums[mid]\\n            ans=min(nums[mid],ans)\\n            if nums[start]==nums[end] and nums[start]==nums[mid]:\\n                start+=1\\n                end-=1\\n                continue\\n            if nums[end]<nums[mid]:\\n                start=mid+1\\n            else:\\n                end=mid-1\\n            \\n         return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        ans=5000\\n        start=0\\n        end=len(nums)-1\\n        if nums[0]<nums[end] or end==0:\\n            return nums[0]\\n        while start<=end:\\n            mid=(start+end)//2\\n            if mid>0 and mid<len(nums)-1:\\n                if nums[mid]<nums[mid+1] and nums[mid]<nums[mid-1]:\\n                    return nums[mid]\\n            ans=min(nums[mid],ans)\\n            if nums[start]==nums[end] and nums[start]==nums[mid]:\\n                start+=1\\n                end-=1\\n                continue\\n            if nums[end]<nums[mid]:\\n                start=mid+1\\n            else:\\n                end=mid-1\\n            \\n         return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545147,
                "title": "python-97-faster-simple-solution",
                "content": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, mid, high = 0,0, len(nums)-1\\n        while low<high:\\n            mid = low+(high-low)//2\\n            if nums[mid]>nums[high]: low = mid+1\\n            elif nums[mid]< nums[high]: high = mid\\n            else: high -=1\\n        return nums[low]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, mid, high = 0,0, len(nums)-1\\n        while low<high:\\n            mid = low+(high-low)//2\\n            if nums[mid]>nums[high]: low = mid+1\\n            elif nums[mid]< nums[high]: high = mid\\n            else: high -=1\\n        return nums[low]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536329,
                "title": "c-easy-binary-search",
                "content": "```\\npublic class Solution \\n{\\n    public int FindMin(int[] nums) \\n    {\\n        int low = 0, high = nums.Length - 1;\\n        \\n        while (low + 1 < high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] > nums[high])\\n            {\\n                low = mid;\\n            }\\n            else if (nums[mid] < nums[high])\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                high -= 1;\\n            }\\n        }\\n        \\n        return Math.Min(nums[low], nums[high]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int FindMin(int[] nums) \\n    {\\n        int low = 0, high = nums.Length - 1;\\n        \\n        while (low + 1 < high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] > nums[high])\\n            {\\n                low = mid;\\n            }\\n            else if (nums[mid] < nums[high])\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                high -= 1;\\n            }\\n        }\\n        \\n        return Math.Min(nums[low], nums[high]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536307,
                "title": "python-binary-search-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        \\n        # Array has only one element\\n        if start == end:\\n            return nums[start]\\n        \\n        # If rotation leads to completely sorted array and all values aren\\'t same.\\n        if nums[end] > nums[start]:\\n            return nums[start]\\n\\n        # Now array is definitely rotated or has all values same.\\n        while start <= end:\\n            mid = start + ((end- start) // 2)\\n            \\n            # If the next value is lower than the previous value then next value will definitely be the minimum as the array is sorted.\\n            if mid > start and nums[mid - 1] > nums[mid]:\\n                return nums[mid]\\n            \\n            # If the next value is lower than the previous value then next value will definitely be the minimum as the array is sorted.\\n            if mid < end and nums[mid] > nums[mid + 1]:\\n                return nums[mid+1]\\n            \\n            # If values at start and end are equal, skip duplicates if possible\\n            if nums[start] == nums[end]:\\n                # Check if value at start+1 isn\\'t the minimum.\\n                if nums[start] > nums[start+1]:\\n                    return nums[start+1]\\n                start += 1\\n                \\n                # Check if value at end isn\\'t the minimum.\\n                if nums[end] < nums[end-1]:\\n                    return nums[end]\\n                end -= 1\\n            else:            \\n                # Since we have ensured that the array is rotated so if middle value is greater than the value at start of array then the minimum element will definitely be at right side of middle value ELSE on left side.\\n                if nums[mid] >= nums[start]:\\n                    start = mid + 1\\n                else:\\n                    end = mid\\n\\n        # All values are same\\n        return nums[start]\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        \\n        # Array has only one element\\n        if start == end:\\n            return nums[start]\\n        \\n        # If rotation leads to completely sorted array and all values aren\\'t same.\\n        if nums[end] > nums[start]:\\n            return nums[start]\\n\\n        # Now array is definitely rotated or has all values same.\\n        while start <= end:\\n            mid = start + ((end- start) // 2)\\n            \\n            # If the next value is lower than the previous value then next value will definitely be the minimum as the array is sorted.\\n            if mid > start and nums[mid - 1] > nums[mid]:\\n                return nums[mid]\\n            \\n            # If the next value is lower than the previous value then next value will definitely be the minimum as the array is sorted.\\n            if mid < end and nums[mid] > nums[mid + 1]:\\n                return nums[mid+1]\\n            \\n            # If values at start and end are equal, skip duplicates if possible\\n            if nums[start] == nums[end]:\\n                # Check if value at start+1 isn\\'t the minimum.\\n                if nums[start] > nums[start+1]:\\n                    return nums[start+1]\\n                start += 1\\n                \\n                # Check if value at end isn\\'t the minimum.\\n                if nums[end] < nums[end-1]:\\n                    return nums[end]\\n                end -= 1\\n            else:            \\n                # Since we have ensured that the array is rotated so if middle value is greater than the value at start of array then the minimum element will definitely be at right side of middle value ELSE on left side.\\n                if nums[mid] >= nums[start]:\\n                    start = mid + 1\\n                else:\\n                    end = mid\\n\\n        # All values are same\\n        return nums[start]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535972,
                "title": "5-lines-100-binary-search",
                "content": "```\\npublic class Solution {\\n  public int findMin(int[] nums) {\\n    return binarySearch(nums, 0 , nums.length - 1);\\n  }\\n\\n  int binarySearch(int[] nums, int l, int h) {\\n    while(l < h) {\\n      int mid = (l + h) / 2;\\n      if(nums[mid] < nums[h]) h = mid;\\n      else if(nums[mid] > nums[h]) l = mid + 1;\\n      else h--;\\n    }\\n    return nums[l];\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n  public int findMin(int[] nums) {\\n    return binarySearch(nums, 0 , nums.length - 1);\\n  }\\n\\n  int binarySearch(int[] nums, int l, int h) {\\n    while(l < h) {\\n      int mid = (l + h) / 2;\\n      if(nums[mid] < nums[h]) h = mid;\\n      else if(nums[mid] > nums[h]) l = mid + 1;\\n      else h--;\\n    }\\n    return nums[l];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535625,
                "title": "brute-force-approach-o-n-optimal-soln-o-logn-easy-solution",
                "content": "**1. Brute force Approach O(n)**\\n```\\nint findMin(vector<int>& nums) {\\n        int minele=INT_MAX;\\n        \\n        for(int i=0; i< nums.size(); i++)\\n        {\\n            if(nums[i]< minele)\\n                minele=nums[i];\\n        }\\n        return minele;\\n    }\\n```\\n**2. Optimal Binary Search Approach O(logn)**\\n```\\nint findMin(vector<int>& nums) {\\n         int start=0,end=nums.size()-1;\\n         while(start<end){\\n             int mid=(start+end)/2; \\n             if(nums[mid]<nums[end])\\n                 end=mid;                \\n             else if(nums[mid]>nums[end])\\n                 start=mid+1;         \\n             else\\n                 end--;                \\n         }\\n         return nums[end];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findMin(vector<int>& nums) {\\n        int minele=INT_MAX;\\n        \\n        for(int i=0; i< nums.size(); i++)\\n        {\\n            if(nums[i]< minele)\\n                minele=nums[i];\\n        }\\n        return minele;\\n    }\\n```\n```\\nint findMin(vector<int>& nums) {\\n         int start=0,end=nums.size()-1;\\n         while(start<end){\\n             int mid=(start+end)/2; \\n             if(nums[mid]<nums[end])\\n                 end=mid;                \\n             else if(nums[mid]>nums[end])\\n                 start=mid+1;         \\n             else\\n                 end--;                \\n         }\\n         return nums[end];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1521241,
                "title": "java-detailed-explanation-binary-search",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int findMin(int[] nums) {\\n     \\n        //Given: Ascending order + repeated values\\n        // As it is sorted, intutively we will go with binary search\\n\\n        //First step, is to find the pivot element\\n        int pivot = pivot_func(nums);\\n        \\n        //As pivot element is the largest number in the array, \\n        //we can easily say that number next to pivot will be the minimum element.\\n        \\n        return nums[pivot+1];\\n    }\\n\\n    public int pivot_func(int[] nums)\\n    {\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n        while(start<=end)\\n        {\\n            int mid = start + (end-start)/2;\\n\\n            //For case like : [...7 0 ...]\\n            //Mid: 7\\n            if(mid<end && nums[mid] > nums[mid+1])\\n            {\\n                return mid;\\n            }\\n\\n            //For case like : [...7 0 ...]\\n            //Mid: 0            \\n            if(mid>start && nums[mid] < nums[mid-1])\\n            {\\n                return mid-1;\\n            }\\n\\n            //For case like: [2 3 4 5 2 2 2]\\n            //Start: 2, Mid: 2, End: 2\\n            if(nums[mid] == nums[start] && nums[mid] == nums[end])\\n            {\\n                //We can now skip start and end as they are just duplicates\\n                //But first we will check if start/ end is pivot or not\\n\\n                if(mid<end && nums[start] > nums[start+1])\\n                {\\n                    return start;\\n                }\\n\\n                if(mid>start && nums[end] < nums[end-1])\\n                {\\n                    return end-1;\\n                }\\n\\n                start++;\\n                end--;\\n            }\\n\\n            //Now, for binary search we must divide the array into halves for searching\\n\\n            else if(nums[start] < nums[mid] || nums[start] == nums[mid] && nums[mid] > nums[end])\\n            {\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n        \\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int findMin(int[] nums) {\\n     \\n        //Given: Ascending order + repeated values\\n        // As it is sorted, intutively we will go with binary search\\n\\n        //First step, is to find the pivot element\\n        int pivot = pivot_func(nums);\\n        \\n        //As pivot element is the largest number in the array, \\n        //we can easily say that number next to pivot will be the minimum element.\\n        \\n        return nums[pivot+1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1435099,
                "title": "javascript-binary-search-variation-on-third-template-easy-understanding-solution",
                "content": "```\\nvar findMin = function(nums) {\\n  // this is variation of template 3\\n  // https://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n  // We start at negative \\'lo\\', and setting \\'hi\\' to the last element of the array\\n  // We assign lo to a new value when we know it is _not_ a possible solution\\n  let lo = -1, hi = nums.length - 1;\\n  \\n  // according to this while condition, at the end of the loop, \\'lo\\' and \\'hi\\' pointers\\n  // will be adjacent to each other. \\'lo\\' will continue to point to the negative condition\\n  // and hi will point to the best candidate found at each iteration\\n  while (lo + 1 < hi) {\\n    let mid = lo + Math.floor((hi-lo)/2);\\n   \\n   // nums[mid] is lower than the best candidate we found, so we update the best\\n   // candidate stored in \\'hi\\' to point to the new value.\\n   if(nums[mid] < nums[hi]) {\\n      hi = mid;\\n\\t\\n\\t  // if the number is higher than the best candidate (\\'hi\\' pointer), so this is not our\\n\\t  // answer. We further decrease the search space by bringing \\'lo\\' closer to the estimate\\n\\t  // but we know that \\'lo\\' is not the answer\\n    } else if (nums[mid] > nums[hi]) {\\n      lo = mid\\n\\t  \\n\\t  // this is where it differs from the standard template of binary search\\n\\t  // and this is also the crux of this algorithm. Both the numbers are equal, the probable\\n\\t  // candidate (pointed by \\'mid\\') and the best candidate (\\'hi\\'). To further decrease the\\n\\t  // search space, we decrease the value of \\'hi\\' pointer by 1.\\n    } else {\\n      hi = hi - 1;\\n    }\\n  }\\n  // At the end of the loop, \\'hi\\' points at our answer\\n  return nums[hi];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nvar findMin = function(nums) {\\n  // this is variation of template 3\\n  // https://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n  // We start at negative \\'lo\\', and setting \\'hi\\' to the last element of the array\\n  // We assign lo to a new value when we know it is _not_ a possible solution\\n  let lo = -1, hi = nums.length - 1;\\n  \\n  // according to this while condition, at the end of the loop, \\'lo\\' and \\'hi\\' pointers\\n  // will be adjacent to each other. \\'lo\\' will continue to point to the negative condition\\n  // and hi will point to the best candidate found at each iteration\\n  while (lo + 1 < hi) {\\n    let mid = lo + Math.floor((hi-lo)/2);\\n   \\n   // nums[mid] is lower than the best candidate we found, so we update the best\\n   // candidate stored in \\'hi\\' to point to the new value.\\n   if(nums[mid] < nums[hi]) {\\n      hi = mid;\\n\\t\\n\\t  // if the number is higher than the best candidate (\\'hi\\' pointer), so this is not our\\n\\t  // answer. We further decrease the search space by bringing \\'lo\\' closer to the estimate\\n\\t  // but we know that \\'lo\\' is not the answer\\n    } else if (nums[mid] > nums[hi]) {\\n      lo = mid\\n\\t  \\n\\t  // this is where it differs from the standard template of binary search\\n\\t  // and this is also the crux of this algorithm. Both the numbers are equal, the probable\\n\\t  // candidate (pointed by \\'mid\\') and the best candidate (\\'hi\\'). To further decrease the\\n\\t  // search space, we decrease the value of \\'hi\\' pointer by 1.\\n    } else {\\n      hi = hi - 1;\\n    }\\n  }\\n  // At the end of the loop, \\'hi\\' points at our answer\\n  return nums[hi];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429873,
                "title": "python",
                "content": "if len(nums) == 1:\\n            return nums[0]\\n\\n        # left pointer\\n        left = 0\\n        # right pointer\\n        right = len(nums) - 1\\n\\n        # if the last element is greater than the first element then there is no rotation.\\n        # e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.\\n        # Hence the smallest element is first element. A[0]\\n        if nums[right] > nums[0]:\\n            return nums[0]\\n\\n        # Binary search way\\n        while right >= left:\\n            # Find the mid element\\n            mid = left + (right - left) / 2\\n            # if the mid element is greater than its next element then mid+1 element is the smallest\\n            # This point would be the point of change. From higher to lower value.\\n            if nums[mid] > nums[mid + 1]:\\n                return nums[mid + 1]\\n            # if the mid element is lesser than its previous element then mid element is the smallest\\n            if nums[mid - 1] > nums[mid]:\\n                return nums[mid]\\n\\n            # if the mid elements value is greater than the 0th element this means\\n            # the least value is still somewhere to the right as we are still dealing with elements greater than nums[0]\\n            if nums[mid] > nums[0]:\\n                left = mid + 1\\n            # if nums[0] is greater than the mid value then this means the smallest value is somewhere to the left\\n            else:\\n                right = mid - 1",
                "solutionTags": [],
                "code": "if len(nums) == 1:\\n            return nums[0]\\n\\n        # left pointer\\n        left = 0\\n        # right pointer\\n        right = len(nums) - 1\\n\\n        # if the last element is greater than the first element then there is no rotation.\\n        # e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.\\n        # Hence the smallest element is first element. A[0]\\n        if nums[right] > nums[0]:\\n            return nums[0]\\n\\n        # Binary search way\\n        while right >= left:\\n            # Find the mid element\\n            mid = left + (right - left) / 2\\n            # if the mid element is greater than its next element then mid+1 element is the smallest\\n            # This point would be the point of change. From higher to lower value.\\n            if nums[mid] > nums[mid + 1]:\\n                return nums[mid + 1]\\n            # if the mid element is lesser than its previous element then mid element is the smallest\\n            if nums[mid - 1] > nums[mid]:\\n                return nums[mid]\\n\\n            # if the mid elements value is greater than the 0th element this means\\n            # the least value is still somewhere to the right as we are still dealing with elements greater than nums[0]\\n            if nums[mid] > nums[0]:\\n                left = mid + 1\\n            # if nums[0] is greater than the mid value then this means the smallest value is somewhere to the left\\n            else:\\n                right = mid - 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1414243,
                "title": "c-faster-than-90-o-log-n-time-constant-space",
                "content": "```\\nint findMin(vector<int>& a) {\\n        int n = a.size();\\n        int l = 0, h = n-1;\\n        while(l<h) {\\n            while(l<h && a[l]==a[l+1]) l++;\\n            while(l<h && a[h]==a[h-1]) h--;\\n            int mid = (l+h)/2;\\n            if(a[mid] < a[h]) h = mid;\\n            else if(a[mid] > a[h]) l = mid+1;\\n        }\\n        return a[l];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findMin(vector<int>& a) {\\n        int n = a.size();\\n        int l = 0, h = n-1;\\n        while(l<h) {\\n            while(l<h && a[l]==a[l+1]) l++;\\n            while(l<h && a[h]==a[h-1]) h--;\\n            int mid = (l+h)/2;\\n            if(a[mid] < a[h]) h = mid;\\n            else if(a[mid] > a[h]) l = mid+1;\\n        }\\n        return a[l];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400058,
                "title": "java-solution-easy-binary-search",
                "content": "int arr[] = {3,3,3,3,3,4,5,6,7,3};\\n1. if arr[mid] > arr[h] then search in right side make l=mid+1\\n2. else if arr[mid]<arr[h] then search then make h = mid\\n3. else handle duplicate, arr[mid] == arr[h] then make h--\\n\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n      int l=0, h= nums.length-1;\\n      \\n      while(l<h){\\n        int mid = l+(h-l)/2;\\n        if(nums[mid]>nums[h])\\n          l = mid+1;\\n        else if(nums[mid]<nums[h])\\n          h = mid;\\n        else\\n          h--;\\n      }\\n      return nums[l];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n      int l=0, h= nums.length-1;\\n      \\n      while(l<h){\\n        int mid = l+(h-l)/2;\\n        if(nums[mid]>nums[h])\\n          l = mid+1;\\n        else if(nums[mid]<nums[h])\\n          h = mid;\\n        else\\n          h--;\\n      }\\n      return nums[l];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339694,
                "title": "rust-with-comments",
                "content": "```\\nimpl Solution {\\n    pub fn find_min(nums: Vec<i32>) -> i32 {\\n        let mut l = 0;\\n        let mut r = nums.len() - 1;\\n\\n        while l < r {\\n            let mid = l + (r - l) / 2;\\n            if nums[mid] < nums[r] {\\n                // left side, mid \"might\" be the target we are looking for, so we don\\'t do \"-1\" aggressively\\n                r = mid\\n            } else if nums[mid] > nums[r] {\\n                // right side, and we can be sure that mid is not possibly the target\\n                l = mid + 1\\n            } else {\\n                r -= 1\\n            }\\n        }\\n\\n        nums[l]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn find_min(nums: Vec<i32>) -> i32 {\\n        let mut l = 0;\\n        let mut r = nums.len() - 1;\\n\\n        while l < r {\\n            let mid = l + (r - l) / 2;\\n            if nums[mid] < nums[r] {\\n                // left side, mid \"might\" be the target we are looking for, so we don\\'t do \"-1\" aggressively\\n                r = mid\\n            } else if nums[mid] > nums[r] {\\n                // right side, and we can be sure that mid is not possibly the target\\n                l = mid + 1\\n            } else {\\n                r -= 1\\n            }\\n        }\\n\\n        nums[l]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1177889,
                "title": "simple-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low =0, high = nums.size()-1;\\n        while(low<high){\\n            int mid = low + (high- low)/2;\\n            if(nums[mid]>nums[high]){\\n                low = mid+1;\\n            }else if(nums[mid]<nums[low]){\\n                high = mid;\\n            }else{\\n                high--;\\n            }\\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low =0, high = nums.size()-1;\\n        while(low<high){\\n            int mid = low + (high- low)/2;\\n            if(nums[mid]>nums[high]){\\n                low = mid+1;\\n            }else if(nums[mid]<nums[low]){\\n                high = mid;\\n            }else{\\n                high--;\\n            }\\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042722,
                "title": "java-binary-search-clean-solution",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < nums[right]) {\\n                right = mid;\\n            } else if (nums[mid] > nums[right]) {\\n                left = mid + 1;\\n            } else if (nums[left] < nums[right]) {\\n                return nums[left];\\n            } else {\\n                left++;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < nums[right]) {\\n                right = mid;\\n            } else if (nums[mid] > nums[right]) {\\n                left = mid + 1;\\n            } else if (nums[left] < nums[right]) {\\n                return nums[left];\\n            } else {\\n                left++;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027762,
                "title": "fast-and-simple-c-0ms",
                "content": "```\\nint findMin(vector<int>& nums) {\\n\\tint low=0,high=nums.size()-1,n=nums.size();\\n\\twhile(low<=high)\\n\\t{\\n\\t\\tint mid=low+(high-low)/2;\\n\\t\\tif((mid==0||nums[mid]<nums[mid-1])&&(mid==n-1||nums[mid]<nums[mid+1]))\\n\\t\\t\\treturn nums[mid];\\n\\t\\telse if(nums[mid]>nums[high])\\n\\t\\t\\tlow=mid+1;\\n\\t\\telse if(nums[mid]<nums[high])\\n\\t\\t\\thigh=mid;\\n\\t\\telse\\n\\t\\t\\thigh--;\\n\\t}\\n\\treturn nums[low];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findMin(vector<int>& nums) {\\n\\tint low=0,high=nums.size()-1,n=nums.size();\\n\\twhile(low<=high)\\n\\t{\\n\\t\\tint mid=low+(high-low)/2;\\n\\t\\tif((mid==0||nums[mid]<nums[mid-1])&&(mid==n-1||nums[mid]<nums[mid+1]))\\n\\t\\t\\treturn nums[mid];\\n\\t\\telse if(nums[mid]>nums[high])\\n\\t\\t\\tlow=mid+1;\\n\\t\\telse if(nums[mid]<nums[high])\\n\\t\\t\\thigh=mid;\\n\\t\\telse\\n\\t\\t\\thigh--;\\n\\t}\\n\\treturn nums[low];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 754421,
                "title": "2-python-solutions-binary-and-nonbinary-search",
                "content": "I don\\'t know why but my non BS solution is 64ms while BS is 100ms. What did I do wrong? Also, the non-BS solution seems more intuitive.\\n\\n```\\n  # O(n) worst case non BS solution\\n        minSoFar= float(\"inf\")\\n        for each in nums:\\n            m = min(minSoFar, each)\\n            minSoFar = min(minSoFar, m)\\n        return m\\n  # binarySearch\\n        l = 0; r = len(nums) - 1\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if nums[r] < nums[mid]:\\n                # min is b/w mid and r\\n                l = mid + 1\\n            elif nums[r] > nums[mid]:\\n                # min lies to the left as in an unrotated array\\n                r = mid\\n            else:\\n                # we dont know  where the min lies, so we shorten the  search window \\n                r -= 1\\n        return nums[l]\\n```",
                "solutionTags": [],
                "code": "```\\n  # O(n) worst case non BS solution\\n        minSoFar= float(\"inf\")\\n        for each in nums:\\n            m = min(minSoFar, each)\\n            minSoFar = min(minSoFar, m)\\n        return m\\n  # binarySearch\\n        l = 0; r = len(nums) - 1\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if nums[r] < nums[mid]:\\n                # min is b/w mid and r\\n                l = mid + 1\\n            elif nums[r] > nums[mid]:\\n                # min lies to the left as in an unrotated array\\n                r = mid\\n            else:\\n                # we dont know  where the min lies, so we shorten the  search window \\n                r -= 1\\n        return nums[l]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703396,
                "title": "golang-binary-search-solution",
                "content": "\\n```\\nfunc findMin(nums []int) int {\\n    \\n    l, r := 0, len(nums) - 1\\n\\t\\n    // l == r when we found our minumum value\\n    for l < r {\\n        mid := l + (r-l)/2\\n        \\n        if nums[l] > nums[mid] { \\n\\t\\t// left side is unsorted, so our answer is inside left\\n            r = mid \\n        } else if nums[mid] > nums[r] {\\n\\t\\t// right side is unsorted, so our answer is inside right.\\n\\t\\t// +1 because mid will always larger than the minumum\\n            l = mid + 1\\n        } else if nums[mid] == nums[r] {\\n\\t\\t// this is when this question get tricky. \\n\\t\\t// think of the case like [2 2 2], [1, 3, 3], [3, 1, 3, 3]\\n            r = r - 1 \\n        }  else {\\n\\t\\t// it\\'s sorted\\n            r = l\\n        }\\n    }\\n    \\n    return nums[l]\\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findMin(nums []int) int {\\n    \\n    l, r := 0, len(nums) - 1\\n\\t\\n    // l == r when we found our minumum value\\n    for l < r {\\n        mid := l + (r-l)/2\\n        \\n        if nums[l] > nums[mid] { \\n\\t\\t// left side is unsorted, so our answer is inside left\\n            r = mid \\n        } else if nums[mid] > nums[r] {\\n\\t\\t// right side is unsorted, so our answer is inside right.\\n\\t\\t// +1 because mid will always larger than the minumum\\n            l = mid + 1\\n        } else if nums[mid] == nums[r] {\\n\\t\\t// this is when this question get tricky. \\n\\t\\t// think of the case like [2 2 2], [1, 3, 3], [3, 1, 3, 3]\\n            r = r - 1 \\n        }  else {\\n\\t\\t// it\\'s sorted\\n            r = l\\n        }\\n    }\\n    \\n    return nums[l]\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 682919,
                "title": "java-divide-and-conquer-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        return recursion(nums, 0 ,nums.length-1);\\n    }\\n    \\n    private int recursion(int[] nums, int start, int end){\\n        if(start == end) return nums[start];\\n        int mid = start + (end - start) / 2;\\n        if(nums[mid]> nums[end]){\\n            return recursion(nums, mid+1 ,end);\\n        } else if (nums[mid]< nums[end]) {\\n            return recursion(nums, start ,mid);\\n        } else {\\n            return Math.min(recursion(nums, mid+1 ,end), recursion(nums, start ,mid));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        return recursion(nums, 0 ,nums.length-1);\\n    }\\n    \\n    private int recursion(int[] nums, int start, int end){\\n        if(start == end) return nums[start];\\n        int mid = start + (end - start) / 2;\\n        if(nums[mid]> nums[end]){\\n            return recursion(nums, mid+1 ,end);\\n        } else if (nums[mid]< nums[end]) {\\n            return recursion(nums, start ,mid);\\n        } else {\\n            return Math.min(recursion(nums, mid+1 ,end), recursion(nums, start ,mid));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665714,
                "title": "java-100-solution-binary-search",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Minimum in Rotated Sorted Array II.\\nMemory Usage: 39.1 MB, less than 40.63% of Java online submissions for Find Minimum in Rotated Sorted Array II.\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1])\\n        {\\n            return nums[0];\\n        }\\n        int low = 0, high = nums.length-1;\\n        while(low<high)\\n        {\\n            int mid  = low + (high-low)/2;\\n            if(nums[mid]>nums[high])\\n            {\\n                low = mid+1;\\n            }\\n            else if(nums[mid]<nums[high])\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                high--;\\n            }\\n        }\\n        return nums[low];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1])\\n        {\\n            return nums[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 644511,
                "title": "python-divide-and-conquer-a-different-variation-of-binary-search",
                "content": "The idea is to recurseively performing binary search both sides when `val == nums[hi]`. \\n\\n```python\\nclass Solution:\\n    # 52 ms, 74.41% \\n    def findMin(self, nums: List[int]) -> int:\\n        def binary_search(lo, hi):\\n            while lo < hi:\\n                mid = (lo + hi)//2\\n                val = nums[mid]\\n                if val < nums[hi]: # case 1\\n                    hi = mid\\n                elif val > nums[hi]: # case 2\\n                    lo = mid + 1\\n                else: # case 3\\n                    return min(binary_search(lo, mid), binary_search(mid+1, hi))\\n            return nums[lo]\\n        return binary_search(0, len(nums) - 1)\\n```\\nTime complexity: \\nIn the worst case, when all numbers are the same, all sub problems (recursion calls) will fall into case 3 and time complexity would be `O(N)`. \\nIn the best case, when all numbers are different, there will be no sub problems (recursion calls) as it will fall in either case 1 or 2. Thus, `O(log N)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```python\\nclass Solution:\\n    # 52 ms, 74.41% \\n    def findMin(self, nums: List[int]) -> int:\\n        def binary_search(lo, hi):\\n            while lo < hi:\\n                mid = (lo + hi)//2\\n                val = nums[mid]\\n                if val < nums[hi]: # case 1\\n                    hi = mid\\n                elif val > nums[hi]: # case 2\\n                    lo = mid + 1\\n                else: # case 3\\n                    return min(binary_search(lo, mid), binary_search(mid+1, hi))\\n            return nums[lo]\\n        return binary_search(0, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620483,
                "title": "simple-java-solution-beats-100",
                "content": "\\n    public int findMin(int[] nums) {\\n\\n\\t\\tint low = 0;\\n\\t\\tint high = nums.length - 1;\\n\\n\\t\\twhile (low < nums.length && nums[low] == nums[high]) {\\n\\t\\t\\tlow++;\\n\\t\\t}\\n\\n\\t\\tif (low == nums.length)\\n\\t\\t\\treturn nums[high];\\n\\n\\t\\tif (nums[low] < nums[high])\\n\\t\\t\\treturn nums[low];\\n\\n\\t\\twhile (low <= high) {\\n\\n\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\tif (mid-1>=0 && nums[mid] < nums[mid - 1])\\n\\t\\t\\t\\treturn nums[mid];\\n\\t\\t\\telse if (mid+1<nums.length && nums[mid] > nums[mid + 1])\\n\\t\\t\\t\\treturn nums[mid + 1];\\n\\t\\t\\telse if (nums[low] <= nums[mid])\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n",
                "solutionTags": [],
                "code": "\\n    public int findMin(int[] nums) {\\n\\n\\t\\tint low = 0;\\n\\t\\tint high = nums.length - 1;\\n\\n\\t\\twhile (low < nums.length && nums[low] == nums[high]) {\\n\\t\\t\\tlow++;\\n\\t\\t}\\n\\n\\t\\tif (low == nums.length)\\n\\t\\t\\treturn nums[high];\\n\\n\\t\\tif (nums[low] < nums[high])\\n\\t\\t\\treturn nums[low];\\n\\n\\t\\twhile (low <= high) {\\n\\n\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\tif (mid-1>=0 && nums[mid] < nums[mid - 1])\\n\\t\\t\\t\\treturn nums[mid];\\n\\t\\t\\telse if (mid+1<nums.length && nums[mid] > nums[mid + 1])\\n\\t\\t\\t\\treturn nums[mid + 1];\\n\\t\\t\\telse if (nums[low] <= nums[mid])\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 241815,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i = 0\\n        j = len(nums)-1\\n        while i < j:\\n            mid = i + (j-i) / 2\\n            if nums[mid] > nums[j]:\\n                i = mid+1\\n            elif nums[mid] < nums[j]:\\n                j = mid\\n            else:\\n                j -= 1\\n        return nums[j]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i = 0\\n        j = len(nums)-1\\n        while i < j:\\n            mid = i + (j-i) / 2\\n            if nums[mid] > nums[j]:\\n                i = mid+1\\n            elif nums[mid] < nums[j]:\\n                j = mid\\n            else:\\n                j -= 1\\n        return nums[j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236406,
                "title": "java-binary-search-solution-that-produces-correct-index-and-value-for-the-minimum-element",
                "content": "This algorithm produces correct **index** and value for the minimum element. Although the problem description does not require the correct **index**, it is not harmful to know exactly which element is picked. Besides, this algorithm uses `rMax` instead of `nums[hi]` or `nums[lo]` for the comparision, which makes more sense, because in this way, we only need take care of the duplicates that are equal to `rMax`.\\n\\n```java\\n/**\\n * Time complexity: O(log(N))\\n * Worst case time complexity: O(N)\\n * Space complexity: O(1)\\n*/\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int N = nums.length;\\n        int lo = 0, hi = N - 1, rMax = nums[N - 1];\\n        // Target: the smallest element (the pivot)\\n        // lo is inclusive: approaches to target.\\n        // hi is inclusive: approaches to target.\\n        // When lo == hi, nums[lo] is the target.\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] > rMax) {\\n                // mid is in the left partition.\\n                // min resides in [mid + 1, hi]\\n                lo = mid + 1;\\n            } else if (nums[mid] < rMax) {\\n                // mid is in the right partition.\\n                // min resides in [lo, mid]\\n                hi = mid;\\n            } else {\\n                // nums[mid] == rMax, then we have the following possibilities:\\n                // \\n                // A. mid is in the \"MAX\" zone of the right partition:\\n                // ==================================================\\n                // 3...3,4,5|1,2,3...3\\n                //               -----\\n                // \\n                // B. mid is in the \"MIN\" zone of the left partition:\\n                // ==================================================\\n                // 3...3,4,5|1,2,3...3\\n                // -----\\n                //\\n                // C. There is only one partition, and mid is in the \"MAX\" zone:\\n                // =============================================================\\n                // 1,2,3...3 \\n                //     -----\\n                //\\n                // D. There is only one partition, and all elements are same:\\n                // ==========================================================\\n                // 3...3\\n                // -----\\n                // \\n                // NOTE: \\n                // Because lo < hi, nums[lo + 1] and nums[hi - 1] are both valid, and mid < hi.\\n                if (nums[hi - 1] == nums[hi]) {\\n                    // We have the following possibilities:\\n                    // A. mid is in the \"MAX\" zone of the right partition; or\\n                    // B. mid is in the \"MIN\" zone of the left partition, and nums[hi] MAY or MAY NOT be equal to rMax; or\\n                    // C. There is only one partition; or\\n                    // D. All elements are same.\\n                    //  \\n                    // For any case above, because nums[hi - 1] == nums[hi], it is always\\n                    // not wrong to reduce hi by one because we are looking for the left most candidate, so\\n                    // that when there are multiple \"smallest\" values, the left-most one will be picked; or\\n                    // if there is only one partition with all duplicates, it will be\\n                    // identified as the left partition, in stead of being split into two partitions: [3,3,3,3].\\n                    hi--;\\n                } else {\\n                    // Now nums[hi] != nums[hi - 1] and nums[mid] == rMax, then the only possibility is B:\\n                    // mid is in the \"MIN\" zone of the left partition.\\n                    // A. is impossible because mid < hi, and nums[hi] != nums[hi-1].\\n                    // C. is impossible because of the same reason.\\n                    // D. is impossible because of the same reaons.\\n                    lo = mid + 1;\\n                }\\n            }\\n        }\\n        // System.out.format(\"lo: %d\\\\n\", lo);\\n        return nums[lo];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Time complexity: O(log(N))\\n * Worst case time complexity: O(N)\\n * Space complexity: O(1)\\n*/\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int N = nums.length;\\n        int lo = 0, hi = N - 1, rMax = nums[N - 1];\\n        // Target: the smallest element (the pivot)\\n        // lo is inclusive: approaches to target.\\n        // hi is inclusive: approaches to target.\\n        // When lo == hi, nums[lo] is the target.\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] > rMax) {\\n                // mid is in the left partition.\\n                // min resides in [mid + 1, hi]\\n                lo = mid + 1;\\n            } else if (nums[mid] < rMax) {\\n                // mid is in the right partition.\\n                // min resides in [lo, mid]\\n                hi = mid;\\n            } else {\\n                // nums[mid] == rMax, then we have the following possibilities:\\n                // \\n                // A. mid is in the \"MAX\" zone of the right partition:\\n                // ==================================================\\n                // 3...3,4,5|1,2,3...3\\n                //               -----\\n                // \\n                // B. mid is in the \"MIN\" zone of the left partition:\\n                // ==================================================\\n                // 3...3,4,5|1,2,3...3\\n                // -----\\n                //\\n                // C. There is only one partition, and mid is in the \"MAX\" zone:\\n                // =============================================================\\n                // 1,2,3...3 \\n                //     -----\\n                //\\n                // D. There is only one partition, and all elements are same:\\n                // ==========================================================\\n                // 3...3\\n                // -----\\n                // \\n                // NOTE: \\n                // Because lo < hi, nums[lo + 1] and nums[hi - 1] are both valid, and mid < hi.\\n                if (nums[hi - 1] == nums[hi]) {\\n                    // We have the following possibilities:\\n                    // A. mid is in the \"MAX\" zone of the right partition; or\\n                    // B. mid is in the \"MIN\" zone of the left partition, and nums[hi] MAY or MAY NOT be equal to rMax; or\\n                    // C. There is only one partition; or\\n                    // D. All elements are same.\\n                    //  \\n                    // For any case above, because nums[hi - 1] == nums[hi], it is always\\n                    // not wrong to reduce hi by one because we are looking for the left most candidate, so\\n                    // that when there are multiple \"smallest\" values, the left-most one will be picked; or\\n                    // if there is only one partition with all duplicates, it will be\\n                    // identified as the left partition, in stead of being split into two partitions: [3,3,3,3].\\n                    hi--;\\n                } else {\\n                    // Now nums[hi] != nums[hi - 1] and nums[mid] == rMax, then the only possibility is B:\\n                    // mid is in the \"MIN\" zone of the left partition.\\n                    // A. is impossible because mid < hi, and nums[hi] != nums[hi-1].\\n                    // C. is impossible because of the same reason.\\n                    // D. is impossible because of the same reaons.\\n                    lo = mid + 1;\\n                }\\n            }\\n        }\\n        // System.out.format(\"lo: %d\\\\n\", lo);\\n        return nums[lo];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151484,
                "title": "simpe-java-code-beats-100",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n          \\n       if (nums == null || nums.length < 1) {\\n            return -1;\\n        }\\n        int l = 0 , r = nums.length-1;\\n        while(l < r){\\n            int  m = l + (r - l) /2;\\n\\n            if(nums[m] > nums[r]) {\\n                l = m+1;\\n            }else if(nums[m] < nums[r]){\\n                r = m;\\n            }else{\\n                r--;\\n            }\\n        }\\n\\n        return nums[l];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n          \\n       if (nums == null || nums.length < 1) {\\n            return -1;\\n        }\\n        int l = 0 , r = nums.length-1;\\n        while(l < r){\\n            int  m = l + (r - l) /2;\\n\\n            if(nums[m] > nums[r]) {\\n                l = m+1;\\n            }else if(nums[m] < nums[r]){\\n                r = m;\\n            }else{\\n                r--;\\n            }\\n        }\\n\\n        return nums[l];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48803,
                "title": "kotlin-simple-solution",
                "content": "```\\nclass Solution {\\n    fun findMin(nums: IntArray): Int =\\n        nums.find { it < nums[0] } ?: nums[0]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findMin(nums: IntArray): Int =\\n        nums.find { it < nums[0] } ?: nums[0]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48937,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n      \\n      public int findMin(int[] a) {\\n        return search(a, 0, a.length - 1);\\n      }\\n      \\n      private int search(int[] a, int lo, int hi) {\\n        // a[] is sorted\\n        if (lo > hi)\\n          return a[0];\\n            \\n        int mid = lo + (hi - lo) / 2;\\n        \\n        if (mid > 0 && a[mid - 1] > a[mid])\\n          return a[mid];\\n        \\n        if (mid < a.length - 1 && a[mid] > a[mid + 1])\\n          return a[mid + 1];\\n            \\n        if (a[lo] == a[mid] && a[mid] == a[hi])\\n          return Math.min(search(a, lo, mid - 1), search(a, mid + 1, hi));\\n            \\n        if (a[lo] <= a[mid])\\n          return search(a, mid + 1, hi);\\n        else\\n          return search(a, lo, mid - 1);\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n      \\n      public int findMin(int[] a) {\\n        return search(a, 0, a.length - 1);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 48993,
                "title": "puzzled-about-the-recommended-solution-find-minimum-in-rotated-sorted-array-ii",
                "content": "    public int findMin(int[] A) {\\n       int L = 0, R = A.length - 1;\\n       while (L < R && A[L] >= A[R]) {\\n          int M = (L + R) / 2;\\n          if (A[M] > A[R]) {\\n             L = M + 1;\\n          } else if (A[M] < A[L]) {\\n             R = M;\\n          } else {   // A[L] == A[M] == A[R]\\n             L = L + 1;\\n          }\\n       }\\n       return A[L];\\n    }\\n\\nthis is the recommended solution the system give.For this case [2,1,4,3]( rotate from [4,3,2,1] ), its result is 2,but in fact, 1 is the correct answer. Here, what is the meaning of  \"rotate\" ,[2,1,4,3] is not a valid input?",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "    public int findMin(int[] A) {\\n       int L = 0, R = A.length - 1;\\n       while (L < R && A[L] >= A[R]) {\\n          int M = (L + R) / 2;\\n          if (A[M] > A[R]) {\\n             L = M + 1;\\n          } else if (A[M] < A[L]) {\\n             R = M;\\n          } else {   // A[L] == A[M] == A[R]\\n             L = L + 1;\\n          }\\n       }\\n       return A[L];\\n    }\\n\\nthis is the recommended solution the system give.For this case [2,1,4,3]( rotate from [4,3,2,1] ), its result is 2,but in fact, 1 is the correct answer. Here, what is the meaning of  \"rotate\" ,[2,1,4,3] is not a valid input?",
                "codeTag": "Unknown"
            },
            {
                "id": 4102456,
                "title": "sm154-java-solution-that-beats-100",
                "content": "# Approach\\nUsual binary search approach, but added just one more case if left = mid = right, then binary search can not decide which way to go, so need linear search.\\n![image.png](https://assets.leetcode.com/users/images/7c7722a8-4af0-42ba-8a61-da5c64646b48_1695931401.8292148.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case O(n)\\nAverage O(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n         return bs(nums, 0, nums.length-1);\\n    }\\n    \\tpublic static int bs(int[] arr, int l, int r) {\\n\\t\\t\\n\\t\\t if(l>=r) return arr[l];\\n\\t\\t \\n\\t\\t int m = l + (r-l)/2;\\n\\t\\t// System.out.println(l+\" \"+r+\"  mid = \"+m);\\n\\t\\t if(arr[m] > arr[r])\\n\\t\\t\\t return bs(arr,m+1,r);\\n\\t\\t else if(arr[m]==arr[r] && arr[m]==arr[l])\\n\\t\\t\\t {\\n\\t\\t\\t\\t  int res=Integer.MAX_VALUE;\\n\\t\\t for(int i:arr) {\\n\\t\\t\\t if(i<res)\\n\\t\\t\\t\\t res=i;\\n\\t\\t }\\n\\t\\t return res;\\n\\t\\t\\t }\\n\\t\\t else\\n\\t\\t\\t return bs(arr,l,m);\\n\\t\\t \\n\\t }\\n\\t \\n\\t\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n         return bs(nums, 0, nums.length-1);\\n    }\\n    \\tpublic static int bs(int[] arr, int l, int r) {\\n\\t\\t\\n\\t\\t if(l>=r) return arr[l];\\n\\t\\t \\n\\t\\t int m = l + (r-l)/2;\\n\\t\\t// System.out.println(l+\" \"+r+\"  mid = \"+m);\\n\\t\\t if(arr[m] > arr[r])\\n\\t\\t\\t return bs(arr,m+1,r);\\n\\t\\t else if(arr[m]==arr[r] && arr[m]==arr[l])\\n\\t\\t\\t {\\n\\t\\t\\t\\t  int res=Integer.MAX_VALUE;\\n\\t\\t for(int i:arr) {\\n\\t\\t\\t if(i<res)\\n\\t\\t\\t\\t res=i;\\n\\t\\t }\\n\\t\\t return res;\\n\\t\\t\\t }\\n\\t\\t else\\n\\t\\t\\t return bs(arr,l,m);\\n\\t\\t \\n\\t }\\n\\t \\n\\t\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102455,
                "title": "beats-100-users-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary Search Approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        return findMinRec(nums,start,end);\\n    }\\n\\n    public int findMinRec(int[]nums, int start, int end){\\n         if((end-start)==0){\\n            return nums[start];\\n         }\\n        if((end-start)==1){\\n          return Math.min(nums[start],nums[end]);\\n        }\\n        int mid = start+(end-start)/2;\\n      //  System.out.println(start+\" \"+end+\"  mid = \"+mid);\\n        if (nums[start]<nums[mid] && nums[end]>=nums[mid]){\\n          return findMinRec(nums,start,mid);\\n        }\\n        else if(nums[start]>=nums[mid] && nums[end]<nums[mid]){\\n          return findMinRec(nums,mid+1,end);\\n        }\\n        else{\\n          return findMinRec(nums,start+1,end);\\n        }\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        return findMinRec(nums,start,end);\\n    }\\n\\n    public int findMinRec(int[]nums, int start, int end){\\n         if((end-start)==0){\\n            return nums[start];\\n         }\\n        if((end-start)==1){\\n          return Math.min(nums[start],nums[end]);\\n        }\\n        int mid = start+(end-start)/2;\\n      //  System.out.println(start+\" \"+end+\"  mid = \"+mid);\\n        if (nums[start]<nums[mid] && nums[end]>=nums[mid]){\\n          return findMinRec(nums,start,mid);\\n        }\\n        else if(nums[start]>=nums[mid] && nums[end]<nums[mid]){\\n          return findMinRec(nums,mid+1,end);\\n        }\\n        else{\\n          return findMinRec(nums,start+1,end);\\n        }\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927131,
                "title": "c-easiest-possible-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s = 0 , e = nums.size()-1;\\n        int mini=INT_MAX;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if((nums[mid]==nums[s]) && (nums[mid]==nums[e])){\\n                s++;\\n                e--;\\n                mini = min(mini, nums[mid]);\\n                continue;\\n            }\\n            if(nums[mid] >= nums[s]){\\n                mini = min(mini, nums[s]);\\n                s = mid+1;\\n            }\\n            else{\\n                mini = min(mini, nums[mid]);\\n                e  = mid-1;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s = 0 , e = nums.size()-1;\\n        int mini=INT_MAX;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if((nums[mid]==nums[s]) && (nums[mid]==nums[e])){\\n                s++;\\n                e--;\\n                mini = min(mini, nums[mid]);\\n                continue;\\n            }\\n            if(nums[mid] >= nums[s]){\\n                mini = min(mini, nums[s]);\\n                s = mid+1;\\n            }\\n            else{\\n                mini = min(mini, nums[mid]);\\n                e  = mid-1;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881665,
                "title": "100-percent-beats",
                "content": "# Approach\\nSame as Question No 153 Just we need to check the case where nums[low] = nums[high] = nums[mid]\\n\\n# Complexity\\n- Time complexity:\\n- In worst Case Complexity is O(N)- When all Elements Are Equal!!!!\\n- Average is O(log N)\\n\\n- Space complexity:\\nConstant space\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n        int low = 0, high = n - 1;\\n\\n        while(low < high){\\n\\n            //If u take this as Low <= High this will be an infinite loop//\\n\\n            int mid = low + (high - low) / 2;\\n            // (high + low) / 2 may result in integer overflow//\\n\\n            if(nums[mid] > nums[mid + 1]) return nums[mid + 1];\\n\\n            else if(mid == 0){\\n                if(nums[low] > nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    return nums[low];\\n                }\\n            }\\n\\n            else if(mid != 0 && nums[mid - 1] > nums[mid]) return nums[mid];\\n            //It\\'s not necessary to write \\'mid != 0\\' since we have already accounted for the condition when the index is zero in the step above//\\n\\n            else if(nums[low] == nums[high] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\n\\n            else if(nums[mid] > nums[high]) \\n                low = mid;\\n                \\n            else if(nums[mid] <= nums[high]){\\n                high = mid;\\n            }\\n\\n        }\\n        return nums[low];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n        int low = 0, high = n - 1;\\n\\n        while(low < high){\\n\\n            //If u take this as Low <= High this will be an infinite loop//\\n\\n            int mid = low + (high - low) / 2;\\n            // (high + low) / 2 may result in integer overflow//\\n\\n            if(nums[mid] > nums[mid + 1]) return nums[mid + 1];\\n\\n            else if(mid == 0){\\n                if(nums[low] > nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    return nums[low];\\n                }\\n            }\\n\\n            else if(mid != 0 && nums[mid - 1] > nums[mid]) return nums[mid];\\n            //It\\'s not necessary to write \\'mid != 0\\' since we have already accounted for the condition when the index is zero in the step above//\\n\\n            else if(nums[low] == nums[high] && nums[mid] == nums[high]){\\n                low++;\\n                high--;\\n            }\\n\\n            else if(nums[mid] > nums[high]) \\n                low = mid;\\n                \\n            else if(nums[mid] <= nums[high]){\\n                high = mid;\\n            }\\n\\n        }\\n        return nums[low];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828171,
                "title": "python3-solution-runtime-beats-99-70-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, we can use binary search, since the array is sorted. Binary search will allow us to find the desired element in O(log(n)) operations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor binary search, we will need three pointers: left, middle and right. Initially, the value of left is 0, the value of right is equal to the last index of the list of nums. The middle pointer is calculated by the formula: middle = (left + right) // 2.\\n\\nWe could just use binary search, but here is the problem - there are duplicate elements in this sorted and rotated array, that is, such a situation is possible:\\n[5, 3, 5, 5, 5]\\nleft = 0, mid = 2, right = 4\\nHere the \"left\", \"right\" and \"mid\" indexes point to elements with the same value of 5. In this case, we don\\'t know exactly where to shift \"mid\" and we need to shift \"left\" to the right or \"right\" to the left. In my solution in this case I just shift \"right\" index to the left.\\nAfter that, left = 0, right = 3, and mid = 1. Now indexes point to elements with different values and we can start a binary search.\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            elif nums[mid] == nums[right]:\\n                right -= 1\\n            else:\\n                right = mid\\n\\n        return nums[left]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            elif nums[mid] == nums[right]:\\n                right -= 1\\n            else:\\n                right = mid\\n\\n        return nums[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802203,
                "title": "easy-solution-java-modified-binary-search",
                "content": "# Intuition\\nit is very simple as it show that the array is sorted and rotated , it means it is modified binary search problem  \\n\\n# Approach\\nmodified binary search approach is used here\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n          int si=0;\\n        int ei=nums.length-1;\\n        while (si<ei){\\n            int mid=(si+ei)/2;\\n            if (nums[mid]>nums[ei]){\\n                si=mid+1;\\n            }else if(nums[mid]<nums[ei]){\\n                ei=mid;\\n            }else{\\n                ei--;\\n            }\\n        }\\n        return nums[si];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n          int si=0;\\n        int ei=nums.length-1;\\n        while (si<ei){\\n            int mid=(si+ei)/2;\\n            if (nums[mid]>nums[ei]){\\n                si=mid+1;\\n            }else if(nums[mid]<nums[ei]){\\n                ei=mid;\\n            }else{\\n                ei--;\\n            }\\n        }\\n        return nums[si];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783775,
                "title": "minimum-in-rotated-sorted-array-ii-with-binary-search",
                "content": "# Intuition\\nThis problem is an extension of binary search in which the intuition is to find the pivot of the array where the rotation is taking place.\\n\\n# Approach\\nStep1: Run a while loop from starting index to ending index\\nStep2: Check if the array is sorted. If sorted return the starting index\\nStep3: Find the mid of the starting and ending index. Check if the mid element is smaller than the starting index. If true then increase the starting index with index of mid element + 1\\nStep4: Check if the mid element is smaller than the ending index. If true then decrease the ending element to mid index -1;\\nStep5: If the starting index value and mid index value is same then increment the starting index by 1 else decrement the ending index by 1.\\nStep6: Check the min value at each iteration and store it. Then check it with the mid element value at each iteration. At last return the min value.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        int res = nums[0];\\n\\n        while(l <= r){\\n            if(nums[l] < nums[r]){\\n                res = min(res, nums[l]);\\n                break;\\n            }\\n\\n            int mid = (l + r) >> 1;\\n            cout << mid << \" \";\\n            res = min(res, nums[mid]);\\n            if(nums[mid] > nums[l]){\\n                l = mid + 1;\\n            }\\n            else if(nums[mid] < nums[r]){\\n                r = mid-1;\\n            }\\n            else{\\n                if(nums[l] == nums[mid]){\\n                    l++;\\n                }else{\\n                    r--;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        int res = nums[0];\\n\\n        while(l <= r){\\n            if(nums[l] < nums[r]){\\n                res = min(res, nums[l]);\\n                break;\\n            }\\n\\n            int mid = (l + r) >> 1;\\n            cout << mid << \" \";\\n            res = min(res, nums[mid]);\\n            if(nums[mid] > nums[l]){\\n                l = mid + 1;\\n            }\\n            else if(nums[mid] < nums[r]){\\n                r = mid-1;\\n            }\\n            else{\\n                if(nums[l] == nums[mid]){\\n                    l++;\\n                }else{\\n                    r--;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3764050,
                "title": "simple-2-lines-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSingle for loop\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int findMin(vector<int>& nums) {        \\n        int len = nums.size();\\n        for(int i=0; i<len-1; i++){\\n            if(nums[i]>nums[i+1]) return nums[i+1];            \\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int findMin(vector<int>& nums) {        \\n        int len = nums.size();\\n        for(int i=0; i<len-1; i++){\\n            if(nums[i]>nums[i+1]) return nums[i+1];            \\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566279,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1569484,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1566243,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1565742,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1567686,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1569552,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1569499,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1572464,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1568985,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1886979,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1566279,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1569484,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1566243,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1565742,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1567686,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1569552,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1569499,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1572464,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1568985,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1886979,
                "content": [
                    {
                        "username": "llaki",
                        "content": "Let\\'s say the input has N elements, (N-1) of which is 2 and the remaining one is equal to 1. (something like this: [2, 2,  ...  2, 1, 2, 2, ... 2] ). Note that 1 could be sitting on any index and it would still be a valid input. It\\'s clear that we can\\'t find on which index exactly does 1 sit without possibly having to look at all indices, which is O(n). It means that any correct code for this problem will be worst case linear. On the other hand, it\\'s trivial to write linear solution."
                    },
                    {
                        "username": "Cong2017",
                        "content": "I saw many of you guys had got an good intuition of why an worst-case O(log N) algorithm  is unlikely to be true, but lacks of a formal proof. So in this post, I\\'ll try to provide  an simple but rigorous proof to show why any algorithm with a better worst-case running time than O(N) doesn\\'t exist.\\n\\nNow suppose someone, say, Alice, claims that she has found an algorithm that can beat O(N) and always return the right answer.  To convince her that she\\'s wrong, I invited her to play a little game, during which I\\'ll show you how to construct inputs that would foil her algorithm, by using a simple lower bound proof technique called **Adversary Argument**.\\n\\n\\nAt the begining of this game, I secretly pick an input, *V*,  which is an vector of integers with length *N*. In the begining Alice knows nothing about the *V*, except it consists of *N* integers. The game works in stages, in each stage, Alice tells me a entry number of the vector and I tells her the corresponding content in that entry. Note that at any stage, the information(knowledge) about the input that Alice knows and only knows, is the contents of all entries that she has checked in previous stage and the vector length *N*. More formally, in each stage,\\n1. Based her so-far information, Alice either tells me the of entry number *i* that she wants to check in this stage, or she yields her answer.\\n2. If Alice gives the entry number *i*, I tell her the corresponding *V[i]*. Otherwise I\\'ll check whether her answer is indeed the minimum of *V*.\\n\\nAlice wins if she get the right answer within less than *N* stages, otherwise I win. Note that if Alice\\'s algorithm does exists, then she always wins. \\n \\n \\nMy worst-case input has a simple form, it\\'s an vector of *N* entries, with *(N-1)* 1\\'s and a unique 0. But at the beginning the input is not complete, since I\\'m not sure where to put the unique 0 in my *V*.  Luckily that doesn\\'t matter, since Alice doesn\\'t know that I don\\'t know :). I can still win the game and my strategy is extremely simple: **Whatever entry she asks about, I simply tell her the content is *1*, and then she\\'s doomed to lose**. \\n\\nWhy? This is because Alice can ask at most *N-1* times while I get *N-1* 1\\'s, therefore enough for me to reply. And after that I also get my winner reward, a worst-case input, simply by putting the *0* in any one of the entries that she didn\\'t ask about! \\n\\nNote that we assume nothing about what does Alice\\'s algorithm look like, therefore our strategy works for any algorithm whose claimed worst-case time complexity is *o(N)*. Therefore we have proved that there does not exists such algorithms, and hence the *O(N)* algorithm is worst-case optimal."
                    },
                    {
                        "username": "ddcamiu",
                        "content": "Just `return min(num)` is accepted with 63ms, which ranks 30% percentile of all python codes."
                    },
                    {
                        "username": "1337beef",
                        "content": "Refer to this image:  ![array config][1]\\n\\nBig version here: http://postimg.org/image/asbbeo2c9/\\n\\nThere are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value.\\n\\nFor non-duplicate case, you may use `num[mid] > num[end]` to distinguish (1)&(2) from (3), and thus safely eliminate half of the array, at each iteration.\\n\\n\\nFor dup case, it is not as straightforward (impossible?)  to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration.\\n\\n\\n  [1]: http://s28.postimg.org/asbbeo2c9/Photo_16_11_14_2_38_34_pm.jpg"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@sivap8435](/sivap8435) It\\'s almost 10 yrs bro owner sold the site :)"
                    },
                    {
                        "username": "sivap8435",
                        "content": "Bro link isn\\'t working dude...."
                    },
                    {
                        "username": "kyuyeon",
                        "content": "Since it allows duplicated values, the worst case time complexity is inevitably O(N) since you have to search the entire list.\\nThe performance may be sped up by implementing binary search but since it cannot have O(logN) complexity because of the duplicated values, the performance difference is marginal.\\nRuntime of solutions is pointless since it may differ even when re-submitting the same code"
                    },
                    {
                        "username": "jason1128",
                        "content": "I found that if we compare nums[mid] with nums[left]. A sorted array will not be handled correctcly, but i do not know the exact reason for this. Could anyone help to explain?"
                    },
                    {
                        "username": "ygoyal48",
                        "content": "It turned out that duplicates can\\u2019t be handled in O(Logn) time in all cases. The special cases that cause problems are like {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn\\u2019t look possible to go to left half or right half by doing constant number of comparisons at the middle. So the problem with repetition can be solved in O(n) worst case."
                    },
                    {
                        "username": "foin",
                        "content": "just use for loop in python3 is 100% beat\\n\\nwhy make simple complicated?"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@mdmasidulhasan27](/mdmasidulhasan27)  Here anyways the worst goes to O(n) no, so directly following linear search is fine no?"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "its good for low amount of data, our test case has low data in array, for huge amount of data it\\'s important to follow a better algorithm like binary search."
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "For the worst case, i.e., all items are the same, the best we could possibly do is O(n). That is, we need to scan every item. \\n\\nThe reason is actually quite straightforward and can be shown by contradictory: Suppose we skip some item with index `i` (if we don't skip any item, time complexity would be of O(n) as a minimum). We can end up with a wrong min value in the case when item at `i` is the minimum. Therefore, we cannot skip any index."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I used the same code as that of 153 and it worked like magic!\\n"
                    }
                ]
            },
            {
                "id": 1863692,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 1575885,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 1571347,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 2062954,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 2028849,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 2019302,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 2006074,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 1999205,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 1897654,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 1859551,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "Can`t we use that 3sum 4sum duplicate removal technique ?\n\n\n\n \n       `  while (l < h && a[l] == a[l + 1]){\n                    ++l;}   \n                 \n        while (l < h && a[h] == a[h - 1]){\n                --h;}.`"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "yes we can. Remove duplicate eaither from front or back(only need ed when nums[0] == nums[n-1], then apply Find Minimum in Rotated Sorted Array I algorithm exactly as it is."
                    },
                    {
                        "username": "rocco2060",
                        "content": "public int FindMin(int[] nums) {\\n                  \\n\\t  return nums.OrderBy(n => n).First();\\n}"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Sorting is O(n*logn) that is worse than simple O(n) search. And the task is decreasing the overall operation steps -> using binary search that in this case still will be O(n) with duplicates but O(logn) with no duplicates.\\n\\nThat\\'s what you would have to say during an interview. You would definitely fail and receive no points if you use sorting here..."
                    },
                    {
                        "username": "ztitt",
                        "content": "One test case is [1,3,3]. Is it a **Rotated** Sorted Array? How could it be?"
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "so this has been rotated 0 times, and thus remains the same. So this is one of the test case where we have to see the case when it\\'s already sorted. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "if we rotate the array of length n , n times then we get the same original sorted array .....  here we rotated the array 3 times i.e. equal to its length so we got the original sorted array\\nexample: 1 3 3\\n1 rotation 3 1 3\\n2nd rotation 3 3 1\\n3rd rotation 1 3 3 which the original one :)"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Wow only one if condition difference can make a question from medium to hard :)"
                    },
                    {
                        "username": "md_isa",
                        "content": "After trying for a while to solve this in O(logn), some or the other comparisons were missing due to duplicates and when mid = high or mid = low, we still were unsure if any smaller number are present on either left side or right side. So had to move the counter linearly to eradicate the duplicate values."
                    },
                    {
                        "username": "Kanishka_Garg",
                        "content": "How we will see the runtime complexity and the difference in the cases when duplicates are there, and in one, they are not."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "Can some explain the difference between the runtime complexity of this problem and its part 1?Ps"
                    },
                    {
                        "username": "user2179PN",
                        "content": "I think I am committing some mistake. because my code is simply 7 lines long.\\ncan someone point it out. I simply sorted the array in ascending order and returned nums[0];(obv all test cases passed).but it shouldnt be too simple right? it is labeled HARD"
                    },
                    {
                        "username": "jayanta1250",
                        "content": "its a sorted array so we can think as a binary search.and the minimum shoud be the next element of the pivot.\\njust you have to know find pivot with duplicate item. Its not a big deal. we have to skip the duplicates. and there is a thought the while skipping we have to think that which element we are skipping that might be the pivot. so to find we can check that is the next element of the start is greater or not. same as end but just we have check with previous element. Try it and learn it. Best of luck have a nice day\\n"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "```\\nclass Solution {\\n    public int getMin(int[] nums, int l, int r) {\\n        int mid = (l+r)/2;\\n        if(l>r)\\n            return nums[0];\\n        if(nums[mid]<nums[mid-1])\\n            return nums[mid];\\n        else if (nums[mid]>=nums[0])\\n            l=mid+1;\\n        else if(nums[mid]<=nums[0])\\n            r=mid-1;\\n        return getMin(nums, l, r);\\n    }\\n\\n    public int findMin(int[] nums) {\\n        if(nums[0]<nums[nums.length-1] || nums.length==1)\\n            return nums[0];\\n        else if(nums[0]>nums[1])\\n            return nums[1];\\n        else\\n            return getMin(nums, 1, nums.length-1);\\n        \\n    }\\n}\\n```\\nThis is my code which is implemented using binary search,\\nbut for 7 cases it\\'s is being failed. \\nex: [3,3,3,1,3,3,3], [2,3,3,3,0,2,2,2]\\nohh. which logic i should use for these 7 cases.. other 187 cases are being passed."
                    }
                ]
            },
            {
                "id": 1858301,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            },
            {
                "id": 1843537,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            },
            {
                "id": 1840709,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            },
            {
                "id": 1840235,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            },
            {
                "id": 1796705,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            },
            {
                "id": 1762748,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            },
            {
                "id": 1756374,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            },
            {
                "id": 1733548,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            },
            {
                "id": 1727910,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            },
            {
                "id": 1722492,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "1 - solution\\n# return min(nums)\\n\\n2-solution\\n# nums.sort()\\n# return nums[0]\\n        \\n3- solution\\nnums.sort()\\nmin = 0\\nfor i in range(len(nums)):\\n     min += nums[i]\\n     break\\nreturn min"
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'m not sure that FAANG will make you an offer after one-liner min() solution :)"
                    },
                    {
                        "username": "DEVELOPER_m77",
                        "content": "``` python\\nreturn min(nums)  ```\\nVote me, if it was helpful "
                    },
                    {
                        "username": "yongler95",
                        "content": "5000 values is way too low, you can get 50% runtime just with the naive solution"
                    },
                    {
                        "username": "sashreek_das",
                        "content": "who put this up in hard"
                    },
                    {
                        "username": "Pradeep-11",
                        "content": "find min in rotated sorted array \\n\\n`class Solution {\\n    public int findMin(int[] nums) {\\n      int min = nums[0];\\n      for(int i=1;i<nums.length;i++){\\n          min = Math.min(min,nums[i]);\\n      }  \\n     return min;\\n    }\\n}`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n     int n=nums.size()-1;\\n     int s=0;\\n     int  mid=s+(n-s)/2;\\n     if(nums.size()==1){\\n         return nums[0];\\n\\n     }   \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n     if(mid==s && nums[mid]<=nums[mid+1]){\\n         return nums[mid];\\n     }\\n     while(s<n){\\n         if( mid> 0 && nums[mid]<nums[mid-1]){\\n             return nums[mid];\\n         }else if(nums[s]>nums[n] && nums[mid]>nums[n]){\\n             s=mid+1;\\n         }else{\\n             n--;\\n         }\\n         mid=s+(n-s)/2;\\n     }\\n     return nums[s];\\n    }\\n};"
                    },
                    {
                        "username": "sswastik959",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int s = 0;\\n        int e = nums.length - 1;\\n        \\n        while(e > s){\\n            int mid = s + (e-s)/2;\\n            if(nums[mid+1] < nums[mid]){\\n                s = mid + 1 ;\\n                \\n            }\\n            else if(nums[mid+1]>nums[mid]){\\n                \\n                e = mid ;\\n            }\\n          \\n        }\\n        return nums[s];\\n    }\\n}\\nwhy is it giving time limit exceed error"
                    }
                ]
            }
        ]
    },
    {
        "title": "Factor Combinations",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1569534,
                "content": [
                    {
                        "username": "justyy",
                        "content": "1. avoid the duplicates by searching next factor that is not less than its previous one.\\n2. exclude 1 and n\\n3. [DFS and BFS](https://helloacm.com/algorithms-to-compute-the-factor-combinations-for-an-integer-using-dfs-and-bfs/)\\n\\n\\n"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "oj in this questions is obviously bad. Python time is very strict compared to Java cpp, etc. They let java 1304 ms to pass even that python can finish this after optimization in 100ms. Many solution in java if rewrite in Python cannot pass the OJ. This is quite unfair. Many Java solutions is 1ms in fact"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "this ^^^. legit just wasted 40+ minutes till i quit and saw the sqrt optimization (that is required to pass) which is unnecessary for other languages  "
                    }
                ]
            },
            {
                "id": 1678322,
                "content": [
                    {
                        "username": "justyy",
                        "content": "1. avoid the duplicates by searching next factor that is not less than its previous one.\\n2. exclude 1 and n\\n3. [DFS and BFS](https://helloacm.com/algorithms-to-compute-the-factor-combinations-for-an-integer-using-dfs-and-bfs/)\\n\\n\\n"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "oj in this questions is obviously bad. Python time is very strict compared to Java cpp, etc. They let java 1304 ms to pass even that python can finish this after optimization in 100ms. Many solution in java if rewrite in Python cannot pass the OJ. This is quite unfair. Many Java solutions is 1ms in fact"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "this ^^^. legit just wasted 40+ minutes till i quit and saw the sqrt optimization (that is required to pass) which is unnecessary for other languages  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Russian Doll Envelopes",
        "question_content": "<p>You are given a 2D array of integers <code>envelopes</code> where <code>envelopes[i] = [w<sub>i</sub>, h<sub>i</sub>]</code> represents the width and the height of an envelope.</p>\n\n<p>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&#39;s width and height.</p>\n\n<p>Return <em>the maximum number of envelopes you can Russian doll (i.e., put one inside the other)</em>.</p>\n\n<p><strong>Note:</strong> You cannot rotate an envelope.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> envelopes = [[5,4],[6,4],[6,7],[2,3]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> envelopes = [[1,1],[1,1],[1,1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= envelopes.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>envelopes[i].length == 2</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub>, h<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 82763,
                "title": "java-nlogn-solution-with-explanation",
                "content": " 1. Sort the array. Ascend on width and descend on height if width are same.\\n 2. Find the [longest increasing subsequence][1] based on height. \\n\\n\\n----------\\n\\n - Since the width is increasing, we only need to consider height. \\n - [3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]\\n\\n\\n----------\\n\\n\\n    public int maxEnvelopes(int[][] envelopes) {\\n        if(envelopes == null || envelopes.length == 0 \\n           || envelopes[0] == null || envelopes[0].length != 2)\\n            return 0;\\n        Arrays.sort(envelopes, new Comparator<int[]>(){\\n            public int compare(int[] arr1, int[] arr2){\\n                if(arr1[0] == arr2[0])\\n                    return arr2[1] - arr1[1];\\n                else\\n                    return arr1[0] - arr2[0];\\n           } \\n        });\\n        int dp[] = new int[envelopes.length];\\n        int len = 0;\\n        for(int[] envelope : envelopes){\\n            int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\\n            if(index < 0)\\n                index = -(index + 1);\\n            dp[index] = envelope[1];\\n            if(index == len)\\n                len++;\\n        }\\n        return len;\\n    }\\n\\n\\n  [1]: https://leetcode.com/problems/longest-increasing-subsequence/",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": " 1. Sort the array. Ascend on width and descend on height if width are same.\\n 2. Find the [longest increasing subsequence][1] based on height. \\n\\n\\n----------\\n\\n - Since the width is increasing, we only need to consider height. \\n - [3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]\\n\\n\\n----------\\n\\n\\n    public int maxEnvelopes(int[][] envelopes) {\\n        if(envelopes == null || envelopes.length == 0 \\n           || envelopes[0] == null || envelopes[0].length != 2)\\n            return 0;\\n        Arrays.sort(envelopes, new Comparator<int[]>(){\\n            public int compare(int[] arr1, int[] arr2){\\n                if(arr1[0] == arr2[0])\\n                    return arr2[1] - arr1[1];\\n                else\\n                    return arr1[0] - arr2[0];\\n           } \\n        });\\n        int dp[] = new int[envelopes.length];\\n        int len = 0;\\n        for(int[] envelope : envelopes){\\n            int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\\n            if(index < 0)\\n                index = -(index + 1);\\n            dp[index] = envelope[1];\\n            if(index == len)\\n                len++;\\n        }\\n        return len;\\n    }\\n\\n\\n  [1]: https://leetcode.com/problems/longest-increasing-subsequence/",
                "codeTag": "Unknown"
            },
            {
                "id": 2071477,
                "title": "c-java-python-best-explanation-with-pictures",
                "content": "**If you like this solution or find it useful, please upvote this post.**\\n<details>\\n\\t<summary>Prerequisite</summary>\\n\\t<br>\\n\\tBefore moving on to the solution, you should know how can we find the length of <strong>Longest Increasing Subsequence</strong> unsing <strong>Binary Search</strong>. You can find the detailed explanation of the logic on the below link.                                        \\n\\t</br>\\n\\t<br></br>\\n\\t<a href=\"https://leetcode.com/problems/longest-increasing-subsequence/discuss/1636162/java-binary-search-stepwise-explanation\">Longest Increasing Subsequence Using Binary Search</a>\\n</details>\\n<br></br>\\n\\n#### Why we need to sort?\\n* In these types of problem when we are dealing with two dimensions, we need to reduce the problem from two-dimensional array into a one-dimensional array in order to improve time complexity. \\n* **\"Sort first when things are undecided\"**, sorting can make the data orderly, reduce the degree of confusion, and often help us to sort out our thinking. the same is true with this question. Now, after doing the correct sorting, we just need to find Longest Increasing Subsequence of that one dimensional array.\\n**Now, you may be wondered what correct sorting actually is?**\\nIt is the sorting which we do to order to achieve the answer. Like, increasing, non-increasing sorting. Without any further discussion, let\\'s dig into Intuition followed by algorithm.\\n\\n##### Algorithm\\n* We sort the array in increasing order of width. And if two widths are same, we need to sort height in decreasing order. \\n* Now why we need to sort in decreasing order if two widths are same. By this practice, we\\'re assuring that no width will get counted more than one time. Let\\'s take an example\\nenvelopes=`[[3, 5], [6, 7], [7, 13], [6, 10], [8, 4], [7, 11]]`\\n![image](https://assets.leetcode.com/users/images/b8e49902-0d0c-477f-a396-2fbc04b4f59b_1643640325.8523316.png)\\nNow, if you see for a while, **6 and 7** is counted twice while we\\'re calculating the length of LIS, which will give the wrong ans. As question is asking, if any width/height are less than or equal, then, it is not possible to russian doll these envelopes. \\nNow, we know the problem. So, how can we tackle these conditions when two width are same, so that it won\\'t affect our answer. We can simple **reverse sort the height if two width are equal, to remove duplicacy.**\\nNow, you may question, how reverse sorting the height would remove duplicacy? As the name itself says, Longest Increasing Subsequnce, the next coming height would be less than the previous one. Hence, forbidding it to increase length count.\\n![image](https://assets.leetcode.com/users/images/31add436-310d-452d-b696-f7faff8ce2f6_1643641876.2816072.png)\\nIf you don\\'t understand how LIS is calculated here, I strongly refer you to follow the prerequisite.\\nNow, we have **sucessfully reduced the problem to LIS!** All you need to apply classical LIS on heights, to calculate the ans. This would be the maximum number of envelopes can be russian doll.\\n\\n**Code**\\n\\n```\\nclass Solution {\\n    public int binarySearch(int[] dp, int val){\\n        int lo=0,hi=dp.length-1,res=0;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(dp[mid]<val){\\n                res=mid;\\n                lo=mid+1;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        return res+1;\\n    }\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\\n        int[] LIS=new int[envelopes.length+1];\\n        Arrays.fill(LIS,Integer.MAX_VALUE);\\n        LIS[0]=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<envelopes.length;i++){\\n            int val=envelopes[i][1];\\n            int insertIndex=binarySearch(LIS,val);\\n            ans=Math.max(ans,insertIndex);\\n            if(LIS[insertIndex]>=val){\\n                LIS[insertIndex]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nNow, if you compare the code of this problem with the classical LIS, it is very similar. Infact, we have added only one line to get the maximum Russian Doll.\\n\\n`Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);`\\n\\nLanguage Used- **JAVA**\\nTime Complexity- **O(nlogn)**\\nSpace Complexity- **O(n)**\\n\\n**Python Solution-**\\n```class Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        LIS = []\\n        size = 0\\n        for (w, h) in envelopes:\\n            if not LIS or h > LIS[-1]:\\n                LIS.append(h)\\n                size += 1\\n            else:\\n                l, r = 0, size\\n                while l < r:\\n                    m = l + (r - l) // 2\\n                    if LIS[m] < h:\\n                        l = m + 1\\n                    else:\\n                        r = m\\n                LIS[l] = h\\n        return size\\n```\\nby @bettercoder168\\n\\nC++ Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a, vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]>b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n        \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(), envelopes.end(), comp);\\n        int i, j, n=envelopes.size();\\n        vector<int>lis;\\n        \\n        for(i=0; i<n; i++){\\n            auto it = lower_bound(lis.begin(), lis.end(), envelopes[i][1]);\\n            if(it==lis.end()){lis.push_back(envelopes[i][1]);}\\n            else{\\n                *it = envelopes[i][1];\\n            }\\n        }\\n        return lis.size();\\n    }\\n};\\n```\\nby @uttarandas501\\n\\t\\t\\n##### If you like this solution or find it useful, please upvote this post.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int binarySearch(int[] dp, int val){\\n        int lo=0,hi=dp.length-1,res=0;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(dp[mid]<val){\\n                res=mid;\\n                lo=mid+1;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        return res+1;\\n    }\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\\n        int[] LIS=new int[envelopes.length+1];\\n        Arrays.fill(LIS,Integer.MAX_VALUE);\\n        LIS[0]=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<envelopes.length;i++){\\n            int val=envelopes[i][1];\\n            int insertIndex=binarySearch(LIS,val);\\n            ans=Math.max(ans,insertIndex);\\n            if(LIS[insertIndex]>=val){\\n                LIS[insertIndex]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```class Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        LIS = []\\n        size = 0\\n        for (w, h) in envelopes:\\n            if not LIS or h > LIS[-1]:\\n                LIS.append(h)\\n                size += 1\\n            else:\\n                l, r = 0, size\\n                while l < r:\\n                    m = l + (r - l) // 2\\n                    if LIS[m] < h:\\n                        l = m + 1\\n                    else:\\n                        r = m\\n                LIS[l] = h\\n        return size\\n```\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a, vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]>b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n        \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(), envelopes.end(), comp);\\n        int i, j, n=envelopes.size();\\n        vector<int>lis;\\n        \\n        for(i=0; i<n; i++){\\n            auto it = lower_bound(lis.begin(), lis.end(), envelopes[i][1]);\\n            if(it==lis.end()){lis.push_back(envelopes[i][1]);}\\n            else{\\n                *it = envelopes[i][1];\\n            }\\n        }\\n        return lis.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134011,
                "title": "js-python-java-c-easy-lis-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to try every single permutation of our envelope array (**E**), but that would be a **time complexity** of **O(N!)** which is frankly an incomprehensible number when **N** goes up to **5000**.\\n\\nAs the naive approach would involve repeating many of the same individual comparisons over and over again, we can quickly see that a **dynamic programming** (**DP**) solution would be beneficial.\\n\\nIn order for a DP solution to be effective, however, we\\'d need to find a way to progress from the easiest subsolution and build from there for each successively more complex subsolution. The best way to do this would be to sort **E** first by **width** (**E[i][0]**), and then by **height** (**E[i][1]**).\\n\\nThen we could start with the smallest envelope and work our way up, storing in our DP array (**dp**) the result of how many smaller envelopes it is possible to fit in the corresponding envelope. That way we could simplify each iteration to checking to see which of the entries in **dp** corresponding to smaller envelopes is the largest. This would drop the time complexity to **O(N^2)**, which is a definite improvement.\\n\\nBut it should also be apparent that if we were to define a **subsequence** of **E** that was the ideal nesting order of envelopes for the solution, then that array would be strictly increasing in *both* width and height.\\n\\nIf we\\'ve already sorted **E** primarily by width, we should then be able to consider a corresponding array of just the heights and realize that the solution would be defined as the [**longest increasing subsequence**](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) of that.\\n\\nThe only difficulty would be for consecutive envelopes with the *same* sorted width. To avoid that, we can simply make sure that our sort function sorts height in descending order so that the first envelope encountered for any given width would be the largest one.\\n\\nAt the end of the longest increasing subsequence algorithm, the length of **dp** is equal to the length of the subsequence. Due to the sort function and the binary searches required for the algorithm, the time complexity now shrinks to **O(N log N)**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has a built-in binary search function, **bisect()**.\\n\\nJava has a built-in binary search function as well (**Arrays.binarySearch()**), but in order to use the more performant **int[]** rather than a **List< Integer >**, we\\'ll need to specify a max length for **dp** and then keep track of the current index of the longest subsequence separately in **ans**.\\n\\nC++ has a built-in binary search function, **lower_bound()**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.8MB** (beats 100% / 90%).\\n```javascript\\nvar maxEnvelopes = function(E) {\\n    E.sort((a,b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\\n    let len = E.length, dp = []\\n    for (let i = 0; i < len; i++) {\\n        let height = E[i][1], left = 0, right = dp.length   \\n        while (left < right) {\\n            let mid = (left + right) >> 1\\n            if (dp[mid] < height) left = mid + 1\\n            else right = mid\\n        }\\n        dp[left] = height\\n    }\\n    return dp.length\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **140ms / 16.4MB** (beats 97% / 85%).\\n```python\\nclass Solution:\\n    def maxEnvelopes(self, E: List[List[int]]) -> int:\\n        E.sort(key=lambda x: (x[0], -x[1]))\\n        dp = []\\n        for _,height in E:\\n            left = bisect_left(dp, height)\\n            if left == len(dp): dp.append(height)\\n            else: dp[left] = height\\n        return len(dp)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **7ms / 39.5MB** (beats 100% / 95%).\\n```java\\nclass Solution {\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **32ms / 15.9MB** (beats 99% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& E) {\\n        sort(E.begin(), E.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];});\\n        vector<int> dp;\\n        for (auto& env : E) {\\n            int height = env[1];\\n            int left = lower_bound(dp.begin(), dp.end(), height) - dp.begin();\\n            if (left == dp.size()) dp.push_back(height);\\n            dp[left] = height;\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxEnvelopes = function(E) {\\n    E.sort((a,b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\\n    let len = E.length, dp = []\\n    for (let i = 0; i < len; i++) {\\n        let height = E[i][1], left = 0, right = dp.length   \\n        while (left < right) {\\n            let mid = (left + right) >> 1\\n            if (dp[mid] < height) left = mid + 1\\n            else right = mid\\n        }\\n        dp[left] = height\\n    }\\n    return dp.length\\n};\\n```\n```python\\nclass Solution:\\n    def maxEnvelopes(self, E: List[List[int]]) -> int:\\n        E.sort(key=lambda x: (x[0], -x[1]))\\n        dp = []\\n        for _,height in E:\\n            left = bisect_left(dp, height)\\n            if left == len(dp): dp.append(height)\\n            else: dp[left] = height\\n        return len(dp)\\n```\n```java\\nclass Solution {\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& E) {\\n        sort(E.begin(), E.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];});\\n        vector<int> dp;\\n        for (auto& env : E) {\\n            int height = env[1];\\n            int left = lower_bound(dp.begin(), dp.end(), height) - dp.begin();\\n            if (left == dp.size()) dp.push_back(height);\\n            dp[left] = height;\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071459,
                "title": "c-o-nlogn-approach-lis-explaination-with-comments",
                "content": "```\\nclass Solution {\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        if(a[0]==b[0]) return a[1] > b[1];\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n = env.size();\\n        \\n        // sorting by height & if we encounter same height\\n        // sort by descending order of width\\n        sort(env.begin(), env.end(), cmp);\\n        \\n        // e.g. -> env => (3,8) (4,5) (2,1) (2,6) (7,8) (5,3) (5,7)\\n        // sorted version => (2,6) (2,1) (3,8) (4,5) (5,7) (5,3) (7,8)\\n        \\n        // Now, we only need to care about width\\n        // So, as of now we only need to look upon v[i][1]\\n        // [ 6, 1, 8, 5, 7, 3, 8 ]\\n        \\n        // Now, we can only put envolop a in envolop b another if width of a is\\n        // less than width of b, or we can say we need an envolop whose width\\n        // is just greater than envolop a ( height we have already handled )\\n        // So, we can think of lower_bound and Longest Increasing Subsequence\\n        \\n        // because we have sorted all envolopes of a particular height\\n        // by descending order of width, one envolope will not interfare with \\n        // another envolop of same height, if we apply lower_bound\\n        // i.e. first elem greater than equal to itself in lis\\n        \\n        vector<int> lis;\\n        \\n        for(int i = 0;i<env.size();i++){\\n            int ele = env[i][1];\\n            \\n            int idx = lower_bound(lis.begin(), lis.end(), ele) - lis.begin();\\n            \\n            if(idx >= lis.size()) lis.push_back(ele);\\n            else lis[idx] = ele;\\n        }\\n        \\n        return lis.size();\\n    }\\n};\\n```\\nPlease upvote if the concept is clear :)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        if(a[0]==b[0]) return a[1] > b[1];\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n = env.size();\\n        \\n        // sorting by height & if we encounter same height\\n        // sort by descending order of width\\n        sort(env.begin(), env.end(), cmp);\\n        \\n        // e.g. -> env => (3,8) (4,5) (2,1) (2,6) (7,8) (5,3) (5,7)\\n        // sorted version => (2,6) (2,1) (3,8) (4,5) (5,7) (5,3) (7,8)\\n        \\n        // Now, we only need to care about width\\n        // So, as of now we only need to look upon v[i][1]\\n        // [ 6, 1, 8, 5, 7, 3, 8 ]\\n        \\n        // Now, we can only put envolop a in envolop b another if width of a is\\n        // less than width of b, or we can say we need an envolop whose width\\n        // is just greater than envolop a ( height we have already handled )\\n        // So, we can think of lower_bound and Longest Increasing Subsequence\\n        \\n        // because we have sorted all envolopes of a particular height\\n        // by descending order of width, one envolope will not interfare with \\n        // another envolop of same height, if we apply lower_bound\\n        // i.e. first elem greater than equal to itself in lis\\n        \\n        vector<int> lis;\\n        \\n        for(int i = 0;i<env.size();i++){\\n            int ele = env[i][1];\\n            \\n            int idx = lower_bound(lis.begin(), lis.end(), ele) - lis.begin();\\n            \\n            if(idx >= lis.size()) lis.push_back(ele);\\n            else lis[idx] = ele;\\n        }\\n        \\n        return lis.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82808,
                "title": "c-9-line-short-and-clean-o-nlogn-solution-plus-classic-o-n-2-dp-solution",
                "content": "    ///O(nlogn)\\n\\n    struct Solution {\\n        int maxEnvelopes(vector<pair<int, int>>& es) {\\n            sort(es.begin(), es.end(), [](pair<int, int> a, pair<int, int> b){\\n                return a.first < b.first || (a.first == b.first && a.second > b.second);});\\n            vector<int> dp;\\n            for (auto e : es)\\n            {\\n                auto iter = lower_bound(dp.begin(), dp.end(), e.second);\\n                if (iter == dp.end())\\n                    dp.push_back(e.second);\\n                else if (e.second < *iter)\\n                    *iter = e.second;\\n            }\\n            return dp.size();\\n        }\\n    };\\n\\n    ///DP\\n    \\n    struct Solution {\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            if (envelopes.empty()) return 0;\\n            sort(envelopes.begin(), envelopes.end());\\n            vector<int> dp(envelopes.size(), 1);\\n            for (int i = 0; i < envelopes.size(); ++i)\\n                for (int j = 0; j < i; ++j)\\n                    if (envelopes[j].first < envelopes[i].first && envelopes[j].second < envelopes[i].second)\\n                        dp[i]  = max(dp[i] , dp[j] + 1);\\n            return *max_element(dp.begin(), dp.end());\\n        }\\n    };",
                "solutionTags": [],
                "code": "    ///O(nlogn)\\n\\n    struct Solution {\\n        int maxEnvelopes(vector<pair<int, int>>& es) {\\n            sort(es.begin(), es.end(), [](pair<int, int> a, pair<int, int> b){\\n                return a.first < b.first || (a.first == b.first && a.second > b.second);});\\n            vector<int> dp;\\n            for (auto e : es)\\n            {\\n                auto iter = lower_bound(dp.begin(), dp.end(), e.second);\\n                if (iter == dp.end())\\n                    dp.push_back(e.second);\\n                else if (e.second < *iter)\\n                    *iter = e.second;\\n            }\\n            return dp.size();\\n        }\\n    };\\n\\n    ///DP\\n    \\n    struct Solution {\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            if (envelopes.empty()) return 0;\\n            sort(envelopes.begin(), envelopes.end());\\n            vector<int> dp(envelopes.size(), 1);\\n            for (int i = 0; i < envelopes.size(); ++i)\\n                for (int j = 0; j < i; ++j)\\n                    if (envelopes[j].first < envelopes[i].first && envelopes[j].second < envelopes[i].second)\\n                        dp[i]  = max(dp[i] , dp[j] + 1);\\n            return *max_element(dp.begin(), dp.end());\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 82759,
                "title": "simple-dp-solution",
                "content": "    public int maxEnvelopes(int[][] envelopes) {\\n        if (   envelopes           == null\\n            || envelopes.length    == 0\\n            || envelopes[0]        == null\\n            || envelopes[0].length == 0){\\n            return 0;    \\n        }\\n        \\n        Arrays.sort(envelopes, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] e1, int[] e2){\\n                return Integer.compare(e1[0], e2[0]);\\n            }\\n        });\\n        \\n        int   n  = envelopes.length;\\n        int[] dp = new int[n];\\n        \\n        int ret = 0;\\n        for (int i = 0; i < n; i++){\\n            dp[i] = 1;\\n            \\n            for (int j = 0; j < i; j++){\\n                if (   envelopes[i][0] > envelopes[j][0]\\n                    && envelopes[i][1] > envelopes[j][1]){\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);    \\n                }\\n            }\\n            \\n            ret = Math.max(ret, dp[i]);\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "    public int maxEnvelopes(int[][] envelopes) {\\n        if (   envelopes           == null\\n            || envelopes.length    == 0\\n            || envelopes[0]        == null\\n            || envelopes[0].length == 0){\\n            return 0;    \\n        }\\n        \\n        Arrays.sort(envelopes, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] e1, int[] e2){\\n                return Integer.compare(e1[0], e2[0]);\\n            }\\n        });\\n        \\n        int   n  = envelopes.length;\\n        int[] dp = new int[n];\\n        \\n        int ret = 0;\\n        for (int i = 0; i < n; i++){\\n            dp[i] = 1;\\n            \\n            for (int j = 0; j < i; j++){\\n                if (   envelopes[i][0] > envelopes[j][0]\\n                    && envelopes[i][1] > envelopes[j][1]){\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);    \\n                }\\n            }\\n            \\n            ret = Math.max(ret, dp[i]);\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1134197,
                "title": "python-4-lines-solution-explained",
                "content": "There is  solution, if we use similar idea of Problems **300** (Longest Increading subsequence), because we want to find the longest increasing sub-sequence.  Check my solution https://leetcode.com/problems/longest-increasing-subsequence/discuss/667975/Python-3-Lines-dp-with-binary-search-explained\\n\\nActually we can done exactly the same as in 300,\\nbut when we sort we put envelopes with equal first elements [6,8], [6,7] it this opposite order\\nin this way we make sure that or longest increasing subsequence works like it is and we put into our dp table the second elements. For example if we have envelopes [1,3],[3,5],[6,8],[6,7],[8,4],[9,5], we work with [3,5,8,7,4,5] and look for longest increasing sequence here.\\n\\n```python\\nclass Solution:\\n    def maxEnvelopes(self, envelopes):\\n        nums = sorted(envelopes, key = lambda x: [x[0], -x[1]])    \\n        dp = [10**10] * (len(nums) + 1)\\n        for elem in nums: dp[bisect_left(dp, elem[1])] = elem[1]  \\n        return dp.index(10**10)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxEnvelopes(self, envelopes):\\n        nums = sorted(envelopes, key = lambda x: [x[0], -x[1]])    \\n        dp = [10**10] * (len(nums) + 1)\\n        for elem in nums: dp[bisect_left(dp, elem[1])] = elem[1]  \\n        return dp.index(10**10)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82761,
                "title": "python-o-nlogn-o-n-solution-beats-97-with-explanation",
                "content": "    class Solution(object):\\n        def maxEnvelopes(self, envs):\\n            def liss(envs):\\n                def lmip(envs, tails, k):\\n                    b, e = 0, len(tails) - 1\\n                    while b <= e:\\n                        m = (b + e) >> 1\\n                        if envs[tails[m]][1] >= k[1]:\\n                            e = m - 1\\n                        else:\\n                            b = m + 1\\n                    return b\\n                \\n                tails = []\\n                for i, env in enumerate(envs):\\n                    idx = lmip(envs, tails, env)\\n                    if idx >= len(tails):\\n                        tails.append(i)\\n                    else:\\n                        tails[idx] = i\\n                return len(tails)\\n            \\n            \\n            def f(x, y):\\n                return -1 if (x[0] < y[0] or x[0] == y[0] and x[1] > y[1]) else 1\\n                \\n            envs.sort(cmp=f)\\n            return liss(envs)\\n\\n    # Runtime: 100ms\\n\\nThe idea is to order the envelopes and then calculate the longest increasing subsequence (LISS). We first sort the envelopes by width, and we also make sure that when the width is the same, the envelope with greater height comes first. Why? This makes sure that when we calculate the LISS, we don't have a case such as [3, 4] [3, 5] (we could increase the LISS but this would be wrong as the width is the same. It can't happen when [3, 5] comes first in the ordering).\\n\\nWe could calculate the LISS using the standard DP algorithm (quadratic runtime), but we can just use the tails array method with a twist: we store the index of the tail, and we do leftmost insertion point as usual to find the right index in `nlogn` time. Why not rightmost? Think about the case [1, 1], [1, 1], [1, 1].",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    class Solution(object):\\n        def maxEnvelopes(self, envs):\\n            def liss(envs):\\n                def lmip(envs, tails, k):\\n                    b, e = 0, len(tails) - 1\\n                    while b <= e:\\n                        m = (b + e) >> 1\\n                        if envs[tails[m]][1] >= k[1]:\\n                            e = m - 1\\n                        else:\\n                            b = m + 1\\n                    return b\\n                \\n                tails = []\\n                for i, env in enumerate(envs):\\n                    idx = lmip(envs, tails, env)\\n                    if idx >= len(tails):\\n                        tails.append(i)\\n                    else:\\n                        tails[idx] = i\\n                return len(tails)\\n            \\n            \\n            def f(x, y):\\n                return -1 if (x[0] < y[0] or x[0] == y[0] and x[1] > y[1]) else 1\\n                \\n            envs.sort(cmp=f)\\n            return liss(envs)\\n\\n    # Runtime: 100ms\\n\\nThe idea is to order the envelopes and then calculate the longest increasing subsequence (LISS). We first sort the envelopes by width, and we also make sure that when the width is the same, the envelope with greater height comes first. Why? This makes sure that when we calculate the LISS, we don't have a case such as [3, 4] [3, 5] (we could increase the LISS but this would be wrong as the width is the same. It can't happen when [3, 5] comes first in the ordering).\\n\\nWe could calculate the LISS using the standard DP algorithm (quadratic runtime), but we can just use the tails array method with a twist: we store the index of the tail, and we do leftmost insertion point as usual to find the right index in `nlogn` time. Why not rightmost? Think about the case [1, 1], [1, 1], [1, 1].",
                "codeTag": "Java"
            },
            {
                "id": 82778,
                "title": "two-solutions-in-c-well-explained",
                "content": "### Solutions\\n\\n#### DP\\nIt's quite intuitive to adopt DP to solve this problem: \\n\\n- sorting the envelopes first via its first value (width)\\n- allocating an array to record the maximal amount for each envelope (the maximal amount we can get ending with the current envelope)\\n\\nDirectly the time cost here will be o(nlogn+n^2) which is o(n^2) and meantime taking up o(n) extra space.\\n\\n```\\nint maxenvelopes(vector<pair<int, int>>& envelopes) \\n{\\n\\tint size = envelopes.size();\\n\\tif(!size) return 0;\\n\\tsort(envelopes.begin(), envelopes.end());\\n\\tint maxrolls[size]{0}, maxroll = 1;\\n\\tmaxrolls[0] = 1;\\n\\tfor(int i = 1; i < size; ++i)\\n\\t{\\n\\t\\tmaxrolls[i] = 1;\\n\\t\\tfor(int j = i-1; j >= 0; --j)\\n\\t\\t\\tif(envelopes[i].first>envelopes[j].first && envelopes[i].second>envelopes[j].second)\\n\\t\\t\\t\\tmaxrolls[i] = max(maxrolls[i], maxrolls[j]+1);\\n\\t\\tmaxroll = max(maxroll, maxrolls[i]);\\n\\t}\\n\\treturn maxroll;\\n}\\n```\\n\\n#### LIS\\nActually here we are counting the **longest increasing sequence** as well except there are two dimensions we need to consider. And also we should remember the o(nlogn) solution in LIS, where the essential greedy concept is trying to \\n\\n1. make the all the elements in the collector as small as possible, especially the last one which is the gate to control the size of the collector - the longest length;\\n2. append the bigger ones to the collector;\\n\\nBut here we need to make some modifications since there are two dimensions to consider. To ensure the two dimensions array can be compressed into one dimension and meantime the requirements of the two conditions above are also properly met, just sorting is not enough here.\\n\\n- we need to convert this 2-dimentsion problem to a 1-dimension LIS: first sort the array via the width in ascending order and then sort the sub-array with the same width in descending order (the height) then the two conditions in LIS will also be met traversing from the smallest width to the biggest: and the height will be used as that in LIS - the last element will be updated to be as smaller as possible and meantime maintain the envelopes constraint since its width order will always be valid, furthermore the condition 2 is also met just as that in LIS.\\n\\n> **Note** if we do not sort the sub-arrays (with the same width) in descending order, the LIS in the height is then invalid. Suppose the sub-arrays are also sorted in ascending order, the height in the same width will be appended in our LIS method, wrong result. To sort the heights in the same width in descending order will avoid this case by updating the height in the same width since we are using `lower_bound`.\\n\\nTime complexity now becomes O(nlogn) taking up O(n) space.\\n\\n```\\nint maxEnvelopes(vector<pair<int, int>>& envelopes) \\n{\\n\\tint size = envelopes.size();\\n\\tsort(envelopes.begin(), envelopes.end(), [](pair<int, int> a, pair<int, int>b){\\n\\t\\treturn a.first<b.first || (a.first==b.first && a.second>b.second);\\n\\t});\\n\\tvector<int> collector;\\n\\tfor(auto& pair: envelopes)\\n\\t{\\n\\t\\tauto iter = lower_bound(collector.begin(), collector.end(), pair.second);\\n\\t\\tif(iter == collector.end()) collector.push_back(pair.second);\\n\\t\\telse if(*iter > pair.second) *iter = pair.second;\\n\\t}\\n\\treturn collector.size();\\n}\\n```\\n\\n##### lower_bound\\n- On random-access iterators, logarithmic in the distance between first and last: Performs approximately log2(N)+1 element comparisons (where N is this distance).\\n- On non-random-access iterators, the iterator advances produce themselves an additional linear complexity in N on average.\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nint maxenvelopes(vector<pair<int, int>>& envelopes) \\n{\\n\\tint size = envelopes.size();\\n\\tif(!size) return 0;\\n\\tsort(envelopes.begin(), envelopes.end());\\n\\tint maxrolls[size]{0}, maxroll = 1;\\n\\tmaxrolls[0] = 1;\\n\\tfor(int i = 1; i < size; ++i)\\n\\t{\\n\\t\\tmaxrolls[i] = 1;\\n\\t\\tfor(int j = i-1; j >= 0; --j)\\n\\t\\t\\tif(envelopes[i].first>envelopes[j].first && envelopes[i].second>envelopes[j].second)\\n\\t\\t\\t\\tmaxrolls[i] = max(maxrolls[i], maxrolls[j]+1);\\n\\t\\tmaxroll = max(maxroll, maxrolls[i]);\\n\\t}\\n\\treturn maxroll;\\n}\\n```\n```\\nint maxEnvelopes(vector<pair<int, int>>& envelopes) \\n{\\n\\tint size = envelopes.size();\\n\\tsort(envelopes.begin(), envelopes.end(), [](pair<int, int> a, pair<int, int>b){\\n\\t\\treturn a.first<b.first || (a.first==b.first && a.second>b.second);\\n\\t});\\n\\tvector<int> collector;\\n\\tfor(auto& pair: envelopes)\\n\\t{\\n\\t\\tauto iter = lower_bound(collector.begin(), collector.end(), pair.second);\\n\\t\\tif(iter == collector.end()) collector.push_back(pair.second);\\n\\t\\telse if(*iter > pair.second) *iter = pair.second;\\n\\t}\\n\\treturn collector.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 82801,
                "title": "c-time-o-nlogn-space-o-n-similar-to-lis-nlogn-solution",
                "content": "    bool cmp (pair<int, int> i, pair<int, int> j) {\\n        if (i.first == j.first)\\n            return i.second > j.second;\\n        return i.first < j.first;\\n    }\\n    \\n    class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            int N = envelopes.size();\\n            vector<int> candidates;\\n            sort(envelopes.begin(), envelopes.end(), cmp);\\n            for (int i = 0; i < N; i++) {\\n                int lo = 0, hi = candidates.size() - 1;\\n                while (lo <= hi) {\\n                    int mid = lo + (hi - lo)/2;\\n                    if (envelopes[i].second > envelopes[candidates[mid]].second)\\n                        lo = mid + 1;\\n                    else\\n                        hi = mid - 1;\\n                }\\n                if (lo == candidates.size())\\n                    candidates.push_back(i);\\n                else\\n                    candidates[lo] = i;\\n            }\\n            return candidates.size();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            int N = envelopes.size();\\n            vector<int> candidates;\\n            sort(envelopes.begin(), envelopes.end(), cmp);\\n            for (int i = 0; i < N; i++) {\\n                int lo = 0, hi = candidates.size() - 1;\\n                while (lo <= hi) {\\n                    int mid = lo + (hi - lo)/2;\\n                    if (envelopes[i].second > envelopes[candidates[mid]].second)\\n                        lo = mid + 1;\\n                    else\\n                        hi = mid - 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1134012,
                "title": "russian-doll-envelopes-js-python-java-c-easy-lis-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to try every single permutation of our envelope array (**E**), but that would be a **time complexity** of **O(N!)** which is frankly an incomprehensible number when **N** goes up to **5000**.\\n\\nAs the naive approach would involve repeating many of the same individual comparisons over and over again, we can quickly see that a **dynamic programming** (**DP**) solution would be beneficial.\\n\\nIn order for a DP solution to be effective, however, we\\'d need to find a way to progress from the easiest subsolution and build from there for each successively more complex subsolution. The best way to do this would be to sort **E** first by **width** (**E[i][0]**), and then by **height** (**E[i][1]**).\\n\\nThen we could start with the smallest envelope and work our way up, storing in our DP array (**dp**) the result of how many smaller envelopes it is possible to fit in the corresponding envelope. That way we could simplify each iteration to checking to see which of the entries in **dp** corresponding to smaller envelopes is the largest. This would drop the time complexity to **O(N^2)**, which is a definite improvement.\\n\\nBut it should also be apparent that if we were to define a **subsequence** of **E** that was the ideal nesting order of envelopes for the solution, then that array would be strictly increasing in *both* width and height.\\n\\nIf we\\'ve already sorted **E** primarily by width, we should then be able to consider a corresponding array of just the heights and realize that the solution would be defined as the [**longest increasing subsequence**](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) of that.\\n\\nThe only difficulty would be for consecutive envelopes with the *same* sorted width. To avoid that, we can simply make sure that our sort function sorts height in descending order so that the first envelope encountered for any given width would be the largest one.\\n\\nAt the end of the longest increasing subsequence algorithm, the length of **dp** is equal to the length of the subsequence. Due to the sort function and the binary searches required for the algorithm, the time complexity now shrinks to **O(N log N)**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has a built-in binary search function, **bisect()**.\\n\\nJava has a built-in binary search function as well (**Arrays.binarySearch()**), but in order to use the more performant **int[]** rather than a **List< Integer >**, we\\'ll need to specify a max length for **dp** and then keep track of the current index of the longest subsequence separately in **ans**.\\n\\nC++ has a built-in binary search function, **lower_bound()**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.8MB** (beats 100% / 90%).\\n```javascript\\nvar maxEnvelopes = function(E) {\\n    E.sort((a,b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\\n    let len = E.length, dp = []\\n    for (let i = 0; i < len; i++) {\\n        let height = E[i][1], left = 0, right = dp.length   \\n        while (left < right) {\\n            let mid = (left + right) >> 1\\n            if (dp[mid] < height) left = mid + 1\\n            else right = mid\\n        }\\n        dp[left] = height\\n    }\\n    return dp.length\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **140ms / 16.4MB** (beats 97% / 85%).\\n```python\\nclass Solution:\\n    def maxEnvelopes(self, E: List[List[int]]) -> int:\\n        E.sort(key=lambda x: (x[0], -x[1]))\\n        dp = []\\n        for _,height in E:\\n            left = bisect_left(dp, height)\\n            if left == len(dp): dp.append(height)\\n            else: dp[left] = height\\n        return len(dp)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **7ms / 39.5MB** (beats 100% / 95%).\\n```java\\nclass Solution {\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **32ms / 15.9MB** (beats 99% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& E) {\\n        sort(E.begin(), E.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];});\\n        vector<int> dp;\\n        for (auto& env : E) {\\n            int height = env[1];\\n            int left = lower_bound(dp.begin(), dp.end(), height) - dp.begin();\\n            if (left == dp.size()) dp.push_back(height);\\n            dp[left] = height;\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar maxEnvelopes = function(E) {\\n    E.sort((a,b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\\n    let len = E.length, dp = []\\n    for (let i = 0; i < len; i++) {\\n        let height = E[i][1], left = 0, right = dp.length   \\n        while (left < right) {\\n            let mid = (left + right) >> 1\\n            if (dp[mid] < height) left = mid + 1\\n            else right = mid\\n        }\\n        dp[left] = height\\n    }\\n    return dp.length\\n};\\n```\n```python\\nclass Solution:\\n    def maxEnvelopes(self, E: List[List[int]]) -> int:\\n        E.sort(key=lambda x: (x[0], -x[1]))\\n        dp = []\\n        for _,height in E:\\n            left = bisect_left(dp, height)\\n            if left == len(dp): dp.append(height)\\n            else: dp[left] = height\\n        return len(dp)\\n```\n```java\\nclass Solution {\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& E) {\\n        sort(E.begin(), E.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];});\\n        vector<int> dp;\\n        for (auto& env : E) {\\n            int height = env[1];\\n            int left = lower_bound(dp.begin(), dp.end(), height) - dp.begin();\\n            if (left == dp.size()) dp.push_back(height);\\n            dp[left] = height;\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82751,
                "title": "o-nlog-n-python-solution-explained",
                "content": "Sort the envelopes first by increasing width. For each block of same-width envelopes, sort by decreasing height.\\n\\nThen find the longest increasing subsequence of heights.\\n\\nSince each same-width subarray is non-increasing  in height, we can never pick more than one height within each width (otherwise heights would be non-increasing)\\n\\nThus, the resulting longest increasing heights subsequence is also increasing in width.\\n\\nExample:\\n\\n**input**\\n\\n    [[5,4],[6,4],[6,7],[2,3]]\\n\\nsort by increasing widths, then decreasing heights:\\n\\n    [[2,3],[5,4],[6,7],[6,4]]\\n\\nGet the heights:\\n\\n    [3,4,7,4]\\n\\nFind the length longest increasing subsequence:\\n\\n    [3,4,7]\\n\\n(Note that we could not have picked more than one evelope with width 6)\\n\\nAnswer: 3\\n```\\nclass Solution(object):\\n    def maxEnvelopes(self, envs):\\n        \"\"\"\\n        :type envelopes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # sort first by increasing width\\n        # within each subarray of same-width envelopes\\n        # sort by decreasing height\\n        envs.sort(key=lambda (w,h): (w,-h))\\n        \\n        # now find the length of the longest increasing subsequence of heights.\\n        # Since each same-width block was sorted non-increasing, \\n        # we can only pick at most one height within each block\\n        # otherwise, the sequence would be non-increasing\\n        tails=[]\\n        for (w,h) in envs:\\n            idx=bisect.bisect_left(tails, h)\\n            if idx==len(tails):\\n                tails.append(h)                        \\n            elif idx==0 or tails[idx-1]<h:\\n                tails[idx]=h\\n        return len(tails)    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxEnvelopes(self, envs):\\n        \"\"\"\\n        :type envelopes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # sort first by increasing width\\n        # within each subarray of same-width envelopes\\n        # sort by decreasing height\\n        envs.sort(key=lambda (w,h): (w,-h))\\n        \\n        # now find the length of the longest increasing subsequence of heights.\\n        # Since each same-width block was sorted non-increasing, \\n        # we can only pick at most one height within each block\\n        # otherwise, the sequence would be non-increasing\\n        tails=[]\\n        for (w,h) in envs:\\n            idx=bisect.bisect_left(tails, h)\\n            if idx==len(tails):\\n                tails.append(h)                        \\n            elif idx==0 or tails[idx-1]<h:\\n                tails[idx]=h\\n        return len(tails)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071626,
                "title": "python-lis-based-approach",
                "content": "The prerequisite for this problem is to understand and solve [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/). So if you are familiar with LIS and have solved it, the difficulty of this problem is reduced.\\n\\nNow, before we can start implementing LIS for this problem, we need to determine the sort order of the input `envelopes`.  You can read this post which explains how the sort order is determined ->  [Explanation on which sort order to choose](https://leetcode.com/problems/russian-doll-envelopes/discuss/2071477/Best-Explanation-with-Pictures)\\n\\n**Time - O(nlogn)** - Time required for sorting and performing LIS\\n**Space - O(n)** - space required for `res`.\\n\\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        \\n        res = []\\t\\t\\n\\t\\t# Perform LIS\\n        for _, h in envelopes:\\n            l,r=0,len(res)-1\\n\\t\\t\\t# find the insertion point in the Sort order\\n            while l <= r:\\n                mid=(l+r)>>1\\n                if res[mid]>=h:\\n                    r=mid-1\\n                else:\\n                    l=mid+1        \\n            idx = l\\n            if idx == len(res):\\n                res.append(h)\\n            else:\\n                res[idx]=h\\n        return len(res)\\n                                               \\n```\\n\\nWe can make the above code more concise by using a python library `bisect_left` to locate the insertion point in the sort order. \\n\\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))        \\n        res = []\\n        for _, h in envelopes:\\n            idx = bisect_left(res, h)\\n            if idx == len(res):\\n                res.append(h)\\n            else:\\n                res[idx]=h\\n        return len(res)                                                                                              \\n```\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        \\n        res = []\\t\\t\\n\\t\\t# Perform LIS\\n        for _, h in envelopes:\\n            l,r=0,len(res)-1\\n\\t\\t\\t# find the insertion point in the Sort order\\n            while l <= r:\\n                mid=(l+r)>>1\\n                if res[mid]>=h:\\n                    r=mid-1\\n                else:\\n                    l=mid+1        \\n            idx = l\\n            if idx == len(res):\\n                res.append(h)\\n            else:\\n                res[idx]=h\\n        return len(res)\\n                                               \\n```\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))        \\n        res = []\\n        for _, h in envelopes:\\n            idx = bisect_left(res, h)\\n            if idx == len(res):\\n                res.append(h)\\n            else:\\n                res[idx]=h\\n        return len(res)                                                                                              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 82810,
                "title": "short-and-simple-java-solution-15-lines",
                "content": " \\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);\\n        int max = 0;\\n        int dp [] = new int [envelopes.length];\\n        for(int i = 0; i < envelopes.length; i++){\\n            dp[i] = 1;\\n            for(int j = 0; j < i; j++){\\n                if(envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1])\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": " \\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);\\n        int max = 0;\\n        int dp [] = new int [envelopes.length];\\n        for(int i = 0; i < envelopes.length; i++){\\n            dp[i] = 1;\\n            for(int j = 0; j < i; j++){\\n                if(envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1])\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1135751,
                "title": "95-faster-c-n-log-n-using-binary-search-lis-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>&a , vector<int>& b)\\n    {\\n      return a[0]==b[0]?a[1]>b[1]:a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>&a) {\\n      sort(a.begin(),a.end(),compare);\\n      vector<int>dp;\\n      for(auto i:a)\\n      {\\n        auto it=lower_bound(dp.begin(),dp.end(),i[1]);\\n        if(it==dp.end())\\n          dp.push_back(i[1]);\\n        else\\n          *it=i[1];\\n      }\\n      return dp.size();\\n    }\\n};\\n```\\n**Upvote if this help you**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>&a , vector<int>& b)\\n    {\\n      return a[0]==b[0]?a[1]>b[1]:a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>&a) {\\n      sort(a.begin(),a.end(),compare);\\n      vector<int>dp;\\n      for(auto i:a)\\n      {\\n        auto it=lower_bound(dp.begin(),dp.end(),i[1]);\\n        if(it==dp.end())\\n          dp.push_back(i[1]);\\n        else\\n          *it=i[1];\\n      }\\n      return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82753,
                "title": "10-lines-python-code-beats-96",
                "content": "```\\nclass Solution(object):\\n    def maxEnvelopes(self, envelopes):\\n        des_ht = [a[1] for a in sorted(envelopes, key = lambda x: (x[0], -x[1]))]\\n        dp, l = [0] * len(des_ht), 0\\n        for x in des_ht:\\n            i = bisect.bisect_left(dp, x, 0, l)\\n            dp[i] = x\\n            if i == l:\\n                l+=1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxEnvelopes(self, envelopes):\\n        des_ht = [a[1] for a in sorted(envelopes, key = lambda x: (x[0], -x[1]))]\\n        dp, l = [0] * len(des_ht), 0\\n        for x in des_ht:\\n            i = bisect.bisect_left(dp, x, 0, l)\\n            dp[i] = x\\n            if i == l:\\n                l+=1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734526,
                "title": "java-lis-revisited-binary-search-best-explanation",
                "content": "**Please upvote if you like the soltion**\\n<details>\\n\\t<summary>Prerequisite</summary>\\n\\t<br>\\n\\tBefore moving on to the solution, you should know how can we find the length of <strong>Longest Increasing Subsequence</strong> unsing <strong>Binary Search</strong>. You can find the detailed explanation of the logic on the below link.                                        \\n\\t</br>\\n\\t<br></br>\\n\\t<a href=\"https://leetcode.com/problems/longest-increasing-subsequence/discuss/1636162/java-binary-search-stepwise-explanation\">Longest Increasing Subsequence Using Binary Search</a>\\n</details>\\n<br></br>\\n\\n#### Why we need to sort?\\n* In these types of problem when we are dealing with two dimensions, we need to reduce the problem from two-dimensional array into a one-dimensional array in order to improve time complexity. \\n* **\"Sort first when things are undecided\"**, sorting can make the data orderly, reduce the degree of confusion, and often help us to sort out our thinking. the same is true with this question. Now, after doing the correct sorting, we just need to find Longest Increasing Subsequence of that one dimensional array.\\n**Now, you may be wondered what correct sorting actually is?**\\nIt is the sorting which we do to order to achieve the answer. Like, increasing, non-increasing sorting. Without any further discussion, let\\'s dig into Intuition followed by algorithm.\\n\\n##### Algorithm\\n* We sort the array in increasing order of width. And if two widths are same, we need to sort height in decreasing order. \\n* Now why we need to sort in decreasing order if two widths are same. By this practice, we\\'re assuring that no width will get counted more than one time. Let\\'s take an example\\nenvelopes=`[[3, 5], [6, 7], [7, 13], [6, 10], [8, 4], [7, 11]]`\\n![image](https://assets.leetcode.com/users/images/b8e49902-0d0c-477f-a396-2fbc04b4f59b_1643640325.8523316.png)\\nNow, if you see for a while, **6 and 7** is counted twice while we\\'re calculating the length of LIS, which will give the wrong ans. As question is asking, if any width/height are less than or equal, then, it is not possible to russian doll these envelopes. \\nNow, we know the problem. So, how can we tackle these conditions when two width are same, so that it won\\'t affect our answer. We can simple **reverse sort the height if two width are equal, to remove duplicacy.**\\nNow, you may question, how reverse sorting the height would remove duplicacy? As the name itself says, Longest Increasing Subsequnce, the next coming height would be less than the previous one. Hence, forbidding it to increase length count.\\n![image](https://assets.leetcode.com/users/images/31add436-310d-452d-b696-f7faff8ce2f6_1643641876.2816072.png)\\nIf you don\\'t understand how LIS is calculated here, I strongly refer you to follow the prerequisite.\\nNow, we have **sucessfully reduced the problem to LIS!** All you need to apply classical LIS on heights, to calculate the ans. This would be the maximum number of envelopes can be russian doll.\\n\\n**Code**\\n\\n```\\nclass Solution {\\n    public int binarySearch(int[] dp, int val){\\n        int lo=0,hi=dp.length-1,res=0;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(dp[mid]<val){\\n                res=mid;\\n                lo=mid+1;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        return res+1;\\n    }\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\\n        int[] LIS=new int[envelopes.length+1];\\n        Arrays.fill(LIS,Integer.MAX_VALUE);\\n        LIS[0]=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<envelopes.length;i++){\\n            int val=envelopes[i][1];\\n            int insertIndex=binarySearch(LIS,val);\\n            ans=Math.max(ans,insertIndex);\\n            if(LIS[insertIndex]>=val){\\n                LIS[insertIndex]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nNow, if you compare the code of this problem with the classical LIS, it is very similar. Infact, we have added only one line to get the maximum Russian Doll.\\n\\n`Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);`\\n\\nTime Complexity- **O(nlogn)**\\nSpace Complexity- **O(n)**\\n\\n##### If you like the explanation, please upvote\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int binarySearch(int[] dp, int val){\\n        int lo=0,hi=dp.length-1,res=0;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(dp[mid]<val){\\n                res=mid;\\n                lo=mid+1;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        return res+1;\\n    }\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\\n        int[] LIS=new int[envelopes.length+1];\\n        Arrays.fill(LIS,Integer.MAX_VALUE);\\n        LIS[0]=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<envelopes.length;i++){\\n            int val=envelopes[i][1];\\n            int insertIndex=binarySearch(LIS,val);\\n            ans=Math.max(ans,insertIndex);\\n            if(LIS[insertIndex]>=val){\\n                LIS[insertIndex]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133907,
                "title": "c-classic-dp-problem-variant",
                "content": "**Variant of Classic DP - LIS problem :**\\nTime Complexity - O(n^2)\\nSpace Complexity - O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(begin(envelopes),end(envelopes),[]\\n             (const vector<int> &a,const vector<int> &b){\\n                 return (a[0]==b[0] ? a[1]<b[1] : a[0]<b[0]);\\n             });\\n\\t\\t\\t \\n        vector<int> dp(envelopes.size(),1);\\n\\t\\t\\n        for(int i=1;i<envelopes.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(envelopes[j][0]<envelopes[i][0]  &&  envelopes[j][1]<envelopes[i][1]){\\n                    if(dp[i]<dp[j]+1)\\n                        dp[i]=dp[j]+1;\\n                }\\n            }\\n        }\\n        return *max_element(begin(dp),end(dp));\\n    }\\n};\\n```\\n\\nEdit1 :- It can be done in O(nlogn) as well. Will include that approach later.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(begin(envelopes),end(envelopes),[]\\n             (const vector<int> &a,const vector<int> &b){\\n                 return (a[0]==b[0] ? a[1]<b[1] : a[0]<b[0]);\\n             });\\n\\t\\t\\t \\n        vector<int> dp(envelopes.size(),1);\\n\\t\\t\\n        for(int i=1;i<envelopes.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(envelopes[j][0]<envelopes[i][0]  &&  envelopes[j][1]<envelopes[i][1]){\\n                    if(dp[i]<dp[j]+1)\\n                        dp[i]=dp[j]+1;\\n                }\\n            }\\n        }\\n        return *max_element(begin(dp),end(dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218424,
                "title": "the-best-answer-your-e-looking-for-recursion-memoization-tabulation-1d-optimization-binary-search",
                "content": "# Recursion (gives TLE at test 57)\\n```\\nclass Solution {\\npublic:\\n    int f(int curr,int prev,vector<vector<int>>& envelopes){\\n        if(curr==envelopes.size()){\\n            return 0;\\n        }\\n        int notTake=0+f(curr+1,prev,envelopes);\\n        int take=-1e9;\\n        if(prev==-1 or (envelopes[prev][0]<envelopes[curr][0] and envelopes[prev][1]     <envelopes[curr][1])){\\n                take=1+f(curr+1,curr,envelopes);\\n        }\\n        return max(take,notTake);\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end());\\n        return f(0,-1,envelopes);\\n    }\\n};\\n```\\n\\n# Memoization (gives TLE at test 83)\\n```\\nclass Solution {\\npublic:\\n    int f(int curr,int prev,vector<vector<int>>& envelopes,vector<vector<int>> &dp){\\n        if(curr==envelopes.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){\\n            return dp[curr][prev+1];\\n        }\\n        int notTake=0+f(curr+1,prev,envelopes,dp);\\n        int take=-1e9;\\n        if(prev==-1 or (envelopes[prev][0]<envelopes[curr][0] and envelopes[prev][1]     <envelopes[curr][1])){\\n                take=1+f(curr+1,curr,envelopes,dp);\\n        }\\n        return dp[curr][prev+1]=max(take,notTake);\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end());\\n        int n=envelopes.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return f(0,-1,envelopes,dp);\\n    }\\n};\\n```\\n\\n# Tabulation (gives TLE at test 85)\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end());\\n        int n=envelopes.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int curr=n-1;curr>=0;curr--){\\n            for(int prev=curr-1;prev>=-1;prev--){\\n                int notTake=0+dp[curr+1][prev+1];\\n                int take=-1e9;\\n                if(prev==-1 or (envelopes[prev][0]<envelopes[curr][0] and envelopes[prev][1]<envelopes[curr][1])){\\n                        take=1+dp[curr+1][curr+1];\\n                }\\n             dp[curr][prev+1]=max(take,notTake); \\n            }\\n        }\\n        return dp[0][0];\\n          \\n    }\\n};\\n```\\n\\n# 1D array optimization (gives TLE at test 85)\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end());\\n        int n=envelopes.size();\\n        vector<int>next(n+1,0),currr(n+1,0);\\n        for(int curr=n-1;curr>=0;curr--){\\n            for(int prev=curr-1;prev>=-1;prev--){\\n                int notTake=0+next[prev+1];\\n                int take=-1e9;\\n                if(prev==-1 or (envelopes[prev][0]<envelopes[curr][0] and envelopes[prev][1]<envelopes[curr][1])){\\n                        take=1+next[curr+1];\\n                }\\n             currr[prev+1]=max(take,notTake); \\n            }\\n            next=currr;\\n        }\\n        return currr[-1+1];\\n    }\\n};\\n```\\n\\n# Binary Search (Final asnwer)\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a,vector<int>&b){\\n        if(a[0]==b[0]){\\n            return a[1]>b[1];\\n        }\\n        else{\\n            return a[0]<b[0];\\n        }\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end(),comp);\\n        vector<int> temp;\\n        temp.push_back(envelopes[0][1]);\\n        for(int i=1;i<envelopes.size();i++){\\n            if(temp.back()<envelopes[i][1]){\\n                temp.push_back(envelopes[i][1]);\\n            }\\n            else{\\n                auto ind=lower_bound(temp.begin(),temp.end(),envelopes[i][1])-temp.begin();\\n                temp[ind]=envelopes[i][1];\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int curr,int prev,vector<vector<int>>& envelopes){\\n        if(curr==envelopes.size()){\\n            return 0;\\n        }\\n        int notTake=0+f(curr+1,prev,envelopes);\\n        int take=-1e9;\\n        if(prev==-1 or (envelopes[prev][0]<envelopes[curr][0] and envelopes[prev][1]     <envelopes[curr][1])){\\n                take=1+f(curr+1,curr,envelopes);\\n        }\\n        return max(take,notTake);\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end());\\n        return f(0,-1,envelopes);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int curr,int prev,vector<vector<int>>& envelopes,vector<vector<int>> &dp){\\n        if(curr==envelopes.size()){\\n            return 0;\\n        }\\n        if(dp[curr][prev+1]!=-1){\\n            return dp[curr][prev+1];\\n        }\\n        int notTake=0+f(curr+1,prev,envelopes,dp);\\n        int take=-1e9;\\n        if(prev==-1 or (envelopes[prev][0]<envelopes[curr][0] and envelopes[prev][1]     <envelopes[curr][1])){\\n                take=1+f(curr+1,curr,envelopes,dp);\\n        }\\n        return dp[curr][prev+1]=max(take,notTake);\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end());\\n        int n=envelopes.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return f(0,-1,envelopes,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end());\\n        int n=envelopes.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int curr=n-1;curr>=0;curr--){\\n            for(int prev=curr-1;prev>=-1;prev--){\\n                int notTake=0+dp[curr+1][prev+1];\\n                int take=-1e9;\\n                if(prev==-1 or (envelopes[prev][0]<envelopes[curr][0] and envelopes[prev][1]<envelopes[curr][1])){\\n                        take=1+dp[curr+1][curr+1];\\n                }\\n             dp[curr][prev+1]=max(take,notTake); \\n            }\\n        }\\n        return dp[0][0];\\n          \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end());\\n        int n=envelopes.size();\\n        vector<int>next(n+1,0),currr(n+1,0);\\n        for(int curr=n-1;curr>=0;curr--){\\n            for(int prev=curr-1;prev>=-1;prev--){\\n                int notTake=0+next[prev+1];\\n                int take=-1e9;\\n                if(prev==-1 or (envelopes[prev][0]<envelopes[curr][0] and envelopes[prev][1]<envelopes[curr][1])){\\n                        take=1+next[curr+1];\\n                }\\n             currr[prev+1]=max(take,notTake); \\n            }\\n            next=currr;\\n        }\\n        return currr[-1+1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a,vector<int>&b){\\n        if(a[0]==b[0]){\\n            return a[1]>b[1];\\n        }\\n        else{\\n            return a[0]<b[0];\\n        }\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end(),comp);\\n        vector<int> temp;\\n        temp.push_back(envelopes[0][1]);\\n        for(int i=1;i<envelopes.size();i++){\\n            if(temp.back()<envelopes[i][1]){\\n                temp.push_back(envelopes[i][1]);\\n            }\\n            else{\\n                auto ind=lower_bound(temp.begin(),temp.end(),envelopes[i][1])-temp.begin();\\n                temp[ind]=envelopes[i][1];\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494335,
                "title": "backtracking-solution-that-you-will-be-expected-to-provide-in-interviews-accepted",
                "content": "The O(nlogn) solution is unreasonable for an interviewer to expect. The solution below should be more than sufficient for you to pass the interview:\\n\\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        // Sort in increasing order by\\n        // any dimension.\\n        // This is an optimization.\\n        if (envelopes.length == 0) return 0;\\n        Arrays.sort(envelopes, (a,b) -> { \\n            if (a[0] != b[0])\\n                return a[0] - b[0];\\n            return a[1] - b[1];\\n        });\\n        \\n        // We will cache hits\\n        HashMap<Integer, Integer> cache = new HashMap<>();\\n        return maxEnvelopes(envelopes, 0, -1, cache);\\n    }\\n    \\n    int maxEnvelopes(int[][] envelopes, int index, int prevIndex, HashMap<Integer, Integer> cache) {\\n        if (index == envelopes.length)\\n            return 0;\\n        \\n        int included = 0;\\n        // included\\n        if (prevIndex == -1 || (envelopes[index][0] > envelopes[prevIndex][0] \\n                               && envelopes[index][1] > envelopes[prevIndex][1])){\\n            if (cache.containsKey(index)){\\n                included = cache.get(index);\\n            } else {\\n                included = 1 + maxEnvelopes(envelopes, index + 1, index, cache);\\n                // Note that hits are only cached for an index\\n                // when we know that the condition that prev is\\n                // less than current is satisifed\\n                cache.put(index, included);\\n            }\\n        }\\n        \\n        int skipped = maxEnvelopes(envelopes, index + 1, prevIndex, cache);\\n        \\n        return Math.max(skipped, included);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        // Sort in increasing order by\\n        // any dimension.\\n        // This is an optimization.\\n        if (envelopes.length == 0) return 0;\\n        Arrays.sort(envelopes, (a,b) -> { \\n            if (a[0] != b[0])\\n                return a[0] - b[0];\\n            return a[1] - b[1];\\n        });\\n        \\n        // We will cache hits\\n        HashMap<Integer, Integer> cache = new HashMap<>();\\n        return maxEnvelopes(envelopes, 0, -1, cache);\\n    }\\n    \\n    int maxEnvelopes(int[][] envelopes, int index, int prevIndex, HashMap<Integer, Integer> cache) {\\n        if (index == envelopes.length)\\n            return 0;\\n        \\n        int included = 0;\\n        // included\\n        if (prevIndex == -1 || (envelopes[index][0] > envelopes[prevIndex][0] \\n                               && envelopes[index][1] > envelopes[prevIndex][1])){\\n            if (cache.containsKey(index)){\\n                included = cache.get(index);\\n            } else {\\n                included = 1 + maxEnvelopes(envelopes, index + 1, index, cache);\\n                // Note that hits are only cached for an index\\n                // when we know that the condition that prev is\\n                // less than current is satisifed\\n                cache.put(index, included);\\n            }\\n        }\\n        \\n        int skipped = maxEnvelopes(envelopes, index + 1, prevIndex, cache);\\n        \\n        return Math.max(skipped, included);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538587,
                "title": "c-recursion-memoization-binarysearch",
                "content": "# Method -1 [Recursion] Gives TLE!\\n![image](https://assets.leetcode.com/users/images/1530a62f-ec33-4ff3-8bbb-4b3299483ad7_1662447073.3290262.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t//     LIS\\n\\t\\tint f(int i,int prev,vector<vector<int>>& env,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tint pick=INT_MIN;\\n\\t\\t\\tif(prev==-1 || env[prev][0]<env[i][0] && env[prev][1]<env[i][1]) pick=1+f(i+1,i,env,n);\\n\\t\\t\\tint notpick=f(i+1,prev,env,n);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint maxEnvelopes(vector<vector<int>>& env) {\\n\\t\\t\\tint n=env.size();\\n\\t\\t\\tsort(env.begin(),env.end());   \\n\\t\\t\\treturn f(0,-1,env,n);\\n\\t\\t}\\n\\t};\\n\\n# Method - 2 [Memoization] Gives TLE!!\\n![image](https://assets.leetcode.com/users/images/cbe4275e-10a2-461d-8b6f-078ffc8d3284_1662447245.8835037.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t//     LIS\\n\\t\\tint f(int i,int prev,vector<vector<int>>& env,int n,vector<vector<int>>& dp){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tif(dp[i][prev+1]!=-1) return dp[i][prev+1];\\n\\t\\t\\tint pick=INT_MIN;\\n\\t\\t\\tif(prev==-1 || (env[prev][0]<env[i][0] && env[prev][1]<env[i][1])) pick=1+f(i+1,i,env,n,dp);\\n\\t\\t\\tint notpick=f(i+1,prev,env,n,dp);\\n\\t\\t\\treturn dp[i][prev+1]=max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint maxEnvelopes(vector<vector<int>>& env) {\\n\\t\\t\\tint n=env.size();\\n\\t\\t\\tsort(env.begin(),env.end());   \\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n+1,-1));\\n\\t\\t\\treturn f(0,-1,env,n,dp);\\n\\t\\t}\\n\\t};\\t\\n\\t\\n***Since we can not reduce the TC further by Tabulation thus we have to apply Binary Search!**\\n\\n# Method - 3 [Binary Search] \\n\\n![image](https://assets.leetcode.com/users/images/d1dbbf1d-cc0b-49c7-891f-7a60981db60d_1662447269.8608131.png)\\n\\n\\n**T->O(nlogn) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstatic bool comp(vector<int>& a,vector<int>& b){\\n\\t\\t\\tif(a[0]==b[0]) return a[1]>b[1];\\n\\t\\t\\treturn a[0]<b[0];\\n\\t\\t}\\n\\n\\t\\tint maxEnvelopes(vector<vector<int>>& env) {\\n\\t\\t\\tint n=env.size();\\n\\t\\t\\tsort(env.begin(),env.end(),comp);   \\n\\t\\t\\tvector<int> temp;\\n\\t\\t\\ttemp.push_back(env[0][1]);\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(temp.back()<env[i][1]) temp.push_back(env[i][1]);\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint ind=lower_bound(temp.begin(),temp.end(),env[i][1])-temp.begin();\\n\\t\\t\\t\\t\\ttemp[ind]=env[i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn temp.size();\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t//     LIS\\n\\t\\tint f(int i,int prev,vector<vector<int>>& env,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tint pick=INT_MIN;\\n\\t\\t\\tif(prev==-1 || env[prev][0]<env[i][0] && env[prev][1]<env[i][1]) pick=1+f(i+1,i,env,n);\\n\\t\\t\\tint notpick=f(i+1,prev,env,n);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2071521,
                "title": "russian-doll-envelopes-simple-c-solution-dynamic-programming",
                "content": "Simple C++ solution \\nUsing dynamic programming\\n\\n``` \\n   int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n  sort(envelopes.begin(), envelopes.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];});\\n        vector<int> dp;\\n        for (auto& env : envelopes) {\\n            int height = env[1];\\n            int left = lower_bound(dp.begin(), dp.end(), height) - dp.begin();\\n            \\n            if (left == dp.size()) dp.push_back(height);\\n            dp[left] = height;\\n        }\\n        return dp.size();\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "``` \\n   int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n  sort(envelopes.begin(), envelopes.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];});\\n        vector<int> dp;\\n        for (auto& env : envelopes) {\\n            int height = env[1];\\n            int left = lower_bound(dp.begin(), dp.end(), height) - dp.begin();\\n            \\n            if (left == dp.size()) dp.push_back(height);\\n            dp[left] = height;\\n        }\\n        return dp.size();\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071387,
                "title": "java-solution-10-lines",
                "content": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[envelopes.length];\\n        int ans = 0;\\n        for (int[] env : envelopes) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[envelopes.length];\\n        int ans = 0;\\n        for (int[] env : envelopes) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480224,
                "title": "c-dp-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        if (envelopes.empty()) return 0;\\n        sort(envelopes.begin(), envelopes.end());\\n        vector<int> dp(envelopes.size(), 1);\\n        for (int i = 0; i < envelopes.size(); ++i)\\n            for (int j = 0; j < i; ++j)\\n                if (envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1])\\n                    dp[i]  = max(dp[i] , dp[j] + 1);\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        if (envelopes.empty()) return 0;\\n        sort(envelopes.begin(), envelopes.end());\\n        vector<int> dp(envelopes.size(), 1);\\n        for (int i = 0; i < envelopes.size(); ++i)\\n            for (int j = 0; j < i; ++j)\\n                if (envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1])\\n                    dp[i]  = max(dp[i] , dp[j] + 1);\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134299,
                "title": "java-lis-application",
                "content": "**Explanation:**\\nBasically its an 2-D version of [longest-increasing-subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) and there is a 3-D version also which is very popular interview problem of Codenation and Google [Box-stacking] .\\n\\nNote: `One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.`\\neg : envelope = [[5,4],[6,4],[6,7],[2,3]]\\nAfter sorting\\n```\\n\\n2   5   6   6\\n3   4   7   4\\n[6,7] is placed before [6,4] because if we select 7 we have to discard 4 as they both have width same.\\n```\\n**Approch 1: Comparable Based**\\n**CODE:**\\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Pair[] arr=new Pair[envelopes.length];\\n        for(int i=0;i<arr.length;i++){\\n            int[] nums=envelopes[i];\\n            int w=nums[0];\\n            int h=nums[1];\\n            Pair np=new Pair(w,h);\\n            arr[i]=np;\\n        }\\n          Arrays.sort(arr);\\n       \\n         return LIS(arr);\\n    }\\n    \\n    private int LIS(Pair[] arr){\\n          int ans=0;\\n          int[] minele=new int[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            int val=arr[i].h;\\n            int lo=0, hi=ans;\\n            \\n            while(lo<hi){\\n                int mid=(lo + hi)/2;\\n                if(minele[mid]<val){\\n                    lo=mid+1;\\n                }else{\\n                    hi=mid;\\n                }\\n            }\\n            minele[lo]=val;\\n            \\n            if(lo==ans){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public static class Pair implements Comparable<Pair>{\\n        int w;\\n        int h;\\n        \\n        Pair(int w,int h){\\n            this.w=w;\\n            this.h=h;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair other){\\n            if(this.w==other.w) return other.h -this.h;\\n            return this.w-other.w;\\n        }\\n    }\\n}\\n```\\n**Complexity :**\\n`Time : O(nlogn) and Space:O(n)`\\n\\n**Approch2 : Comparator Based\\nCODE:**\\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n         Arrays.sort(envelopes,new EnvelopeComparator());\\n         return LIS(envelopes);\\n    }\\n    \\n    private int LIS(int[][] arr){\\n          int ans=0;\\n          int[] minele=new int[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            int val=arr[i][1];\\n            int lo=0, hi=ans;\\n            \\n            while(lo<hi){\\n                int mid=(lo + hi)/2;\\n                if(minele[mid]<val){\\n                    lo=mid+1;\\n                }else{\\n                    hi=mid;\\n                }\\n            }\\n            minele[lo]=val;\\n            \\n            if(lo==ans){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public class EnvelopeComparator implements Comparator<int[]>{\\n        @Override\\n        public int compare(int[] one,int[] two){\\n            if(one[0]==two[0]) return two[1]-one[1];\\n            return one[0]-two[0];\\n        }\\n    }\\n}\\n```\\n**COMPLEXITY:** `TIME:O(NLOGN) AND SPACE:O(N)(minele array space)`\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n\\n2   5   6   6\\n3   4   7   4\\n[6,7] is placed before [6,4] because if we select 7 we have to discard 4 as they both have width same.\\n```\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Pair[] arr=new Pair[envelopes.length];\\n        for(int i=0;i<arr.length;i++){\\n            int[] nums=envelopes[i];\\n            int w=nums[0];\\n            int h=nums[1];\\n            Pair np=new Pair(w,h);\\n            arr[i]=np;\\n        }\\n          Arrays.sort(arr);\\n       \\n         return LIS(arr);\\n    }\\n    \\n    private int LIS(Pair[] arr){\\n          int ans=0;\\n          int[] minele=new int[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            int val=arr[i].h;\\n            int lo=0, hi=ans;\\n            \\n            while(lo<hi){\\n                int mid=(lo + hi)/2;\\n                if(minele[mid]<val){\\n                    lo=mid+1;\\n                }else{\\n                    hi=mid;\\n                }\\n            }\\n            minele[lo]=val;\\n            \\n            if(lo==ans){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public static class Pair implements Comparable<Pair>{\\n        int w;\\n        int h;\\n        \\n        Pair(int w,int h){\\n            this.w=w;\\n            this.h=h;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair other){\\n            if(this.w==other.w) return other.h -this.h;\\n            return this.w-other.w;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n         Arrays.sort(envelopes,new EnvelopeComparator());\\n         return LIS(envelopes);\\n    }\\n    \\n    private int LIS(int[][] arr){\\n          int ans=0;\\n          int[] minele=new int[arr.length];\\n        for(int i=0;i<arr.length;i++){\\n            int val=arr[i][1];\\n            int lo=0, hi=ans;\\n            \\n            while(lo<hi){\\n                int mid=(lo + hi)/2;\\n                if(minele[mid]<val){\\n                    lo=mid+1;\\n                }else{\\n                    hi=mid;\\n                }\\n            }\\n            minele[lo]=val;\\n            \\n            if(lo==ans){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public class EnvelopeComparator implements Comparator<int[]>{\\n        @Override\\n        public int compare(int[] one,int[] two){\\n            if(one[0]==two[0]) return two[1]-one[1];\\n            return one[0]-two[0];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045200,
                "title": "c-n-log-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // Dynamic Programming with Binary Search\\n    // Time complexity : O(nlogn). Sorting and binary search both take nlogn time.\\n    // Space complexity : O(n). dp array of size n is used.\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n      // For each envelope, sorted by envelope[0] first, so envelope[1] is the the longest increasing\\n      // sequence(LIS) problem. When envelope[0] tie, we reverse sort by envelope[1] because bigger\\n      // envelope[1] can\\'t contain the previous one.\\n      sort(envelopes.begin(), envelopes.end(), [](const vector<int>& a, const vector<int>& b) {\\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\\n      });\\n      // dp keeps some of the visited element in a sorted list, and its size is length Of LIS sofar.\\n      // It always keeps the our best chance to build a LIS in the future.\\n      vector<int> dp;\\n      for (auto envelope: envelopes) {\\n        auto it = lower_bound(dp.begin(), dp.end(), envelope[1]);\\n        if (it == dp.end()){\\n          // If envelope[1] is the biggest, we should add it into the end of dp.\\n          dp.push_back(envelope[1]);\\n        } else {\\n          // If envelope[1] is not the biggest, we should keep it in dp and replace the previous\\n          // envelope[1] in this position. Because even if envelope[1] can\\'t build longer LIS\\n          // directly, it can help build a smaller dp, and we will have the best chance to build\\n          // a LIS in the future. All elements before this position will be the best(smallest) LIS\\n          // sor far.\\n          *it = envelope[1];\\n        }\\n      }\\n      // dp doesn\\'t keep LIS, and only keep the length Of LIS.\\n      return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Dynamic Programming with Binary Search\\n    // Time complexity : O(nlogn). Sorting and binary search both take nlogn time.\\n    // Space complexity : O(n). dp array of size n is used.\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n      // For each envelope, sorted by envelope[0] first, so envelope[1] is the the longest increasing\\n      // sequence(LIS) problem. When envelope[0] tie, we reverse sort by envelope[1] because bigger\\n      // envelope[1] can\\'t contain the previous one.\\n      sort(envelopes.begin(), envelopes.end(), [](const vector<int>& a, const vector<int>& b) {\\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\\n      });\\n      // dp keeps some of the visited element in a sorted list, and its size is length Of LIS sofar.\\n      // It always keeps the our best chance to build a LIS in the future.\\n      vector<int> dp;\\n      for (auto envelope: envelopes) {\\n        auto it = lower_bound(dp.begin(), dp.end(), envelope[1]);\\n        if (it == dp.end()){\\n          // If envelope[1] is the biggest, we should add it into the end of dp.\\n          dp.push_back(envelope[1]);\\n        } else {\\n          // If envelope[1] is not the biggest, we should keep it in dp and replace the previous\\n          // envelope[1] in this position. Because even if envelope[1] can\\'t build longer LIS\\n          // directly, it can help build a smaller dp, and we will have the best chance to build\\n          // a LIS in the future. All elements before this position will be the best(smallest) LIS\\n          // sor far.\\n          *it = envelope[1];\\n        }\\n      }\\n      // dp doesn\\'t keep LIS, and only keep the length Of LIS.\\n      return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134158,
                "title": "python-reduce-to-1d",
                "content": "Reduce the problem to 1D and then it becomes Leetcode Problem 300 - Longest Increasing Subsequence.\\nOnce the letters are sorted in increasing width, we only need to sort based on height. Same width envelopes can be traversed in decreasing height because they will never be included in the same sequence.\\n\\nIf all the letter widths are distinct it would be much easier to see that this is Longest Increasing Subsequence.\\n\\nBut the reduction in this case is not trivial. Even if you find it, you need the binary search solution for Longest Increasing Subsequence, that one is not trivial either. In fact, I found this question to be one of the hardest.\\n\\nAlso the \"vanilla\" DP would work perfectly fine for sequences of smaller length (typically less than 1000 on Leetcode platform), which is `O(N^2)`.\\n\\nTime: `O(N logN)` due to sort and longest increasing subsequence computation\\nSpace: `O(N)`\\n\\n\\n```python\\nclass Solution:\\n    def maxEnvelopes(self, A):\\n        #sort A\\n        A.sort(key = lambda x: (x[0], -x[1]))\\n        #reduce to 1D\\n        A1 = [y for _,y in A]\\n        #Now this is Leetcode 300\\n        return self.lengthOfLIS(A1)\\n                \\n    #Leetcode 300\\n    def lengthOfLIS(self, A1):\\n        L = 0\\n        DP = []\\n        for x in A1:\\n            i = bisect.bisect_left(DP, x)\\n            if i == len(DP):\\n                DP.append(x)\\n            else:\\n                DP[i] = x\\n            if i == L:\\n                L += 1\\n        return L     \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxEnvelopes(self, A):\\n        #sort A\\n        A.sort(key = lambda x: (x[0], -x[1]))\\n        #reduce to 1D\\n        A1 = [y for _,y in A]\\n        #Now this is Leetcode 300\\n        return self.lengthOfLIS(A1)\\n                \\n    #Leetcode 300\\n    def lengthOfLIS(self, A1):\\n        L = 0\\n        DP = []\\n        for x in A1:\\n            i = bisect.bisect_left(DP, x)\\n            if i == len(DP):\\n                DP.append(x)\\n            else:\\n                DP[i] = x\\n            if i == L:\\n                L += 1\\n        return L     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 82776,
                "title": "clean-and-short-nlogn-solution",
                "content": "See more explanation in [Longest Increasing Subsequence Size (N log N)][1]\\n\\n    def maxEnvelopes(self, envelopes):\\n        def bin_search(A, key):\\n            l, r = 0, len(A)\\n            while l < r:\\n                mid = (l+r)/2\\n                if A[mid][1] < key[1]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n            return l\\n        envelopes.sort(\\n            cmp = lambda x,y: x[0]-y[0] if x[0] != y[0] else y[1]-x[1])\\n        n = len(envelopes)\\n        tails = []\\n        for i in range(n):\\n            e = envelopes[i]\\n            p = bin_search(tails, e)\\n            if p == len(tails):\\n                tails.append(e)\\n            else:\\n                tails[p] = e\\n        return len(tails)\\n\\n\\n  [1]: http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/",
                "solutionTags": [
                    "Python"
                ],
                "code": "See more explanation in [Longest Increasing Subsequence Size (N log N)][1]\\n\\n    def maxEnvelopes(self, envelopes):\\n        def bin_search(A, key):\\n            l, r = 0, len(A)\\n            while l < r:\\n                mid = (l+r)/2\\n                if A[mid][1] < key[1]:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n            return l\\n        envelopes.sort(\\n            cmp = lambda x,y: x[0]-y[0] if x[0] != y[0] else y[1]-x[1])\\n        n = len(envelopes)\\n        tails = []\\n        for i in range(n):\\n            e = envelopes[i]\\n            p = bin_search(tails, e)\\n            if p == len(tails):\\n                tails.append(e)\\n            else:\\n                tails[p] = e\\n        return len(tails)\\n\\n\\n  [1]: http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/",
                "codeTag": "Python3"
            },
            {
                "id": 82818,
                "title": "c-dp-version-time-o-n-2-space-o-n",
                "content": "       bool cmp (pair<int, int> i, pair<int, int> j) {\\n            if (i.first == j.first)\\n                return i.second < j.second;\\n            return i.first < j.first;\\n        }\\n        \\n        class Solution {\\n        public:\\n            int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n                int N = envelopes.size();\\n                vector<int> dp(N, 1);\\n                int mx = (N == 0) ? 0 : 1;\\n                sort(envelopes.begin(), envelopes.end(), cmp);\\n                for (int i = 0; i < N; i++) {\\n                    for (int j = i - 1; j >= 0; j--) {\\n                        if (envelopes[i].first > envelopes[j].first && envelopes[i].second > envelopes[j].second) {\\n                            dp[i] = max(dp[i], dp[j] + 1);\\n                            mx = max(dp[i], mx);\\n                        }\\n                    }\\n                }\\n                return mx;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n                int N = envelopes.size();\\n                vector<int> dp(N, 1);\\n                int mx = (N == 0) ? 0 : 1;\\n                sort(envelopes.begin(), envelopes.end(), cmp);\\n                for (int i = 0; i < N; i++) {\\n                    for (int j = i - 1; j >= 0; j--) {\\n                        if (envelopes[i].first > envelopes[j].first && envelopes[i].second > envelopes[j].second) {\\n                            dp[i] = max(dp[i], dp[j] + 1);\\n                            mx = max(dp[i], mx);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3603095,
                "title": "longest-increasing-subsequence-variant-with-explaination",
                "content": "**Note - Despite two test cases exceeding the time limit, I am sharing the following code as it is more intuitive. You can give this approach in your interview; it sounds more realistic and intuitive.**\\n\\n# Intuition\\nThe problem asks us to find the maximum number of envelopes we can Russian doll, which means we need to find the longest increasing subsequence based on both width and height. To solve this problem efficiently, we can use dynamic programming.\\n\\n# Approach\\n1. Sort the given input array envelopes based on the width of the envelopes in ascending order. Sorting the envelopes based on width ensures that if envelopes[i] can be nested inside envelopes[j], then envelopes[j] will always appear before envelopes[i] in the sorted array.\\n2. Create a vector vec of size n, where n is the number of envelopes. Each element of vec will store the length of the longest increasing subsequence that ends at the corresponding envelope.\\n3. Iterate through each envelope in envelopes using the outer loop. For each envelope at index i, iterate through all the previous envelopes using the inner loop (from 0 to i-1).\\n4. Check if the width and height of envelope envelopes[i] are strictly greater than the width and height of envelope envelopes[j]. If both conditions are satisfied and the length of the subsequence ending at envelopes[j] plus one is greater than the current length of the subsequence ending at envelopes[i], update the length of the subsequence at vec[i] to be one plus the length of the subsequence at vec[j].\\n5. After the inner loop, the length of the longest increasing subsequence ending at envelopes[i] will be stored in vec[i].\\n6. Iterate through vec and find the maximum length of the subsequence. This represents the maximum number of envelopes that can be Russian dolled.\\n7. Return the maximum length.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), where n is the number of envelopes. The outer loop runs for n iterations, and the inner loop also runs for a maximum of n iterations.\\n\\n- Space complexity:\\nThe space complexity is O(n) since we are using an additional vector vec of size n to store the lengths of subsequences.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end()); // based on width of envelope\\n        int n = envelopes.size();\\n        vector<int> vec(n,1);\\n        for(int  i = 0; i < n; i++)\\n        {\\n            for(int j = 0 ;  j < i; j++)\\n            {\\n                if(envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1] && vec[j]+1 > vec[i])\\n                {\\n                    vec[i] = 1+ vec[j];\\n                }\\n            }\\n        }\\n        int ans = 1;\\n        for(auto i:vec) ans = max(ans,i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end()); // based on width of envelope\\n        int n = envelopes.size();\\n        vector<int> vec(n,1);\\n        for(int  i = 0; i < n; i++)\\n        {\\n            for(int j = 0 ;  j < i; j++)\\n            {\\n                if(envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1] && vec[j]+1 > vec[i])\\n                {\\n                    vec[i] = 1+ vec[j];\\n                }\\n            }\\n        }\\n        int ans = 1;\\n        for(auto i:vec) ans = max(ans,i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769918,
                "title": "c-solutions-easy-to-solve",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>&a , vector<int>& b)\\n    {\\n      return a[0]==b[0]?a[1]>b[1]:a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>&a) {\\n      sort(a.begin(),a.end(),compare);\\n      vector<int>dp;\\n      for(auto i:a)\\n      {\\n        auto it=lower_bound(dp.begin(),dp.end(),i[1]);\\n        if(it==dp.end())\\n          dp.push_back(i[1]);\\n        else\\n          *it=i[1];\\n      }\\n      return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>&a , vector<int>& b)\\n    {\\n      return a[0]==b[0]?a[1]>b[1]:a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>&a) {\\n      sort(a.begin(),a.end(),compare);\\n      vector<int>dp;\\n      for(auto i:a)\\n      {\\n        auto it=lower_bound(dp.begin(),dp.end(),i[1]);\\n        if(it==dp.end())\\n          dp.push_back(i[1]);\\n        else\\n          *it=i[1];\\n      }\\n      return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076588,
                "title": "lis-run-time-o-n-logn-space-o-n",
                "content": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        List<Integer> result = new ArrayList<>();\\n        result.add(envelopes[0][1]);\\n        for (int i = 1; i < envelopes.length; ++i) {\\n            if (result.get(result.size() - 1) < envelopes[i][1])\\n                result.add(envelopes[i][1]);\\n            else {\\n                int idx = Collections.binarySearch(result, envelopes[i][1]);\\n                result.set(idx < 0 ? -idx - 1 : idx, envelopes[i][1]);\\n            }\\n        }\\n        return result.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        List<Integer> result = new ArrayList<>();\\n        result.add(envelopes[0][1]);\\n        for (int i = 1; i < envelopes.length; ++i) {\\n            if (result.get(result.size() - 1) < envelopes[i][1])\\n                result.add(envelopes[i][1]);\\n            else {\\n                int idx = Collections.binarySearch(result, envelopes[i][1]);\\n                result.set(idx < 0 ? -idx - 1 : idx, envelopes[i][1]);\\n            }\\n        }\\n        return result.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545621,
                "title": "java-easy-to-understand-dynamic-programming-longest-increasing-sub-sequence",
                "content": "```\\n\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        \\n        int omax = 0;\\n        Arrays.sort(envelopes,(a,b)->(a[0]-b[0]));\\n        int[] dp = new int[envelopes.length];\\n        for(int i=0;i<envelopes.length;i++)\\n        {\\n            dp[i] = 1; \\n            for(int j=0;j<i;j++)\\n            {\\n                if(envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])\\n                {\\n                    dp[i] = Math.max(dp[i],1+dp[j]);\\n                }\\n            }\\n            omax = Math.max(omax,dp[i]);\\n        }\\n        \\n        \\n        return omax;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        \\n        int omax = 0;\\n        Arrays.sort(envelopes,(a,b)->(a[0]-b[0]));\\n        int[] dp = new int[envelopes.length];\\n        for(int i=0;i<envelopes.length;i++)\\n        {\\n            dp[i] = 1; \\n            for(int j=0;j<i;j++)\\n            {\\n                if(envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])\\n                {\\n                    dp[i] = Math.max(dp[i],1+dp[j]);\\n                }\\n            }\\n            omax = Math.max(omax,dp[i]);\\n        }\\n        \\n        \\n        return omax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135577,
                "title": "java-simple-and-easy-solution-8-ms-faster-than-98-48-t-o-nlogn-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        //sort the enevelope\\n        //as increasing of width, when both width is same, then sort  by decreasing order heights\\n        Arrays.sort(envelopes, (a, b) ->  (a[0] == b[0]) ? (b[1] - a[1]) : (a[0] - b[0]));\\n        \\n        //just extarct the height\\n        int[] heights = new int[envelopes.length];\\n        for(int i = 0; i < heights.length; i++){\\n            heights[i] = envelopes[i][1];\\n        }\\n        \\n        //find the longest increasing subsequen on heights\\n        return getLIS(heights);\\n    }\\n    \\n    private int getLIS(int[] nums){\\n        int[] dp = new int[nums.length];\\n        int len = 0;\\n        \\n        for(int num : nums){\\n            int index = Arrays.binarySearch(dp, 0, len, num);\\n            \\n            if(index < 0){\\n                index = -(index + 1);\\n            }\\n            \\n            dp[index] = num;\\n            \\n            if(index == len)\\n                len++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        //sort the enevelope\\n        //as increasing of width, when both width is same, then sort  by decreasing order heights\\n        Arrays.sort(envelopes, (a, b) ->  (a[0] == b[0]) ? (b[1] - a[1]) : (a[0] - b[0]));\\n        \\n        //just extarct the height\\n        int[] heights = new int[envelopes.length];\\n        for(int i = 0; i < heights.length; i++){\\n            heights[i] = envelopes[i][1];\\n        }\\n        \\n        //find the longest increasing subsequen on heights\\n        return getLIS(heights);\\n    }\\n    \\n    private int getLIS(int[] nums){\\n        int[] dp = new int[nums.length];\\n        int len = 0;\\n        \\n        for(int num : nums){\\n            int index = Arrays.binarySearch(dp, 0, len, num);\\n            \\n            if(index < 0){\\n                index = -(index + 1);\\n            }\\n            \\n            dp[index] = num;\\n            \\n            if(index == len)\\n                len++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045229,
                "title": "golang-n-log-n-solution",
                "content": "```\\n// Dynamic Programming with Binary Search\\n// Time complexity : O(nlogn). Sorting and binary search both take nlogn time.\\n// Space complexity : O(n). dp array of size n is used.\\nfunc maxEnvelopes(envelopes [][]int) int {\\n\\t// For each envelope, sorted by envelope[0] first, so envelope[1] is the the longest\\n\\t// increasing sequence(LIS) problem. When envelope[0] tie, we reverse sort by envelope[1]\\n\\t// because bigger envelope[1] can\\'t contain the previous one.\\n\\tsort.Slice(envelopes,func(i, j int) bool {\\n\\t\\tif envelopes[i][0] == envelopes[j][0] {\\n\\t\\t\\treturn envelopes[i][1] > envelopes[j][1]\\n\\t\\t} else {\\n\\t\\t\\treturn envelopes[i][0] < envelopes[j][0]\\n\\t\\t}\\n\\t})\\n\\t// dp keeps some of the visited element in a sorted list, and its size is\\n\\t// length Of LIS sofar. It always keeps the our best chance to build a LIS in the future.\\n\\tdp := []int{}\\n\\tfor _, envelope := range envelopes {\\n\\t\\ti := sort.SearchInts(dp, envelope[1])\\n\\t\\tif (i == len(dp)) {\\n\\t\\t\\t// If envelope[1] is the biggest, we should add it into the end of dp.\\n\\t\\t\\tdp = append(dp, envelope[1])\\n\\t\\t} else {\\n\\t\\t\\t// If envelope[1] is not the biggest, we should keep it in dp and replace\\n\\t\\t\\t// the previous envelope[1] in this position. Because even if envelope[1]\\n\\t\\t\\t// can\\'t build longer LIS directly, it can help build a smaller dp, and\\n\\t\\t\\t// we will have the best chance to build a LIS in the future. All elements\\n\\t\\t\\t// before this position will be the best(smallest) LIS sor far. \\n\\t\\t\\tdp[i] = envelope[1];\\n\\t\\t}\\n\\t}\\n\\t// dp doesn\\'t keep LIS, and only keep the length Of LIS.\\n\\treturn len(dp)    \\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n// Dynamic Programming with Binary Search\\n// Time complexity : O(nlogn). Sorting and binary search both take nlogn time.\\n// Space complexity : O(n). dp array of size n is used.\\nfunc maxEnvelopes(envelopes [][]int) int {\\n\\t// For each envelope, sorted by envelope[0] first, so envelope[1] is the the longest\\n\\t// increasing sequence(LIS) problem. When envelope[0] tie, we reverse sort by envelope[1]\\n\\t// because bigger envelope[1] can\\'t contain the previous one.\\n\\tsort.Slice(envelopes,func(i, j int) bool {\\n\\t\\tif envelopes[i][0] == envelopes[j][0] {\\n\\t\\t\\treturn envelopes[i][1] > envelopes[j][1]\\n\\t\\t} else {\\n\\t\\t\\treturn envelopes[i][0] < envelopes[j][0]\\n\\t\\t}\\n\\t})\\n\\t// dp keeps some of the visited element in a sorted list, and its size is\\n\\t// length Of LIS sofar. It always keeps the our best chance to build a LIS in the future.\\n\\tdp := []int{}\\n\\tfor _, envelope := range envelopes {\\n\\t\\ti := sort.SearchInts(dp, envelope[1])\\n\\t\\tif (i == len(dp)) {\\n\\t\\t\\t// If envelope[1] is the biggest, we should add it into the end of dp.\\n\\t\\t\\tdp = append(dp, envelope[1])\\n\\t\\t} else {\\n\\t\\t\\t// If envelope[1] is not the biggest, we should keep it in dp and replace\\n\\t\\t\\t// the previous envelope[1] in this position. Because even if envelope[1]\\n\\t\\t\\t// can\\'t build longer LIS directly, it can help build a smaller dp, and\\n\\t\\t\\t// we will have the best chance to build a LIS in the future. All elements\\n\\t\\t\\t// before this position will be the best(smallest) LIS sor far. \\n\\t\\t\\tdp[i] = envelope[1];\\n\\t\\t}\\n\\t}\\n\\t// dp doesn\\'t keep LIS, and only keep the length Of LIS.\\n\\treturn len(dp)    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466383,
                "title": "python-5-lines-short-code",
                "content": "```python\\nclass Solution:\\n    def maxEnvelopes(self, es):\\n        es.sort(key=lambda x: (x[0], -x[1]))\\n        heights = [0x3f3f3f3f] * len(es)\\n        for _, h in es:\\n            heights[bisect.bisect_left(heights, h)] = h\\n        return bisect.bisect_right(heights, 0x3f3f3f3f - 1)\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxEnvelopes(self, es):\\n        es.sort(key=lambda x: (x[0], -x[1]))\\n        heights = [0x3f3f3f3f] * len(es)\\n        for _, h in es:\\n            heights[bisect.bisect_left(heights, h)] = h\\n        return bisect.bisect_right(heights, 0x3f3f3f3f - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289005,
                "title": "python-o-nlogn-a-tricky-sorting-to-solve-the-2-d-dilemma",
                "content": "On the first look of this problem, we should be able to come up with sorting the envelopes from small to large. Something like `sort(envelopes)`. Firstly **sort by the first dimension (let\\'s say width), then use the second dimension data (height) to solve the LIS problem**. However, without carefully modifying your sort criteria, you could be wrong. The reason is: For one doll to cover another , both dimension have to be strictly greater.  It means you cannot have something like `[[1,2], [1, 3]]` in your final doll list. \\n\\nHere is a tricky data set that better explain the bug in normal patient sort. \\n`A = [[1,4], [2,5], [3,1], [3,2], [3,3]]`\\n\\nThe correct answer is to select `lst = [[1,4], [2,5]]` and answer is 2. But if you go over `[[3,1], [3,2], [3,3]]` and leverage the binary search to do the overwrite, you could end up with answer 3. \\n\\nThen you might be conservative and say: **Ok, I only pick one for the dolls with same width.** Then the previous example ends with answer 2, because after considering `[3,1]`, you will directly ignore `[[3,2], [3,3]]`. However, this is still wrong. \\n\\nConsider `B = [[1, 2], [2, 1], [2, 3]]`. The correct answer should be 2. However, if you just consider the first `width=2` doll, which is `[2, 1]`, you will miss the chance to take `[2, 3]`. \\n\\nSo the dilemma is: when you have a group of dolls with the **same width**, you really don\\'t know which of the following you should do\\n1. Pick one with smaller height and overwrite the `lst`\\n2. Pick one with greater height and expand the `lst`\\n\\nThe right pick is depending on the upcoming dolls. If you do 1, it is possible that you miss the chance to expand the current `lst` and you get answer that is smaller than right answer. If you do 2, it is possible that the doll you pick has too large height, and you will miss more chances to expand later. \\n\\nActually, the correct solution is: when you sort the doll, it should be sorted like `envelopes.sort(key = lambda x: (x[0], -x[1]))`. The first dimension is sorted from small to larget. The **second dimension is sorted reversely**. Then, you do not need to worry about \"Only pick one\" for each width. The sorted order would take care of dedupl for you. \\n\\nHere is the solution\\n\\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key = lambda x : (x[0], -x[1]))\\n        \\n        #print(envelopes)\\n        \\n        lst = []\\n        \\n        for start, end in envelopes:\\n            lo, hi = 0, len(lst)\\n            \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                \\n                if end > lst[mid]:\\n                    lo = mid + 1\\n                else:\\n                    hi = mid\\n                    \\n            if lo == len(lst):\\n                lst.append(end)\\n            else:\\n                lst[lo] = end\\n                \\n        return len(lst)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key = lambda x : (x[0], -x[1]))\\n        \\n        #print(envelopes)\\n        \\n        lst = []\\n        \\n        for start, end in envelopes:\\n            lo, hi = 0, len(lst)\\n            \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                \\n                if end > lst[mid]:\\n                    lo = mid + 1\\n                else:\\n                    hi = mid\\n                    \\n            if lo == len(lst):\\n                lst.append(end)\\n            else:\\n                lst[lo] = end\\n                \\n        return len(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82754,
                "title": "python-solution-based-on-lis",
                "content": "It's a problem based on LIS.  \\nDP solution for LIS is N^2 which will TLE here.\\nUsing Binary Search approach will get accepted.\\n\\nhttps://leetcode.com/problems/longest-increasing-subsequence/\\n\\n    def maxEnvelopes(self, envelopes):\\n        \"\"\"\\n        :type envelopes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not envelopes:\\n            return 0\\n        \\n        l = len(envelopes)\\n        if l == 1:\\n            return 1\\n        \\n        envelopes.sort(\\n            cmp = lambda x, y: x[0] - y[0] if x[0] != y[0] else y[1] - x[1]) \\n        # sort the envelopes by width because they need to be inorder before consider the heigths or versa\\n        \\n        width = []\\n        for i in envelopes:\\n            width.append(i[1])\\n            \\n        res = self.longestSubsequence(width)\\n        # the problem became LIS after sort(width)\\n        \\n        return res\\n        \\n        \\n    \\n    def longestSubsequence(self, nums):\\n        \"\"\"\\n        return type: int (number of longest subsequence)\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        l = len(nums)\\n        res = []\\n        \\n        for num in nums:\\n            pos = self.binarySearch(num, res)\\n            if pos >= len(res):\\n                res.append(num)\\n            else:\\n                res[pos] = num\\n        \\n        return len(res)\\n        \\n        \\n    \\n    def binarySearch(self, target, nums):\\n        \"\"\"\\n        return type: int (ceiling of the insert position)\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        \\n        l = len(nums)\\n        start = 0\\n        end = l - 1\\n        \\n        while start <= end:\\n            half = start + (end - start) // 2\\n            if nums[half] == target:\\n                return half\\n            elif nums[half] < target:\\n                start = half + 1\\n            else:\\n                end = half - 1\\n            \\n        return start\\n'''",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's a problem based on LIS.  \\nDP solution for LIS is N^2 which will TLE here.\\nUsing Binary Search approach will get accepted.\\n\\nhttps://leetcode.com/problems/longest-increasing-subsequence/\\n\\n    def maxEnvelopes(self, envelopes):\\n        \"\"\"\\n        :type envelopes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not envelopes:\\n            return 0\\n        \\n        l = len(envelopes)\\n        if l == 1:\\n            return 1\\n        \\n        envelopes.sort(\\n            cmp = lambda x, y: x[0] - y[0] if x[0] != y[0] else y[1] - x[1]) \\n        # sort the envelopes by width because they need to be inorder before consider the heigths or versa\\n        \\n        width = []\\n        for i in envelopes:\\n            width.append(i[1])\\n            \\n        res = self.longestSubsequence(width)\\n        # the problem became LIS after sort(width)\\n        \\n        return res\\n        \\n        \\n    \\n    def longestSubsequence(self, nums):\\n        \"\"\"\\n        return type: int (number of longest subsequence)\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        l = len(nums)\\n        res = []\\n        \\n        for num in nums:\\n            pos = self.binarySearch(num, res)\\n            if pos >= len(res):\\n                res.append(num)\\n            else:\\n                res[pos] = num\\n        \\n        return len(res)\\n        \\n        \\n    \\n    def binarySearch(self, target, nums):\\n        \"\"\"\\n        return type: int (ceiling of the insert position)\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        \\n        l = len(nums)\\n        start = 0\\n        end = l - 1\\n        \\n        while start <= end:\\n            half = start + (end - start) // 2\\n            if nums[half] == target:\\n                return half\\n            elif nums[half] < target:\\n                start = half + 1\\n            else:\\n                end = half - 1\\n            \\n        return start\\n'''",
                "codeTag": "Python3"
            },
            {
                "id": 3246400,
                "title": "354-space-98-16-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We first sort the envelopes based on width in ascending order, and if the widths are equal, we sort them based on height in descending order. This is because when we are trying to find the maximum number of envelopes we can Russian doll, we only care about the heights of the envelopes that have the same width as the current envelope, and we want to sort them in descending order so that we can maintain the largest possible doll set.\\n\\n2. We then initialize an array called doll_set to store the heights of the envelopes in the Russian doll set.\\n\\n3. We iterate through each envelope in the sorted envelopes list.\\n\\n4. For each envelope, we get its height and use binary search to find the index where we can insert the current height to maintain the sorted order of the doll set.\\n\\n5. If the index is beyond the length of the doll set, we add the height to the end of the doll set.\\n\\n6. Otherwise, we replace the height at that index with the current height, since it can fit inside the previous envelope.\\n\\n7. After iterating through all the envelopes, the length of the doll_set array is the maximum number of envelopes we can Russian doll, so we return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\\n    # Same as 300. Longest Increasing Subsequence\\n    ans = 0\\n    dp = [0] * len(envelopes)\\n\\n    for _, h in envelopes:\\n      l = 0\\n      r = ans\\n      while l < r:\\n        m = (l + r) // 2\\n        if dp[m] >= h:\\n          r = m\\n        else:\\n          l = m + 1\\n      dp[l] = h\\n      if l == ans:\\n        ans += 1\\n\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\\n    # Same as 300. Longest Increasing Subsequence\\n    ans = 0\\n    dp = [0] * len(envelopes)\\n\\n    for _, h in envelopes:\\n      l = 0\\n      r = ans\\n      while l < r:\\n        m = (l + r) // 2\\n        if dp[m] >= h:\\n          r = m\\n        else:\\n          l = m + 1\\n      dp[l] = h\\n      if l == ans:\\n        ans += 1\\n\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071305,
                "title": "c-nlogn-binary-search-dp",
                "content": "```\\n    public int MaxEnvelopes(int[][] envelopes)\\n    {\\n        Array.Sort(envelopes, (a, b) => a[0] == b[0] ? b[1].CompareTo(a[1]) : a[0].CompareTo(b[0]));\\n\\n        int[] dp = new int[envelopes.Length];\\n        int len = 0;\\n        foreach(int[] envelope in envelopes){\\n            int index = Array.BinarySearch(dp, 0, len, envelope[1]);\\n            if(index< 0)\\n                index = ~index;\\n            dp[index] = envelope[1];\\n            if(index == len)\\n                len++;\\n        }\\n        return len;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int MaxEnvelopes(int[][] envelopes)\\n    {\\n        Array.Sort(envelopes, (a, b) => a[0] == b[0] ? b[1].CompareTo(a[1]) : a[0].CompareTo(b[0]));\\n\\n        int[] dp = new int[envelopes.Length];\\n        int len = 0;\\n        foreach(int[] envelope in envelopes){\\n            int index = Array.BinarySearch(dp, 0, len, envelope[1]);\\n            if(index< 0)\\n                index = ~index;\\n            dp[index] = envelope[1];\\n            if(index == len)\\n                len++;\\n        }\\n        return len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071263,
                "title": "c-simple-binary-search-solution",
                "content": "**Note :** Sort `hight` in decreasing order when `width` is same.\\n```\\nclass Solution {\\npublic:\\n    int bSearch(vector<int>& vec, int maxVal, vector<vector<int>>& envelopes, int i){\\n        int l = 0;\\n        int r = maxVal;\\n        \\n        int temp = maxVal;\\n        \\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            \\n            if(vec[mid] < envelopes[i][1])\\n                l = mid + 1;\\n            \\n            else {\\n                temp = mid;\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return temp;\\n    }\\n    \\n    // to sort in decreasing order\\n    static bool decSort(vector<int>& v1, vector<int>& v2) {\\n        if(v1[0] == v2[0])\\n            return v1[1] > v2[1];\\n        \\n        return v1[0] < v2[0];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int siz = envelopes.size();\\n        \\n        if(siz == 0)\\n            return 0;\\n        \\n        sort(envelopes.begin(), envelopes.end(), decSort);\\n        \\n        vector<int> vec(siz, 0);\\n        int maxVal = 0;\\n        \\n        for(int i = 0; i < siz; i++) {\\n            int pos = bSearch(vec, maxVal, envelopes, i);\\n            \\n            vec[pos] = envelopes[i][1];\\n            \\n            if(pos == maxVal)\\n                maxVal++;\\n        }\\n        \\n        return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bSearch(vector<int>& vec, int maxVal, vector<vector<int>>& envelopes, int i){\\n        int l = 0;\\n        int r = maxVal;\\n        \\n        int temp = maxVal;\\n        \\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            \\n            if(vec[mid] < envelopes[i][1])\\n                l = mid + 1;\\n            \\n            else {\\n                temp = mid;\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return temp;\\n    }\\n    \\n    // to sort in decreasing order\\n    static bool decSort(vector<int>& v1, vector<int>& v2) {\\n        if(v1[0] == v2[0])\\n            return v1[1] > v2[1];\\n        \\n        return v1[0] < v2[0];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int siz = envelopes.size();\\n        \\n        if(siz == 0)\\n            return 0;\\n        \\n        sort(envelopes.begin(), envelopes.end(), decSort);\\n        \\n        vector<int> vec(siz, 0);\\n        int maxVal = 0;\\n        \\n        for(int i = 0; i < siz; i++) {\\n            int pos = bSearch(vec, maxVal, envelopes, i);\\n            \\n            vec[pos] = envelopes[i][1];\\n            \\n            if(pos == maxVal)\\n                maxVal++;\\n        }\\n        \\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034251,
                "title": "python-o-nlogn-solution-dp-binary-search-is-not-used",
                "content": "```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        # sort the width by ascending order, the height by descending order\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        tops = []\\n        for e in envelopes:\\n            if tops and tops[-1][0] < e[0] and tops[-1][1] < e[1]: \\n                # To speed up, if height and width is bigger than the envelope in our piles, create a new pile\\n                tops.append(e)\\n                continue\\n\\n            for i in range(len(tops)):\\n                if tops[i][1] >= e[1]: \\n                    # if envelope is smaller than top envelope of pile, update top envelope of pile\\n                    tops[i] = e\\n                    break\\n            else:\\n                # not trigger break (height and width is bigger than the envelope in our piles, create a new pile)\\n                tops.append(e)\\n        return len(tops)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        # sort the width by ascending order, the height by descending order\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        tops = []\\n        for e in envelopes:\\n            if tops and tops[-1][0] < e[0] and tops[-1][1] < e[1]: \\n                # To speed up, if height and width is bigger than the envelope in our piles, create a new pile\\n                tops.append(e)\\n                continue\\n\\n            for i in range(len(tops)):\\n                if tops[i][1] >= e[1]: \\n                    # if envelope is smaller than top envelope of pile, update top envelope of pile\\n                    tops[i] = e\\n                    break\\n            else:\\n                # not trigger break (height and width is bigger than the envelope in our piles, create a new pile)\\n                tops.append(e)\\n        return len(tops)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045219,
                "title": "python-n-log-n-solution",
                "content": "```\\nclass Solution:\\n    # Dynamic Programming with Binary Search\\n    # Time complexity : O(nlogn). Sorting and binary search both take nlogn time.\\n    # Space complexity : O(n). dp array of size n is used.\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        # For each envelope, sorted by envelope[0] first, so envelope[1] is the the longest\\n        # increasing sequence(LIS) problem. When envelope[0] tie, we reverse sort by envelope[1]\\n        # because bigger envelope[1] can\\'t contain the previous one.\\n        envelopes.sort(key=lambda e: (e[0], -e[1]))\\n        # dp keeps some of the visited element in a sorted list, and its size is length Of LIS\\n        # sofar. It always keeps the our best chance to build a LIS in the future.\\n        dp = []\\n        for envelope in envelopes:\\n            i = bisect.bisect_left(dp, envelope[1])\\n            if i == len(dp):\\n                # If envelope[1] is the biggest, we should add it into the end of dp.\\n                dp.append(envelope[1])\\n            else:\\n                # If envelope[1] is not the biggest, we should keep it in dp and replace the\\n                # previous envelope[1] in this position. Because even if envelope[1] can\\'t build\\n                # longer LIS directly, it can help build a smaller dp, and we will have the best\\n                # chance to build a LIS in the future. All elements before this position will be\\n                # the best(smallest) LIS sor far. \\n                dp[i] = envelope[1]\\n        # dp doesn\\'t keep LIS, and only keep the length Of LIS.\\n        return len(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    # Dynamic Programming with Binary Search\\n    # Time complexity : O(nlogn). Sorting and binary search both take nlogn time.\\n    # Space complexity : O(n). dp array of size n is used.\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        # For each envelope, sorted by envelope[0] first, so envelope[1] is the the longest\\n        # increasing sequence(LIS) problem. When envelope[0] tie, we reverse sort by envelope[1]\\n        # because bigger envelope[1] can\\'t contain the previous one.\\n        envelopes.sort(key=lambda e: (e[0], -e[1]))\\n        # dp keeps some of the visited element in a sorted list, and its size is length Of LIS\\n        # sofar. It always keeps the our best chance to build a LIS in the future.\\n        dp = []\\n        for envelope in envelopes:\\n            i = bisect.bisect_left(dp, envelope[1])\\n            if i == len(dp):\\n                # If envelope[1] is the biggest, we should add it into the end of dp.\\n                dp.append(envelope[1])\\n            else:\\n                # If envelope[1] is not the biggest, we should keep it in dp and replace the\\n                # previous envelope[1] in this position. Because even if envelope[1] can\\'t build\\n                # longer LIS directly, it can help build a smaller dp, and we will have the best\\n                # chance to build a LIS in the future. All elements before this position will be\\n                # the best(smallest) LIS sor far. \\n                dp[i] = envelope[1]\\n        # dp doesn\\'t keep LIS, and only keep the length Of LIS.\\n        return len(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699268,
                "title": "python-simple-dp-nlogn-solution",
                "content": "```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## Similar to Leetcode : 300 Longest Increasing Subsequence ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(NlogN) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        ## LIS : replace larger number with small one, append larger numbers ##\\n        ## NUMS  [100, 89, 53, 68, 45, 81] ##\\n        ## DP ##\\n        # [100]\\n        # [89]\\n        # [53]\\n        # [53, 68]\\n        # [45, 68]\\n        # [45, 68, 81]\\n        \\n        def lis(nums):\\n            # print(nums)\\n            dp = []\\n            for i in range(len(nums)):\\n                idx = bisect_left(dp, nums[i])\\n                if idx == len(dp):\\n                    dp.append(nums[i])\\n                else:\\n                    dp[idx] = nums[i]\\n                # print(dp)\\n            return len(dp)\\n        \\n        # sort increasing in first dimension and decreasing on second\\n        # take a moment and think why ? ( we want to perform LIS on second dimension, think in terms when a set of boxes have same first dimension)\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        \\n        # extract the second dimension and run the LIS\\n        return lis([envelope[1] for envelope in envelopes])     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## Similar to Leetcode : 300 Longest Increasing Subsequence ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(NlogN) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        ## LIS : replace larger number with small one, append larger numbers ##\\n        ## NUMS  [100, 89, 53, 68, 45, 81] ##\\n        ## DP ##\\n        # [100]\\n        # [89]\\n        # [53]\\n        # [53, 68]\\n        # [45, 68]\\n        # [45, 68, 81]\\n        \\n        def lis(nums):\\n            # print(nums)\\n            dp = []\\n            for i in range(len(nums)):\\n                idx = bisect_left(dp, nums[i])\\n                if idx == len(dp):\\n                    dp.append(nums[i])\\n                else:\\n                    dp[idx] = nums[i]\\n                # print(dp)\\n            return len(dp)\\n        \\n        # sort increasing in first dimension and decreasing on second\\n        # take a moment and think why ? ( we want to perform LIS on second dimension, think in terms when a set of boxes have same first dimension)\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        \\n        # extract the second dimension and run the LIS\\n        return lis([envelope[1] for envelope in envelopes])     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 385691,
                "title": "easy-peasy-python-o-nlogn-solution-with-comments",
                "content": "\\tdef maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        # sort in one property and find the longest increasing subsequence\\n        # in the other property, that\\'s it\\n        # to avoid cases such as [(3, 4), (3, 6)] - output should be 1\\n        # sort the (w) in ascending and (h) in descending\\n    \\n        #let\\'s sort in second property(h) and then find LIS using first property(w)\\n        ln = len(envelopes)\\n        if ln <= 1:\\n            return ln\\n        \\n        envelopes = sorted(envelopes, key=lambda x:(x[1], -x[0]))\\n        #now find the LIS\\n        q = [envelopes[0][0]]\\n        \\n        for i in range(1, ln):\\n            num = envelopes[i][0]\\n            if q[-1] < num:\\n                q.append(num)\\n            elif q[-1] > num:\\n                # use binary search \\n                idx = self.upperbound(q, num)\\n                q[idx] = num\\n        \\n        return len(q)\\n    \\n    def upperbound(self, ls, num):\\n        ln = len(ls)\\n        s, e = 0, ln-1\\n        while s <= e:\\n            mid = (e-s)//2 + s\\n            if ls[mid] == num:\\n                #we can or we don\\'t have to replace this\\n                return mid\\n            elif ls[mid] < num:\\n                if mid+1 < ln and ls[mid+1] > num:\\n                    return mid+1\\n                s = mid + 1\\n            else:\\n                if mid == 0:\\n                    return mid\\n                e = mid-1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "\\tdef maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        # sort in one property and find the longest increasing subsequence\\n        # in the other property, that\\'s it\\n        # to avoid cases such as [(3, 4), (3, 6)] - output should be 1\\n        # sort the (w) in ascending and (h) in descending\\n    \\n        #let\\'s sort in second property(h) and then find LIS using first property(w)\\n        ln = len(envelopes)\\n        if ln <= 1:\\n            return ln\\n        \\n        envelopes = sorted(envelopes, key=lambda x:(x[1], -x[0]))\\n        #now find the LIS\\n        q = [envelopes[0][0]]\\n        \\n        for i in range(1, ln):\\n            num = envelopes[i][0]\\n            if q[-1] < num:\\n                q.append(num)\\n            elif q[-1] > num:\\n                # use binary search \\n                idx = self.upperbound(q, num)\\n                q[idx] = num\\n        \\n        return len(q)\\n    \\n    def upperbound(self, ls, num):\\n        ln = len(ls)\\n        s, e = 0, ln-1\\n        while s <= e:\\n            mid = (e-s)//2 + s\\n            if ls[mid] == num:\\n                #we can or we don\\'t have to replace this\\n                return mid\\n            elif ls[mid] < num:\\n                if mid+1 < ln and ls[mid+1] > num:\\n                    return mid+1\\n                s = mid + 1\\n            else:\\n                if mid == 0:\\n                    return mid\\n                e = mid-1",
                "codeTag": "Python3"
            },
            {
                "id": 183277,
                "title": "python-6-lines-bisect-solution",
                "content": "* I don\\'t go much into details. \\n* The method is all over the discussion, \"longest increasing subsequence\" tail method.\\n* We simply catch the minimum height for specified number of dolls or length of tails in other words.\\n* We reversed heights of same widths in envelopes array because it would continue adding another doll onto same width.\\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes):\\n        tails = []\\n        for w, h in sorted(envelopes, key = lambda x: (x[0], -x[1])):\\n            i = bisect.bisect_left(tails, h)\\n            if i == len(tails): tails.append(h)\\n            else: tails[i] = h\\n        return len(tails)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes):\\n        tails = []\\n        for w, h in sorted(envelopes, key = lambda x: (x[0], -x[1])):\\n            i = bisect.bisect_left(tails, h)\\n            if i == len(tails): tails.append(h)\\n            else: tails[i] = h\\n        return len(tails)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466402,
                "title": "sort-lis-c",
                "content": "```\\nclass Solution {\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(), envelopes.end(), cmp);\\n\\n        vector<int> v;\\n        for(auto e : envelopes) {\\n            if(!v.size() || v.back() < e[1]) v.push_back(e[1]);\\n            else {\\n                int pos = lower_bound(v.begin(), v.end(), e[1]) - v.begin();\\n                v[pos] = e[1];\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(), envelopes.end(), cmp);\\n\\n        vector<int> v;\\n        for(auto e : envelopes) {\\n            if(!v.size() || v.back() < e[1]) v.push_back(e[1]);\\n            else {\\n                int pos = lower_bound(v.begin(), v.end(), e[1]) - v.begin();\\n                v[pos] = e[1];\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265363,
                "title": "lis-o-nlogn-easy-to-understand-intuitive",
                "content": "# Longest Increasing Subsequence in 2 dimension!\\nFirstly, if you have solved the `Longest Increasing Subsequence (LIS)` question, you\\'ve perhaps related this question to LIS in some way or the other, if so, you\\'re in the right track. In LIS we found the longest increasing subsequence in an 1D array but in this question the ask is to find the LIS in 2D array *(for both the width and the height, since an envelope can get inside another envelope iff both its height and width are smaller than the other one)*. The trick is to **sort the array according to its width**. That makes life easier as now we only need to deal with the height since width is already sorted. So **the LIS of height will automatically be the LIS of both width and height**.\\n\\n**Input:** ```[[5,4],[6,4],[6,7],[2,3]]```\\n**After sorting:** ```[[2,3],[5,4],[6,7],[6,4]]```\\nNow an LIS on height i.e., ```[3,4,7,4]``` will give 3 as the length since ```[3,4,7]``` is the LIS.\\nAnd now if you bring the width into the picture ```[[2,3],[5,4],[6,7]]``` is the LIS of both width and height, which means an envelope ```[2,3]``` can be put inside an envelope ```[5,4]``` which in turn can be put inside an envelope ```[6,7]```. Hope the requirement of the concept of LIS is no more a question here.\\n\\nWe need to take care of certain scenarios where width may be same for 2 or more envelopes, say, `[6,5]` & `[6,7]`. In such scenarios we can not take both `5` and `7` in our LIS *(of height)* since the envelope of same width can not get inside the other. To skip this scenario and only take one envelope we better configure our code to sort the height in reverse order only when 2 or more width of envelopes are same. Now in the sorted array, `[6,7]` will appear before `[6,5]` so the LIS of height won\\'t take both `7` & `5` into calculation.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int N = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end(), [](vector<int>& a, vector<int>& b) {\\n            if(a[0]==b[0]) return a[1]>b[1];\\n            return a[0]<b[0];\\n        });\\n        // for(int i=0; i<N; i++) cout<<envelopes[i][0]<<\" \"<<envelopes[i][1]<<endl;\\n        vector<int> dp;\\n        dp.push_back(envelopes[0][1]);\\n        int l=1;\\n        for(int i=1; i<N; i++) {\\n            if(envelopes[i][1]>dp.back()) {\\n                dp.push_back(envelopes[i][1]);\\n                l++;\\n            }\\n            else {\\n                int index = lower_bound(dp.begin(), dp.end(), envelopes[i][1]) - dp.begin();\\n                dp[index] = envelopes[i][1];\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```\\n**Time complexity:** `O(NlogN)` *(for sorting)* + `O(NlogN)` *(for inserting into the DP vector * for finding the lower bound)* ~ `O(NlogN)`\\n**Space complexity:** `O(N)` *(size of the DP vector)*\\n\\nDo hit a like if you like the explanation. Thank you.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```[[5,4],[6,4],[6,7],[2,3]]```\n```[[2,3],[5,4],[6,7],[6,4]]```\n```[3,4,7,4]```\n```[3,4,7]```\n```[[2,3],[5,4],[6,7]]```\n```[2,3]```\n```[5,4]```\n```[6,7]```\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int N = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end(), [](vector<int>& a, vector<int>& b) {\\n            if(a[0]==b[0]) return a[1]>b[1];\\n            return a[0]<b[0];\\n        });\\n        // for(int i=0; i<N; i++) cout<<envelopes[i][0]<<\" \"<<envelopes[i][1]<<endl;\\n        vector<int> dp;\\n        dp.push_back(envelopes[0][1]);\\n        int l=1;\\n        for(int i=1; i<N; i++) {\\n            if(envelopes[i][1]>dp.back()) {\\n                dp.push_back(envelopes[i][1]);\\n                l++;\\n            }\\n            else {\\n                int index = lower_bound(dp.begin(), dp.end(), envelopes[i][1]) - dp.begin();\\n                dp[index] = envelopes[i][1];\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2073409,
                "title": "c-sorting-and-lis",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n   int find_bound(vector<int> &dp,int target){\\n       \\n       int pos = dp.size();\\n       \\n       int low = 0;\\n       int high = dp.size()-1;\\n       \\n       while(low<=high){\\n           \\n           int mid = low + (high-low)/2;\\n           \\n           if(dp[mid]>=target){\\n               pos = mid;\\n               high = mid-1;\\n           }\\n           else{\\n               low = mid+1;\\n           }\\n           \\n       }\\n       \\n       return pos;\\n       \\n   } \\n    \\n    \\n   int maxEnvelopes(vector<vector<int>>& envelopes) {\\n       \\n        sort(envelopes.begin(),envelopes.end());\\n        \\n        for(int i=0;i<envelopes.size();){\\n            int start = i;\\n            int num = envelopes[i][0];\\n           \\n            \\n            while(i<envelopes.size() && envelopes[i][0]==num){\\n                i++;\\n            }\\n            \\n            int end = i-1;\\n            \\n            reverse(envelopes.begin()+start,envelopes.begin()+end+1);\\n            \\n        }\\n       \\n        \\n        vector<int> height;\\n        \\n        for(int i=0;i<envelopes.size();i++){\\n            int h = envelopes[i][1];\\n            height.push_back(h);\\n           \\n        }\\n       \\n        vector<int> dp;\\n        \\n        for(int i=0;i<height.size();i++){\\n            int sz = dp.size();\\n            \\n            if(sz == 0){\\n                dp.push_back(height[i]);\\n            }\\n            else if(dp[sz-1]<height[i]){\\n                dp.push_back(height[i]);\\n            }\\n            else{\\n                // here upper-bound will not work for the test-case--> \\n                // [[15,8],[2,20],[2,14],[4,17],[8,19],[8,9],[5,7],[11,19],[8,11],[13,11],[2,13],[11,19],[8,11], [13,11],[2,13],[11,19],[16,1],[18,13],[14,17],[18,19]] \\n                \\n                // So, here we create custom function for find the exact position for height[i] element in dp array...                \\n                int pos = find_bound(dp,height[i]);\\n                if(pos >= dp.size()) continue;\\n                dp[pos] = height[i];\\n                \\n            }\\n        }\\n       \\n\\t    return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n   int find_bound(vector<int> &dp,int target){\\n       \\n       int pos = dp.size();\\n       \\n       int low = 0;\\n       int high = dp.size()-1;\\n       \\n       while(low<=high){\\n           \\n           int mid = low + (high-low)/2;\\n           \\n           if(dp[mid]>=target){\\n               pos = mid;\\n               high = mid-1;\\n           }\\n           else{\\n               low = mid+1;\\n           }\\n           \\n       }\\n       \\n       return pos;\\n       \\n   } \\n    \\n    \\n   int maxEnvelopes(vector<vector<int>>& envelopes) {\\n       \\n        sort(envelopes.begin(),envelopes.end());\\n        \\n        for(int i=0;i<envelopes.size();){\\n            int start = i;\\n            int num = envelopes[i][0];\\n           \\n            \\n            while(i<envelopes.size() && envelopes[i][0]==num){\\n                i++;\\n            }\\n            \\n            int end = i-1;\\n            \\n            reverse(envelopes.begin()+start,envelopes.begin()+end+1);\\n            \\n        }\\n       \\n        \\n        vector<int> height;\\n        \\n        for(int i=0;i<envelopes.size();i++){\\n            int h = envelopes[i][1];\\n            height.push_back(h);\\n           \\n        }\\n       \\n        vector<int> dp;\\n        \\n        for(int i=0;i<height.size();i++){\\n            int sz = dp.size();\\n            \\n            if(sz == 0){\\n                dp.push_back(height[i]);\\n            }\\n            else if(dp[sz-1]<height[i]){\\n                dp.push_back(height[i]);\\n            }\\n            else{\\n                // here upper-bound will not work for the test-case--> \\n                // [[15,8],[2,20],[2,14],[4,17],[8,19],[8,9],[5,7],[11,19],[8,11],[13,11],[2,13],[11,19],[8,11], [13,11],[2,13],[11,19],[16,1],[18,13],[14,17],[18,19]] \\n                \\n                // So, here we create custom function for find the exact position for height[i] element in dp array...                \\n                int pos = find_bound(dp,height[i]);\\n                if(pos >= dp.size()) continue;\\n                dp[pos] = height[i];\\n                \\n            }\\n        }\\n       \\n\\t    return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073344,
                "title": "c-lis-binary-search-with-detailed-comments",
                "content": "```c++\\nclass Solution {\\npublic:\\n    static bool my_comp(vector<int> &a, vector<int> &b){\\n        if (a[0] == b[0]) {\\n            return (a[1] > b[1]);\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        /* Sort envelopes in increasing order of width and decreasing order of height.\\n        *  Then, apply LIS on heights.\\n        *    LIS:\\n        *    Create a tmp_arr to save sequence.\\n        *    If curr_elem in arr is greater than tmp_arr.back(), append curr_elem to tmp_arr.\\n        *    Else, replace elem in tmp_arr such that,\\n        *      curr_elem < tmp_elem and it should not break incerasing nature of tmp_arr.\\n        *      (Binary search for curr_elem in tmp_arr will give you the proper index)\\n        *    Finally return len of tmp_arr.\\n        */\\n        \\n        sort(envelopes.begin(), envelopes.end(), my_comp);\\n\\n        vector<int> tmp;\\n        tmp.push_back(envelopes[0][1]);\\n        for (int i = 1; i < envelopes.size(); i++){\\n            int curr_elem = envelopes[i][1];\\n            if (tmp.back() < curr_elem)\\n            {\\n                tmp.push_back(curr_elem);\\n            }\\n            else \\n            {\\n                int idx = lower_bound(tmp.begin(), tmp.end(), curr_elem) - tmp.begin();\\n                tmp[idx] = curr_elem;\\n            }\\n            \\n        }\\n        return tmp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    static bool my_comp(vector<int> &a, vector<int> &b){\\n        if (a[0] == b[0]) {\\n            return (a[1] > b[1]);\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        /* Sort envelopes in increasing order of width and decreasing order of height.\\n        *  Then, apply LIS on heights.\\n        *    LIS:\\n        *    Create a tmp_arr to save sequence.\\n        *    If curr_elem in arr is greater than tmp_arr.back(), append curr_elem to tmp_arr.\\n        *    Else, replace elem in tmp_arr such that,\\n        *      curr_elem < tmp_elem and it should not break incerasing nature of tmp_arr.\\n        *      (Binary search for curr_elem in tmp_arr will give you the proper index)\\n        *    Finally return len of tmp_arr.\\n        */\\n        \\n        sort(envelopes.begin(), envelopes.end(), my_comp);\\n\\n        vector<int> tmp;\\n        tmp.push_back(envelopes[0][1]);\\n        for (int i = 1; i < envelopes.size(); i++){\\n            int curr_elem = envelopes[i][1];\\n            if (tmp.back() < curr_elem)\\n            {\\n                tmp.push_back(curr_elem);\\n            }\\n            else \\n            {\\n                int idx = lower_bound(tmp.begin(), tmp.end(), curr_elem) - tmp.begin();\\n                tmp[idx] = curr_elem;\\n            }\\n            \\n        }\\n        return tmp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664228,
                "title": "treeset-java",
                "content": "\\n   \\n    class Solution {\\n\\tpublic int maxEnvelopes(int[][] envelopes) {\\n\\t\\n        //sorting the array width wise but when equal sorting in descending order of the heights\\n        Arrays.sort(envelopes,(a,b)-> a[0]!=b[0] ? a[0]-b[0] : b[1]-a[1]);\\n        \\n        //implementing treeset which implements bst interface\\n        TreeSet<Integer> s=new TreeSet<>();\\n        \\n        //code for finding LIS of the height values in O(nlogn) time\\n        for(int i=0;i<envelopes.length;i++){\\n            Integer higher_value=s.ceiling(envelopes[i][1]);\\n            \\n            if(higher_value==null){\\n                s.add(envelopes[i][1]);\\n            }\\n            \\n            else{\\n                s.remove(higher_value);\\n                s.add(envelopes[i][1]);\\n            }\\n            \\n        }\\n        return s.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic int maxEnvelopes(int[][] envelopes) {\\n\\t\\n        //sorting the array width wise but when equal sorting in descending order of the heights\\n        Arrays.sort(envelopes,(a,b)-> a[0]!=b[0] ? a[0]-b[0] : b[1]-a[1]);\\n        \\n        //implementing treeset which implements bst interface\\n        TreeSet<Integer> s=new TreeSet<>();\\n        \\n        //code for finding LIS of the height values in O(nlogn) time\\n        for(int i=0;i<envelopes.length;i++){\\n            Integer higher_value=s.ceiling(envelopes[i][1]);\\n            \\n            if(higher_value==null){\\n                s.add(envelopes[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1631249,
                "title": "easy-to-understand-sorting-technique-lis-d-p",
                "content": "class Solution {\\npublic:\\n\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if(n==0)\\n            return 0;\\n        \\n        sort(envelopes.begin(),envelopes.end());\\n        vector<int> dp(n+1,1);\\n        int max = 1;\\n        for(int i=1;i<n;++i)\\n        {\\n            for(int j=0;j<i;++j)\\n            {\\n                if(envelopes[i][0]>envelopes[j][0]\\n                   && envelopes[i][1]>envelopes[j][1]\\n                   && 1+dp[j]>dp[i])\\n                    dp[i] = 1 + dp[j];\\n                if(max<dp[i])\\n                    max = dp[i];\\n            }\\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if(n==0)\\n            return 0;\\n        \\n        sort(envelopes.begin(),envelopes.end());\\n        vector<int> dp(n+1,1);\\n        int max = 1;\\n        for(int i=1;i<n;++i)\\n        {\\n            for(int j=0;j<i;++j)\\n            {\\n                if(envelopes[i][0]>envelopes[j][0]\\n                   && envelopes[i][1]>envelopes[j][1]\\n                   && 1+dp[j]>dp[i])\\n                    dp[i] = 1 + dp[j];\\n                if(max<dp[i])\\n                    max = dp[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1133916,
                "title": "russian-doll-envelopes-easy-dp-solution-simple-trick-explained",
                "content": "The trick is, we first sort the envolopes based on their width, Then the problem now turned into finding **longest Increasing subsequence(LIS**), so we just need to find **LIS on heights of envolopes** but including some edges cases. \\nLets see the edge cases to understand it more..\\nconsider, `envolope = [[2,3],[5,8],[3,6],[5,7]]`, if we sort based on `compare function`, we get `[[2,3],[3,6],[5,7],[5,8]]`\\nNow, if perform LIS on heights, **LIS=4, but answer should be 3**, to tackle this we take `en[i][0] > en[j][0] && en[i][1]>en[j][1]` as our condition instead of `en[i][1]>en[j][1]` inorder to make sure both width and height increasing.\\n\\n**Do Upvote** if you like the code and comment down if you are facing some difficulty or having some queries.\\nGo through the code below for better understanding !!!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>a,vector<int>b){\\n        if(a[0] == b[0]) return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& en) {\\n        sort(en.begin(),en.end(),compare);\\n        int n = en.size(),res=1;\\n        vector<int>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(en[i][0] > en[j][0] && en[i][1]>en[j][1]){\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                    res = max(res,dp[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>a,vector<int>b){\\n        if(a[0] == b[0]) return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& en) {\\n        sort(en.begin(),en.end(),compare);\\n        int n = en.size(),res=1;\\n        vector<int>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(en[i][0] > en[j][0] && en[i][1]>en[j][1]){\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                    res = max(res,dp[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766331,
                "title": "c-easy-dp-solution-in-o-nlogn-time-and-o-n-space-with-explanation",
                "content": "This question is a varation of Longest increasing subsequence problem. We need to find the largest number of rectangles which can be russian doll. So, we need to first sort the numbers with respect to height or width. I have sorted the number according to width. Also, it is given that the height and width should be strictly greater so, to for that while sorting we need to take care that when the width are equal, then we must sort them according to decreaing height. This is done so that we don\\'t include the equal heights sequence in the answer.\\n\\n```\\nclass Solution {\\npublic:\\n   static bool func(vector<int>& e1, vector<int>& e2){\\n         return (e1[0]==e2[0])?e1[1]>e2[1]:e1[0]<e2[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end(),func);\\n        vector<int> v;\\n        for(int i=0;i<envelopes.size();i++)\\n        {\\n            if(i==0 || envelopes[i][1]>v[v.size()-1])\\n               {\\n                   v.push_back(envelopes[i][1]);\\n               }\\n               else\\n               {\\n                   int index=binarysearch(v,envelopes[i][1]);\\n                   v[index]=envelopes[i][1];\\n               }\\n        }\\n     return v.size();           \\n    }\\n    \\n    int binarysearch(vector<int> &v,int x)\\n    {\\n        int i=0;\\n        int j=v.size()-1;\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            int mid=(i+(j-i)/2);\\n            if(v[mid]==x)\\n                return mid;\\n            else if(v[mid]>x)\\n            {\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else\\n                i=mid+1;\\n        }\\n        return ans;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool func(vector<int>& e1, vector<int>& e2){\\n         return (e1[0]==e2[0])?e1[1]>e2[1]:e1[0]<e2[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end(),func);\\n        vector<int> v;\\n        for(int i=0;i<envelopes.size();i++)\\n        {\\n            if(i==0 || envelopes[i][1]>v[v.size()-1])\\n               {\\n                   v.push_back(envelopes[i][1]);\\n               }\\n               else\\n               {\\n                   int index=binarysearch(v,envelopes[i][1]);\\n                   v[index]=envelopes[i][1];\\n               }\\n        }\\n     return v.size();           \\n    }\\n    \\n    int binarysearch(vector<int> &v,int x)\\n    {\\n        int i=0;\\n        int j=v.size()-1;\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            int mid=(i+(j-i)/2);\\n            if(v[mid]==x)\\n                return mid;\\n            else if(v[mid]>x)\\n            {\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else\\n                i=mid+1;\\n        }\\n        return ans;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511118,
                "title": "java-8-liner-using-treeset",
                "content": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b)-> a[0]==b[0]? b[1]-a[1]: a[0]-b[0]);\\n        TreeSet<Integer> sortedSet = new TreeSet<>();\\n        for (int[] env : envelopes) {\\n            Integer ceiling = sortedSet.ceiling(env[1]);            \\n            if (ceiling != null && ceiling.intValue() != env[1]) sortedSet.remove(ceiling);\\n            sortedSet.add(env[1]);\\n        }        \\n        return sortedSet.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b)-> a[0]==b[0]? b[1]-a[1]: a[0]-b[0]);\\n        TreeSet<Integer> sortedSet = new TreeSet<>();\\n        for (int[] env : envelopes) {\\n            Integer ceiling = sortedSet.ceiling(env[1]);            \\n            if (ceiling != null && ceiling.intValue() != env[1]) sortedSet.remove(ceiling);\\n            sortedSet.add(env[1]);\\n        }        \\n        return sortedSet.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82814,
                "title": "c-nlogn-solution",
                "content": "    class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            auto Cmp = [](const pair<int, int> &a, const pair<int, int> &b) { \\n                if(a.first < b.first) return true;\\n                if(a.first == b.first && a.second > b.second) return true;\\n                return false;\\n            };\\n            auto Cmp2 = [](const pair<int, int> &a, const pair<int, int> &b) { \\n                return a.second < b.second;\\n            };\\n            sort(envelopes.begin(), envelopes.end(), Cmp);\\n            \\n            vector<pair<int, int>> res;\\n            for(int i=0; i<envelopes.size(); i++) {\\n                auto it = std::lower_bound(res.begin(), res.end(), envelopes[i], Cmp2);\\n                if(it == res.end()) res.push_back(envelopes[i]);\\n                else *it = envelopes[i];\\n            }\\n            return res.size();\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            auto Cmp = [](const pair<int, int> &a, const pair<int, int> &b) { \\n                if(a.first < b.first) return true;\\n                if(a.first == b.first && a.second > b.second) return true;\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3830641,
                "title": "easy-c-solution-dp-binary-search-approach-beat-99-61",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        if(a[0]==b[0])\\n            return a[1]>b[1];\\n        return a[0]<b[0];\\n    }\\n    int mostOptimal(vector<vector<int>>& envelopes){\\n       \\n        vector<int> ans;\\n        ans.push_back(envelopes[0][1]);\\n        for(int i=1;i<envelopes.size();i++){\\n            if(envelopes[i][1]>ans.back())\\n                ans.push_back(envelopes[i][1]);\\n            else{\\n                int index=lower_bound(ans.begin(),ans.end(),envelopes[i][1])-ans.begin();\\n                ans[index]=envelopes[i][1];\\n            }\\n        }\\n        return ans.size();\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        sort(envelopes.begin(),envelopes.end(),compare);\\n        int prev=-1;\\n        int curr=0;\\n        return mostOptimal(envelopes);\\n\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b){\\n        if(a[0]==b[0])\\n            return a[1]>b[1];\\n        return a[0]<b[0];\\n    }\\n    int mostOptimal(vector<vector<int>>& envelopes){\\n       \\n        vector<int> ans;\\n        ans.push_back(envelopes[0][1]);\\n        for(int i=1;i<envelopes.size();i++){\\n            if(envelopes[i][1]>ans.back())\\n                ans.push_back(envelopes[i][1]);\\n            else{\\n                int index=lower_bound(ans.begin(),ans.end(),envelopes[i][1])-ans.begin();\\n                ans[index]=envelopes[i][1];\\n            }\\n        }\\n        return ans.size();\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        sort(envelopes.begin(),envelopes.end(),compare);\\n        int prev=-1;\\n        int curr=0;\\n        return mostOptimal(envelopes);\\n\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417917,
                "title": "c-binary-search",
                "content": "\\tclass Solution {\\n\\t\\tprivate:\\n\\n\\t\\t\\tint solve(int n,vector<int> &nums){\\n\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\tans.push_back(nums[0]);\\n\\n\\t\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\t\\tif(nums[i] > ans.back()){\\n\\t\\t\\t\\t\\t\\tans.push_back(nums[i]);\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tint index = lower_bound(ans.begin(),ans.end(),nums[i]) - ans.begin();\\n\\t\\t\\t\\t\\t\\tans[index] = nums[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans.size();\\n\\n\\t\\t\\t}\\n\\tpublic:\\n\\t\\tint maxEnvelopes(vector<vector<int>>& envelopes) {\\n\\n\\t\\t\\tint n = envelopes.size();\\n\\n\\t\\t\\tif(n == 0) return 0;\\n\\n\\t\\t\\tsort(envelopes.begin(),envelopes.end(),[](vector<int> &a, vector<int> &b){\\n\\t\\t\\t\\tif(a[0] == b[0]){   \\n\\t\\t\\t\\t\\treturn a[1] > b[1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn a[0] < b[0];\\n\\t\\t\\t});\\n\\n\\n\\t\\t\\tvector<int> nums;\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tnums.push_back(envelopes[i][1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn solve(n,nums);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tprivate:\\n\\n\\t\\t\\tint solve(int n,vector<int> &nums){\\n\\n\\t\\t\\t\\tvector<int> ans;\\n\\t\\t\\t\\tans.push_back(nums[0]);\\n\\n\\t\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\t\\tif(nums[i] > ans.back()){\\n\\t\\t\\t\\t\\t\\tans.push_back(nums[i]);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2293519,
                "title": "highly-intutive-and-using-comparator",
                "content": "```\\nclass Solution {\\n\\tpublic int maxEnvelopes(int[][] envelopes) {\\n\\t\\tint n = envelopes.length;\\n\\t\\tArrays.sort(envelopes, new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] a, int[] b) {\\n\\t\\t\\t\\treturn a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tint[] height = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\theight[i] = envelopes[i][1];\\n\\n\\t\\treturn lengthOfLIS(height);\\n\\t}\\n\\n\\tpublic int lengthOfLIS(int[] arr) {\\n\\t\\tint piles = 0, n = arr.length;\\n\\t\\tint[] top = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint poker = arr[i];\\n\\t\\t\\tint left = 0, right = piles;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint mid = (left + right) / 2;\\n\\t\\t\\t\\tif (top[mid] >= poker)\\n\\t\\t\\t\\t\\tright = mid;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (left == piles)\\n\\t\\t\\t\\tpiles++;\\n\\t\\t\\ttop[left] = poker;\\n\\t\\t}\\n\\t\\treturn piles;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int maxEnvelopes(int[][] envelopes) {\\n\\t\\tint n = envelopes.length;\\n\\t\\tArrays.sort(envelopes, new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] a, int[] b) {\\n\\t\\t\\t\\treturn a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tint[] height = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\theight[i] = envelopes[i][1];\\n\\n\\t\\treturn lengthOfLIS(height);\\n\\t}\\n\\n\\tpublic int lengthOfLIS(int[] arr) {\\n\\t\\tint piles = 0, n = arr.length;\\n\\t\\tint[] top = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint poker = arr[i];\\n\\t\\t\\tint left = 0, right = piles;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint mid = (left + right) / 2;\\n\\t\\t\\t\\tif (top[mid] >= poker)\\n\\t\\t\\t\\t\\tright = mid;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (left == piles)\\n\\t\\t\\t\\tpiles++;\\n\\t\\t\\ttop[left] = poker;\\n\\t\\t}\\n\\t\\treturn piles;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071234,
                "title": "4-line-of-code-in-c-using-dp",
                "content": "```\\n// please upvote if you like it\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& E) {\\n        sort(E.begin(), E.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];});\\n        vector<int> dp;\\n        for (auto& env : E) {\\n            int height = env[1];\\n            int left = lower_bound(dp.begin(), dp.end(), height) - dp.begin();\\n            if (left == dp.size()) dp.push_back(height);\\n            dp[left] = height;\\n        }\\n        return dp.size();\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& E) {\\n        sort(E.begin(), E.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];}",
                "codeTag": "Java"
            },
            {
                "id": 1134753,
                "title": "simple-dp-lis-box-stacking",
                "content": "It is a simple application of Longest Increasing subsequence. \\nYou Just have to increase the sequence with a smaller element. \\nThere is also a NlogN solution do check it out!\\n\\n```\\n\\tstatic bool compare(pair<int,pair<int,int>>& a,pair<int,pair<int,int>>& b){\\n        return a.first>b.first;\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n=env.size();\\n        vector<int> dp(n,1);\\n        vector<pair<int,pair<int,int>>> envs;\\n        for(int i=0;i<n;i++){\\n            envs.push_back({env[i][0]*env[i][1],{env[i][0],env[i][1]}});\\n        }\\n        \\n        sort(envs.begin(),envs.end(),compare);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(envs[j].second.first>envs[i].second.first && envs[j].second.second>envs[i].second.second){\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n\\t```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tstatic bool compare(pair<int,pair<int,int>>& a,pair<int,pair<int,int>>& b){\\n        return a.first>b.first;\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n=env.size();\\n        vector<int> dp(n,1);\\n        vector<pair<int,pair<int,int>>> envs;\\n        for(int i=0;i<n;i++){\\n            envs.push_back({env[i][0]*env[i][1],{env[i][0],env[i][1]}});\\n        }\\n        \\n        sort(envs.begin(),envs.end(),compare);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(envs[j].second.first>envs[i].second.first && envs[j].second.second>envs[i].second.second){\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 967870,
                "title": "simple-dp-recursive-solution-easy-to-understand-1d-dp",
                "content": "\\nps:- you can make it more faster by sorting the array of envelopes\\n\\n```\\nclass Solution {\\n    static int n;\\n    static int dp[];\\n    public int maxEnvelopes(int[][] a) {\\n        n=a.length;\\n        dp=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return dfs(a,n);        \\n    }\\n    \\n    private static int dfs(int a[][],int prev){\\n        if(dp[prev]!=-1) return dp[prev];\\n        \\n        int x=0,y=0;\\n        if(prev!=n) {\\n           x=a[prev][0];\\n           y=a[prev][1];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i][0]>x && a[i][1]>y){\\n                ans=Math.max(ans,1+dfs(a,i));\\n            }\\n        }\\n        return dp[prev]=ans;\\n     }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int n;\\n    static int dp[];\\n    public int maxEnvelopes(int[][] a) {\\n        n=a.length;\\n        dp=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return dfs(a,n);        \\n    }\\n    \\n    private static int dfs(int a[][],int prev){\\n        if(dp[prev]!=-1) return dp[prev];\\n        \\n        int x=0,y=0;\\n        if(prev!=n) {\\n           x=a[prev][0];\\n           y=a[prev][1];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i][0]>x && a[i][1]>y){\\n                ans=Math.max(ans,1+dfs(a,i));\\n            }\\n        }\\n        return dp[prev]=ans;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852215,
                "title": "c-lis-based-n-logn-with-explanation",
                "content": "We have to find the envelopes with fit inside each other. It is very intuitive to think that the envelopes which fit inside each other would have dimensions in ascending order. So, in the first step, we would arrange the input in increasing order by sorting them on basis of width. \\n\\nInput :           [[5,4],[6,4],[6,7],[2,3]]\\nAfter sorting: [[2,3],[5,4],[6,4],[6,7]]\\n\\nAfter sorting the width, now we have to take care of the heights as well. Again, to make sure that one envelops exactly fit in another the height too has to be in increasing order. Basically now are just left with a subproblem, to find the largest increasing subsequence of height. \\n\\nFor the above example, we are left with finding find LIS of [3,4,4,7]. \\nHere LIS would be 3 -> 4 -> 7, which gives the answer 3.\\n\\n**Notes:**\\n1. Comparator functions have been used to handle caes when widgth are same.\\n2. Please go through Leetcode 300( Longest Increasing Subsequence) in order to understand the approach used for finding LIS.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(), envelopes.end(), [](auto a, auto b){return (a[0]==b[0])?a[1]>b[1]:a[0]<b[0];}); \\n\\t\\t// sort in increasing order of width\\n        \\n        vector<vector<int>> lis;\\n        auto comp=[](auto a, auto b){return (a[1]<b[1])&&(a[0]<b[0]);};\\n\\t\\t//custom comparator for comparing lengths\\n        \\n        for(int i =0; i < envelopes.size(); i++){                                             // find LIS of heights \\n            auto it = lower_bound(lis.begin(), lis.end(), envelopes[i], comp);\\n            \\n            if(it == lis.end()){\\n                lis.emplace_back(envelopes[i]);\\n            } else{\\n                *it = envelopes[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(), envelopes.end(), [](auto a, auto b){return (a[0]==b[0])?a[1]>b[1]:a[0]<b[0];}); \\n\\t\\t// sort in increasing order of width\\n        \\n        vector<vector<int>> lis;\\n        auto comp=[](auto a, auto b){return (a[1]<b[1])&&(a[0]<b[0]);};\\n\\t\\t//custom comparator for comparing lengths\\n        \\n        for(int i =0; i < envelopes.size(); i++){                                             // find LIS of heights \\n            auto it = lower_bound(lis.begin(), lis.end(), envelopes[i], comp);\\n            \\n            if(it == lis.end()){\\n                lis.emplace_back(envelopes[i]);\\n            } else{\\n                *it = envelopes[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707500,
                "title": "solution-using-lambda-in-python",
                "content": "IDEA:\\n1. Sort envelopes according to width or you can sort height also.\\n2. Now , find Longest Increasing Subsequence of height or width(if you sort envelopes according to height).\\n3. Your answer will be length of Longest Increasing Subsequence.\\n\\n***Note**: I have used DP to find LIS with complexity O(n^2) you can also use binary approach which leads to O(nlogn).*\\n```\\ndef maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        if not envelopes:\\n            return 0\\n        envelopes = sorted(envelopes,key=lambda envelop:(envelop[0],-1*envelop[1]))\\n        return self.LIS(envelopes)\\n\\n    def LIS(self,envelopes):\\n        lis = [1]*len(envelopes)\\n        res = 1\\n        for i in range(1,len(envelopes)):\\n            for j in range(0,i):\\n                if(envelopes[j][1] < envelopes[i][1] and lis[i]<lis[j]+1):\\n                    lis[i] = lis[j]+1\\n            if res < lis[i]:\\n                res = lis[i]\\n        return res\\n```\\nStill facing difficulties, comment below.\\nYou can upvote too. :)",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\ndef maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        if not envelopes:\\n            return 0\\n        envelopes = sorted(envelopes,key=lambda envelop:(envelop[0],-1*envelop[1]))\\n        return self.LIS(envelopes)\\n\\n    def LIS(self,envelopes):\\n        lis = [1]*len(envelopes)\\n        res = 1\\n        for i in range(1,len(envelopes)):\\n            for j in range(0,i):\\n                if(envelopes[j][1] < envelopes[i][1] and lis[i]<lis[j]+1):\\n                    lis[i] = lis[j]+1\\n            if res < lis[i]:\\n                res = lis[i]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 530553,
                "title": "accepted-c-sort-lis-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int MaxEnvelopes(int[][] envelopes)\\n    {\\n        if (envelopes == null || envelopes.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(envelopes, (a, b) => a[0] == b[0] ? b[1].CompareTo(a[1]) : a[0].CompareTo(b[0]));\\n        return LengthOfLIS(envelopes.Select(x => x[1]).ToArray());\\n    }\\n    \\n    public int LengthOfLIS(int[] nums)\\n    {\\n        int[] dp = new int[nums.Length];\\n        int len = 0;\\n        foreach (int n in nums)\\n        {\\n            int i = Array.BinarySearch(dp, 0, len, n);\\n            if (i < 0)\\n                i = -(i + 1);\\n            \\n            dp[i] = n;\\n            if (i == len)\\n                len++;\\n        }\\n        \\n        return len;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxEnvelopes(int[][] envelopes)\\n    {\\n        if (envelopes == null || envelopes.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(envelopes, (a, b) => a[0] == b[0] ? b[1].CompareTo(a[1]) : a[0].CompareTo(b[0]));\\n        return LengthOfLIS(envelopes.Select(x => x[1]).ToArray());\\n    }\\n    \\n    public int LengthOfLIS(int[] nums)\\n    {\\n        int[] dp = new int[nums.Length];\\n        int len = 0;\\n        foreach (int n in nums)\\n        {\\n            int i = Array.BinarySearch(dp, 0, len, n);\\n            if (i < 0)\\n                i = -(i + 1);\\n            \\n            dp[i] = n;\\n            if (i == len)\\n                len++;\\n        }\\n        \\n        return len;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294000,
                "title": "java-dp-solution-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    int[] dp;\\n    \\n    public int lengthOfRussianDoll(int index, int[][] envelopes){\\n        \\n\\t\\t// terminating condition aka base case\\n        if(index > envelopes.length-1)\\n            return 0;\\n        \\n        if(dp[index] > 0)\\n            return dp[index];\\n\\n        int maxCount = 0;\\n        \\n\\t\\t// main recursive module\\n        for(int i=index+1;i<envelopes.length;i++){\\n\\t\\t\\t// check if i envelope can be put inside index envelope\\n            if(envelopes[index][1] > envelopes[i][1] && envelopes[index][0] > envelopes[i][0])\\n                maxCount = Math.max(maxCount, lengthOfRussianDoll(i,envelopes)+1);\\n        }\\n        \\n        dp[index] = maxCount;\\n        \\n        return dp[index];\\n    }\\n    \\n    public int maxEnvelopes(int[][] envelopes) {\\n        // edge cases\\n        if(envelopes == null || envelopes.length == 0)\\n            return 0;\\n        \\n\\t\\t// sort the array on envelopes with width descending order.\\n        Arrays.sort(envelopes, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a1, int[] a2){\\n                return a2[0] - a1[0];\\n            }\\n        });\\n        \\n\\t\\t// dp[index] gives the maxium length of russian doll taking index as the outer most envelope.\\n        dp = new int[envelopes.length];\\n        \\n\\t\\t// Now we consider creating the russian doll sequence with considering each envelope as the\\n\\t\\t// outermost envelope and then moving forward. The important thing about sorting is than for any\\n\\t\\t// index i ....only possible indexes will be greater than i. \\n        int maxCount = 0;\\n        for(int i=0;i<envelopes.length;i++){\\n            maxCount = Math.max(maxCount, lengthOfRussianDoll(i,envelopes)+1);        \\n        }\\n        \\n        return maxCount;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[] dp;\\n    \\n    public int lengthOfRussianDoll(int index, int[][] envelopes){\\n        \\n\\t\\t// terminating condition aka base case\\n        if(index > envelopes.length-1)\\n            return 0;\\n        \\n        if(dp[index] > 0)\\n            return dp[index];\\n\\n        int maxCount = 0;\\n        \\n\\t\\t// main recursive module\\n        for(int i=index+1;i<envelopes.length;i++){\\n\\t\\t\\t// check if i envelope can be put inside index envelope\\n            if(envelopes[index][1] > envelopes[i][1] && envelopes[index][0] > envelopes[i][0])\\n                maxCount = Math.max(maxCount, lengthOfRussianDoll(i,envelopes)+1);\\n        }\\n        \\n        dp[index] = maxCount;\\n        \\n        return dp[index];\\n    }\\n    \\n    public int maxEnvelopes(int[][] envelopes) {\\n        // edge cases\\n        if(envelopes == null || envelopes.length == 0)\\n            return 0;\\n        \\n\\t\\t// sort the array on envelopes with width descending order.\\n        Arrays.sort(envelopes, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a1, int[] a2){\\n                return a2[0] - a1[0];\\n            }\\n        });\\n        \\n\\t\\t// dp[index] gives the maxium length of russian doll taking index as the outer most envelope.\\n        dp = new int[envelopes.length];\\n        \\n\\t\\t// Now we consider creating the russian doll sequence with considering each envelope as the\\n\\t\\t// outermost envelope and then moving forward. The important thing about sorting is than for any\\n\\t\\t// index i ....only possible indexes will be greater than i. \\n        int maxCount = 0;\\n        for(int i=0;i<envelopes.length;i++){\\n            maxCount = Math.max(maxCount, lengthOfRussianDoll(i,envelopes)+1);        \\n        }\\n        \\n        return maxCount;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016011,
                "title": "russian-doll-envelopes-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  static bool comp(vector<int> &a, vector<int> &b){\\n      if(a[0] == b[0])\\n        return a[1]>b[1];\\n\\n    return a[0]<b[0];\\n  }\\n  int solveOptimal(int n, vector<vector<int>>& envelopes){\\n      if(n==0)\\n       return 0;\\n    vector<int> ans;\\n    ans.push_back(envelopes[0][1]);\\n    for(int i=1; i<n; i++){\\n        if(envelopes[i][1]>ans.back())\\n           ans.push_back(envelopes[i][1]);\\n        else{\\n            int index = lower_bound(ans.begin(),ans.end(),envelopes[i][1]) - ans.begin();\\n            ans[index] = envelopes[i][1];\\n        }\\n    }\\n    return ans.size();\\n  }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(),envelopes.end(), comp);\\n\\n        return solveOptimal(n,envelopes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  static bool comp(vector<int> &a, vector<int> &b){\\n      if(a[0] == b[0])\\n        return a[1]>b[1];\\n\\n    return a[0]<b[0];\\n  }\\n  int solveOptimal(int n, vector<vector<int>>& envelopes){\\n      if(n==0)\\n       return 0;\\n    vector<int> ans;\\n    ans.push_back(envelopes[0][1]);\\n    for(int i=1; i<n; i++){\\n        if(envelopes[i][1]>ans.back())\\n           ans.push_back(envelopes[i][1]);\\n        else{\\n            int index = lower_bound(ans.begin(),ans.end(),envelopes[i][1]) - ans.begin();\\n            ans[index] = envelopes[i][1];\\n        }\\n    }\\n    return ans.size();\\n  }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(),envelopes.end(), comp);\\n\\n        return solveOptimal(n,envelopes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760081,
                "title": "dp-binary-search-solution",
                "content": "\\n# Approach\\nSort the envelopes based on their widths in ascending order. If two envelopes have the same width, sort them in descending order of their heights. This sorting is done using a custom comparator function passed to the sort function.\\n\\nExtract the heights of the sorted envelopes and store them in the ans vector.\\n\\nDefine a helper function lis that takes the ans vector and its size n as input and returns the length of the longest increasing subsequence.\\n\\nInitialize a result vector and push the first element of ans into it.\\n\\nIterate through the remaining elements of ans starting from index 1.\\n\\nIf the current element is greater than the last element in the result vector, it can be nested inside the envelopes encountered so far. Hence, push the current element to the result vector.\\n\\nIf the current element is not greater, find the index where it can be placed in the result vector using the lower_bound function. Update the element at that index with the current element.\\n\\nFinally, return the size of the result vector, which represents the length of the longest increasing subsequence.\\n\\nIn the maxEnvelopes function, call the lis function with the ans vector and its size, and return the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lis(vector<int>& ans, int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        vector<int> result;\\n        result.push_back(ans[0]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (ans[i] > result.back()) {\\n                result.push_back(ans[i]);\\n            }\\n            else {\\n                int index = lower_bound(result.begin(), result.end(), ans[i]) - result.begin();\\n                result[index] = ans[i];\\n            }\\n        }\\n        \\n        return result.size();\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        // SORT THE VECTOR\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n        });\\n        \\n        vector<int> ans;\\n        for (auto i : envelopes) {\\n            ans.push_back(i[1]);\\n        }\\n        \\n        int n = ans.size();\\n        return lis(ans, n);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lis(vector<int>& ans, int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        vector<int> result;\\n        result.push_back(ans[0]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (ans[i] > result.back()) {\\n                result.push_back(ans[i]);\\n            }\\n            else {\\n                int index = lower_bound(result.begin(), result.end(), ans[i]) - result.begin();\\n                result[index] = ans[i];\\n            }\\n        }\\n        \\n        return result.size();\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        // SORT THE VECTOR\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n        });\\n        \\n        vector<int> ans;\\n        for (auto i : envelopes) {\\n            ans.push_back(i[1]);\\n        }\\n        \\n        int n = ans.size();\\n        return lis(ans, n);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332337,
                "title": "4-approch-with-explain-same-as-lis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLONGEST INCREASING SUBSEQUENCE SAME\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRussian dolls hai unko envelops me dalna hai to sort kardia width wise but agar width same hui kisi ki toh kya kre?\\n\\nto hmne HIEGHT ko sort krdia but descending order me an descending order me kyu kara ?\\nbeacuse hum LIS lga sake uspr agar hum normal karenge to mja n aaega..\\n(Complex hoega)\\n\\n#love babar bhaiya\\n\\n# Complexity\\n- Time complexity:RECURSION->exponential (TLE)\\n- MEMOIZATION-> O(N*N) (TLE)\\n- TOP-DOWN-> O(N*N) (TLE)\\n- Binary search ->O(N*LOG(N)) (optimised)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- MEMOIZATION-> O(N*N)\\n- TOP-DOWN-> O(N*N)\\n- Binary search ->O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    // int solve(int n, vector<vector<int>>& envelopes,int curr,int prev)\\n    // {\\n    //     if(curr == n)\\n    //     {\\n    //         return 0;\\n    //     }\\n\\n    //     int include=0;\\n    //     if(prev == -1 or (envelopes[prev][0] < envelopes[curr][0] and \\n    //     envelopes[prev][1] < envelopes[curr][1]))\\n    //     {\\n             //check with and heigth both\\n    //         include = 1 + solve(n,envelopes,curr+1,curr);\\n    //     }\\n\\n    //     int exclude = 0 + solve(n,envelopes, curr+1, prev);\\n\\n    //     return max(include,exclude);\\n    // }\\n\\n    // int solve_mem(int n, vector<vector<int>>& envelopes,int curr,int prev,vector<vector<int>> &dp)\\n    // {\\n    //     if(curr == n)\\n    //     {\\n    //         return 0;\\n    //     }\\n\\n    //     if(dp[curr][prev+1] != -1)\\n    //     return dp[curr][prev+1];\\n\\n\\n    //     int include=0;\\n    //     if(prev == -1 or (envelopes[prev][0] < envelopes[curr][0] and \\n    //     envelopes[prev][1] < envelopes[curr][1]))\\n    //     {\\n    //         include = 1 + solve_mem(n,envelopes,curr+1,curr,dp);\\n    //     }\\n\\n    //     int exclude = 0 + solve_mem(n,envelopes, curr+1, prev,dp);\\n\\n    //     dp[curr][prev+1] = max(include,exclude);\\n\\n    //     return dp[curr][prev+1];\\n    // }\\n\\n    static bool comp(const vector<int> &v1,const vector<int> &v2)\\n    {\\n        if(v1[0] == v2[0])\\n        {\\n            return v1[1] > v2[1];\\n        }\\n        else\\n        return v2[0] > v1[0];\\n    }\\n\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n\\n\\n        // sort(envelopes.begin(),envelopes.end());\\n\\n        //   for(int i=0;i<envelopes.size();i++)\\n        //   {\\n        //       for(int j=0;j<envelopes[0].size();j++)\\n        //       {\\n        //           cout<<\"envelopes[i][j]\"<<envelopes[i][j]<<\" \";\\n        //       }\\n        //       cout<<endl;\\n        //   }\\n\\n        //RECURSION\\n        // return solve(envelopes.size(), envelopes, 0, -1);\\n        \\n        //MEMOIZATION\\n        // vector<vector<int>> dp(envelopes.size()+1,vector<int>(envelopes.size()+1,-1));\\n        // return solve_mem(envelopes.size(), envelopes, 0, -1,dp);\\n\\n        //TABULATION\\n\\n        // vector<vector<int>> dp(envelopes.size()+1,vector<int>(envelopes.size()+1,0));\\n        // int n=envelopes.size();\\n        // for(int curr = n-1; curr>=0; curr--)\\n        // {\\n        //     for(int prev= curr-1; prev>=-1; prev--)\\n        //     {\\n        //             int include=0;\\n        //             if(prev == -1 or (envelopes[prev][0] < envelopes[curr][0] and \\n        //             envelopes[prev][1] < envelopes[curr][1]))\\n        //             {\\n        //                 include = 1 + dp[curr+1][curr+1];\\n        //             }\\n\\n        //             int exclude = 0 + dp[curr+1][prev+1];\\n\\n        //             dp[curr][prev+1] = max(include,exclude);\\n        //     }\\n        // }\\n\\n        // return dp[0][0];\\n\\n        //BINARY SEARCH\\n\\n    //      \\n      int n = envelopes.size();\\n        sort(envelopes.begin(),envelopes.end(),comp);\\n        vector<int>arr;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(arr.empty() || arr.back()<envelopes[i][1])\\n                arr.push_back(envelopes[i][1]);\\n            else\\n            {\\n                int index = lower_bound(arr.begin(),arr.end(),envelopes[i][1])\\n                        -   arr.begin();\\n                arr[index] = envelopes[i][1];\\n            }\\n        }\\n        \\n        return arr.size();\\n    }\\n};\\n\\n\\n// class Solution {\\n// public:\\n//     static bool cmp(const vector<int>& v1, const vector<int>& v2)\\n//     {\\n//       if(v1[0] == v2[0]) return v1[1] > v2[1];\\n//             return v1[0]<v2[0];\\n//     }\\n//     int maxEnvelopes(vector<vector<int>>& envelopes) {\\n//         int n = envelopes.size();\\n//         sort(envelopes.begin(),envelopes.end(),cmp);\\n//         vector<int>arr;\\n//         for(int i =0;i<n;i++)\\n//         {\\n//             if(arr.empty() || arr.back()<envelopes[i][1])\\n//                 arr.push_back(envelopes[i][1]);\\n//             else\\n//             {\\n//                 int index = lower_bound(arr.begin(),arr.end(),envelopes[i][1])\\n//                         -   arr.begin();\\n//                 arr[index] = envelopes[i][1];\\n//             }\\n//         }\\n        \\n//         return arr.size();\\n//     }\\n// };\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    // int solve(int n, vector<vector<int>>& envelopes,int curr,int prev)\\n    // {\\n    //     if(curr == n)\\n    //     {\\n    //         return 0;\\n    //     }\\n\\n    //     int include=0;\\n    //     if(prev == -1 or (envelopes[prev][0] < envelopes[curr][0] and \\n    //     envelopes[prev][1] < envelopes[curr][1]))\\n    //     {\\n             //check with and heigth both\\n    //         include = 1 + solve(n,envelopes,curr+1,curr);\\n    //     }\\n\\n    //     int exclude = 0 + solve(n,envelopes, curr+1, prev);\\n\\n    //     return max(include,exclude);\\n    // }\\n\\n    // int solve_mem(int n, vector<vector<int>>& envelopes,int curr,int prev,vector<vector<int>> &dp)\\n    // {\\n    //     if(curr == n)\\n    //     {\\n    //         return 0;\\n    //     }\\n\\n    //     if(dp[curr][prev+1] != -1)\\n    //     return dp[curr][prev+1];\\n\\n\\n    //     int include=0;\\n    //     if(prev == -1 or (envelopes[prev][0] < envelopes[curr][0] and \\n    //     envelopes[prev][1] < envelopes[curr][1]))\\n    //     {\\n    //         include = 1 + solve_mem(n,envelopes,curr+1,curr,dp);\\n    //     }\\n\\n    //     int exclude = 0 + solve_mem(n,envelopes, curr+1, prev,dp);\\n\\n    //     dp[curr][prev+1] = max(include,exclude);\\n\\n    //     return dp[curr][prev+1];\\n    // }\\n\\n    static bool comp(const vector<int> &v1,const vector<int> &v2)\\n    {\\n        if(v1[0] == v2[0])\\n        {\\n            return v1[1] > v2[1];\\n        }\\n        else\\n        return v2[0] > v1[0];\\n    }\\n\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n\\n\\n        // sort(envelopes.begin(),envelopes.end());\\n\\n        //   for(int i=0;i<envelopes.size();i++)\\n        //   {\\n        //       for(int j=0;j<envelopes[0].size();j++)\\n        //       {\\n        //           cout<<\"envelopes[i][j]\"<<envelopes[i][j]<<\" \";\\n        //       }\\n        //       cout<<endl;\\n        //   }\\n\\n        //RECURSION\\n        // return solve(envelopes.size(), envelopes, 0, -1);\\n        \\n        //MEMOIZATION\\n        // vector<vector<int>> dp(envelopes.size()+1,vector<int>(envelopes.size()+1,-1));\\n        // return solve_mem(envelopes.size(), envelopes, 0, -1,dp);\\n\\n        //TABULATION\\n\\n        // vector<vector<int>> dp(envelopes.size()+1,vector<int>(envelopes.size()+1,0));\\n        // int n=envelopes.size();\\n        // for(int curr = n-1; curr>=0; curr--)\\n        // {\\n        //     for(int prev= curr-1; prev>=-1; prev--)\\n        //     {\\n        //             int include=0;\\n        //             if(prev == -1 or (envelopes[prev][0] < envelopes[curr][0] and \\n        //             envelopes[prev][1] < envelopes[curr][1]))\\n        //             {\\n        //                 include = 1 + dp[curr+1][curr+1];\\n        //             }\\n\\n        //             int exclude = 0 + dp[curr+1][prev+1];\\n\\n        //             dp[curr][prev+1] = max(include,exclude);\\n        //     }\\n        // }\\n\\n        // return dp[0][0];\\n\\n        //BINARY SEARCH\\n\\n    //      \\n      int n = envelopes.size();\\n        sort(envelopes.begin(),envelopes.end(),comp);\\n        vector<int>arr;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(arr.empty() || arr.back()<envelopes[i][1])\\n                arr.push_back(envelopes[i][1]);\\n            else\\n            {\\n                int index = lower_bound(arr.begin(),arr.end(),envelopes[i][1])\\n                        -   arr.begin();\\n                arr[index] = envelopes[i][1];\\n            }\\n        }\\n        \\n        return arr.size();\\n    }\\n};\\n\\n\\n// class Solution {\\n// public:\\n//     static bool cmp(const vector<int>& v1, const vector<int>& v2)\\n//     {\\n//       if(v1[0] == v2[0]) return v1[1] > v2[1];\\n//             return v1[0]<v2[0];\\n//     }\\n//     int maxEnvelopes(vector<vector<int>>& envelopes) {\\n//         int n = envelopes.size();\\n//         sort(envelopes.begin(),envelopes.end(),cmp);\\n//         vector<int>arr;\\n//         for(int i =0;i<n;i++)\\n//         {\\n//             if(arr.empty() || arr.back()<envelopes[i][1])\\n//                 arr.push_back(envelopes[i][1]);\\n//             else\\n//             {\\n//                 int index = lower_bound(arr.begin(),arr.end(),envelopes[i][1])\\n//                         -   arr.begin();\\n//                 arr[index] = envelopes[i][1];\\n//             }\\n//         }\\n        \\n//         return arr.size();\\n//     }\\n// };\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2175259,
                "title": "what-i-understood-from-all-lis-solution",
                "content": "\\n// this is nlogn lis variant\\nwe need to sort the weights in increasing order but if they are equal then\\n   heights should be in decreasing order , this is done to ensure that when we\\n   do lis on the height the lower one do not gets picked up. eg\\n   \\n   [[5,4],[6,5],[6,7],[2,3]]\\n   \\n   after sorting in inc width and height for same width\\n   \\n   [[2,3] [5,4] [6,5] [6,7]]\\n   \\n   { 3, 4, 5, 7} this is telling we can put 3rd envolope in 4th but its false\\n   so thats why we do reverse sort for same width\\n   \\n   [[2,3] [5,4] [6,7] [6,5]]\\n   {3,4,7} {3,4,5} this wont allow lower value to be part of lis as big is ahead\\n   \\n\\n    // time = nlogn\\n\\n```\\n    bool static comp(vector<int> &a, vector<int> &b){\\n        if(a[0] == b[0]){\\n            return a[1] > b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end(),comp);\\n        vector<int> temp;\\n        temp.push_back(envelopes[0][1]);\\n        for(int i=1; i<envelopes.size(); ++i){\\n            if(temp.back() < envelopes[i][1]){\\n                temp.push_back(envelopes[i][1]);\\n            }else{\\n                int idx = lower_bound(temp.begin(),temp.end(),envelopes[i][1])\\n                    - temp.begin();\\n                temp[idx] = envelopes[i][1];\\n            }\\n        }\\n        return temp.size();\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    bool static comp(vector<int> &a, vector<int> &b){\\n        if(a[0] == b[0]){\\n            return a[1] > b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end(),comp);\\n        vector<int> temp;\\n        temp.push_back(envelopes[0][1]);\\n        for(int i=1; i<envelopes.size(); ++i){\\n            if(temp.back() < envelopes[i][1]){\\n                temp.push_back(envelopes[i][1]);\\n            }else{\\n                int idx = lower_bound(temp.begin(),temp.end(),envelopes[i][1])\\n                    - temp.begin();\\n                temp[idx] = envelopes[i][1];\\n            }\\n        }\\n        return temp.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2073930,
                "title": "russian-doll-envelopes-o-nlogn-lis-binary-search",
                "content": "First, we sort the Envelopes. width in ascending order and height in decending order. Then apply LIS (Longest Increasing Subsequence) on height to find the required length.\\n\\nWhy height in decending order?\\nIf we sort the height in ascending order and If the width of two envelopes are same and the height of first envelope is less than the next envelope, there will be LIS of 2 length but first envelope can not fit in next envelope because the width of both envelopes are same.\\nExample: If sort both width and height in ascending order : [6,4],[6,7]. Here LIS will be [4,7], lenght will be 2 but they can not fit.\\nIf sort width in ascending order and height in decending order : [6,7],[6,4]. Here LIS will be either [7] or [4], length will be 1 because they can not fit.\\n\\nIf width of some envelopes are same, they can not fit. Here We apply the LIS with respect to height, we sort the height in decending order so that the envelopes with same width can not be in one LIS.\\n\\n\\nHere we will use binary search to find the length of LIS. Binary Search approach can only find the length of LIS but not the elements of LIS.\\nLet\\'s create a list lis to store the LIS. It may not be valid LIS but length will be correct.\\n\\nSuppose a new element come, find the index where it can fit in lis so that lis will be in increasing subsequence. If it can not fit in lis, append in the lis.\\n\\nExample: [1,7,8,4,5,6,-1,9]\\nlis : []\\n(i)   element 1 : lis -> [1]\\n(ii)  element 7 : lis -> [1,7]\\n(iii) element 8 : lis -> [1,7,8]\\n(iv)  element 4 : lis -> [1,4,8]  4 fit at place of 7. Now suppose two or more elements new element come greater than 4 but less tha equal to 7 in increasing sequence (e.g. [5,6,7]), we can find a larger subsequence([1,4,5,6,7]) than the previous subsequence ([1,7,8])\\n(v)   element 5 : lis -> [1,4,5] 5 can fit at place of 8. You can think that a new element come that can be in increasing sequence with 8 element (e.g. 10) but That element also will be in increasing subsequence with lesser element than 8 elemnt (e.g. 5).\\n(vi)  element 6 : lis -> [1,4,5,6]\\n(vii) element -1: lis -> [-1,4,5,6]\\n(viii)element 9 : lis -> [-1,4,5,6,9]\\n\\nThis is not the valid LIS ([-1,4,5,6,9]) but length of the longest valid subsequence will be equal to this LIS.\\nIn a valid subsequence element at a index will be greater than or equal to the element at that index in this LIS.\\n\\nHere we will use binary search to find the position of new element where it can fit in the lis.\\n\\nCollections.binarySearch(List<T>, T) return the index of the element in the list if it is present in the list.\\nIf it is not present in the list, it will return  -(insertion index)-1 or -(insertion index+1).\\nIf it is negative, multiply by -1 and then subtract 1 from it to find the correct position in lis.\\n\\nclass Solution {\\n    \\n    List<Integer> lis;\\n    public int maxEnvelopes(int[][] envelopes) {\\n        \\n        Arrays.sort(envelopes, (a, b)-> a[0]==b[0] ? b[1]-a[1] : a[0]-b[0]); //sort width in asending order and height in desending order.\\n        \\n        lis = new ArrayList<>();\\n        \\n        lis.add(envelopes[0][1]);\\n        \\n        for(int k=1; k<envelopes.length; k++){\\n            \\n            if(lis.get(lis.size()-1) < envelopes[k][1]) lis.add(envelopes[k][1]);\\n            else lis.set(binarySearch(envelopes[k][1]), envelopes[k][1]);\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int binarySearch(int height){\\n        \\n        int i = Collections.binarySearch(lis, height);\\n        if(i < 0){\\n            \\n            i *= -1;\\n            i -= 1;\\n        }\\n        return i;\\n        \\n        /*int low = 0, high = lis.size()-1, mid, pos = 0;\\n        \\n        while(low <= high){\\n            \\n            mid = (low + high)/2;\\n            if(lis.get(mid) == height) return mid;\\n            if(lis.get(mid) < height){\\n                \\n                pos = mid+1;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        return pos;*/\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n    List<Integer> lis;\\n    public int maxEnvelopes(int[][] envelopes) {\\n        \\n        Arrays.sort(envelopes, (a, b)-> a[0]==b[0] ? b[1]-a[1] : a[0]-b[0]); //sort width in asending order and height in desending order.\\n        \\n        lis = new ArrayList<>();\\n        \\n        lis.add(envelopes[0][1]);\\n        \\n        for(int k=1; k<envelopes.length; k++){\\n            \\n            if(lis.get(lis.size()-1) < envelopes[k][1]) lis.add(envelopes[k][1]);\\n            else lis.set(binarySearch(envelopes[k][1]), envelopes[k][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2072549,
                "title": "c-2-approaches-well-explained-o-n-2-o-nlogn-easy-clean-code",
                "content": "**Approach-1:** O(N^2) Approach | passed 85/87 testcases\\nstep-1 sort the ds\\n step-2: Solve it like LIS problem (https://leetcode.com/problems/longest-increasing-subsequence/discuss/2072338/c-on2-solution-explained-through-comments) \\n\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        //step-1: sort the envelopes in increasing order\\n        sort(envelopes.begin(), envelopes.end());\\n        \\n        int n = envelopes.size(), mx = 1; //1 envelope will be there always\\n        \\n        vector<int> LIS(n, 1);  //1 for a single envelop\\n        \\n        //step-2: find LIS(Longest Increasing Sequence)\\n        for(int i=1;i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(envelopes[i][0]> envelopes[j][0] && envelopes[i][1]> envelopes[j][1] && LIS[i]<=LIS[j])\\n                   LIS[i] = 1+ LIS[j];\\n            }\\n            mx = max(mx, LIS[i]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```\\n\\n**Approach-2:** O(NlogN) Approach\\n```\\nclass Solution {\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        if(a[0]==b[0]) return a[1] > b[1];\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n = env.size();\\n        \\n        // sorting by height & if we encounter same height\\n        // sort by descending order of width\\n        sort(env.begin(), env.end(), cmp);\\n        \\n      \\n        vector<int> lis;\\n        \\n        for(int i = 0;i<env.size();i++){\\n            int ele = env[i][1];\\n            \\n            int idx = lower_bound(lis.begin(), lis.end(), ele) - lis.begin();\\n            \\n            if(idx >= lis.size()) lis.push_back(ele);\\n            else lis[idx] = ele;\\n        }\\n        \\n        return lis.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        //step-1: sort the envelopes in increasing order\\n        sort(envelopes.begin(), envelopes.end());\\n        \\n        int n = envelopes.size(), mx = 1; //1 envelope will be there always\\n        \\n        vector<int> LIS(n, 1);  //1 for a single envelop\\n        \\n        //step-2: find LIS(Longest Increasing Sequence)\\n        for(int i=1;i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(envelopes[i][0]> envelopes[j][0] && envelopes[i][1]> envelopes[j][1] && LIS[i]<=LIS[j])\\n                   LIS[i] = 1+ LIS[j];\\n            }\\n            mx = max(mx, LIS[i]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        if(a[0]==b[0]) return a[1] > b[1];\\n        return a[0] < b[0];\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n = env.size();\\n        \\n        // sorting by height & if we encounter same height\\n        // sort by descending order of width\\n        sort(env.begin(), env.end(), cmp);\\n        \\n      \\n        vector<int> lis;\\n        \\n        for(int i = 0;i<env.size();i++){\\n            int ele = env[i][1];\\n            \\n            int idx = lower_bound(lis.begin(), lis.end(), ele) - lis.begin();\\n            \\n            if(idx >= lis.size()) lis.push_back(ele);\\n            else lis[idx] = ele;\\n        }\\n        \\n        return lis.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072008,
                "title": "c-4-approaches-recursion-memoization-tabulation-binary-search",
                "content": "**1. Recursion\\nCODE:**\\n\\n    // Recursion  *** Will Give TLE ***\\n    int solve(int idx, int prev, vector<vector<int>> &arr, int n) {\\n        if(idx == n)\\n            return 0;\\n        int take = 0, untake = 0;\\n        untake = solve(idx+1, prev, arr, n);\\n        if((prev == -1) || (arr[idx][0] > arr[prev][0] && arr[idx][1] > arr[prev][1])) {\\n            take = 1 + solve(idx+1, idx, arr, n);\\n        }\\n        return max(take, untake);\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end());\\n        return solve(0, -1, envelopes, n);\\n    }\\n\\t\\t\\n**2. Recursion + Memoization\\nCODE:**\\n\\n\\t// Memoization  *** Will Give TLE ***\\n     int solve(int idx, int prev, vector<vector<int>> &arr, int n, vector<vector<int>>&dp) {\\n        if(idx == n)\\n            return 0;\\n        int take = 0, untake = 0;\\n        if(dp[idx][prev+1] != -1)\\n            return dp[idx][prev+1];\\n        untake = solve(idx+1, prev, arr, n, dp);\\n        if((prev == -1) || (arr[idx][0] > arr[prev][0] && arr[idx][1] > arr[prev][1])) {\\n            take = 1 + solve(idx+1, idx, arr, n, dp);\\n        }\\n        return dp[idx][prev+1] = max(take, untake);\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end());\\n        vector<vector<int>>dp(n, vector<int>(n+1, -1));\\n        return solve(0, -1, envelopes, n, dp);\\n    }\\n\\t\\t\\n\\t\\t\\n**3. Tabulation\\nCODE:**\\n \\n\\t // Tabulation  *** Will Give TLE ***\\n\\t\\tint maxEnvelopes(vector<vector<int>>& envelopes) {\\n\\t\\t\\tint n = envelopes.size();\\n\\t\\t\\tif(n == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tsort(envelopes.begin(), envelopes.end());\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tint take = 0, untake = 0;\\n\\t\\t\\tfor(int idx = 0; idx < n; idx++) {\\n\\t\\t\\t\\tfor(int prev = 0; prev < idx; prev++) {\\n\\t\\t\\t\\t\\tif(envelopes[idx][0] > envelopes[prev][0] && envelopes[idx][1] > envelopes[prev][1]) {\\n\\t\\t\\t\\t\\t\\tdp[idx] = max(dp[idx], 1 + dp[prev]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn *max_element(dp.begin(),dp.end());\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n**4. Binary Search Approach\\nCODE:**\\n\\n\\t // Binary Search\\n\\t\\t  static bool comp(const vector<int> &a, const vector<int> &b) {\\n\\t\\t\\tif(a[0] < b[0])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\telse if(a[0] > b[0])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\telse if(a[1] > b[1])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn false;\\n\\t\\t  } \\n\\t\\t  int maxEnvelopes(vector<vector<int>>& envelopes) {\\n\\t\\t\\tsort(envelopes.begin(), envelopes.end(), comp);\\n\\t\\t\\tvector<int> dp;\\n\\t\\t\\tfor (auto it : envelopes)\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto iter = lower_bound(dp.begin(), dp.end(), it[1]);\\n\\t\\t\\t\\tif (iter == dp.end())\\n\\t\\t\\t\\t\\tdp.push_back(it[1]);\\n\\t\\t\\t\\telse if (it[1] < *iter)\\n\\t\\t\\t\\t\\t*iter = it[1];\\n\\t\\t\\t}\\n\\t\\t\\treturn dp.size();\\n\\t\\t}\\n",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "**1. Recursion\\nCODE:**\\n\\n    // Recursion  *** Will Give TLE ***\\n    int solve(int idx, int prev, vector<vector<int>> &arr, int n) {\\n        if(idx == n)\\n            return 0;\\n        int take = 0, untake = 0;\\n        untake = solve(idx+1, prev, arr, n);\\n        if((prev == -1) || (arr[idx][0] > arr[prev][0] && arr[idx][1] > arr[prev][1])) {\\n            take = 1 + solve(idx+1, idx, arr, n);\\n        }\\n        return max(take, untake);\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end());\\n        return solve(0, -1, envelopes, n);\\n    }\\n\\t\\t\\n**2. Recursion + Memoization\\nCODE:**\\n\\n\\t// Memoization  *** Will Give TLE ***\\n     int solve(int idx, int prev, vector<vector<int>> &arr, int n, vector<vector<int>>&dp) {\\n        if(idx == n)\\n            return 0;\\n        int take = 0, untake = 0;\\n        if(dp[idx][prev+1] != -1)\\n            return dp[idx][prev+1];\\n        untake = solve(idx+1, prev, arr, n, dp);\\n        if((prev == -1) || (arr[idx][0] > arr[prev][0] && arr[idx][1] > arr[prev][1])) {\\n            take = 1 + solve(idx+1, idx, arr, n, dp);\\n        }\\n        return dp[idx][prev+1] = max(take, untake);\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end());\\n        vector<vector<int>>dp(n, vector<int>(n+1, -1));\\n        return solve(0, -1, envelopes, n, dp);\\n    }\\n\\t\\t\\n\\t\\t\\n**3. Tabulation\\nCODE:**\\n \\n\\t // Tabulation  *** Will Give TLE ***\\n\\t\\tint maxEnvelopes(vector<vector<int>>& envelopes) {\\n\\t\\t\\tint n = envelopes.size();\\n\\t\\t\\tif(n == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tsort(envelopes.begin(), envelopes.end());\\n\\t\\t\\tvector<int>dp(n, 1);\\n\\t\\t\\tint take = 0, untake = 0;\\n\\t\\t\\tfor(int idx = 0; idx < n; idx++) {\\n\\t\\t\\t\\tfor(int prev = 0; prev < idx; prev++) {\\n\\t\\t\\t\\t\\tif(envelopes[idx][0] > envelopes[prev][0] && envelopes[idx][1] > envelopes[prev][1]) {\\n\\t\\t\\t\\t\\t\\tdp[idx] = max(dp[idx], 1 + dp[prev]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn *max_element(dp.begin(),dp.end());\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n**4. Binary Search Approach\\nCODE:**\\n\\n\\t // Binary Search\\n\\t\\t  static bool comp(const vector<int> &a, const vector<int> &b) {\\n\\t\\t\\tif(a[0] < b[0])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\telse if(a[0] > b[0])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\telse if(a[1] > b[1])\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn false;\\n\\t\\t  } \\n\\t\\t  int maxEnvelopes(vector<vector<int>>& envelopes) {\\n\\t\\t\\tsort(envelopes.begin(), envelopes.end(), comp);\\n\\t\\t\\tvector<int> dp;\\n\\t\\t\\tfor (auto it : envelopes)\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto iter = lower_bound(dp.begin(), dp.end(), it[1]);\\n\\t\\t\\t\\tif (iter == dp.end())\\n\\t\\t\\t\\t\\tdp.push_back(it[1]);\\n\\t\\t\\t\\telse if (it[1] < *iter)\\n\\t\\t\\t\\t\\t*iter = it[1];\\n\\t\\t\\t}\\n\\t\\t\\treturn dp.size();\\n\\t\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2071992,
                "title": "java-sorting-lis-tle-mle-o-n-2-o-n-logn",
                "content": "__COUPLE OF SOLUTIONS IN JAVA__\\n* Below is Naive approach which throws TLE.\\n ```\\nclass Solution {\\n    \\n    private int MAX_VALUE = 100002;\\n        \\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);\\n        int[] prev = new int[]{MAX_VALUE, MAX_VALUE};\\n        return LIS(envelopes, envelopes.length - 1, prev);\\n    }\\n    \\n    private int LIS(int[][] envelopes, int index, int[] prev){\\n        if(index == 0){\\n            return (envelopes[0][0] < prev[0] && envelopes[0][1] < prev[1]) ? 1 : 0;\\n        }\\n        int exclude = LIS(envelopes, index - 1, prev);\\n        int include = 0;\\n        if(envelopes[index][0] < prev[0] && envelopes[index][1] < prev[1]){\\n            include = 1 + LIS(envelopes, index - 1, envelopes[index]);\\n        }\\n\\n        return Math.max(exclude, include);\\n    }\\n}\\n ```\\n * Below is Memoized approach which  throws MLE.\\n ```\\n class Solution {\\n    \\n    private int MAX_VALUE = 100002;\\n        \\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);\\n        int[] prev = new int[]{MAX_VALUE, MAX_VALUE};\\n        int[][][] dp = new int[envelopes.length][MAX_VALUE + 1][MAX_VALUE + 1];\\n        \\n        for(int[][] grid : dp)\\n            for(int[] row : grid)\\n                Arrays.fill(row, -1);\\n        \\n        return LIS(envelopes, envelopes.length - 1, prev, dp);\\n    }\\n    \\n    private int LIS(int[][] envelopes, int index, int[] prev, int[][][] dp){\\n        if(index == 0){\\n            return (envelopes[0][0] < prev[0] && envelopes[0][1] < prev[1]) ? 1 : 0;\\n        }\\n        \\n        if(dp[index][prev[0]][prev[1]] != -1) return dp[index][prev[0]][prev[1]];\\n        int exclude = LIS(envelopes, index - 1, prev, dp);\\n        int include = 0;\\n        if(envelopes[index][0] < prev[0] && envelopes[index][1] < prev[1]){\\n            include = 1 + LIS(envelopes, index - 1, envelopes[index], dp);\\n        }\\n\\n        return dp[index][prev[0]][prev[1]] = Math.max(exclude, include);\\n    }\\n \\n}\\n ```\\n * Below is Optmized approach which must pass all cases but sadly passes oly 85/87 TC and also throws TLE\\uD83E\\uDD72.\\n ```\\n class Solution {\\n    \\n    private int MAX_VALUE = 100002;\\n        \\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length, maxNumberOfEnvelopes = 1;\\n        \\n        // We sort According to Width!!\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);\\n        \\n        for(int[] envelope : envelopes)\\n            System.out.println(envelope[0] + \" \" + envelope[1]);\\n        \\n        // We find LIS according to Height!!\\n        int prev = MAX_VALUE;\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        \\n        for(int i = 1;i < n; i++){\\n            dp[i] = 1;\\n            for(int j = 0; j < i; j++)\\n                if(envelopes[i][0] != envelopes[j][0] && envelopes[i][1] > envelopes[j][1])\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n            \\n            maxNumberOfEnvelopes = Math.max(maxNumberOfEnvelopes, dp[i]);\\n        }\\n        \\n       return maxNumberOfEnvelopes;\\n    }\\n \\n}\\n```\\n\\n* Below is the Optmized Solution which passes all test cases with TC O(N logN).\\uD83E\\uDEE1\\n```\\nclass Solution {\\n        \\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length, len = 0;\\n        \\n        // We sort According to Width!!\\n        Arrays.sort(envelopes, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        \\n        int dp[] = new int[n];\\n        for(int[] envelope : envelopes){\\n            int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\\n            if(index < 0)\\n                index = -(index + 1);\\n            dp[index] = envelope[1];\\n            if(index == len)\\n                len++;\\n        }\\n\\t\\t\\n        return len;\\n    }   \\n}\\n```\\n \\n * Bonus Tip :: Always make helper functions as private[ABSTRACTION].\\n * Happy Coding and do Upvote if Helpful!\\n \\n author : [@bharathkalyans](https://leetcode.com/bharathkalyans/)\\nlinkedin : [@bharathkalyans](https://www.linkedin.com/in/bharathkalyans/)\\ntwitter : [@bharathkalyans](https://twitter.com/bharathkalyans)\\ngithub : [@bharathkalyans](https://github.com/bharathkalyans/)\\n \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int MAX_VALUE = 100002;\\n        \\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);\\n        int[] prev = new int[]{MAX_VALUE, MAX_VALUE};\\n        return LIS(envelopes, envelopes.length - 1, prev);\\n    }\\n    \\n    private int LIS(int[][] envelopes, int index, int[] prev){\\n        if(index == 0){\\n            return (envelopes[0][0] < prev[0] && envelopes[0][1] < prev[1]) ? 1 : 0;\\n        }\\n        int exclude = LIS(envelopes, index - 1, prev);\\n        int include = 0;\\n        if(envelopes[index][0] < prev[0] && envelopes[index][1] < prev[1]){\\n            include = 1 + LIS(envelopes, index - 1, envelopes[index]);\\n        }\\n\\n        return Math.max(exclude, include);\\n    }\\n}\\n ```\n```\\n class Solution {\\n    \\n    private int MAX_VALUE = 100002;\\n        \\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);\\n        int[] prev = new int[]{MAX_VALUE, MAX_VALUE};\\n        int[][][] dp = new int[envelopes.length][MAX_VALUE + 1][MAX_VALUE + 1];\\n        \\n        for(int[][] grid : dp)\\n            for(int[] row : grid)\\n                Arrays.fill(row, -1);\\n        \\n        return LIS(envelopes, envelopes.length - 1, prev, dp);\\n    }\\n    \\n    private int LIS(int[][] envelopes, int index, int[] prev, int[][][] dp){\\n        if(index == 0){\\n            return (envelopes[0][0] < prev[0] && envelopes[0][1] < prev[1]) ? 1 : 0;\\n        }\\n        \\n        if(dp[index][prev[0]][prev[1]] != -1) return dp[index][prev[0]][prev[1]];\\n        int exclude = LIS(envelopes, index - 1, prev, dp);\\n        int include = 0;\\n        if(envelopes[index][0] < prev[0] && envelopes[index][1] < prev[1]){\\n            include = 1 + LIS(envelopes, index - 1, envelopes[index], dp);\\n        }\\n\\n        return dp[index][prev[0]][prev[1]] = Math.max(exclude, include);\\n    }\\n \\n}\\n ```\n```\\n class Solution {\\n    \\n    private int MAX_VALUE = 100002;\\n        \\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length, maxNumberOfEnvelopes = 1;\\n        \\n        // We sort According to Width!!\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);\\n        \\n        for(int[] envelope : envelopes)\\n            System.out.println(envelope[0] + \" \" + envelope[1]);\\n        \\n        // We find LIS according to Height!!\\n        int prev = MAX_VALUE;\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        \\n        for(int i = 1;i < n; i++){\\n            dp[i] = 1;\\n            for(int j = 0; j < i; j++)\\n                if(envelopes[i][0] != envelopes[j][0] && envelopes[i][1] > envelopes[j][1])\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n            \\n            maxNumberOfEnvelopes = Math.max(maxNumberOfEnvelopes, dp[i]);\\n        }\\n        \\n       return maxNumberOfEnvelopes;\\n    }\\n \\n}\\n```\n```\\nclass Solution {\\n        \\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length, len = 0;\\n        \\n        // We sort According to Width!!\\n        Arrays.sort(envelopes, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        \\n        int dp[] = new int[n];\\n        for(int[] envelope : envelopes){\\n            int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\\n            if(index < 0)\\n                index = -(index + 1);\\n            dp[index] = envelope[1];\\n            if(index == len)\\n                len++;\\n        }\\n\\t\\t\\n        return len;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071784,
                "title": "c-russian-doll-envelopes-simple-solution",
                "content": "Why we need to sort?\\n\\nIn these types of problem when we are dealing with two dimensions, we need to reduce the problem from two-dimensional array into a one-dimensional array in order to improve time complexity.\\n\\t\\n\"**Sort first when things are undecided**\", sorting can make the data orderly, reduce the degree of confusion, and often help us to sort out our thinking. the same is true with this question. Now, after doing the correct sorting, we just need to find Longest Increasing Subsequence of that one dimensional array.\\n\\nNow, you may be wondered what correct sorting actually is?\\n   \\nIt is the sorting which we do to order to achieve the answer. Like, increasing, non-increasing sorting. Without any further discussion, let\\'s dig into Intuition followed by algorithm.\\n\\nAlgorithm\\n\\n*    We sort the array in increasing order of width. And if two widths are same, we need to sort height in decreasing order.\\n*   Now why we need to sort in decreasing order if two widths are same. By this practice, we\\'re assuring that no width will get counted more than one time. Let\\'s take an example\\n*   envelopes=[[3, 5], [6, 7], [7, 13], [6, 10], [8, 4], [7, 11]]\\n\\n*   Now, if you see for a while, 6 and 7 is counted twice while we\\'re calculating the length of LIS, which will give the wrong ans. As question is asking, if any width/height are less than or equal, then, it is not possible to russian doll these envelopes.\\n\\n\\n*   Now, we know the problem. So, how can we tackle these conditions when two width are same, so that it won\\'t affect our answer. We can simple reverse sort the height if two width are equal, to remove duplicacy.\\n\\n*   Now, you may question, how reverse sorting the height would remove duplicacy? As the name itself says, Longest Increasing Subsequnce, the next coming height would be less than the previous one. Hence, forbidding it to increase length count.\\n\\n\\t* Breify speaking we sort the envelopes based on width in ascending\\n\\t\\t* After this Envelopes look like [[3, 5], [6, 7],[6, 10], [7, 11] ,[7, 13] , [8, 4]]\\n\\t* Then we sort those element in decreasing order fro which width is same\\n\\t\\t* After this Envelopes look like [[3, 5], [6, 10],[6, 7], [7, 13] ,[7, 11] , [8, 4]]\\n\\n\\t* **Then we Count length of Longest increasing subsequence based on Height only** i.e {5,10,7,13,11,4}\\n\\t\\t* So it comes out to be 3\\n   \\n   \\n**  If you don\\'t understand how LIS is calculated here, I strongly refer you to follow the prerequisite.**\\n  \\nNow, we have sucessfully reduced the problem to LIS! All you need to apply classical LIS on heights, to calculate the ans. This would be the maximum number of envelopes can be russian doll.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //This compare function going to pass to sort function it should be static function\\n\\t\\n\\t// To understand this think that we take two element adjacent to each other a,b both here are vector \\n\\t\\n\\t// Based on what you want right return condition \\n/* \\n\\t\\tlike  \\n\\t\\t\\t1. a<b for ascending ( first element should be less than second )   \\n\\t\\t\\t2. a>b for descending ( first element should be greater than second ) \\n\\n*/\\n    static bool cmp(vector<int>& a,vector<int>& b)\\n    {\\n        if(a[0]==b[0]) //if first val of pair are equal than  for a,b than check for second val of pair\\n        {\\n            return a[1]>b[1]; // comparing second val of pair in a,b\\n        }\\n        \\n        return a[0]<b[0];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n     \\n        \\n        sort(envelopes.begin(),envelopes.end(),cmp);\\n        \\n        vector<int> v;\\n        \\n        for(auto i: envelopes)\\n        {\\n            auto it= lower_bound(v.begin(),v.end(),i[1]);\\n            \\n            if(it== v.end()) // if element greater than i[1] not present than push i[1] here i[1] represent height of envelope\\n            {\\n                v.push_back(i[1]);\\n            }\\n            else\\n            {\\n                *it= i[1]; // if element greater than i[1] not present than replace previous element as it will not impact or LIS \\n            }\\n        }\\n        \\n        return v.size();\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //This compare function going to pass to sort function it should be static function\\n\\t\\n\\t// To understand this think that we take two element adjacent to each other a,b both here are vector \\n\\t\\n\\t// Based on what you want right return condition \\n/* \\n\\t\\tlike  \\n\\t\\t\\t1. a<b for ascending ( first element should be less than second )   \\n\\t\\t\\t2. a>b for descending ( first element should be greater than second ) \\n\\n*/\\n    static bool cmp(vector<int>& a,vector<int>& b)\\n    {\\n        if(a[0]==b[0]) //if first val of pair are equal than  for a,b than check for second val of pair\\n        {\\n            return a[1]>b[1]; // comparing second val of pair in a,b\\n        }\\n        \\n        return a[0]<b[0];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n     \\n        \\n        sort(envelopes.begin(),envelopes.end(),cmp);\\n        \\n        vector<int> v;\\n        \\n        for(auto i: envelopes)\\n        {\\n            auto it= lower_bound(v.begin(),v.end(),i[1]);\\n            \\n            if(it== v.end()) // if element greater than i[1] not present than push i[1] here i[1] represent height of envelope\\n            {\\n                v.push_back(i[1]);\\n            }\\n            else\\n            {\\n                *it= i[1]; // if element greater than i[1] not present than replace previous element as it will not impact or LIS \\n            }\\n        }\\n        \\n        return v.size();\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071454,
                "title": "c-explaination-why-sort-like-that-works-lis-binary-search",
                "content": "The question can be confusing even though you know the solution of classic lis using binary search.I recommend learning first the Binary search solution of classic LIS. \\nThe sorting part caused a lot of confusion to me also ;)\\n\\n**This post focuses on why sorting a particular way yields the solution**\\n\\nFor a envelope A to go inside B, lengthA < lengthB and widthA < widthB\\n1. We cannot take care of both parameters simontaneously, so lets sort according to one paremeter lets say height , and take care of other parameter while forming the solution.\\n2. Lets say we have dolls \\n\\t[2,6] , [2,3], [4,5] , [5,7] ,[8,9], [4,7], [6,9]\\napply sort acc to 0\\'th index , (we will see how later we need to modify the sort a little bit)\\n\\t[2,6], [2,3], [4,5], [4,7] , [5,7], [6,9], [8,9]\\n\\n**general idea behind binary search solution is that if we cant add the current candidate to the end , we should start forming a new solution simultaneously . So lets try this approach on the example and see how it fails**\\n[2,6]     \\n\\n[2,6]                                               since [2,3] cant be fitted because of short 1\\'st index(call height)\\n[2,3]\\n\\n[2,6]                                                height [4,5] is shorter\\n[2,3], [4,5]\\n\\n[2,6],[4,7]\\n[2,3],[4,5], [4,7]                              height[4,7] big enough to fit in both\\n\\nWait but we just hit an invalid sequence [2,3],[4,5],[4,7]. This happened because of equal widths of [4,5],[4,7] but why it didnt happen when we considered the dolls [2,6],[2,3]?\\n\\n**Reason**: If among envelopes having same width , if we consider any envelope having height smaller first then the higher height envelopes will start contributing the solution of smaller ones which is actually invalid.\\nBut as we saw in case of [2,3] and [2,6] , [2,3] instead of contributing, started its own new solution.\\n**The new new sorting we have now is**\\n**sort in increasing according to width and incase of equal widths sort according to the lengths.**\\n\\nThe rest solution is same as the classic LIS.\\n**Hope it helps:) Do upvote**\\n```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int> &a , vector<int> &b){\\n        if(a[0]==b[0]) return a[1]>b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n=envelopes.size();\\n        sort(envelopes.begin(),envelopes.end(),compare);\\n        \\n        vector<int> lis;\\n        for(int i=0;i<n;i++){\\n            int ht = envelopes[i][1];\\n            auto idx = lower_bound(lis.begin(),lis.end(),ht)-lis.begin();\\n            if(idx==lis.size())\\n                lis.push_back(ht);\\n            else lis[idx]=ht;\\n        }\\n        \\n        return lis.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int> &a , vector<int> &b){\\n        if(a[0]==b[0]) return a[1]>b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n=envelopes.size();\\n        sort(envelopes.begin(),envelopes.end(),compare);\\n        \\n        vector<int> lis;\\n        for(int i=0;i<n;i++){\\n            int ht = envelopes[i][1];\\n            auto idx = lower_bound(lis.begin(),lis.end(),ht)-lis.begin();\\n            if(idx==lis.size())\\n                lis.push_back(ht);\\n            else lis[idx]=ht;\\n        }\\n        \\n        return lis.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071294,
                "title": "c-same-as-longest-increasing-subsequence-o-nlogn-approach-and-how-it-works",
                "content": "This problem is similar to the Longest Increasing Subsequence Problem,but in this case we cant write the O(n^2) approach because of the constraints.Instead we use the lower bound function to find the element which is just greater than or equal to the present element and replace that element.By replacing the element we mean ,we may get the Longest increasing subsequence including this point.\\nExample:\\n   [[1,2],[2,3],[3,4],[3,5],[4,5],[5,5],[5,6],[6,7],[7,8]]\\n  After Sorting:\\n  [[1,2],[2,3],[3,5],[3,4],[4,5],[5,6],[5,5],[6,7],[7,8]]\\n  Then \\n     after 3 iterations the vector v is [2,3,5]\\n\\tNow,when we encounter 4 we replace 5 with 4.\\nNow this 4 ,then combines in the next iterations with other elements and finally v becomes\\n[2,3,4,5,6,7,8]\\n**we update the iterator beacause it may form the LIS(Longest increasing Subsequence).**\\n\\n**we dont need to take care about the first elements (i[0]) as they are already sorted.**\\n\\n **I would suggest to solve Longest Increasing Subsequence Problem in nlogn approach ,an then solve this problem (it would become very easy).**\\n  \\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b){\\n        if(a[0]==b[0])\\n            return a[1]>b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end(),cmp);\\n        vector<int>v;\\n        for(auto i:envelopes){\\n            auto it=lower_bound(v.begin(),v.end(),i[1]);\\n            if(it==v.end())\\n                v.push_back(i[1]);\\n\\t\\t\\t//if the element is greater than all elements push it\\n            else\\n                *it=i[1];\\n\\t\\t\\t//if it less than or equal to a particular element replace it,because it may form the Longest Increasing subsequence\\n            \\n        }\\n        return v.size();\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b){\\n        if(a[0]==b[0])\\n            return a[1]>b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(),envelopes.end(),cmp);\\n        vector<int>v;\\n        for(auto i:envelopes){\\n            auto it=lower_bound(v.begin(),v.end(),i[1]);\\n            if(it==v.end())\\n                v.push_back(i[1]);\\n\\t\\t\\t//if the element is greater than all elements push it\\n            else\\n                *it=i[1];\\n\\t\\t\\t//if it less than or equal to a particular element replace it,because it may form the Longest Increasing subsequence\\n            \\n        }\\n        return v.size();\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743812,
                "title": "c-using-lower-bound-lis",
                "content": "```\\nstatic bool cmp(vector<int>&a,vector<int>&b){\\n        if(a[0]!=b[0]) return a[0]<b[0];\\n        return a[1]>b[1];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& e) {\\n        sort(e.begin(),e.end(),cmp);\\n        int n=e.size();\\n        vector<int> dp;\\n        for(int i=0;i<n;i++){\\n           auto it=lower_bound(dp.begin(),dp.end(),e[i][1]);\\n            if(it==dp.end()) dp.push_back(e[i][1]);\\n            else *it=e[i][1];\\n        }\\n        return dp.size();\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic bool cmp(vector<int>&a,vector<int>&b){\\n        if(a[0]!=b[0]) return a[0]<b[0];\\n        return a[1]>b[1];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& e) {\\n        sort(e.begin(),e.end(),cmp);\\n        int n=e.size();\\n        vector<int> dp;\\n        for(int i=0;i<n;i++){\\n           auto it=lower_bound(dp.begin(),dp.end(),e[i][1]);\\n            if(it==dp.end()) dp.push_back(e[i][1]);\\n            else *it=e[i][1];\\n        }\\n        return dp.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1664326,
                "title": "c-lis-implementation-comparator-trick",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION AND EXPLANATION.**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        //sort the given vector in non-decreasing manner onb basis of either height or width\\n        //HERE I HAVE SORTED ON THE BASIS OF HEIGHT\\n        \\n        //we then sort the other parameter in non-increasing manner for similar heights.(i.e., for a pair of\\n        //envelop if their heights are same then the one with greater width should come at first than the \\n        //lesser one in the sorted array)\\n        \\n        //we do this because we know that we can only consider one envelop from a group of similar-height\\n        //envelops but we cannot claim that we should take the envelop with (minimum of their widths) \\n        //as their might be a case [h,w]-->[H,W]  where h<H but w>W or that we take the maximum of their \\n        //widths) for case like [H,W]-->[h,w] where H<h and W>w.\\n        \\n        //so we need an optimal sequence which provide us with longest possible length of envelopes\\n        //considering the above cases.\\n        \\n        \\n        //HENCE WE PERFORM LIS ON THE OTHER PARAMETER AFTER SORTING IT IN THE MANNER MENTIONED ABOVE\\n        //FOR ENSURING --->[h,w]-->[H,W] for which the W is just greater than w \\n        //in the set of [H]->[W1,W2,W3...]\\n        \\n\\t\\t//counter case:if we arrange the width in non-decreasing order then we will have a sequence where\\n\\t\\t//width will be in increasing order but we will include similar heights in this case.\\n\\t\\t//eg:[[1,2],[1,3],[2,4],[2,5]]--->if we follow the above method we will get the entire seq (length=4)\\n\\t\\t//as ans but the correct ans is 2.\\n\\t\\t\\n     sort(envelopes.begin(),envelopes.end(),[&](const vector<int>& v1,const vector<int>& v2){return v1[0]==v2[0]?v1[1]>v2[1]:v1[0]<v2[0];});\\n        \\n        vector<int>LIS;\\n        for(auto &x:envelopes)\\n        {\\n            if(LIS.empty()||LIS.back()<x[1])\\n                LIS.push_back(x[1]);\\n            else\\n            {\\n                int idx=lower_bound(LIS.begin(),LIS.end(),x[1])-LIS.begin();\\n                LIS[idx]=x[1];\\n            }\\n        }\\n        return LIS.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        //sort the given vector in non-decreasing manner onb basis of either height or width\\n        //HERE I HAVE SORTED ON THE BASIS OF HEIGHT\\n        \\n        //we then sort the other parameter in non-increasing manner for similar heights.(i.e., for a pair of\\n        //envelop if their heights are same then the one with greater width should come at first than the \\n        //lesser one in the sorted array)\\n        \\n        //we do this because we know that we can only consider one envelop from a group of similar-height\\n        //envelops but we cannot claim that we should take the envelop with (minimum of their widths) \\n        //as their might be a case [h,w]-->[H,W]  where h<H but w>W or that we take the maximum of their \\n        //widths) for case like [H,W]-->[h,w] where H<h and W>w.\\n        \\n        //so we need an optimal sequence which provide us with longest possible length of envelopes\\n        //considering the above cases.\\n        \\n        \\n        //HENCE WE PERFORM LIS ON THE OTHER PARAMETER AFTER SORTING IT IN THE MANNER MENTIONED ABOVE\\n        //FOR ENSURING --->[h,w]-->[H,W] for which the W is just greater than w \\n        //in the set of [H]->[W1,W2,W3...]\\n        \\n\\t\\t//counter case:if we arrange the width in non-decreasing order then we will have a sequence where\\n\\t\\t//width will be in increasing order but we will include similar heights in this case.\\n\\t\\t//eg:[[1,2],[1,3],[2,4],[2,5]]--->if we follow the above method we will get the entire seq (length=4)\\n\\t\\t//as ans but the correct ans is 2.\\n\\t\\t\\n     sort(envelopes.begin(),envelopes.end(),[&](const vector<int>& v1,const vector<int>& v2){return v1[0]==v2[0]?v1[1]>v2[1]:v1[0]<v2[0];});\\n        \\n        vector<int>LIS;\\n        for(auto &x:envelopes)\\n        {\\n            if(LIS.empty()||LIS.back()<x[1])\\n                LIS.push_back(x[1]);\\n            else\\n            {\\n                int idx=lower_bound(LIS.begin(),LIS.end(),x[1])-LIS.begin();\\n                LIS[idx]=x[1];\\n            }\\n        }\\n        return LIS.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393958,
                "title": "c-bit-solution-o-nlogn",
                "content": "Runtime: 36 ms, faster than 95.55% of C++ online submissions for Russian Doll Envelopes.\\nMemory Usage: 16.4 MB, less than 32.18% of C++ online submissions for Russian Doll Envelopes.\\n\\n```\\nWe sort the array in ascending order of width and descending order of height if width are same. \\nThen we just calculate the LIS for height in the sorted array. As we do not want to consider same width\\ndifferent height to fall in to a subsequence count, so we sort same width in descending order of height\\nand so higher hight of same width [3,7] does not cover the subsequence count of lower height [3,4] \\nof same width and each height is only covered for LIS by different width only. We solve the max LIS of\\nheight same as LIS problem using BIT.\\n```\\n\\n```\\nclass FenWickTree{\\n    \\npublic:\\n    vector<int>tree;\\n    FenWickTree(){};\\n    FenWickTree(int n)\\n    {\\n        tree.resize(n);\\n        fill(tree.begin(),tree.end(),0);\\n    }\\n    \\n    // update i to max tree size with val if val > tree[i]\\n    void update(int i, int val)\\n    {\\n        while(i<tree.size())\\n        {\\n            tree[i] = max(tree[i],val);\\n            i+= (i&-i);\\n        }\\n    }\\n    \\n    // get max LIS from ith index to 1\\n    int get(int i)\\n    {\\n        int val = 0;\\n        while(i>0)\\n        {\\n            val = max(val,tree[i]);\\n            i-= (i&-i);\\n        }\\n        \\n        return val;\\n    }      \\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& env) {\\n\\n        int n = env.size();\\n        \\n        // sort envelops in ascending order of width and descending order of height when widths are same\\n        sort(env.begin(),env.end(),[](auto &a, auto &b){ return a[0]==b[0] ? a[1]>b[1] : a[0]<b[0];});\\n        \\n        // max height of all envelops\\n        vector<int> maxv = *max_element(env.begin(),env.end(),[](auto &a, auto &b){ return a[1]<b[1];});\\n\\n        // create max height + 1 size BIT\\n        FenWickTree tree(maxv[1]+1);\\n            \\n        // max LIS\\n        int maxL = 1;\\n        int lis;\\n        \\n        // loop through heights and get max LIS for (current height - 1) from BIT + 1 \\n        // update BIT with current height and LIS\\n        for(int i=0;i<n;i++)\\n        {\\n            lis = tree.get(env[i][1]-1) + 1;\\n            tree.update(env[i][1],lis);\\n            maxL = max(maxL,lis);\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Tree",
                    "Sorting"
                ],
                "code": "```\\nWe sort the array in ascending order of width and descending order of height if width are same. \\nThen we just calculate the LIS for height in the sorted array. As we do not want to consider same width\\ndifferent height to fall in to a subsequence count, so we sort same width in descending order of height\\nand so higher hight of same width [3,7] does not cover the subsequence count of lower height [3,4] \\nof same width and each height is only covered for LIS by different width only. We solve the max LIS of\\nheight same as LIS problem using BIT.\\n```\n```\\nclass FenWickTree{\\n    \\npublic:\\n    vector<int>tree;\\n    FenWickTree(){};\\n    FenWickTree(int n)\\n    {\\n        tree.resize(n);\\n        fill(tree.begin(),tree.end(),0);\\n    }\\n    \\n    // update i to max tree size with val if val > tree[i]\\n    void update(int i, int val)\\n    {\\n        while(i<tree.size())\\n        {\\n            tree[i] = max(tree[i],val);\\n            i+= (i&-i);\\n        }\\n    }\\n    \\n    // get max LIS from ith index to 1\\n    int get(int i)\\n    {\\n        int val = 0;\\n        while(i>0)\\n        {\\n            val = max(val,tree[i]);\\n            i-= (i&-i);\\n        }\\n        \\n        return val;\\n    }      \\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& env) {\\n\\n        int n = env.size();\\n        \\n        // sort envelops in ascending order of width and descending order of height when widths are same\\n        sort(env.begin(),env.end(),[](auto &a, auto &b){ return a[0]==b[0] ? a[1]>b[1] : a[0]<b[0];});\\n        \\n        // max height of all envelops\\n        vector<int> maxv = *max_element(env.begin(),env.end(),[](auto &a, auto &b){ return a[1]<b[1];});\\n\\n        // create max height + 1 size BIT\\n        FenWickTree tree(maxv[1]+1);\\n            \\n        // max LIS\\n        int maxL = 1;\\n        int lis;\\n        \\n        // loop through heights and get max LIS for (current height - 1) from BIT + 1 \\n        // update BIT with current height and LIS\\n        for(int i=0;i<n;i++)\\n        {\\n            lis = tree.get(env[i][1]-1) + 1;\\n            tree.update(env[i][1],lis);\\n            maxL = max(maxL,lis);\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369692,
                "title": "java-full-explanation",
                "content": "# ******This problem is asking for LIS in two dimensions, width and height. Sorting the width reduces the problem by one dimension. If width is strictly increasing, the problem is equivalent to finding LIS in only the height dimension. However, when there is a tie in width, a strictly increasing sequence in height may not be a correct solution. For example, [[3,3] cannot fit in [3,4]]. Sorting height in descending order when there is a tie prevents such a sequence to be included in the solution.The same idea can be applied to problems of higher dimensions. For example, box fitting is three dimensions, width, height, and length. Sorting width ascending and height descending reduces the problem by one dimension. Finding the LIS by height further reduces the problem by another dimension. When find LIS based on only length, it becomes a standard LIS problem.\\n\\n```\\nclass Solution {\\n    public class Envelope implements Comparable<Envelope>{\\n        int w;\\n        int h;\\n        public Envelope(int w, int h){\\n            this.w = w;\\n            this.h = h;\\n        }\\n        public int compareTo(Envelope e){\\n            if(this.w!=e.w){\\n                return this.w - e.w;\\n            } else {\\n                return e.h - this.h;\\n            }\\n        }\\n    }\\n    \\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length;\\n        Envelope[] envlps = new Envelope[n];\\n        for(int i=0;i<n;i++){\\n            envlps[i] = new Envelope(envelopes[i][0],envelopes[i][1]);\\n        }\\n        Arrays.sort(envlps);\\n        int dp[] = new int[n];\\n        int ovm = 0;\\n        for(int i=0;i<n;i++){\\n            int max = 0;\\n            for(int j=0;j<i;j++){\\n                if(envlps[i].h>envlps[j].h){\\n                    max = Math.max(max,dp[j]);\\n                }\\n            }\\n            dp[i] = max+1;\\n            ovm = Math.max(dp[i],ovm);\\n        }\\n        return ovm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public class Envelope implements Comparable<Envelope>{\\n        int w;\\n        int h;\\n        public Envelope(int w, int h){\\n            this.w = w;\\n            this.h = h;\\n        }\\n        public int compareTo(Envelope e){\\n            if(this.w!=e.w){\\n                return this.w - e.w;\\n            } else {\\n                return e.h - this.h;\\n            }\\n        }\\n    }\\n    \\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length;\\n        Envelope[] envlps = new Envelope[n];\\n        for(int i=0;i<n;i++){\\n            envlps[i] = new Envelope(envelopes[i][0],envelopes[i][1]);\\n        }\\n        Arrays.sort(envlps);\\n        int dp[] = new int[n];\\n        int ovm = 0;\\n        for(int i=0;i<n;i++){\\n            int max = 0;\\n            for(int j=0;j<i;j++){\\n                if(envlps[i].h>envlps[j].h){\\n                    max = Math.max(max,dp[j]);\\n                }\\n            }\\n            dp[i] = max+1;\\n            ovm = Math.max(dp[i],ovm);\\n        }\\n        return ovm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169847,
                "title": "c-simple-dp-solution-similar-to-lis",
                "content": "```\\n bool cmp(vector<int> a, vector<int> b){\\n       if(a[0]!=b[0]) return a[0]<b[0];\\n        return a[1]<b[1]; \\n    }\\nclass Solution {\\npublic:\\n   \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        ios_base::sync_with_stdio(0);\\n        int n=envelopes.size();\\n        if(n==1) return 1;\\n        int res=1;\\n        sort(envelopes.begin(),envelopes.end(),cmp);\\n        vector<int> dp(n,1);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(envelopes[j][0]<envelopes[i][0] && envelopes[j][1]< envelopes[i][1])\\n                {\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                    res=max(res,dp[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n bool cmp(vector<int> a, vector<int> b){\\n       if(a[0]!=b[0]) return a[0]<b[0];\\n        return a[1]<b[1]; \\n    }\\nclass Solution {\\npublic:\\n   \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        ios_base::sync_with_stdio(0);\\n        int n=envelopes.size();\\n        if(n==1) return 1;\\n        int res=1;\\n        sort(envelopes.begin(),envelopes.end(),cmp);\\n        vector<int> dp(n,1);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(envelopes[j][0]<envelopes[i][0] && envelopes[j][1]< envelopes[i][1])\\n                {\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                    res=max(res,dp[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136463,
                "title": "c-dp-solutions-compared-and-explained-70-time-90-space",
                "content": "My initial approach was to add another value to each letter, the maximum amount of letters you can wrap in.\\n\\nGoing through them, after having them sorted from the smallest (width-wise and with extra condition for the height), we would then get how each one can fit into the others.\\n\\nTo do so, we declare a single support variable `res`, initialised to `1` (even if no letter fits into any other, you would still have a single letter on his own as a minimum amount to consider valid).\\n\\nWe would then sort `envelopes` and add to each of them `1` (again, the minimum series of envelopes you can wrap in - a single envelope).\\n\\nNow time to find the matches between fitting envelopes!\\n\\nWe will loop with `i` through all the envelopes but the last one and:\\n* assign `cix`, `ciy` and `ciq` respectively as the propery of the enveoped pointed by `i`;\\n* loop with `j` throught all the envelopes from `i + ` to the last one and:\\n\\t* assign `cjx`, `cjy` and `cjq` respectively as the propery of the enveoped pointed by `j`;\\n\\t* if there is a fit (`cjx > cix && cjy > ciy`), update the maximum size as the max between the current value (`ciq`) and the new one (`ciq + 1`);\\n\\t* update `res` as the maximum value between its current one and the new one we just updated.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        // support variables\\n        int res = 1;\\n        // preparing envelopes\\n        sort(begin(envelopes), end(envelopes));\\n        for (auto &e: envelopes) e.push_back(1);\\n        // matching envelopes\\n        for (int i = 0, lmti = envelopes.size() - 1, cix, ciy, ciq; i < lmti; i++) {\\n            cix = envelopes[i][0], ciy = envelopes[i][1], ciq = envelopes[i][2];\\n            for (int j = i + 1, lmtj = lmti + 1, cjx, cjy, cjq; j < lmtj; j++) {\\n                cjx = envelopes[j][0], cjy = envelopes[j][1], cjq = envelopes[j][2];\\n                if (cjx > cix && cjy > ciy) envelopes[j][2] = max(cjq, ciq + 1);\\n                res = max(res, envelopes[j][2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nSecond version, storing the data about the amount of letters you can wrap in into a `wrapped` array; turns out it takes like half the time, just for this :o\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        // support variables\\n        int res = 1, len = envelopes.size();\\n        int wrapped[len];\\n        // preparing envelopes\\n        sort(begin(envelopes), end(envelopes));\\n        // preparing wrapped\\n        for (int i = 0; i < len; i++) wrapped[i] = 1;\\n        // matching envelopes\\n        for (int i = 0, lmti = len - 1, cix, ciy, ciq; i < lmti; i++) {\\n            cix = envelopes[i][0], ciy = envelopes[i][1], ciq = wrapped[i];\\n            for (int j = i + 1, lmtj = lmti + 1, cjx, cjy, cjq; j < lmtj; j++) {\\n                cjx = envelopes[j][0], cjy = envelopes[j][1], cjq = wrapped[j];\\n                if (cjx > cix && cjy > ciy) wrapped[j] = max(cjq, ciq + 1);\\n                res = max(res, wrapped[j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        // support variables\\n        int res = 1;\\n        // preparing envelopes\\n        sort(begin(envelopes), end(envelopes));\\n        for (auto &e: envelopes) e.push_back(1);\\n        // matching envelopes\\n        for (int i = 0, lmti = envelopes.size() - 1, cix, ciy, ciq; i < lmti; i++) {\\n            cix = envelopes[i][0], ciy = envelopes[i][1], ciq = envelopes[i][2];\\n            for (int j = i + 1, lmtj = lmti + 1, cjx, cjy, cjq; j < lmtj; j++) {\\n                cjx = envelopes[j][0], cjy = envelopes[j][1], cjq = envelopes[j][2];\\n                if (cjx > cix && cjy > ciy) envelopes[j][2] = max(cjq, ciq + 1);\\n                res = max(res, envelopes[j][2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        // support variables\\n        int res = 1, len = envelopes.size();\\n        int wrapped[len];\\n        // preparing envelopes\\n        sort(begin(envelopes), end(envelopes));\\n        // preparing wrapped\\n        for (int i = 0; i < len; i++) wrapped[i] = 1;\\n        // matching envelopes\\n        for (int i = 0, lmti = len - 1, cix, ciy, ciq; i < lmti; i++) {\\n            cix = envelopes[i][0], ciy = envelopes[i][1], ciq = wrapped[i];\\n            for (int j = i + 1, lmtj = lmti + 1, cjx, cjy, cjq; j < lmtj; j++) {\\n                cjx = envelopes[j][0], cjy = envelopes[j][1], cjq = wrapped[j];\\n                if (cjx > cix && cjy > ciy) wrapped[j] = max(cjq, ciq + 1);\\n                res = max(res, wrapped[j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135556,
                "title": "python-clean-lis",
                "content": "# Idea \\nThe idea is to apply LIS algorithm, please solve question 300 first, if you are unfamiliar with it, because this problem adds a level of complexity to that problem. The key idea here is to make sure to sort the elements in ascending order by the first element and descending order by the second element.\\n```\\ndef maxEnvelopes(self, envelopes):\\n\\ttails = []\\n\\tfor _, b in sorted(envelopes, key = lambda x: (x[0], -x[1])): \\n\\t\\tidx = bisect.bisect_left(tails, b)\\n\\t\\ttails[idx:idx+1] = [b]\\n\\treturn len(tails)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxEnvelopes(self, envelopes):\\n\\ttails = []\\n\\tfor _, b in sorted(envelopes, key = lambda x: (x[0], -x[1])): \\n\\t\\tidx = bisect.bisect_left(tails, b)\\n\\t\\ttails[idx:idx+1] = [b]\\n\\treturn len(tails)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1135364,
                "title": "using-lis-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end());\\n        \\n        //Now, find LIS keeping width and height both in consideration\\n                \\n        vector<int> lis(n, 1);\\n        int result = 1;\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                if(envelopes[i][0] > envelopes[j][0] && \\n                   envelopes[i][1] > envelopes[j][1]) {\\n                    lis[i] = max(lis[i], lis[j]+1);\\n                    result = max(result, lis[i]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end());\\n        \\n        //Now, find LIS keeping width and height both in consideration\\n                \\n        vector<int> lis(n, 1);\\n        int result = 1;\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                if(envelopes[i][0] > envelopes[j][0] && \\n                   envelopes[i][1] > envelopes[j][1]) {\\n                    lis[i] = max(lis[i], lis[j]+1);\\n                    result = max(result, lis[i]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135214,
                "title": "python-lis-without-bisect-slow-but-not-tle",
                "content": "This approach definitely isn\\'t the fastest, consistently taking around 5 seconds to complete, but it\\'s fairly easy to follow as a way to find the longest increasing subsequence.\\n\\n```\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort()   # Orders envelopes by width, then by height\\n        n = len(envelopes) # Number of envelopes\\n        c = [1] * n        # Count of how many can be nested for each envelope\\n        \\n        for i in range(n):    # Calculate c[i] for each envelope\\n            s = envelopes[i]  # s is the size of the current envelope\\n            for j in range(i):   # Try all envelopes smaller than s\\n                if c[j] >= c[i]: # Actually, only check if it would be more envelopes\\n                    t = envelopes[j]    # t is the size of the envelope to test\\n                    if s[0] > t[0] and s[1] > t[1]:  # Check if t is smaller than s\\n                        c[i] = c[j] + 1              # Update c\\n        \\n        return max(c)  # This will be the maximum number of envelopes that can be nested\\n   ```\\n   \\n   Initially I had coded it to perform the size comparison envelope first and update the count array (`c[i]`) with `max(c[i], c[j+1)`, but that timed out.  By checking that `c[j]` was greater than or equal to `c[i]` before comparing the size saved enough cycles that it passed the test even while still at O(N\\xB2).  Obviously there are faster approaches, mostly relying on `bisect()` to determine an optimal sequence of envelopes, but I wanted to present an alternative approach.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort()   # Orders envelopes by width, then by height\\n        n = len(envelopes) # Number of envelopes\\n        c = [1] * n        # Count of how many can be nested for each envelope\\n        \\n        for i in range(n):    # Calculate c[i] for each envelope\\n            s = envelopes[i]  # s is the size of the current envelope\\n            for j in range(i):   # Try all envelopes smaller than s\\n                if c[j] >= c[i]: # Actually, only check if it would be more envelopes\\n                    t = envelopes[j]    # t is the size of the envelope to test\\n                    if s[0] > t[0] and s[1] > t[1]:  # Check if t is smaller than s\\n                        c[i] = c[j] + 1              # Update c\\n        \\n        return max(c)  # This will be the maximum number of envelopes that can be nested\\n   ```",
                "codeTag": "Python3"
            },
            {
                "id": 1134480,
                "title": "java-dp-solution-with-comments-for-explanation",
                "content": "```java\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        // sort the envelopes in ascending order based on width\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]); \\n        \\n         // keep track of max envelopes could be Russian doll for each envelop.\\n        int[] dp = new int[envelopes.length];\\n        Arrays.fill(dp, 1);\\n        \\n        int max = 1;\\n        \\n        // i is the current envelop index\\n        // j is the previous envelop index before i\\n        for(int i = 0; i < envelopes.length; i++){\\n            for(int j = 0; j < i; j++){\\n                // compare the width and height of the current envelop with all the previous ones.\\n                if(envelopes[j][0] < envelopes[i][0] &&\\n                   envelopes[j][1] < envelopes[i][1])\\n                {\\n                    // update the max number of envelopes the current envelop could be Russian doll\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }\\n            }\\n            \\n            max = Math.max(dp[i], max);\\n        }\\n        \\n        return max;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        // sort the envelopes in ascending order based on width\\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]); \\n        \\n         // keep track of max envelopes could be Russian doll for each envelop.\\n        int[] dp = new int[envelopes.length];\\n        Arrays.fill(dp, 1);\\n        \\n        int max = 1;\\n        \\n        // i is the current envelop index\\n        // j is the previous envelop index before i\\n        for(int i = 0; i < envelopes.length; i++){\\n            for(int j = 0; j < i; j++){\\n                // compare the width and height of the current envelop with all the previous ones.\\n                if(envelopes[j][0] < envelopes[i][0] &&\\n                   envelopes[j][1] < envelopes[i][1])\\n                {\\n                    // update the max number of envelopes the current envelop could be Russian doll\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }\\n            }\\n            \\n            max = Math.max(dp[i], max);\\n        }\\n        \\n        return max;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134368,
                "title": "rust-solution",
                "content": "```rust\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn max_envelopes(envelopes: Vec<Vec<i32>>) -> i32 {\\n        let mut envelopes = envelopes\\n            .iter()\\n            .map(|envelope| (envelope[0], Reverse(envelope[1])))\\n            .collect::<Vec<_>>();\\n        envelopes.sort_unstable();\\n        let mut dp = Vec::new();\\n        for &(_, Reverse(h)) in &envelopes {\\n            if let Some(i) = dp.binary_search(&h).err() {\\n                if i < dp.len() {\\n                    dp[i] = h;\\n                } else {\\n                    dp.push(h);\\n                }\\n            }\\n        }\\n        dp.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn max_envelopes(envelopes: Vec<Vec<i32>>) -> i32 {\\n        let mut envelopes = envelopes\\n            .iter()\\n            .map(|envelope| (envelope[0], Reverse(envelope[1])))\\n            .collect::<Vec<_>>();\\n        envelopes.sort_unstable();\\n        let mut dp = Vec::new();\\n        for &(_, Reverse(h)) in &envelopes {\\n            if let Some(i) = dp.binary_search(&h).err() {\\n                if i < dp.len() {\\n                    dp[i] = h;\\n                } else {\\n                    dp.push(h);\\n                }\\n            }\\n        }\\n        dp.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1134006,
                "title": "my-java-solution-using-sort-and-longest-increasing-subsequence-concept",
                "content": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        // sort as \\n        // if widths are equal, sort based on the decreeasing height\\n        // else carry on with width on increasing\\n        Arrays.sort(envelopes, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        // now just find the longest increasing subsequence of height and thats the answer\\n        // it is a general dp question and that concept can be applied here\\n        int length = envelopes.length;\\n        int [] dp = new int [length];\\n        Arrays.fill(dp, 1); // this is the minimum possible value\\n        for (int i=0; i<length; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (envelopes[i][1] > envelopes[j][1] && dp[i] < dp[j] + 1)\\n                    dp[i] = dp[j] + 1;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int number : dp) {\\n            max = Math.max(number, max);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n```\\n// since we sorted we can also use binary search concept for LIS\\n        int result = 0;\\n        for (int [] e : envelopes) {\\n            int index = Arrays.binarySearch(dp, 0, result, e[1]);\\n            if (index < 0) {\\n                index = -(index + 1);\\n            }\\n            dp[index] = e[1];\\n            if (index == result)\\n                result += 1;\\n        }\\n        return result;\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        // sort as \\n        // if widths are equal, sort based on the decreeasing height\\n        // else carry on with width on increasing\\n        Arrays.sort(envelopes, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        // now just find the longest increasing subsequence of height and thats the answer\\n        // it is a general dp question and that concept can be applied here\\n        int length = envelopes.length;\\n        int [] dp = new int [length];\\n        Arrays.fill(dp, 1); // this is the minimum possible value\\n        for (int i=0; i<length; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (envelopes[i][1] > envelopes[j][1] && dp[i] < dp[j] + 1)\\n                    dp[i] = dp[j] + 1;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int number : dp) {\\n            max = Math.max(number, max);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\n// since we sorted we can also use binary search concept for LIS\\n        int result = 0;\\n        for (int [] e : envelopes) {\\n            int index = Arrays.binarySearch(dp, 0, result, e[1]);\\n            if (index < 0) {\\n                index = -(index + 1);\\n            }\\n            dp[index] = e[1];\\n            if (index == result)\\n                result += 1;\\n        }\\n        return result;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990096,
                "title": "c-lis-solutions-from-o-n-2-bottom-up-dp-to-o-nlogn-binary-search",
                "content": "Similar question: [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)\\n\\nThis problem is very tricky. We can turn it into a classic LIS problem by first sorting the envelopes by width in the ascending order, and break the tie by sorting the height in the descending order.\\n\\nTo understand why we do a descending sort for the height, consider the following example given by the question:\\n`[[5,4],[6,4],[6,7],[2,3]]`\\nIf we do an ascending sort on both width and height, the envelopes will look like this:\\n`[[2,3],[5,4],[6,4],[6,7]]`\\nThe problem with this is that if two envelopes have the same width like `[6,4]` and `[6,7]`, we cannot fit one into another. However, this information is lost when we only look at height, and then we will count this as a valid case, which is not true. If we break the tie by sorting the height descendingly, we can avoid this situation.\\n\\nWe then can start buiding the array. `dp[i]` means that the longest increasing string **including** the ith item. To calculate `dp[i]`, we need to go through all the previously calculated values(`dp[0...i-1]`). We need to check if the ith item is larger than those items. If yes, then we update the value if the new LIS that we get is larger than the LIS that we currently have.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        if (envelopes.empty()) {\\n            return 0;\\n        }\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int> &e1, const vector<int> &e2) {\\n            if (e1[0] != e2[0]) {\\n                return e1[0] < e2[0];\\n            }\\n            return e1[1] > e2[1];\\n        });\\n        vector<int> dp(envelopes.size(), 1);\\n        int maxEnvelopes = 1;\\n        for (int i = 1; i < envelopes.size(); ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (envelopes[i][1] > envelopes[j][1]) {\\n                    dp[i] = max(dp[i], 1 + dp[j]);\\n                    maxEnvelopes = max(maxEnvelopes, dp[i]);\\n                }\\n            }\\n        }\\n        return maxEnvelopes;\\n    }\\n};\\n```\\n\\nThe solution mentioned above is O(n^2). We can improve the complexity to O(nlogn) by introducing binary search, which is less intuitive though.\\nThe main idea is that we maintain an monotonic array when we do the array traversal. Each time when we are at a new item, we see if it\\'s larger than the last item in the array. If yes, then we simply add it to the end of our monotonic array. If not, then we do a binary search to find the smallest element that is larger than this new item, and replace it with our new item.\\nAfter the traversal, the size of this monotonic array will be the result of LIS.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        if (envelopes.empty()) {\\n            return 0;\\n        }\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int> &e1, const vector<int> &e2) {\\n            if (e1[0] != e2[0]) {\\n                return e1[0] < e2[0];\\n            }\\n            return e1[1] > e2[1];\\n        });\\n        vector<int> increasingArr;\\n        increasingArr.push_back(envelopes[0][1]);\\n        for (int i = 1; i < envelopes.size(); ++i) {\\n            if (envelopes[i][1] > increasingArr.back()) {\\n                increasingArr.push_back(envelopes[i][1]);\\n            } else {\\n                replaceWithBinarySearch(increasingArr, envelopes[i][1]);\\n            }\\n        }\\n        return increasingArr.size();\\n    }\\nprivate:\\n    void replaceWithBinarySearch(vector<int> &arr, int val) {\\n        int left = 0, right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] == val) {\\n                return;\\n            } else if (arr[mid] < val) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        arr[left] = val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        if (envelopes.empty()) {\\n            return 0;\\n        }\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int> &e1, const vector<int> &e2) {\\n            if (e1[0] != e2[0]) {\\n                return e1[0] < e2[0];\\n            }\\n            return e1[1] > e2[1];\\n        });\\n        vector<int> dp(envelopes.size(), 1);\\n        int maxEnvelopes = 1;\\n        for (int i = 1; i < envelopes.size(); ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (envelopes[i][1] > envelopes[j][1]) {\\n                    dp[i] = max(dp[i], 1 + dp[j]);\\n                    maxEnvelopes = max(maxEnvelopes, dp[i]);\\n                }\\n            }\\n        }\\n        return maxEnvelopes;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        if (envelopes.empty()) {\\n            return 0;\\n        }\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int> &e1, const vector<int> &e2) {\\n            if (e1[0] != e2[0]) {\\n                return e1[0] < e2[0];\\n            }\\n            return e1[1] > e2[1];\\n        });\\n        vector<int> increasingArr;\\n        increasingArr.push_back(envelopes[0][1]);\\n        for (int i = 1; i < envelopes.size(); ++i) {\\n            if (envelopes[i][1] > increasingArr.back()) {\\n                increasingArr.push_back(envelopes[i][1]);\\n            } else {\\n                replaceWithBinarySearch(increasingArr, envelopes[i][1]);\\n            }\\n        }\\n        return increasingArr.size();\\n    }\\nprivate:\\n    void replaceWithBinarySearch(vector<int> &arr, int val) {\\n        int left = 0, right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] == val) {\\n                return;\\n            } else if (arr[mid] < val) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        arr[left] = val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670934,
                "title": "python-3-beats-94-with-explanation",
                "content": "The first step is to sort the *envelopes* list in **increasing** **width**, but **decreasing height**.\\n\\nYou sort it this way because if an envelop has the same width as another one, then you may not insert it into it regardless of its height.\\n\\n```\\nenvelopes.sort(key= lambda x: (x[0], -x[1]))\\n```\\n\\nThen, you determine the LIS (Longest Increasing Sequence) from the height: envelopes[i][1]\\n\\nEssentially, I\\'m getting the LIS by initializing a list of length equal to that of envelopes -Filled with infinite values. Then I\\'m getting the bisect location of each value and replacing either an infinite value, or bigger value, with that number.\\n\\nThe answer is the count of non-infinite values my new list.\\n\\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        \\n        envelopes.sort(key= lambda x: (x[0], -x[1]))\\n        \\n        dp = [float(\\'inf\\')] * len(envelopes)\\n        \\n        for w,h in envelopes:\\n            i = bisect.bisect_left(dp, h)\\n            dp[i] = h\\n        \\n        i = 0\\n        ans = 0\\n        while i < len(dp) and dp[i] != float(\\'inf\\'):\\n            i += 1\\n            ans += 1\\n        \\n        return ans\\n```\\n\\nI hope this helps!\\n\\n*Runtime: 152 ms, faster than 94.25% of Python3 online submissions for Russian Doll Envelopes.\\nMemory Usage: 16.1 MB, less than 50.90% of Python3 online submissions for Russian Doll Envelopes.*",
                "solutionTags": [],
                "code": "```\\nenvelopes.sort(key= lambda x: (x[0], -x[1]))\\n```\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        \\n        envelopes.sort(key= lambda x: (x[0], -x[1]))\\n        \\n        dp = [float(\\'inf\\')] * len(envelopes)\\n        \\n        for w,h in envelopes:\\n            i = bisect.bisect_left(dp, h)\\n            dp[i] = h\\n        \\n        i = 0\\n        ans = 0\\n        while i < len(dp) and dp[i] != float(\\'inf\\'):\\n            i += 1\\n            ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622785,
                "title": "c-variation-of-lis-dp",
                "content": "```\\nclass Solution {\\n    static bool compare(vector<int>v1, vector<int>v2) {\\n        return v1[0] < v2[0] || (v1[0] == v2[0] && v1[1] < v2[1]);\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if (n == 0) return 0;\\n        \\n        sort(envelopes.begin(), envelopes.end(), compare);\\n        \\n        int LIS[n];\\n        for (int i = 0; i < n; i++)\\n            LIS[i] = 1;\\n        \\n        int ans = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])\\n                    LIS[i] = max(LIS[i], 1+LIS[j]);\\n            }\\n            ans = max(ans, LIS[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static bool compare(vector<int>v1, vector<int>v2) {\\n        return v1[0] < v2[0] || (v1[0] == v2[0] && v1[1] < v2[1]);\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if (n == 0) return 0;\\n        \\n        sort(envelopes.begin(), envelopes.end(), compare);\\n        \\n        int LIS[n];\\n        for (int i = 0; i < n; i++)\\n            LIS[i] = 1;\\n        \\n        int ans = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])\\n                    LIS[i] = max(LIS[i], 1+LIS[j]);\\n            }\\n            ans = max(ans, LIS[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579339,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\n    static bool compare(vector<int>v1, vector<int>v2) {\\n        return v1[0] < v2[0] || (v1[0] == v2[0] && v1[1] < v2[1]);\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if (n == 0) return 0;\\n        \\n        sort(envelopes.begin(), envelopes.end(), compare);\\n        \\n        int LIS[n];\\n        for (int i = 0; i < n; i++)\\n            LIS[i] = 1;\\n        \\n        int ans = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])\\n                    LIS[i] = max(LIS[i], 1+LIS[j]);\\n            }\\n            ans = max(ans, LIS[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static bool compare(vector<int>v1, vector<int>v2) {\\n        return v1[0] < v2[0] || (v1[0] == v2[0] && v1[1] < v2[1]);\\n    }\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if (n == 0) return 0;\\n        \\n        sort(envelopes.begin(), envelopes.end(), compare);\\n        \\n        int LIS[n];\\n        for (int i = 0; i < n; i++)\\n            LIS[i] = 1;\\n        \\n        int ans = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])\\n                    LIS[i] = max(LIS[i], 1+LIS[j]);\\n            }\\n            ans = max(ans, LIS[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465134,
                "title": "dfs-or-topological-sorting",
                "content": "The solution I propose may not be as efficient as many other solutions posted. But I find topological sorting is very intuitive here and is quite interesting. Consider each doll is a node in a graph. Two nodes are connected if one can contain another. It is easy to come up with a O(n^2) solution with DFS:\\n\\n```\\nclass Solution {\\n    // Topological sorting\\n    public int maxEnvelopes(int[][] envelopes) {\\n        int[] visited = new int[envelopes.length]; // we need to memorize the longest path of each node.\\n        int max = 0;\\n        for (int i=0; i<envelopes.length; i++) {\\n            max = Math.max(max, dfs(i, envelopes, visited));\\n        }\\n        return max;\\n    }\\n    \\n    private int dfs(int cur, int[][] envelopes, int[] visited) {\\n        if (visited[cur] > 0) {\\n            return visited[cur];\\n        }\\n        \\n        int max = 1;\\n        for (int i=0; i<envelopes.length; i++) {\\n            if (envelopes[i][0] < envelopes[cur][0] && envelopes[i][1] < envelopes[cur][1]) {\\n                max = Math.max(max, dfs(i, envelopes, visited) + 1);\\n            }\\n        }\\n        visited[cur] = max;\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Topological sorting\\n    public int maxEnvelopes(int[][] envelopes) {\\n        int[] visited = new int[envelopes.length]; // we need to memorize the longest path of each node.\\n        int max = 0;\\n        for (int i=0; i<envelopes.length; i++) {\\n            max = Math.max(max, dfs(i, envelopes, visited));\\n        }\\n        return max;\\n    }\\n    \\n    private int dfs(int cur, int[][] envelopes, int[] visited) {\\n        if (visited[cur] > 0) {\\n            return visited[cur];\\n        }\\n        \\n        int max = 1;\\n        for (int i=0; i<envelopes.length; i++) {\\n            if (envelopes[i][0] < envelopes[cur][0] && envelopes[i][1] < envelopes[cur][1]) {\\n                max = Math.max(max, dfs(i, envelopes, visited) + 1);\\n            }\\n        }\\n        visited[cur] = max;\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398609,
                "title": "can-anyone-explain-why-my-solution-is-showing-tle",
                "content": "I did the same thing in java and checked in discussion froum as well, the same algo is working for other languages buy why in python is it giving TLE for larger inputs ? \\n\\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        if envelopes is None:\\n            return None \\n        l = len(envelopes)\\n        \\n        if l == 0 or l == 1:\\n            return l \\n        \\n        e = sorted(envelopes)\\n        lis = [1] * l \\n        ans = 0\\n        \\n        for i in range(1,l):\\n            p1 = e[i]\\n            for j in range(0, i):\\n                p2 = e[j]\\n                if p1[0] > p2[0] and p1[1] > p2[1]:\\n                    lis[i] = max(lis[i], lis[j] + 1)\\n            \\n            ans = max(ans, lis[i])\\n        return ans\\n            ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        if envelopes is None:\\n            return None \\n        l = len(envelopes)\\n        \\n        if l == 0 or l == 1:\\n            return l \\n        \\n        e = sorted(envelopes)\\n        lis = [1] * l \\n        ans = 0\\n        \\n        for i in range(1,l):\\n            p1 = e[i]\\n            for j in range(0, i):\\n                p2 = e[j]\\n                if p1[0] > p2[0] and p1[1] > p2[1]:\\n                    lis[i] = max(lis[i], lis[j] + 1)\\n            \\n            ans = max(ans, lis[i])\\n        return ans\\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 373703,
                "title": "simple-java-graph-based-solution-bad-performance",
                "content": "Came up with this different approach to the problem. I figured we could model these envelopes as a graph where an edge from n1 -> n2 would mean that n1 can envelope n2 [n1.width > n2.width && n1.height > n2.height]. Now that we have the graph, we can find the longest path and the length of that would give us the answer. I cached the longest path from nodes to avoid recurring subproblems, to avoid TLE. \\n\\nRuntime : 1131ms. faster than 5% of the submissions\\nMemory: 111.4mb, less than 7.69% of the submissions\\n\\nDefinitely not the best approach but a possible one. \\n\\n```\\nclass Node {\\n    int width;\\n    int height;\\n    public List<Node> canHold = new ArrayList<>();\\n    \\n    @Override\\n    public String toString() {\\n        return \"Node[\" + this.width + \"][\" + this.height + \"]\";\\n    }\\n    Node(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n    }\\n    \\n    public void checkHold(Node n) {\\n        if(this.width > n.width && this.height > n.height) {\\n            canHold.add(n);\\n        }\\n    }\\n}\\nclass Solution {\\n    public List<Node> path;\\n    public Map<Node, Integer> cache = new HashMap<>();\\n    public int getMaxDistanceHelper(Node n, int distance) {\\n        \\n        if(cache.get(n) == null) {\\n            int result;\\n            if(n.canHold.size() == 0) \\n                result = distance;\\n            else {\\n                int max = 0;\\n                for(Node n2 : n.canHold) {\\n                    int temp = 1 + getMaxDistanceHelper(n2, distance);\\n                    if(temp > max)\\n                        max = temp;\\n                }\\n                result = max;            \\n            }   \\n            cache.put(n, result);\\n        }\\n        return cache.get(n);\\n    }\\n    public int maxEnvelopes(int[][] envelopes) {\\n        List<Node> nodes = new ArrayList<>();\\n        \\n        for(int i = 0; i < envelopes.length; i++) {\\n            nodes.add(new Node(envelopes[i][0], envelopes[i][1]));\\n        }\\n        for(int i = 0; i < nodes.size(); i++) {\\n            for(int j = 0; j < nodes.size(); j++) {\\n                if(i != j) \\n                    nodes.get(i).checkHold(nodes.get(j));\\n            }\\n        }\\n\\n        int max = 0;\\n        for(Node n: nodes) {\\n            \\n            int dist = getMaxDistanceHelper(n, 1);\\n            if(dist > max)\\n                max = dist;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Node {\\n    int width;\\n    int height;\\n    public List<Node> canHold = new ArrayList<>();\\n    \\n    @Override\\n    public String toString() {\\n        return \"Node[\" + this.width + \"][\" + this.height + \"]\";\\n    }\\n    Node(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n    }\\n    \\n    public void checkHold(Node n) {\\n        if(this.width > n.width && this.height > n.height) {\\n            canHold.add(n);\\n        }\\n    }\\n}\\nclass Solution {\\n    public List<Node> path;\\n    public Map<Node, Integer> cache = new HashMap<>();\\n    public int getMaxDistanceHelper(Node n, int distance) {\\n        \\n        if(cache.get(n) == null) {\\n            int result;\\n            if(n.canHold.size() == 0) \\n                result = distance;\\n            else {\\n                int max = 0;\\n                for(Node n2 : n.canHold) {\\n                    int temp = 1 + getMaxDistanceHelper(n2, distance);\\n                    if(temp > max)\\n                        max = temp;\\n                }\\n                result = max;            \\n            }   \\n            cache.put(n, result);\\n        }\\n        return cache.get(n);\\n    }\\n    public int maxEnvelopes(int[][] envelopes) {\\n        List<Node> nodes = new ArrayList<>();\\n        \\n        for(int i = 0; i < envelopes.length; i++) {\\n            nodes.add(new Node(envelopes[i][0], envelopes[i][1]));\\n        }\\n        for(int i = 0; i < nodes.size(); i++) {\\n            for(int j = 0; j < nodes.size(); j++) {\\n                if(i != j) \\n                    nodes.get(i).checkHold(nodes.get(j));\\n            }\\n        }\\n\\n        int max = 0;\\n        for(Node n: nodes) {\\n            \\n            int dist = getMaxDistanceHelper(n, 1);\\n            if(dist > max)\\n                max = dist;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241178,
                "title": "java-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length;\\n        if(envelopes.length == 0) return 0;\\n        Comparator<int[]> comp = new Comparator<int[]>() { //comparator that sorts on area of each envelope\\n            public int compare(int[] a, int[] b) {\\n                return a[0]*a[1] - b[0]*b[1];\\n            }\\n        };\\n        \\n        Arrays.sort(envelopes, comp);\\n        int dp[] = new int[n];\\n        Arrays.fill(dp, 1);\\n        int max = 1;\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                if(envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1]) {\\n                    dp[i] = Math.max(dp[j] + 1, dp[i]);\\n                }\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n    \\n        return max;\\n    }\\n  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length;\\n        if(envelopes.length == 0) return 0;\\n        Comparator<int[]> comp = new Comparator<int[]>() { //comparator that sorts on area of each envelope\\n            public int compare(int[] a, int[] b) {\\n                return a[0]*a[1] - b[0]*b[1];\\n            }\\n        };\\n        \\n        Arrays.sort(envelopes, comp);\\n        int dp[] = new int[n];\\n        Arrays.fill(dp, 1);\\n        int max = 1;\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<i; j++) {\\n                if(envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1]) {\\n                    dp[i] = Math.max(dp[j] + 1, dp[i]);\\n                }\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n    \\n        return max;\\n    }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82805,
                "title": "clean-c-11-implementation-with-explaination-refered-from-kamyu104",
                "content": "It is easy to relate this problem with the previous LIS problem. But how to solve it under the 2 dimensional cases. The key ideas lay at that how we deal with the equal width but different hight cases.  \\n\\nA clever solution is to sort the pair<int,int> array according the width, if the width is equal, just sort by the height reversely.  \\n\\nThen we can get the following solutions :  \\n\\n    class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            int size_ = envelopes.size();\\n            if(size_ < 2)  return size_; \\n            sort(envelopes.begin(), envelopes.end(), \\n                [](const pair<int, int>& a, const pair<int, int>& b) {\\n                    if(a.first == b.first) {\\n                        return a.second > b.second;\\n                    }\\n                    else {\\n                        return a.first < b.first;\\n                    }\\n                });\\n            /** find the LIS of the height, as we have filtered the width equal cases **/\\n            vector<int> result;\\n            for (const auto& iter : envelopes) {\\n                const auto target = iter.second;\\n                auto cur = lower_bound(result.begin(), result.end(), target);\\n                if (cur == result.end()) {\\n                    result.emplace_back(target);\\n                } else {\\n                    *cur = target;\\n                }\\n            }\\n            return result.size();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            int size_ = envelopes.size();\\n            if(size_ < 2)  return size_; \\n            sort(envelopes.begin(), envelopes.end(), \\n                [](const pair<int, int>& a, const pair<int, int>& b) {\\n                    if(a.first == b.first) {\\n                        return a.second > b.second;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 82809,
                "title": "c-dp-solution-with-o-n-2-time-complexity-o-n-space-complexity",
                "content": "    class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            int ans = 0;\\n            vector<int> dp;\\n            if(!envelopes.size())\\n                return ans;\\n            sort(envelopes.begin(), envelopes.end(), cmpfunc);\\n            dp.resize(envelopes.size());\\n            dp[0] = 1;\\n            ans = 1;\\n            for(int i = 1; i < envelopes.size(); ++ i){\\n                dp[i] = 0;\\n                for(int j = 0; j < i; ++ j){\\n                    if(envelopes[j].first < envelopes[i].first && envelopes[j].second < envelopes[i].second)\\n                        dp[i] = max(dp[i], dp[j]);\\n                }\\n                ++ dp[i];\\n                ans = max(ans, dp[i]);\\n            }\\n            return ans;\\n        }\\n    private:\\n        struct cmp{\\n    \\t   bool operator() (const pair<int, int> &a, const pair<int, int> &b){\\n    \\t        return a.first*a.second < b.first*b.second; \\n    \\t   }\\n    \\t}cmpfunc;\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            int ans = 0;\\n            vector<int> dp;\\n            if(!envelopes.size())\\n                return ans;\\n            sort(envelopes.begin(), envelopes.end(), cmpfunc);\\n            dp.resize(envelopes.size());\\n            dp[0] = 1;\\n            ans = 1;\\n            for(int i = 1; i < envelopes.size(); ++ i){\\n                dp[i] = 0;\\n                for(int j = 0; j < i; ++ j){\\n                    if(envelopes[j].first < envelopes[i].first && envelopes[j].second < envelopes[i].second)\\n                        dp[i] = max(dp[i], dp[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 82777,
                "title": "6-lines-o-nlogn-ruby",
                "content": "Idea from [TianhaoSong's solution](https://leetcode.com/discuss/106946/java-nlogn-solution-with-explanation).\\n\\n    def max_envelopes(envelopes)\\n      ends = []\\n      envelopes.sort_by { |w, h| [w, -h] }.each { |_, h|\\n        i = (0...ends.size).bsearch { |i| ends[i] >= h }\\n        ends[i || ends.size] = h\\n      }\\n      ends.size\\n    end\\n\\nIf we had Ruby 2.3 here, this should also work and would be nicer:\\n\\n        i = ends.bsearch_index { |x| x >= h }",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "Idea from [TianhaoSong's solution](https://leetcode.com/discuss/106946/java-nlogn-solution-with-explanation).\\n\\n    def max_envelopes(envelopes)\\n      ends = []\\n      envelopes.sort_by { |w, h| [w, -h] }.each { |_, h|\\n        i = (0...ends.size).bsearch { |i| ends[i] >= h }\\n        ends[i || ends.size] = h\\n      }\\n      ends.size\\n    end\\n\\nIf we had Ruby 2.3 here, this should also work and would be nicer:\\n\\n        i = ends.bsearch_index { |x| x >= h }",
                "codeTag": "Python3"
            },
            {
                "id": 82817,
                "title": "my-three-c-solutions-dp-binary-search-and-lower-bound",
                "content": "Solution One:\\n\\n    class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            int res = 0, n = envelopes.size();\\n    \\t\\tvector<int> dp(n, 1);\\n    \\t\\tsort(envelopes.begin(), envelopes.end());\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\tfor (int j = 0; j < i; ++j) {\\n    \\t\\t\\t\\tif (envelopes[i].first > envelopes[j].first && envelopes[i].second > envelopes[j].second) {\\n    \\t\\t\\t\\t\\tdp[i] = max(dp[i], dp[j] + 1);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tres = max(res, dp[i]);\\n    \\t\\t}\\n    \\t\\treturn res;\\n        }\\n    };\\n\\nSolution Two:\\n\\n    class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            vector<int> dp;\\n    \\t\\tsort(envelopes.begin(), envelopes.end(), [](const pair<int, int> &a, const pair<int, int> &b){\\n    \\t\\t\\tif (a.first == b.first) return a.second > b.second;\\n    \\t\\t\\treturn a.first < b.first;\\n    \\t\\t});\\n    \\t\\tfor (int i = 0; i < envelopes.size(); ++i) {\\n    \\t\\t\\tint left = 0, right = dp.size(), t= envelopes[i].second;\\n    \\t\\t\\twhile (left < right) {\\n    \\t\\t\\t\\tint mid = left + (right - left) / 2;\\n    \\t\\t\\t\\tif (dp[mid] < t) left = mid + 1;\\n    \\t\\t\\t\\telse right = mid;\\n    \\t\\t\\t}\\n    \\t\\t\\tif (right >= dp.size()) dp.push_back(t);\\n    \\t\\t\\telse dp[right] = t;\\n    \\t\\t}\\n    \\t\\treturn dp.size();\\n        }\\n    };\\n\\nSolution Three:\\n\\n    class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            vector<int> dp;\\n    \\t\\tsort(envelopes.begin(), envelopes.end(), [](const pair<int, int> &a, const pair<int, int> &b){\\n    \\t\\t\\tif (a.first == b.first) return a.second > b.second;\\n    \\t\\t\\treturn a.first < b.first;\\n    \\t\\t});\\n    \\t\\tfor (int i = 0; i < envelopes.size(); ++i) {\\n    \\t\\t\\tauto it = lower_bound(dp.begin(), dp.end(), envelopes[i].second);\\n    \\t\\t\\tif (it == dp.end()) dp.push_back(envelopes[i].second);\\n    \\t\\t\\telse *it = envelopes[i].second;\\n    \\t\\t}\\n    \\t\\treturn dp.size();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxEnvelopes(vector<pair<int, int>>& envelopes) {\\n            int res = 0, n = envelopes.size();\\n    \\t\\tvector<int> dp(n, 1);\\n    \\t\\tsort(envelopes.begin(), envelopes.end());\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\tfor (int j = 0; j < i; ++j) {\\n    \\t\\t\\t\\tif (envelopes[i].first > envelopes[j].first && envelopes[i].second > envelopes[j].second) {\\n    \\t\\t\\t\\t\\tdp[i] = max(dp[i], dp[j] + 1);\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 82822,
                "title": "longest-path-in-dag-dp-solution-with-follow-up-solution",
                "content": "**dp[i] = max(0, dp[j]** | if rectangle j can be embedded to rectangle i) **+ 1**\\n\\n    public class Solution {\\n        \\n        boolean canFit(int[] a, int[] b) {  // Rectangle a can fit into rectangle b. \\n            return (a[0] < b[0] && a[1] < b[1]);\\n        }\\n        \\n        public int maxEnvelopes(int[][] envelopes) {\\n            if(envelopes == null || envelopes.length == 0) return 0;\\n            // In the follow up question, rectangle can be rotated to fit into another. In this case, we need preprocess envelopes array to let smaller value be envelopes[0], bigger value be envelopes[1]\\n            Arrays.sort(envelopes, (int[] x, int[] y) -> x[0] - y[0]);\\n            int n = envelopes.length;\\n            int dp[] = new int[n];\\n            int rst = 0;\\n            for(int i = 0; i < n; ++i) {\\n                int max = 0;\\n                for(int j = 0; j < i; ++j) {\\n                    if(canFit(envelopes[j], envelopes[i])) max = Math.max(max, dp[j]);\\n                }\\n                dp[i] = max + 1;\\n                rst = Math.max(dp[i], rst);\\n            }\\n            return rst;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        boolean canFit(int[] a, int[] b) {  // Rectangle a can fit into rectangle b. \\n            return (a[0] < b[0] && a[1] < b[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3592608,
                "title": "lis-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//recursive TLE\\n    int solve(int ind, int prevwidth, int prevheight, vector<vector<int>> &envelopes, int n)\\n{\\n    if (ind >= n)\\n    {\\n        return 0;\\n    }\\n    int nonpick = 0 + solve(ind + 1, prevwidth, prevheight, envelopes, n);\\n    int pick = 0;\\n    if (envelopes[ind][0] > prevwidth and envelopes[ind][1] > prevheight)\\n    {\\n        pick = 1 + solve(ind + 1, envelopes[ind][0], envelopes[ind][1], envelopes, n);\\n    }\\n    return max(pick, nonpick);\\n}\\n\\nstatic bool cmp(vector<int> &a, vector<int> &b)\\n{\\n    if (a[0] == b[0])\\n    {\\n        return a[1] > b[1];\\n    }\\n\\n    return a[0] < b[0];\\n}\\n\\nint maxEnvelopes(vector<vector<int>> &envelopes)\\n{\\n    int n = envelopes.size();\\n    sort(envelopes.begin(), envelopes.end(), cmp);\\n    // return solve(0, -1, -1, envelopes, n);\\n\\n    vector<int> temp;\\n    for (int i = 0; i < n; i++)\\n    {\\n        int val = envelopes[i][1];\\n        int index = lower_bound(temp.begin(), temp.end(), val) - temp.begin();\\n\\n        if (index >= temp.size())\\n        {\\n            temp.push_back(val);\\n        }\\n        else\\n        {\\n            temp[index] = val;\\n        }\\n    }\\n    return temp.size();\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//recursive TLE\\n    int solve(int ind, int prevwidth, int prevheight, vector<vector<int>> &envelopes, int n)\\n{\\n    if (ind >= n)\\n    {\\n        return 0;\\n    }\\n    int nonpick = 0 + solve(ind + 1, prevwidth, prevheight, envelopes, n);\\n    int pick = 0;\\n    if (envelopes[ind][0] > prevwidth and envelopes[ind][1] > prevheight)\\n    {\\n        pick = 1 + solve(ind + 1, envelopes[ind][0], envelopes[ind][1], envelopes, n);\\n    }\\n    return max(pick, nonpick);\\n}\\n\\nstatic bool cmp(vector<int> &a, vector<int> &b)\\n{\\n    if (a[0] == b[0])\\n    {\\n        return a[1] > b[1];\\n    }\\n\\n    return a[0] < b[0];\\n}\\n\\nint maxEnvelopes(vector<vector<int>> &envelopes)\\n{\\n    int n = envelopes.size();\\n    sort(envelopes.begin(), envelopes.end(), cmp);\\n    // return solve(0, -1, -1, envelopes, n);\\n\\n    vector<int> temp;\\n    for (int i = 0; i < n; i++)\\n    {\\n        int val = envelopes[i][1];\\n        int index = lower_bound(temp.begin(), temp.end(), val) - temp.begin();\\n\\n        if (index >= temp.size())\\n        {\\n            temp.push_back(val);\\n        }\\n        else\\n        {\\n            temp[index] = val;\\n        }\\n    }\\n    return temp.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418441,
                "title": "optimizing-the-longest-increasing-subsequence-algorithm-for-russian-doll-envelopes-very-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find the maximum number of envelopes we can put one inside the other, given that we can only put an envelope inside another if its width and height are strictly greater than the width and height of the other envelope. We can solve this problem using the Longest Increasing Subsequence (LIS) algorithm. We can sort the envelopes in increasing order of their width and if the widths of two envelopes are the same, we can sort them in decreasing order of their height so that the same width element won\\'t get counted in the LIS. After sorting, we can find the LIS of the heights of the envelopes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the envelopes in increasing order of their width.\\nIf the widths of two envelopes are the same, sort them in decreasing order of their height.\\nFind the Longest Increasing Subsequence (LIS) of the heights of the envelopes.\\nWe can implement the LIS algorithm using dynamic programming or binary search. We can use dynamic programming to solve the problem in O(n^2) time complexity and O(n) space complexity. Alternatively, we can use the binary search version of the LIS algorithm to optimize the time complexity to O(n log n) and the space complexity to O(n).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting the envelopes takes O(n log n) time complexity. Finding the LIS using dynamic programming takes O(n^2) time complexity, and finding the LIS using binary search takes O(n log n) time complexity. Therefore, the overall time complexity of the solution is O(n log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use O(n) space complexity to store the LIS array. Therefore, the overall space complexity of the solution is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n  int n = envelopes.size();\\n    sort(envelopes.begin(), envelopes.end(), [](const auto& a, const auto& b) {\\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\\n    });\\n    vector<int> tails;\\n    for (int i = 0; i < n; i++) {\\n        int h = envelopes[i][1];\\n        auto it = lower_bound(tails.begin(), tails.end(), h);\\n        if (it == tails.end()) {\\n            tails.push_back(h);\\n        } else {\\n            *it = h;\\n        }\\n    }\\n    return tails.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n  int n = envelopes.size();\\n    sort(envelopes.begin(), envelopes.end(), [](const auto& a, const auto& b) {\\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\\n    });\\n    vector<int> tails;\\n    for (int i = 0; i < n; i++) {\\n        int h = envelopes[i][1];\\n        auto it = lower_bound(tails.begin(), tails.end(), h);\\n        if (it == tails.end()) {\\n            tails.push_back(h);\\n        } else {\\n            *it = h;\\n        }\\n    }\\n    return tails.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481615,
                "title": "easy-solution-using-binary-search-for-longest-increasing-subsequence-happy-coding",
                "content": "```\\nclass Solution {\\n      \\npublic:\\n    bool static comp( vector<int>&a, vector<int>&b){\\n        if(a[0]==b[0])\\n        {\\n            return a[1]>b[1];\\n        }\\n        else{\\n            return a[0]<b[0];\\n        }\\n   }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) \\n    {\\n        \\n        int n=envelopes.size();\\n        sort(envelopes.begin(),envelopes.end(),comp);\\n        vector<int>ans;\\n        ans.push_back(envelopes[0][1]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(envelopes[i][1]>ans.back()){\\n                ans.push_back(envelopes[i][1]);\\n            }\\n            else\\n            {\\n                int idx=lower_bound(ans.begin(),ans.end(),envelopes[i][1]) - ans.begin();\\n                ans[idx]=envelopes[i][1];\\n            }\\n        }\\n        \\n        return ans.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n      \\npublic:\\n    bool static comp( vector<int>&a, vector<int>&b){\\n        if(a[0]==b[0])\\n        {\\n            return a[1]>b[1];\\n        }\\n        else{\\n            return a[0]<b[0];\\n        }\\n   }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) \\n    {\\n        \\n        int n=envelopes.size();\\n        sort(envelopes.begin(),envelopes.end(),comp);\\n        vector<int>ans;\\n        ans.push_back(envelopes[0][1]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(envelopes[i][1]>ans.back()){\\n                ans.push_back(envelopes[i][1]);\\n            }\\n            else\\n            {\\n                int idx=lower_bound(ans.begin(),ans.end(),envelopes[i][1]) - ans.begin();\\n                ans[idx]=envelopes[i][1];\\n            }\\n        }\\n        \\n        return ans.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386379,
                "title": "c-sort-cmp-using-lambda-function-lis-o-nlogn-n-s-1",
                "content": "1. Sorting the envelopes in ascending order of width. If they are same width, sorting the envelopes in descending order.\\n2. Finding the longest increasing subsequence of width by using lower bound(binary search). To save the space, we use the original instead of creating a new vector to store the LIS.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end(), [](auto &l, auto &r)\\n             {\\n                return l[0] == r[0] ? l[1] > r[1] : l[0] < r[0]; \\n             });\\n        int len = 0;\\n        for(auto& cur: envelopes)\\n        {\\n            if(len==0 || envelopes[len-1][1] < cur[1])\\n                envelopes[len++] = cur;\\n            else\\n                *lower_bound(envelopes.begin(), envelopes.begin()+ len, cur, [](auto &l, auto &r)\\n                             {\\n                                 return l[1] < r[1];\\n                             }) = cur;\\n        }\\n        return len;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8816f6f4-408c-479d-a672-742751d6cba5_1659772940.2546148.png)\\n\\nIf you like it, please give me a upvote. \\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end(), [](auto &l, auto &r)\\n             {\\n                return l[0] == r[0] ? l[1] > r[1] : l[0] < r[0]; \\n             });\\n        int len = 0;\\n        for(auto& cur: envelopes)\\n        {\\n            if(len==0 || envelopes[len-1][1] < cur[1])\\n                envelopes[len++] = cur;\\n            else\\n                *lower_bound(envelopes.begin(), envelopes.begin()+ len, cur, [](auto &l, auto &r)\\n                             {\\n                                 return l[1] < r[1];\\n                             }) = cur;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368424,
                "title": "faster-than-98-06-python-binary-search-insert-tc-o-nlogn-sc-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/9752f8c3-d0d9-4bae-8b61-775c6c9a7825_1659428636.4378119.png)\\n**solution**\\n```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes = sorted(envelopes, key= lambda x:(x[0],-x[1]))\\n        rst = []\\n        for _,h in envelopes:\\n            i = bisect_left(rst,h)\\n            if i == len(rst):\\n                rst.append(h)\\n            else:\\n                rst[i] = h\\n        return len(rst)\\n```\\n:)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes = sorted(envelopes, key= lambda x:(x[0],-x[1]))\\n        rst = []\\n        for _,h in envelopes:\\n            i = bisect_left(rst,h)\\n            if i == len(rst):\\n                rst.append(h)\\n            else:\\n                rst[i] = h\\n        return len(rst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347407,
                "title": "java-easy-nlogn-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n\\t\\t//sort the envelopes considering only width\\n        Arrays.sort(envelopes, new sortEnvelopes());\\n\\t\\t\\n\\t\\t//Now this is a Longest Increasing Subsequence problem on heights\\n\\t\\t//tempList to store the temporary elements, size of this list will be the length of LIS \\n        ArrayList<Integer> tempList = new ArrayList<>();\\n        tempList.add(envelopes[0][1]);\\n\\t\\t\\n        for(int i=1; i<envelopes.length; i++){\\n            if(envelopes[i][1]>tempList.get(tempList.size()-1)){\\n                tempList.add(envelopes[i][1]);\\n            } else{\\n\\t\\t\\t//if the element is smaller than the largest(last because it is sorted) element of tempList, replace the largest smaller element of tempList with it..\\n\\t\\t\\t//ex->(assume if envelopes[i][1] is 4), then >>[1,7,8] will become [1,4,8]<<\\n                int index = lowerBound(tempList, envelopes[i][1]);\\n                tempList.set(index, envelopes[i][1]);\\n            }\\n        }\\n        return tempList.size();\\n    }\\n    \\n\\t//finding the index of greatest smaller element \\n    public int lowerBound(ArrayList<Integer> list, int search){\\n        int start = 0;\\n        int end = list.size()-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if(list.get(mid) < search){\\n                start = mid+1;\\n            } else{\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n\\nclass sortEnvelopes implements Comparator<int[]> {\\n    public int compare(int[] a, int[] b){\\n        if(a[0] == b[0]){\\n\\t\\t//to ignore the duplicates, we are sorting such that, for same width-> element with \\n\\t\\t//largest height would be considered first, in this way all the other smaller heights would\\n\\t\\t//be ignored\\n            return b[1] - a[1];\\n        } else{\\n            return a[0] - b[0];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n\\t\\t//sort the envelopes considering only width\\n        Arrays.sort(envelopes, new sortEnvelopes());\\n\\t\\t\\n\\t\\t//Now this is a Longest Increasing Subsequence problem on heights\\n\\t\\t//tempList to store the temporary elements, size of this list will be the length of LIS \\n        ArrayList<Integer> tempList = new ArrayList<>();\\n        tempList.add(envelopes[0][1]);\\n\\t\\t\\n        for(int i=1; i<envelopes.length; i++){\\n            if(envelopes[i][1]>tempList.get(tempList.size()-1)){\\n                tempList.add(envelopes[i][1]);\\n            } else{\\n\\t\\t\\t//if the element is smaller than the largest(last because it is sorted) element of tempList, replace the largest smaller element of tempList with it..\\n\\t\\t\\t//ex->(assume if envelopes[i][1] is 4), then >>[1,7,8] will become [1,4,8]<<\\n                int index = lowerBound(tempList, envelopes[i][1]);\\n                tempList.set(index, envelopes[i][1]);\\n            }\\n        }\\n        return tempList.size();\\n    }\\n    \\n\\t//finding the index of greatest smaller element \\n    public int lowerBound(ArrayList<Integer> list, int search){\\n        int start = 0;\\n        int end = list.size()-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if(list.get(mid) < search){\\n                start = mid+1;\\n            } else{\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n\\nclass sortEnvelopes implements Comparator<int[]> {\\n    public int compare(int[] a, int[] b){\\n        if(a[0] == b[0]){\\n\\t\\t//to ignore the duplicates, we are sorting such that, for same width-> element with \\n\\t\\t//largest height would be considered first, in this way all the other smaller heights would\\n\\t\\t//be ignored\\n            return b[1] - a[1];\\n        } else{\\n            return a[0] - b[0];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073523,
                "title": "c-solution-sort-then-find-the-longest-subsequence-of-the-width",
                "content": "\\t// Sort height by ascending and the width by descending\\n\\tpublic class CustomComparer : Comparer<int[]>\\n\\t{\\n\\t\\tpublic override int Compare(int[] array1, int[] array2){\\n\\t\\t\\tif(array1[0] != array2[0]){\\n\\t\\t\\t\\treturn (array1[0]-array2[0]);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\treturn(array2[1]-array1[1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic class Solution {\\n\\t\\n\\t\\t// Find the longest subsequence of width\\n\\t\\tprivate int LongestSubSequence(int[] sequence){\\n\\t\\t\\tList<int> seq = new List<int>();\\n\\t\\t\\tseq.Add(sequence[0]);\\n\\t\\t\\tfor(int i=1;i<sequence.Length;i++){\\n\\t\\t\\t\\tint num = sequence[i];\\n\\t\\t\\t\\tif(sequence[i]>seq[seq.Count-1]){\\n\\t\\t\\t\\t\\tseq.Add(sequence[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint nextLargestIndex = BinarySearch(seq,num);\\n\\t\\t\\t\\t\\tseq[nextLargestIndex] = num;\\n\\t\\t\\t\\t }      \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn seq.Count;\\n\\t\\t}\\n\\t\\t\\n\\t\\t//Use binary search to find the next largest element of the given number\\n\\t\\tprivate int BinarySearch(List<int> seq, int num){\\n\\t\\t\\tint startIndex = 0;\\n\\t\\t\\tint endIndex = seq.Count-1;\\n\\n\\t\\t\\twhile(startIndex<endIndex){\\n\\t\\t\\t\\tint midIndex = (startIndex)+(endIndex-startIndex)/2;\\n\\n\\t\\t\\t\\tif(seq[midIndex] == num)\\n\\t\\t\\t\\t\\treturn midIndex;\\n\\n\\t\\t\\t\\tif(seq[midIndex]<num){\\n\\t\\t\\t\\t\\tstartIndex = midIndex+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tendIndex = midIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn startIndex;\\n\\t\\t}\\n\\t\\tpublic int MaxEnvelopes(int[][] envelopes) {\\n\\t\\t   Array.Sort(envelopes, new CustomComparer());\\n\\n\\t\\t\\tint[] widthSequence = new int[envelopes.Length];\\n\\t\\t\\tfor(int i=0;i<envelopes.Length;i++){\\n\\t\\t\\t\\twidthSequence[i] = envelopes[i][1];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn LongestSubSequence(widthSequence);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\n\\t\\t// Find the longest subsequence of width\\n\\t\\tprivate int LongestSubSequence(int[] sequence){\\n\\t\\t\\tList<int> seq = new List<int>();\\n\\t\\t\\tseq.Add(sequence[0]);\\n\\t\\t\\tfor(int i=1;i<sequence.Length;i++){\\n\\t\\t\\t\\tint num = sequence[i];\\n\\t\\t\\t\\tif(sequence[i]>seq[seq.Count-1]){\\n\\t\\t\\t\\t\\tseq.Add(sequence[i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2072835,
                "title": "easy-understandable-java",
                "content": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] arr) {\\n         int n = arr.length;\\n        Arrays.sort(arr,(p,q)-> p[0]==q[0] ? q[1]-p[1] : p[0]-q[0]);\\n        \\n         int dp[] = new int[arr.length];\\n    int len = 0;\\n    for(int[] envelope : arr){\\n        int index = binarySearch(dp, 0, len, envelope[1]);\\n        \\n        dp[index] = envelope[1];\\n        if(index == len)\\n            len++;\\n    }\\n    return len;\\n        \\n    }\\n    \\n    public int binarySearch(int[] dp,int si, int ei, int target) {\\n         while(si<ei){\\n             int mid = si+(ei-si)/2;\\n             if(dp[mid] == target) return mid;\\n             else if(dp[mid] > target) ei = mid;\\n             else  si = mid+1;\\n         }\\n        return si;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] arr) {\\n         int n = arr.length;\\n        Arrays.sort(arr,(p,q)-> p[0]==q[0] ? q[1]-p[1] : p[0]-q[0]);\\n        \\n         int dp[] = new int[arr.length];\\n    int len = 0;\\n    for(int[] envelope : arr){\\n        int index = binarySearch(dp, 0, len, envelope[1]);\\n        \\n        dp[index] = envelope[1];\\n        if(index == len)\\n            len++;\\n    }\\n    return len;\\n        \\n    }\\n    \\n    public int binarySearch(int[] dp,int si, int ei, int target) {\\n         while(si<ei){\\n             int mid = si+(ei-si)/2;\\n             if(dp[mid] == target) return mid;\\n             else if(dp[mid] > target) ei = mid;\\n             else  si = mid+1;\\n         }\\n        return si;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072739,
                "title": "solution-with-the-explanation",
                "content": "**Here is the simple code and explanation, if you have any doubt then please ask me.**\\n\\n\\tclass Solution:\\n\\t\\tdef maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n\\t\\t\\tenvelopes.sort(key=lambda x: (x[0], -x[1]))\\n\\t\\t\\t#why we are using the comparator function and why the simple sort will not work here?\\n\\t\\t\\t# lets take an example [[4,5],[4,6],[6,7],[2,3],[1,1]]\\n\\t\\t\\t# for this example if we sort with our simple sort function the after sort\\n\\t\\t\\t# [[1,1],[2,3],[4,5],[4,6],[6,7]]\\n\\t\\t\\t# and if we use this then our answer will not be correct because when we are puting the elements into the res list then [4,5] will be first inserted into the list and after that we got [4,6] and it will use it as a big envelope and thinks that [4,6] will store all of them (i.e. means all the previous ones) but that not the case so we have to use comparator function to solve this problem\\n\\t\\t\\t#after sorting using the comparator function we will get the array like\\n\\t\\t\\t#[[1,1],[2,3],[4,7],[4,6],[6,7]]\\n\\t\\t\\t#and when we are finding the position for the [4,6] it will return the ind 2 but we have already the length 3 so we will replace [4,7] with [4,6]\\n\\t\\t\\t#and it will gives the correct output\\n\\t\\t\\tres = []\\n\\t\\t\\tfor i, e in enumerate(envelopes):\\n\\t\\t\\t\\tidx = bisect_left(res, e[1])\\n\\t\\t\\t\\tif idx == len(res):\\n\\t\\t\\t\\t\\tres.append(e[1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[idx]=e[1]\\n\\t\\t\\treturn len(res)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "**Here is the simple code and explanation, if you have any doubt then please ask me.**\\n\\n\\tclass Solution:\\n\\t\\tdef maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n\\t\\t\\tenvelopes.sort(key=lambda x: (x[0], -x[1]))\\n\\t\\t\\t#why we are using the comparator function and why the simple sort will not work here?\\n\\t\\t\\t# lets take an example [[4,5],[4,6],[6,7],[2,3],[1,1]]\\n\\t\\t\\t# for this example if we sort with our simple sort function the after sort\\n\\t\\t\\t# [[1,1],[2,3],[4,5],[4,6],[6,7]]\\n\\t\\t\\t# and if we use this then our answer will not be correct because when we are puting the elements into the res list then [4,5] will be first inserted into the list and after that we got [4,6] and it will use it as a big envelope and thinks that [4,6] will store all of them (i.e. means all the previous ones) but that not the case so we have to use comparator function to solve this problem\\n\\t\\t\\t#after sorting using the comparator function we will get the array like\\n\\t\\t\\t#[[1,1],[2,3],[4,7],[4,6],[6,7]]\\n\\t\\t\\t#and when we are finding the position for the [4,6] it will return the ind 2 but we have already the length 3 so we will replace [4,7] with [4,6]\\n\\t\\t\\t#and it will gives the correct output\\n\\t\\t\\tres = []\\n\\t\\t\\tfor i, e in enumerate(envelopes):\\n\\t\\t\\t\\tidx = bisect_left(res, e[1])\\n\\t\\t\\t\\tif idx == len(res):\\n\\t\\t\\t\\t\\tres.append(e[1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[idx]=e[1]\\n\\t\\t\\treturn len(res)",
                "codeTag": "Java"
            },
            {
                "id": 2072230,
                "title": "python-lis-simple-solution-with-explanation",
                "content": "### Logic:\\n1. This problem resembles with [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) so we will use a similar logic of building the longest increasing subsequence in the most optimal way(in O(NlogN) time).\\n2. Since the given envelopes are in random order so the first thing that we have to do is to sort those envelopes in ascending order of their width (and descending order of their height in case of same width) or vice versa.\\n3. The above sorting is done in a particular mentioned way so as to build the **lis(our answer variable)** as follows:\\n\\t- While iterating over envelopes(sorted as per point #2), for **width[i]** if **width[i-1] < width[i]** and if **height[i-1] < height[i]** then we add the ith envelope in **lis**, if **height[i-1] >= height[i]** then we check for next envelope.\\n\\t- While iterating over envelopes(sorted as per point #2), for **width[i]** if **width[i-1] == width[i]** then we take only that envelope of **width[i]** whose **height** is just greater than envelope **j** where **width[j]** is just small than **width[i]**\\n4. Point #3 basically means that we have to build **lis** over the heights of envelope and widths will be already taken care of because of particular (mentioned in point #2) way of sorting.\\n\\n```\\nclass Solution:\\n    def binarySearch(self, heights, minHeight):\\n        start = 0\\n        end = len(heights)\\n        while start < end:\\n            mid = start + ((end - start) // 2)\\n            if heights[mid] < minHeight:\\n                start = mid + 1\\n            else:\\n                end = mid\\n        return start\\n\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key = lambda x: (x[0], -x[1]))\\n        \\n        heights = [h for _, h in envelopes]\\n        lis = []\\n        \\n        for height in heights:\\n            idx = self.binarySearch(lis, height)\\n            if idx == len(lis):\\n                lis.append(height)\\n            else:\\n                lis[idx] = height\\n\\n        return len(lis)\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def binarySearch(self, heights, minHeight):\\n        start = 0\\n        end = len(heights)\\n        while start < end:\\n            mid = start + ((end - start) // 2)\\n            if heights[mid] < minHeight:\\n                start = mid + 1\\n            else:\\n                end = mid\\n        return start\\n\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key = lambda x: (x[0], -x[1]))\\n        \\n        heights = [h for _, h in envelopes]\\n        lis = []\\n        \\n        for height in heights:\\n            idx = self.binarySearch(lis, height)\\n            if idx == len(lis):\\n                lis.append(height)\\n            else:\\n                lis[idx] = height\\n\\n        return len(lis)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072080,
                "title": "russian-doll-envelopes-java-binary-search",
                "content": "#### **Russian Doll Envelopes**\\n\\nThe naive Longest Increasing Subsequence approach gives a TLE. Hence we use Binary Search.\\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length, left, right, mid;\\n        // Sort array\\n        Arrays.sort(envelopes, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] == b[0]) {\\n                    return Integer.compare(b[1], a[1]);\\n                } else {\\n                    return Integer.compare(a[0], b[0]);\\n                }\\n            }\\n        });\\n        \\n        List<Integer> list = new ArrayList<>();\\n        list.add(envelopes[0][1]);\\n        \\n        for (int i=1; i<n; i++) {\\n            if (envelopes[i][1] > list.get(list.size() - 1)) {\\n                list.add(envelopes[i][1]);\\n            } else {\\n                // Find pos of first element which is >= current element\\n                left = 0; \\n                right = list.size() - 1;\\n                while (left < right) {\\n                    mid = left + (right - left) / 2;\\n                    if (list.get(mid) >= envelopes[i][1]) {\\n                        right = mid;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                list.set(right, envelopes[i][1]);\\n            }\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n = envelopes.length, left, right, mid;\\n        // Sort array\\n        Arrays.sort(envelopes, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] == b[0]) {\\n                    return Integer.compare(b[1], a[1]);\\n                } else {\\n                    return Integer.compare(a[0], b[0]);\\n                }\\n            }\\n        });\\n        \\n        List<Integer> list = new ArrayList<>();\\n        list.add(envelopes[0][1]);\\n        \\n        for (int i=1; i<n; i++) {\\n            if (envelopes[i][1] > list.get(list.size() - 1)) {\\n                list.add(envelopes[i][1]);\\n            } else {\\n                // Find pos of first element which is >= current element\\n                left = 0; \\n                right = list.size() - 1;\\n                while (left < right) {\\n                    mid = left + (right - left) / 2;\\n                    if (list.get(mid) >= envelopes[i][1]) {\\n                        right = mid;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                list.set(right, envelopes[i][1]);\\n            }\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071844,
                "title": "lis-with-binary-search",
                "content": "class Solution {\\n    \\n    public class Envelop implements Comparable<Envelop>{\\n        \\n        int width;\\n        int height;\\n        \\n        Envelop(int width,int height){\\n            \\n            this.width=width;\\n            this.height=height;\\n        }\\n        \\n        \\n        public int compareTo(Envelop e){\\n            \\n            if(this.width==e.width){\\n               return -this.height+e.height;\\n            }\\n            return this.width-e.width;\\n        }\\n    }\\n    public int maxEnvelopes(int[][] envelopes) {\\n        \\n        \\n        \\n        Envelop[] arr=new Envelop[envelopes.length];\\n        \\n        for(int i=0;i<envelopes.length;i++){\\n            \\n            arr[i]=new Envelop(envelopes[i][0],envelopes[i][1]);\\n        }\\n        \\n        Arrays.sort(arr);\\n        \\n        // applying lis here\\n    \\n          \\n        \\n        \\n        int[] dp=new int[arr.length];\\n        int clen=0;\\n        \\n   \\n        \\n        \\n        for(int i=0;i<arr.length;i++){\\n            \\n        \\n         int lo=0;\\n         int hi=clen;\\n            \\n            \\n            while(lo<hi){\\n                \\n                int mid=(lo+hi)/2;\\n                \\n                if(dp[mid]<arr[i].height){\\n                    lo=mid+1;\\n                }\\n                else{\\n                    hi=mid;\\n                }\\n            }\\n            \\n            dp[lo]=arr[i].height;\\n            \\n            if(lo==clen){\\n                clen++;\\n            }\\n            \\n       \\n        }\\n        return clen;\\n    }\\n}\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n    public class Envelop implements Comparable<Envelop>{\\n        \\n        int width;\\n        int height;\\n        \\n        Envelop(int width,int height){\\n            \\n            this.width=width;\\n            this.height=height;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2071801,
                "title": "dp-and-ceil-binary-search-python-o-nlog-n",
                "content": "**Steps:**\\n1.Sort given envelopes.(increasing width and if(width are equal arrange them in decresing order of height)\\n2.declare dp table with max value\\n3.findind the ceil to know how many elements are smaller than current.\\n4.enter the values or store something at that index.\\n5.serch for max value you stored.\\n**Time complexity:**\\n**(Nlog(N))**(to sort)+**(N+1)**(dp table)+**(Nlog(N))**(for finding ceil for every element)+**(N)**(to find index of max we declared)\\n```\\nclass Solution:\\n    def ceil(self,arr,i,j,k):\\n        ans=-1\\n        while(i<=j):\\n            m=(i+j)//2\\n            if(arr[m]<k):\\n                i=m+1\\n            else:\\n                ans=m\\n                j=m-1\\n        return ans\\n    def maxEnvelopes(self, e: List[List[int]]) -> int:\\n        l=sorted(e, key=lambda x:[x[0],-x[1]]) #step1\\n        dp=[float(\\'inf\\') for i in range(len(e)+1)] #step2\\n        for i in range(len(e)): #step3\\n            k=self.ceil(dp,0,len(e)-1,l[i][1])\\n            dp[k]=l[i][1] #step4\\n        return dp.index(float(\\'inf\\')) #step5\\n```\\n**upvote**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def ceil(self,arr,i,j,k):\\n        ans=-1\\n        while(i<=j):\\n            m=(i+j)//2\\n            if(arr[m]<k):\\n                i=m+1\\n            else:\\n                ans=m\\n                j=m-1\\n        return ans\\n    def maxEnvelopes(self, e: List[List[int]]) -> int:\\n        l=sorted(e, key=lambda x:[x[0],-x[1]]) #step1\\n        dp=[float(\\'inf\\') for i in range(len(e)+1)] #step2\\n        for i in range(len(e)): #step3\\n            k=self.ceil(dp,0,len(e)-1,l[i][1])\\n            dp[k]=l[i][1] #step4\\n        return dp.index(float(\\'inf\\')) #step5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071772,
                "title": "lis-dp-python-soln",
                "content": "As problem stated we have to put the envelope if and only if height1 < height2 and width1 < width2.\\nSo, a solution part if we come up with LIS Solution after sorting the envelopes Array/List. it will give us the wrong ans for some test cases **but why**??\\n\\nSo, lets take one example and see\\n\\nenv = [[4,5],[4,6],[6,7],[2,3],[1,1]]\\nafter sorting on width:\\nenv = [[1,1],[2,3],[4,5],[4,6],[6,7]]\\n\\nnow, if we compare the height for calculating the LIS the it would lead us to wrong ans because of \\n[[1,1],[2,3]**,[4,5],[4,6]**,[6,7]]\\n\\n**So Now**\\n\\nWe can do two things to overcome this issue\\n1. we can sort width in asc order and height in desending order\\n2. comparing the height and width both for LIS\\n\\nCode accoring to first Solution\\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        dp = [1] * len(envelopes)\\n        maxi = 1\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        for i in range(1, len(envelopes)):\\n            for j in range(i):\\n                if envelopes[i][1] > envelopes[j][1] and  dp[i] <= dp[j]:\\n                    dp[i] = dp[j]+1\\n                    if dp[i] > maxi:\\n                        maxi = dp[i]\\n        return maxi\\n```\\n\\nUmm, this code will give us TLE.\\nSo, better soln is by using bisect function.\\n\\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        dp = []\\n        for width,height in envelopes:\\n\\t\\t# returns the index where to insert ele to maintain list in sorted order \\n\\t\\t\\tleft = bisect_left(dp, height)\\n            if left == len(dp): dp.append(height)\\n            else: dp[left] = height\\n        return len(dp)\\n```\\n\\nAccepted:\\n\\nThanks.\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        dp = [1] * len(envelopes)\\n        maxi = 1\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        for i in range(1, len(envelopes)):\\n            for j in range(i):\\n                if envelopes[i][1] > envelopes[j][1] and  dp[i] <= dp[j]:\\n                    dp[i] = dp[j]+1\\n                    if dp[i] > maxi:\\n                        maxi = dp[i]\\n        return maxi\\n```\n```\\nclass Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        dp = []\\n        for width,height in envelopes:\\n\\t\\t# returns the index where to insert ele to maintain list in sorted order \\n\\t\\t\\tleft = bisect_left(dp, height)\\n            if left == len(dp): dp.append(height)\\n            else: dp[left] = height\\n        return len(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071541,
                "title": "clean-and-concise-lis-variation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& arr) {\\n        sort(arr.begin(),arr.end(),[&](auto &a,auto &b){return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];});\\n        \\n        int n = arr.size();\\n        \\n        vector<vector<int>> dp;\\n        \\n        for(int i=0;i<n;i++){\\n            auto lb = lower_bound(dp.begin(),dp.end(),arr[i],[&](auto &a, auto &b){return (a[1] < b[1]) and (a[0] < b[0]);});\\n            if(lb == dp.end())\\n                dp.push_back(arr[i]);\\n            else\\n                *lb = arr[i];\\n        }\\n        \\n        return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& arr) {\\n        sort(arr.begin(),arr.end(),[&](auto &a,auto &b){return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];});\\n        \\n        int n = arr.size();\\n        \\n        vector<vector<int>> dp;\\n        \\n        for(int i=0;i<n;i++){\\n            auto lb = lower_bound(dp.begin(),dp.end(),arr[i],[&](auto &a, auto &b){return (a[1] < b[1]) and (a[0] < b[0]);});\\n            if(lb == dp.end())\\n                dp.push_back(arr[i]);\\n            else\\n                *lb = arr[i];\\n        }\\n        \\n        return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071501,
                "title": "c-short-easy-explanation-lis-o-nlogn",
                "content": "**Time Complexity: O(NlogN)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b){ // compare function for sorting\\n        if(a[0]==b[0]) return a[1] > b[1];\\n        return a[0] < b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n = env.size();\\n        sort(env.begin(),env.end(),comp); // sort by width in decreasing order\\n        vector<int> lis; // longest increasing subsequence\\n        for(int i=0;i<n;i++){ // for each envelope\\n            int ele = env[i][1]; // width of envelope i \\n            int index = lower_bound(lis.begin(),lis.end(),ele)-lis.begin(); // find the first element in lis that is greater than ele\\n            if(index>=lis.size()) lis.push_back(ele); // if no such element, add ele to lis\\n            else lis[index] = ele; // if there is such element, replace it with ele\\n        }\\n        return lis.size(); // return the size of lis\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b){ // compare function for sorting\\n        if(a[0]==b[0]) return a[1] > b[1];\\n        return a[0] < b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n = env.size();\\n        sort(env.begin(),env.end(),comp); // sort by width in decreasing order\\n        vector<int> lis; // longest increasing subsequence\\n        for(int i=0;i<n;i++){ // for each envelope\\n            int ele = env[i][1]; // width of envelope i \\n            int index = lower_bound(lis.begin(),lis.end(),ele)-lis.begin(); // find the first element in lis that is greater than ele\\n            if(index>=lis.size()) lis.push_back(ele); // if no such element, add ele to lis\\n            else lis[index] = ele; // if there is such element, replace it with ele\\n        }\\n        return lis.size(); // return the size of lis\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071370,
                "title": "o-n-logn-easy-to-understand-commented-lis-veriation-dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n    static bool cmp(vector<int> &a , vector<int> &b)\\n    {\\n        //if first are same then we will taje bigger one from them first so a[1] > b[1]\\n        if(a[0] == b[0]) return (a[1] > b[1]);\\n        \\n        //else simple sorting a[0]<b[0]\\n        return (a[0] < b[0]);\\n    }\\n\\t//simple first sort by 1st corrdinate and the apply LIS on second one\\n    int maxEnvelopes(vector<vector<int>>&mat) {\\n     \\n        sort(mat.begin() , mat.end() , cmp);\\n        \\n        vector<int> dp;\\n        \\n        for(auto curr : mat)\\n        {\\n            auto pointer = lower_bound(dp.begin() , dp.end() ,curr[1]) ;\\n            \\n            if(pointer == dp.end())\\n                dp.push_back(curr[1]);\\n            else\\n                *pointer = curr[1];\\n        }\\n        \\n        return dp.size();\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n    static bool cmp(vector<int> &a , vector<int> &b)\\n    {\\n        //if first are same then we will taje bigger one from them first so a[1] > b[1]\\n        if(a[0] == b[0]) return (a[1] > b[1]);\\n        \\n        //else simple sorting a[0]<b[0]\\n        return (a[0] < b[0]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1959339,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }\\n        return ans;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1899777,
                "title": "c-based-on-lis-no-tle-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& A,  vector<int>& B){\\n        if(A[0] == B[0]){\\n            return A[1] > B[1];\\n        } \\n        return A[0] < B[0];\\n    }\\n    \\n    static bool comp1( const vector<int>& A, const vector<int>& B){\\n        return A[1] < B[1];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums), comp);\\n        vector<vector<int>> ans;\\n        ans.push_back(nums[0]);\\n        for(int i = 1; i < n; i++){\\n            if(nums[i][0] > ans.back()[0] and nums[i][1] > ans.back()[1]){\\n                ans.push_back(nums[i]);\\n            }else{\\n                int idx = lower_bound(begin(ans), end(ans), nums[i], comp1) - ans.begin();\\n                ans[idx] = nums[i];\\n            }\\n        }\\n        \\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& A,  vector<int>& B){\\n        if(A[0] == B[0]){\\n            return A[1] > B[1];\\n        } \\n        return A[0] < B[0];\\n    }\\n    \\n    static bool comp1( const vector<int>& A, const vector<int>& B){\\n        return A[1] < B[1];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums), comp);\\n        vector<vector<int>> ans;\\n        ans.push_back(nums[0]);\\n        for(int i = 1; i < n; i++){\\n            if(nums[i][0] > ans.back()[0] and nums[i][1] > ans.back()[1]){\\n                ans.push_back(nums[i]);\\n            }else{\\n                int idx = lower_bound(begin(ans), end(ans), nums[i], comp1) - ans.begin();\\n                ans[idx] = nums[i];\\n            }\\n        }\\n        \\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899735,
                "title": "c-dynamic-programming-lis-binary-search-o-n-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b) {\\n        if(a[0] != b[0]) return a[0] < b[0];\\n        else return a[1] > b[1];\\n        \\n        return false;\\n    }\\n    int find_env(vector<vector<int>>& envelopes) {\\n        if(envelopes.empty()) return 0;\\n        \\n        sort(envelopes.begin(), envelopes.end(), compare);\\n        int count = 0;\\n        vector<int> v(envelopes.size(), 0);\\n        for(int i = 0; i < envelopes.size(); i++) {\\n            int start = 0; int end = count;\\n            while(start < end) {\\n                int mid = start + (end - start) / 2;\\n                if(v[mid] < envelopes[i][1]) start = mid + 1;\\n                else end = mid;\\n            }\\n            v[start] = envelopes[i][1];\\n            if(start == count) count++;\\n        }\\n        \\n        return count;\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        return find_env(envelopes);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>& a, vector<int>& b) {\\n        if(a[0] != b[0]) return a[0] < b[0];\\n        else return a[1] > b[1];\\n        \\n        return false;\\n    }\\n    int find_env(vector<vector<int>>& envelopes) {\\n        if(envelopes.empty()) return 0;\\n        \\n        sort(envelopes.begin(), envelopes.end(), compare);\\n        int count = 0;\\n        vector<int> v(envelopes.size(), 0);\\n        for(int i = 0; i < envelopes.size(); i++) {\\n            int start = 0; int end = count;\\n            while(start < end) {\\n                int mid = start + (end - start) / 2;\\n                if(v[mid] < envelopes[i][1]) start = mid + 1;\\n                else end = mid;\\n            }\\n            v[start] = envelopes[i][1];\\n            if(start == count) count++;\\n        }\\n        \\n        return count;\\n    }\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        return find_env(envelopes);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708113,
                "title": "fenwick-tree-dp-solution",
                "content": "We know that answer for an envelope [w,h] is always best answer till the envelope with height <h and width < w, thus we can use dp and to find the max till some height/width we can use fenwick tree\\nWe first sort the envelopes based on widths and we know all left envelopes have width less than current thus we dont need to care about widths, we care about only heights < current height, thus find best answer till height=current height -1 and update the dp table, here trick is if the widths are same for two consecutive envelopes (in sorted manner) we should not update our fenwick tree\\n```\\n#define MAX 10005\\nint BIT[MAX]={0};\\n\\nvoid update(int idx, int val){\\n    for(;idx<MAX;idx+=(-idx)&idx){\\n        BIT[idx]=max(BIT[idx],val);\\n    }\\n}\\n\\nint find(int idx){\\n    int ans=0;\\n    for(;idx>0;idx-=(-idx)&idx){\\n        ans=max(ans,BIT[idx]);\\n    }\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> adj[MAX];\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        memset(BIT,0,sizeof(BIT));\\n        int max_val =0;\\n        int n = envelopes.size();\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n        }\\n        // sort by width\\n        vector<pair<int,int> > v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({envelopes[i][0], envelopes[i][1]});\\n        }\\n        sort(v.begin(), v.end());\\n        // simple DP it  , we dont need to go to that again\\n        // just search for lower height\\'s max answer\\n        int last_w=v[0].first;\\n        int last_v = 0;\\n        int ans=0;\\n        vector<int> heights;\\n        unordered_map <int,int> dp;\\n        for(int i=0;i<n;i++){\\n            // find current widths and answer\\n            int w = v[i].first;\\n            int h = v[i].second;\\n\\t\\t\\t// check if current width is lesser than the last recorded\\n            if(last_w!=w){\\n\\t\\t\\t\\t// append heights width same widths\\n                for(auto height:heights){\\n                    update(height,dp[height]);\\n                }\\n                heights.clear();\\n            }\\n\\t\\t\\t//  find best answer till h-1 and update current dp\\n            dp[h]=find(h-1)+1;\\n            ans = max(ans,dp[h]);\\n            heights.push_back(h);\\n            last_w=w;\\n        }\\n        return ans;    \\n    }\\n};\\n```\\nComplexity is O(maxWidthLog(maxWidth))\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n#define MAX 10005\\nint BIT[MAX]={0};\\n\\nvoid update(int idx, int val){\\n    for(;idx<MAX;idx+=(-idx)&idx){\\n        BIT[idx]=max(BIT[idx],val);\\n    }\\n}\\n\\nint find(int idx){\\n    int ans=0;\\n    for(;idx>0;idx-=(-idx)&idx){\\n        ans=max(ans,BIT[idx]);\\n    }\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> adj[MAX];\\n    \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        memset(BIT,0,sizeof(BIT));\\n        int max_val =0;\\n        int n = envelopes.size();\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n        }\\n        // sort by width\\n        vector<pair<int,int> > v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({envelopes[i][0], envelopes[i][1]});\\n        }\\n        sort(v.begin(), v.end());\\n        // simple DP it  , we dont need to go to that again\\n        // just search for lower height\\'s max answer\\n        int last_w=v[0].first;\\n        int last_v = 0;\\n        int ans=0;\\n        vector<int> heights;\\n        unordered_map <int,int> dp;\\n        for(int i=0;i<n;i++){\\n            // find current widths and answer\\n            int w = v[i].first;\\n            int h = v[i].second;\\n\\t\\t\\t// check if current width is lesser than the last recorded\\n            if(last_w!=w){\\n\\t\\t\\t\\t// append heights width same widths\\n                for(auto height:heights){\\n                    update(height,dp[height]);\\n                }\\n                heights.clear();\\n            }\\n\\t\\t\\t//  find best answer till h-1 and update current dp\\n            dp[h]=find(h-1)+1;\\n            ans = max(ans,dp[h]);\\n            heights.push_back(h);\\n            last_w=w;\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674324,
                "title": "c-o-nlogn-and-o-n-2-approach",
                "content": "```\\n// This problem is application of LIS\\n\\n//O(N^2) solution\\nclass Solution\\n{\\npublic:\\n    int maxEnvelopes(vector<vector<int>> &envelopes)\\n    {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end());\\n        vector<int> dp(n + 1, 1);\\n        // LIS\\n        for (int i = 1; i < n; i++)\\n        {\\n            for (int j = 0; j <= i - 1; j++)\\n            {\\n                if ((envelopes[i][0] > envelopes[j][0]) && (envelopes[i][1] > envelopes[j][1]))\\n                {\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        int ans = *max_element(dp.begin(), dp.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n// O(N*LOGN)\\nclass Solution\\n{\\npublic:\\n    int maxEnvelopes(vector<vector<int>> &envelopes)\\n    {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int> &a, const vector<int> &b)\\n             {\\n                 if (a[0] < b[0])\\n                     return true;\\n                 if (a[0] == b[0])\\n                     return a[1] > b[1];\\n                 return false;\\n             });\\n        vector<int> lis;\\n        lis.push_back(envelopes[0][1]);\\n        for (int i = 1; i < n; i++)\\n        {\\n            int indx = lower_bound(lis.begin(), lis.end(), envelopes[i][1]) - lis.begin();\\n            if (indx == lis.size())\\n            {\\n                lis.push_back(envelopes[i][1]);\\n            }\\n            else\\n            {\\n                lis[indx] = envelopes[i][1];\\n            }\\n        }\\n        return lis.size();\\n    }\\n};\\n```\\n\\n```\\n//  other version of compartor\\nclass Solution\\n{\\npublic:\\n    bool static compare(const vector<int> &a, vector<int> &b)\\n    {\\n        if (a[0] < b[0])\\n        {\\n            return true;\\n        }\\n        if (a[0] == b[0])\\n        {\\n            return a[1] > b[1];\\n        }\\n        return false;\\n    }\\n    int maxEnvelopes(vector<vector<int>> &envelopes)\\n    {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end(), compare);\\n        vector<int> lis;\\n        lis.push_back(envelopes[0][1]);\\n        for (int i = 1; i < n; i++)\\n        {\\n            int indx = lower_bound(lis.begin(), lis.end(), envelopes[i][1]) - lis.begin();\\n            if (indx == lis.size())\\n            {\\n                lis.push_back(envelopes[i][1]);\\n            }\\n            else\\n            {\\n                lis[indx] = envelopes[i][1];\\n            }\\n        }\\n        return lis.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n// This problem is application of LIS\\n\\n//O(N^2) solution\\nclass Solution\\n{\\npublic:\\n    int maxEnvelopes(vector<vector<int>> &envelopes)\\n    {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end());\\n        vector<int> dp(n + 1, 1);\\n        // LIS\\n        for (int i = 1; i < n; i++)\\n        {\\n            for (int j = 0; j <= i - 1; j++)\\n            {\\n                if ((envelopes[i][0] > envelopes[j][0]) && (envelopes[i][1] > envelopes[j][1]))\\n                {\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        int ans = *max_element(dp.begin(), dp.end());\\n        return ans;\\n    }\\n};\\n```\n```\\n// O(N*LOGN)\\nclass Solution\\n{\\npublic:\\n    int maxEnvelopes(vector<vector<int>> &envelopes)\\n    {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int> &a, const vector<int> &b)\\n             {\\n                 if (a[0] < b[0])\\n                     return true;\\n                 if (a[0] == b[0])\\n                     return a[1] > b[1];\\n                 return false;\\n             });\\n        vector<int> lis;\\n        lis.push_back(envelopes[0][1]);\\n        for (int i = 1; i < n; i++)\\n        {\\n            int indx = lower_bound(lis.begin(), lis.end(), envelopes[i][1]) - lis.begin();\\n            if (indx == lis.size())\\n            {\\n                lis.push_back(envelopes[i][1]);\\n            }\\n            else\\n            {\\n                lis[indx] = envelopes[i][1];\\n            }\\n        }\\n        return lis.size();\\n    }\\n};\\n```\n```\\n//  other version of compartor\\nclass Solution\\n{\\npublic:\\n    bool static compare(const vector<int> &a, vector<int> &b)\\n    {\\n        if (a[0] < b[0])\\n        {\\n            return true;\\n        }\\n        if (a[0] == b[0])\\n        {\\n            return a[1] > b[1];\\n        }\\n        return false;\\n    }\\n    int maxEnvelopes(vector<vector<int>> &envelopes)\\n    {\\n        int n = envelopes.size();\\n        sort(envelopes.begin(), envelopes.end(), compare);\\n        vector<int> lis;\\n        lis.push_back(envelopes[0][1]);\\n        for (int i = 1; i < n; i++)\\n        {\\n            int indx = lower_bound(lis.begin(), lis.end(), envelopes[i][1]) - lis.begin();\\n            if (indx == lis.size())\\n            {\\n                lis.push_back(envelopes[i][1]);\\n            }\\n            else\\n            {\\n                lis[indx] = envelopes[i][1];\\n            }\\n        }\\n        return lis.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582082,
                "title": "russian-doll-3d-how-to-approach",
                "content": "\\nFrom the solution its easy to see how sorting across 1 dimension and finding the longest increasing sequence results into a solution in 2D,  Now how about a 3D envlope, with 3 dimesions l x b xh??\\n\\nHow to solve/approach ? Any help much appreciated!  \\n\\n```\\nshould we sort in 1 dimension and find LIS sets in dimension 2 and then do LIS on dimension 3 across all the sets ?? \\n\\n```",
                "solutionTags": [],
                "code": "```\\nshould we sort in 1 dimension and find LIS sets in dimension 2 and then do LIS on dimension 3 across all the sets ?? \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448880,
                "title": "javascript-lis-binary-search-faster-then-dp",
                "content": "```js\\nvar maxEnvelopes = function(envelopes) {\\n    var n = envelopes.length;\\n    \\n    // sort by width\\n    envelopes.sort((a,b)=>a[0] === b[0] ? b[1]-a[1] : a[0]-b[0]);\\n\\n    // lis\\n    var dp = [envelopes[0][1]];\\n    for(var i = 1; i<n; i++)\\n    {\\n        var target = envelopes[i][1];\\n        var l =0 ;\\n        var r = dp.length;\\n        while(l<r)\\n        {\\n            var mid = Math.floor((l+r)/2);\\n            if(dp[mid] < target)\\n            {\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                r= mid;\\n            }\\n        }\\n        if(l>=0)\\n        {\\n            dp[l] = target;\\n        }\\n    }\\n    return dp.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar maxEnvelopes = function(envelopes) {\\n    var n = envelopes.length;\\n    \\n    // sort by width\\n    envelopes.sort((a,b)=>a[0] === b[0] ? b[1]-a[1] : a[0]-b[0]);\\n\\n    // lis\\n    var dp = [envelopes[0][1]];\\n    for(var i = 1; i<n; i++)\\n    {\\n        var target = envelopes[i][1];\\n        var l =0 ;\\n        var r = dp.length;\\n        while(l<r)\\n        {\\n            var mid = Math.floor((l+r)/2);\\n            if(dp[mid] < target)\\n            {\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                r= mid;\\n            }\\n        }\\n        if(l>=0)\\n        {\\n            dp[l] = target;\\n        }\\n    }\\n    return dp.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1410015,
                "title": "c-nlogn-lis-beats-80-commented-code-easy-explanation",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    // compare returns when first element if pair is equal then it sorts in the decreasing order of the second element in the pair\\n    static bool compare(vector<int> a, vector<int> b) {\\n        if (a[0] == b[0])\\n            return a[1] > b[1];\\n        return a[0] < b[0];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n = env.size();\\n\\t\\t// initialize dp with zero size -> ans will be size of the all elements pushed\\n        vector<int> dp;\\n        sort(env.begin(), env.end(), compare);\\n\\t\\t// first element will always be in the dp as it is already sorted\\n        dp.push_back(env[0][1]);\\n        for(int i = 1; i < n; i++) {\\n            int cur = env[i][1];\\n\\t\\t\\t// returns an iterator pointing to the first element in the range [first, last) which has a value not less than val\\n            auto itr = lower_bound(dp.begin(), dp.end(), cur);\\n\\t\\t\\t// if all values are less than cur then its time to push the current inside dp\\n            if (itr == dp.end())\\n                dp.push_back(cur);\\n\\t\\t\\t// else if it is greater then replace the value already present at itr index with cur as cur is lesser\\n            else if(*itr > cur)\\n                dp[itr - dp.begin()] = cur;\\n        }\\n\\t\\t// total size of dp will be the ans as you only inserted those element which are part of LIS\\n        return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // compare returns when first element if pair is equal then it sorts in the decreasing order of the second element in the pair\\n    static bool compare(vector<int> a, vector<int> b) {\\n        if (a[0] == b[0])\\n            return a[1] > b[1];\\n        return a[0] < b[0];\\n    }\\n    \\n    int maxEnvelopes(vector<vector<int>>& env) {\\n        int n = env.size();\\n\\t\\t// initialize dp with zero size -> ans will be size of the all elements pushed\\n        vector<int> dp;\\n        sort(env.begin(), env.end(), compare);\\n\\t\\t// first element will always be in the dp as it is already sorted\\n        dp.push_back(env[0][1]);\\n        for(int i = 1; i < n; i++) {\\n            int cur = env[i][1];\\n\\t\\t\\t// returns an iterator pointing to the first element in the range [first, last) which has a value not less than val\\n            auto itr = lower_bound(dp.begin(), dp.end(), cur);\\n\\t\\t\\t// if all values are less than cur then its time to push the current inside dp\\n            if (itr == dp.end())\\n                dp.push_back(cur);\\n\\t\\t\\t// else if it is greater then replace the value already present at itr index with cur as cur is lesser\\n            else if(*itr > cur)\\n                dp[itr - dp.begin()] = cur;\\n        }\\n\\t\\t// total size of dp will be the ans as you only inserted those element which are part of LIS\\n        return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402631,
                "title": "c-pair-lis",
                "content": "```\\n\\n```public:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        long long int i,j,f=0,m=1;\\n        vector<pair<int,int>>v;\\n        for(i=0;i<envelopes.size();i++)\\n        {\\n            v.push_back({envelopes[i][0],envelopes[i][1]});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>res(v.size(),1);\\n        for(i=1;i<v.size();i++)\\n        {\\n           for(j=0;j<i;j++)\\n           {\\n               if(v[j].first<v[i].first&&v[j].second<v[i].second)\\n               {\\n                   res[i]=max(res[i],res[j]+1);\\n               }\\n           }\\n            if(res[i]>m)\\n            {\\n                m=res[i];\\n            }\\n        }\\n        return m;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135356,
                "title": "ruby-o-nlogn",
                "content": "```\\n# @param {Integer[][]} envelopes\\n# @return {Integer}\\n\\ndef max_envelopes(envelopes)\\n  a = []\\n  \\n  envelopes.sort_by{|e| [e[0], -e[1]]}.each {|e|\\n    j = a.bsearch_index{|x| x >= e[1]}\\n    a[j || a.count] = e[1]\\n  }\\n  \\n  a.count\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} envelopes\\n# @return {Integer}\\n\\ndef max_envelopes(envelopes)\\n  a = []\\n  \\n  envelopes.sort_by{|e| [e[0], -e[1]]}.each {|e|\\n    j = a.bsearch_index{|x| x >= e[1]}\\n    a[j || a.count] = e[1]\\n  }\\n  \\n  a.count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1135162,
                "title": "top-down-dp-java",
                "content": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        \\n        if(envelopes.length <= 1){\\n            return envelopes.length;\\n        }\\n        \\n        Arrays.sort(envelopes, (int[] r1, int [] r2) -> {\\n            if(Integer.compare(r1[0],r2[0]) == 0){\\n                return Integer.compare(r1[1],r2[1]);\\n            }\\n            return Integer.compare(r1[0],r2[0]);\\n        });\\n        \\n        cache = new Integer[envelopes.length + 1][envelopes.length + 1];\\n        \\n        return dp(envelopes, 0, -1);\\n    }\\n    \\n    Integer[][] cache;\\n    \\n    int dp(int[][] envelopes, int i, int prev){\\n        if(i >= envelopes.length){\\n            return 0;\\n        }\\n        \\n        if(cache[i][prev + 1] != null){\\n            return cache[i][prev + 1];\\n        }\\n        \\n        int take = 0;\\n        \\n        //can take current\\n        if(prev == -1 || (envelopes[i][0] > envelopes[prev][0] && envelopes[i][1] > envelopes[prev][1])){\\n            take = 1 + dp(envelopes, i + 1, i);\\n        }\\n        \\n        int notTake = dp(envelopes, i + 1, prev);\\n        \\n        int max = Math.max(take, notTake);\\n        \\n        cache[i][prev + 1] = max;\\n        \\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        \\n        if(envelopes.length <= 1){\\n            return envelopes.length;\\n        }\\n        \\n        Arrays.sort(envelopes, (int[] r1, int [] r2) -> {\\n            if(Integer.compare(r1[0],r2[0]) == 0){\\n                return Integer.compare(r1[1],r2[1]);\\n            }\\n            return Integer.compare(r1[0],r2[0]);\\n        });\\n        \\n        cache = new Integer[envelopes.length + 1][envelopes.length + 1];\\n        \\n        return dp(envelopes, 0, -1);\\n    }\\n    \\n    Integer[][] cache;\\n    \\n    int dp(int[][] envelopes, int i, int prev){\\n        if(i >= envelopes.length){\\n            return 0;\\n        }\\n        \\n        if(cache[i][prev + 1] != null){\\n            return cache[i][prev + 1];\\n        }\\n        \\n        int take = 0;\\n        \\n        //can take current\\n        if(prev == -1 || (envelopes[i][0] > envelopes[prev][0] && envelopes[i][1] > envelopes[prev][1])){\\n            take = 1 + dp(envelopes, i + 1, i);\\n        }\\n        \\n        int notTake = dp(envelopes, i + 1, prev);\\n        \\n        int max = Math.max(take, notTake);\\n        \\n        cache[i][prev + 1] = max;\\n        \\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134924,
                "title": "the-art-of-dynamic-programming",
                "content": "**O(N) solutions: AC**\\n\\nUse [\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master): we can **sort** the input array of envelopes `A` by **increasing width  and decreasing height** to perform a linear scan of `A` to track the heights of dolls we can \"wrap-around\" existing dolls within a monotonically increasing array `dp`.  Then return the length of the portion of `dp` which has been filled with doll heights.\\n\\n**Question:** why is it important to sort by increasing x-axis (width) but decreasing y-axis (height)?\\n\\n**Answer:** otherwise if we incorrectly sort by increasing x-axis (width) and increasing y-axis (height), this results in an incorrect solution:\\n\\n```\\nWrong Answer\\nDetails \\n\\nInput\\n[[4,5],[4,6],[6,7],[2,3],[1,1]]\\n\\nOutput\\n5\\n\\nExpected\\n4\\n\\nincorrectly sorted(A) = [1,1] [2,3] [4,5] [4,6] [6,7] ie. 4,5 is incorrectly inserted into 4,6 as dp = [1,3,5,6], and then dp will be [1,3,5,6,7] with len = 5 when the last envelop is processed\\n  correctly sorted(A) = [1,1] [2,3] [4,6] [4,5] [6,7] which results in dp = [1,3,6] when [4,6] is processed before [4,5], then\\n                                     ^^^^^^^^^^                        dp = [1,3,5] when [4,5] is processed, the 5 replaces the 6 within dp[2], and then dp will be [1,3,5,7] with len = 4 when the last envelop is processed\\n```\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxEnvelopes(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var dp = IntArray(N) { INF }\\n        for ((x, y) in A.sortedWith(Comparator{ a: IntArray, b: IntArray -> if (a[0] == b[0]) b[1].compareTo(a[1]) else a[0].compareTo(b[0]) })) {\\n            var i = dp.binarySearch(y)\\n            if (i < 0)\\n                i = -(i + 1)\\n            dp[i] = y\\n        }\\n        var i = dp.indexOf(INF) // \\uD83D\\uDCA9 Kotlin\\'s binarySearch() does not always return the first index of the target value\\n        return if (i != -1) i else N\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxEnvelopes = A => {\\n    let N = A.length;\\n    let dp = Array(N).fill(Infinity);\\n    A.sort((a, b) => a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n    for (let [x, y] of A) {\\n        let i = _.sortedIndex(dp, y);\\n        dp[i] = y;\\n    }\\n    return _.sortedIndex(dp, Infinity);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxEnvelopes(self, A: List[List[int]], INF = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        dp = [INF] * N\\n        for x, y in sorted(A, key = cmp_to_key(lambda a, b: b[1] - a[1] if a[0] == b[0] else a[0] - b[0])):\\n            i = bisect_left(dp, y)\\n            dp[i] = y\\n        return bisect_left(dp, INF)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxEnvelopes(VVI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        sort(A.begin(), A.end(), [](auto& a, auto& b) { return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0]; });\\n        VI dp(N, INF);\\n        for (auto& pair: A) {\\n            auto [x, y] = tie(pair[0], pair[1]);\\n            auto i = distance(dp.begin(), lower_bound(dp.begin(), dp.end(), y));\\n            dp[i] = y;\\n        }\\n        return distance(dp.begin(), lower_bound(dp.begin(), dp.end(), INF));\\n    }\\n};\\n```\\n\\n---\\n\\n**O(N<sup>2</sup>) solutions: TLE**\\n\\nUse [\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master): after sorting the input array of envelopes `A` in monotonically non-decreasing order, this problem is abstracted as the [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/385203/Javascript-and-C%2B%2B-solutions), ie. we are attempting to find the longest subsequence of envelopes which fit within eachother similar to [Matryoshka dolls](https://en.wikipedia.org/wiki/Matryoshka_doll).  Let `dp[j]` denote the longest increasing subsequence ending at `j` inclusive.  Initally all `dp[j]`<sup>th</sup> values are set to `1` since each `j`<sup>th</sup> element is at least a subsequence of length `1` (itself).  We explore all `1..N - 1` inclusive possibilities for `j` and return the maximal `j`<sup>th</sup> value based upon each previous optimal `i`<sup>th</sup> value where `i = 0..j - 1 < j`, ie. if the `j`<sup>th</sup> element can be appended onto a previous optimal subsequence ending at `i`, then we can formulate a new optimal subsequence of length `dp[i] + 1` (the previous optimal subsequence ending at `i` plus `1` (for the `j`<sup>th</sup> element which was just appended).\\n\\n* Note: the Python3 and C++ solutions result in TLE.  However, the Kotlin and Javascript solutions are AC \\xAF\\\\\\\\_(\\u30C4)_/\\xAF\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxEnvelopes(A: Array<IntArray>): Int {\\n        A.sortWith(Comparator{ a: IntArray, b: IntArray -> if (a[0] == b[0]) a[1].compareTo(b[1]) else a[0].compareTo(b[0]) })\\n        var ok = { a: IntArray, b: IntArray -> a[0] < b[0] && a[1] < b[1] }\\n        var N = A.size\\n        var dp = IntArray(N) { 1 }\\n        for (j in 1 until N)\\n            for (i in 0 until j)\\n                if (ok(A[i], A[j]))\\n                    dp[j] = Math.max(dp[j], 1 + dp[i])\\n        return dp.max()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxEnvelopes = A => {\\n    A.sort((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    let N = A.length;\\n    let dp = Array(N).fill(1);\\n    let ok = (a, b) => a[0] < b[0] && a[1] < b[1];\\n    for (let j = 1; j < N; ++j)\\n        for (let i = 0; i < j; ++i)\\n            if (ok(A[i], A[j]))\\n                dp[j] = Math.max(dp[j], 1 + dp[i]);\\n    return Math.max(...dp);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxEnvelopes(self, A: List[List[int]]) -> int:\\n        A.sort()\\n        N = len(A)\\n        dp = [1] * N\\n        ok = lambda a, b: a[0] < b[0] and a[1] < b[1]\\n        for j in range(1, N):\\n            for i in range(j):\\n                if ok(A[i], A[j]):\\n                    dp[j] = max(dp[j], 1 + dp[i])\\n        return max(dp)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxEnvelopes(VVI& A) {\\n        sort(A.begin(), A.end(), [](auto& a, auto& b) { return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0]; });\\n        auto ok = [](auto a, auto b) { return a[0] < b[0] && a[1] < b[1]; };\\n        auto N = A.size();\\n        VI dp(N, 1);\\n        for (auto j{ 1 }; j < N; ++j)\\n            for (auto i{ 0 }; i < j; ++i)\\n                if (ok(A[i], A[j]))\\n                    dp[j] = max(dp[j], 1 + dp[i]);\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nWrong Answer\\nDetails \\n\\nInput\\n[[4,5],[4,6],[6,7],[2,3],[1,1]]\\n\\nOutput\\n5\\n\\nExpected\\n4\\n\\nincorrectly sorted(A) = [1,1] [2,3] [4,5] [4,6] [6,7] ie. 4,5 is incorrectly inserted into 4,6 as dp = [1,3,5,6], and then dp will be [1,3,5,6,7] with len = 5 when the last envelop is processed\\n  correctly sorted(A) = [1,1] [2,3] [4,6] [4,5] [6,7] which results in dp = [1,3,6] when [4,6] is processed before [4,5], then\\n                                     ^^^^^^^^^^                        dp = [1,3,5] when [4,5] is processed, the 5 replaces the 6 within dp[2], and then dp will be [1,3,5,7] with len = 4 when the last envelop is processed\\n```\n```\\nclass Solution {\\n    fun maxEnvelopes(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var dp = IntArray(N) { INF }\\n        for ((x, y) in A.sortedWith(Comparator{ a: IntArray, b: IntArray -> if (a[0] == b[0]) b[1].compareTo(a[1]) else a[0].compareTo(b[0]) })) {\\n            var i = dp.binarySearch(y)\\n            if (i < 0)\\n                i = -(i + 1)\\n            dp[i] = y\\n        }\\n        var i = dp.indexOf(INF) // \\uD83D\\uDCA9 Kotlin\\'s binarySearch() does not always return the first index of the target value\\n        return if (i != -1) i else N\\n    }\\n}\\n```\n```\\nlet maxEnvelopes = A => {\\n    let N = A.length;\\n    let dp = Array(N).fill(Infinity);\\n    A.sort((a, b) => a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n    for (let [x, y] of A) {\\n        let i = _.sortedIndex(dp, y);\\n        dp[i] = y;\\n    }\\n    return _.sortedIndex(dp, Infinity);\\n};\\n```\n```\\nclass Solution:\\n    def maxEnvelopes(self, A: List[List[int]], INF = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        dp = [INF] * N\\n        for x, y in sorted(A, key = cmp_to_key(lambda a, b: b[1] - a[1] if a[0] == b[0] else a[0] - b[0])):\\n            i = bisect_left(dp, y)\\n            dp[i] = y\\n        return bisect_left(dp, INF)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxEnvelopes(VVI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        sort(A.begin(), A.end(), [](auto& a, auto& b) { return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0]; });\\n        VI dp(N, INF);\\n        for (auto& pair: A) {\\n            auto [x, y] = tie(pair[0], pair[1]);\\n            auto i = distance(dp.begin(), lower_bound(dp.begin(), dp.end(), y));\\n            dp[i] = y;\\n        }\\n        return distance(dp.begin(), lower_bound(dp.begin(), dp.end(), INF));\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun maxEnvelopes(A: Array<IntArray>): Int {\\n        A.sortWith(Comparator{ a: IntArray, b: IntArray -> if (a[0] == b[0]) a[1].compareTo(b[1]) else a[0].compareTo(b[0]) })\\n        var ok = { a: IntArray, b: IntArray -> a[0] < b[0] && a[1] < b[1] }\\n        var N = A.size\\n        var dp = IntArray(N) { 1 }\\n        for (j in 1 until N)\\n            for (i in 0 until j)\\n                if (ok(A[i], A[j]))\\n                    dp[j] = Math.max(dp[j], 1 + dp[i])\\n        return dp.max()!!\\n    }\\n}\\n```\n```\\nlet maxEnvelopes = A => {\\n    A.sort((a, b) => a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    let N = A.length;\\n    let dp = Array(N).fill(1);\\n    let ok = (a, b) => a[0] < b[0] && a[1] < b[1];\\n    for (let j = 1; j < N; ++j)\\n        for (let i = 0; i < j; ++i)\\n            if (ok(A[i], A[j]))\\n                dp[j] = Math.max(dp[j], 1 + dp[i]);\\n    return Math.max(...dp);\\n};\\n```\n```\\nclass Solution:\\n    def maxEnvelopes(self, A: List[List[int]]) -> int:\\n        A.sort()\\n        N = len(A)\\n        dp = [1] * N\\n        ok = lambda a, b: a[0] < b[0] and a[1] < b[1]\\n        for j in range(1, N):\\n            for i in range(j):\\n                if ok(A[i], A[j]):\\n                    dp[j] = max(dp[j], 1 + dp[i])\\n        return max(dp)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxEnvelopes(VVI& A) {\\n        sort(A.begin(), A.end(), [](auto& a, auto& b) { return a[0] == b[0] ? a[1] < b[1] : a[0] < b[0]; });\\n        auto ok = [](auto a, auto b) { return a[0] < b[0] && a[1] < b[1]; };\\n        auto N = A.size();\\n        VI dp(N, 1);\\n        for (auto j{ 1 }; j < N; ++j)\\n            for (auto i{ 0 }; i < j; ++i)\\n                if (ok(A[i], A[j]))\\n                    dp[j] = max(dp[j], 1 + dp[i]);\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134512,
                "title": "rust-4ms-o-n-logn",
                "content": "```\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn max_envelopes(envs: Vec<Vec<i32>>) -> i32 {\\n        let mut envs: Vec<_> = envs.iter().map(|e| (e[0], Reverse(e[1]))).collect();\\n        envs.sort_unstable();\\n        let mut max_dp = Vec::new();\\n        for (_, Reverse(h)) in envs {\\n            let i = max_dp.binary_search(&h).unwrap_or_else(|i| i);\\n            if i < max_dp.len() {\\n                max_dp[i] = h;\\n            } else {\\n                max_dp.push(h);\\n            }\\n        }\\n        \\n        max_dp.len() as _\\n    }\\n}\\n```\\n\\n---\\n\\nWe can alternatively shorten the above using `BTreeSet`s.\\nThis approach is _slightly_ less performant (~8ms runtime):\\n\\n```\\nuse std::{cmp::Reverse, collections::BTreeSet};\\n\\nimpl Solution {\\n    pub fn max_envelopes(envs: Vec<Vec<i32>>) -> i32 {\\n        let mut envs: BTreeSet<_> = envs.iter().map(|e| (e[0], Reverse(e[1]))).collect();\\n        let mut max_dp = BTreeSet::new();\\n        for (_, Reverse(h)) in envs {\\n            if let Some(&h) = max_dp.range(h..).next() {\\n                max_dp.remove(&h);\\n            }\\n            max_dp.insert(h);\\n        }\\n\\n        max_dp.len() as _\\n    }\\n}\\n```\\n\\nOne thing to note about the above is that we abuse `BTreeSet`\\'s sorted iteration order to sort `envs`.\\nThis obviously isn\\'t as efficient as `Vec::sort_unstable()` like the first approach, but it saves us a line (and also dedupes!) :)\\n\\nAlso, if you _really_ want to be weird, you can get rid of the `if let` in the `for` loop and just use:\\n\\n```\\nmax_dp.remove(&max_dp.range(h..).next().copied().unwrap_or(0));\\n```\\n\\nWe can do this as we know from the problem\\'s input constraints that `h` is always `> 0`, so `remove(0)` can be used as a kind of no-op.",
                "solutionTags": [
                    "Rust",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn max_envelopes(envs: Vec<Vec<i32>>) -> i32 {\\n        let mut envs: Vec<_> = envs.iter().map(|e| (e[0], Reverse(e[1]))).collect();\\n        envs.sort_unstable();\\n        let mut max_dp = Vec::new();\\n        for (_, Reverse(h)) in envs {\\n            let i = max_dp.binary_search(&h).unwrap_or_else(|i| i);\\n            if i < max_dp.len() {\\n                max_dp[i] = h;\\n            } else {\\n                max_dp.push(h);\\n            }\\n        }\\n        \\n        max_dp.len() as _\\n    }\\n}\\n```\n```\\nuse std::{cmp::Reverse, collections::BTreeSet};\\n\\nimpl Solution {\\n    pub fn max_envelopes(envs: Vec<Vec<i32>>) -> i32 {\\n        let mut envs: BTreeSet<_> = envs.iter().map(|e| (e[0], Reverse(e[1]))).collect();\\n        let mut max_dp = BTreeSet::new();\\n        for (_, Reverse(h)) in envs {\\n            if let Some(&h) = max_dp.range(h..).next() {\\n                max_dp.remove(&h);\\n            }\\n            max_dp.insert(h);\\n        }\\n\\n        max_dp.len() as _\\n    }\\n}\\n```\n```\\nmax_dp.remove(&max_dp.range(h..).next().copied().unwrap_or(0));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1134326,
                "title": "java-lis-by-height",
                "content": "Sort the envelopes in ascending order by width, resolving collisions by height in descending order.\\nRun [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) on the heights.\\n\\nTime complexity: `O(N log N)`.\\nSpace complexity: `O(N)`.\\n\\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> {\\n            int cmp = Integer.compare(a[0], b[0]);\\n            return cmp != 0 ? cmp : -Integer.compare(a[1], b[1]);\\n        });\\n        \\n        int len = 0;\\n        int[] dp = new int[envelopes.length];\\n        for (int[] e : envelopes) {\\n            int pos = Arrays.binarySearch(dp, 0, len, e[1]);\\n            if (pos < 0) {\\n                pos = -pos - 1;\\n            }\\n            dp[pos] = e[1];\\n            if (pos == len) {\\n                len++;\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a, b) -> {\\n            int cmp = Integer.compare(a[0], b[0]);\\n            return cmp != 0 ? cmp : -Integer.compare(a[1], b[1]);\\n        });\\n        \\n        int len = 0;\\n        int[] dp = new int[envelopes.length];\\n        for (int[] e : envelopes) {\\n            int pos = Arrays.binarySearch(dp, 0, len, e[1]);\\n            if (pos < 0) {\\n                pos = -pos - 1;\\n            }\\n            dp[pos] = e[1];\\n            if (pos == len) {\\n                len++;\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126907,
                "title": "c-o-nlogn-one-dimension-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int> &a, const vector<int> &b) {\\n            if (a[0] != b[0]) return a[0] < b[0]; return (a[1] >= b[1]);\\n        });\\n        for (auto &e : envelopes) {\\n            if (!dp.size() || e[1] > dp[dp.size() - 1]) dp.push_back(e[1]);\\n            else dp[lower_bound(dp.begin(), dp.end(), e[1]) - dp.begin()] = e[1];\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(), envelopes.end(), [](const vector<int> &a, const vector<int> &b) {\\n            if (a[0] != b[0]) return a[0] < b[0]; return (a[1] >= b[1]);\\n        });\\n        for (auto &e : envelopes) {\\n            if (!dp.size() || e[1] > dp[dp.size() - 1]) dp.push_back(e[1]);\\n            else dp[lower_bound(dp.begin(), dp.end(), e[1]) - dp.begin()] = e[1];\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120408,
                "title": "java-o-nlogn-lis-binary-search",
                "content": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a,b) -> { \\n            int diff1 = a[0] - b[0];\\n            if(diff1!=0)\\n                return diff1;\\n                       \\n            return b[1] - a[1];\\n        });\\n        \\n        return lis(envelopes);  \\n    }\\n    \\n    private int lis(int[][] nums){\\n        int n = nums.length;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i = 0; i<n; i++){\\n            if(list.isEmpty() || list.get(list.size()-1) < nums[i][1])\\n                list.add(nums[i][1]);\\n            else{\\n                int idx = findCeilIndex(list, nums[i][1]);\\n                if(idx!=-1)\\n                list.set(idx, nums[i][1]);\\n            }\\n        }\\n        \\n        return list.size();\\n    }\\n    //returns index of smallest element >= x\\n    private int findCeilIndex(List<Integer> list, int x){\\n            int l = 0, h = list.size()-1;\\n                int idx = -1;\\n                while(l<=h){\\n                    int mid = l + (h-l)/2;\\n                    if(list.get(mid) == x){\\n                        idx = mid;\\n                        break;\\n                    }\\n                    if(list.get(mid) > x){\\n                        idx = mid;\\n                        h = mid-1;\\n                    } else\\n                        l = mid+1;\\n                }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes, (a,b) -> { \\n            int diff1 = a[0] - b[0];\\n            if(diff1!=0)\\n                return diff1;\\n                       \\n            return b[1] - a[1];\\n        });\\n        \\n        return lis(envelopes);  \\n    }\\n    \\n    private int lis(int[][] nums){\\n        int n = nums.length;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i = 0; i<n; i++){\\n            if(list.isEmpty() || list.get(list.size()-1) < nums[i][1])\\n                list.add(nums[i][1]);\\n            else{\\n                int idx = findCeilIndex(list, nums[i][1]);\\n                if(idx!=-1)\\n                list.set(idx, nums[i][1]);\\n            }\\n        }\\n        \\n        return list.size();\\n    }\\n    //returns index of smallest element >= x\\n    private int findCeilIndex(List<Integer> list, int x){\\n            int l = 0, h = list.size()-1;\\n                int idx = -1;\\n                while(l<=h){\\n                    int mid = l + (h-l)/2;\\n                    if(list.get(mid) == x){\\n                        idx = mid;\\n                        break;\\n                    }\\n                    if(list.get(mid) > x){\\n                        idx = mid;\\n                        h = mid-1;\\n                    } else\\n                        l = mid+1;\\n                }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038923,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     static bool cmp(vector<int>&a,vector<int>&b)\\n     {\\n         return a[0]==b[0]?a[1]<b[1]:a[0]<b[0];\\n     }\\n    int maxEnvelopes(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end(),cmp);\\n        vector<int>dp(n,1);\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i][1]>nums[j][1]&&nums[i][0]>nums[j][0]&&dp[i]<dp[j]+1)\\n                {\\n                    dp[i]=dp[j]+1;\\n                }\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     static bool cmp(vector<int>&a,vector<int>&b)\\n     {\\n         return a[0]==b[0]?a[1]<b[1]:a[0]<b[0];\\n     }\\n    int maxEnvelopes(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end(),cmp);\\n        vector<int>dp(n,1);\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i][1]>nums[j][1]&&nums[i][0]>nums[j][0]&&dp[i]<dp[j]+1)\\n                {\\n                    dp[i]=dp[j]+1;\\n                }\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965421,
                "title": "java-short-and-crisp-o-n-2-o-n-log-n-with-explanation",
                "content": "**Dynamic Programming:**\\n```\\npublic int maxEnvelopes(int[][] envelopes) {\\n        int max=1,n=envelopes.length;\\n        if(n<=1) return n;\\n        Arrays.sort(envelopes,(a,b)->{\\n            if(a[0]==b[0]) return b[1]-a[1];\\n            else return a[0]-b[0];\\n        });\\n        int[] dp=new int[n];\\n        Arrays.fill(dp,1);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(envelopes[j][0]<envelopes[i][0] && envelopes[j][1]<envelopes[i][1] \\n                  &&\\n                    dp[j]+1>dp[i]\\n                  )\\n                    dp[i]=1+dp[j];\\n            }\\n            max=Math.max(max,dp[i]);\\n        }\\n        return max;\\n```\\n**Binary Search :**\\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n=envelopes.length,len=1;\\n        if(n<=1) return n;\\n        Arrays.sort(envelopes,(a,b)->{\\n            if(a[0]==b[0]) return b[1]-a[1];\\n            else return a[0]-b[0];\\n        });\\n         int[][] sorted=new int[n][2];sorted[0]=envelopes[0];\\n        for(int[] arr : envelopes){\\n            int  index=insertion_position(sorted,arr,0,len-1);\\n            sorted[index]=arr;\\n            if(len==index ) len++;    \\n        }\\n       return len;\\n    }\\n    private int insertion_position(int[][] input,int[] arr,int st,int end){\\n       if(input[end][0]<arr[0] && input[end][1]<arr[1]) return end+1;\\n        while(st<=end){\\n            int mid=st+(end-st)/2;\\n            if(input[mid][1]>arr[1]) end=mid-1;\\n            else if(input[mid][1]<arr[1])  st=mid+1;\\n            else return mid;\\n        }\\n        return st;\\n    }\\n}\\n```\\n***Here we sort array as ascending order of width, and if width is same then sort in descending order of height.***\\nLets assume that there are many envelops with same height, then it is better to choose bigger envelop first as it has better chance to fit the LIS.\\n**Ex:** [1,1] [2,2] [3,3] [4,3] [4,4].\\nHere if sort in ascending order of width and height, then it would result in LIS od [1,1] [2,2] [4,3]. But if we sort in descending order of height if width is same then, it would result in [1,1] [2,2] [3,3] [4,4].\\nEx: [1,1] [2,2] [3,3] [4,5] [4,4] [5,5]\\n[4,5] has larger area than [3,3] so insert [4,5] at end.\\n[4,4] is not larger than [4,5]. So insert [4,4] at its ceil position i.e., at [4,5] beacuse it has better chance in future to form a LIS.\\n\\nBy sorting in descending order if width are same, what we are essentially doing is by wrapping smaller envelopes with largest evelope then trying to check if it is possible to get LIS of same length with evelops with same width and samller heights, so that in future we get bigger LIS .",
                "solutionTags": [],
                "code": "```\\npublic int maxEnvelopes(int[][] envelopes) {\\n        int max=1,n=envelopes.length;\\n        if(n<=1) return n;\\n        Arrays.sort(envelopes,(a,b)->{\\n            if(a[0]==b[0]) return b[1]-a[1];\\n            else return a[0]-b[0];\\n        });\\n        int[] dp=new int[n];\\n        Arrays.fill(dp,1);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(envelopes[j][0]<envelopes[i][0] && envelopes[j][1]<envelopes[i][1] \\n                  &&\\n                    dp[j]+1>dp[i]\\n                  )\\n                    dp[i]=1+dp[j];\\n            }\\n            max=Math.max(max,dp[i]);\\n        }\\n        return max;\\n```\n```\\nclass Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        int n=envelopes.length,len=1;\\n        if(n<=1) return n;\\n        Arrays.sort(envelopes,(a,b)->{\\n            if(a[0]==b[0]) return b[1]-a[1];\\n            else return a[0]-b[0];\\n        });\\n         int[][] sorted=new int[n][2];sorted[0]=envelopes[0];\\n        for(int[] arr : envelopes){\\n            int  index=insertion_position(sorted,arr,0,len-1);\\n            sorted[index]=arr;\\n            if(len==index ) len++;    \\n        }\\n       return len;\\n    }\\n    private int insertion_position(int[][] input,int[] arr,int st,int end){\\n       if(input[end][0]<arr[0] && input[end][1]<arr[1]) return end+1;\\n        while(st<=end){\\n            int mid=st+(end-st)/2;\\n            if(input[mid][1]>arr[1]) end=mid-1;\\n            else if(input[mid][1]<arr[1])  st=mid+1;\\n            else return mid;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944051,
                "title": "c-lower-bound-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maxEnvelopes(vector<vector<int>>& e) {\\n        int n=e.size();\\n        \\n        sort(e.begin(),e.end(),[](vector<int>& a,vector<int>& b){\\n           \\n            if(a[1]==b[1])\\n            {\\n                return a[0]<b[0];\\n            }\\n            \\n            return a[1]>b[1];\\n            \\n        });\\n        \\n        \\n        // sorting on height then LIS on weight;\\n        // and lis should be using the binary search otherwsie it will\\n        // be similar to O(n^2)\\n        // lis on 0th index of e\\n        \\n        vector<int> dp;\\n        for (int i = n-1; i >=0; i--) \\n        {\\n            auto itr = lower_bound(dp.begin(), dp.end(), e[i][0]);\\n            \\n            if (itr == dp.end()) {\\n                dp.push_back(e[i][0]);\\n            } else {\\n                \\n                \\n                // the index dosent matters at all with respect to the length\\n                // of the subsequences...\\n                // these dosent matter since the new element gets added to the lower bound and hence will\\n                // will increase it..\\n                \\n                *itr = e[i][0];\\n            }\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxEnvelopes(vector<vector<int>>& e) {\\n        int n=e.size();\\n        \\n        sort(e.begin(),e.end(),[](vector<int>& a,vector<int>& b){\\n           \\n            if(a[1]==b[1])\\n            {\\n                return a[0]<b[0];\\n            }\\n            \\n            return a[1]>b[1];\\n            \\n        });\\n        \\n        \\n        // sorting on height then LIS on weight;\\n        // and lis should be using the binary search otherwsie it will\\n        // be similar to O(n^2)\\n        // lis on 0th index of e\\n        \\n        vector<int> dp;\\n        for (int i = n-1; i >=0; i--) \\n        {\\n            auto itr = lower_bound(dp.begin(), dp.end(), e[i][0]);\\n            \\n            if (itr == dp.end()) {\\n                dp.push_back(e[i][0]);\\n            } else {\\n                \\n                \\n                // the index dosent matters at all with respect to the length\\n                // of the subsequences...\\n                // these dosent matter since the new element gets added to the lower bound and hence will\\n                // will increase it..\\n                \\n                *itr = e[i][0];\\n            }\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778932,
                "title": "python-10-line-o-nlogn-binary-search-smallest-tail-of-increasing-subsequences",
                "content": "From the idea of [question 300 (longest increasing subsequence)](https://leetcode.com/problems/longest-increasing-subsequence/)\\n- the envelops should be sorted by  increasing width and decreasing height,\\n- then extract only the height from the original array. \\n- thus, it can be garanteed that a former envelope with lower height can always be put into a later envelope with larger height.\\n```\\nclass Solution:\\n    def maxEnvelopes(self, A: List[List[int]]) -> int:\\n        A.sort(key=lambda x: (x[0], -x[1]))\\n        tails = [inf] * len(A)\\n        size = 0\\n        for w in map(lambda x: x[1], A):\\n            i = bisect_left(tails, w)\\n            tails[i] = w\\n            size = max(i + 1, size)\\n        return size\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxEnvelopes(self, A: List[List[int]]) -> int:\\n        A.sort(key=lambda x: (x[0], -x[1]))\\n        tails = [inf] * len(A)\\n        size = 0\\n        for w in map(lambda x: x[1], A):\\n            i = bisect_left(tails, w)\\n            tails[i] = w\\n            size = max(i + 1, size)\\n        return size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688164,
                "title": "simple-n-2-solution-dynamic-programming-and-recursion",
                "content": "```\\nclass Solution {\\n  public int maxEnvelopes(int[][] envelopes) {\\n    int n = envelopes.length;\\n\\t// Sort the envelopes\\n    Arrays.sort(envelopes, (e1, e2) -> {\\n      if (e1[0] < e2[0]) return -1; // e1 first if smaller width\\n      if (e1[0] > e2[0]) return 1;  // e1 second if bigger width\\n      if (e1[1] < e2[1]) return -1; // e1 first if smaller height\\n      if (e1[1] > e2[1]) return 1; // e1 second if bigger height\\n      return 0; // preserve ordering if equal width and height\\n    });\\n\\n\\t// idea is to have an auxillary array where dp[i] = number of envelopes that can fit\\n\\t// Because we sorted the envelopes from smallest to highest\\n\\t// we can traverse everything in the left of i\\n\\t// and look at all envelopes that might have been smaller\\n    int result = 0;\\n    int[] dp = new int[n];\\n    for (int i = 0; i < n; i++) {\\n      dp[i] = 1;\\n\\t  // look at all other smaller envelopes than enevelopes[i]\\n      for (int j = 0; j < i; j++) {\\n        if (bigger(envelopes[i], envelopes[j])) {\\n          dp[i] = Math.max(\\n            dp[j] + 1,\\n            dp[i]\\n          );\\n        }\\n      }\\n      \\n      result = Math.max(dp[i], result);\\n    }\\n    return result;\\n    // return recurse(envelopes, new LinkedList<>(), 0, envelopes.length);\\n  }\\n  \\n  // Time limit exceeded\\n  public int recurse(int[][] remaining, List<int[]> chosen, int pos, int n) {\\n    if (pos == n)\\n      return 0;\\n    \\n    int count = 0;\\n    int[] envelope = remaining[pos];\\n    \\n    int resultIfChosen = 0, resultIfNOTChosen = 0;\\n    \\n    int prev = chosen.size() - 1;\\n    if (chosen.isEmpty() || bigger(envelope, chosen.get(prev))) {\\n\\t\\t// choose to include envelope in russian doll\\n\\t\\tchosen.add(envelope);\\n\\t\\tresultIfChosen = 1 + recurse(remaining, chosen, pos+1, n);\\n\\t\\tchosen.remove(chosen.size() - 1); // backtrack\\n\\t}\\n\\t\\t\\n\\t// choose to NOT include envelope in russian doll\\n    resultIfNOTChosen = recurse(remaining, chosen, pos+1, n);\\n\\n    return Math.max(resultIfChosen, resultIfNOTChosen);\\n  }\\n  \\n  private boolean bigger(int[] e1, int[] e2) {\\n    return e1[0] > e2[0] && e1[1] > e2[1];\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int maxEnvelopes(int[][] envelopes) {\\n    int n = envelopes.length;\\n\\t// Sort the envelopes\\n    Arrays.sort(envelopes, (e1, e2) -> {\\n      if (e1[0] < e2[0]) return -1; // e1 first if smaller width\\n      if (e1[0] > e2[0]) return 1;  // e1 second if bigger width\\n      if (e1[1] < e2[1]) return -1; // e1 first if smaller height\\n      if (e1[1] > e2[1]) return 1; // e1 second if bigger height\\n      return 0; // preserve ordering if equal width and height\\n    });\\n\\n\\t// idea is to have an auxillary array where dp[i] = number of envelopes that can fit\\n\\t// Because we sorted the envelopes from smallest to highest\\n\\t// we can traverse everything in the left of i\\n\\t// and look at all envelopes that might have been smaller\\n    int result = 0;\\n    int[] dp = new int[n];\\n    for (int i = 0; i < n; i++) {\\n      dp[i] = 1;\\n\\t  // look at all other smaller envelopes than enevelopes[i]\\n      for (int j = 0; j < i; j++) {\\n        if (bigger(envelopes[i], envelopes[j])) {\\n          dp[i] = Math.max(\\n            dp[j] + 1,\\n            dp[i]\\n          );\\n        }\\n      }\\n      \\n      result = Math.max(dp[i], result);\\n    }\\n    return result;\\n    // return recurse(envelopes, new LinkedList<>(), 0, envelopes.length);\\n  }\\n  \\n  // Time limit exceeded\\n  public int recurse(int[][] remaining, List<int[]> chosen, int pos, int n) {\\n    if (pos == n)\\n      return 0;\\n    \\n    int count = 0;\\n    int[] envelope = remaining[pos];\\n    \\n    int resultIfChosen = 0, resultIfNOTChosen = 0;\\n    \\n    int prev = chosen.size() - 1;\\n    if (chosen.isEmpty() || bigger(envelope, chosen.get(prev))) {\\n\\t\\t// choose to include envelope in russian doll\\n\\t\\tchosen.add(envelope);\\n\\t\\tresultIfChosen = 1 + recurse(remaining, chosen, pos+1, n);\\n\\t\\tchosen.remove(chosen.size() - 1); // backtrack\\n\\t}\\n\\t\\t\\n\\t// choose to NOT include envelope in russian doll\\n    resultIfNOTChosen = recurse(remaining, chosen, pos+1, n);\\n\\n    return Math.max(resultIfChosen, resultIfNOTChosen);\\n  }\\n  \\n  private boolean bigger(int[] e1, int[] e2) {\\n    return e1[0] > e2[0] && e1[1] > e2[1];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552394,
                "title": "python-dp-n-2-bs-nlogn",
                "content": "1) Dynamic Programming:\\nSort envelopes first, then it\\'s easy to derive that:\\ndp[i]:  maximum number of envelopes ends with envelopes[i]\\ndp[i] = max{dp[j]}(0<=j<i) + 1\\n```\\nclass Solution(object):\\n    def maxEnvelopes(self, envelopes):\\n        \"\"\"\\n        :type envelopes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(envelopes)\\n        if n < 2:\\n            return n\\n        envelopes.sort()\\n        ans = 1\\n        dp = [1 for i in range(n)]\\n        for i in range(1, n):\\n            for j in range(i):\\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\\n                    dp[i] = max(dp[i], dp[j]+1)\\n            ans = max(ans, dp[i])\\n        return ans\\n```\\n\\n2) Binary Search:\\nSort envelopes first, then use LIS solution to find maximum length of subsequence of the 2nd dimension. Note that when we sort the original envelopes list, we need to increasing 1st dimension and decreasing 2nd dimension. Think about case [[1, 3], [1, 4], [1,5], [1, 3]].  Decreasing 2nd dimension can help us to avoid the equavalent 1st dimension cases.\\n```\\nclass Solution(object):\\n    def bs(self, nums, h):\\n        left, right = 0, len(nums)-1\\n        while left <= right:\\n            mid = left + (right - left)/2\\n            if nums[mid] < h:\\n                left = mid + 1\\n            else:\\n                pos = mid\\n                right = mid - 1\\n        return pos\\n    \\n    def maxEnvelopes(self, envelopes):\\n        \"\"\"\\n        :type envelopes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(envelopes)\\n        if n < 2:\\n            return n\\n        envelopes.sort(key=lambda x:(x[0], -x[1]))\\n        ans = [envelopes[0][1]]\\n        for i in range(1, n):\\n            if envelopes[i][1] > ans[-1]:\\n                ans.append(envelopes[i][1])\\n            else:\\n                pos = self.bs(ans, envelopes[i][1])\\n                ans[pos] = envelopes[i][1]\\n        return len(ans)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxEnvelopes(self, envelopes):\\n        \"\"\"\\n        :type envelopes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(envelopes)\\n        if n < 2:\\n            return n\\n        envelopes.sort()\\n        ans = 1\\n        dp = [1 for i in range(n)]\\n        for i in range(1, n):\\n            for j in range(i):\\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\\n                    dp[i] = max(dp[i], dp[j]+1)\\n            ans = max(ans, dp[i])\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def bs(self, nums, h):\\n        left, right = 0, len(nums)-1\\n        while left <= right:\\n            mid = left + (right - left)/2\\n            if nums[mid] < h:\\n                left = mid + 1\\n            else:\\n                pos = mid\\n                right = mid - 1\\n        return pos\\n    \\n    def maxEnvelopes(self, envelopes):\\n        \"\"\"\\n        :type envelopes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(envelopes)\\n        if n < 2:\\n            return n\\n        envelopes.sort(key=lambda x:(x[0], -x[1]))\\n        ans = [envelopes[0][1]]\\n        for i in range(1, n):\\n            if envelopes[i][1] > ans[-1]:\\n                ans.append(envelopes[i][1])\\n            else:\\n                pos = self.bs(ans, envelopes[i][1])\\n                ans[pos] = envelopes[i][1]\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529258,
                "title": "simple-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int MaxEnvelopes(int[][] envelopes)\\n        {\\n            if (envelopes.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            if (envelopes.Length == 1)\\n            {\\n                return 1;\\n            }\\n\\n            Array.Sort(envelopes, (e1, e2) =>\\n            {\\n                var wCmp = e1[0].CompareTo(e2[0]);\\n                if (wCmp != 0)\\n                {\\n                    return wCmp;\\n                }\\n\\n                return e1[1].CompareTo(e2[1]);\\n            });\\n\\n            int[] dp = new int[envelopes.Length];\\n\\n            dp[0] = 1;\\n\\n            for (int i = 1; i < envelopes.Length; i++)\\n            {\\n                dp[i] = 1;\\n                var curr = envelopes[i];\\n\\n                for (int j = 0; j < i; j++)\\n                {\\n                    var prevDp = dp[j];\\n                    var prev = envelopes[j];\\n\\n                    if (prev[0] < curr[0] && prev[1] < curr[1])\\n                    {\\n                        if (prevDp + 1 > dp[i])\\n                        {\\n                            dp[i] = prevDp + 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return dp.Max();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public int MaxEnvelopes(int[][] envelopes)\\n        {\\n            if (envelopes.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            if (envelopes.Length == 1)\\n            {\\n                return 1;\\n            }\\n\\n            Array.Sort(envelopes, (e1, e2) =>\\n            {\\n                var wCmp = e1[0].CompareTo(e2[0]);\\n                if (wCmp != 0)\\n                {\\n                    return wCmp;\\n                }\\n\\n                return e1[1].CompareTo(e2[1]);\\n            });\\n\\n            int[] dp = new int[envelopes.Length];\\n\\n            dp[0] = 1;\\n\\n            for (int i = 1; i < envelopes.Length; i++)\\n            {\\n                dp[i] = 1;\\n                var curr = envelopes[i];\\n\\n                for (int j = 0; j < i; j++)\\n                {\\n                    var prevDp = dp[j];\\n                    var prev = envelopes[j];\\n\\n                    if (prev[0] < curr[0] && prev[1] < curr[1])\\n                    {\\n                        if (prevDp + 1 > dp[i])\\n                        {\\n                            dp[i] = prevDp + 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return dp.Max();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523101,
                "title": "c-super-simple-solution",
                "content": "```\\n    int maxEnvelopes(vector<vector<int>>& e) {\\n        sort(e.begin(), e.end(), [](auto& a, auto& b){\\n            return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\\n        });\\n        \\n        vector<int> dp;\\n        for(auto& t : e) {\\n            auto it = lower_bound(dp.begin(), dp.end() , t[1]);\\n            if(it == dp.end()) dp.push_back(t[1]);\\n            else *it = t[1];\\n        }\\n        return dp.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxEnvelopes(vector<vector<int>>& e) {\\n        sort(e.begin(), e.end(), [](auto& a, auto& b){\\n            return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\\n        });\\n        \\n        vector<int> dp;\\n        for(auto& t : e) {\\n            auto it = lower_bound(dp.begin(), dp.end() , t[1]);\\n            if(it == dp.end()) dp.push_back(t[1]);\\n            else *it = t[1];\\n        }\\n        return dp.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419132,
                "title": "c-clean-short-code-lis-using-set-o-nlgn-binary-search",
                "content": "This problem can be converted to LIS using sort.\\n\\n**LIS using Set: O(nlgn)**\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if (n == 0) return 0;\\n        sort(envelopes.begin(), envelopes.end(), \\n             [](vector<int>& a, vector<int>& b){\\n                 return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n             });\\n        \\n        set<int> s;\\n        for (int i = 0; i < n; ++i) {\\n            if (s.count(envelopes[i][1])) continue;\\n            s.insert(envelopes[i][1]);\\n            auto it = s.upper_bound(envelopes[i][1]);\\n            if (it != s.end()) {\\n                s.erase(*it);\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```\\n**If they don\\'t allow you to use upper_bound, use binary search!!**\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if (n == 0) return 0;\\n        sort(envelopes.begin(), envelopes.end(), \\n             [](vector<int>& a, vector<int>& b){\\n                 return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n             });\\n        \\n        vector<int> t;\\n        for (int i = 0; i < n; ++i) {\\n            \\n            int l = 0, r = t.size();\\n            int target = envelopes[i][1];\\n            \\n            while (l < r){\\n                int mid = l + (r-l)/2;\\n                if (t[mid] < target) l = mid+1;\\n                else r = mid;\\n            }\\n            if (r == t.size()) t.push_back(target);\\n            else t[r] = target;\\n        }\\n        return t.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if (n == 0) return 0;\\n        sort(envelopes.begin(), envelopes.end(), \\n             [](vector<int>& a, vector<int>& b){\\n                 return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n             });\\n        \\n        set<int> s;\\n        for (int i = 0; i < n; ++i) {\\n            if (s.count(envelopes[i][1])) continue;\\n            s.insert(envelopes[i][1]);\\n            auto it = s.upper_bound(envelopes[i][1]);\\n            if (it != s.end()) {\\n                s.erase(*it);\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        \\n        int n = envelopes.size();\\n        if (n == 0) return 0;\\n        sort(envelopes.begin(), envelopes.end(), \\n             [](vector<int>& a, vector<int>& b){\\n                 return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n             });\\n        \\n        vector<int> t;\\n        for (int i = 0; i < n; ++i) {\\n            \\n            int l = 0, r = t.size();\\n            int target = envelopes[i][1];\\n            \\n            while (l < r){\\n                int mid = l + (r-l)/2;\\n                if (t[mid] < target) l = mid+1;\\n                else r = mid;\\n            }\\n            if (r == t.size()) t.push_back(target);\\n            else t[r] = target;\\n        }\\n        return t.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380421,
                "title": "java-dp-solution-extension-of-longest-increasing-subsequence",
                "content": "```\\n public int maxEnvelopes(int[][] envelopes) {\\n        // sort the widths and then longest increasing subseq problem for heights\\n        if (envelopes == null || envelopes.length == 0) {\\n            return 0;\\n        }\\n        Comparator comp = Comparator.comparing((int[] arr)-> arr[0]).thenComparing((int[] arr)->arr[1], Comparator.reverseOrder());\\n        Arrays.sort(envelopes, comp);\\n        int result = 1;\\n        int[] dp = new int[envelopes.length];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < envelopes.length; i ++) {\\n            for (int j = 0; j < i ; j ++) {\\n                if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1]) {\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n                }\\n            }\\n            result = Math.max(dp[i], result);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int maxEnvelopes(int[][] envelopes) {\\n        // sort the widths and then longest increasing subseq problem for heights\\n        if (envelopes == null || envelopes.length == 0) {\\n            return 0;\\n        }\\n        Comparator comp = Comparator.comparing((int[] arr)-> arr[0]).thenComparing((int[] arr)->arr[1], Comparator.reverseOrder());\\n        Arrays.sort(envelopes, comp);\\n        int result = 1;\\n        int[] dp = new int[envelopes.length];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < envelopes.length; i ++) {\\n            for (int j = 0; j < i ; j ++) {\\n                if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1]) {\\n                    dp[i] = Math.max(dp[i], 1 + dp[j]);\\n                }\\n            }\\n            result = Math.max(dp[i], result);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331669,
                "title": "simple-solution-with-o-n-log-n-time-2-clean-codes",
                "content": "This problem is the application of **LIS (Longest Increasing Subsequence)**\\n**This code will take O(n^2) Time and O(n) Space Complexity**\\nRuntime: 628 ms, faster than 27.65% of C++ online submissions for Russian Doll Envelopes.\\nMemory Usage: 14.5 MB, less than 13.85% of C++ online submissions for Russian Doll Envelopes.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size(), result = 1;\\n        if(n == 0) return 0;\\n        sort(envelopes.begin(), envelopes.end());\\n        vector<int>res(n, 1);\\n        res[0] = 1;\\n        for(int i  = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])       \\n                    res[i] = max(res[i], res[j] + 1);\\n            }\\n            result = max(result, res[i]);\\n        }\\n        return result;\\n        \\n    }\\n};\\n```\\n\\n**This code will take O(n log n) Time and O(n) Space complexity**\\nRuntime: 36 ms, faster than 86.99% of C++ online submissions for Russian Doll Envelopes.\\nMemory Usage: 14.4 MB, less than 13.85% of C++ online submissions for Russian Doll Envelopes.\\n\\n```\\nbool sortby(const vector<int>&a, const vector<int> &b)\\n{\\n    return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n}\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        if(n == 0) return 0;\\n        sort(envelopes.begin(), envelopes.end(), sortby);\\n        \\n        vector<int>res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            auto it = lower_bound(res.begin(), res.end(), envelopes[i][1]);\\n            if(it == res.end())\\n                res.push_back(envelopes[i][1]);\\n            else if(*it > envelopes[i][1])//replace it\\n                *it = envelopes[i][1];\\n        }\\n        return res.size();\\n    }\\n};\\n```\\n\\n**If you have doubt regarding my code, feel free to ask me**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size(), result = 1;\\n        if(n == 0) return 0;\\n        sort(envelopes.begin(), envelopes.end());\\n        vector<int>res(n, 1);\\n        res[0] = 1;\\n        for(int i  = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])       \\n                    res[i] = max(res[i], res[j] + 1);\\n            }\\n            result = max(result, res[i]);\\n        }\\n        return result;\\n        \\n    }\\n};\\n```\n```\\nbool sortby(const vector<int>&a, const vector<int> &b)\\n{\\n    return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n}\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        int n = envelopes.size();\\n        if(n == 0) return 0;\\n        sort(envelopes.begin(), envelopes.end(), sortby);\\n        \\n        vector<int>res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            auto it = lower_bound(res.begin(), res.end(), envelopes[i][1]);\\n            if(it == res.end())\\n                res.push_back(envelopes[i][1]);\\n            else if(*it > envelopes[i][1])//replace it\\n                *it = envelopes[i][1];\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256511,
                "title": "javascript-solution-sort-and-dp",
                "content": "First, we need to sort. Because we would like to get a sequence that the smallest size envelop should be on the left side of the array. Then, it can easier determine whether next envelop could / could not wrap it. The evelopes on its left cannot do that.\\n\\nFor the DP:\\n\\nthe dp[i] means for the envelop `i`, the maximun envelopes it can contain.\\n\\n`dp[i] = Math.max(dp[i], dp[j] + 1); j : [0, i);`\\n\\nbecause for each i, it may has different ways to wrap. But we do not know which way is the best.\\n\\n```javascript\\nvar maxEnvelopes = function(envelopes) {\\n    envelopes.sort((a, b) => {\\n        if (a[0] === b[0]) {\\n            return a[1] - b[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n    const dp = new Array(envelopes.length); // dp[i], i \\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u7684\\u4FE1\\u5C01\\uFF0C\\u80FD\\u88C5\\u7684\\u6700\\u591A\\u7684\\u4FE1\\u3002\\n    dp.fill(1);\\n    let max = 0;\\n    for (let i = 0; i < envelopes.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        max = Math.max(max, dp[i]);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar maxEnvelopes = function(envelopes) {\\n    envelopes.sort((a, b) => {\\n        if (a[0] === b[0]) {\\n            return a[1] - b[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n    const dp = new Array(envelopes.length); // dp[i], i \\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u7684\\u4FE1\\u5C01\\uFF0C\\u80FD\\u88C5\\u7684\\u6700\\u591A\\u7684\\u4FE1\\u3002\\n    dp.fill(1);\\n    let max = 0;\\n    for (let i = 0; i < envelopes.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1]) {\\n                dp[i] = Math.max(dp[i], dp[j] + 1);\\n            }\\n        }\\n        max = Math.max(max, dp[i]);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195723,
                "title": "concise-and-easy-to-understand-java-dp-binary-search-with-comments",
                "content": "```\\n class Solution {\\n    public int maxEnvelopes(int[][] envelops) {\\n        // so the envelop: width, height\\n        // sort the envelop with width in asending order, if there are envelop with the same width\\n        // arrange them with height in descending order, and then try to find the longest increasing subsequence \\n        // in this , by height \\n        \\n        // sanity check \\n        if(envelops == null || envelops.length == 0 || envelops[0] == null || envelops[0].length != 2) return 0;\\n        \\n        // sort the envelops by the width in increasing order , if two width is the same, sort by height decreaisng order \\n        Arrays.sort(envelops, (e1, e2) -> e1[0] == e2[0] ? e2[1] - e1[1] : e1[0] - e2[0]);\\n            // Collections.sort(personList, (p1, p2) -> p1.firstName.compareTo(p2.firstName));\\n        int[] array = new int[envelops.length];\\n        for(int i = 0; i < envelops.length; i++){\\n            array[i] = envelops[i][1];\\n        }\\n        return lis(array);\\n    }\\n    \\n\\n\\n    private int lis(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        List<Integer> res = new ArrayList<>();\\n        res.add(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            int cur = nums[i];\\n            if(cur == res.get(res.size() - 1)) continue;\\n            if(cur > res.get(res.size() - 1)){\\n                res.add(cur);\\n            }else{\\n                int index = bs(res, cur);\\n                // replacement \\n                res.set(index, cur);\\n            }\\n        }\\n        return res.size();\\n    }\\n    private int bs(List<Integer> res, int newNum){\\n        // find the index of the element in the list, which is the first number that is bigger than the new element \\n        int left = 0;\\n        int right = res.size() - 1;\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(res.get(mid) == newNum){\\n                return mid;\\n            }else if(res.get(mid) > newNum){\\n                right = mid;\\n            }else{\\n                // res.get(mid) < newNum\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n    public int maxEnvelopes(int[][] envelops) {\\n        // so the envelop: width, height\\n        // sort the envelop with width in asending order, if there are envelop with the same width\\n        // arrange them with height in descending order, and then try to find the longest increasing subsequence \\n        // in this , by height \\n        \\n        // sanity check \\n        if(envelops == null || envelops.length == 0 || envelops[0] == null || envelops[0].length != 2) return 0;\\n        \\n        // sort the envelops by the width in increasing order , if two width is the same, sort by height decreaisng order \\n        Arrays.sort(envelops, (e1, e2) -> e1[0] == e2[0] ? e2[1] - e1[1] : e1[0] - e2[0]);\\n            // Collections.sort(personList, (p1, p2) -> p1.firstName.compareTo(p2.firstName));\\n        int[] array = new int[envelops.length];\\n        for(int i = 0; i < envelops.length; i++){\\n            array[i] = envelops[i][1];\\n        }\\n        return lis(array);\\n    }\\n    \\n\\n\\n    private int lis(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        List<Integer> res = new ArrayList<>();\\n        res.add(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            int cur = nums[i];\\n            if(cur == res.get(res.size() - 1)) continue;\\n            if(cur > res.get(res.size() - 1)){\\n                res.add(cur);\\n            }else{\\n                int index = bs(res, cur);\\n                // replacement \\n                res.set(index, cur);\\n            }\\n        }\\n        return res.size();\\n    }\\n    private int bs(List<Integer> res, int newNum){\\n        // find the index of the element in the list, which is the first number that is bigger than the new element \\n        int left = 0;\\n        int right = res.size() - 1;\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(res.get(mid) == newNum){\\n                return mid;\\n            }else if(res.get(mid) > newNum){\\n                right = mid;\\n            }else{\\n                // res.get(mid) < newNum\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157840,
                "title": "concise-8-line-python-o-nlogn-solution-easy-to-understand",
                "content": "The idea is pretty much shared in almost all the other solutions. \\n\\nI understood it most clearly after reading it from https://leetcode.com/problems/russian-doll-envelopes/discuss/82796/A-Trick-to-solve-this-problem. \\n```\\nYou can solve this problem in this way :\\n\\nlet\\'s suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we Sort this envelopes in a tricky way that Sort the envelopes according to width BUT when the values of width are same, we can sort it in reverse way like this :\\n\\n[2,3]\\n[3,7]\\n[4,8]\\n[4,6]\\n\\nNow just Do LIS on the all height values, you will get the answer\\n```\\n\\nThere are subtle nuances to Longest Increasing Subsequence problem. There is an `O(n^2)` solution and also an `O(nlogn)` solution, but O(nlogn) solution almost always results in messy code unless we use built in `bisect` method. \\n\\nSo I try to use the builtin `bisect_left` to simplify the code\\n```python3\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxEnvelopes(self, envelopes):\\n        tails = []\\n        for _,h in sorted(envelopes, key = lambda env : (env[0], -env[1])):\\n            pos = bisect_left(tails, h)\\n            if pos == len(tails):\\n                tails.append(h)\\n            else:\\n                tails[pos] = h\\n        return len(tails)      \\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nYou can solve this problem in this way :\\n\\nlet\\'s suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we Sort this envelopes in a tricky way that Sort the envelopes according to width BUT when the values of width are same, we can sort it in reverse way like this :\\n\\n[2,3]\\n[3,7]\\n[4,8]\\n[4,6]\\n\\nNow just Do LIS on the all height values, you will get the answer\\n```\n```python3\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxEnvelopes(self, envelopes):\\n        tails = []\\n        for _,h in sorted(envelopes, key = lambda env : (env[0], -env[1])):\\n            pos = bisect_left(tails, h)\\n            if pos == len(tails):\\n                tails.append(h)\\n            else:\\n                tails[pos] = h\\n        return len(tails)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 82767,
                "title": "clear-easy-to-understand-java-solution-sort-then-dfs-with-memoization",
                "content": "This isn't the most optimal solution being discussed, but I believe it is still O(nlog(n)) and it is much easier to understand than the more optimal solution involving finding the longest increasing subsequence discussed in the highest ranked posts. It beats about 40% of the other submissions, so it's not too bad, either.\\n\\n```\\npublic class Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        if (envelopes.length == 0) {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(envelopes, new Comparator<int[]>() {\\n            public int compare(int[] a, int b[]) {\\n                if (a[0] == b[0]) {\\n                    return a[1] - b[1];\\n                }\\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        int[] memos = new int[envelopes.length];\\n        \\n        int maxCount = 0;\\n        for (int i = 0; i < envelopes.length; i ++) {\\n            maxCount = Math.max(maxCount, dfs(i, envelopes, memos));\\n        }\\n        \\n        return maxCount;\\n    }\\n    \\n    private int dfs(int index, int[][] envelopes, int[] memos) {\\n        if (memos[index] != 0) {\\n            return memos[index];\\n        }\\n        \\n        int maxCount = 0;\\n        for (int high = index + 1; high < envelopes.length; high ++) {\\n            if (envelopes[index][0] < envelopes[high][0] && envelopes[index][1] < envelopes[high][1]) {\\n                maxCount = Math.max(maxCount, dfs(high, envelopes, memos));\\n            }\\n        }\\n        \\n        int result = maxCount + 1;\\n        memos[index] = result;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int maxEnvelopes(int[][] envelopes) {\\n        if (envelopes.length == 0) {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(envelopes, new Comparator<int[]>() {\\n            public int compare(int[] a, int b[]) {\\n                if (a[0] == b[0]) {\\n                    return a[1] - b[1];\\n                }\\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        int[] memos = new int[envelopes.length];\\n        \\n        int maxCount = 0;\\n        for (int i = 0; i < envelopes.length; i ++) {\\n            maxCount = Math.max(maxCount, dfs(i, envelopes, memos));\\n        }\\n        \\n        return maxCount;\\n    }\\n    \\n    private int dfs(int index, int[][] envelopes, int[] memos) {\\n        if (memos[index] != 0) {\\n            return memos[index];\\n        }\\n        \\n        int maxCount = 0;\\n        for (int high = index + 1; high < envelopes.length; high ++) {\\n            if (envelopes[index][0] < envelopes[high][0] && envelopes[index][1] < envelopes[high][1]) {\\n                maxCount = Math.max(maxCount, dfs(high, envelopes, memos));\\n            }\\n        }\\n        \\n        int result = maxCount + 1;\\n        memos[index] = result;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564571,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1766625,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1565817,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1568572,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1576806,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1565137,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1570389,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1570819,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1569097,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1572667,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1564571,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1766625,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1565817,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1568572,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1576806,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1565137,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1570389,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1570819,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1569097,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1572667,
                "content": [
                    {
                        "username": "anjani12",
                        "content": "You can solve this problem in this way :\\n\\nlet's suppose the values are given as...\\n[2,3]\\n[4,6]\\n[3,7]\\n[4,8]\\n\\nIf we **Sort** this envelopes in a tricky way that *Sort the envelopes according to width BUT when the values of height are same, we can sort it in reverse way* like this :\\n\\n[2,3]\\n[3,7]\\n**[4,8]\\n[4,6]**\\n\\nNow just **Do LIS on the all height values, you will get the answer**"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  might be cuz of error in ur lis implmentation "
                    },
                    {
                        "username": "yingtu35",
                        "content": "Thanks for the brilliant =idea! I am just wondering why the solution always guarantees the correct length of LIS even if replacing one of the envelopes in LIS breaks the rule of the problem.\\n\\nFor example, we have already sorted envelopes:\\n\\n```\\n# already sorted by width and reversed height\\nenvelopes = [[2,4],[3,8],[3,6],[4,2]]\\nFollowing the algorithm, the final LIS will look like this (if we include the width along with height):\\n```\\n```\\n# [4,2] will be put into 0 position of LIS because it has a smallest height\\nLIS = [[4,2],[3,6]]\\n# The truth LIS should be: [[2,4],[3,6]] or [[2,4],[3,8]]\\n```\\nClearly [[4,2],[3,6]] is not a valid russian doll envelope but the length is the same.\\nI came across this problem while solving it and thought this is not the solution, but actually, it works.\\nCan someone explain it?\\nThanks!"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@mlodyg](/mlodyg) Yes, thank you, i got it\\uD83D\\uDE09"
                    },
                    {
                        "username": "mlodyg",
                        "content": "[@spookie886](/spookie886) You can\\'t put envelopes with the same widths into each other.  If our sorted list looked like this: [[4,6], [4,8]], the length of LIS would be 2, however the expected answer is 1 (same widths). The trick protects us from such a situation (for [[4,8],[4,6]] the length of LIS=1).\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "Can anyone please tell me why we should do that with the height values? i really dont get it"
                    },
                    {
                        "username": "DarkFlames11",
                        "content": "[@devvartkumarkumar](/devvartkumarkumar)  nope that it gives 5 only... it will try to remove the bigger height value and try to place smaller heigh value"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "[[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]] \\nafter sorting in that way its becomes\\n2 100\\n3 200\\n4 300\\n5 500\\n5 400\\n5 250\\n6 370\\n6 360\\n7 380\\nthis also gives ans: 4\\nbut correct is 5\\n"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Even using DP and reducing the problem to LIS-like after sorting envelopes in ascending order of width, I am getting TLE passing 85/87 test cases in Python3."
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Same here, failing 85th case even though I am using C++. I think there must be any better solution than O(n^2).\\nLIS can also be solved using binary search so may be that is optimal here."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/russian-doll-envelopes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort + Longest Increasing Subsequence\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vkvk123vkvk321",
                        "content": "That descending sort on the second dimension is just...diabolical."
                    },
                    {
                        "username": "killerraj369",
                        "content": "[@spookie886](/spookie886) But suppose a test case like [1,2] [1,3]. since the width is same doing lis on 2 and 3 will increase the length of lis. but it should not be like this as the width and height of envelopes should be greater than the previous one. For this sort the envelopes in descending order of height so that it becomes [1,3] -> [1,2]. now doing lis on [3,2] will not increase the length of LIS and that's what we want. "
                    },
                    {
                        "username": "spookie886",
                        "content": "Why should we do that with the height values?\\n"
                    },
                    {
                        "username": "hisumai",
                        "content": "Why for the second test case, the maximum number of envelopes is shown as 1?\\n\\nBecause, as per the condition mentioned, the width and height of one enveloper should BE GREATER THAN that of the other envelope. The condition DOES NOT STATE it has to be GREATER THAN OR EQUAL TO.\\n\\nSo, how, in the case of second test case, the max number of envelopes is 1?"
                    },
                    {
                        "username": "code_with_rj",
                        "content": "if you are talking about [[1,1],[1,1],[1,1]] case, answer 1 is correct because, we can always fold first envelop. And then from next one, there is no way to keep that first one in to any other envelops. So answer is 1. "
                    },
                    {
                        "username": "Samuri",
                        "content": "[1,3] -> [3,5] -> [8,4] -> [9,5]\\n\\nDon't tell me that you can't rotate the envelope...coz that is silly.\\n\\nHowever, if the rotation is allowed, the O(n) algorithm will not work. You have to solve the longest path in the DAG.\\n\\nThe question should clearly say the rotation is not allowed."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "There\\'s an O(n) solution?"
                    },
                    {
                        "username": "Copyrightly",
                        "content": "I just want to generalize the problem. What if the envelopes have 3 or higher dimension? Can we still reduce it to LIS problem?"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "there is an entire ques for that😂\nhttps://leetcode.com/problems/maximum-height-by-stacking-cuboids/"
                    },
                    {
                        "username": "akun1012",
                        "content": "As I do not think it will be asked during current condition."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "say given is [3, 2] [3, 4 ]  after rotate [3, 4] -> [4, 3] then we can put [3, 2] into [4, 3]"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "Suppose instead of letters, we now have cuboidal boxes. I\\'m thinking is it possible to generalize LIS(nlogn) solution to 3d.\\nFor 2d algorithm is\\n- sort by length in increasing order.\\n- if length is same, sort by breadth in decreasing order\\n- find LIS of breadths\\n\\nCan we for 3d\\n- sort by length in increasing order\\n- if length is same, sort by breadth in increasing order\\n- if breadth is same, sort by height in decreasing order\\n- find LIS of heights\\n\\nSeems like we can. Just putting it out there to confirm"
                    },
                    {
                        "username": "shreyashiiti",
                        "content": "Your result might allow 2 envelopes of same length to be in your answer . "
                    }
                ]
            },
            {
                "id": 1809603,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            },
            {
                "id": 1572073,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            },
            {
                "id": 2049768,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            },
            {
                "id": 2037175,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            },
            {
                "id": 1969242,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            },
            {
                "id": 1909939,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            },
            {
                "id": 1789342,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            },
            {
                "id": 1759626,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            },
            {
                "id": 1741673,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            },
            {
                "id": 2071729,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "Hello Darkness, My Old Friend..."
                    },
                    {
                        "username": "Nifall",
                        "content": "What if the element is 3-dimension or more? Let\\'s say, it\\'s not an envelope but a box. \\nFor example: (1,1,2), (1,2,1), (2,2,3), (3,3,4), (3,4,3), (4,5,4).  The answer should be: (1,1,2), (2,2,3), (3,4,3), (4,5,4).\\nStill easy to solve in O(n^2), (like https://leetcode.com/problems/russian-doll-envelopes/discuss/82759/Simple-DP-solution), but I can\\'t figure out how to do in O(nlogn) (or in another word, with binarySearch, like https://leetcode.com/problems/longest-increasing-subsequence/description/).\\nInspired by this problem, We can still sort elements roughly first, just to make sure if b>a then b appears after a\\uFF08reverse is not guaranteed). Then we should find the longest \"strictly increasing\" (like b.x>a.x && b.y>a.y && b.z>a.z) subarray. But I wonder if we could do this with binarySearch? Any help would be appreciated."
                    },
                    {
                        "username": "sukiboo",
                        "content": "How can I solve this problem if **envelop rotation is allowed**?\\nI can\\'t wrap my head around it >_<"
                    },
                    {
                        "username": "sukiboo",
                        "content": "Alright I think I got it!\\nIf the rotations are allowed we should arrange envelopes so that `height <= width` for each envelop, and then proceed with the solution as usual.\\nWe can use mathematical induction to prove that arranging envelopes like that does not decrease the length of the chain, and therefore the longest chain can be build with rotated envelopes."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Why `envelopes = [[1,1],[1,1],[1,1]]` outputs 1, shouldn\\'t it be 0?"
                    },
                    {
                        "username": "fli033",
                        "content": "Just to make sure. We don\\'t need to sort the second dimension the other way with the $n^2$ solution, right?"
                    },
                    {
                        "username": "runtime_error2",
                        "content": "yes u r correct\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In Case 87/87 it says tle and there is no input mentioned its blank i solved using binary search and lis still having this problem what can be the issue?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "what\\'s best TC for this  ?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Aniket21448",
                        "content": "If one envelope can go inside another envelope when both width and height are greater of one than another, how the test case with [[1,1],[1,1],[1,1]] is giving Output as 1 not 0 if both width and height are equal.  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "Ankit_Kumar_8700",
                        "content": "yes, because 1 envelope of length and breadth = 1 each, can successfully be returned without fitting any other inside it\\ni.e, 1 empty envelope of 1X1 size"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "Here is the mark dwn of the problem statment :\\n1. here we need to  sort the data in sho first we need to add the defenciate the maxenvelopes after thet we can begains count and end count "
                    }
                ]
            }
        ]
    },
    {
        "title": "4Sum II",
        "question_content": "<p>Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j, k, l &lt; n</code></li>\n\t<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThe two tuples are:\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>n == nums3.length</code></li>\n\t<li><code>n == nums4.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>-2<sup>28</sup> &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2<sup>28</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1740606,
                "title": "going-from-o-n-4-o-n-3-o-n-2-java-c",
                "content": "```\\nWhat the question is saying, \\nGiven four integer arrays nums1, nums2, nums3, and nums4 all of length n, \\nreturn the number of tuples (i, j, k, l) such that their sum of nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\\n```\\nOne **brute force approach** came in mind, let\\'s iterate over all the array & form all the **possible tuples** & see how many **tuples** are having **sum zero**\\n\\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                for(int k : nums3)\\n                    for(int l : nums4)\\n                        if(i + j + k + l == 0) count++;\\n        return count;\\n    }\\n}\\n```\\nANALYSIS :- `[Time Limit Exceed]`\\n* **Time Complexity :- BigO(N^4)**\\n\\nBut, if you have solve 2-sum problem then you might have guess that we have to store some kind of data & make use of that and get access in O(1) time in data structure, so it\\'s **HashMap**\\n\\nLet just optimize a little bit. Just a bit,\\nRemove 1 loop **\"l\"** and we will use HashMap which will track the frequency of each number in our Array\\n\\nLet me show you it in our code:-\\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int l : nums4)\\n            map.put(l, map.getOrDefault(l, 0) + 1); // if number already present the inrement with + 1, otherwise add in map\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                for(int k : nums3)\\n                        count += map.getOrDefault(-(i + j + k), 0); // we have to find out the -ve of i + j + k \\n        // & in d we have to find such no that -(i + j + k) + l gives = 0. If it is there get it otherwise get 0\\n        // and update the count\\n        return count;\\n    }\\n}\\n```\\nIn this solution we reduce the Time Complexity from **O(N^4) -> O(N^3)** as still we running 3 nested for loop\\nANALYSIS :- `[Time Limit Exceed]`\\n* **Time Complexity :- BigO(N^3)**\\n\\n**Now, you think why don\\'t we move one more array in our HashMap and do the same logic**. I\\'ll say we gonna do that exact same thing, we will take one more for loop and put it in HashMap. So, what we will do is, take **\"k\"** for loop and when we put in Map **\"l\"** already present. By that we will form all the pair of **\"l n k\"**\\n\\nLet\\'s look at it\\'s code,\\n\\n**Java**\\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int k : nums3)\\n            for(int l : nums4)\\n                map.put(k + l, map.getOrDefault(k + l, 0) + 1);\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                        count += map.getOrDefault(-(i + j), 0);\\n        return count;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        map<int,int> mp;\\n        for(int k : nums3)\\n            for(int l : nums4)\\n                mp[k + l]++;\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                        count += mp[-(i + j)];\\n        return count;\\n    }\\n};\\n```\\nNow as you can see we have optimize it more. And the time complexity of solution has reduce from **O(N^3) -> O(N^2)**\\nANALYSIS :- \\n* **Time Complexity :-** BigO(N^2)\\n\\n* **Space Complexity :-** BigO(N^2)\\n\\n\\n**ANALYSIS, detailed EXPLANATION :-**\\n```\\nTime complexity: put and get methods for hashing can be considered constant complexity O(1). \\nEach double loop complexity has quadratic complexity O(N^2), repeated two times. \\nHence, Total Time complexity will be: O(2 N^2) + O(1) = O(N^2)\\n\\nSpace complexity: how mush space you add? map.put add a row in the map, here you are adding space in the memory. \\nHow much space? the number of times of the double for loop: O(N^2). Second double loop does not add space, has only get method. \\nFor loops themselves add only variable j and i in the memory, considered O(1), as well as the other variables in the code.\\nHence, Total Space Complexity will be: O(N^2) + O(1) = O(N^2)\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nWhat the question is saying, \\nGiven four integer arrays nums1, nums2, nums3, and nums4 all of length n, \\nreturn the number of tuples (i, j, k, l) such that their sum of nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\\n```\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                for(int k : nums3)\\n                    for(int l : nums4)\\n                        if(i + j + k + l == 0) count++;\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int l : nums4)\\n            map.put(l, map.getOrDefault(l, 0) + 1); // if number already present the inrement with + 1, otherwise add in map\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                for(int k : nums3)\\n                        count += map.getOrDefault(-(i + j + k), 0); // we have to find out the -ve of i + j + k \\n        // & in d we have to find such no that -(i + j + k) + l gives = 0. If it is there get it otherwise get 0\\n        // and update the count\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int k : nums3)\\n            for(int l : nums4)\\n                map.put(k + l, map.getOrDefault(k + l, 0) + 1);\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                        count += map.getOrDefault(-(i + j), 0);\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        map<int,int> mp;\\n        for(int k : nums3)\\n            for(int l : nums4)\\n                mp[k + l]++;\\n        int count = 0;\\n        for(int i : nums1)\\n            for(int j : nums2)\\n                        count += mp[-(i + j)];\\n        return count;\\n    }\\n};\\n```\n```\\nTime complexity: put and get methods for hashing can be considered constant complexity O(1). \\nEach double loop complexity has quadratic complexity O(N^2), repeated two times. \\nHence, Total Time complexity will be: O(2 N^2) + O(1) = O(N^2)\\n\\nSpace complexity: how mush space you add? map.put add a row in the map, here you are adding space in the memory. \\nHow much space? the number of times of the double for loop: O(N^2). Second double loop does not add space, has only get method. \\nFor loops themselves add only variable j and i in the memory, considered O(1), as well as the other variables in the code.\\nHence, Total Space Complexity will be: O(N^2) + O(1) = O(N^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740529,
                "title": "c-100-fast-and-easy-solution-commented-philosophy",
                "content": "**\"Welcome to abivilion\\'s solution. Kindly Upvote for supporting this article.**\\n<br>\\n\\n**SOLUTION**\\n\\n***TC - O(N^2)***\\n***SC - O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        \\n        int count=0;\\n        unordered_map<int,int> mp;\\n        \\n        /* Philosophy\\n        \\n        1. I know that Addtion have two parts in it  EG (a +b , Part 1 - a, Part 2- b.\\n        2.So, Lets make and find this dependency factors. How can I do it?\\n        \\n        3. If there are 4 Sum. it means 2 sums is going to Part 1 and another 2 gonna be Part 2 which are dependent on Part 1 for 0 resultant.\\n        \\n        4. I gonna store summation 2 nums1 in a FREQUENCY Hashmap.\\n        \\n        5. Then I traverse 2nd part of the summation (rest to nums) and keep checking that do (0-it1-it2) is exist in map . \\n       \\n        6. If yes, the add the frequency of Part1 int COUNT var.\\n        \\n        7. return count;\\n        */\\n        \\n        //Traversing Part 1\\n        for (auto &it1: nums1)\\n            for (auto &it2:nums2)\\n                mp[it1+it2]++; \\n        \\n        // Traversing Part 2\\n        for(auto &it3: nums3)\\n            for(auto &it4:nums4)\\n               if(mp.count(0-it3-it4)) count+=mp[0-it3-it4];\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        \\n        int count=0;\\n        unordered_map<int,int> mp;\\n        \\n        /* Philosophy\\n        \\n        1. I know that Addtion have two parts in it  EG (a +b , Part 1 - a, Part 2- b.\\n        2.So, Lets make and find this dependency factors. How can I do it?\\n        \\n        3. If there are 4 Sum. it means 2 sums is going to Part 1 and another 2 gonna be Part 2 which are dependent on Part 1 for 0 resultant.\\n        \\n        4. I gonna store summation 2 nums1 in a FREQUENCY Hashmap.\\n        \\n        5. Then I traverse 2nd part of the summation (rest to nums) and keep checking that do (0-it1-it2) is exist in map . \\n       \\n        6. If yes, the add the frequency of Part1 int COUNT var.\\n        \\n        7. return count;\\n        */\\n        \\n        //Traversing Part 1\\n        for (auto &it1: nums1)\\n            for (auto &it2:nums2)\\n                mp[it1+it2]++; \\n        \\n        // Traversing Part 2\\n        for(auto &it3: nums3)\\n            for(auto &it4:nums4)\\n               if(mp.count(0-it3-it4)) count+=mp[0-it3-it4];\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740570,
                "title": "python3-o-n-2-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe simple bruteforce solution would take `n^4` time complexity here. We can do better by dividing given lists into two groups and precalculating all possible sums for the first group. Results go to a hashmap where keys are sums and values are frequencies. It will take `n^2` time and space. After that, we iterate over elements of the second group, and for every pair check whether their sum can add up to zero with a sum from the first group using a hashmap.\\n\\nTime: **O(n^2)** - double n^2 scan\\nSpace: **O(n^2)** - for hashmap\\n\\nRuntime: 716 ms, faster than **85.08%** of Python3 online submissions for 4Sum II.\\nMemory Usage: 14.1 MB, less than **98.30%** of Python3 online submissions for 4Sum II.\\n\\n```\\ndef fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n\\tn, hm, res = len(nums1), defaultdict(int), 0\\n\\n\\tfor i in range(n):\\n\\t\\tfor j in range(n):\\n\\t\\t\\thm[nums1[i] + nums2[j]] += 1 \\n\\n\\tfor k in range(n):\\n\\t\\tfor l in range(n):\\n\\t\\t\\tres += hm[0 - (nums3[k] + nums4[l])]\\n\\n\\treturn res\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n\\tn, hm, res = len(nums1), defaultdict(int), 0\\n\\n\\tfor i in range(n):\\n\\t\\tfor j in range(n):\\n\\t\\t\\thm[nums1[i] + nums2[j]] += 1 \\n\\n\\tfor k in range(n):\\n\\t\\tfor l in range(n):\\n\\t\\t\\tres += hm[0 - (nums3[k] + nums4[l])]\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1740490,
                "title": "java-3-liner-simple-explained",
                "content": "**Idea:**\\n```\\nCount number of solutions to a + b + c + d  = 0\\n\\u21D2 a + b = -(c + d)\\n```\\n* Iterate through the first 2 arrays and count the frequency of all possible sums of pairs\\n* Iterate through the other 2 arrays and sum up the frequency of `-(c + d)` where c and d are all possible pairs in these 2 arrays. `-(c + d)` should be equal to `a + b` for a valid solution.\\n* The number of such matches is the required result\\n`Example:`\\n```\\nnums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\\n\\nIterated over nums1 and nums2, pairSums = {1 + (-2), 1 + (-1), 2 + (-2), 2 + (-1)}\\n= {-1, 0, 0, 1}\\npairCountBySum = {-1 : 1, 0 : 2, 1 : 1}, i.e. there is 1 pair with sum = 1, 2 pairs with sum = 0, 1 pair with sum = -1\\n\\nIterated over nums3 and nums4, pairSums = {-1 + 0, -1 + 2, 2 + 0, 2 + 2}\\n= {-1, 1, 2, 4}\\nNegate this to be able to find -(c + d)\\n= {1, -1, -2, -4}\\n\\nUse the hashMap pairCountBySum = {-1 : 1, 0 : 2, 1 : 1} for each item in {1, -1, -2, -4}\\n\\nfourSumCount = 0\\nfourSumCount += map.get(1)  \\u21D2 fourSumCount = 0 + 1 = 1\\nfourSumCount += map.get(-1) \\u21D2 fourSumCount = 1 + 1 = 2\\nfourSumCount += map.get(-2) \\u21D2 fourSumCount = 2 + 0 = 2\\nfourSumCount += map.get(-4) \\u21D2 fourSumCount = 2 + 0 = 2\\n\\nNumber of tuples = 2 [Ans]\\n```\\n>**T/S:** O(n\\xB2)/O(n\\xB2), where n = size(nums1)\\n \\n```\\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n\\tvar pairCountBySum = new HashMap<Integer, Integer>();\\n\\tfor (var num1 : nums1)\\n\\t\\tfor (var num2 : nums2)\\n\\t\\t\\tpairCountBySum.compute(num1 + num2, (k, sumCount) -> sumCount == null ? 1 : ++sumCount);\\n\\n\\tvar fourSumCount = 0;\\n\\tfor (var num3 : nums3)\\n\\t\\tfor (var num4 : nums4)\\n\\t\\t\\tfourSumCount += pairCountBySum.getOrDefault(-(num3 + num4), 0);\\n\\n\\treturn fourSumCount;\\n}\\n```\\n\\n**Version 2:** 3 liner using streams\\n```\\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n\\tvar pairCountBySum = new HashMap<Integer, Integer>();\\n\\t\\n\\tArrays.stream(nums1)\\n\\t\\t  .forEach(num1 -> Arrays.stream(nums2)\\n\\t\\t\\t\\t\\t\\t\\t     .forEach(num2 -> pairCountBySum.compute(num1 + num2, (k, sumCount) -> sumCount == null ? 1 : ++sumCount)));\\n\\t\\t  \\n\\treturn Arrays.stream(nums3)\\n\\t\\t\\t\\t .map(num3 -> Arrays.stream(nums4)\\n\\t\\t\\t\\t\\t\\t\\t\\t    .map(num4 -> pairCountBySum.getOrDefault(-(num3 + num4), 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t.sum())\\n\\t\\t\\t\\t .sum();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nCount number of solutions to a + b + c + d  = 0\\n\\u21D2 a + b = -(c + d)\\n```\n```\\nnums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\\n\\nIterated over nums1 and nums2, pairSums = {1 + (-2), 1 + (-1), 2 + (-2), 2 + (-1)}\\n= {-1, 0, 0, 1}\\npairCountBySum = {-1 : 1, 0 : 2, 1 : 1}, i.e. there is 1 pair with sum = 1, 2 pairs with sum = 0, 1 pair with sum = -1\\n\\nIterated over nums3 and nums4, pairSums = {-1 + 0, -1 + 2, 2 + 0, 2 + 2}\\n= {-1, 1, 2, 4}\\nNegate this to be able to find -(c + d)\\n= {1, -1, -2, -4}\\n\\nUse the hashMap pairCountBySum = {-1 : 1, 0 : 2, 1 : 1} for each item in {1, -1, -2, -4}\\n\\nfourSumCount = 0\\nfourSumCount += map.get(1)  \\u21D2 fourSumCount = 0 + 1 = 1\\nfourSumCount += map.get(-1) \\u21D2 fourSumCount = 1 + 1 = 2\\nfourSumCount += map.get(-2) \\u21D2 fourSumCount = 2 + 0 = 2\\nfourSumCount += map.get(-4) \\u21D2 fourSumCount = 2 + 0 = 2\\n\\nNumber of tuples = 2 [Ans]\\n```\n```\\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n\\tvar pairCountBySum = new HashMap<Integer, Integer>();\\n\\tfor (var num1 : nums1)\\n\\t\\tfor (var num2 : nums2)\\n\\t\\t\\tpairCountBySum.compute(num1 + num2, (k, sumCount) -> sumCount == null ? 1 : ++sumCount);\\n\\n\\tvar fourSumCount = 0;\\n\\tfor (var num3 : nums3)\\n\\t\\tfor (var num4 : nums4)\\n\\t\\t\\tfourSumCount += pairCountBySum.getOrDefault(-(num3 + num4), 0);\\n\\n\\treturn fourSumCount;\\n}\\n```\n```\\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n\\tvar pairCountBySum = new HashMap<Integer, Integer>();\\n\\t\\n\\tArrays.stream(nums1)\\n\\t\\t  .forEach(num1 -> Arrays.stream(nums2)\\n\\t\\t\\t\\t\\t\\t\\t     .forEach(num2 -> pairCountBySum.compute(num1 + num2, (k, sumCount) -> sumCount == null ? 1 : ++sumCount)));\\n\\t\\t  \\n\\treturn Arrays.stream(nums3)\\n\\t\\t\\t\\t .map(num3 -> Arrays.stream(nums4)\\n\\t\\t\\t\\t\\t\\t\\t\\t    .map(num4 -> pairCountBySum.getOrDefault(-(num3 + num4), 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t.sum())\\n\\t\\t\\t\\t .sum();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93917,
                "title": "easy-2-lines-o-n-2-python",
                "content": "    def fourSumCount(self, A, B, C, D):\\n        AB = collections.Counter(a+b for a in A for b in B)\\n        return sum(AB[-c-d] for c in C for d in D)",
                "solutionTags": [],
                "code": "    def fourSumCount(self, A, B, C, D):\\n        AB = collections.Counter(a+b for a in A for b in B)\\n        return sum(AB[-c-d] for c in C for d in D)",
                "codeTag": "Python3"
            },
            {
                "id": 93920,
                "title": "clean-java-solution-o-n-2",
                "content": "    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<C.length; i++) {\\n            for(int j=0; j<D.length; j++) {\\n                int sum = C[i] + D[j];\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0; i<A.length; i++) {\\n            for(int j=0; j<B.length; j++) {\\n                res += map.getOrDefault(-1 * (A[i]+B[j]), 0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\t\\n\\tTime complexity:  O(n^2)\\n\\tSpace complexity: O(n^2)",
                "solutionTags": [],
                "code": "    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<C.length; i++) {\\n            for(int j=0; j<D.length; j++) {\\n                int sum = C[i] + D[j];\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0; i<A.length; i++) {\\n            for(int j=0; j<B.length; j++) {\\n                res += map.getOrDefault(-1 * (A[i]+B[j]), 0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\t\\n\\tTime complexity:  O(n^2)\\n\\tSpace complexity: O(n^2)",
                "codeTag": "Unknown"
            },
            {
                "id": 93925,
                "title": "concise-c-11-code-beat-99-5",
                "content": "```\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int, int>  abSum;\\n        for(auto a : A) {\\n            for(auto b : B) {\\n                ++abSum[a+b];\\n            }\\n        }\\n        int count = 0;\\n        for(auto c : C) {\\n            for(auto d : D) {\\n                auto it = abSum.find(0 - c - d);\\n                if(it != abSum.end()) {\\n                    count += it->second;\\n                }\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int, int>  abSum;\\n        for(auto a : A) {\\n            for(auto b : B) {\\n                ++abSum[a+b];\\n            }\\n        }\\n        int count = 0;\\n        for(auto c : C) {\\n            for(auto d : D) {\\n                auto it = abSum.find(0 - c - d);\\n                if(it != abSum.end()) {\\n                    count += it->second;\\n                }\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 175783,
                "title": "hash-java-with-explanations",
                "content": "**Thought**\\nWe aim to find all possible A[i] + B[j] + C[k] + D[l] = 0, that is,\\n`A[i] + B[j] = -(C[k] + D[l])`\\nIn other words, we need to  count the number of all possible two-sums between A and B that equals to opposite of any two-sum between C and D.\\nThus, we enumerate all two-sums between C and D, and store sum-to-frequency mappings for reference.\\n\\n**Code**\\n```\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>(); // key: sum, value: frequency of sum.\\n        \\n        int n = A.length, result = 0; \\n        \\n        // Get all possible two-sums between C and D.\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int sum = C[i] + D[j];\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        \\n        // Count the number of two-sums between A and B that equals to opposite of any two-sum between C and D\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int sum = A[i] + B[j];\\n                if (map.containsKey(-sum))\\n                    result += map.get(-sum);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>(); // key: sum, value: frequency of sum.\\n        \\n        int n = A.length, result = 0; \\n        \\n        // Get all possible two-sums between C and D.\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int sum = C[i] + D[j];\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        \\n        // Count the number of two-sums between A and B that equals to opposite of any two-sum between C and D\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int sum = A[i] + B[j];\\n                if (map.containsKey(-sum))\\n                    result += map.get(-sum);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93946,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n\\tMap<Integer,Integer> sums = new HashMap<>();\\n\\tint count = 0;\\n\\tfor(int i=0; i<A.length;i++) {\\n\\t\\tfor(int j=0;j<B.length;j++){\\n\\t\\t\\tint sum = A[i]+B[j];\\n\\t\\t\\tif(sums.containsKey(sum)) {\\n\\t\\t\\t\\tsums.put(sum, sums.get(sum)+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsums.put(sum, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int k=0; k<A.length;k++) {\\n\\t\\tfor(int z=0;z<C.length;z++){\\n\\t\\t\\tint sum = -(C[k]+D[z]);\\n\\t\\t\\tif(sums.containsKey(sum)) {\\n\\t\\t\\t\\tcount+=sums.get(sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\\n\\nTake the arrays A and B, and compute all the possible sums of two elements. Put the sum in the Hash map, and increase the hash map value if more than 1 pair sums to the same value.\\n\\nCompute all the possible sums of the arrays C and D. If the hash map contains the opposite value of the current sum, increase the count of four elements sum to 0 by the counter in the map.",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n\\tMap<Integer,Integer> sums = new HashMap<>();\\n\\tint count = 0;\\n\\tfor(int i=0; i<A.length;i++) {\\n\\t\\tfor(int j=0;j<B.length;j++){\\n\\t\\t\\tint sum = A[i]+B[j];\\n\\t\\t\\tif(sums.containsKey(sum)) {\\n\\t\\t\\t\\tsums.put(sum, sums.get(sum)+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsums.put(sum, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int k=0; k<A.length;k++) {\\n\\t\\tfor(int z=0;z<C.length;z++){\\n\\t\\t\\tint sum = -(C[k]+D[z]);\\n\\t\\t\\tif(sums.containsKey(sum)) {\\n\\t\\t\\t\\tcount+=sums.get(sum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93927,
                "title": "python-o-n-2-solution-with-hashtable",
                "content": "\\n    class Solution(object):\\n        def fourSumCount(self, A, B, C, D):\\n            \"\"\"\\n            :type A: List[int]\\n            :type B: List[int]\\n            :type C: List[int]\\n            :type D: List[int]\\n            :rtype: int\\n            \"\"\"\\n            hashtable = {}\\n            for a in A:\\n                for b in B :\\n                    if a + b in hashtable :\\n                        hashtable[a+b] += 1\\n                    else :\\n                        hashtable[a+b] = 1\\n            count = 0         \\n            for c in C :\\n                for d in D :\\n                    if -c - d in hashtable :\\n                        count += hashtable[-c-d]\\n            return count",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "class Solution(object):\\n        def fourSumCount(self, A, B, C, D):\\n            \"\"\"\\n            :type A: List[int]\\n            :type B: List[int]\\n            :type C: List[int]\\n            :type D: List[int]\\n            :rtype: int\\n            \"\"\"\\n            hashtable = {}",
                "codeTag": "Java"
            },
            {
                "id": 975319,
                "title": "python-o-n-2-two-2-sum-explained",
                "content": "Let us look at pairs of numbers from `A` and `B` and calculate all `O(n^2)` of them. Next, we look at all pairs from `C` and `D` and again calculate all of them. Now, our problem is reduced to **2-sum** problem: we need to find two numbers from two lists, such that sum of them equal to `0`. There is couple of moments we need to care about:\\n\\n1. There can be duplicates, so we keep `Counter()` for our sums.\\n2. When we update `ans`, we check how many numbers we have in first counter and multiply it by how many times we have for opposite number.\\n\\n**Complexity**: total complexity is `O(n^2)` to look at all pairs from `(A, B)` and `(C, D)`. Space complexity is also `O(n^2)`. One possible optimization is to first create counters from our lists and work with them directly.\\n\\n```\\nclass Solution:\\n    def fourSumCount(self, A, B, C, D):\\n        Cnt1, Cnt2, ans = Counter(), Counter(), 0\\n        for a, b in product(A, B):\\n            Cnt1[a + b] += 1\\n            \\n        for c, d in product(C, D):\\n            Cnt2[c + d] += 1\\n            \\n        for val in Cnt1:\\n            if -val in Cnt2:\\n                ans += Cnt1[val]*Cnt2[-val]\\n                \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, A, B, C, D):\\n        Cnt1, Cnt2, ans = Counter(), Counter(), 0\\n        for a, b in product(A, B):\\n            Cnt1[a + b] += 1\\n            \\n        for c, d in product(C, D):\\n            Cnt2[c + d] += 1\\n            \\n        for val in Cnt1:\\n            if -val in Cnt2:\\n                ans += Cnt1[val]*Cnt2[-val]\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182291,
                "title": "c-easy-approach-with-detailed-solution",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED !!!**\\n\\n*Overload the comments section with doubts and praises if you have.!!!*\\n\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& p, vector<int>& q, vector<int>& r, vector<int>& s) {\\n        unordered_map<int, int> hash;\\n        int n = p.size();\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                // Increment the hashtable at the sum of the pair\\n                hash[p[i] + q[j]]++;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                // Check if the negative of curr sum of the pair exists in the hash table. Then they will add upto zero. \\n                // i.e hash[p[w] + q[x]] + hash[r[y] + s[z]] == 0.\\n                // But we dont want zero. We want no. of two touples. Hence we store the value in hashtable in ans. If it is present in hashtable it will get stored in ans, else it will get neglected cosidering it as a zero.\\n                ans = ans + hash[-(r[i] + s[j])];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& p, vector<int>& q, vector<int>& r, vector<int>& s) {\\n        unordered_map<int, int> hash;\\n        int n = p.size();\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                // Increment the hashtable at the sum of the pair\\n                hash[p[i] + q[j]]++;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                // Check if the negative of curr sum of the pair exists in the hash table. Then they will add upto zero. \\n                // i.e hash[p[w] + q[x]] + hash[r[y] + s[z]] == 0.\\n                // But we dont want zero. We want no. of two touples. Hence we store the value in hashtable in ans. If it is present in hashtable it will get stored in ans, else it will get neglected cosidering it as a zero.\\n                ans = ans + hash[-(r[i] + s[j])];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210038,
                "title": "c-unordered-map-clean-and-easy-solution",
                "content": "class Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        \\n        int f=0;\\n        unordered_map<int,int>m;\\n        \\n        for(auto u:A)\\n            for(auto v:B)\\n                m[u+v]++;\\n\\n        for(auto u:C)\\n            for(auto v:D)\\n            {\\n                auto it=m.find(0-u-v);\\n                if(it!=m.end())\\n                    f += it->second;\\n            }\\n\\n        return f;\\n}\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        \\n        int f=0;\\n        unordered_map<int,int>m;\\n        \\n        for(auto u:A)\\n            for(auto v:B)\\n                m[u+v]++;\\n\\n        for(auto u:C)\\n            for(auto v:D)\\n            {\\n                auto it=m.find(0-u-v);\\n                if(it!=m.end())\\n                    f += it->second;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 465288,
                "title": "python3-two-liner",
                "content": "Instead of using a usual dictionary to store 2-sums and their counts we can use standard Counter class that does that automatically and write solution in the most pythonic way possible:\\n\\n```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        sums = collections.Counter(c+d for c in C for d in D)\\n        return sum(sums.get(-(a+b), 0) for a in A for b in B)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        sums = collections.Counter(c+d for c in C for d in D)\\n        return sum(sums.get(-(a+b), 0) for a in A for b in B)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741072,
                "title": "python-clean-and-concise-detail-explanation-one-linear",
                "content": "The first things to note is unlike the prevoius variation of this problem (3 Sum, 2 Sum) where they asked us to return the indexes of the array, here we are supposed to return only the no of ways in which we can achieve it. \\n\\nSo, first lets loop through any of the two array and store all possible combination of sum which can be achived by those two arrays. So lets take an example below,\\n```\\nnums1 = [1,2] \\nnums2 = [-1,-2]\\nnums3 = [-1,2]\\nnums4 = [0,2]\\n```\\nIn this case lets choose nums1 and nums2, so our hasmap after we store all possible combination of sum will be \\n\\n`Map<sum, count> = {-1: 1, 0: 2, 1: 1}`\\n\\nNow that we have these values and also we know the final sum to be zero, we can do the similar iteration with other two arrays to get all possible combination sums of those, now if we encounter negation of the same value in our Map  (-x +x = 0), that will indeed result to a pair of values resulting in total sum 0, so we can increase our result by 1. \\n\\n**Talking is cheap,**\\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        \\n        # hashmap and final result count\\n        nums12, res = defaultdict(int), 0\\n        \\n        # storing all possible combinations of sum\\n        for i in nums1:\\n            for j in nums2:\\n                nums12[i+j] += 1\\n        \\n        # iterating the left out two array to find negation of same value\\n        for k in nums3:\\n            for l in nums4:\\n                res += nums12[-(k+l)]\\n        \\n        return res\\n```\\n\\nWe can also convert it more pythonic using a one linear, here you go\\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        return sum(counts[-(c + d)] for counts in [Counter(a + b for a in nums1 for b in nums2)] for c in nums3 for d in nums4)\\n```\\n\\n*Time complexity*: **O(n^2)**\\n*Space complexity*: **O(n^2)**\\n\\n***Upvote if this helped!***\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nnums1 = [1,2] \\nnums2 = [-1,-2]\\nnums3 = [-1,2]\\nnums4 = [0,2]\\n```\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        \\n        # hashmap and final result count\\n        nums12, res = defaultdict(int), 0\\n        \\n        # storing all possible combinations of sum\\n        for i in nums1:\\n            for j in nums2:\\n                nums12[i+j] += 1\\n        \\n        # iterating the left out two array to find negation of same value\\n        for k in nums3:\\n            for l in nums4:\\n                res += nums12[-(k+l)]\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        return sum(counts[-(c + d)] for counts in [Counter(a + b for a in nums1 for b in nums2)] for c in nums3 for d in nums4)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443289,
                "title": "python-100-memory-96-7-faster-o-n-2",
                "content": "first we put sum of C and D values into dict\\nC = [1,2]\\nD = [1,2] \\n1 + 1 => {2:1}\\n1 + 2 => {2:1, 3:1}\\n2 + 1 => {2:1, 3:2}\\n2 + 2 => {2:1, 3:2, 4:1}\\n\\nthen we iterate over A and B\\nA = [-1,-2]\\nB = [-1,-2]\\n-1 -1 => 0 - (-2) => 2 is key we want. (matches += 1)\\n-1 -2 => 0 - (-3) => 3 is key we want. (matches += 2)\\n-2 -1 => 0 - (-3) => 3 is key we want. (matches += 2) \\n-2 -2 => 0 - (-4) => 4 is key we want. (matches += 1)\\n\\nanswer is 6\\n\\n```python\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        total_sum = 0\\n        cache = {}\\n        for i in C:\\n            for j in D:\\n                key = i + j\\n                if key in cache:\\n                    cache[key] += 1\\n                else:\\n                    cache[key] = 1\\n        for i in A:\\n            for j in B:\\n                key = 0 - i - j\\n                if key in cache:\\n                    total_sum += cache[key]\\n        return total_sum\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        total_sum = 0\\n        cache = {}\\n        for i in C:\\n            for j in D:\\n                key = i + j\\n                if key in cache:\\n                    cache[key] += 1\\n                else:\\n                    cache[key] = 1\\n        for i in A:\\n            for j in B:\\n                key = 0 - i - j\\n                if key in cache:\\n                    total_sum += cache[key]\\n        return total_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93973,
                "title": "dividing-arrays-into-two-parts-full-thinking-process-from-naive-n-4-to-effective-n-2-solution",
                "content": "1) The naive solution is to run four loops by iterating all elements and check for (A[i] + B[j] + C[k] + d[h]) == 0. Time complexity: N^4\\n2) We can improve solution by iterating through elements of three arrays and check if the fourth array contains A[i] + B[j] + C[k] + d == 0  ---->  d = -A[i] - B[j] - C[k]. We can use HashSet to store elements of fourth array. Overall time complexity: N^3;\\n3) To improve the solution we can divide arrays into two parts. Then make calculation of sums of one part (A[i] + B[j]) and store their sum's occurences counter in a HashMap. While calculating second part arrays' sum (secondSum = C[k] + D[h]) we can check whether map contains secondSum*(-1);\\nA[i] + B[j] == - C[k] - D[h]\\nA[i] + B[j] == - (C[k]+D[h])\\n\\nThis solution can be extended for N arrays.\\n\\n```\\npublic class Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        HashMap<Integer, Integer> sumCounter = getSumCounters(A,B);\\n        int fourSumCounter = 0;\\n        for (int c : C) {\\n            for (int d: D) {\\n                fourSumCounter += sumCounter.getOrDefault(c+d, 0);\\n            }\\n        }\\n        return fourSumCounter;\\n    }\\n    \\n    private HashMap<Integer, Integer> getSumCounters(int [] A, int [] B) {\\n        HashMap<Integer, Integer> sumCounter = new HashMap<>();\\n        for (int a : A) {\\n            for (int b: B) {\\n                int sum = -a-b;\\n                sumCounter.put(sum, sumCounter.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        return sumCounter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        HashMap<Integer, Integer> sumCounter = getSumCounters(A,B);\\n        int fourSumCounter = 0;\\n        for (int c : C) {\\n            for (int d: D) {\\n                fourSumCounter += sumCounter.getOrDefault(c+d, 0);\\n            }\\n        }\\n        return fourSumCounter;\\n    }\\n    \\n    private HashMap<Integer, Integer> getSumCounters(int [] A, int [] B) {\\n        HashMap<Integer, Integer> sumCounter = new HashMap<>();\\n        for (int a : A) {\\n            for (int b: B) {\\n                int sum = -a-b;\\n                sumCounter.put(sum, sumCounter.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        return sumCounter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288500,
                "title": "easy-java-solution-uses-hashmap-with-o-n-2-and-beats-98-86-java-solutions",
                "content": "\\t  public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tMap<Integer,Integer> hashMap = new HashMap<>();\\n\\t\\t\\tfor (int numA : A) {\\n\\t\\t\\t\\tfor (int numB : B) {\\n\\t\\t\\t\\t\\tint sumAB = numA + numB;\\n\\t\\t\\t\\t\\thashMap.put(sumAB, hashMap.getOrDefault(sumAB, 0) + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (int numC : C){\\n\\t\\t\\t\\tfor (int numD : D){\\n\\t\\t\\t\\t\\tint sumCD = numC + numD;\\n\\t\\t\\t\\t\\tcount += hashMap.getOrDefault(-sumCD,0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\t  public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tMap<Integer,Integer> hashMap = new HashMap<>();\\n\\t\\t\\tfor (int numA : A) {\\n\\t\\t\\t\\tfor (int numB : B) {\\n\\t\\t\\t\\t\\tint sumAB = numA + numB;\\n\\t\\t\\t\\t\\thashMap.put(sumAB, hashMap.getOrDefault(sumAB, 0) + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (int numC : C){\\n\\t\\t\\t\\tfor (int numD : D){\\n\\t\\t\\t\\t\\tint sumCD = numC + numD;\\n\\t\\t\\t\\t\\tcount += hashMap.getOrDefault(-sumCD,0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 191237,
                "title": "python3-clean-solution",
                "content": "```    \ndef fourSumCount(self, A, B, C, D):\n        ab = {}\n        for i in A:\n            for j in B:\n                ab[i+j] = ab.get(i+j, 0) + 1\n        \n        ans = 0\n        for i in C:\n            for j in D:\n                ans += ab.get(-i-j, 0)       \n        return ans\n\n```",
                "solutionTags": [],
                "code": "```    \ndef fourSumCount(self, A, B, C, D):\n        ab = {}\n        for i in A:\n            for j in B:\n                ab[i+j] = ab.get(i+j, 0) + 1\n        \n        ans = 0\n        for i in C:\n            for j in D:\n                ans += ab.get(-i-j, 0)       \n        return ans\n\n```",
                "codeTag": "Python3"
            },
            {
                "id": 975369,
                "title": "c-o-n-2-solution-faster-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int res=0;\\n        unordered_map<int,int> m(A.size() * B.size());\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<B.size();j++)\\n            {\\n                m[A[i]+B[j]]++;\\n            }\\n        }\\n        for(int i=0;i<C.size();i++)\\n        {\\n            for(int j=0;j<D.size();j++)\\n            {\\n                const auto it=m.find(-C[i]-D[j]);\\n                if(it!=m.end())\\n                {\\n                    res+=it->second;\\n                }\\n            }\\n        }\\n        return res;}\\n   \\n};\\n```\\nplease upvote if it helps !",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int res=0;\\n        unordered_map<int,int> m(A.size() * B.size());\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<B.size();j++)\\n            {\\n                m[A[i]+B[j]]++;\\n            }\\n        }\\n        for(int i=0;i<C.size();i++)\\n        {\\n            for(int j=0;j<D.size();j++)\\n            {\\n                const auto it=m.find(-C[i]-D[j]);\\n                if(it!=m.end())\\n                {\\n                    res+=it->second;\\n                }\\n            }\\n        }\\n        return res;}\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114123,
                "title": "java-solution-using-sort-not-map-beats-93-o-n-2-log-n-time",
                "content": "Comparing with map, this solution using sorting costs O(n^2*log(n)) time but actually runs faster because it avoids map overheads (my hash map solution beats only 71%). Of course for very large n, map solution eventually wins, but curious what n would it be.\\n```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n    /* sorting, O(n^2*log(n)) time, O(n^2) space, no map */\\n    int nAB = A.length * B.length;\\n    int[] sumAB = new int[nAB];\\n    int i = 0;\\n    for (int a : A) {\\n        for (int b : B) {\\n            sumAB[i++] = a + b;\\n        }\\n    }\\n    Arrays.sort(sumAB);\\n    int nCD = C.length * D.length;\\n    int[] negSumCD = new int[nCD];\\n    i = 0;\\n    for (int c : C) {\\n        for (int d : D) {\\n            negSumCD[i++] = - (c + d);\\n        }\\n    }\\n    Arrays.sort(negSumCD);\\n    // if sumAB = negSumCD, then 4 sum = 0\\n    i = 0;\\n    int j = 0;\\n    int res = 0;\\n    while (i < nAB && j < nCD) {\\n        if (sumAB[i] < negSumCD[j]) i++;\\n        else if (sumAB[i] > negSumCD[j]) j++;\\n        else {\\n            // sumAB[i] == negSumCD[j]\\n            // need to count number of same consecutive values, and multiply them\\n            int countAB = 1, countCD = 1;\\n            while (++i < nAB && sumAB[i-1] == sumAB[i]) countAB += 1;\\n            while (++j < nCD && negSumCD[j-1] == negSumCD[j]) countCD += 1;\\n            res += countAB * countCD;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n    /* sorting, O(n^2*log(n)) time, O(n^2) space, no map */\\n    int nAB = A.length * B.length;\\n    int[] sumAB = new int[nAB];\\n    int i = 0;\\n    for (int a : A) {\\n        for (int b : B) {\\n            sumAB[i++] = a + b;\\n        }\\n    }\\n    Arrays.sort(sumAB);\\n    int nCD = C.length * D.length;\\n    int[] negSumCD = new int[nCD];\\n    i = 0;\\n    for (int c : C) {\\n        for (int d : D) {\\n            negSumCD[i++] = - (c + d);\\n        }\\n    }\\n    Arrays.sort(negSumCD);\\n    // if sumAB = negSumCD, then 4 sum = 0\\n    i = 0;\\n    int j = 0;\\n    int res = 0;\\n    while (i < nAB && j < nCD) {\\n        if (sumAB[i] < negSumCD[j]) i++;\\n        else if (sumAB[i] > negSumCD[j]) j++;\\n        else {\\n            // sumAB[i] == negSumCD[j]\\n            // need to count number of same consecutive values, and multiply them\\n            int countAB = 1, countCD = 1;\\n            while (++i < nAB && sumAB[i-1] == sumAB[i]) countAB += 1;\\n            while (++j < nCD && negSumCD[j-1] == negSumCD[j]) countCD += 1;\\n            res += countAB * countCD;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1740730,
                "title": "c-easy-to-understand-easy-explanation-intuitive-fast",
                "content": "**Please Upvote if You Like it...!**\\n**Feel Free to Share your thoughts... :)**\\n\\n\\n**Approach 1: Naive**\\n**Finding all the possibe quad\\'s and check if their sum is equl to zero or not**\\n\\n**Status: TLE**\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int cnt=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                for(int k=0;k<nums3.size();k++)\\n                {\\n                    for(int l=0;l<nums4.size();l++)\\n                    {\\n                        if(nums1[i]+nums2[j]+nums3[k]+nums4[l]==0)\\n                        {\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n\\n**Approach 2: Using Unordered_map**\\n**Status: AC**\\n\\n**Intution:**\\n```\\nCount the total number of solutions to that satisfies the condition -->  a + b = -(c + d)\\n\\n1) Iterate over the first 2 vectors and count the frequency of all possible sums of pairs and store it in a map\\n2) Iterate over the other 2 vectors and sum up the frequency of -(c + d) \\n3) If (a + b) is be equal to -(c + d). Then add the frequency of -(c + d) to the counter .\\n4) The total number of pairs which satisfies the above condition is the required result\\n```\\n\\n**Answer**\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int cnt = 0;\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            for(int j = 0; j < nums2.size(); j++)\\n            {\\n                int sum = nums1[i] + nums2[j];\\n                mp[sum]++;\\n            }\\n        }\\n        for(int i = 0; i < nums3.size(); i++)\\n        {\\n            for(int j = 0; j < nums4.size(); j++)\\n            {\\n                int sum = (-1) * (nums3[i] + nums4[j]);\\n                if(mp[sum])\\n                {\\n                    cnt += mp[sum];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int cnt=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                for(int k=0;k<nums3.size();k++)\\n                {\\n                    for(int l=0;l<nums4.size();l++)\\n                    {\\n                        if(nums1[i]+nums2[j]+nums3[k]+nums4[l]==0)\\n                        {\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nCount the total number of solutions to that satisfies the condition -->  a + b = -(c + d)\\n\\n1) Iterate over the first 2 vectors and count the frequency of all possible sums of pairs and store it in a map\\n2) Iterate over the other 2 vectors and sum up the frequency of -(c + d) \\n3) If (a + b) is be equal to -(c + d). Then add the frequency of -(c + d) to the counter .\\n4) The total number of pairs which satisfies the above condition is the required result\\n```\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int cnt = 0;\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            for(int j = 0; j < nums2.size(); j++)\\n            {\\n                int sum = nums1[i] + nums2[j];\\n                mp[sum]++;\\n            }\\n        }\\n        for(int i = 0; i < nums3.size(); i++)\\n        {\\n            for(int j = 0; j < nums4.size(); j++)\\n            {\\n                int sum = (-1) * (nums3[i] + nums4[j]);\\n                if(mp[sum])\\n                {\\n                    cnt += mp[sum];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260070,
                "title": "javascript-solution-0",
                "content": "Idea is, \\n1. Reduce this problem to the 2Sum problem by calculating all possible sum of pairs in (A,B) and (C,D), store in two maps. Map key will be the sum, and the value will be the frequency of the sum.\\n\\n2. Iterate map1,  calculate each offset value (0 - current value). If the offset value is found in map2 then use get the frequency and multiply them, add to the total.\\n\\n\\n```\\nvar fourSumCount = function(A, B, C, D) {\\n  \\n\\tconst sumTwoList = function(x,y){\\n        let len = x.length;\\n        let result = new Map();\\n        for(let i = 0; i < len; i++){\\n            for(let j = 0; j < len; j++){\\n               let c = x[i] + y[j];\\n               result.set(c, result.get(c) + 1 || 1); \\n            }\\n        }\\n        return result;\\n    }\\n    \\n    let sum1 = sumTwoList(A,B);\\n    let sum2 = sumTwoList(C,D);\\n    let total = 0;\\n   \\n    sum1.forEach((value,key) =>{\\n        let offset = 0 - key;\\n        if(sum2.has(offset)){\\n            total += (sum2.get(offset) * sum1.get(key));\\n        }\\n    })\\n    return total;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar fourSumCount = function(A, B, C, D) {\\n  \\n\\tconst sumTwoList = function(x,y){\\n        let len = x.length;\\n        let result = new Map();\\n        for(let i = 0; i < len; i++){\\n            for(let j = 0; j < len; j++){\\n               let c = x[i] + y[j];\\n               result.set(c, result.get(c) + 1 || 1); \\n            }\\n        }\\n        return result;\\n    }\\n    \\n    let sum1 = sumTwoList(A,B);\\n    let sum2 = sumTwoList(C,D);\\n    let total = 0;\\n   \\n    sum1.forEach((value,key) =>{\\n        let offset = 0 - key;\\n        if(sum2.has(offset)){\\n            total += (sum2.get(offset) * sum1.get(key));\\n        }\\n    })\\n    return total;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975315,
                "title": "4sum-ii-o-n-2-10-lines-of-code-simple",
                "content": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n            for(int j=0;j<B.length;j++){\\n                map.putIfAbsent(A[i]+B[j],0);\\n                map.compute(A[i]+B[j],(key,val)->val+1);\\n            }\\n        int count=0;\\n        for(int i=0;i<C.length;i++)\\n            for(int j=0;j<D.length;j++)\\n                if(map.containsKey(-(C[i]+D[j])))\\n                    count+=map.get(-(C[i]+D[j]));\\n        return count;\\n    }\\n}\\n```\\n\\n**if you stuck somewhere or any questions let me know .If you like it please upvote It inspires me .Thank You**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n            for(int j=0;j<B.length;j++){\\n                map.putIfAbsent(A[i]+B[j],0);\\n                map.compute(A[i]+B[j],(key,val)->val+1);\\n            }\\n        int count=0;\\n        for(int i=0;i<C.length;i++)\\n            for(int j=0;j<D.length;j++)\\n                if(map.containsKey(-(C[i]+D[j])))\\n                    count+=map.get(-(C[i]+D[j]));\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975269,
                "title": "python-reduce-to-2-sum",
                "content": "Let `AB[x]` be the number of times we can get the value of `x` summing two elements from `A` and `B`. Define `CD[x]` similarly. Then there are `AB[x]*CD[-x]` ways to sum to `0` using a key value of `x`. Iterate over all such keys.\\n\\nTime: `O(N^2)`\\nSpace: `O(N^2)`\\n\\n```python\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSumCount(self, A, B, C, D):\\n        AB = defaultdict(int)\\n        for a in A:\\n            for b in B:\\n                AB[a+b] += 1\\n        \\n        CD = defaultdict(int)\\n        for c in C:\\n            for d in D:\\n                CD[c+d] += 1\\n        \\n        ans = 0\\n        for key in AB.keys():\\n            ans += AB[key]*CD[-key]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSumCount(self, A, B, C, D):\\n        AB = defaultdict(int)\\n        for a in A:\\n            for b in B:\\n                AB[a+b] += 1\\n        \\n        CD = defaultdict(int)\\n        for c in C:\\n            for d in D:\\n                CD[c+d] += 1\\n        \\n        ans = 0\\n        for key in AB.keys():\\n            ans += AB[key]*CD[-key]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489763,
                "title": "python-not-small-but-understandable-solution",
                "content": "```\\nclass Solution(object):\\n    def fourSumCount(self, A, B, C, D):\\n        count = 0\\n        N = len(A)\\n        sumAB = {}\\n        sumCD = {}\\n        for i in range(N):\\n            for j in range(N):\\n                if A[i] + B[j] in sumAB:\\n                    sumAB[A[i] + B[j]] += 1\\n                else:\\n                    sumAB[A[i] + B[j]] = 1\\n                if C[i] + D[j] in sumCD:\\n                    sumCD[C[i] + D[j]] += 1\\n                else:\\n                    sumCD[C[i] + D[j]] = 1\\n\\n        for key in sumAB:\\n            if -key in sumCD:\\n                count += sumAB[key]*sumCD[-key]\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fourSumCount(self, A, B, C, D):\\n        count = 0\\n        N = len(A)\\n        sumAB = {}\\n        sumCD = {}\\n        for i in range(N):\\n            for j in range(N):\\n                if A[i] + B[j] in sumAB:\\n                    sumAB[A[i] + B[j]] += 1\\n                else:\\n                    sumAB[A[i] + B[j]] = 1\\n                if C[i] + D[j] in sumCD:\\n                    sumCD[C[i] + D[j]] += 1\\n                else:\\n                    sumCD[C[i] + D[j]] = 1\\n\\n        for key in sumAB:\\n            if -key in sumCD:\\n                count += sumAB[key]*sumCD[-key]\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523917,
                "title": "c-easy-solution-explained-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n     \\n       // idea: a+b+c+d = 0  =>  a+b = -(c+d) ;\\n       // store a+b in hash map for first two array combinations\\n       // later for last two array combinations check if sum exist in array\\n    \\n       unordered_map<int, int> hmap; \\n        \\n       for( auto a: nums1){\\n           for(auto b: nums2){\\n               ++hmap[a+b]; // store and a+b and increment their frequencies also\\n           }\\n       }\\n        \\n      int count = 0;\\n      for(auto c: nums3){\\n          for(auto d: nums4){\\n              auto iter = hmap.find(0-c-d);\\n              if(iter != hmap.end() ){ \\n                  count+= iter->second; \\n                  // just incrementing count is not enough because duplicates tuple is also valid\\n              }\\n          }\\n      }\\n        \\n        \\n        return count;\\n    }\\n};\\n```\\n\\n##### Upvote if it has helped you. Thanks :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n     \\n       // idea: a+b+c+d = 0  =>  a+b = -(c+d) ;\\n       // store a+b in hash map for first two array combinations\\n       // later for last two array combinations check if sum exist in array\\n    \\n       unordered_map<int, int> hmap; \\n        \\n       for( auto a: nums1){\\n           for(auto b: nums2){\\n               ++hmap[a+b]; // store and a+b and increment their frequencies also\\n           }\\n       }\\n        \\n      int count = 0;\\n      for(auto c: nums3){\\n          for(auto d: nums4){\\n              auto iter = hmap.find(0-c-d);\\n              if(iter != hmap.end() ){ \\n                  count+= iter->second; \\n                  // just incrementing count is not enough because duplicates tuple is also valid\\n              }\\n          }\\n      }\\n        \\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975289,
                "title": "4-sum-ii-python-easy-to-understand",
                "content": "```\\ndef fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        \\n        h = dict()\\n        \\n        for a in A:\\n            for b in B:\\n                p = -(a+b)\\n                if p in h:\\n                    h[p]+=1\\n                else:\\n                    h[p]=1\\n        count=0\\n        \\n        for c in C:\\n            for d in D:\\n                p = c+d\\n                if p in h:\\n                    count+=h[p]\\n                    \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        \\n        h = dict()\\n        \\n        for a in A:\\n            for b in B:\\n                p = -(a+b)\\n                if p in h:\\n                    h[p]+=1\\n                else:\\n                    h[p]=1\\n        count=0\\n        \\n        for c in C:\\n            for d in D:\\n                p = c+d\\n                if p in h:\\n                    count+=h[p]\\n                    \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 975343,
                "title": "c-double-ended-dfs-solution-explained-98-time-90-space",
                "content": "This takes the same trick I already used in another couple of problems here, the one I learnt reading how LinkedIn computes and map your connections.\\n\\nThe main idea is to consider the whole graph of connections that you can achieve, but to tackle it from the 2 extremes: we will compute all the values we can achieve moving from `a` to `b` (or the other way around) and all the values we can get from `d` to `c` (same: order doess not really matter here).\\n\\nWe will then increase an accumulator variable by the product of the frequency each partial sum `x`  with the frequency of each matching `-x` partial sum in the other mapping.\\n\\nIn order to do so, we will first of all declare few support variables:\\n* `res` is our accumulator variable, storing the amount of matches summing up to `0` as we go;\\n* `abMap` and `cdMap` will store the partial sums we get from `a` to `b` and from `c` to `d`, respectively.\\n\\nAnd the 2 maps are the ones we will be populating initially, with a couple of simple nested loops.\\n\\nAfter that, we take each partial sum in `abMap` and look for a match (the same value with an opposite sign) in `cdMap` and, if any, we multiply the 2 respective frequencies and add them finally to `res`.\\n\\nOnce we are done, we can just return `res` :)\\n\\nLet\\'s clarify with an example, assuming this initial input:\\n\\n```cpp\\n[1,2,3,2]\\n[-2,-1,-3,-2]\\n[-1,2,4,-3]\\n[0,2,1,0]\\n```\\n\\nAfter we are done building the maps, we will have:\\n\\n```cpp\\n{1, 4}, {-2, 1}, {0, 6}, {2, 1}, {-1, 4} // abMap\\n{5, 1}, {6, 1}, {3, 1}, {4, 3}, {-3, 2}, {0, 1}, {-2, 1}, {1, 1}, {2, 2}, {-1, 3} // cdMap\\n```\\n\\nMeaning that in `abMap` for example we have `4` partial sums up to `1`, `1` partial sum up to `-2`, `6` partial sums up to `0`, etc.\\n\\nAnd then we can start looping from `abMap`, taking the first pair of `{value, frequence}` we stored there - as mentioned above, we would have `4` combinations of values from `a` ans `b` that sum up to `1`, so we look to see if we have partial sums up to `-1` in `cdMap` and since we have `3` of them, we increase `res` by `4 * 3 == 12`.\\n\\nGoing on, we find `1` occurrence of a partial sum up to `-2` and since we have `2` occurrences of partial sums up to `2` in `cdMap`, we then increase `res` by `1 * 2 == 2` and so on.\\n\\nIf you try to move across all the steps, you will ultimately return the correct expected result of `25` possible combinations here.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<int, int> abMap, cdMap;\\n        // populating abMap and cdMap as frequency tables of sums\\n        for (int i: a) for (int j: b) abMap[i + j]++;\\n        for (int i: c) for (int j: d) cdMap[i + j]++;\\n        // finding if we have opposite matches in abMap and cdMap\\n        for (auto e: abMap) {\\n            // looking for the pointer to the opposite element\\n            auto p = cdMap.find(-e.first);\\n            // if not we move on\\n            if (p == end(cdMap)) continue;\\n            // otherwise we update res\\n            res += e.second * p->second;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nI tried also a version in which we only loop through the smaller map and do not care if we access elements which are not there (and this means we create new ones that default to `0`, so the memory usage is about 50% more on average), but it really goes much slower:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<int, int> abMap, cdMap;\\n        // populating abMap and cdMap as frequency tables of sums\\n        for (int i: a) for (int j: b) abMap[i + j]++;\\n        for (int i: c) for (int j: d) cdMap[i + j]++;\\n        // making sure we loop through the smaller of the 2\\n        if (abMap.size() > cdMap.size()) swap(abMap, cdMap);\\n        // finding if we have opposite matches in abMap and cdMap\\n        for (auto e: abMap) {\\n            // otherwise we update res\\n            res += e.second * cdMap[-e.first];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd finally it dawned to me that actually a sole hashmap was enough and I could just compute and use results from the other on the fly, so here is my vastly optimised code, taking about half time and half space compared to the versions above:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<int, int> abMap;\\n        // populating abMap as frequency tables of sums\\n        for (int i: a) for (int j: b) abMap[i + j]++;\\n        // finding if we have opposite matches in abMap and cdMap\\n        for (int i: c) for (int j: d) {\\n            // looking for the pointer to the opposite element\\n            auto p = abMap.find(-i - j);\\n            // if not we move on\\n            if (p == end(abMap)) continue;\\n            // otherwise we update res\\n            res += p->second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\n[1,2,3,2]\\n[-2,-1,-3,-2]\\n[-1,2,4,-3]\\n[0,2,1,0]\\n```\n```cpp\\n{1, 4}, {-2, 1}, {0, 6}, {2, 1}, {-1, 4} // abMap\\n{5, 1}, {6, 1}, {3, 1}, {4, 3}, {-3, 2}, {0, 1}, {-2, 1}, {1, 1}, {2, 2}, {-1, 3} // cdMap\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<int, int> abMap, cdMap;\\n        // populating abMap and cdMap as frequency tables of sums\\n        for (int i: a) for (int j: b) abMap[i + j]++;\\n        for (int i: c) for (int j: d) cdMap[i + j]++;\\n        // finding if we have opposite matches in abMap and cdMap\\n        for (auto e: abMap) {\\n            // looking for the pointer to the opposite element\\n            auto p = cdMap.find(-e.first);\\n            // if not we move on\\n            if (p == end(cdMap)) continue;\\n            // otherwise we update res\\n            res += e.second * p->second;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<int, int> abMap, cdMap;\\n        // populating abMap and cdMap as frequency tables of sums\\n        for (int i: a) for (int j: b) abMap[i + j]++;\\n        for (int i: c) for (int j: d) cdMap[i + j]++;\\n        // making sure we loop through the smaller of the 2\\n        if (abMap.size() > cdMap.size()) swap(abMap, cdMap);\\n        // finding if we have opposite matches in abMap and cdMap\\n        for (auto e: abMap) {\\n            // otherwise we update res\\n            res += e.second * cdMap[-e.first];\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<int, int> abMap;\\n        // populating abMap as frequency tables of sums\\n        for (int i: a) for (int j: b) abMap[i + j]++;\\n        // finding if we have opposite matches in abMap and cdMap\\n        for (int i: c) for (int j: d) {\\n            // looking for the pointer to the opposite element\\n            auto p = abMap.find(-i - j);\\n            // if not we move on\\n            if (p == end(abMap)) continue;\\n            // otherwise we update res\\n            res += p->second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743403,
                "title": "easy-c-solution-using-hashmap-with-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we are storing all possible addition of the first 2 vectors in a hashmap.\\n- Then we\\u2019re adding all combinations from the last 2 vectors and searched for the negative value from the map, it took O(1) time.\\n- If the value is present that means the addition of all 4 will be 0, so we increase the count.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n = nums1.size(), count=0;\\n        unordered_map<int, int> mp;\\n        \\n        for(auto i:nums1){\\n            for(auto j:nums2){\\n                mp[i+j]++;\\n            }\\n        }\\n        \\n        for(auto i:nums3){\\n            for(auto j:nums4){\\n                if(mp.find(0-(i+j)) != mp.end())\\n                    count += mp[0-(i+j)];\\n            }\\n        }\\n        return count;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n = nums1.size(), count=0;\\n        unordered_map<int, int> mp;\\n        \\n        for(auto i:nums1){\\n            for(auto j:nums2){\\n                mp[i+j]++;\\n            }\\n        }\\n        \\n        for(auto i:nums3){\\n            for(auto j:nums4){\\n                if(mp.find(0-(i+j)) != mp.end())\\n                    count += mp[0-(i+j)];\\n            }\\n        }\\n        return count;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741216,
                "title": "extremely-naive-to-optimal-step-by-step-explained",
                "content": "**NOTE: The first two approaches will give you TLE. I discussed them so that you can reach to the optimal solution step by step!**\\n\\n\\n**APPROACH-1: Brute Force (The Naive One)**\\n\\n**IDEA:** As you all can see, if we use four loops to form all possible combinations we\\'ll be able to get our answer. But, due to its high TC it won\\'t pass all the Test Cases :(\\n\\n**TC: O(N^4)**, Very poor\\n**SC: O(1) **\\n   \\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4){\\n        int count=0;\\n        for(auto val1:nums1){\\n            for(auto val2:nums2){\\n                for(auto val3:nums3){\\n                    for(auto val4:nums4){\\n                        if(val1+val2+val3+val4==0) count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n\\n\\n**APPROACH-2: A Better Approach**\\n\\n**IDEA:** We haven\\'t used any aux space in our previous solution. So, let\\'s see if we can reduce the TC by using some aux space.\\nYes, we can do so. If we store the 4-th input in an unordered_map we can reduce one loop from our solution, because we\\'ll be able to fetch data from the map in O(1). Let\\'s see how we do that-\\n\\n**TC: O(N^3)\\nSC: O(N)**, as we have used map to store a vector of size N *(Remember- In unorderedmap the TC can become O(N) for its operations in worst case)*\\n\\n**NOTE:** This solution will still give you TLE for larger input values\\n\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4){\\n        int count=0;\\n        unordered_map<int, int> mp;\\n        \\n        for(auto val4:nums4){  \\n            mp[val4]++;   //storing the frequencies\\n        }\\n        \\n        for(auto val1:nums1){\\n            for(auto val2:nums2){\\n                for(auto val3:nums3){ \\n                    count+=mp[-(val1+val2+val3)];    //adding the frequencies (not incrementing by 1), because they all will have different contribution if any value is present in  nums4 more than once\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n\\n\\n**APPROACH-3: Optimal**\\n\\n**IDEA:** Here we almost think the same way we did to come out with our approach-2\\nWe reduce one more for loop by using the map. And for that we store the sum of val3 and val4 (val3=value from nums3, and val4= value from nums4)\\n\\n**NOTE:** As we are storing the sum of val3 and val4, we have to store the frequencies of all the possible (val3, val4), and for that reason our SC can become O(N^2) in worst case.\\n\\n\\n**TC: O(N^2),** because still we have two for loops there\\n**SC: O(N^2),** as I explained before\\n\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int count=0;\\n        unordered_map<int,int> mp;\\n        \\n\\t\\t//storing the frequencies of all (val1+val2)\\n        for(auto val3:nums3){\\n            for(auto val4: nums4){\\n                mp[val3+val4]++;\\n            }\\n        }\\n        \\n        for(auto val1:nums1){\\n            for(auto val2:nums2){\\n                 count+=mp[-(val1+val2)];  //checking if -(val1+val2) is present in our map\\n            }\\n        }\\n        return count;\\n    }\\n\\t\\n\\t\\n***Hope It Helps! :)***",
                "solutionTags": [],
                "code": "**NOTE: The first two approaches will give you TLE. I discussed them so that you can reach to the optimal solution step by step!**\\n\\n\\n**APPROACH-1: Brute Force (The Naive One)**\\n\\n**IDEA:** As you all can see, if we use four loops to form all possible combinations we\\'ll be able to get our answer. But, due to its high TC it won\\'t pass all the Test Cases :(\\n\\n**TC: O(N^4)**, Very poor\\n**SC: O(1) **\\n   \\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4){\\n        int count=0;\\n        for(auto val1:nums1){\\n            for(auto val2:nums2){\\n                for(auto val3:nums3){\\n                    for(auto val4:nums4){\\n                        if(val1+val2+val3+val4==0) count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n\\n\\n**APPROACH-2: A Better Approach**\\n\\n**IDEA:** We haven\\'t used any aux space in our previous solution. So, let\\'s see if we can reduce the TC by using some aux space.\\nYes, we can do so. If we store the 4-th input in an unordered_map we can reduce one loop from our solution, because we\\'ll be able to fetch data from the map in O(1). Let\\'s see how we do that-\\n\\n**TC: O(N^3)\\nSC: O(N)**, as we have used map to store a vector of size N *(Remember- In unorderedmap the TC can become O(N) for its operations in worst case)*\\n\\n**NOTE:** This solution will still give you TLE for larger input values\\n\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4){\\n        int count=0;\\n        unordered_map<int, int> mp;\\n        \\n        for(auto val4:nums4){  \\n            mp[val4]++;   //storing the frequencies\\n        }\\n        \\n        for(auto val1:nums1){\\n            for(auto val2:nums2){\\n                for(auto val3:nums3){ \\n                    count+=mp[-(val1+val2+val3)];    //adding the frequencies (not incrementing by 1), because they all will have different contribution if any value is present in  nums4 more than once\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n\\n\\n**APPROACH-3: Optimal**\\n\\n**IDEA:** Here we almost think the same way we did to come out with our approach-2\\nWe reduce one more for loop by using the map. And for that we store the sum of val3 and val4 (val3=value from nums3, and val4= value from nums4)\\n\\n**NOTE:** As we are storing the sum of val3 and val4, we have to store the frequencies of all the possible (val3, val4), and for that reason our SC can become O(N^2) in worst case.\\n\\n\\n**TC: O(N^2),** because still we have two for loops there\\n**SC: O(N^2),** as I explained before\\n\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int count=0;\\n        unordered_map<int,int> mp;\\n        \\n\\t\\t//storing the frequencies of all (val1+val2)\\n        for(auto val3:nums3){\\n            for(auto val4: nums4){\\n                mp[val3+val4]++;\\n            }\\n        }\\n        \\n        for(auto val1:nums1){\\n            for(auto val2:nums2){\\n                 count+=mp[-(val1+val2)];  //checking if -(val1+val2) is present in our map\\n            }\\n        }\\n        return count;\\n    }\\n\\t\\n\\t\\n***Hope It Helps! :)***",
                "codeTag": "Unknown"
            },
            {
                "id": 235749,
                "title": "c-solution-easy-to-understand-detailed-explained",
                "content": "We know we can do the question with time complexity of BigO(n^4) by iterating over every possible values of A,B,C,D. But that will get you TLE.\\nSo, Let\\'s get the thinking process as solution is very easy. What I thought was if i had only two list that is A,B i could iterate over every element of A and try to find if there is any element in B present which can sum up with A\\'s element to give sum zero. The finding thing can be easily done by binary_search or maps.\\nSo I concluded I just have to convert these 4 arrays to 2. and DONE here this question ends. thats all you need to think\\n\\nmerge A,B (iterate every element of A and add it to every element of B and store the sum in an array/vector).\\nsimilarly merge C,D (store the count of each sum in map that is what I used).\\nFinally,\\niterate the merged array formed by merging A,B and search map for element that will sum up to zero.\\n\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        vector<int> v;\\n\\t\\t//Merge A,B and store result in vector v\\n        for(int i=0;i<a.size();i++){\\n            for(int j=0;j<b.size();j++){\\n                v.push_back(a[i]+b[j]);\\n            }\\n        }\\n        map<int,int> m;\\n\\t\\t//Merge C,D and store count in map m\\n        for(int i=0;i<c.size();i++){\\n            for(int j=0;j<d.size();j++){\\n                m[c[i]+d[j]]++;\\n            }\\n        }\\n        //Iterate over every element in Merged vector and find the number of elements that sum up to zero\\n        int ans=0;\\n        for(int i=0;i<v.size();i++){\\n            ans+=m[-v[i]];\\n        }\\n        return ans;  //return the final answer\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        vector<int> v;\\n\\t\\t//Merge A,B and store result in vector v\\n        for(int i=0;i<a.size();i++){\\n            for(int j=0;j<b.size();j++){\\n                v.push_back(a[i]+b[j]);\\n            }\\n        }\\n        map<int,int> m;\\n\\t\\t//Merge C,D and store count in map m\\n        for(int i=0;i<c.size();i++){\\n            for(int j=0;j<d.size();j++){\\n                m[c[i]+d[j]]++;\\n            }\\n        }\\n        //Iterate over every element in Merged vector and find the number of elements that sum up to zero\\n        int ans=0;\\n        for(int i=0;i<v.size();i++){\\n            ans+=m[-v[i]];\\n        }\\n        return ans;  //return the final answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741781,
                "title": "c-simple-solution-w-explanation-step-by-step-solution-o-n-4-to-o-n-3-to-o-n-2",
                "content": "***Brief note about Question-***\\n\\nWe have to count *tuples* such that -\\n\\n`nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`\\n`where 0 <= i, j, k, l < n and n is the length of each array`\\n_____________________________________________________________________________________________\\n\\n***Solution - I (Most basic approach, TLE)***\\n\\nOkay, so the most basic approach we can think of is, we are are obedient person, and not to do anything extra from ourself,\\nwe simply do, what the question wants us to do, i.e we run four(4) loops naming i, j, k, l by trying out every possiblity and when we get our sum as zero, simply we increment our count.\\n    So, obviously it gives us **TLE**, but no problem we will find a way to optimise it further, \\n    therefore,\\n\\t\\n\\tTime Complexity --> O(n ^ 4) &\\n    Space Complexity --> O(1)\\n\\tIt paases [ 20 / 132 ] in built test cases\\n**Code (C++)**\\n```\\nclass Solution {\\npublic: \\n    int fourSumCount(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3, vector<int>& arr4) {\\n        int n = arr1.size();// since length of all arrays are same,so we called it  as \\'n\\'\\n        \\n        int count = 0; // to count our tuples\\n        \\n        // running 4 loops\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                for(int k = 0; k < n; k++)\\n                {\\n                    for(int l = 0; l < n; l++)\\n                    {\\n                        if(arr1[i] + arr2[j] + arr3[k] + arr4[l] == 0)\\n                        {\\n                            count++; // everytime we got an answer increment count\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n_____________________________________________________________________________________________\\n\\n***Solution - II (Further Optimisation but still TLE)***\\n\\n1) After getting TLE, Now, we want to become a good programmer, therefore we start thinking that how we may optimise it, so on observing carefully, we came to a conclusion that, why not try to store array 4 somewhere from which we don\\'t have to run an extra loop, so we will use an unordered map.\\n2) So, we will use a map and store all the elements of 4th array and after running three loops we will check whether the remainng value is present in our map or not.\\n\\n    so **A question arises why, why we use an unordered map ?**\\n    *Ans - we use an unordered map to store all the elements of 4th array and use **find function** to find the remaining element as the **Time complexity of find function in an unordered map is O(1) on average**, so this will reduce a burden of an extra loop from us.*\\n\\ttherefore,\\n\\n```\\nTime Complexity is --> O(n ^ 3)&\\nSpace Complexity is --> O(n) (As we use an unordered map to store the elemnts of 4th array)\\nIt passes [53 / 132] in built test cases\\n```\\n\\n**Code (C++)**\\n```\\nclass Solution {\\npublic: \\n    int fourSumCount(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3, vector<int>& arr4) {\\n        int n = arr1.size();// since length of all arrays are same,so we called it  as \\'n\\'\\n        \\n        int count = 0; // to count our tuples\\n        \\n        // make an unordered_map to store elements of 4th array\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr4[i]]++; // storing elements\\n        }\\n        \\n        // running 3 loops\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                for(int k = 0; k < n; k++)\\n                {\\n                    // remaining element to find out\\n                    int remaining = 0 - (arr1[i] + arr2[j] + arr3[k]);\\n                    \\n                    // if element is present\\n                    if(mp.find(remaining) != mp.end())\\n                    {\\n                        // add element in our count that how many times it is present in our map\\n                        count += mp[remaining];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count; // simply return count\\n    }\\n};\\n```\\n________________________________________________________________________________________\\n***Solution - III (Further Optimisation and yes correct answer)***\\n1) Aah, We try Hard but still we got TLE, okay no problem, we are hardworking guy, we will find a way to make it AC.\\n2) So, again we start thinking to our previous soloution, what we may further do to optimise it. And Now at this staze we know that O(n ^ 3) not worked so we have to do it in O(n ^ 2) and also we know this using unordered map we can do it.\\n3) Now, We think instead of just storing all the elements of 4th array, may we are able to store some more elements to it, and we conclude that yes!!, ***first we will store the sum of first two arrays in our unordered map and then we will use a very basic maths type thing.***\\n4) See, We have to find the number of tuples such that\\n      ```\\n    nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\\n    -> nums1[i] + nums2[j] == -(nums3[k] + nums4[l])\\n    ```\\n    that\\'s it, we have to just do this,\\n    \\n    So, On concluding, what we will have to do?\\n    1) Store sum of first and second array in our unordered map.\\n    2) Then just multiply by -1 we have to find that whether sum of third and fourth array is present in map or not,\\n    If present then simply increase the count\\n    3) simply return the count.\\n    Therefore,\\n```\\nTime Complexity --> O(n ^ 2) &\\nSpace Complexity --> O(n) (As we use an unordered map to store the sum of elements of first two arrays)\\nIt paases [ 132 / 132 ] in built test cases\\n```\\n\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3, vector<int>& arr4) {\\n        int n = arr1.size();// since length of all arrays are same,so we called it  as \\'n\\'\\n        \\n        // make an unordered map to store sum of first and second array into the map\\n        unordered_map<int,int> mp;\\n           \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int sum = arr1[i] + arr2[j];\\n                mp[sum]++; // storing sum of first and second array\\n            }\\n        }\\n        \\n        int count = 0; // variable count which gives us  number of tuples\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                // make a variable to find from third and fourth array\\n                int to_find = -1 * (arr3[i] + arr4[j]);\\n                \\n                // if this present in our map\\n                if(mp.find(to_find) != mp.end())\\n                {\\n                    // add in our count that how many times it is present in our map\\n                    count += mp[to_find];\\n                }\\n            }\\n        }\\n        \\n        return count; // simply return count\\n    }\\n};\\n```\\n\\n***`If u like this, please consider to give a upvote!!`***\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int fourSumCount(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3, vector<int>& arr4) {\\n        int n = arr1.size();// since length of all arrays are same,so we called it  as \\'n\\'\\n        \\n        int count = 0; // to count our tuples\\n        \\n        // running 4 loops\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                for(int k = 0; k < n; k++)\\n                {\\n                    for(int l = 0; l < n; l++)\\n                    {\\n                        if(arr1[i] + arr2[j] + arr3[k] + arr4[l] == 0)\\n                        {\\n                            count++; // everytime we got an answer increment count\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nTime Complexity is --> O(n ^ 3)&\\nSpace Complexity is --> O(n) (As we use an unordered map to store the elemnts of 4th array)\\nIt passes [53 / 132] in built test cases\\n```\n```\\nclass Solution {\\npublic: \\n    int fourSumCount(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3, vector<int>& arr4) {\\n        int n = arr1.size();// since length of all arrays are same,so we called it  as \\'n\\'\\n        \\n        int count = 0; // to count our tuples\\n        \\n        // make an unordered_map to store elements of 4th array\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr4[i]]++; // storing elements\\n        }\\n        \\n        // running 3 loops\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                for(int k = 0; k < n; k++)\\n                {\\n                    // remaining element to find out\\n                    int remaining = 0 - (arr1[i] + arr2[j] + arr3[k]);\\n                    \\n                    // if element is present\\n                    if(mp.find(remaining) != mp.end())\\n                    {\\n                        // add element in our count that how many times it is present in our map\\n                        count += mp[remaining];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count; // simply return count\\n    }\\n};\\n```\n```\\n    nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\\n    -> nums1[i] + nums2[j] == -(nums3[k] + nums4[l])\\n    ```\n```\\nTime Complexity --> O(n ^ 2) &\\nSpace Complexity --> O(n) (As we use an unordered map to store the sum of elements of first two arrays)\\nIt paases [ 132 / 132 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3, vector<int>& arr4) {\\n        int n = arr1.size();// since length of all arrays are same,so we called it  as \\'n\\'\\n        \\n        // make an unordered map to store sum of first and second array into the map\\n        unordered_map<int,int> mp;\\n           \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int sum = arr1[i] + arr2[j];\\n                mp[sum]++; // storing sum of first and second array\\n            }\\n        }\\n        \\n        int count = 0; // variable count which gives us  number of tuples\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                // make a variable to find from third and fourth array\\n                int to_find = -1 * (arr3[i] + arr4[j]);\\n                \\n                // if this present in our map\\n                if(mp.find(to_find) != mp.end())\\n                {\\n                    // add in our count that how many times it is present in our map\\n                    count += mp[to_find];\\n                }\\n            }\\n        }\\n        \\n        return count; // simply return count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976025,
                "title": "easy-c-faster-than-99-8-lines-of-code",
                "content": "If we observe the constrants we have` N can be` as large as `500` and we have **4 different arrays** at which in the worst case have **N^4** time complexity (**500^4**) which is **not a real solution** to our problem when **we use brute force**.\\n\\nSo we need to consider a better approach at which we **use** the **problem statment**  (`A+B+C+D=0`) which is as same as `A+B=-(C+D)`.\\n\\nFrom the equation we can see if we use an `unordered_map` to store the `negation` of `(A+B)` and **check** if it\\'s found in **C+D values** which solves the problem in **O(N^2)** time & space complexities.\\n```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C,\\n                 vector<int>& D) {\\n  unordered_map<int, int> umap;\\n  for (int x : A)\\n    for (int y : B) umap[-(x + y)]++;\\n  int count = 0;\\n  for (int x : C)\\n    for (int y : D)\\n      if (umap.find(x + y) != umap.end()) count += umap[x + y];\\n  return count;\\n}\\n```\\nIf you have any questions, drop them below\\u2B07 and if you like my solution, **UP VOTE** it \\uD83D\\uDD25\\n",
                "solutionTags": [],
                "code": "```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C,\\n                 vector<int>& D) {\\n  unordered_map<int, int> umap;\\n  for (int x : A)\\n    for (int y : B) umap[-(x + y)]++;\\n  int count = 0;\\n  for (int x : C)\\n    for (int y : D)\\n      if (umap.find(x + y) != umap.end()) count += umap[x + y];\\n  return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975332,
                "title": "4-sum-ii-c-map-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n    \\n      \\n      unordered_map<int,int> umap1,umap2;\\n      \\n      int n=A.size(),count=0;\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n        for(int j=0;j<n;j++)\\n        {\\n          umap1[A[i]+B[j]]++;\\n          umap2[C[i]+D[j]]++;\\n          \\n        }\\n      }\\n      \\n      for(auto x : umap1)\\n      {\\n        int num=x.first;\\n        \\n        if(umap2.find(-1*num)!=umap2.end())\\n          count+=x.second*umap2[-1*num];\\n         \\n      }\\n            \\n      return count;\\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n    \\n      \\n      unordered_map<int,int> umap1,umap2;\\n      \\n      int n=A.size(),count=0;\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n        for(int j=0;j<n;j++)\\n        {\\n          umap1[A[i]+B[j]]++;\\n          umap2[C[i]+D[j]]++;\\n          \\n        }\\n      }\\n      \\n      for(auto x : umap1)\\n      {\\n        int num=x.first;\\n        \\n        if(umap2.find(-1*num)!=umap2.end())\\n          count+=x.second*umap2[-1*num];\\n         \\n      }\\n            \\n      return count;\\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606609,
                "title": "shortest-solution-you-can-get-c",
                "content": "**If needed explanation please comment.\\nUpvotes are appreciated**\\n```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n       unordered_map<int,int> mp;\\n        for(auto i:A){\\n            for(auto j:B)\\n                mp[i+j]++;\\n        }\\n        int ans=0;\\n        for(auto i:C){\\n            for(auto j:D)\\n                if(mp.find(-i-j)!=mp.end())\\n                    ans+=mp[-i-j];\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n       unordered_map<int,int> mp;\\n        for(auto i:A){\\n            for(auto j:B)\\n                mp[i+j]++;\\n        }\\n        int ans=0;\\n        for(auto i:C){\\n            for(auto j:D)\\n                if(mp.find(-i-j)!=mp.end())\\n                    ans+=mp[-i-j];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389019,
                "title": "python-using-dictionary",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        res, d = 0, {}\\n        for n1 in A:\\n            for n2 in B:\\n                tmp = n1 + n2\\n                if tmp in d: d[tmp] += 1\\n                else: d[tmp] = 1\\n            \\n        for n1 in C:\\n            for n2 in D:\\n                tmp = 0  - (n1 + n2)\\n                if tmp in d: \\n                    res += d[tmp]\\n        return res        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        res, d = 0, {}\\n        for n1 in A:\\n            for n2 in B:\\n                tmp = n1 + n2\\n                if tmp in d: d[tmp] += 1\\n                else: d[tmp] = 1\\n            \\n        for n1 in C:\\n            for n2 in D:\\n                tmp = 0  - (n1 + n2)\\n                if tmp in d: \\n                    res += d[tmp]\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 93941,
                "title": "concise-hash-map-o-n-2-solution-with-explanation-c",
                "content": "Using 2 hash maps for each of possible sums in both (A,B) and (C,D) find number of occurrences of this sum. Then, for each sum in (A,B) we can find if (C,D) contains complimentary sum. Add (this sum occurrences(a,b)) * (complimentary sum occurrences(c,d)) to the result.\\n```\\nclass Solution {\\npublic:\\n    void fillMap(vector<int>& A, vector<int>& B, unordered_map<int,int> &m)\\n    {\\n        int n = A.size();\\n        for(int i = 0; i < n; ++i)\\n        for(int j = 0; j < n; ++j)\\n          ++m[A[i] + B[j]];\\n          \\n    }\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int,int> m1, m2;\\n        fillMap(A, B, m1);\\n        fillMap(C, D, m2);\\n        int res = 0;\\n        for(auto it = m1.begin(); it != m1.end(); ++it)\\n        {\\n           auto it2 = m2.find(-it->first);\\n           if(it2 != m2.end())\\n             res += it->second*it2->second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fillMap(vector<int>& A, vector<int>& B, unordered_map<int,int> &m)\\n    {\\n        int n = A.size();\\n        for(int i = 0; i < n; ++i)\\n        for(int j = 0; j < n; ++j)\\n          ++m[A[i] + B[j]];\\n          \\n    }\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int,int> m1, m2;\\n        fillMap(A, B, m1);\\n        fillMap(C, D, m2);\\n        int res = 0;\\n        for(auto it = m1.begin(); it != m1.end(); ++it)\\n        {\\n           auto it2 = m2.find(-it->first);\\n           if(it2 != m2.end())\\n             res += it->second*it2->second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740803,
                "title": "4sum-ii-easy-solution-faster-than-98",
                "content": "#### **If you find this post helpful please upvote**\\n\\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        lookup = {}\\n        \\n\\t\\t# Finding the 2sum and adding in lookup.\\n        for i in nums1:\\n            for j in nums2:\\n                s = i+j\\n                if s not in lookup:\\n                    lookup[s] = 0\\n                lookup[s] += 1\\n        \\n        ans = 0\\n\\t\\t# Find the 2sum and checking in lookup whether the negative is present or not.\\n        for i in nums3:\\n            for j in nums4:\\n                s = i + j\\n                if -s in lookup:\\n                    ans += lookup[-s]\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        lookup = {}\\n        \\n\\t\\t# Finding the 2sum and adding in lookup.\\n        for i in nums1:\\n            for j in nums2:\\n                s = i+j\\n                if s not in lookup:\\n                    lookup[s] = 0\\n                lookup[s] += 1\\n        \\n        ans = 0\\n\\t\\t# Find the 2sum and checking in lookup whether the negative is present or not.\\n        for i in nums3:\\n            for j in nums4:\\n                s = i + j\\n                if -s in lookup:\\n                    ans += lookup[-s]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194735,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int n=nums1.length;\\n        int count=0;\\n\\t\\tHashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint sum=nums1[i]+nums2[j];\\n\\t\\t\\t\\tmap.put(-sum, map.getOrDefault(-sum, 0)+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint sum=nums3[i]+nums4[j];\\n\\t\\t\\t\\tcount=count+map.getOrDefault(sum, 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int n=nums1.length;\\n        int count=0;\\n\\t\\tHashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint sum=nums1[i]+nums2[j];\\n\\t\\t\\t\\tmap.put(-sum, map.getOrDefault(-sum, 0)+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint sum=nums3[i]+nums4[j];\\n\\t\\t\\t\\tcount=count+map.getOrDefault(sum, 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544243,
                "title": "c-o-n-n",
                "content": "```cpp\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D, int res = 0) {\\n    unordered_map<int, int> m;\\n    for (auto a : A)\\n        for (auto b : B) ++m[a + b];\\n     for (auto c : C)\\n        for (auto d : D) {\\n            auto it = m.find(- c - d);\\n            if (it != end(m))\\n                res += it->second;            \\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D, int res = 0) {\\n    unordered_map<int, int> m;\\n    for (auto a : A)\\n        for (auto b : B) ++m[a + b];\\n     for (auto c : C)\\n        for (auto d : D) {\\n            auto it = m.find(- c - d);\\n            if (it != end(m))\\n                res += it->second;            \\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93951,
                "title": "javascript-solution",
                "content": "```\\nvar fourSumCount = function(A, B, C, D) {\\n    var mp = {};\\n    \\n    for(var i=0; i<C.length; i++) {\\n        for(var j=0; j<D.length; j++) {\\n            var sum = C[i] + D[j];\\n            mp[sum] = mp[sum] + 1 || 1;\\n        }\\n    }\\n    \\n    var res=0;\\n    for(var i=0; i<A.length; i++) {\\n        for(var j=0; j<B.length; j++) {\\n            res += mp[-1 * (A[i]+B[j])] || 0;\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar fourSumCount = function(A, B, C, D) {\\n    var mp = {};\\n    \\n    for(var i=0; i<C.length; i++) {\\n        for(var j=0; j<D.length; j++) {\\n            var sum = C[i] + D[j];\\n            mp[sum] = mp[sum] + 1 || 1;\\n        }\\n    }\\n    \\n    var res=0;\\n    for(var i=0; i<A.length; i++) {\\n        for(var j=0; j<B.length; j++) {\\n            res += mp[-1 * (A[i]+B[j])] || 0;\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653304,
                "title": "c-o-n-2-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) \\n    {\\n        unordered_map<int,int> m;\\n        int ans =0;\\n        for(int i =0;i<nums1.size();i++)\\n        {\\n            for(int j =0;j<nums2.size();j++)\\n            {\\n                m[nums1[i] + nums2[j]]++;\\n                \\n            }\\n        }\\n        for(int k = 0;k<nums3.size();k++)\\n        {\\n            for(int z=0;z<nums4.size();z++)\\n            {\\n                int val = -1*(nums3[k]+nums4[z]);\\n                if(m.find(val) != m.end())\\n                {\\n                    ans = ans + m[val];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) \\n    {\\n        unordered_map<int,int> m;\\n        int ans =0;\\n        for(int i =0;i<nums1.size();i++)\\n        {\\n            for(int j =0;j<nums2.size();j++)\\n            {\\n                m[nums1[i] + nums2[j]]++;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1314440,
                "title": "java-easy",
                "content": "class Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        \\tHashMap<Integer , Integer> map = new HashMap<>();\\n        \\n            for(int a : nums1){\\n                for(int b : nums2){\\n                     map.put(a + b , map.getOrDefault((a + b) , 0) + 1);\\n                }\\n            }\\n            int target = 0;\\n            int count = 0;\\n\\n           for(int c : nums3){\\n               for(int d : nums4){\\n                    count += map.getOrDefault(target - (c+d) , 0);\\n               }\\n            }\\n             return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        \\tHashMap<Integer , Integer> map = new HashMap<>();\\n        \\n            for(int a : nums1){\\n                for(int b : nums2){\\n                     map.put(a + b , map.getOrDefault((a + b) , 0) + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1289267,
                "title": "c-easy-solution-with-intuition-using-std-unordered-map",
                "content": "## Basic Idea of Question\\nWe are given four arrays of equal length, and we have to return the number of quadruplets that add up to zero.\\ni.e 0<= i, j, k, l<=n such that A[i] + B[j] + C[k] + D[l] = 0, where n is the length of the arrays.\\n\\nThe most naive approach to this question would be to just calculate all possible sums of quadruplets in the four arrays and count those which are zero. When implemented most naively, (i.e with four nested loops, one for each array), it costs us runtime of **O(n<sup>4</sup>)**, which is laughable, but it\\'s a start, nonetheless!\\n<br/>\\n\\n## Approach 1: (TLE)\\nOne improvement in this solution comes from the fact that once we select three numbers, we know what to find in the fourth array, (which is equal to -(A[i] + B[j] + C[k])) if we can count these elements in the fourth array quicker than O(n), we can improve the complexity of the solution.\\nSo, let\\'s use a hashmap to represent the array D. Each entry in the hashmap maps the element to its frequency in the array.\\n\\nHere is the code for this approach:\\n```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n\\tunordered_map<int, int> hashmap;\\n\\tint n = A.size();\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\thashmap[D[i]]++;\\n\\t}\\n\\tint cnt = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tfor(int k = 0; k<n; k++) {\\n\\t\\t\\t\\tint x = A[i] + B[j] + C[k];\\n\\t\\t\\t\\t//we have to find -x in D\\n\\t\\t\\t\\tif(hashmap[-x]) {\\n\\t\\t\\t\\t\\tcnt += hashmap[-x];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n```\\n\\n**Time: O(n<sup>3</sup>)**. We select three elements with n choices each O(n<sup>3</sup>), and the last one is checked and updated in O(1).\\n**Space: O(n)**. In the worst case, all the elements of D are different, then we will have to store n entries in our hashmap.\\n\\nThis solution only passed around 50% of the test cases, and gave Time Limit Exceeded on the next test case. So the judge wants a better solution than this.\\n<br/>\\n\\n## Approach 2: Accepted, an observation\\nInstead of selecting three elements, can we get away with selecting just two? Why, yes, but we would need to know the sum of all pairs of the remaining two arrays, so that we can check the existence of any sum pair in O(1).\\nSo our hashmap will now contain the occurence of all possible pair sums in C and D, and we iterate over A and B, checking if -(A[i] + B[j]) is present, if yes the count is incremented by its frequency in the sum space.\\n\\nThe code for this solution is as follows:\\n```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n\\tunordered_map<int, int> hashmap;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\t++hashmap[C[i] + D[j]];\\n\\t\\t}\\n\\t}\\n\\tint cnt = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tint x = A[i] + B[j];\\n\\t\\t\\t//we have to find -x\\n\\t\\t\\tif(hashmap[-x]) cnt+=hashmap[-x];\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n```\\n\\n**Time: O(n<sup>2</sup>)**. Both the initial filling of the hashmap and the checking of pairs are O(n<sup>2</sup>) operations.\\n**Space: O(n<sup>2</sup>)**. In the worst case, there are n<sup>2</sup> possible unique sum pairs for C and D, which occupy one place each in the hashmap.\\n\\nThis solution was accepted on the platform. But still there is one quark here. If the number of unique sum  pairs in A and B is very less, then also this solution performs with the same time complexity, while this could be improved. \\n<br/>\\n\\n## Approach 3: Not much gain here, but could be worth it on real data\\nWe can use a similar hashmap to record the sum pairs of A and B as well. This way, we will only check the unique sum pairs of A and B with the unique sum pairs of C and D, which may prove much more efficient on redundant data, which is very common on real data.\\nThe worst case complexity is still the same, but the average runtime will improve drastically with reduction in the number of unique sum pairs.\\nWe iterate over the unique sum pairs of A and B and check if their complement (i.e -(A[i] + B[j])) exists in our second hashmap, if yes, we increment the count with the product of the counts of the respective pairs in A and B, and C and D (i.e hashmap1[x] * hashmap2[-x]).\\n\\nHere is the code for this approach:\\n```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n\\tunordered_map hashmap1, hashmap2;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\t++hashmap1[A[i] + B[j]];\\n\\t\\t\\t++hashmap2[C[i] + D[j]];\\n\\t\\t}\\n\\t}\\n\\tint cnt = 0;\\n\\tfor(auto& h: hashmap1) {\\n\\t\\tif(hashmap2[-h.first]) {\\n\\t\\t\\tcnt += h.second * hashmap2[-h.first];\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n```\\n\\nThe worst case time and space complexities are the same as approach 2, but it performs much better than approach 2 if the data in A and B is highly redundant.\\n\\nFeel free to ask any doubts or suggest any corrections/improvements in the comments.\\nIf you liked this post, please upvote it!\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n\\tunordered_map<int, int> hashmap;\\n\\tint n = A.size();\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\thashmap[D[i]]++;\\n\\t}\\n\\tint cnt = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tfor(int k = 0; k<n; k++) {\\n\\t\\t\\t\\tint x = A[i] + B[j] + C[k];\\n\\t\\t\\t\\t//we have to find -x in D\\n\\t\\t\\t\\tif(hashmap[-x]) {\\n\\t\\t\\t\\t\\tcnt += hashmap[-x];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n```\n```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n\\tunordered_map<int, int> hashmap;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\t++hashmap[C[i] + D[j]];\\n\\t\\t}\\n\\t}\\n\\tint cnt = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\tint x = A[i] + B[j];\\n\\t\\t\\t//we have to find -x\\n\\t\\t\\tif(hashmap[-x]) cnt+=hashmap[-x];\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n```\n```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n\\tunordered_map hashmap1, hashmap2;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n; j++) {\\n\\t\\t\\t++hashmap1[A[i] + B[j]];\\n\\t\\t\\t++hashmap2[C[i] + D[j]];\\n\\t\\t}\\n\\t}\\n\\tint cnt = 0;\\n\\tfor(auto& h: hashmap1) {\\n\\t\\tif(hashmap2[-h.first]) {\\n\\t\\t\\tcnt += h.second * hashmap2[-h.first];\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975672,
                "title": "c-python-4sum-2sum-2sum-hashmap",
                "content": "C++\\n```\\nclass Solution { //hashmap\\npublic: // Time/Space Complexity: O(N^2)\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int ans = 0;\\n        unordered_map<int, int> m;\\n        for(int a: A)\\n            for(int b: B)\\n                ++m[a+b];\\n        for(int c: C)\\n            for(int d: D)\\n                ans+=m[-(c+d)];\\n        return ans;\\n    }\\n};\\n```\\n\\nPython:\\n```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        ans = 0\\n        m = {}\\n        for a in A:\\n            for b in B:\\n                m[a + b] = m.get(a + b, 0) + 1\\n        for c in C:\\n            for d in D:\\n                ans += m.get(-(c + d), 0)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { //hashmap\\npublic: // Time/Space Complexity: O(N^2)\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int ans = 0;\\n        unordered_map<int, int> m;\\n        for(int a: A)\\n            for(int b: B)\\n                ++m[a+b];\\n        for(int c: C)\\n            for(int d: D)\\n                ans+=m[-(c+d)];\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        ans = 0\\n        m = {}\\n        for a in A:\\n            for b in B:\\n                m[a + b] = m.get(a + b, 0) + 1\\n        for c in C:\\n            for d in D:\\n                ans += m.get(-(c + d), 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520901,
                "title": "simple-java-solution-beats-100",
                "content": "```\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<A.length; i++){\\n            for(int j=0; j<B.length; j++){\\n                int sum = A[i] + B[j];\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<C.length; i++){\\n            for(int j=0; j<D.length; j++){\\n                int sum = C[i] + D[j];\\n                res += map.getOrDefault(-sum, 0);\\n            }\\n        }\\n        \\n        return res;\\n```",
                "solutionTags": [],
                "code": "```\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<A.length; i++){\\n            for(int j=0; j<B.length; j++){\\n                int sum = A[i] + B[j];\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<C.length; i++){\\n            for(int j=0; j<D.length; j++){\\n                int sum = C[i] + D[j];\\n                res += map.getOrDefault(-sum, 0);\\n            }\\n        }\\n        \\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503971,
                "title": "java-simple-o-n-2-solution-with-explanation",
                "content": "```\\n        /*\\n        Approach: Brute force approach will be for every possible combination of A, B, C and D, check if that leads to 0 sum.\\n                  But this will have e time complexity of O(n^4), which is not that good.\\n                  In this approach, we first calculate the sum of each A and B, and the count of the sum in a HashMap.\\n                  So, now we have each (A+B) and their frequencies.\\n                  Now we need to find which possible C and D combos along with A+B combos sum to 0.\\n                  For that, we loop through C and D, and check if we have the complement sums in our A+B combo HashMap.\\n                  If we have, that means for each count of that A+B combo, we our this C+D combo can lead to 0 sum.\\n                  So we add the frequency of that A+B combo to our sumCount.\\n                  \\n        Complexity analysis: Time: O(n^2)\\n                             Space: O(n^2)\\n        */\\n        \\n        HashMap<Integer, Integer> sumABFrequencyMap = new HashMap<>();\\n        \\n        for(int a : A){\\n            for(int b : B){\\n                sumABFrequencyMap.put(a+b, sumABFrequencyMap.getOrDefault(a+b,0)+1);\\n            }\\n        }\\n        \\n        int sumCount = 0;\\n        \\n        System.out.println(sumABFrequencyMap);\\n        \\n        for(int c : C){\\n            for(int d : D){\\n                int sumCD = c+d;\\n                if(sumABFrequencyMap.containsKey(-sumCD)){\\n                    sumCount += sumABFrequencyMap.get(-sumCD);\\n                }\\n            }\\n        }\\n        \\n        return sumCount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        /*\\n        Approach: Brute force approach will be for every possible combination of A, B, C and D, check if that leads to 0 sum.\\n                  But this will have e time complexity of O(n^4), which is not that good.\\n                  In this approach, we first calculate the sum of each A and B, and the count of the sum in a HashMap.\\n                  So, now we have each (A+B) and their frequencies.\\n                  Now we need to find which possible C and D combos along with A+B combos sum to 0.\\n                  For that, we loop through C and D, and check if we have the complement sums in our A+B combo HashMap.\\n                  If we have, that means for each count of that A+B combo, we our this C+D combo can lead to 0 sum.\\n                  So we add the frequency of that A+B combo to our sumCount.\\n                  \\n        Complexity analysis: Time: O(n^2)\\n                             Space: O(n^2)\\n        */\\n        \\n        HashMap<Integer, Integer> sumABFrequencyMap = new HashMap<>();\\n        \\n        for(int a : A){\\n            for(int b : B){\\n                sumABFrequencyMap.put(a+b, sumABFrequencyMap.getOrDefault(a+b,0)+1);\\n            }\\n        }\\n        \\n        int sumCount = 0;\\n        \\n        System.out.println(sumABFrequencyMap);\\n        \\n        for(int c : C){\\n            for(int d : D){\\n                int sumCD = c+d;\\n                if(sumABFrequencyMap.containsKey(-sumCD)){\\n                    sumCount += sumABFrequencyMap.get(-sumCD);\\n                }\\n            }\\n        }\\n        \\n        return sumCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 421476,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @param {number[]} C\\n * @param {number[]} D\\n * @return {number}\\n */\\nvar fourSumCount = function(A, B, C, D) {\\n    let count = 0;\\n    const dict = {};\\n    \\n    for (const a of A) {\\n        for (const b of B) {\\n            const currSum = a + b;\\n            \\n            if (!dict[currSum]) {\\n                dict[currSum] = 0;\\n            }\\n            \\n            dict[currSum]++;\\n        }\\n    }\\n    \\n    for (const c of C) {\\n        for (const d of D) {\\n            const currSum = c + d;\\n            \\n            if (dict[-currSum]) {\\n                count += dict[-currSum];\\n            }   \\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @param {number[]} C\\n * @param {number[]} D\\n * @return {number}\\n */\\nvar fourSumCount = function(A, B, C, D) {\\n    let count = 0;\\n    const dict = {};\\n    \\n    for (const a of A) {\\n        for (const b of B) {\\n            const currSum = a + b;\\n            \\n            if (!dict[currSum]) {\\n                dict[currSum] = 0;\\n            }\\n            \\n            dict[currSum]++;\\n        }\\n    }\\n    \\n    for (const c of C) {\\n        for (const d of D) {\\n            const currSum = c + d;\\n            \\n            if (dict[-currSum]) {\\n                count += dict[-currSum];\\n            }   \\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 409139,
                "title": "short-and-easy-to-understand-python-solution-o-n-2-time-and-space",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        dict = collections.defaultdict(int)\\n        for a in A:\\n            for b in B:\\n                dict[a + b] += 1\\n        return sum(dict[-c-d] for c in C for d in D)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        dict = collections.defaultdict(int)\\n        for a in A:\\n            for b in B:\\n                dict[a + b] += 1\\n        return sum(dict[-c-d] for c in C for d in D)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406925,
                "title": "share-my-python3-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        res, cache = 0, {}\\n        for a in A:\\n            for b in B:\\n                sums = a + b\\n                cache[sums] = cache.get(sums, 0) + 1\\n        \\n        for c in C:\\n            for d in D:\\n                sums = c + d\\n                if -sums in cache:\\n                    res += cache[-sums]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        res, cache = 0, {}\\n        for a in A:\\n            for b in B:\\n                sums = a + b\\n                cache[sums] = cache.get(sums, 0) + 1\\n        \\n        for c in C:\\n            for d in D:\\n                sums = c + d\\n                if -sums in cache:\\n                    res += cache[-sums]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93940,
                "title": "c-o-n-2-algorithm-with-unordered-map",
                "content": "The algorithm is to hash the sum of each elements in A and B, then find whether opposite number for sum of elements in C and D occurs.\\nThe time complexity is O(n^2), space complexity is O(n)\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int count = 0;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = 0; j < B.size(); j++) {\\n                mp[A[i]+B[j]]++;\\n            }\\n        }\\n        for (int i = 0; i < C.size(); i++) {\\n            for (int j = 0; j < D.size(); j++) {\\n                if (mp.find(-(C[i] + D[j])) != mp.end()) {\\n                    count += mp[-(C[i] + D[j])];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int count = 0;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = 0; j < B.size(); j++) {\\n                mp[A[i]+B[j]]++;\\n            }\\n        }\\n        for (int i = 0; i < C.size(); i++) {\\n            for (int j = 0; j < D.size(); j++) {\\n                if (mp.find(-(C[i] + D[j])) != mp.end()) {\\n                    count += mp[-(C[i] + D[j])];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763859,
                "title": "a-smart-solution-that-is-100-faster-tc-n-n-sc-n-n-using-default-dictnory",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        dc1=defaultdict(lambda:0)\\n        for a in nums1:\\n            for b in nums2:\\n                dc1[a+b]+=1\\n        ans=0\\n        for c in nums3:\\n            for d in nums4:\\n                ans+=dc1[-c-d]\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        dc1=defaultdict(lambda:0)\\n        for a in nums1:\\n            for b in nums2:\\n                dc1[a+b]+=1\\n        ans=0\\n        for c in nums3:\\n            for d in nums4:\\n                ans+=dc1[-c-d]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987642,
                "title": "python-combine-then-look-up-complement-in-hashmap-clean-concise",
                "content": "```python\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        def combine(arr1, arr2):\\n            res = []\\n            for num1 in arr1:\\n                for num2 in arr2:\\n                    res.append(num1 + num2)\\n            return res\\n        \\n        arr1 = combine(nums1, nums2)\\n        arr2 = combine(nums3, nums4)\\n        # a + b = 0\\n        res = 0\\n        seen = Counter(arr1)\\n        for num in arr2:\\n            if -num in seen:\\n                res += seen[-num]\\n        \\n        return res\\n```\\nComplexity:\\n- Time: `O(N^2)`, where `N <= 200` is length of each arrays.\\n- Space: `O(N^2)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        def combine(arr1, arr2):\\n            res = []\\n            for num1 in arr1:\\n                for num2 in arr2:\\n                    res.append(num1 + num2)\\n            return res\\n        \\n        arr1 = combine(nums1, nums2)\\n        arr2 = combine(nums3, nums4)\\n        # a + b = 0\\n        res = 0\\n        seen = Counter(arr1)\\n        for num in arr2:\\n            if -num in seen:\\n                res += seen[-num]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741970,
                "title": "easy-java-solution",
                "content": "\\n\\n\\n\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) \\n    {\\n        int c=0;\\n        int n = A.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        //int i,j;\\n        for(int i:A)\\n        {\\n            for(int j:B)\\n            {\\n                int sum =i+j;\\n                map.put(-sum,map.getOrDefault(-sum,0)+1);\\n            }\\n            \\n        }\\n        \\n        for(int i:C)\\n        {\\n            for(int j:D)\\n            {\\n                int sum = i+j;\\n                c+=map.getOrDefault(sum,0);\\n            }\\n        }\\n        \\n        \\n        \\n        return c;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) \\n    {\\n        int c=0;\\n        int n = A.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        //int i,j;\\n        for(int i:A)\\n        {\\n            for(int j:B)\\n            {\\n                int sum =i+j;\\n                map.put(-sum,map.getOrDefault(-sum,0)+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1741141,
                "title": "easy-c-solution-using-unordered-map-o-n-2",
                "content": "In this approach i have first traverse through first and second array ,then added there respective elements and stored in a map.\\nThen traversing through third and fourth array , storing negative of respective sum in a variable.\\nIf the sum is present in the map we will add it into the count.\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int count = 0;\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i<nums1.size();i++){\\n            for(int j= 0;j<nums2.size();j++){\\n                int sum = nums1[i]+nums2[j];\\n                mp[sum]++;\\n            }\\n        }\\n        for(int i = 0; i<nums3.size();i++){\\n            for(int j = 0;j<nums4.size();j++){\\n                int sum = -1*(nums3[i]+nums4[j]);\\n                if(mp[sum]){\\n                    count+=mp[sum];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nIf you like the approach pls upvote",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int count = 0;\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i<nums1.size();i++){\\n            for(int j= 0;j<nums2.size();j++){\\n                int sum = nums1[i]+nums2[j];\\n                mp[sum]++;\\n            }\\n        }\\n        for(int i = 0; i<nums3.size();i++){\\n            for(int j = 0;j<nums4.size();j++){\\n                int sum = -1*(nums3[i]+nums4[j]);\\n                if(mp[sum]){\\n                    count+=mp[sum];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740781,
                "title": "dividing-the-time-complexity-into-n-2-and-n-2-using-unordered-map",
                "content": "In the first n^2 part I have stored all types of pair sums from arrays nums3 and nums4 in an unordered_map the again traverse for forming pairs from nums1 and nums2 , let\\'s say int x= nums1[index1]+nums2[index2]; so to get a pair we need to search for -x in the map , the count is gonna help us to get all quadraples of sum 0 \\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n1= nums1.size(); \\n        int n2= nums2.size(); \\n        int n3= nums3.size();\\n        int n4= nums4.size(); \\n   \\n        unordered_map<int,int>mp; \\n\\n        for(int i=0;i<n3;i++){\\n            for(int j=0;j<n4;j++){\\n                mp[nums3[i]+nums4[j]]++; \\n            }\\n        }\\n        int ans=0; \\n        for(int i=0;i<n1;i++){\\n              for(int j=0;j<n2;j++){\\n                  int curr= nums1[i]+nums2[j]; \\n                  if(mp.find(-curr)!=mp.end()) ans+= mp[-curr]; \\n              }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n1= nums1.size(); \\n        int n2= nums2.size(); \\n        int n3= nums3.size();\\n        int n4= nums4.size(); \\n   \\n        unordered_map<int,int>mp; \\n\\n        for(int i=0;i<n3;i++){\\n            for(int j=0;j<n4;j++){\\n                mp[nums3[i]+nums4[j]]++; \\n            }\\n        }\\n        int ans=0; \\n        for(int i=0;i<n1;i++){\\n              for(int j=0;j<n2;j++){\\n                  int curr= nums1[i]+nums2[j]; \\n                  if(mp.find(-curr)!=mp.end()) ans+= mp[-curr]; \\n              }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460149,
                "title": "javascript-ksum-solution",
                "content": "```\\n/**\\n * kSum II\\n * divide list to 2 halves\\n * 1st half to added to map as sum:count\\n * 2nd half used to find complement of number and add the count to output\\n * *Time: O(N ^(k/2))\\n * *Space: O(N ^(k/2))\\n */\\n// Runtime: 252 ms, faster than 59.66% of JavaScript online submissions for 4Sum II.\\n// Memory Usage: 43 MB, less than 86.13% of JavaScript online submissions for 4Sum II.\\nconst fourSumCount = (nums1, nums2, nums3, nums4) => {\\n\\tconst addToHash = (i, sum) => {\\n\\t\\t// for the 1st half arrays, recursively add count to map\\n\\t\\tif (i < pivot) {\\n\\t\\t\\tfor (const num of list[i]) addToHash(i + 1, sum + num);\\n\\t\\t}\\n\\n\\t\\t// if sum exist increment count by 1, if NOT set to 1\\n\\t\\telse map.set(sum, (map.get(sum) || 0) + 1);\\n\\t};\\n\\n\\tconst complements = (i, sum) => {\\n\\t\\t// for the 2nd half array, recursively find complements\\n\\t\\tif (i < list.length) {\\n\\t\\t\\tfor (const num of list[i]) complements(i + 1, sum + num);\\n\\t\\t}\\n\\n\\t\\t// find complement and add to count\\n\\t\\telse if (map.has(-sum)) count += map.get(-sum);\\n\\t};\\n\\n\\tconst list = [nums1, nums2, nums3, nums4];\\n\\tconst pivot = Math.floor(list.length / 2); // pivot to divide list in half\\n\\tconst map = new Map();\\n\\tlet count = 0;\\n\\n\\taddToHash(0, 0);\\n\\tcomplements(pivot, 0);\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * kSum II\\n * divide list to 2 halves\\n * 1st half to added to map as sum:count\\n * 2nd half used to find complement of number and add the count to output\\n * *Time: O(N ^(k/2))\\n * *Space: O(N ^(k/2))\\n */\\n// Runtime: 252 ms, faster than 59.66% of JavaScript online submissions for 4Sum II.\\n// Memory Usage: 43 MB, less than 86.13% of JavaScript online submissions for 4Sum II.\\nconst fourSumCount = (nums1, nums2, nums3, nums4) => {\\n\\tconst addToHash = (i, sum) => {\\n\\t\\t// for the 1st half arrays, recursively add count to map\\n\\t\\tif (i < pivot) {\\n\\t\\t\\tfor (const num of list[i]) addToHash(i + 1, sum + num);\\n\\t\\t}\\n\\n\\t\\t// if sum exist increment count by 1, if NOT set to 1\\n\\t\\telse map.set(sum, (map.get(sum) || 0) + 1);\\n\\t};\\n\\n\\tconst complements = (i, sum) => {\\n\\t\\t// for the 2nd half array, recursively find complements\\n\\t\\tif (i < list.length) {\\n\\t\\t\\tfor (const num of list[i]) complements(i + 1, sum + num);\\n\\t\\t}\\n\\n\\t\\t// find complement and add to count\\n\\t\\telse if (map.has(-sum)) count += map.get(-sum);\\n\\t};\\n\\n\\tconst list = [nums1, nums2, nums3, nums4];\\n\\tconst pivot = Math.floor(list.length / 2); // pivot to divide list in half\\n\\tconst map = new Map();\\n\\tlet count = 0;\\n\\n\\taddToHash(0, 0);\\n\\tcomplements(pivot, 0);\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135532,
                "title": "3-continously-improvised-solution-u-can-discuss-with-interviewer",
                "content": "MTHOD-1 : Naive solution \\n\\n           time : O(n^4)\\n           space : O(1)\\n    java code is:\\n# \\t\\n```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n      int n=A.length;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    for(int l=0;l<n;l++)\\n                        if((A[i]+B[j]+C[k]+D[l])==0) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n} \\n```\\n\\n METHOD-2 USING BINARY-SEARCH \\n \\n           TIME : O(n^3*logn)\\n           SPACE : O(1)\\n        java code is:\\n# \\t\\t\\n```\\n\\nclass Solution {\\n    int left(int arr[],int target){\\n        int res=-1;\\n        int l=0,r=arr.length-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(arr[m]==target){\\n                res=m;\\n                r=m-1;\\n            }\\n            else if(arr[m]>target) r=m-1;\\n            else l=m+1;\\n        }\\n        return res;\\n    }\\n    int right(int arr[],int target){\\n        int res=-1;\\n        int l=0,r=arr.length-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(arr[m]==target){\\n                res=m;\\n                l=m+1;\\n            }\\n            else if(arr[m]>target) r=m-1;\\n            else l=m+1;\\n        }\\n        return res;\\n    }\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int n=A.length;\\n        int count=0;\\n        Arrays.sort(D);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    int l=left(D,-(A[i]+B[j]+C[k]));\\n                    if(l==-1) continue;\\n                    int r=right(D,-(A[i]+B[j]+C[k]));\\n                   count+=(r-l+1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n      METHOD-3 : USING MAP\\n\\t  \\n           TIME : O(n^2)\\n           SPACE : O(n^2)\\n        java code is:\\n# \\n```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n       int n=A.length;\\n       Map<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++) map.put(A[i]+B[j],map.getOrDefault(A[i]+B[j],0)+1);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++)\\n                if(map.containsKey(-(C[i]+D[j]))) ans+=map.get(-(C[i]+D[j]));\\n        }\\n        return ans;\\n        \\n    }\\n} \\n```\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n      int n=A.length;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    for(int l=0;l<n;l++)\\n                        if((A[i]+B[j]+C[k]+D[l])==0) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n} \\n```\n```\\n\\nclass Solution {\\n    int left(int arr[],int target){\\n        int res=-1;\\n        int l=0,r=arr.length-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(arr[m]==target){\\n                res=m;\\n                r=m-1;\\n            }\\n            else if(arr[m]>target) r=m-1;\\n            else l=m+1;\\n        }\\n        return res;\\n    }\\n    int right(int arr[],int target){\\n        int res=-1;\\n        int l=0,r=arr.length-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(arr[m]==target){\\n                res=m;\\n                l=m+1;\\n            }\\n            else if(arr[m]>target) r=m-1;\\n            else l=m+1;\\n        }\\n        return res;\\n    }\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int n=A.length;\\n        int count=0;\\n        Arrays.sort(D);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    int l=left(D,-(A[i]+B[j]+C[k]));\\n                    if(l==-1) continue;\\n                    int r=right(D,-(A[i]+B[j]+C[k]));\\n                   count+=(r-l+1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n       int n=A.length;\\n       Map<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++) map.put(A[i]+B[j],map.getOrDefault(A[i]+B[j],0)+1);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++)\\n                if(map.containsKey(-(C[i]+D[j]))) ans+=map.get(-(C[i]+D[j]));\\n        }\\n        return ans;\\n        \\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099977,
                "title": "4-sum-ii-c-o-n-2-using-hashmaps",
                "content": "My approach for this problem is like we first store in a hashmap the sum of all the possible pairs in a and b tuples and then iterating over c and d tuples and this checking if the negative of the value present in the hashmap is there or not.... If yes then add the freq of that sum into the ans and if not simply continue...\\n**#nevergiveup**\\n\\n```\\n#include<map>\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        map<int,int> m;\\n        for(auto x : a){\\n            for(auto y : b){\\n                m[x+y]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto x : c){\\n            for(auto y : d){\\n                if(m.find(-(x+y))!=m.end()){\\n                    ans+=m[-(x+y)];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<map>\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        map<int,int> m;\\n        for(auto x : a){\\n            for(auto y : b){\\n                m[x+y]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto x : c){\\n            for(auto y : d){\\n                if(m.find(-(x+y))!=m.end()){\\n                    ans+=m[-(x+y)];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 975429,
                "title": "4sum-ii-video-solution-in-java-o-n-2",
                "content": "https://www.youtube.com/watch?v=pM3msjuyHuo\\n\\n```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int count =0;\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n        {\\n            for(int j=0;j<B.length;j++)\\n            {\\n                int sum = A[i] + B[j];\\n                if(mp.containsKey(sum))\\n                {\\n                    int v = mp.get(sum);\\n                    v++;\\n                    mp.put(sum,v);\\n                }\\n                else\\n                {\\n                    mp.put(sum,1);\\n                }\\n            }\\n        }\\n\\n        //System.out.println(mp);\\n        for(int i=0;i<C.length;i++)\\n        {\\n            for(int j=0;j<D.length;j++)\\n            {\\n                int sum = C[i] + D[j];\\n                // System.out.println(sum);\\n                if(mp.containsKey(-1*sum))\\n                {\\n                    count += mp.get(-1*sum);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int count =0;\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n        {\\n            for(int j=0;j<B.length;j++)\\n            {\\n                int sum = A[i] + B[j];\\n                if(mp.containsKey(sum))\\n                {\\n                    int v = mp.get(sum);\\n                    v++;\\n                    mp.put(sum,v);\\n                }\\n                else\\n                {\\n                    mp.put(sum,1);\\n                }\\n            }\\n        }\\n\\n        //System.out.println(mp);\\n        for(int i=0;i<C.length;i++)\\n        {\\n            for(int j=0;j<D.length;j++)\\n            {\\n                int sum = C[i] + D[j];\\n                // System.out.println(sum);\\n                if(mp.containsKey(-1*sum))\\n                {\\n                    count += mp.get(-1*sum);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975339,
                "title": "simple-and-easy-java-solution",
                "content": "**Naive Approach:**\\nWe need four numbers from four arrays such that A + B + C + D = 0.\\nWe can use four for loops and iterate over all possible combinations of the numbers, sum them and check if it is equal to 0.\\nThis approach takes O(n<sup>4</sup>).\\n\\n**Efficient Approach:**\\nA + B + C + D = 0 can also be written as A + B = - (C + D).\\nUsing the above idea, we first calculate all possible sums from arrays A and B and store them in a HashMap along with the sums\\' frequency (ie if sum = 5 occurs 2 times then we store it as {5:2}).\\nThen we calculate all possible sums from arrays C and D and check if - (C + D) is present in the HashMap.\\nThe number of -(C+D) in the hashmap will be added to the final ans.\\nPlease upvote if it helps.\\nTime Complexity: O(n<sup>2</sup>).\\n```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int len = A.length;\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < len; i++)\\n        {\\n            for (int j = 0; j < len; j++)\\n            {\\n                map1.put(A[i]+B[j], map1.getOrDefault(A[i]+B[j], 0) + 1);\\n            }\\n            \\n        }\\n        int count = 0;\\n        for (int i = 0; i < len; i++)\\n        {\\n            for (int j = 0; j < len; j++)\\n            {\\n                count += map1.getOrDefault(-(C[i] + D[j]), 0);        \\n            }  \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int len = A.length;\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < len; i++)\\n        {\\n            for (int j = 0; j < len; j++)\\n            {\\n                map1.put(A[i]+B[j], map1.getOrDefault(A[i]+B[j], 0) + 1);\\n            }\\n            \\n        }\\n        int count = 0;\\n        for (int i = 0; i < len; i++)\\n        {\\n            for (int j = 0; j < len; j++)\\n            {\\n                count += map1.getOrDefault(-(C[i] + D[j]), 0);        \\n            }  \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975306,
                "title": "c-2-hashmap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int len = A.size();\\n        if(len == 0){\\n            return 0;\\n        }\\n\\n        unordered_map<int,int> AB;\\n        unordered_map<int,int> CD;\\n        \\n        int count = 0;\\n        int ab = 0;\\n        int cd = 0;\\n        \\n        for(int i = 0; i < len; i++){\\n            for(int j = 0; j < len; j++){\\n                ab = A[i]+B[j];\\n                cd = 0-(C[i]+D[j]);\\n                \\n                if(AB.count(ab) == 0){\\n                    AB[ab] = 1;\\n                }\\n                else{\\n                    AB[ab]++;\\n                }\\n                \\n                if(CD.count(cd) == 0){\\n                    CD[cd] = 1;\\n                }\\n                else{\\n                    CD[cd]++;\\n                }\\n            }\\n        }\\n        \\n        for(auto it:AB){\\n            ab = it.first;\\n            count += AB[ab]*CD[ab];\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int len = A.size();\\n        if(len == 0){\\n            return 0;\\n        }\\n\\n        unordered_map<int,int> AB;\\n        unordered_map<int,int> CD;\\n        \\n        int count = 0;\\n        int ab = 0;\\n        int cd = 0;\\n        \\n        for(int i = 0; i < len; i++){\\n            for(int j = 0; j < len; j++){\\n                ab = A[i]+B[j];\\n                cd = 0-(C[i]+D[j]);\\n                \\n                if(AB.count(ab) == 0){\\n                    AB[ab] = 1;\\n                }\\n                else{\\n                    AB[ab]++;\\n                }\\n                \\n                if(CD.count(cd) == 0){\\n                    CD[cd] = 1;\\n                }\\n                else{\\n                    CD[cd]++;\\n                }\\n            }\\n        }\\n        \\n        for(auto it:AB){\\n            ab = it.first;\\n            count += AB[ab]*CD[ab];\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871513,
                "title": "java-o-n-2-hashmap",
                "content": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> a = sum(A, B);\\n        Map<Integer, Integer> b = sum(C, D);  \\n        \\n        int count = 0;\\n        for(int k : a.keySet()) {\\n            if(b.containsKey(-k)) {\\n                count += b.get(-k) * a.get(k);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    Map<Integer, Integer> sum(int[] a, int[] b) {\\n        Map<Integer, Integer> result = new HashMap<>();        \\n        for(int i = 0; i < a.length; i++) {\\n            for(int j = 0; j < b.length; j++) {\\n                int sum = a[i] + b[j];\\n                result.put(sum, result.getOrDefault(sum,0) + 1);\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> a = sum(A, B);\\n        Map<Integer, Integer> b = sum(C, D);  \\n        \\n        int count = 0;\\n        for(int k : a.keySet()) {\\n            if(b.containsKey(-k)) {\\n                count += b.get(-k) * a.get(k);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    Map<Integer, Integer> sum(int[] a, int[] b) {\\n        Map<Integer, Integer> result = new HashMap<>();        \\n        for(int i = 0; i < a.length; i++) {\\n            for(int j = 0; j < b.length; j++) {\\n                int sum = a[i] + b[j];\\n                result.put(sum, result.getOrDefault(sum,0) + 1);\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758154,
                "title": "c-o-n-2-easy-solution",
                "content": "```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        map<int,int>mp;\\n        for(auto a:A )\\n            for(auto b: B) \\n                mp[a+b]++;\\n        int ans = 0;\\n        for(auto c: C)\\n            for(auto d:D)\\n                ans+=mp[0-c-d];\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        map<int,int>mp;\\n        for(auto a:A )\\n            for(auto b: B) \\n                mp[a+b]++;\\n        int ans = 0;\\n        for(auto c: C)\\n            for(auto d:D)\\n                ans+=mp[0-c-d];\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1742681,
                "title": "c-javascript-solution",
                "content": "**Approach:-**\\n* We can visualize it like this :\\n* \\n   Let suppose x1, y1, x2, y2 are integers and we need to find when,  \\n    `    ( x1 + y1 + x2 + y2 ) = 0`\\n\\t`\\t( x1 + y1 ) = - ( x2 + y2 )`\\n\\t\\t\\n*   So how can we ensure this condition ? That\\'s a question right ?\\n  What if we can store ( x1 + y1 ) somewhere in a map ?\\n  Similarly we can store ( x2 + y2 ) in another map , got it ?\\n  It\\'s pretty easy , isn\\'t it ? Yeah , ok !!\\n  \\n*   Let\\'s store it then , **map1** contains key as **( x1 + y1 )** and value as **count** of such pair\\n    e.g  ` Map1= { -2 => 2, 0 => 2 }`\\n\\n    Now move to second part, we need to check for every **( x1 + y1)** how many pairs of  **-ve( x2 + y2 )** exists, and that\\'s it.\\n\\t\\n* \\t**Time Complexity** would be : O(N^2) + O(N^2) ~ **O(N^2)**\\n\\n\\n  \\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unordered_map<int,int> m;\\n        int count=0;\\n        \\n        for(auto x:nums1){\\n            for(auto y:nums2){\\n                m[x+y]++;\\n            }\\n        }\\n        \\n        for(auto a:nums3){\\n            for(auto b:nums4){\\n                int sum=a+b;\\n                if(m.find(-sum)!=m.end()){\\n                    count+=m[-sum];\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n\\n**Javascript Code**\\n```\\nvar fourSumCount = function(nums1, nums2, nums3, nums4) {\\n    let m=new Map(),count=0;\\n    \\n    nums1.forEach(n1=>{\\n        nums2.forEach(n2=>{\\n            let sum=n1+n2;\\n            m.set(sum,m.get(sum)+1 || 1);\\n        })\\n    })\\n   \\n    nums3.forEach(n3=>{\\n        nums4.forEach(n4=>{\\n            let sum=-(n3+n4);\\n            count+=m.get(sum)?m.get(sum):0;\\n        })\\n    })\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unordered_map<int,int> m;\\n        int count=0;\\n        \\n        for(auto x:nums1){\\n            for(auto y:nums2){\\n                m[x+y]++;\\n            }\\n        }\\n        \\n        for(auto a:nums3){\\n            for(auto b:nums4){\\n                int sum=a+b;\\n                if(m.find(-sum)!=m.end()){\\n                    count+=m[-sum];\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nvar fourSumCount = function(nums1, nums2, nums3, nums4) {\\n    let m=new Map(),count=0;\\n    \\n    nums1.forEach(n1=>{\\n        nums2.forEach(n2=>{\\n            let sum=n1+n2;\\n            m.set(sum,m.get(sum)+1 || 1);\\n        })\\n    })\\n   \\n    nums3.forEach(n3=>{\\n        nums4.forEach(n4=>{\\n            let sum=-(n3+n4);\\n            count+=m.get(sum)?m.get(sum):0;\\n        })\\n    })\\n    return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742492,
                "title": "java-forever-o-n-2-loop-a-and-b-store-result-then-loop-c-and-d",
                "content": "```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n        for(int a : nums1)\\n            for(int b : nums2){\\n                int s = a+b;\\n                map.put( s, map.getOrDefault(s, 0)+1 ); \\n            }\\n        \\n        int result=0;\\n        for(int c : nums3)\\n            for(int d : nums4){\\n                int s = -c-d;\\n                result += map.getOrDefault(s, 0);\\n            }\\n        return result; \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n        for(int a : nums1)\\n            for(int b : nums2){\\n                int s = a+b;\\n                map.put( s, map.getOrDefault(s, 0)+1 ); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1742393,
                "title": "c-easy-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4)  \\n    {\\n        int n=nums1.size();\\n        unordered_map<int,int> mp1,mp2;\\n        for(int i=0;i<n;i++)\\n        {\\n               for(int j=0;j<n;j++)\\n               {\\n                   mp1[nums1[i]+nums2[j]]++;\\n                   mp2[nums3[i]+nums4[j]]++;\\n               }\\n        }\\n        int cnt=0;\\n        for(auto x:mp1)\\n        {\\n            for(auto y:mp2)\\n            {\\n                if(x.first+y.first==0)\\n                {\\n                    cnt=cnt+x.second*y.second;\\n                }\\n            }\\n        }\\n        return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4)  \\n    {\\n        int n=nums1.size();\\n        unordered_map<int,int> mp1,mp2;\\n        for(int i=0;i<n;i++)\\n        {\\n               for(int j=0;j<n;j++)\\n               {\\n                   mp1[nums1[i]+nums2[j]]++;\\n                   mp2[nums3[i]+nums4[j]]++;\\n               }\\n        }\\n        int cnt=0;\\n        for(auto x:mp1)\\n        {\\n            for(auto y:mp2)\\n            {\\n                if(x.first+y.first==0)\\n                {\\n                    cnt=cnt+x.second*y.second;\\n                }\\n            }\\n        }\\n        return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742209,
                "title": "python-3-500ms-n-2-approach-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        ht = defaultdict(int)\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                ht[n1 + n2] += 1\\n        ans = 0\\n        c=0\\n        for n3 in nums3:\\n            for n4 in nums4:\\n                c=ht[-n3 - n4]\\n                ans +=c\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        ht = defaultdict(int)\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                ht[n1 + n2] += 1\\n        ans = 0\\n        c=0\\n        for n3 in nums3:\\n            for n4 in nums4:\\n                c=ht[-n3 - n4]\\n                ans +=c\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742089,
                "title": "c-simple-solution",
                "content": "The intuition behind the solution is simple.\\nLet us take look to the intuition:-\\n1/ In simple addition we have two things like in a+b we have two side (first one is a) and the (second one is b)\\n\\tkeeping this in our mind we can proceed with this problem.\\n2/ Here also we will have two sides (As we know we 4 nums so we will divide them into 2-2 group) i.e nums1 and nums2 will be on one side and nums3 and nums4 will  be on another side.\\n*                               **** nums1 + nums2  =  -(nums3+num4) ****\\n\\n\\nHere is my solution to the problem:-\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unordered_map<int,int>mp;\\n        int cnt =0;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                int sum = nums1[i] + nums2[j];\\n                mp[sum]++;\\n            }\\n        }\\n        for(int i=0;i<nums3.size();i++){\\n            for(int j=0;j<nums4.size();j++){\\n                int sum = (-1)*(nums3[i] + nums4[j]);\\n                if(mp[sum]){\\n                    cnt+= mp[sum];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nDo give a thumbs up if you understood the solution!!!!!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unordered_map<int,int>mp;\\n        int cnt =0;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                int sum = nums1[i] + nums2[j];\\n                mp[sum]++;\\n            }\\n        }\\n        for(int i=0;i<nums3.size();i++){\\n            for(int j=0;j<nums4.size();j++){\\n                int sum = (-1)*(nums3[i] + nums4[j]);\\n                if(mp[sum]){\\n                    cnt+= mp[sum];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741432,
                "title": "how-to-think-from-o-n-4-to-o-n-2-gradually",
                "content": "First, we need to think of all the permutations for i, j, k and l which will be the index of the nums vectors in increasing numbering. So, we can use four nested loops which traverse for all the possible permutations to find the sum of the elements on those respective indexes and if it is equal to 0 we can increase the global count value by 1. \\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n=nums1.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int k=0;k<n;k++)\\n                {\\n                    for(int l=0;l<n;l++)\\n                    {\\n                        if(nums1[i]+nums2[j]+nums3[k]+nums4[l]==0)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;     \\n    }\\n};\\n\\n```\\n\\nThis gives us the complexity of O(N^4) which is very bad. Quick optimization is storing 1 array in a hashmap and removing the last loop. This will be then the O(N^3) code which is still not good. But this quick optimization gives us a hint to store N^2  combinations of the sum of elements in an array and one in a hashmap which can be solved in linear time using a simple 2Sum approach. Voila! We got O(N^2) complexity. Neat!  \\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n=nums1.size();\\n        int new1[n*n];\\n        unordered_map<int,int> m;\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                new1[k]=nums1[i]+nums2[j];\\n                m[nums3[i]+nums4[j]]++;\\n                k++;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            int temp=-1*new1[i];\\n            if(m[temp]>0)  count+=m[temp];\\n        }\\n        return count; \\n    }\\n};\\n```\\nIt can be optimized further more such as using two hashmaps only and stuff but, I think this pretty good too.\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n=nums1.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int k=0;k<n;k++)\\n                {\\n                    for(int l=0;l<n;l++)\\n                    {\\n                        if(nums1[i]+nums2[j]+nums3[k]+nums4[l]==0)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;     \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n=nums1.size();\\n        int new1[n*n];\\n        unordered_map<int,int> m;\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                new1[k]=nums1[i]+nums2[j];\\n                m[nums3[i]+nums4[j]]++;\\n                k++;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            int temp=-1*new1[i];\\n            if(m[temp]>0)  count+=m[temp];\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741127,
                "title": "python3-faster-solution-easiest-approach",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        ht = defaultdict(int)\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                ht[n1 + n2] += 1\\n        ans = 0\\n        c=0\\n        for n3 in nums3:\\n            for n4 in nums4:\\n                c=ht[-n3 - n4]\\n                ans +=c\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        ht = defaultdict(int)\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                ht[n1 + n2] += 1\\n        ans = 0\\n        c=0\\n        for n3 in nums3:\\n            for n4 in nums4:\\n                c=ht[-n3 - n4]\\n                ans +=c\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740733,
                "title": "easy-to-understand-c-solution",
                "content": "Make a map of sums of all pairs in nums1 and nums2, and another map for sums of all pairs in nums3 and nums4.\\nTraverse through one of the maps and check whether its negative exists in the second map.\\nIf yes, add the number of corresponding pairs to you answer.\\n\\n```\\nclass Solution {\\n    unordered_map<int, int> makeMap(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> M;\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int sum = nums1[i] + nums2[j];\\n                if(M.find(sum) != M.end()) M[sum] += 1;\\n                else M[sum] = 1;\\n            }\\n        }\\n        return M;\\n    }\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n = nums1.size();\\n        unordered_map<int, int> M = makeMap(nums1, nums2);\\n        unordered_map<int, int> N = makeMap(nums3, nums4);\\n        \\n        int ans = 0;\\n        \\n        for(auto it = M.begin(); it != M.end(); it++) {\\n            int temp = -(it->first);\\n            if(N.find(temp) != N.end()) {\\n                ans += (N[temp] * (it->second));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTC: O(n^2)\\nSC: O(n^2)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> makeMap(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> M;\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int sum = nums1[i] + nums2[j];\\n                if(M.find(sum) != M.end()) M[sum] += 1;\\n                else M[sum] = 1;\\n            }\\n        }\\n        return M;\\n    }\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n = nums1.size();\\n        unordered_map<int, int> M = makeMap(nums1, nums2);\\n        unordered_map<int, int> N = makeMap(nums3, nums4);\\n        \\n        int ans = 0;\\n        \\n        for(auto it = M.begin(); it != M.end(); it++) {\\n            int temp = -(it->first);\\n            if(N.find(temp) != N.end()) {\\n                ans += (N[temp] * (it->second));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740689,
                "title": "c-easy-to-understand-maps",
                "content": "1. calculate each sum for **x** in **nums1** and **y** in **nums2** Store it in map with frequency\\n2. make loop to check for sum of  **p** in **nums3** and **q** in **nums4** , check if **(-(p+q))** is present in map\\n\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unordered_map<int,int> sum1;\\n        for(int x : nums1){\\n            for(int y : nums2){\\n                sum1[x+y]++;\\n            }\\n        }\\n        int cnt = 0;\\n        for(int x : nums3){\\n            for(int y : nums4){\\n                if(sum1.count((-(x+y)))==1){\\n                    cnt+= sum1[(-(x+y))];\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```\\n\\n**if you can understand shorter code** *it is faster but logic is same*\\n```\\nint res = 0;\\n        unordered_map<int, int> AB;\\n        for (int a : A)\\n            for (int b : B)\\n                AB[a + b]++;\\n        for (int c : C)\\n            for (int d : D)\\n                res += AB[-c - d];\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unordered_map<int,int> sum1;\\n        for(int x : nums1){\\n            for(int y : nums2){\\n                sum1[x+y]++;\\n            }\\n        }\\n        int cnt = 0;\\n        for(int x : nums3){\\n            for(int y : nums4){\\n                if(sum1.count((-(x+y)))==1){\\n                    cnt+= sum1[(-(x+y))];\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```\n```\\nint res = 0;\\n        unordered_map<int, int> AB;\\n        for (int a : A)\\n            for (int b : B)\\n                AB[a + b]++;\\n        for (int c : C)\\n            for (int d : D)\\n                res += AB[-c - d];\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740646,
                "title": "python-clean-and-documented-code-using-hashmap",
                "content": "```\\nfrom collections import Counter\\nfrom itertools import product\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        \"\"\"\\n        @see https://leetcode.com/problems/4sum-ii/discuss/93920/Clean-java-solution-O(n2)/150111\\n\\n        Let n = len(A) = len(B) = len(C) = len(D) and we want i, j, k and l such that,\\n                            A[i] + B[j] + C[k] + D[l] = 0 and 0 <= i, j, k, l < n\\n        or,\\n                            A[i] + B[j] = -C[k] - D[l]\\n\\n        for every pair (C[k], D[l]) we want to find if A[i] + B[j] exists such that\\n        the above condition holds. This is done by having a hashmap.\\n        \\n        :param A:\\n        :param B:\\n        :param C:\\n        :param D:\\n        :return:\\n        \"\"\"\\n        cnt = Counter(-a - b for a, b in product(A, B))\\n        return sum(cnt[c + d] for c, d in product(C, D))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nfrom itertools import product\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        \"\"\"\\n        @see https://leetcode.com/problems/4sum-ii/discuss/93920/Clean-java-solution-O(n2)/150111\\n\\n        Let n = len(A) = len(B) = len(C) = len(D) and we want i, j, k and l such that,\\n                            A[i] + B[j] + C[k] + D[l] = 0 and 0 <= i, j, k, l < n\\n        or,\\n                            A[i] + B[j] = -C[k] - D[l]\\n\\n        for every pair (C[k], D[l]) we want to find if A[i] + B[j] exists such that\\n        the above condition holds. This is done by having a hashmap.\\n        \\n        :param A:\\n        :param B:\\n        :param C:\\n        :param D:\\n        :return:\\n        \"\"\"\\n        cnt = Counter(-a - b for a, b in product(A, B))\\n        return sum(cnt[c + d] for c, d in product(C, D))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583283,
                "title": "easy-java",
                "content": "```\\n public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int count=0;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n     for(int i=0;i<nums3.length;i++)\\n     {\\n         for(int j=0;j<nums4.length;j++)\\n         {\\n             int sum=nums3[i]+nums4[j];\\n             \\n         map.put(sum,map.getOrDefault(sum,0)+1);\\n             \\n             \\n             \\n         }\\n     }\\n\\n        for(int i=0;i< nums1.length;i++)\\n        {\\n            for(int j=0;j< nums2.length;j++)\\n            {\\n               int m=-(nums1[i]+nums2[j]);\\n                \\n\\n               count += map.getOrDefault(m, 0);\\n\\n            }\\n        }\\n\\nreturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int count=0;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n     for(int i=0;i<nums3.length;i++)\\n     {\\n         for(int j=0;j<nums4.length;j++)\\n         {\\n             int sum=nums3[i]+nums4[j];\\n             \\n         map.put(sum,map.getOrDefault(sum,0)+1);\\n             \\n             \\n             \\n         }\\n     }\\n\\n        for(int i=0;i< nums1.length;i++)\\n        {\\n            for(int j=0;j< nums2.length;j++)\\n            {\\n               int m=-(nums1[i]+nums2[j]);\\n                \\n\\n               count += map.getOrDefault(m, 0);\\n\\n            }\\n        }\\n\\nreturn count;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1437356,
                "title": "c-simple-hashmap-solution",
                "content": "**Please upvote if you like!**\\n\\n     int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4)    \\n\\t {\\n\\t\\tunordered_map<int,int> map;\\n        int n=nums1.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map[nums1[i]+nums2[j]]++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans=ans+map[-(nums3[i]+nums4[j])];\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**Please upvote if you like!**\\n\\n     int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4)    \\n\\t {\\n\\t\\tunordered_map<int,int> map;\\n        int n=nums1.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map[nums1[i]+nums2[j]]++;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                ans=ans+map[-(nums3[i]+nums4[j])];\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1364541,
                "title": "clean-java-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int x=nums1.length,y=nums2.length,z=nums3.length,w=nums4.length,res=0;\\n        for(int i=0;i<x;i++){\\n            for(int j=0;j<y;j++){\\n                map.put(nums1[i]+nums2[j],map.getOrDefault(nums1[i]+nums2[j],0)+1);\\n            }\\n        }\\n        for(int i=0;i<z;i++){\\n            for(int j=0;j<w;j++){\\n                int sum = -(nums3[i]+nums4[j]);\\n                if(map.containsKey(sum)){\\n                    res+=map.get(sum);\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        int x=nums1.length,y=nums2.length,z=nums3.length,w=nums4.length,res=0;\\n        for(int i=0;i<x;i++){\\n            for(int j=0;j<y;j++){\\n                map.put(nums1[i]+nums2[j],map.getOrDefault(nums1[i]+nums2[j],0)+1);\\n            }\\n        }\\n        for(int i=0;i<z;i++){\\n            for(int j=0;j<w;j++){\\n                int sum = -(nums3[i]+nums4[j]);\\n                if(map.containsKey(sum)){\\n                    res+=map.get(sum);\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330577,
                "title": "c-dictionary-solution",
                "content": "- time: O(n ^ 2)\\n- space: O(n ^ 2)\\n\\n```\\npublic class Solution {\\n    public int FourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n     \\n        int res = 0, n = nums1.Length;\\n        \\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int sum = nums1[i] + nums2[j];\\n                if(dic.ContainsKey(sum))\\n                    dic[sum]++;\\n                else\\n                    dic.Add(sum,1);\\n            }\\n        }\\n        \\n        for(int p = 0; p < n; p++)\\n        {\\n            for(int q = 0; q < n; q++)\\n            {\\n                int sum = nums3[p] + nums4[q];\\n                if(dic.ContainsKey(-sum))\\n                    res += dic[-sum];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n     \\n        int res = 0, n = nums1.Length;\\n        \\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int sum = nums1[i] + nums2[j];\\n                if(dic.ContainsKey(sum))\\n                    dic[sum]++;\\n                else\\n                    dic.Add(sum,1);\\n            }\\n        }\\n        \\n        for(int p = 0; p < n; p++)\\n        {\\n            for(int q = 0; q < n; q++)\\n            {\\n                int sum = nums3[p] + nums4[q];\\n                if(dic.ContainsKey(-sum))\\n                    res += dic[-sum];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259913,
                "title": "java-short-n-simple-o-n-2-solution",
                "content": "I have made use of HashMaps here. I have added all possible pairs of sums to the HashMaps. \\nAnd then I\\'m checking if I get any tuple satisfying the given condition.\\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        \\n        HashMap<Integer, Integer> hs12 = new HashMap<>();\\n        HashMap<Integer, Integer> hs34 = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i = 0; i < nums1.length; i++) {\\n            for(int j = 0; j < nums3.length; j++) {\\n                int key12 = nums1[i] + nums2[j];\\n                int key34 = nums3[i] + nums4[j];\\n                hs12.put(key12, hs12.getOrDefault(key12, 0) + 1);\\n                hs34.put(key34, hs34.getOrDefault(key34, 0) + 1);\\n            }\\n        }\\n        \\n        for(int key: hs12.keySet()) {\\n            int val34 = hs34.getOrDefault(-key, 0);\\n            int val12 = hs12.getOrDefault(key, 0);\\n            count += val12*val34;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        \\n        HashMap<Integer, Integer> hs12 = new HashMap<>();\\n        HashMap<Integer, Integer> hs34 = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i = 0; i < nums1.length; i++) {\\n            for(int j = 0; j < nums3.length; j++) {\\n                int key12 = nums1[i] + nums2[j];\\n                int key34 = nums3[i] + nums4[j];\\n                hs12.put(key12, hs12.getOrDefault(key12, 0) + 1);\\n                hs34.put(key34, hs34.getOrDefault(key34, 0) + 1);\\n            }\\n        }\\n        \\n        for(int key: hs12.keySet()) {\\n            int val34 = hs34.getOrDefault(-key, 0);\\n            int val12 = hs12.getOrDefault(key, 0);\\n            count += val12*val34;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251314,
                "title": "c-simple-and-clear-hashmap-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n\\t\\t\\tunordered_map<int, int> m;\\n\\t\\t\\tfor(int i = 0; i < nums1.size(); i++){\\n\\t\\t\\t\\tfor(int j = 0; j < nums2.size(); j++){\\n\\t\\t\\t\\t\\tm[nums1[i] + nums2[j]]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(int i = 0; i < nums3.size(); i++){\\n\\t\\t\\t\\tfor(int j = 0; j < nums4.size(); j++){\\n\\t\\t\\t\\t\\tif(m.find(-(nums3[i] + nums4[j])) != m.end()){\\n\\t\\t\\t\\t\\t\\tres += m[-(nums3[i] + nums4[j])];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;        \\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n\\t\\t\\tunordered_map<int, int> m;\\n\\t\\t\\tfor(int i = 0; i < nums1.size(); i++){\\n\\t\\t\\t\\tfor(int j = 0; j < nums2.size(); j++){\\n\\t\\t\\t\\t\\tm[nums1[i] + nums2[j]]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1167514,
                "title": "c-unordered-map",
                "content": "```\\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n=nums1.size();\\n        int res=0;\\n        unordered_map<int,int> my;\\n        for(int i=0;i<n;i++)\\n              for(int j=0;j<n;j++)\\n                  my[nums1[i]+nums2[j]]+=1;\\n        \\n        for(int i=0;i<n;i++)\\n              for(int j=0;j<n;j++)\\n                   res=res+my[-nums3[i]-nums4[j]];\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n=nums1.size();\\n        int res=0;\\n        unordered_map<int,int> my;\\n        for(int i=0;i<n;i++)\\n              for(int j=0;j<n;j++)\\n                  my[nums1[i]+nums2[j]]+=1;\\n        \\n        for(int i=0;i<n;i++)\\n              for(int j=0;j<n;j++)\\n                   res=res+my[-nums3[i]-nums4[j]];\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065383,
                "title": "easy-o-n-2-c-solution-faster-then-93",
                "content": "class Solution {\\npublic:\\n\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int,int> m;\\n        for(int i:D)\\n            for(int j:C){\\n                m[i+j]++;\\n        }\\n\\t\\t\\n        int ans = 0;\\n        for(int i: A)\\n            for(int j:B)\\n                    if(m[-(i+j)])\\n                        ans+=m[-(i+j)];\\n\\t\\t\\t\\t\\t\\t\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int,int> m;\\n        for(int i:D)\\n            for(int j:C){\\n                m[i+j]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 976376,
                "title": "c-very-simple-and-easy-solution-o-n-2-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int res = 0;\\n        unordered_map<int, int> m;\\n        for (auto a : A) {\\n            for (auto b : B) {\\n                m[a+b]++;\\n            }\\n        }\\n        for (auto c : C) {\\n            for (auto d : D) {\\n                if (m.find(-(c+d)) != m.end())\\n                    res += m[-(c+d)];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote**\\n**Have any comments? I\\'d love to hear!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int res = 0;\\n        unordered_map<int, int> m;\\n        for (auto a : A) {\\n            for (auto b : B) {\\n                m[a+b]++;\\n            }\\n        }\\n        for (auto c : C) {\\n            for (auto d : D) {\\n                if (m.find(-(c+d)) != m.end())\\n                    res += m[-(c+d)];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975301,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic int FourSumCount(int[] A, int[] B, int[] C, int[] D) =>\\n    A.SelectMany(a => B.Select(b => a + b)).GroupBy(s => s).Join(\\n    C.SelectMany(c => D.Select(d => c + d)).GroupBy(s => s),\\n    g => g.Key, g => -g.Key,\\n    (x, y) => x.Count() * y.Count()).Sum();\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int FourSumCount(int[] A, int[] B, int[] C, int[] D) =>\\n    A.SelectMany(a => B.Select(b => a + b)).GroupBy(s => s).Join(\\n    C.SelectMany(c => D.Select(d => c + d)).GroupBy(s => s),\\n    g => g.Key, g => -g.Key,\\n    (x, y) => x.Count() * y.Count()).Sum();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975262,
                "title": "simple-java-solution-using-map",
                "content": "```\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int result = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int a : A) {\\n            for (int b : B) {\\n                int index = a + b;\\n                map.put(index, map.getOrDefault(index, 0) + 1);\\n            }\\n        }\\n        \\n        for (int c : C) {\\n            for (int d : D) {\\n                int index = -(c + d);\\n                \\n                if (map.containsKey(index)) {\\n                    result += map.get(index);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int result = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int a : A) {\\n            for (int b : B) {\\n                int index = a + b;\\n                map.put(index, map.getOrDefault(index, 0) + 1);\\n            }\\n        }\\n        \\n        for (int c : C) {\\n            for (int d : D) {\\n                int index = -(c + d);\\n                \\n                if (map.containsKey(index)) {\\n                    result += map.get(index);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 975260,
                "title": "python-clean-2-sum-solution",
                "content": "```html5\\n<b>Time Complexity: O(n<sup>2</sup>)</b>\\n<b>Space Complexity: O(n<sup>2</sup>)</b>\\n```\\n\\n<details>\\n\\n<summary><b>Approach:</b> (click to show)</summary>\\n\\nFind all possible combinations of 2 numbers from A and B.\\nWorking with just 2 lists makes this a O(n<sup>2</sup>) operation where n is A.length.  \\nRepeat this for lists C and D.\\n\\nFor each sum of 2 numbers (```ab```) check if ```-ab``` exists in\\nthe combinations of numbers from CD.  \\ni.e. if there are ten 2\\'s in AB and five -2\\'s in CD we can make 10&middot;5 = 50 zeros.\\n\\n</details>\\n\\n<br>\\n\\n```python\\ndef fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n\\tdef twoSum(A, B):\\n\\t\\tA = collections.Counter(A)\\n\\t\\tB = collections.Counter(B)\\n\\t\\tC = collections.defaultdict(int)\\n\\t\\tfor a in A:\\n\\t\\t\\tfor b in B:\\n\\t\\t\\t\\tC[a+b] += A[a] * B[b]\\n\\t\\treturn C\\n\\n\\tAB = twoSum(A, B)\\n\\tCD = twoSum(C, D)\\n\\treturn sum(AB[ab] * CD[-ab] for ab in AB)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```html5\\n<b>Time Complexity: O(n<sup>2</sup>)</b>\\n<b>Space Complexity: O(n<sup>2</sup>)</b>\\n```\n```ab```\n```-ab```\n```python\\ndef fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n\\tdef twoSum(A, B):\\n\\t\\tA = collections.Counter(A)\\n\\t\\tB = collections.Counter(B)\\n\\t\\tC = collections.defaultdict(int)\\n\\t\\tfor a in A:\\n\\t\\t\\tfor b in B:\\n\\t\\t\\t\\tC[a+b] += A[a] * B[b]\\n\\t\\treturn C\\n\\n\\tAB = twoSum(A, B)\\n\\tCD = twoSum(C, D)\\n\\treturn sum(AB[ab] * CD[-ab] for ab in AB)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 876611,
                "title": "simple-java-solution-using-hashmap-o-n-2",
                "content": "```java\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        int n = A.length;\\n        for (int i = 0; i<n; i++){\\n            for (int j = 0; j <n;j++){\\n                Integer curr = counter.get(A[i]+B[j]);\\n                curr = curr == null ? 1 : curr + 1;\\n                counter.put(A[i]+B[j],curr);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i<n; i++){\\n            for (int j = 0; j <n;j++){\\n                int findValue = -C[i] - D[j];\\n                Integer curr = counter.get(findValue);\\n                if (curr != null){\\n                    res += curr;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        int n = A.length;\\n        for (int i = 0; i<n; i++){\\n            for (int j = 0; j <n;j++){\\n                Integer curr = counter.get(A[i]+B[j]);\\n                curr = curr == null ? 1 : curr + 1;\\n                counter.put(A[i]+B[j],curr);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i<n; i++){\\n            for (int j = 0; j <n;j++){\\n                int findValue = -C[i] - D[j];\\n                Integer curr = counter.get(findValue);\\n                if (curr != null){\\n                    res += curr;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836214,
                "title": "go",
                "content": "```\\nfunc fourSumCount(A []int, B []int, C []int, D []int) int {\\n    \\n    dict := make(map[int]int)\\n    l := len(A)\\n    res := 0\\n    \\n    for i := 0; i < l; i++ {\\n        for j := 0; j < l; j++ {\\n            dict[A[i] + B[j]]++\\n        }\\n    }\\n    \\n    for i := 0; i < l; i++ {\\n        for j := 0; j < l; j++ {\\n            res += dict[-C[i]-D[j]]\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc fourSumCount(A []int, B []int, C []int, D []int) int {\\n    \\n    dict := make(map[int]int)\\n    l := len(A)\\n    res := 0\\n    \\n    for i := 0; i < l; i++ {\\n        for j := 0; j < l; j++ {\\n            dict[A[i] + B[j]]++\\n        }\\n    }\\n    \\n    for i := 0; i < l; i++ {\\n        for j := 0; j < l; j++ {\\n            res += dict[-C[i]-D[j]]\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761528,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, A, B, C, D):\\n        count = 0\\n        num_dict = {}\\n        for c in C:\\n            for d in D:\\n                nsum = c + d\\n                if nsum in num_dict:\\n                    num_dict[nsum] += 1\\n                else:\\n                    num_dict[nsum] = 1\\n\\n        for a in A:\\n            for b in B:\\n                target = 0 - (a+b)\\n                if target in num_dict:\\n                    count += num_dict[target]\\n        return count     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, A, B, C, D):\\n        count = 0\\n        num_dict = {}\\n        for c in C:\\n            for d in D:\\n                nsum = c + d\\n                if nsum in num_dict:\\n                    num_dict[nsum] += 1\\n                else:\\n                    num_dict[nsum] = 1\\n\\n        for a in A:\\n            for b in B:\\n                target = 0 - (a+b)\\n                if target in num_dict:\\n                    count += num_dict[target]\\n        return count     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 744909,
                "title": "how-about-this-n-2-solution-in-c-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n\\n\\t\\tunordered_map<int, int> mem;\\n\\t\\tint res = 0;\\n\\n\\t\\tfor (int a : A) {\\n\\t\\t\\tfor (int b : B) {\\n\\t\\t\\t\\tmem[a + b]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int c : C) {\\n\\t\\t\\tfor (int d : D) {\\n\\t\\t\\t\\tint sum = -(c + d);\\n\\t\\t\\t\\tif (mem[sum]) res += mem[sum];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n\\n\\t\\tunordered_map<int, int> mem;\\n\\t\\tint res = 0;\\n\\n\\t\\tfor (int a : A) {\\n\\t\\t\\tfor (int b : B) {\\n\\t\\t\\t\\tmem[a + b]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int c : C) {\\n\\t\\t\\tfor (int d : D) {\\n\\t\\t\\t\\tint sum = -(c + d);\\n\\t\\t\\t\\tif (mem[sum]) res += mem[sum];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690183,
                "title": "very-short-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int,int>mp; int ans=0;\\n        for(auto x:A)\\n            for(auto y:B) mp[x+y]++;\\n        \\n        for(auto x:C)\\n            for(auto y:D) if(mp.find(-x-y)!=mp.end()) ans+=mp[-x-y];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int,int>mp; int ans=0;\\n        for(auto x:A)\\n            for(auto y:B) mp[x+y]++;\\n        \\n        for(auto x:C)\\n            for(auto y:D) if(mp.find(-x-y)!=mp.end()) ans+=mp[-x-y];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672394,
                "title": "java-map-2-2",
                "content": "Similar idea could be expanded to any k-sum; Complexity will be O(N^(k + 1) >> 1);\\n```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                map.put(A[i] + B[j], map.getOrDefault(A[i] + B[j], 0) + 1);\\n            }\\n        }\\n        for (int i = 0; i < C.length; i++) {\\n            for (int j = 0; j < D.length; j++) {\\n                res += map.getOrDefault(-(C[i] + D[j]), 0);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = 0; j < B.length; j++) {\\n                map.put(A[i] + B[j], map.getOrDefault(A[i] + B[j], 0) + 1);\\n            }\\n        }\\n        for (int i = 0; i < C.length; i++) {\\n            for (int j = 0; j < D.length; j++) {\\n                res += map.getOrDefault(-(C[i] + D[j]), 0);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483508,
                "title": "c-simple-o-n-2-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/4sum-ii/\\n*/\\nclass Solution {\\npublic:\\n    /// TC: O(N^2)\\n    int fourSumCount(vector<int> a, vector<int> b,\\n                    vector<int> c, vector<int> d) {\\n        // create a hash table of all pair combinations of first two arrays\\n        // key: sum, value: no. of times the sum was seen\\n        unordered_map<int, int> two_sum;\\n        int total = 0;\\n        \\n        // store sum pair of first two arrays\\n        for(const auto& first: a)\\n            for(const auto& second: b) {\\n                int sum = first + second;\\n                if(two_sum.find(sum) == two_sum.end())\\n                    two_sum.emplace(sum, 0);\\n                ++two_sum[sum];\\n            }\\n        \\n        // since a + b + c + d = 0 needs to be found\\n        // => a + b = -(c + d)\\n        // store a + b pairs, and for all cmb of c and d,\\n        // we check if there is -(c + d) in the hash table\\n        for(const int& third: c) {\\n            for(const int& fourth: d) {\\n                int sum_to_find = -1 * (third + fourth);\\n                // check how many pairs have the required sum\\n                // current combination can combine with that many pairs for 0 sum\\n                auto it = two_sum.find(sum_to_find);\\n                \\n                if(it != two_sum.end())\\n                    total += it->second;\\n            }\\n        }\\n        \\n        return total;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    https://leetcode.com/problems/4sum-ii/\\n*/\\nclass Solution {\\npublic:\\n    /// TC: O(N^2)\\n    int fourSumCount(vector<int> a, vector<int> b,\\n                    vector<int> c, vector<int> d) {\\n        // create a hash table of all pair combinations of first two arrays\\n        // key: sum, value: no. of times the sum was seen\\n        unordered_map<int, int> two_sum;\\n        int total = 0;\\n        \\n        // store sum pair of first two arrays\\n        for(const auto& first: a)\\n            for(const auto& second: b) {\\n                int sum = first + second;\\n                if(two_sum.find(sum) == two_sum.end())\\n                    two_sum.emplace(sum, 0);\\n                ++two_sum[sum];\\n            }\\n        \\n        // since a + b + c + d = 0 needs to be found\\n        // => a + b = -(c + d)\\n        // store a + b pairs, and for all cmb of c and d,\\n        // we check if there is -(c + d) in the hash table\\n        for(const int& third: c) {\\n            for(const int& fourth: d) {\\n                int sum_to_find = -1 * (third + fourth);\\n                // check how many pairs have the required sum\\n                // current combination can combine with that many pairs for 0 sum\\n                auto it = two_sum.find(sum_to_find);\\n                \\n                if(it != two_sum.end())\\n                    total += it->second;\\n            }\\n        }\\n        \\n        return total;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407296,
                "title": "python-binary-search-the-correct-way",
                "content": "```\\nclass Solution(object):\\n    def biSearch(self, nums, x, LEFT):\\n        l = 0\\n        r = len(nums)-1\\n        m = 0 \\n        while (l <= r) :\\n            m = (l+r)>>1\\n            if (LEFT):\\n                if (nums[m] >= x): r = m - 1\\n                else: l = m + 1\\n            else:\\n                if (nums[m] <= x): l = m + 1\\n                else: r = m - 1\\n        return l if LEFT else r\\n        \\n    def fourSumCount(self, A, B, C, D):\\n        s, m = list(), list()\\n        sum, ans, n = 0,0, len(A)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                s.append(A[i]+B[j])\\n                m.append(C[i]+D[j])\\n        s.sort()\\n        m.sort()\\n        for i in range(len(s)):\\n            if i != 0 and s[i]==s[i-1]:\\n                ans+=sum\\n            else:\\n                sum = self.biSearch(m, -s[i],False)-self.biSearch(m,-s[i],True) +1\\n                ans += sum\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def biSearch(self, nums, x, LEFT):\\n        l = 0\\n        r = len(nums)-1\\n        m = 0 \\n        while (l <= r) :\\n            m = (l+r)>>1\\n            if (LEFT):\\n                if (nums[m] >= x): r = m - 1\\n                else: l = m + 1\\n            else:\\n                if (nums[m] <= x): l = m + 1\\n                else: r = m - 1\\n        return l if LEFT else r\\n        \\n    def fourSumCount(self, A, B, C, D):\\n        s, m = list(), list()\\n        sum, ans, n = 0,0, len(A)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                s.append(A[i]+B[j])\\n                m.append(C[i]+D[j])\\n        s.sort()\\n        m.sort()\\n        for i in range(len(s)):\\n            if i != 0 and s[i]==s[i-1]:\\n                ans+=sum\\n            else:\\n                sum = self.biSearch(m, -s[i],False)-self.biSearch(m,-s[i],True) +1\\n                ans += sum\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371059,
                "title": "java-using-hashmap-beats-90-66ms-58mb-memory",
                "content": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int n = A.length;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int sum = A[i]+B[j];\\n                map.put(sum,map.getOrDefault(sum,0)+1);\\n            }\\n        }\\n        int result=0;\\n        HashMap<Integer,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map2.containsKey(C[i])){\\n                result+=map2.get(C[i]);\\n                continue;\\n            }\\n            int increment=0;\\n            for(int j=0;j<n;j++){\\n                int sum = 0-C[i]-D[j];\\n                if(map.containsKey(sum)){\\n                    increment+=map.get(sum);\\n                }\\n            }\\n            result+=increment;\\n            map2.put(C[i],increment);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int n = A.length;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int sum = A[i]+B[j];\\n                map.put(sum,map.getOrDefault(sum,0)+1);\\n            }\\n        }\\n        int result=0;\\n        HashMap<Integer,Integer> map2 = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map2.containsKey(C[i])){\\n                result+=map2.get(C[i]);\\n                continue;\\n            }\\n            int increment=0;\\n            for(int j=0;j<n;j++){\\n                int sum = 0-C[i]-D[j];\\n                if(map.containsKey(sum)){\\n                    increment+=map.get(sum);\\n                }\\n            }\\n            result+=increment;\\n            map2.put(C[i],increment);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357968,
                "title": "o-n-2logn-2-binary-search-without-hashmap",
                "content": "Since this problem is tagged as binary search also, I post my binary search algorithm here. \\nFor each element in AB, use binary search to search the element in CD which equals to AB[i].\\n\\n\\'\\'\\'\\n\\t\\t\\n        # time: O(n^2log(n^2))\\n        # space: O(n^2)\\n        N=len(A)\\n        AB, CD=[], []\\n        for i in range(N):\\n            for j in range(N):\\n                AB.append(A[i]+B[j])\\n                CD.append(-C[i]-D[j])\\n                \\n        AB.sort()\\n        CD.sort()\\n        \\n        def binarySearch(left, target):\\n            right=N**2-1\\n            while left<right:\\n                mid=left+(right-left)/2\\n                if CD[mid]>=target:\\n                    right=mid\\n                else:\\n                    left=mid+1\\n            return left # the first one >= target\\n        \\n        l=0\\n        res=0\\n        i=0\\n        while i<=N**2-1:\\n            ab, cd=1, 0\\n            t=AB[i]\\n            firstEle=binarySearch(l, t)\\n            \\n            if CD[firstEle]==t:\\n                while i+ab<N**2 and AB[i+ab]==AB[i]:\\n                    ab+=1\\n                while firstEle+cd<N**2 and CD[firstEle+cd]==CD[firstEle]:\\n                    cd+=1\\n                \\n                res+=ab*cd\\n            l=firstEle+cd\\n            i+=ab\\n            if l>=N**2 or i>=N**2: break\\n        \\n        return res\\n        \\n        \\n\\'\\'\\'",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "Since this problem is tagged as binary search also, I post my binary search algorithm here. \\nFor each element in AB, use binary search to search the element in CD which equals to AB[i].\\n\\n\\'\\'\\'\\n\\t\\t\\n        # time: O(n^2log(n^2))\\n        # space: O(n^2)\\n        N=len(A)\\n        AB, CD=[], []\\n        for i in range(N):\\n            for j in range(N):\\n                AB.append(A[i]+B[j])\\n                CD.append(-C[i]-D[j])\\n                \\n        AB.sort()\\n        CD.sort()\\n        \\n        def binarySearch(left, target):\\n            right=N**2-1\\n            while left<right:\\n                mid=left+(right-left)/2\\n                if CD[mid]>=target:\\n                    right=mid\\n                else:\\n                    left=mid+1\\n            return left # the first one >= target\\n        \\n        l=0\\n        res=0\\n        i=0\\n        while i<=N**2-1:\\n            ab, cd=1, 0\\n            t=AB[i]\\n            firstEle=binarySearch(l, t)\\n            \\n            if CD[firstEle]==t:\\n                while i+ab<N**2 and AB[i+ab]==AB[i]:\\n                    ab+=1\\n                while firstEle+cd<N**2 and CD[firstEle+cd]==CD[firstEle]:\\n                    cd+=1\\n                \\n                res+=ab*cd\\n            l=firstEle+cd\\n            i+=ab\\n            if l>=N**2 or i>=N**2: break\\n        \\n        return res\\n        \\n        \\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 342604,
                "title": "c-plus-plus-glorious-o-n-2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int res = 0;\\n        unordered_map<int, int> sums;\\n\\t\\t\\n        for (int a : A) for (int b : B) ++sums[a + b];\\n        \\n        for (int c : C) for (int d : D) res += sums[-(c + d)];\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int res = 0;\\n        unordered_map<int, int> sums;\\n\\t\\t\\n        for (int a : A) for (int b : B) ++sums[a + b];\\n        \\n        for (int c : C) for (int d : D) res += sums[-(c + d)];\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155057,
                "title": "ruby-solution-using-hash-table",
                "content": "Take arrays A and B. For every possible sum of two elements, count the possibilities by storing its counter in a hash map. Finally, compute all the possible sums of the arrays C and D. If the hash map contains the opposite value of the current sum, add it to the response.\\n\\n```ruby\\ndef four_sum_count(a, b, c, d)\\n  h = Hash.new(0); res = 0\\n\\n  # store possible sums of A + B in a hash\\n  a.each{ |el_a| b.each{ |el_b| h[el_a + el_b] += 1 } }\\n  # count those sums for each pair of C + D\\n  c.each{ |el_c| d.each{ |el_d| res += h[-(el_c + el_d)] } }\\n\\n  return res\\nend\\n```\\n\\nSubmission details: https://leetcode.com/submissions/detail/166638537/",
                "solutionTags": [],
                "code": "```ruby\\ndef four_sum_count(a, b, c, d)\\n  h = Hash.new(0); res = 0\\n\\n  # store possible sums of A + B in a hash\\n  a.each{ |el_a| b.each{ |el_b| h[el_a + el_b] += 1 } }\\n  # count those sums for each pair of C + D\\n  c.each{ |el_c| d.each{ |el_d| res += h[-(el_c + el_d)] } }\\n\\n  return res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3661030,
                "title": "two-for-loops-c-o-n-2",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n**The approach is very simple, first handle two arrays and store the sum of all possible pairs, then handle the remaining two arrays by computing all pair sums.**\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3, vector<int>& arr4) {\\n        int n = arr1.size(),ans = 0;\\n        unordered_map<int,int> mp;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            mp[arr3[i]+arr4[j]]++;\\n        } \\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n              int sum =  0-arr1[i]-arr2[j];\\n              if(mp.find(sum)!=mp.end())\\n              ans+=mp[sum];\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/eaef64c4-68fa-49cc-b94e-2398d7b3f72f_1687255863.9891098.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3, vector<int>& arr4) {\\n        int n = arr1.size(),ans = 0;\\n        unordered_map<int,int> mp;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            mp[arr3[i]+arr4[j]]++;\\n        } \\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n              int sum =  0-arr1[i]-arr2[j];\\n              if(mp.find(sum)!=mp.end())\\n              ans+=mp[sum];\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295268,
                "title": "very-easy-java-o-n-2-solution",
                "content": "# Intuition\\nWe know That nums1[i] + nums2[j] + nums3[k] + nums4[l] should be equal to zero;\\n-> nums1[i] + nums2[j] = - ( nums3[k] + nums4[l])\\n\\n# Approach\\nWe get all Combinations of nums1 and nums2 into a map \\nand then traverse into combinations of nums3 and nums4 and check for \\n-( nums[k] + nums[l]) in the map\\n\\n# Complexity\\n- Time complexity:\\no(n^2)\\n\\n- Space complexity:\\nO(nums1 * nums2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums1.length; i++){\\n            for(int j = 0; j < nums2.length; j++){\\n                int temp = map.getOrDefault(nums1[i] + nums2[j], 0);\\n                map.put(nums1[i] + nums2[j], temp + 1);\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i < nums3.length; i++){\\n            for(int j = 0; j < nums4.length; j++){\\n                int temp = nums3[i] + nums4[j];\\n                if(map.containsKey(-temp)){\\n                    count += map.get(-temp);\\n                }\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums1.length; i++){\\n            for(int j = 0; j < nums2.length; j++){\\n                int temp = map.getOrDefault(nums1[i] + nums2[j], 0);\\n                map.put(nums1[i] + nums2[j], temp + 1);\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i < nums3.length; i++){\\n            for(int j = 0; j < nums4.length; j++){\\n                int temp = nums3[i] + nums4[j];\\n                if(map.containsKey(-temp)){\\n                    count += map.get(-temp);\\n                }\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277297,
                "title": "454-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a defaultdict(int) called sums12 to store the counts of all possible sums of elements in nums1 and nums2.\\n\\n2. For each pair of elements num1 and num2 in nums1 and nums2, calculate their sum num1 + num2 and increment the corresponding count in sums12.\\n\\n3. Set a variable count to 0.\\n\\n4. For each pair of elements num3 and num4 in nums3 and nums4, calculate their complement -num3 - num4.\\n\\n5. Check if the complement exists in sums12. If it does, increment count by the corresponding count in sums12.\\n\\n6. Return count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        \\n        # Use a defaultdict to store the counts of all possible sums of elements in nums1 and nums2\\n        sums12 = defaultdict(int)\\n        for num1 in nums1:\\n            for num2 in nums2:\\n                sums12[num1 + num2] += 1\\n        \\n        count = 0\\n        \\n        # For each pair of elements in nums3 and nums4, check if their complement exists in sums12\\n        for num3 in nums3:\\n            for num4 in nums4:\\n                complement = -num3 - num4\\n                count += sums12.get(complement, 0)\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        \\n        # Use a defaultdict to store the counts of all possible sums of elements in nums1 and nums2\\n        sums12 = defaultdict(int)\\n        for num1 in nums1:\\n            for num2 in nums2:\\n                sums12[num1 + num2] += 1\\n        \\n        count = 0\\n        \\n        # For each pair of elements in nums3 and nums4, check if their complement exists in sums12\\n        for num3 in nums3:\\n            for num4 in nums4:\\n                complement = -num3 - num4\\n                count += sums12.get(complement, 0)\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147326,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unordered_map<int, int> mp1;\\n        for(int i:nums1)\\n            for(int j:nums2)\\n                mp1[i+j]++;\\n        int ans=0;\\n        for(int i:nums3)\\n            for(int j:nums4)\\n                ans+=mp1[-(i+j)];\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unordered_map<int, int> mp1;\\n        for(int i:nums1)\\n            for(int j:nums2)\\n                mp1[i+j]++;\\n        int ans=0;\\n        for(int i:nums3)\\n            for(int j:nums4)\\n                ans+=mp1[-(i+j)];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991783,
                "title": "python3-solution-beats-92-70-dictionary-approach",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        dictionary = defaultdict(int)\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                numberNeeded = -(n1 + n2)\\n                dictionary[numberNeeded] += 1\\n                \\n        numberOfTuples = 0\\n        for n3 in nums3:\\n            for n4 in nums4:\\n                numberOfTuples += dictionary[n3 + n4]\\n            \\n        return numberOfTuples\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        dictionary = defaultdict(int)\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                numberNeeded = -(n1 + n2)\\n                dictionary[numberNeeded] += 1\\n                \\n        numberOfTuples = 0\\n        for n3 in nums3:\\n            for n4 in nums4:\\n                numberOfTuples += dictionary[n3 + n4]\\n            \\n        return numberOfTuples\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849955,
                "title": "easy-to-understand-o-n-2-using-map-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums1){\\n            for(auto &j: nums2){\\n                mp[i+j]++;\\n            }\\n        }\\n        for(auto &i: nums3){\\n            for(auto &j: nums4){\\n                if(mp.count(-(i+j)))\\n                ans += mp[-(i+j)];\\n            }\\n        }\\n                   return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums1){\\n            for(auto &j: nums2){\\n                mp[i+j]++;\\n            }\\n        }\\n        for(auto &i: nums3){\\n            for(auto &j: nums4){\\n                if(mp.count(-(i+j)))\\n                ans += mp[-(i+j)];\\n            }\\n        }\\n                   return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1927338,
                "title": "java-13ms-100-faster-solution",
                "content": "We need to get min and max in order to solve memory exceeded exception. \\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        Arrays.sort(nums3);\\n        Arrays.sort(nums4);\\n        int min = Math.min(nums1[0] + nums2[0], -(nums3[n - 1] + nums4[n - 1]));\\n        int max = Math.max(nums1[n - 1] + nums2[n - 1], -(nums3[0] + nums4[0]));\\n        \\n        int[] map = new int[max - min + 1];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                map[nums1[i] + nums2[j]-min]++;\\n            }\\n        }\\n        int total = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n               total += map[- nums3[i] - nums4[j] - min];                \\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        Arrays.sort(nums3);\\n        Arrays.sort(nums4);\\n        int min = Math.min(nums1[0] + nums2[0], -(nums3[n - 1] + nums4[n - 1]));\\n        int max = Math.max(nums1[n - 1] + nums2[n - 1], -(nums3[0] + nums4[0]));\\n        \\n        int[] map = new int[max - min + 1];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                map[nums1[i] + nums2[j]-min]++;\\n            }\\n        }\\n        int total = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n               total += map[- nums3[i] - nums4[j] - min];                \\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772722,
                "title": "java-solution-with-explaination",
                "content": "***/Please upvote if you find this helpful***\\n\\n**//logic\\n//1) fill the map with sum of numbers from two arrays (say it be l1)\\n//2) than find the sum of numbers from the other two arrays(say it being l2)\\n//3) if negative of l2 exists in the map as l1 thant means that the condition\\n//   l2 = -l1 satisfies from one of the elements in map than increase the count by \\n//   the frequency of l1 in the map**\\n\\nclass Solution {\\n\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        HashMap<Integer,Integer>map = new HashMap<>();\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                int l1 = nums1[i] + nums2[j];\\n                if(map.containsKey(l1)){\\n                    map.put(l1,map.get(l1)+1);\\n                }\\n                else{\\n                    map.put(l1,1);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int k=0; k<nums3.length; k++){\\n            for(int l=0; l<nums4.length; l++){\\n                int l2 = (nums3[k] + nums4[l]);\\n                if(map.containsKey(-l2)){\\n                    count += map.get(-l2);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n***/Please upvote if you find this helpful***",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        HashMap<Integer,Integer>map = new HashMap<>();\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                int l1 = nums1[i] + nums2[j];\\n                if(map.containsKey(l1)){\\n                    map.put(l1,map.get(l1)+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1742815,
                "title": "o-n-2-java-c-beats-100",
                "content": "# Intuition:\\n>If we combine the first two lists into another with all possible sums from the two. Then we combine the last two lists into another with all possible sums from them. We are left with 2Sum.\\n>>**NOTE:** To save memory we can instead iterate through the first two lists and store all possible sums counts in a hashtable. Then when we iterate through the last two lists checking if their sum negated (its complement to 0) existed from the previous lists in the hashtable.\\n\\n\\n# Visualization with test input:\\n![image](https://assets.leetcode.com/users/images/f29849f5-b148-4fef-8389-cdc49445bb7f_1643916072.8054662.jpeg)\\n\\n\\n# Implementation Overview:\\n\\n1. First we will need to **sort** all of the lists in order to make finding the *minimum* and *maximum* possible sums from the grouped lists(this is important for hashtable sizing).\\n\\n2. Now we will need to find the lowest index that will go into the hashtable. This can be found by taking the *minimum* of the first values of list1 and list2 **added** and the final values in list3 and list4 **added** and **negated** (since we will be looking for the complements from these lists).\\n\\n3. Next we will find the highest index similarly. The *maximum* will be taken of the final elements in list1 and list2 **added**. Along with the first elements in list3 and list4 **added** and **negated**.\\n\\n4. With the range of values found we can now initialize our hashtable to length **max - min + 1**. Along with a count variable for keeping up with the number of tuples.\\n\\n5. Populate the hashtable by iterating through all values in list1 adding them to all values in list2. Incrementing this sums index in the hashtable **sum** - **min** (*accounting for its offset from minimum value*).\\n\\n6. Finally we can now iterate through list3 and list4 calculating all possible sums the same as in the previous step. This time we will negate the sum once it is found and check if the negated value exists within the hashtable (*e.g. table[-val1 - val2 - min] > 0*) making sure to account for **offset** from *minimum*. If so then for each possible combination from the first two lists a tuple exists so add the count at this index in the table to the total count.\\n\\n7. Once done all possible tuples have been accounted for so return the total count.\\n\\n\\n# Java Implementation:\\n\\n```\\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4){\\n    Arrays.sort(nums1); // Step 1\\n    Arrays.sort(nums2); // Step 1\\n    Arrays.sort(nums3); // Step 1\\n    Arrays.sort(nums4); // Step 1\\n    int len = nums1.length; // Step 1.5\\n    int min = Math.min(nums1[0] + nums2[0], -nums3[len - 1] - nums4[len - 1]); // Step 2\\n    int max = Math.max(nums1[len - 1] + nums2[len - 1], -nums3[0] - nums4[0]); // Step 3\\n    int[] table = new int[max - min + 1]; // Step 4\\n    int count = 0; // Step 4\\n    for(int n : nums1) // Step 5\\n        for(int m : nums2) // Step 5\\n            table[n + m - min]++; // Step 5\\n    for(int n : nums3) // Step 6\\n        for(int m : nums4) // Step 6\\n            if(table[-n - m - min] > 0) count += table[-n - m - min]; // Step 6\\n    return count; // Step 7\\n}\\n```\\n\\n\\n# C++ Implementation:\\n```\\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n    sort(nums1.begin(), nums1.end()); // Step 1\\n\\tsort(nums2.begin(), nums2.end()); // Step 1\\n    sort(nums3.begin(), nums3.end()); // Step 1\\n    sort(nums4.begin(), nums4.end()); // Step 1\\n    int len = nums1.size(); // Step 1.5\\n    int low = min(nums1[0] + nums2[0], -nums3[len - 1] - nums4[len - 1]); // Step 2\\n    int high = max(nums1[len - 1] + nums2[len - 1], -nums3[0] - nums4[0]); // Step 3\\n    int table[high - low + 1]; // Step 4\\n    int count = 0; // Step 4\\n    for(int i = 0; i < high - low + 1; i++) table[i] = 0; // Step 4.5\\n    for(int n : nums1) // Step 5\\n        for(int m : nums2) // Step 5\\n            table[n + m - low]++; // Step 5\\n    for(int n : nums3) // Step 6\\n        for(int m : nums4) // Step 6\\n            if(table[-n - m - low] > 0) count += table[-n - m - low]; // Step 6\\n    return count; // Step 7\\n}\\n```\\n\\nHope this helps those who are stuck at the ~200ms runtime mark (I was for quite awhile)!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4){\\n    Arrays.sort(nums1); // Step 1\\n    Arrays.sort(nums2); // Step 1\\n    Arrays.sort(nums3); // Step 1\\n    Arrays.sort(nums4); // Step 1\\n    int len = nums1.length; // Step 1.5\\n    int min = Math.min(nums1[0] + nums2[0], -nums3[len - 1] - nums4[len - 1]); // Step 2\\n    int max = Math.max(nums1[len - 1] + nums2[len - 1], -nums3[0] - nums4[0]); // Step 3\\n    int[] table = new int[max - min + 1]; // Step 4\\n    int count = 0; // Step 4\\n    for(int n : nums1) // Step 5\\n        for(int m : nums2) // Step 5\\n            table[n + m - min]++; // Step 5\\n    for(int n : nums3) // Step 6\\n        for(int m : nums4) // Step 6\\n            if(table[-n - m - min] > 0) count += table[-n - m - min]; // Step 6\\n    return count; // Step 7\\n}\\n```\n```\\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n    sort(nums1.begin(), nums1.end()); // Step 1\\n\\tsort(nums2.begin(), nums2.end()); // Step 1\\n    sort(nums3.begin(), nums3.end()); // Step 1\\n    sort(nums4.begin(), nums4.end()); // Step 1\\n    int len = nums1.size(); // Step 1.5\\n    int low = min(nums1[0] + nums2[0], -nums3[len - 1] - nums4[len - 1]); // Step 2\\n    int high = max(nums1[len - 1] + nums2[len - 1], -nums3[0] - nums4[0]); // Step 3\\n    int table[high - low + 1]; // Step 4\\n    int count = 0; // Step 4\\n    for(int i = 0; i < high - low + 1; i++) table[i] = 0; // Step 4.5\\n    for(int n : nums1) // Step 5\\n        for(int m : nums2) // Step 5\\n            table[n + m - low]++; // Step 5\\n    for(int n : nums3) // Step 6\\n        for(int m : nums4) // Step 6\\n            if(table[-n - m - low] > 0) count += table[-n - m - low]; // Step 6\\n    return count; // Step 7\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741593,
                "title": "c-solution-o-n-2-time-complexity-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n     unordered_map<int, int> m;\\n    for(int i=0;i<nums1.size();i++){\\n        for(int j=0;j<nums2.size();j++){\\n            m[nums1[i]+nums2[j]]++;\\n        }\\n    }\\n    int count = 0;\\n    for(int i=0;i<nums3.size();i++){\\n        for(int j=0;j<nums4.size();j++){\\n            int sum = nums3[i]+nums4[j];\\n            if(m[0-sum]!=0){\\n                count = count + m[0-sum];\\n            }\\n        }\\n    }\\n    return count;       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n     unordered_map<int, int> m;\\n    for(int i=0;i<nums1.size();i++){\\n        for(int j=0;j<nums2.size();j++){\\n            m[nums1[i]+nums2[j]]++;\\n        }\\n    }\\n    int count = 0;\\n    for(int i=0;i<nums3.size();i++){\\n        for(int j=0;j<nums4.size();j++){\\n            int sum = nums3[i]+nums4[j];\\n            if(m[0-sum]!=0){\\n                count = count + m[0-sum];\\n            }\\n        }\\n    }\\n    return count;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741275,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        map <int,int> m;\\n        int ans=0;\\n        \\n        for(int u: a)\\n        {\\n            for(int v: b)\\n                m[u+v]++;\\n        }\\n        \\n        for(int u: c)\\n        {\\n            for(int v: d)\\n            {\\n                if(m.find(-(u+v))!=m.end())\\n                    ans+=m[-(u+v)];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& a, vector<int>& b, vector<int>& c, vector<int>& d) {\\n        map <int,int> m;\\n        int ans=0;\\n        \\n        for(int u: a)\\n        {\\n            for(int v: b)\\n                m[u+v]++;\\n        }\\n        \\n        for(int u: c)\\n        {\\n            for(int v: d)\\n            {\\n                if(m.find(-(u+v))!=m.end())\\n                    ans+=m[-(u+v)];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741183,
                "title": "explained-python3-from-n-3-to-n-2-solution",
                "content": "So if you have done previous versions of this problem. You can convert into a 4Sum problem.\\nBasic idea is for all combinations of nums1,nums2,nums3,nums4 all the different possible answers is to be returned\\n* So first we can put one of the lists in a dictionary [LIKE we do in TWO-SUM]\\n* Then in the last loop we basically perform twoSum\\n```\\ndef fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n\\n\\t\\tmydict = {}\\n        for num,x in enumerate(nums4):\\n            if mydict.get(x,-1)!=-1:\\n                mydict[x] +=1\\n            else:\\n                mydict[x] = 1\\n\\t\\t\\t\\t\\n        ans = 0\\n        for num1 in nums1:\\n            for num2 in nums2:\\n                target = -(num1+num2)\\n                for num3 in nums3:\\n                    reqd = target-num4\\n                   \\n                    if mydict.get(reqd,-1)!=-1:\\n                        times = mydict[reqd]\\n                        \\n                        ans+=times\\n                        \\n        return ans\\n```\\n**N^2 Solution***\\nHere the idea is to convert into **2  X two Sum problems**. Now how to do it?\\nSo we can take first two lists -nums1,nums2:\\nnums1 = [1,2], nums2 = [-2,-1]\\n* All the combinations = [1+-2], [1+-1], [2+-2], [2+-1] = [-1], [0] , [0] , [1]\\n* Add them to our HashMap\\n* Next we iterate over all the combinations of nums3 and nums4:\\n* And search over for the given sum the required value is available in the Hash Map or not\\n\\n```\\ndef fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        \\n        mydict = {}\\n        for num1 in nums1:\\n            for num2 in nums2:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tPutting all the combination of nums1 and nums2 in Map\\n\\t\\t\\t\"\"\"\\n                val = num1+num2\\n                if mydict.get(val,-1)!=-1:\\n                    mydict[val]+=1\\n                else:\\n                    mydict[val] = 1\\n        ans = 0\\n\\t\\t\"\"\"\\n\\t\\tChecking all the combinations of nums3 and nums4 \\n\\t\\t\"\"\"\\n        for num3 in nums3:\\n            for num4 in nums4:\\n\\t\\t\\t#target is the one of the combination\\n                target = num3+num4\\n\\t\\t\\t# complement is what we need to make target to  0\\n\\t\\t\\t\\tcomplement = -target\\n                if mydict.get(complement,-1)!=-1:\\n                    times = mydict[complement]\\n                    ans+=times  #Adding how many such combinations are there\\n        return ans\\n```\\nI believe that the second solution is really tricky and doesn\\'t comes straight away and that\\'s why I wanted to share both the approaches!\\n**Happy Leetcoding**\\nI hope my solution was readable to all of you !",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n\\n\\t\\tmydict = {}\\n        for num,x in enumerate(nums4):\\n            if mydict.get(x,-1)!=-1:\\n                mydict[x] +=1\\n            else:\\n                mydict[x] = 1\\n\\t\\t\\t\\t\\n        ans = 0\\n        for num1 in nums1:\\n            for num2 in nums2:\\n                target = -(num1+num2)\\n                for num3 in nums3:\\n                    reqd = target-num4\\n                   \\n                    if mydict.get(reqd,-1)!=-1:\\n                        times = mydict[reqd]\\n                        \\n                        ans+=times\\n                        \\n        return ans\\n```\n```\\ndef fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        \\n        mydict = {}\\n        for num1 in nums1:\\n            for num2 in nums2:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tPutting all the combination of nums1 and nums2 in Map\\n\\t\\t\\t\"\"\"\\n                val = num1+num2\\n                if mydict.get(val,-1)!=-1:\\n                    mydict[val]+=1\\n                else:\\n                    mydict[val] = 1\\n        ans = 0\\n\\t\\t\"\"\"\\n\\t\\tChecking all the combinations of nums3 and nums4 \\n\\t\\t\"\"\"\\n        for num3 in nums3:\\n            for num4 in nums4:\\n\\t\\t\\t#target is the one of the combination\\n                target = num3+num4\\n\\t\\t\\t# complement is what we need to make target to  0\\n\\t\\t\\t\\tcomplement = -target\\n                if mydict.get(complement,-1)!=-1:\\n                    times = mydict[complement]\\n                    ans+=times  #Adding how many such combinations are there\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1740907,
                "title": "c-explaination-intuition-optimisation-o-n-2",
                "content": "Familiarity with **target pair sum** is required for this ques. Do check it out if u aren\\'t.\\n\\n**A naive approach:**\\nIf we have 4 arrays 1,2,3,4, and we keep adding them 1 by 1 i.e 1,2,3,4 -> 1,2,3+4, -> 1,2+3+4, 1+2+3+4\\nHere we are adding each element to each element of prev array . this way we will have **O(n^2) element in first addition , O(n^3) in third and O(n^4) in 4th addition**.\\nThe solution is very slow\\n\\n**Optimisation:**\\nIf we somehow **reduce the elements** and bring  **4 down to 2 arrays** we can easy do it with target sum approach.\\n> add elements of any two arrays and put the sum in unordered_map\\n> For other two arrays while adding them, we will check if **-(sum)** is present in map. If yes , increment the count to **number of time -(sum) is present in the map**.\\n**Time:** O(n^2)\\n**Space:** O(n^2)\\n\\n```\\nclass Solution {\\npublic:\\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n\\tunordered_map<int , int> s;\\n\\tfor (int i = 0; i < nums3.size(); i++) {\\n\\t\\tfor (int j = 0; j < nums4.size(); j++) {\\n\\t\\t\\ts[nums3[i] + nums4[j]]++;\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < nums1.size(); i++) {\\n\\t\\tfor (int j = 0; j < nums2.size(); j++) {\\n\\t\\t\\tans += s[-(nums1[i] + nums2[j])];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n\\tunordered_map<int , int> s;\\n\\tfor (int i = 0; i < nums3.size(); i++) {\\n\\t\\tfor (int j = 0; j < nums4.size(); j++) {\\n\\t\\t\\ts[nums3[i] + nums4[j]]++;\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < nums1.size(); i++) {\\n\\t\\tfor (int j = 0; j < nums2.size(); j++) {\\n\\t\\t\\tans += s[-(nums1[i] + nums2[j])];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740747,
                "title": "c-solution-similar-problems-discussion",
                "content": "The brute force approach of this solution is O(n^4) Time & O(n) space.\\n The optimized approach is O(n^2) Time and O(n) space.\\n \\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        map<int,int> mp;\\n        \\n        for(auto i: nums1){\\n            for(auto j: nums2){\\n                mp[i+j]++;\\n            }\\n        }\\n        int count = 0;\\n        for(auto i: nums3){\\n            for(auto j: nums4){\\n                count += mp[-i-j];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n**Try this:**\\nGiven 4 arrays of type Integer, nums1, nums2, nums3, nums4, containing n elements each.\\nFind the number of quadruples such that nums1[i]^nums2[j]^nums3[k]^nums4[l] == 0,\\n`INT_MIN < i,j,k,l < INT_MAX`\\nwhere `^` is **XOR** operation.\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        map<int,int> mp;\\n        \\n        for(auto i: nums1){\\n            for(auto j: nums2){\\n                mp[i+j]++;\\n            }\\n        }\\n        int count = 0;\\n        for(auto i: nums3){\\n            for(auto j: nums4){\\n                count += mp[-i-j];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740492,
                "title": "python-in-2-lines",
                "content": "```\\nimport collections\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        count = collections.Counter(a + b for a in nums1 for b in nums2)\\n        return sum(count[-c-d] for c in nums3 for d in nums4)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        count = collections.Counter(a + b for a in nums1 for b in nums2)\\n        return sum(count[-c-d] for c in nums3 for d in nums4)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740491,
                "title": "python3-time-complexity-o-n-2",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        seen = defaultdict(lambda: 0)\\n        for numA in nums1: \\n            for numB in nums2:\\n                seen[numA + numB] += 1 \\n        \\n        ans = 0 \\n        for numC in nums3:\\n            for numD in nums4:\\n                aux = -(numC + numD)\\n                ans += seen[aux]\\n                \\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        seen = defaultdict(lambda: 0)\\n        for numA in nums1: \\n            for numB in nums2:\\n                seen[numA + numB] += 1 \\n        \\n        ans = 0 \\n        for numC in nums3:\\n            for numD in nums4:\\n                aux = -(numC + numD)\\n                ans += seen[aux]\\n                \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740471,
                "title": "c-short-code-explanation",
                "content": "**The problem can be reduced to a 2SUM problem.**\\n<br>\\nBasically lets take all possible sums nums1[i] + nums2[j] and put them in one array, and take all possible sums nums3[i] + nums4[j] and put them in another array (0<=i<n and 0<=j<n), now the question is basically finding two elements in two arrays which have a sum of 0, and this problem can be solved with a hashtable.\\n<br>\\n\\n**Time complexity : O(n^2)\\nSpace complexity : O(n^2)**\\n\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n=nums1.size();\\n        map<int,int> mp;\\n        for(int x:nums1){\\n            for(int y:nums2) mp[x+y]++; // keeping the elements of the first array directly in the hashtable\\n        }\\n        int ans=0;\\n        for(int x:nums3){\\n            for(int y:nums4)  ans+=mp[-x-y]; // getting all elements that can complete our second array\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        int n=nums1.size();\\n        map<int,int> mp;\\n        for(int x:nums1){\\n            for(int y:nums2) mp[x+y]++; // keeping the elements of the first array directly in the hashtable\\n        }\\n        int ans=0;\\n        for(int x:nums3){\\n            for(int y:nums4)  ans+=mp[-x-y]; // getting all elements that can complete our second array\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526490,
                "title": "using-unordered-map-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int count = 0;\\n        unordered_map<int,int> sumAB;\\n        \\n        for(int a : A) for(int b : B) sumAB[a + b]++;\\n        for(int c : C) for(int d : D) count += sumAB[0-c-d];\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        int count = 0;\\n        unordered_map<int,int> sumAB;\\n        \\n        for(int a : A) for(int b : B) sumAB[a + b]++;\\n        for(int c : C) for(int d : D) count += sumAB[0-c-d];\\n        \\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1483923,
                "title": "beats-97-easy-to-understand-python-3-c-compare-performance-and-different-method",
                "content": "# **Solution:**\\n## **C++**\\n**1)\\tUsing hash map**\\n\\n*Runtime: 172 ms, faster than 97.16% of C++ online submissions for 4Sum II.\\nMemory Usage: 24.5 MB, less than 54.21% of C++ online submissions for 4Sum II.*\\n```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unorderedmap<int,int> ref;\\n        for (auto a:nums1)\\n            for(auto b:nums2)\\n                ++ref[a+b];\\n        int ans=0;\\n        for (auto a:nums3)\\n            for(auto b:nums4)\\n                    ans+=ref[-a-b];\\n    return ans;\\n    }\\n};\\n```\\n\\n## **Python3**\\n*there is a huge difference in performance between dictionary and default dict*\\n**1) using defaultdict**\\n*Runtime: 580 ms, faster than 96.58% of Python3 online submissions for 4Sum II.\\nMemory Usage: 14.2 MB, less than 96.92% of Python3 online submissions for 4Sum II.*\\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        ref=defaultdict(int)\\n        for a in nums1:\\n            for b in nums2:\\n                    ref[a+b]+=1\\n        ans=0        \\n        for a in nums3:\\n            for b in nums4:\\n                ans+=ref[-a-b]\\n        return ans\\n```\\n \\n**2)using dic only**\\n\\n*Runtime: 976 ms, faster than 34.53% of Python3 online submissions for 4Sum II.\\nMemory Usage: 14.4 MB, less than 70.50% of Python3 online submissions for 4Sum II.*\\n\\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        ref={}\\n        for a in nums1:\\n            for b in nums2:\\n                if ref.get(a+b)!=None:\\n                    ref[a+b]+=1\\n                else:\\n                    ref[a+b]=1\\n        ans=0        \\n        for a in nums3:\\n            for b in nums4:\\n                if ref.get(-a-b):\\n                    ans+=ref[-a-b]\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        unorderedmap<int,int> ref;\\n        for (auto a:nums1)\\n            for(auto b:nums2)\\n                ++ref[a+b];\\n        int ans=0;\\n        for (auto a:nums3)\\n            for(auto b:nums4)\\n                    ans+=ref[-a-b];\\n    return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        ref=defaultdict(int)\\n        for a in nums1:\\n            for b in nums2:\\n                    ref[a+b]+=1\\n        ans=0        \\n        for a in nums3:\\n            for b in nums4:\\n                ans+=ref[-a-b]\\n        return ans\\n```\n```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        ref={}\\n        for a in nums1:\\n            for b in nums2:\\n                if ref.get(a+b)!=None:\\n                    ref[a+b]+=1\\n                else:\\n                    ref[a+b]=1\\n        ans=0        \\n        for a in nums3:\\n            for b in nums4:\\n                if ref.get(-a-b):\\n                    ans+=ref[-a-b]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431183,
                "title": "python-simple-dict-77",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: list[int], nums2: list[int], nums3: list[int], nums4: list[int]) -> int:\\n        have=defaultdict(int)\\n        ans=0\\n\\n        for i in nums1:\\n            for j in nums2:\\n                have[i+j]+=1\\n        for k in nums3:\\n            for l in nums4:\\n                if -(k+l) in have:\\n                    ans+=have[-k-l]\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: list[int], nums2: list[int], nums3: list[int], nums4: list[int]) -> int:\\n        have=defaultdict(int)\\n        ans=0\\n\\n        for i in nums1:\\n            for j in nums2:\\n                have[i+j]+=1\\n        for k in nums3:\\n            for l in nums4:\\n                if -(k+l) in have:\\n                    ans+=have[-k-l]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1429719,
                "title": "explanation-of-ksum-approach",
                "content": "```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n    return kSumCount(new int[][]{A, B, C, D});\\n}\\n\\npublic int kSumCount(int[][] lists) {\\n    Map<Integer, Integer> m = new HashMap<>();\\n    addToHash(lists, m, 0, 0); // here, add the first half of arrays. if odd, then less than half.\\n    return countComplements(lists, m, lists.length / 2, 0); // here, subtract from the rest of the arrays.\\n}\\n\\n// think about DFS case, for the first level, there are n nodes of array 0. each node will have n children from array 1 on the next level.\\nvoid addToHash(int[][] lists, Map<Integer, Integer> m, int i, int sum) { // note that variable i means array number (from 0).\\n    if (i == lists.length / 2) // at this level, sum is ready. just add to the number of cases having the same sum.\\n        m.put(sum, m.getOrDefault(sum, 0) + 1);\\n    else\\n\\t\\t// this loop tries to add from current array (numbered i)\\n        for (int a : lists[i]) \\n\\t\\t\\t// what this is trying to do is adding array i+1 to sum when element a from array i is added.\\n\\t\\t\\t// note that i & sum are local variable (parameters) so called method won\\'t affect these values when returned.\\n            addToHash(lists, m, i + 1, sum + a); \\n}\\n// the same idea here. we subtract, instead, until the level of empty level reaches.\\nint countComplements(int[][] lists, Map<Integer, Integer> m, int i, int complement) {\\n    if (i == lists.length)\\n        return m.getOrDefault(complement, 0);\\n    int cnt = 0;\\n    for (int a : lists[i])\\n        cnt += countComplements(lists, m, i + 1, complement - a);\\n    return cnt;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n    return kSumCount(new int[][]{A, B, C, D});\\n}\\n\\npublic int kSumCount(int[][] lists) {\\n    Map<Integer, Integer> m = new HashMap<>();\\n    addToHash(lists, m, 0, 0); // here, add the first half of arrays. if odd, then less than half.\\n    return countComplements(lists, m, lists.length / 2, 0); // here, subtract from the rest of the arrays.\\n}\\n\\n// think about DFS case, for the first level, there are n nodes of array 0. each node will have n children from array 1 on the next level.\\nvoid addToHash(int[][] lists, Map<Integer, Integer> m, int i, int sum) { // note that variable i means array number (from 0).\\n    if (i == lists.length / 2) // at this level, sum is ready. just add to the number of cases having the same sum.\\n        m.put(sum, m.getOrDefault(sum, 0) + 1);\\n    else\\n\\t\\t// this loop tries to add from current array (numbered i)\\n        for (int a : lists[i]) \\n\\t\\t\\t// what this is trying to do is adding array i+1 to sum when element a from array i is added.\\n\\t\\t\\t// note that i & sum are local variable (parameters) so called method won\\'t affect these values when returned.\\n            addToHash(lists, m, i + 1, sum + a); \\n}\\n// the same idea here. we subtract, instead, until the level of empty level reaches.\\nint countComplements(int[][] lists, Map<Integer, Integer> m, int i, int complement) {\\n    if (i == lists.length)\\n        return m.getOrDefault(complement, 0);\\n    int cnt = 0;\\n    for (int a : lists[i])\\n        cnt += countComplements(lists, m, i + 1, complement - a);\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383885,
                "title": "java-two-pass-beginner-friendly-with-explanation",
                "content": "**Big Idea:**\\nThere are **n^2** different sums of nums1 and nums2 right?\\nThat means there are **n^2** different sums in nums3 and nums4 eh?\\n\\nThe only way we can get these buggers summed up to 0 is if a combination from nums1 and nums2 is equal to the **negative** of a sum from nums3 and nums4\\n\\ni.e. [1,2] [3,4] [-1,5] [-3,65]\\nin nums1 and nums2, we can get (1+3)=4\\nin nums3 and nums4 , we can get (-1+-3)=-4\\n\\nthese cancels out!!\\n\\nwe should just store the different possible sums of nums1 and nums2 into a hashmap and loop once again for nums3 and nums4 and add the counter variable!!\\n\\n```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int counter = 0;\\n        for(int i = 0; i<nums1.length; i++){\\n            for(int j = 0; j<nums2.length; j++){\\n                hm.put(nums1[i]+nums2[j],hm.getOrDefault(nums1[i]+nums2[j],0)+1);\\n            }\\n        }\\n        for(int a = 0; a<nums3.length; a++){\\n            for(int b = 0; b<nums4.length; b++){\\n                if (hm.containsKey(-(nums3[a]+nums4[b]))){\\n                    counter+=hm.get(-(nums3[a]+nums4[b]));\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int counter = 0;\\n        for(int i = 0; i<nums1.length; i++){\\n            for(int j = 0; j<nums2.length; j++){\\n                hm.put(nums1[i]+nums2[j],hm.getOrDefault(nums1[i]+nums2[j],0)+1);\\n            }\\n        }\\n        for(int a = 0; a<nums3.length; a++){\\n            for(int b = 0; b<nums4.length; b++){\\n                if (hm.containsKey(-(nums3[a]+nums4[b]))){\\n                    counter+=hm.get(-(nums3[a]+nums4[b]));\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347126,
                "title": "java-easy-explained",
                "content": "**Idea:**\\n```\\nCount number of solutions to a + b + c + d  = 0\\n\\u21D2 a + b = -(c + d)\\n```\\n* Iterate through the first 2 arrays and count the frequency of all possible sums of pairs\\n* Iterate through the other 2 arrays and sum up the frequency of `-(c + d)` where c and d are all possible pairs in these 2 arrays. `-(c + d)` should be equal to `a + b` for a valid solution.\\n* The number of such matches is the required result\\n`Example:`\\n```\\nnums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\\n\\nIterated over nums1 and nums2, pairSums = {1 + (-2), 1 + (-1), 2 + (-2), 2 + (-1)}\\n= {-1, 0, 0, 1}\\npairCountBySum = {-1 : 1, 0 : 2, 1 : 1}, i.e. there is 1 pair with sum = 1, 2 pairs with sum = 0, 1 pair with sum = -1\\n\\nIterated over nums3 and nums4, pairSums = {-1 + 0, -1 + 2, 2 + 0, 2 + 2}\\n= {-1, 1, 2, 4}\\nNegate this to be able to find -(c + d)\\n= {1, -1, -2, -4}\\n\\nUse the hashMap pairCountBySum = {-1 : 1, 0 : 2, 1 : 1} for each item in {1, -1, -2, -4}\\n\\nfourSumCount += map.get(1) \\u21D2 fourSumCount = 1\\nfourSumCount += map.get(-1) \\u21D2 fourSumCount = 1 + 1 = 2\\nfourSumCount += map.get(-2) \\u21D2 fourSumCount = 2 + 0 = 2\\nfourSumCount += map.get(-4) \\u21D2 fourSumCount = 2 + 0 = 2\\n\\nNumber of tuples = 2 [Ans]\\n```\\n>**T/S:** O(n\\xB2)/O(n\\xB2), where n = size(nums1)\\n \\n```\\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n\\tvar pairCountBySum = new HashMap<Integer, Integer>();\\n\\tfor (var num1 : nums1)\\n\\t\\tfor (var num2 : nums2)\\n\\t\\t\\tpairCountBySum.compute(num1 + num2, (k, sumCount) -> sumCount == null ? 1 : sumCount + 1);\\n\\n\\tvar fourSumCount = 0;\\n\\tfor (var num3 : nums3)\\n\\t\\tfor (var num4 : nums4)\\n\\t\\t\\tfourSumCount += pairCountBySum.getOrDefault(-(num3 + num4), 0);\\n\\n\\treturn fourSumCount;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nCount number of solutions to a + b + c + d  = 0\\n\\u21D2 a + b = -(c + d)\\n```\n```\\nnums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\\n\\nIterated over nums1 and nums2, pairSums = {1 + (-2), 1 + (-1), 2 + (-2), 2 + (-1)}\\n= {-1, 0, 0, 1}\\npairCountBySum = {-1 : 1, 0 : 2, 1 : 1}, i.e. there is 1 pair with sum = 1, 2 pairs with sum = 0, 1 pair with sum = -1\\n\\nIterated over nums3 and nums4, pairSums = {-1 + 0, -1 + 2, 2 + 0, 2 + 2}\\n= {-1, 1, 2, 4}\\nNegate this to be able to find -(c + d)\\n= {1, -1, -2, -4}\\n\\nUse the hashMap pairCountBySum = {-1 : 1, 0 : 2, 1 : 1} for each item in {1, -1, -2, -4}\\n\\nfourSumCount += map.get(1) \\u21D2 fourSumCount = 1\\nfourSumCount += map.get(-1) \\u21D2 fourSumCount = 1 + 1 = 2\\nfourSumCount += map.get(-2) \\u21D2 fourSumCount = 2 + 0 = 2\\nfourSumCount += map.get(-4) \\u21D2 fourSumCount = 2 + 0 = 2\\n\\nNumber of tuples = 2 [Ans]\\n```\n```\\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n\\tvar pairCountBySum = new HashMap<Integer, Integer>();\\n\\tfor (var num1 : nums1)\\n\\t\\tfor (var num2 : nums2)\\n\\t\\t\\tpairCountBySum.compute(num1 + num2, (k, sumCount) -> sumCount == null ? 1 : sumCount + 1);\\n\\n\\tvar fourSumCount = 0;\\n\\tfor (var num3 : nums3)\\n\\t\\tfor (var num4 : nums4)\\n\\t\\t\\tfourSumCount += pairCountBySum.getOrDefault(-(num3 + num4), 0);\\n\\n\\treturn fourSumCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307382,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n//     Take the arrays A and B, and compute all the possible sums of two elements. Put the sum in the Hash map, and increase the hash map value if more than 1 pair sums to the same value.\\n\\n// Compute all the possible sums of the arrays C and D. If the hash map contains the opposite value of the current sum, increase the count of four elements sum to 0 by the counter in the map.\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                int sum = nums1[i] + nums2[j];\\n                if(map.containsKey(sum)){\\n                    map.put(sum,map.get(sum)+1);\\n                }else{\\n                    map.put(sum,1);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<nums3.length;i++){\\n            for(int j=0;j<nums4.length;j++){\\n                int sum = -(nums3[i]+ nums4[j]);\\n                \\n                if(map.containsKey(sum)){\\n                    count = count + map.get(sum);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n//     Take the arrays A and B, and compute all the possible sums of two elements. Put the sum in the Hash map, and increase the hash map value if more than 1 pair sums to the same value.\\n\\n// Compute all the possible sums of the arrays C and D. If the hash map contains the opposite value of the current sum, increase the count of four elements sum to 0 by the counter in the map.\\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                int sum = nums1[i] + nums2[j];\\n                if(map.containsKey(sum)){\\n                    map.put(sum,map.get(sum)+1);\\n                }else{\\n                    map.put(sum,1);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<nums3.length;i++){\\n            for(int j=0;j<nums4.length;j++){\\n                int sum = -(nums3[i]+ nums4[j]);\\n                \\n                if(map.containsKey(sum)){\\n                    count = count + map.get(sum);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288139,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        \\n        //store the all possible sum from the first two vectors\\n        unordered_map<int,int> mp;\\n        for(auto a:nums1)\\n            for(auto b:nums2)\\n                mp[a+b]++;\\n        \\n        int res=0;\\n        for(auto c:nums3){\\n            for(auto d:nums4)\\n            {\\n                if(mp.find(-(c+d))!=mp.end())\\n                {\\n                    res+=mp[-(c+d)];\\n                }\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\\n        \\n        //store the all possible sum from the first two vectors\\n        unordered_map<int,int> mp;\\n        for(auto a:nums1)\\n            for(auto b:nums2)\\n                mp[a+b]++;\\n        \\n        int res=0;\\n        for(auto c:nums3){\\n            for(auto d:nums4)\\n            {\\n                if(mp.find(-(c+d))!=mp.end())\\n                {\\n                    res+=mp[-(c+d)];\\n                }\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227983,
                "title": "java-solution-o-n-2-time-o-n-2-space",
                "content": "```\\n public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer,Integer>map = new HashMap<>();\\n        \\n        for(int i:nums1){\\n            for(int j:nums2)\\n                map.put(i+j,map.getOrDefault(i+j,0)+1);\\n        }\\n        int count=0;\\n        for(int k:nums3){\\n            for(int l:nums4){\\n                count+=map.getOrDefault(-(k+l),0);\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\\n        Map<Integer,Integer>map = new HashMap<>();\\n        \\n        for(int i:nums1){\\n            for(int j:nums2)\\n                map.put(i+j,map.getOrDefault(i+j,0)+1);\\n        }\\n        int count=0;\\n        for(int k:nums3){\\n            for(int l:nums4){\\n                count+=map.getOrDefault(-(k+l),0);\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203433,
                "title": "python-simple-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        d = {}\\n        for a in nums1:\\n            for b in nums2:\\n                temp = a + b\\n                if temp not in d:\\n                    d[temp]=1\\n                else:\\n                    d[temp]+=1\\n        ans = 0\\n        for n1 in nums3:\\n            for n2 in nums4:\\n                tmp = 0  - (n1 + n2)\\n                if tmp in d: \\n                    ans += d[tmp]\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 1045599,
                "title": "python-binary-search",
                "content": "We can take advantage of the pairwise situation, and collect pairs for ab, and cd. We sort, then binary search for the complement of pairs in `ab` list. The idea is the exact same as the more brute force solutions. Also note that using the map pairs is technically more efficient since lookups are O(1).\\n\\nTime complexity: `n ^ 2 log n ` (log rules are: O(log(n^2)) is simply O(2 log(n)) = O(log(n))) where `n` is the length of the lists.\\nSpace: `O(n ^ 2)` \\n\\n```python\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        ans = 0\\n        ab = []\\n        cd = []\\n        \\n        n = len(A)\\n        m = len(B)\\n        ans = 0\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                ab.append((A[i] + B[j]))\\n                cd.append((C[i] + D[j]))\\n        \\n        ab.sort()\\n        cd.sort()\\n        \\n        for pair in ab:\\n            first_idx = bisect.bisect_left(cd, -pair)\\n            last_idx = bisect.bisect_right(cd, -pair)\\n            \\n            if first_idx != -1:\\n                ans += (last_idx - first_idx)\\n                \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        ans = 0\\n        ab = []\\n        cd = []\\n        \\n        n = len(A)\\n        m = len(B)\\n        ans = 0\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                ab.append((A[i] + B[j]))\\n                cd.append((C[i] + D[j]))\\n        \\n        ab.sort()\\n        cd.sort()\\n        \\n        for pair in ab:\\n            first_idx = bisect.bisect_left(cd, -pair)\\n            last_idx = bisect.bisect_right(cd, -pair)\\n            \\n            if first_idx != -1:\\n                ans += (last_idx - first_idx)\\n                \\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1033700,
                "title": "ksum-solution-w-comments",
                "content": "```\\n// ksum approach is not too hard if we think of the group of arrays as an n-ary tree and we are doing dfs on it\\n// we have the same 2 steps as the iterative solution\\nclass Solution {\\n    int tupleCount = 0;\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n    \\tif(A.length == 0) {\\n\\t\\t    return tupleCount;\\n        }\\n\\n        int[][] nums = new int[][]{A, B, C, D};\\n        HashMap<Integer, Integer> sums = new HashMap<Integer, Integer>();\\n        getFirstHalfMap(nums, sums, 0, 0);\\n        setTupleCount(nums, sums, (nums.length+1)/2, 0);  \\n        return tupleCount;\\n    }\\n    \\n    public void getFirstHalfMap(int[][] nums, HashMap<Integer, Integer> sums, int level, int sum) {\\n        // we want the first half of the arrays in our hashmap\\n        // so we define our base case as the stop condition of reaching the end of the first half\\n        if(level == ((nums.length+1)/2)) {\\n            // we have reached the end of our dfs so add the sum\\n            sums.put(sum, sums.getOrDefault(sum, 0)+1);\\n            return;\\n        }\\n        \\n        // we do dfs over the array where the current level elements are neighbors an we visit each neighbor\\'s children\\n        for(int i = 0; i < nums[level].length;i++) {\\n            getFirstHalfMap(nums, sums, level+1, sum+nums[level][i]);\\n        }\\n    }\\n    \\n    public void setTupleCount(int[][] nums, HashMap<Integer, Integer> sums, int level, int sum) {\\n        // we want to get the complement of sums of the second half of the arrays\\n        // so we define our base case as the stop condition of reaching the end of the second half\\n        if(level == nums.length) {\\n            int complement = 0-sum;\\n            // we have reached the end of our dfs, no more children so check if the complement exists\\n            if(sums.containsKey(complement)) {\\n                tupleCount += sums.get(complement);\\n            }\\n            return;\\n        }\\n        \\n        // dfs again\\n        for(int i = 0; i < nums[level].length;i++) {\\n            setTupleCount(nums, sums, level+1, sum+nums[level][i]);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// ksum approach is not too hard if we think of the group of arrays as an n-ary tree and we are doing dfs on it\\n// we have the same 2 steps as the iterative solution\\nclass Solution {\\n    int tupleCount = 0;\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n    \\tif(A.length == 0) {\\n\\t\\t    return tupleCount;\\n        }\\n\\n        int[][] nums = new int[][]{A, B, C, D};\\n        HashMap<Integer, Integer> sums = new HashMap<Integer, Integer>();\\n        getFirstHalfMap(nums, sums, 0, 0);\\n        setTupleCount(nums, sums, (nums.length+1)/2, 0);  \\n        return tupleCount;\\n    }\\n    \\n    public void getFirstHalfMap(int[][] nums, HashMap<Integer, Integer> sums, int level, int sum) {\\n        // we want the first half of the arrays in our hashmap\\n        // so we define our base case as the stop condition of reaching the end of the first half\\n        if(level == ((nums.length+1)/2)) {\\n            // we have reached the end of our dfs so add the sum\\n            sums.put(sum, sums.getOrDefault(sum, 0)+1);\\n            return;\\n        }\\n        \\n        // we do dfs over the array where the current level elements are neighbors an we visit each neighbor\\'s children\\n        for(int i = 0; i < nums[level].length;i++) {\\n            getFirstHalfMap(nums, sums, level+1, sum+nums[level][i]);\\n        }\\n    }\\n    \\n    public void setTupleCount(int[][] nums, HashMap<Integer, Integer> sums, int level, int sum) {\\n        // we want to get the complement of sums of the second half of the arrays\\n        // so we define our base case as the stop condition of reaching the end of the second half\\n        if(level == nums.length) {\\n            int complement = 0-sum;\\n            // we have reached the end of our dfs, no more children so check if the complement exists\\n            if(sums.containsKey(complement)) {\\n                tupleCount += sums.get(complement);\\n            }\\n            return;\\n        }\\n        \\n        // dfs again\\n        for(int i = 0; i < nums[level].length;i++) {\\n            setTupleCount(nums, sums, level+1, sum+nums[level][i]);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982131,
                "title": "simple-python-o-n-2-natural-reasoning",
                "content": "I derived the solution in a very natural way; this was fun to solve.\\n\\n**PURE BRUTEFORCE: O(N^4)**\\nFirst I consider bruteforce as you always should - loop through A, B, C, D: O(N^4). \\nGiven the constraint of 500 elements in each, the maximum # operations = 500^4 = 62,500,000,000 ~= 10^11. Modern computer does up to ~10^9 ops per second (1 bil). 10^11 clearly won\\'t pass the 10s limit of python (which is already a slow language to begin with). \\n\\nHow to cut down the complexity? I thought about math tricks, but I couldn\\'t find any. I realized that if you chose 3 positive numbers so far, the next one must be negative; if list D is sorted, this could potentially cut the search through D by half or so. But still, this will still be O(N^4) ish (maybe ~O(N^3.5) if there are very few negatives in D), which still sucks. \\n\\n**BETTER BRUTEFORCE: O(N^3), but not good enough**\\nAnother thing I always think about is to convert looping over lists into searching within sets/hashmaps. This is very fast and is practically O(1), not O(N). (for details I\\'m afraid you\\'ll have to consult a data structures tutorial)\\n\\tImportantly, I realized that if you already have the sum: ``` A[i] + B[j] + C[k]``` , you just need to find if ```-sum``` exists within D. This is possible once we convert D into a ```Counter()``` or simply a dictionary with ```keys = each number of D, and value = freqeuncy of that number.``` \\nSo, looping over A, B, C means O(N^3), which is much better, and is ~10^8 max # ops. But this is just counting looping, without all the hash creation, summing, and searching. Still, I gave it a shot, but it failed the last few test cases which had ~500 elements in each list, which wasn\\'t surprising. \\n\\n**SUCCESS: O(N^2)**\\nNow, I wondered how I could break this down into O(N^2). It is more simple than I imagined. Just loop through A & B, then make a hashmap of all summed values, and repeat for C & D. We just have to find all the sums in CD_hashmap (e.g. 2+3=5) that are the negative of those sums in AB_hashmap (e.g. -4-1=-5). Each time, we only do O(N^2) though we have to do this twice, which should be significantly faster than O(N^3) for bigger N like 500. \\n```\\nfrom collections import defaultdict\\nclass Solution: \\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        AB, CD = defaultdict(int), defaultdict(int)\\n        for i in range(len(A)):\\n            for j in range(len(B)):\\n                AB[A[i] + B[j]] += 1\\n        \\n        for k in range(len(C)):\\n            for l in range(len(D)):\\n                CD[C[k] + D[l]] += 1\\n        \\n        total = 0\\n        for ab in AB:\\n            total += CD[-ab] * AB[ab]\\n        return total\\n```\\nNote that you don\\'t actually need the second hashtable/dict/counter/whatever you want to call it. You can just search whether ```C[k]+D[l]``` exists in AB, and **add** the frequency of that sum in AB to total. Also note that in my implementation, I have to multiply ```CD[-ab] * AB[ab]```, not sum (you can check on pen & paper). The use of a defaultdict is just for convenience; I can just use dict, but I will have to check if the current sum `A[i] + B[j] `already exists in AB, if it does, += 1, if not, initialize the frequency to 1.",
                "solutionTags": [],
                "code": "``` A[i] + B[j] + C[k]```\n```-sum```\n```Counter()```\n```keys = each number of D, and value = freqeuncy of that number.```\n```\\nfrom collections import defaultdict\\nclass Solution: \\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        AB, CD = defaultdict(int), defaultdict(int)\\n        for i in range(len(A)):\\n            for j in range(len(B)):\\n                AB[A[i] + B[j]] += 1\\n        \\n        for k in range(len(C)):\\n            for l in range(len(D)):\\n                CD[C[k] + D[l]] += 1\\n        \\n        total = 0\\n        for ab in AB:\\n            total += CD[-ab] * AB[ab]\\n        return total\\n```\n```C[k]+D[l]```\n```CD[-ab] * AB[ab]```",
                "codeTag": "Java"
            },
            {
                "id": 976276,
                "title": "simple-java-solution-using-hashmap",
                "content": "```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int res=0;\\n        for(int itemA:A) {\\n            for(int itemB:B) {\\n                map.put(itemA+itemB,map.getOrDefault(itemA+itemB,0)+1);\\n            }\\n        }\\n        for(int itemC:C) {\\n            for(int itemD:D) {\\n                res+=map.getOrDefault(-1*(itemC+itemD),0);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int res=0;\\n        for(int itemA:A) {\\n            for(int itemB:B) {\\n                map.put(itemA+itemB,map.getOrDefault(itemA+itemB,0)+1);\\n            }\\n        }\\n        for(int itemC:C) {\\n            for(int itemD:D) {\\n                res+=map.getOrDefault(-1*(itemC+itemD),0);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975489,
                "title": "easy-to-understand-python3-solution-for-general-k",
                "content": "```\\nclass Solution:\\n    \\n    def helper(self, lists):\\n        c = collections.Counter()\\n        for tup in itertools.product(*lists):\\n            c[sum(tup)] += 1\\n        return c\\n    \\n    def kSumII(self, lists):\\n        half = len(lists) // 2\\n        c1 = self.helper(lists[:half])\\n        c2 = self.helper(lists[half:])\\n        return sum(c1[val]*c2[-val] for val in c1)\\n        \\n        \\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        return self.kSumII([A, B, C, D])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def helper(self, lists):\\n        c = collections.Counter()\\n        for tup in itertools.product(*lists):\\n            c[sum(tup)] += 1\\n        return c\\n    \\n    def kSumII(self, lists):\\n        half = len(lists) // 2\\n        c1 = self.helper(lists[:half])\\n        c2 = self.helper(lists[half:])\\n        return sum(c1[val]*c2[-val] for val in c1)\\n        \\n        \\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        return self.kSumII([A, B, C, D])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975486,
                "title": "my-java-and-python-solution-same-concept-of-hashmap-a-b-c-d",
                "content": "```\\nJava\\n\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int x: A) {\\n            for (int y : B) {\\n                map.put(x+y, map.getOrDefault((x+y), 0) + 1);\\n            }\\n        }\\n        int total = 0;\\n        for (int x: C) {\\n            for (int y:D) {\\n                total += map.getOrDefault(-1 * (x + y), 0);\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```\\n\\n\\n```\\nPython\\n\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        dictionary = collections.defaultdict(int)\\n        totalCount = 0\\n        for x in A:\\n            for y in B:\\n                dictionary[x+y] += 1\\n        \\n        for x in C:\\n            for y in D:\\n                totalCount += dictionary[-(x+y)]\\n        return totalCount\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nJava\\n\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int x: A) {\\n            for (int y : B) {\\n                map.put(x+y, map.getOrDefault((x+y), 0) + 1);\\n            }\\n        }\\n        int total = 0;\\n        for (int x: C) {\\n            for (int y:D) {\\n                total += map.getOrDefault(-1 * (x + y), 0);\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```\n```\\nPython\\n\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        dictionary = collections.defaultdict(int)\\n        totalCount = 0\\n        for x in A:\\n            for y in B:\\n                dictionary[x+y] += 1\\n        \\n        for x in C:\\n            for y in D:\\n                totalCount += dictionary[-(x+y)]\\n        return totalCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975390,
                "title": "easy-understandable-python-approach-o-ab-cd",
                "content": "Simple approach \\n\\nLogic is ```a+b = -(c+d)```\\n\\n```\\ndef fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        d = {}\\n        answer = 0\\n        \\n        for num in A:\\n            for num2 in B:\\n                d[num+num2] = d.get(num+num2, 0) + 1\\n        for num in C:\\n            for num2 in D:\\n                answer += d.get(-(num+num2), 0)\\n        return answer\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```a+b = -(c+d)```\n```\\ndef fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        d = {}\\n        answer = 0\\n        \\n        for num in A:\\n            for num2 in B:\\n                d[num+num2] = d.get(num+num2, 0) + 1\\n        for num in C:\\n            for num2 in D:\\n                answer += d.get(-(num+num2), 0)\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 905729,
                "title": "c-o-n-2-using-hash-map",
                "content": "```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n    int n = (int)A.size();\\n    int res = 0;\\n    vector<int> sum1(n*n);\\n    unordered_map<int, int> mapCdSum;\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < n; j++)\\n        {\\n            sum1[i*n + j] = A[i] + B[j];\\n            mapCdSum[C[i] + D[j]]++;\\n        }\\n    }\\n    for (int i = 0; i < n*n; i++)\\n    {\\n        res += mapCdSum[-sum1[i]];\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n    int n = (int)A.size();\\n    int res = 0;\\n    vector<int> sum1(n*n);\\n    unordered_map<int, int> mapCdSum;\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < n; j++)\\n        {\\n            sum1[i*n + j] = A[i] + B[j];\\n            mapCdSum[C[i] + D[j]]++;\\n        }\\n    }\\n    for (int i = 0; i < n*n; i++)\\n    {\\n        res += mapCdSum[-sum1[i]];\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 868899,
                "title": "simple-java-solution-o-n-2-time-and-space",
                "content": "```\\nclass Solution {\\n    /**\\n     * Approach: This solution uses a very simple approach.\\n     * We want to find a 4-number tuple in this form (a,b,c,d) and a + b + c + d = 0\\n     * where a is from A, b is from B and so on.\\n     *\\n     * We first compute all possible pairs of (c, d) and their sum then put them in a hash map.\\n     * The idea here is to compute all pair of sum(a, b) first and see if there is a value of -sum(a,b) in the hashmap.\\n     * If there is, then we found a tuple that satisfy the condition. \\n     * The reason is if a + b + c + d = 0, then we have (a + b) = -(c + d)\\n     *\\n     * Time complexity: O(N^2)\\n     * Space complexity: O(N^2)\\n     */\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int length = A.length;\\n        if (length == 0) return length;\\n        \\n        Map<Integer, Integer> tupleCD = new HashMap<>();\\n        for (int i = 0; i < length; i++) {\\n            for (int j = 0; j < length; j++) {\\n                int sumCD = C[i] + D[j];\\n                int freq = tupleCD.getOrDefault(sumCD, 0);\\n                tupleCD.put(sumCD, freq + 1);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < length; i++) {\\n            for (int j = 0; j < length; j++) {\\n                int sumAB = A[i] + B[j];\\n                int freq = tupleCD.getOrDefault(-sumAB, 0);\\n                ans += freq;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /**\\n     * Approach: This solution uses a very simple approach.\\n     * We want to find a 4-number tuple in this form (a,b,c,d) and a + b + c + d = 0\\n     * where a is from A, b is from B and so on.\\n     *\\n     * We first compute all possible pairs of (c, d) and their sum then put them in a hash map.\\n     * The idea here is to compute all pair of sum(a, b) first and see if there is a value of -sum(a,b) in the hashmap.\\n     * If there is, then we found a tuple that satisfy the condition. \\n     * The reason is if a + b + c + d = 0, then we have (a + b) = -(c + d)\\n     *\\n     * Time complexity: O(N^2)\\n     * Space complexity: O(N^2)\\n     */\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int length = A.length;\\n        if (length == 0) return length;\\n        \\n        Map<Integer, Integer> tupleCD = new HashMap<>();\\n        for (int i = 0; i < length; i++) {\\n            for (int j = 0; j < length; j++) {\\n                int sumCD = C[i] + D[j];\\n                int freq = tupleCD.getOrDefault(sumCD, 0);\\n                tupleCD.put(sumCD, freq + 1);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < length; i++) {\\n            for (int j = 0; j < length; j++) {\\n                int sumAB = A[i] + B[j];\\n                int freq = tupleCD.getOrDefault(-sumAB, 0);\\n                ans += freq;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851832,
                "title": "javascript-easy-and-faster-than-98-36",
                "content": "*Runtime: 136 ms, faster than 98.36% of JavaScript online submissions for 4Sum II.\\nMemory Usage: 51.7 MB, less than 87.50% of JavaScript online submissions for 4Sum II.*\\n\\n``` javascript\\nvar fourSumCount = function(A, B, C, D) {\\n    if (!A || !B || !C || !D) return [];\\n    // cuadratic solution... counter, reduced from sum_of_two\\n    let memory = new Map();\\n    for (let i of A) {\\n        for (let j of B) {\\n            memory.set(-(i + j), memory.get(-(i + j)) + 1 || 1);\\n        }\\n    }\\n    // look in the map if we have seen the complement of this sum\\n    let output = 0;\\n    for (let m of C) {\\n        for (let n of D) {\\n            output += memory.has(m + n)? memory.get(m + n): 0;\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar fourSumCount = function(A, B, C, D) {\\n    if (!A || !B || !C || !D) return [];\\n    // cuadratic solution... counter, reduced from sum_of_two\\n    let memory = new Map();\\n    for (let i of A) {\\n        for (let j of B) {\\n            memory.set(-(i + j), memory.get(-(i + j)) + 1 || 1);\\n        }\\n    }\\n    // look in the map if we have seen the complement of this sum\\n    let output = 0;\\n    for (let m of C) {\\n        for (let n of D) {\\n            output += memory.has(m + n)? memory.get(m + n): 0;\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 742478,
                "title": "rust-hashmap",
                "content": "```Rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn four_sum_count(a: Vec<i32>, b: Vec<i32>, c: Vec<i32>, d: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        let mut map = HashMap::new();\\n        for num_a in &a {\\n            for num_b in &b {\\n                *map.entry(num_a + num_b).or_insert(0) += 1;\\n            }\\n        }\\n        for num_c in &c {\\n            for num_d in &d {\\n                ans += map.get(&-(num_c + num_d)).unwrap_or(&0);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn four_sum_count(a: Vec<i32>, b: Vec<i32>, c: Vec<i32>, d: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        let mut map = HashMap::new();\\n        for num_a in &a {\\n            for num_b in &b {\\n                *map.entry(num_a + num_b).or_insert(0) += 1;\\n            }\\n        }\\n        for num_c in &c {\\n            for num_d in &d {\\n                ans += map.get(&-(num_c + num_d)).unwrap_or(&0);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739413,
                "title": "simple-c-solution",
                "content": "```\\nunordered_map<int,int> m1,m2;\\n        for(auto i:A)\\n            for(auto j:B)\\n                m1[i+j]++;\\n        for(auto i:C)\\n            for(auto j:D)\\n                m2[i+j]++;\\n        int answer=0;\\n        for(auto i:m1)\\n            if(m2[0-i.first]) answer+=i.second*m2[0-i.first];\\n        return answer;\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<int,int> m1,m2;\\n        for(auto i:A)\\n            for(auto j:B)\\n                m1[i+j]++;\\n        for(auto i:C)\\n            for(auto j:D)\\n                m2[i+j]++;\\n        int answer=0;\\n        for(auto i:m1)\\n            if(m2[0-i.first]) answer+=i.second*m2[0-i.first];\\n        return answer;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697336,
                "title": "java-concise-o-n-2-62ms",
                "content": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int a: A)\\n            for(int b: B)\\n                map.put(a+b, map.getOrDefault(a+b, 0) + 1);\\n        int count = 0;\\n        for(int c: C)\\n            for(int d: D)\\n                count += map.getOrDefault(-(c+d), 0);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int a: A)\\n            for(int b: B)\\n                map.put(a+b, map.getOrDefault(a+b, 0) + 1);\\n        int count = 0;\\n        for(int c: C)\\n            for(int d: D)\\n                count += map.getOrDefault(-(c+d), 0);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672817,
                "title": "c-o-n-2-using-dictionary-to-store-pair-sums",
                "content": "```csharp\\npublic int FourSumCount(int[] A, int[] B, int[] C, int[] D) \\n{\\n\\tDictionary<int, int> pairSums = new Dictionary<int, int>();\\n\\n\\tfor(int i = 0; i < A.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < B.Length; j++)\\n\\t\\t{\\n\\t\\t\\tint sum = A[i] + B[j];        \\n\\t\\t\\tif(pairSums.ContainsKey(sum))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpairSums[sum]++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tpairSums.Add(sum, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < C.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < D.Length; j++)\\n\\t\\t{\\n\\t\\t\\tint sum = -1 * (C[i] + D[j]);        \\n\\t\\t\\tif(pairSums.ContainsKey(sum))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount += pairSums[sum];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int FourSumCount(int[] A, int[] B, int[] C, int[] D) \\n{\\n\\tDictionary<int, int> pairSums = new Dictionary<int, int>();\\n\\n\\tfor(int i = 0; i < A.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < B.Length; j++)\\n\\t\\t{\\n\\t\\t\\tint sum = A[i] + B[j];        \\n\\t\\t\\tif(pairSums.ContainsKey(sum))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpairSums[sum]++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tpairSums.Add(sum, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < C.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < D.Length; j++)\\n\\t\\t{\\n\\t\\t\\tint sum = -1 * (C[i] + D[j]);        \\n\\t\\t\\tif(pairSums.ContainsKey(sum))\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount += pairSums[sum];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 637313,
                "title": "c-easy-solution-using-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        \\n        map<int,int> seen;\\n        \\n        for(auto x: A)\\n        {\\n            for(auto y: B)\\n            {\\n                seen[x+y]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto x: C)\\n        {\\n            for(auto y: D)\\n            {\\n                int s=x+y;\\n                if(seen.find(-s)!=seen.end()) ans+=seen[-s];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        \\n        map<int,int> seen;\\n        \\n        for(auto x: A)\\n        {\\n            for(auto y: B)\\n            {\\n                seen[x+y]++;\\n            }\\n        }\\n        int ans=0;\\n        for(auto x: C)\\n        {\\n            for(auto y: D)\\n            {\\n                int s=x+y;\\n                if(seen.find(-s)!=seen.end()) ans+=seen[-s];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580724,
                "title": "java-binary-search",
                "content": "```\\n\\nclass Solution {\\n    int findIndex(ArrayList<Integer> arr,int val,String side)\\n    {\\n        int index = -1,low=0,high=arr.size()-1,mid;\\n        while(low<=high){\\n            mid=(low+high)/2;\\n            if(side.equals(\"right\") && arr.get(mid)==val){\\n                index = mid;\\n                low=mid+1;\\n            }else if(side.equals(\"left\")&&arr.get(mid)==val){\\n                index = mid;\\n                high=mid-1;\\n            }else if(arr.get(mid)>val){\\n                high=mid-1;\\n            }else \\n                low=mid+1;\\n        }\\n        return index;\\n    }\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int n = A.length;\\n        ArrayList<Integer> aPlusB = new ArrayList<>();\\n         ArrayList<Integer> cPlusD = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++){\\n                aPlusB.add(A[i]+B[j]);\\n                cPlusD.add(C[i]+D[j]);\\n            }\\n        Collections.sort(aPlusB);\\n        Collections.sort(cPlusD);\\n        int res=0;\\n        for(int i=0;i<aPlusB.size();i++){\\n            int value = aPlusB.get(i);\\n            int firstIndex = findIndex(cPlusD,-1*value,\"left\");\\n            int lastIndex = findIndex(cPlusD,-1*value,\"right\");\\n            if(firstIndex!=-1){\\n                res+=(lastIndex-firstIndex+1);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n```\\n\\n\\nTime complexity is O((n*n)+log(n*n))",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    int findIndex(ArrayList<Integer> arr,int val,String side)\\n    {\\n        int index = -1,low=0,high=arr.size()-1,mid;\\n        while(low<=high){\\n            mid=(low+high)/2;\\n            if(side.equals(\"right\") && arr.get(mid)==val){\\n                index = mid;\\n                low=mid+1;\\n            }else if(side.equals(\"left\")&&arr.get(mid)==val){\\n                index = mid;\\n                high=mid-1;\\n            }else if(arr.get(mid)>val){\\n                high=mid-1;\\n            }else \\n                low=mid+1;\\n        }\\n        return index;\\n    }\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        int n = A.length;\\n        ArrayList<Integer> aPlusB = new ArrayList<>();\\n         ArrayList<Integer> cPlusD = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++){\\n                aPlusB.add(A[i]+B[j]);\\n                cPlusD.add(C[i]+D[j]);\\n            }\\n        Collections.sort(aPlusB);\\n        Collections.sort(cPlusD);\\n        int res=0;\\n        for(int i=0;i<aPlusB.size();i++){\\n            int value = aPlusB.get(i);\\n            int firstIndex = findIndex(cPlusD,-1*value,\"left\");\\n            int lastIndex = findIndex(cPlusD,-1*value,\"right\");\\n            if(firstIndex!=-1){\\n                res+=(lastIndex-firstIndex+1);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480285,
                "title": "java-solution",
                "content": "\\'\\'\\'class Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        \\n        HashMap<Integer,Integer> map1 = new HashMap<Integer,Integer>();\\n         int s1,n=A.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                s1=A[i]+B[j];\\n                if(map1.containsKey(s1))\\n                {\\n                    map1.put(s1,map1.get(s1)+1);\\n                }\\n                else\\n                    map1.put(s1,1);\\n            }\\n        }\\n        \\n        int c=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                s1=C[i]+D[j];\\n                               \\n                if(map1.containsKey(0-s1))\\n                {\\n                    c+=map1.get(0-s1);\\n                }                \\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        \\n        HashMap<Integer,Integer> map1 = new HashMap<Integer,Integer>();\\n         int s1,n=A.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                s1=A[i]+B[j];\\n                if(map1.containsKey(s1))\\n                {\\n                    map1.put(s1,map1.get(s1)+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 479860,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 56 ms, faster than 86.67% of Go online submissions for 4Sum II.\\nMemory Usage: 18.4 MB, less than 81.67% of Go online submissions for 4Sum II.\\n\\n```go\\nfunc fourSumCount(A []int, B []int, C []int, D []int) int {\\n    ans, tmp := 0, make(map[int]int)\\n    for _, a := range A {\\n        for _, b := range B {\\n            tmp[a + b]++\\n        }\\n    }\\n    for _, c := range C {\\n        for _, d := range D {\\n            ans += tmp[-(c + d)]\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc fourSumCount(A []int, B []int, C []int, D []int) int {\\n    ans, tmp := 0, make(map[int]int)\\n    for _, a := range A {\\n        for _, b := range B {\\n            tmp[a + b]++\\n        }\\n    }\\n    for _, c := range C {\\n        for _, d := range D {\\n            ans += tmp[-(c + d)]\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 464382,
                "title": "python3-o-n-2-solution-faster-than-94-05",
                "content": "```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        if len(A) == 0 or len(B) == 0 or len(C) == 0 or len(D) == 0:\\n            return 0\\n        sum_ab = {}\\n        for a in A:\\n            for b in B:\\n                sum_ = a+b\\n                if sum_ in sum_ab:\\n                    sum_ab[sum_] += 1\\n                else:\\n                    sum_ab[sum_] = 1\\n        ret = 0\\n        for c in C:\\n            for d in D:\\n                key = -1*(c+d)\\n                if key in sum_ab:\\n                    ret += sum_ab[key]\\n                \\n        return ret\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        if len(A) == 0 or len(B) == 0 or len(C) == 0 or len(D) == 0:\\n            return 0\\n        sum_ab = {}\\n        for a in A:\\n            for b in B:\\n                sum_ = a+b\\n                if sum_ in sum_ab:\\n                    sum_ab[sum_] += 1\\n                else:\\n                    sum_ab[sum_] = 1\\n        ret = 0\\n        for c in C:\\n            for d in D:\\n                key = -1*(c+d)\\n                if key in sum_ab:\\n                    ret += sum_ab[key]\\n                \\n        return ret\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 416954,
                "title": "python-faster-than-98-all-other-solutions",
                "content": "\\'\\'\\'\\n    def fourSumCount(self, A,B,C,D):\\n        output = 0\\n        thisDictC = {}\\n        thisDictD = {}\\n        \\n        if not A:\\n            return 0               \\n                \\n        for t in C:\\n            if t not in thisDictC:\\n                thisDictC[t] = 1\\n            else:\\n                thisDictC[t]+= 1\\n        for t in D:\\n            if t not in thisDictD:\\n                thisDictD[t] = 1\\n            else:\\n                thisDictD[t]+= 1\\n                \\n        firstTwoSums = {}\\n        for i in A:\\n            for j in B:\\n                key = -(i + j)\\n                if key not in firstTwoSums:\\n                    firstTwoSums[key] = 1\\n                else:\\n                    firstTwoSums[key] += 1\\n\\n        for i in thisDictC:\\n            for j in thisDictD:\\n                if (i + j) in firstTwoSums:\\n                    temp1 = thisDictC[i]\\n                    temp2 = thisDictD[j]\\n                    output += (firstTwoSums[i + j] * (temp1 * temp2))                   \\n        return output\\n\\'\\'\\'\\n The solution above has a Big O time of 2n^2. The output is the multiplication of all possible combinations at the given number.\\n Any questions feel free to ask. I\\'m not the best at explaining -_-\\n",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n    def fourSumCount(self, A,B,C,D):\\n        output = 0\\n        thisDictC = {}\\n        thisDictD = {}\\n        \\n        if not A:\\n            return 0               \\n                \\n        for t in C:\\n            if t not in thisDictC:\\n                thisDictC[t] = 1\\n            else:\\n                thisDictC[t]+= 1\\n        for t in D:\\n            if t not in thisDictD:\\n                thisDictD[t] = 1\\n            else:\\n                thisDictD[t]+= 1\\n                \\n        firstTwoSums = {}\\n        for i in A:\\n            for j in B:\\n                key = -(i + j)\\n                if key not in firstTwoSums:\\n                    firstTwoSums[key] = 1\\n                else:\\n                    firstTwoSums[key] += 1\\n\\n        for i in thisDictC:\\n            for j in thisDictD:\\n                if (i + j) in firstTwoSums:\\n                    temp1 = thisDictC[i]\\n                    temp2 = thisDictD[j]\\n                    output += (firstTwoSums[i + j] * (temp1 * temp2))                   \\n        return output\\n\\'\\'\\'\\n The solution above has a Big O time of 2n^2. The output is the multiplication of all possible combinations at the given number.\\n Any questions feel free to ask. I\\'m not the best at explaining -_-\\n",
                "codeTag": "Python3"
            },
            {
                "id": 401781,
                "title": "easy-to-understand-c-solution",
                "content": "Runtime: 156 ms, faster than 83.33% of C++ online submissions for 4Sum II.\\nMemory Usage: 28.5 MB, less than 86.36% of C++ online submissions for 4Sum II.\\n\\n```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int, int> mp;\\n        int count = 0;\\n        \\n        for(int i=0; i<C.size(); i++)\\n            for(int j=0; j<D.size(); j++)\\n                mp[C[i]+D[j]]++;\\n        \\n        for(int i=0; i<A.size(); i++)\\n            for(int j=0; j<B.size(); j++)\\n                if(mp.find(-(A[i]+B[j])) != mp.end())\\n                    count += mp[-(A[i]+B[j])];\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 156 ms, faster than 83.33% of C++ online submissions for 4Sum II.\\nMemory Usage: 28.5 MB, less than 86.36% of C++ online submissions for 4Sum II.\\n\\n```\\nint fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\\n        unordered_map<int, int> mp;\\n        int count = 0;\\n        \\n        for(int i=0; i<C.size(); i++)\\n            for(int j=0; j<D.size(); j++)\\n                mp[C[i]+D[j]]++;\\n        \\n        for(int i=0; i<A.size(); i++)\\n            for(int j=0; j<B.size(); j++)\\n                if(mp.find(-(A[i]+B[j])) != mp.end())\\n                    count += mp[-(A[i]+B[j])];\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 401476,
                "title": "java-solution-using-hashmap-with-explanation",
                "content": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        // convert problem to two-sum\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n\\n        // store all the possible sums and their frequency in the map\\n        for(int a : A) {\\n            for(int b : B) {\\n\\t\\t\\t    int sum = a + b;\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n\\n        // find the ones that equals to -sum in previous map, thus they add up to zero\\n        // and return their frequecy\\n        for(int c : C) {\\n            for(int d : D) {\\n                res += map.getOrDefault(-1 * (c + d), 0);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\\n        // convert problem to two-sum\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n\\n        // store all the possible sums and their frequency in the map\\n        for(int a : A) {\\n            for(int b : B) {\\n\\t\\t\\t    int sum = a + b;\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n\\n        // find the ones that equals to -sum in previous map, thus they add up to zero\\n        // and return their frequecy\\n        for(int c : C) {\\n            for(int d : D) {\\n                res += map.getOrDefault(-1 * (c + d), 0);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369919,
                "title": "python-simple-4-line-fast",
                "content": "```\\n\\'\\'\\'Shared is the intersection of the keys of hashmap s1 and s2, instead of checking all keys.\\'\\'\\'\\n\\nfrom collections import Counter\\ndef fourSumCount(A, B, C, D):\\n\\ts1 = Counter([-(i+j) for i in A for j in B])\\n\\ts2 = Counter([(i+j) for i in C for j in D])\\n\\tshared = s1.keys() & s2.keys()\\n\\treturn sum([s1[i]*s2[i] for i in shared])\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'Shared is the intersection of the keys of hashmap s1 and s2, instead of checking all keys.\\'\\'\\'\\n\\nfrom collections import Counter\\ndef fourSumCount(A, B, C, D):\\n\\ts1 = Counter([-(i+j) for i in A for j in B])\\n\\ts2 = Counter([(i+j) for i in C for j in D])\\n\\tshared = s1.keys() & s2.keys()\\n\\treturn sum([s1[i]*s2[i] for i in shared])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 343289,
                "title": "c-simple-solution-hope-you-like-it",
                "content": "\\u2018\\u2019\\u2019\\n\\n\\t\\tunordered_map<int, int> record;\\n\\t\\tfor (int i = 0; i < C.size(); i++)\\n\\t\\t\\tfor (int j = 0; j < D.size(); j++)\\n\\t\\t\\t\\trecord[C[i] + D[j]]++;\\n\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < A.size(); i++)\\n\\t\\t\\tfor (int j = 0; j < B.size(); j++)\\n\\t\\t\\t\\tif (record.find(0 - A[i] - B[j]) != record.end())\\n\\t\\t\\t\\t\\tres += record[0 - A[i] - B[j]];\\n\\n\\t\\treturn res;\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\u2018\\u2019\\u2019\\n\\n\\t\\tunordered_map<int, int> record;\\n\\t\\tfor (int i = 0; i < C.size(); i++)\\n\\t\\t\\tfor (int j = 0; j < D.size(); j++)\\n\\t\\t\\t\\trecord[C[i] + D[j]]++;\\n\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < A.size(); i++)\\n\\t\\t\\tfor (int j = 0; j < B.size(); j++)\\n\\t\\t\\t\\tif (record.find(0 - A[i] - B[j]) != record.end())\\n\\t\\t\\t\\t\\tres += record[0 - A[i] - B[j]];\\n\\n\\t\\treturn res;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570039,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1566088,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1565810,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1566102,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1576330,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1742515,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1808637,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1749465,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1720484,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1625352,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1570039,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1566088,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1565810,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1566102,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1576330,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1742515,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1808637,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1749465,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1720484,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            },
            {
                "id": 1625352,
                "content": [
                    {
                        "username": "am_",
                        "content": "Hmm, seems tough\\nBrute force is staright forward: O(n^4).\\nUmm, how to optimize\\noh wait, can i use a min heap based approach as in merging k sorted lists\\nNo, wont work. The whole point of that method is just to get a sorted sequeuence. It won\\'t traverse all combintaions\\nMaybe i\\'m going on the wrong path, let\\'s read the problem again and see if i get any insights\\nOh yeah! given a,b,c , I can binary search for the last value after sorting the last row. Atleast got a O(n^3) logn\\nWhat\\'s stopping from using a map for last row, making it O(n^3)!. \\nIf i can use map for last row, i can use map for c+d, and search for a+b pairs....\\n\\nThe part to get to binary search took me 20-25 mins and then reaching to map and writing the code and submitting around 10 minutes. So perseverance is the key. You will land on a solution sooner or later\\n"
                    },
                    {
                        "username": "SergeGardien",
                        "content": "This question has \"Binary Search\" as a tag but in the solutions proposed (in discuss) I don't see it used. How is that?\\nIs it actually possible to use binary search to solve such problem?"
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Binary Search\" is no more. Just \"Array\" and \"Hash table\". Though the fastest solutions don\\'t use any hash tables either."
                    },
                    {
                        "username": "joban9872",
                        "content": "here is the binary search solution but it gets TLE\nhttps://leetcode.com/problems/4sum-ii/submissions/1015665178/"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "[@qiushile](/qiushile) well binary search can be used to find weather a particular element is present in any array. so you can sort the last array since the max size of array is 200 so sorting wont be an issue and then we can use binary search in log(200) = 8 operations. but we can use hash map to do it in O(1) \\nThey might have put binary search bcz some people might use ordered_map"
                    },
                    {
                        "username": "qiushile",
                        "content": "You can find out your answer in the official solution but it need money"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/4sum-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** kSum II\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "moonrainbow",
                        "content": "I wrote 4 variants of code for this question. The reason it didn\\'t get accepted the first time? Simple - time limit. Took me that long (30 minutes, at least) to figure out that a+b=-(c+d). Even then I wrote a solution with 2 maps in Java and it beat barely 4.XX% of all submissions. I call bullshit here. I might not be the brightest tool in the drawer - granted, but how fast your normal engineer can figure this out during an interview? My first submission included a sum of 3 arrays with a look-up of the 4th component in a Map. It\\'s a perfectly legitimate solution that covers much of JDK knowledge and algorithms. What exactly is contibuted to the assessment of a candidate by the math here?\\nIn a real life I\\'d have an SLA that would tell me how fast this would need to go and I\\'d have some time to figure out the best approach, if I was faced with a problem like this. Adding math to the interview question seems entirely detrimental to the purpose of the interview."
                    },
                    {
                        "username": "the_codinator",
                        "content": "I know the O(n^2) HashMap based Solution where we count all (a+b) and the search for all -(c+d). This is what I implemented and it takes roughly 100ms on the submission. I looked at a few of the fastest solutions of about 65-75ms, and I see that in all the solutions, all the 4 arrays were first sorted (using Arrays.sort) and then the same hashmap based algorithm was applied... How does the addition of this sorting improve the performance so significantly ?? Instead of increase in time due to 4x O(nlogn) sorting, I see that the performance has improved by 25-30% ?? Does the sorting somehow have some internal benefits to the HashMap ? Any ideas here ?"
                    },
                    {
                        "username": "ayus786",
                        "content": "I am confused why it will give TLE for O(n^3) solution. As per question, size of n is under 200, So n^3-> 200^3 which will result as 8 * 10^6 and i think it should work and if we take check the value in hash table then it will cause O(1) time. So why is it giving TLE in O(n^3) solution.\nBelow is one solution for O(n^3).\n\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> mp;\n        for(auto i:nums4) mp[i]++;\n        int n=nums1.size();\n        int sum=0;\n        for(auto i:nums1){\n            for(auto j:nums2){\n                for(auto k:nums3){\n                    sum+=mp[-1*(i+j+k)];\n                }\n            }\n        }\n        return sum;\n    }\n};\n```"
                    },
                    {
                        "username": "realitant",
                        "content": "That\\'s not how big-O notation works. All that time complexity tells you is comparative runtimes as n approaches infinity. As soon as you start plugging in values for n, it loses all meaning. It\\'s entirely possible (though unlikely in this case) that an optimized O(n^4) solution could pass while an inefficient O(n^3) solution times out."
                    },
                    {
                        "username": "aayu1784",
                        "content": "idk what\\'s the problem with this. facing same issue.\\nis shouldn\\'t give TLE."
                    },
                    {
                        "username": "user8296H",
                        "content": "So, the most efficient complexity is O(n^2) for time and space ?"
                    },
                    {
                        "username": "mbansalmrt",
                        "content": "What if I store all the values of the four arrays with indices as pairs in a single array, indices will represent from which array the element initially belonged to [1-4]\\nThen apply 4sum problem logic with one additional condition that all the indices are different to make sure that all elements are from different arrays\\nWill that be right? "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just wasted my time thinking the tuples should be  unique as they were in 4Sum  :("
                    },
                    {
                        "username": "tanmay8043",
                        "content": "hi guys, I need help. \nI was trying to solve this question. The `hashmap` solution was pretty straightforward but I need help with the following solution:\n ```\npublic int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int n = nums1.length;\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n        Arrays.sort(nums4);\n        int res=0;\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                int lo =0;\n                int hi = n-1;\n                int target = -(nums1[i] + nums2[j]);\n                while(lo <= hi){                    \n                    if(nums3[lo] + nums4[hi] == target){ \n                        res++;\n                        System.out.println(nums1[i]+ \" \"+nums2[j]+ \" \"+nums3[lo]+ \" \"+nums4[hi]+ \"=\"+ target);\n                        break; // i reckon there's a need to change in break statement\n                    }\n                    else if(nums3[lo] + nums4[hi] < target) lo++;\n                    else hi--;\n                }\n            }\n        }\n        return res;\n    }\n```\nPlease help!!!\nIs there even a solution possible with the above code?"
                    },
                    {
                        "username": "2212573",
                        "content": "bhai mera bhi same problem hai please solve"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "The termination condition of the inner while loop should be \"lo < n && hi >= 0\". Since after you find one pair matching the solution, there are still other valid pairs, and you need to continue the search until one pointer goes out of the boundary.\n\nAnd you need to deal with duplicates. E.g. target = 0; nums3=[-1,1, 1], nums4=[-1,-1,1]\n\nThe while loop should be\n```\n                while(lo < n && hi >= 0){                    \n                   if(nums3[lo] + nums4[hi] == target){\n                       int cntLo = 1;\n                       int cntHi = 1;\n                       // Count all possible duplicates.\n                       lo++;\n                       while(lo < n && nums3[lo] == nums3[lo-1]) {\n                        cntLo++;\n                        lo++;\n                       }\n                       hi--;\n                       while(hi >= 0 && nums4[hi] == nums4[hi + 1]) {\n                        cntHi++;\n                        hi--;\n                       }\n                       res += cntLo * cntHi;\n                   } else if (nums3[lo] + nums4[hi] < target)\n                       lo++;\n                   else \n                       hi--;\n               }\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Brick Wall",
        "question_content": "<p>There is a rectangular brick wall in front of you with <code>n</code> rows of bricks. The <code>i<sup>th</sup></code> row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.</p>\n\n<p>Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.</p>\n\n<p>Given the 2D array <code>wall</code> that contains the information about the wall, return <em>the minimum number of crossed bricks after drawing such a vertical line</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\" style=\"width: 493px; height: 577px;\" />\n<pre>\n<strong>Input:</strong> wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> wall = [[1],[1],[1]]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == wall.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= wall[i].length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= sum(wall[i].length) &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>sum(wall[i])</code> is the same for each row <code>i</code>.</li>\n\t<li><code>1 &lt;= wall[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 888577,
                "title": "intuitive-explanation-in-c-java-w-pictures-w-comments",
                "content": "![image](https://assets.leetcode.com/users/images/d55b627a-2d87-4f09-b064-310a8bce0377_1602342798.4437773.png)\\n\\n***Intuition:-***\\nThe above wall is represented in a 2D Array where each element is the **size** of the respective brick :\\n[[1,2,2,1],\\n[3,1,2],\\n[1,3,2],\\n[2,4],\\n[3,1,2],\\n[1,3,1,1]]\\n\\nNote : Size of each brick is at least 1 unit.\\n\\nSo to mininize the number of bricks crossed by line, we want the line to pass through as many edges as possible.\\nFor this approach the edge postion will be defined with respect to the leftmost edge.\\n![image](https://assets.leetcode.com/users/images/af224f0c-e14b-4117-829c-a6f509c0c519_1602344960.0595038.png)\\n\\nIn the above picture, the leftmost edge is conscidered to be at *0th* postion. Hence the optimal line crosses from the edge \"**4**\".\\n\\nBut how do we figure out that the line which passes from the edge 4 is optimal ?\\nWe can do that by storing each brick\\'s edge & looking out for common edges through which the line can pass.\\n\\n![image](https://assets.leetcode.com/users/images/c6f4f639-b41e-4f6f-a678-0ff8be3b9755_1602346638.7041118.png)\\n\\nAny edge position can be calculated by the sum of the lenghts of bricks observed till that edge.\\nLike in the above diagram :\\nEdge Position = Length of 1st Brick + Length of 2nd Brick\\n=> Edge Position = 1 + 2\\n=> Edge Position = 3\\n\\nNOTE: ***You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.***\\nBecause of this note we won\\'t consider the ***edge 0*** & ***edge 6*** to solve the question.\\n![image](https://assets.leetcode.com/users/images/db68928a-3baf-4d67-baad-7410dcb8307e_1602358144.364781.png)\\n\\nOne interesting observation is that for calculating next edge position, we don\\'t have to start adding the lengths from the very first brick of the row. Instead, we can add the \"Sum of lengths of bricks obervered till the previous edge\" + current brick\\'s length.\\nSo,\\nNext Edge Position = (Sum of lengths of bricks observered till the previous edge) + Current Brick\\'s Length.\\n=> **Next Edge Position = Previous Edge Position + Current Brick\\'s Length**\\n![image](https://assets.leetcode.com/users/images/ff66fbe5-5aaa-44a0-9867-443658e561e5_1602409975.487065.png)\\n\\n\\nUsing the same logic, we can calculate every edge\\'s position in the wall\\n![image](https://assets.leetcode.com/users/images/df791514-be1d-496e-8897-b86e8b9ddb6b_1602357507.7656312.png)\\n\\n**The edge which happens to be in multiple rows will contribute to the optimal solution as the line passing through that common edge will result in minimun crossing/cutting of bricks.**\\nHence we wanna find the edge that has higest frequency in the wall.\\n\\nNow comes an important question, which data structure should we use and why?\\n**Suggestion :**\\n*How about using a data-structure that stores the 2-dimentional grid information via which we can access any position\\'s info (whether its a brick or an edge) in a constant time?*\\n**Analysis of Suggestion :** \\n*The problem of using a 2D grid is that we will be storing the edge\\'s positions as well as the brick\\'s positions. So we are wasting space in storing all the brick\\'s coordinates.*\\n**Optimizing the Suggestion :**\\n*So if we look into our requirement, we are only concerned with the pair of \"position of the edge\" & \"its frequency in the wall\". We don\\'t care about the brick\\'s position. HashMap seems like a perfect data structure to store the pair*\\n\\nHence we will store every calculated edge in a HashMap.\\nStructure of the HashMap :\\n**Key of HashMap = Edge Position**\\n**Value of HashMap = Frequency of Edge in the Entire Wall**\\n![image](https://assets.leetcode.com/users/images/ab772be9-7be0-4985-8d01-7515dd73d1c7_1619437012.802769.png)\\n\\n![image](https://assets.leetcode.com/users/images/0f0a4a61-2c4a-4ff4-9aaa-21099ceef28a_1623125674.4072828.png)\\n![image](https://assets.leetcode.com/users/images/eb868c19-89fb-49a8-b3b4-804743ff6197_1623125744.9454632.png)\\n![image](https://assets.leetcode.com/users/images/5bf89742-bbe7-4c36-98dd-f0771771c46d_1623125755.2961688.png)\\n![image](https://assets.leetcode.com/users/images/b1481576-6511-47de-b440-0be449843699_1623125761.956156.png)\\n![image](https://assets.leetcode.com/users/images/4a5fa365-9048-4543-85c2-526a6f8bbf04_1623125769.1751635.png)\\n\\n![image](https://assets.leetcode.com/users/images/67578355-6f58-458a-9f8f-c8ec72eb4099_1619437107.3954344.png)\\n\\nFrom the hashmap we can clearly see that **edge 4** is the edge having maximum frequency.\\n![image](https://assets.leetcode.com/users/images/9584ee2a-e268-41e3-ac34-7e2bfca8de0b_1602359532.5487833.png)\\n\\nNow we are sure that the line passing from edge 4 will result in minimum crossing of bricks.\\nBut we need to return the number of crossing the line makes.\\nIn the above diagram,\\n*Red Box = Line passing through an edge*\\n*Blue Box = Line crossing through a brick*\\n\\nHence a fomulae can be derived:\\nNumber of Blue Boxes+ Number of Red Boxes = Number of Rows in Wall\\n=> Number of Blue Boxes + (Frequency of Most Occuring Edge) = Number of Rows in Wall\\n=> (Number of Bricks Crossed by Line) + (Frequency of Most Occuring Edge) = Number of Rows in Wall\\n=> (Number of Bricks Crossed by Line) = Number of Rows in Wall - (Frequency of Most Occuring Edge)\\n\\n***Number of Bricks Crossed by Line* = *Number of Rows in Wall* - *Frequency of Most Occuring Edge***\\n\\nHence\\nNumber of Bricks Crossed by Line = Number of Rows in Wall - Frequency of Most Occuring Edge\\n=> Number of Bricks Crossed by Line = 6 - 4\\n=> Number of Bricks Crossed by Line = **2** (We return this answer)\\n\\nBelow is the **C++** Code of the above mentioned logic:\\n\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) \\n    {\\n        unordered_map<int, int> edge_frequency;     //HashMap to store the number of common edges among the rows\\n        int max_frequency = 0;         //Variable to store the frequency of most occuring edge\\n        \\n        for(int row=0; row<wall.size(); row++)        //Iterating through each row\\n        {\\n            int edge_postion = 0;       //Variable to store different edge postion\\n            \\n            for(int brick_no=0; brick_no< wall[row].size() -1; brick_no++)    //Iterating through each brick inside a row\\n            { \\n                int current_brick_length = wall[row][brick_no];  //Length of the current brick\\n                edge_postion = edge_postion + current_brick_length ;  //Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n                edge_frequency[edge_postion]++;  //Incrementing the Frequency of just calculated Edge Postion\\n                max_frequency = max(edge_frequency[edge_postion],max_frequency);  //Comparing the \"Frequency of just calculated Edge Postion\" with \"Max Frequency seen till now\" & storing whichever is greater.\\n            }\\n        }\\n        return wall.size() - max_frequency; // returning (Number of Bricks Crossed by Line) i.e. (Number of Rows in Wall - Frequency of Most Occuring Edge) \\n    }\\n};\\n```\\nBelow is the **Java** Code of the above mentioned logic:\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) \\n    {\\n        HashMap<Integer, Integer> edge_frequency = new HashMap<>(); //HashMap to store the number of common edges among the rows\\n        int max_frequency = 0; //Variable to store the frequency of most occuring edge\\n        \\n        for(int row=0; row<wall.size(); row++) //Iterating through each row\\n        {\\n            int edge_postion = 0; //Variable to store different edge postion\\n            \\n            for(int brick_no=0; brick_no<wall.get(row).size()-1; brick_no++) //Iterating through each brick inside a row\\n            {\\n                int current_brick_length = wall.get(row).get(brick_no); //Length of the current brick\\n                edge_postion = edge_postion + current_brick_length; //Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n                edge_frequency.put(edge_postion,edge_frequency.getOrDefault(edge_postion,0)+1); //Incrementing the Frequency of just calculated Edge Postion\\n                max_frequency = Math.max(edge_frequency.get(edge_postion),max_frequency); //Comparing the \"Frequency of just calculated Edge Postion\" with \"Max Frequency seen till now\" & storing whichever is greater.\\n            }\\n        }\\n        return wall.size() - max_frequency; // returning (Number of Bricks Crossed by Line) i.e. (Number of Rows in Wall - Frequency of Most Occuring Edge)\\n    }\\n}\\n```\\n\\n**Time Complexity : O(N * M)**, \\n*where N = hieght of the wall OR number of rows in wall\\nwhere M = approx width of each row OR approx number of bricks in each row\\nwhere N * M = Total number of bricks in the wall*\\n[Since we iterated through each brick once to calucluate the edge postion hence the time complexity would be equal to the total number of bricks.]\\n\\n**Space Complexity :  O(M)**,\\n*where M = Approx number of bricks in each row*\\n[Since we are using a HashMap to store the number frequency of each edge postion, the space complexity would be equal to the maximum number of edges possible in the wall. \\nSo, Maximum Number of Edges = (Approx number of bricks in each row) - 1 = M - 1 \\nHence space complexity equal to M-1, which approximates to M]\\n\\n**Edge Case 1 : wall = [ [1], [1], [1] ]**\\n**Expected Output : 3**\\n![image](https://assets.leetcode.com/users/images/fedda19b-24a9-4bd9-80ad-8fd94d54efac_1602366278.1775723.png)\\nSince we can\\'t cross the walls via *purple* lines (i.e. We can\\'t cross via the leftmost & the rightmost edge).\\nThe only option left is to cross via the *blue* line (i.e. Cross the wall by cutting through each brick).\\nHence the number of bricks crossed is 3. (Encircled by Red Box)\\nIn our code the second \"for\" loop won\\'t run, due to which the maximum frequency remains zero.\\nHence we\\nreturn \"wall.size() - max_frequency\"\\n=> return \"wall.size() - 0\"\\n=> return \"3 - 0\"\\nThat is \"3\" is returned as the answer.\\n\\n**Edge Case 2 : wall = [ [1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1] ]**\\n**Expected Output : 0**\\n![image](https://assets.leetcode.com/users/images/4f211db3-9e6e-4127-b520-33dc5c83afb9_1602368154.9120328.png)\\nJust like the previous edge case, we can\\'t cross the walls via *red* lines (i.e. We can\\'t cross via the leftmost & the rightmost edge).\\nIn this case, we do find some edges (Enrciled in yellow/purple/brown boxes), hence we don\\'t need to cut through the bricks like we did in the previous edge case. Note that the occurence of each edge is equal to the number of rows. (Its visible in the hashmap)\\nBut since there are multiple maximum frequency present in the hashmap (Three 4s), hence we can select any one of the edges.\\nWhich gives us 3 possible lines to draw (blue lines in the diagram)\\nSo \"edge frequency = number of rows\" means that there exists an edge that is aligned in each row from top to bottom such that the line can pass without cutting any brick. Hence the number of bricks cutted is 0. (Clearly visible in the diagram)\\nIn our code, the maximum frequency will be setted to \"4\" (Which is retrived via hashmap)\\nHence we\\nreturn \"wall.size() - max_frequency\"\\n=> return \"wall.size() - 4\"\\n=> return \"4 - 4\"\\nThat is \"0\" is returned as the answer.\\n\\n****************************************** THE END ******************************************\\n\\n**Doubt (by @astroash):**\\nI think that the space complexity will be O(mn) and not O(m). You mentioned \"the space complexity would be equal to the maximum number of edges possible in the wall\". In the worst case (staggered arrangement of bricks), this value will be equal to the total number of bricks in the wall which is mn. You assumed that this value will be equal to the maximum number of bricks in a single row, but all the bricks might account for a new edge distance too.\\n\\n**Clarification of space complexity analysis confusion:**\\n\\tI understand your confusion. Let me elaborate on the same. The worst-case scenario (staggered arrangement of bricks) is covered in **Edge Case 2**. (Picture Link: https://assets.leetcode.com/users/images/4f211db3-9e6e-4127-b520-33dc5c83afb9_1602368154.9120328.png)\\n\\n**1st Doubt:** \"*You assumed that this value will be equal to the maximum number of bricks in a single row*\"\\n**My Response:** As per your understanding, I\\'m assuming that space complexity will be equal to the maximum number of bricks in a SINGLE row. That is incorrect, I\\'m looking for DIFFERENT TYPES of edges in the ENTIRE wall. So doesn\\'t matter which row I look into.\\n\\n**2nd Doubt:** \"*but all the bricks might account for a new edge distance too.*\"\\n**My Response:** Does it really account for a new edge distance? And only because the bricks are in a different row?\\n\\nImagine every row in the wall has an edge distance of 1 unit only. And total rows are 3.\\n\\t\\t1) So the hashmap <edge, frequency> will have an entry as <(1,3)>. Meaning the ENTIRE wall has only an edge distance of 1 and that occurred 3 times. Now Add a 4th row, with an edge distance of 1 in it.\\n\\t\\t2) Hashmap <edge, frequency> will now look something like <(1,4)>. Meaning the ENTIRE wall has only an edge distance of 1 and that occurred 4 times. Now Add a 5th row, with an edge distance of 2 in it.\\n\\t\\t3) Hashmap <edge, frequency> will now look something like <(1,4), (2,1)>. Meaning the ENTIRE wall has an edge distance of 1 that occurred 4 times & an edge distance of 2 that occurred 1 time.\\n\\nSo what increased the size of the hashmap? Adding the 4th row or the 5th row? \\n5th row, right? It was because the 5th row came along with a NEW edge distance that resulted in a new key-value pair in the hashmap.\\n\\nNow coming back to your question, \"won\\'t the same edge in a different row account for a new edge distance?\"\\nLook at what happened when you added the 4th row in the example, the hashmap went from <(1,3)> to <(1,4)>. The edge in the new row was the same as that in all the other rows. Because of which the value of an EXISTING pair in the hashmap changed from 3 to 4 and no new pair was added to the hashmap.\\n\\nSo m * n will result in counting the same edge multiple times and that is not the actual size of the hashmap. The size of the hashmap is determined by the number of different key-value pairs in it. The MAGNITUDE of the value has NOTHING to do with the space complexity. I hope this answers your question.",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) \\n    {\\n        unordered_map<int, int> edge_frequency;     //HashMap to store the number of common edges among the rows\\n        int max_frequency = 0;         //Variable to store the frequency of most occuring edge\\n        \\n        for(int row=0; row<wall.size(); row++)        //Iterating through each row\\n        {\\n            int edge_postion = 0;       //Variable to store different edge postion\\n            \\n            for(int brick_no=0; brick_no< wall[row].size() -1; brick_no++)    //Iterating through each brick inside a row\\n            { \\n                int current_brick_length = wall[row][brick_no];  //Length of the current brick\\n                edge_postion = edge_postion + current_brick_length ;  //Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n                edge_frequency[edge_postion]++;  //Incrementing the Frequency of just calculated Edge Postion\\n                max_frequency = max(edge_frequency[edge_postion],max_frequency);  //Comparing the \"Frequency of just calculated Edge Postion\" with \"Max Frequency seen till now\" & storing whichever is greater.\\n            }\\n        }\\n        return wall.size() - max_frequency; // returning (Number of Bricks Crossed by Line) i.e. (Number of Rows in Wall - Frequency of Most Occuring Edge) \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) \\n    {\\n        HashMap<Integer, Integer> edge_frequency = new HashMap<>(); //HashMap to store the number of common edges among the rows\\n        int max_frequency = 0; //Variable to store the frequency of most occuring edge\\n        \\n        for(int row=0; row<wall.size(); row++) //Iterating through each row\\n        {\\n            int edge_postion = 0; //Variable to store different edge postion\\n            \\n            for(int brick_no=0; brick_no<wall.get(row).size()-1; brick_no++) //Iterating through each brick inside a row\\n            {\\n                int current_brick_length = wall.get(row).get(brick_no); //Length of the current brick\\n                edge_postion = edge_postion + current_brick_length; //Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n                edge_frequency.put(edge_postion,edge_frequency.getOrDefault(edge_postion,0)+1); //Incrementing the Frequency of just calculated Edge Postion\\n                max_frequency = Math.max(edge_frequency.get(edge_postion),max_frequency); //Comparing the \"Frequency of just calculated Edge Postion\" with \"Max Frequency seen till now\" & storing whichever is greater.\\n            }\\n        }\\n        return wall.size() - max_frequency; // returning (Number of Bricks Crossed by Line) i.e. (Number of Rows in Wall - Frequency of Most Occuring Edge)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137777,
                "title": "java-map-solution",
                "content": "The idea is straightforward, since each brick length is positive, we can record all the edge index in the wall and figure out which edge index is the most common. We cut through that edge index, it will cross ```number of rows - most common edge count``` rows\\n\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int count = 0;\\n        for (List<Integer> row : wall) {\\n            int sum = 0;\\n            for (int i = 0; i < row.size() - 1; i++) {\\n                sum += row.get(i);\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n                count = Math.max(count, map.get(sum));\\n            }\\n        }\\n        \\n        return wall.size() - count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```number of rows - most common edge count```\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int count = 0;\\n        for (List<Integer> row : wall) {\\n            int sum = 0;\\n            for (int i = 0; i < row.size() - 1; i++) {\\n                sum += row.get(i);\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n                count = Math.max(count, map.get(sum));\\n            }\\n        }\\n        \\n        return wall.size() - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170869,
                "title": "short-simple-solution-w-explanation-comments-beats-100",
                "content": "We are given a brick wall with different width of bricks inside it. We are required to draw a line from top to bottom which intersects the least number of bricks. Passing the line thorugh the edges of brick don\\'t count as intersections.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution (Using HashMap)***\\n\\nIn each row of *Brick Wall*, there maybe a brick-edge (where one brick ends and next one starts) at any index from **`[0, W]`** (where `W` is the width of Brick Wall). \\n\\nNow, to get the least number of intersections, we must draw a line starting at top from some wall index `idx` such that the **number of brick edges at that index is maximum**. This will ensure that we have least number of brick intersections.\\n\\nFor this, we can use a **hashmap to store each index** and **map it with frequency of brick edges at that index**. This can be done by iterating each row of wall. For each brick-edge on that row, increment frequncy for the corresponding index `idx`. The next index can be successively found by adding the current brick width to `idx`\\n\\nLastly, we draw a line starting from the brick index where maximum number of brick edges frequency was found.\\n\\n```\\nint leastBricks(vector<vector<int>>& wall) {\\n\\tint rows = size(wall), maxBrickEdges = 0, idx;\\n\\tunordered_map<int, int> edgesFrequency; // will map index to count of brick edges at that index\\n\\tfor(auto& row : wall) {\\n\\t\\t// idx: denotes index of wall. We add each brick-width of row to find the next index having brick edge\\n\\t\\tidx = 0; \\n\\t\\tfor(int i = 0; i < size(row) - 1; i++) // ignore last brick, since we don\\'t want to count wall edge index\\n\\t\\t    idx += row[i], edgesFrequency[idx]++;\\n    }\\n\\t// Lastly find the maximum number of brickEdges found at any index\\n\\tfor(auto& pair : edgesFrequency) maxBrickEdges = max(maxBrickEdges, pair.second);\\n\\t// Rest of the bricks(excluding maxBrickEdges) would be intersected which is the minimum answer\\n\\treturn rows - maxBrickEdges;\\n}\\n```\\n\\n***Time Complexity :*** **`O(R*W)`**, where *`R`* is the number of rows in Brick Wall and *`W`* is the width of each row.\\n***Space Complexity :*** **`O(W)`**, required to maintain hashmap.\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (HashMap in One-Pass)***\\n\\nThis solution is exactly the same as above except that we are doing it in a single pass -\\n\\n**C++**\\n```\\nint leastBricks(vector<vector<int>>& wall) {\\n\\tint rows = size(wall), maxEdges = 0;\\n\\tunordered_map<int, int> edgeFreq;\\n\\tfor(auto& row : wall)\\n\\t\\tfor(int i = 0, idx = 0; i < size(row) - 1; i++)\\n\\t\\t    idx += row[i], edgeFreq[idx]++, maxEdges = max(maxEdges, edgeFreq[idx]);\\n\\treturn rows - maxEdges;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef leastBricks(self, wall: List[List[int]]) -> int:\\n\\tedges, maxEdges = defaultdict(int), 0\\n\\tfor row in wall:\\n\\t\\tfor idx in accumulate(row[:-1]):\\n\\t\\t\\tedges[idx] += 1\\n\\t\\t\\tmaxEdges = max(maxEdges, edges[idx])\\n\\treturn len(wall) - maxEdges\\n```\\n\\n\\n***Time Complexity :*** **`O(R*W)`**\\n***Space Complexity :*** **`O(W)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/41d56264-83af-4b62-862c-9cf46df0cd42_1619079060.8913374.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint leastBricks(vector<vector<int>>& wall) {\\n\\tint rows = size(wall), maxBrickEdges = 0, idx;\\n\\tunordered_map<int, int> edgesFrequency; // will map index to count of brick edges at that index\\n\\tfor(auto& row : wall) {\\n\\t\\t// idx: denotes index of wall. We add each brick-width of row to find the next index having brick edge\\n\\t\\tidx = 0; \\n\\t\\tfor(int i = 0; i < size(row) - 1; i++) // ignore last brick, since we don\\'t want to count wall edge index\\n\\t\\t    idx += row[i], edgesFrequency[idx]++;\\n    }\\n\\t// Lastly find the maximum number of brickEdges found at any index\\n\\tfor(auto& pair : edgesFrequency) maxBrickEdges = max(maxBrickEdges, pair.second);\\n\\t// Rest of the bricks(excluding maxBrickEdges) would be intersected which is the minimum answer\\n\\treturn rows - maxBrickEdges;\\n}\\n```\n```\\nint leastBricks(vector<vector<int>>& wall) {\\n\\tint rows = size(wall), maxEdges = 0;\\n\\tunordered_map<int, int> edgeFreq;\\n\\tfor(auto& row : wall)\\n\\t\\tfor(int i = 0, idx = 0; i < size(row) - 1; i++)\\n\\t\\t    idx += row[i], edgeFreq[idx]++, maxEdges = max(maxEdges, edgeFreq[idx]);\\n\\treturn rows - maxEdges;\\n}\\n```\n```\\ndef leastBricks(self, wall: List[List[int]]) -> int:\\n\\tedges, maxEdges = defaultdict(int), 0\\n\\tfor row in wall:\\n\\t\\tfor idx in accumulate(row[:-1]):\\n\\t\\t\\tedges[idx] += 1\\n\\t\\t\\tmaxEdges = max(maxEdges, edges[idx])\\n\\treturn len(wall) - maxEdges\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 101726,
                "title": "clear-python-solution",
                "content": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = collections.defaultdict(int)\\n        for line in wall:\\n            i = 0\\n            for brick in line[:-1]:\\n                i += brick\\n                d[i] += 1\\n        # print len(wall), d\\n        return len(wall)-max(d.values()+[0])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = collections.defaultdict(int)\\n        for line in wall:\\n            i = 0\\n            for brick in line[:-1]:\\n                i += brick\\n                d[i] += 1\\n        # print len(wall), d\\n        return len(wall)-max(d.values()+[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101738,
                "title": "c-6-lines-hash-map",
                "content": "For each potential cut position - which is at the edge of any brick, I am counting the number of brick edges for all rows. Note that we need to use hash map to only track potential (not all) cuts. If bricks are very wide, you'll get MLE if you store all cut positions.\\n```\\nint leastBricks(vector<vector<int>>& wall) {\\n    unordered_map<int, int> edges;\\n    auto min_bricks = wall.size();\\n    for (auto row : wall)\\n        for (auto i = 0, width = 0; i < row.size() - 1; ++i) // skip last brick\\n            min_bricks = min(min_bricks, wall.size() - (++edges[width += row[i]]));\\n    return min_bricks;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint leastBricks(vector<vector<int>>& wall) {\\n    unordered_map<int, int> edges;\\n    auto min_bricks = wall.size();\\n    for (auto row : wall)\\n        for (auto i = 0, width = 0; i < row.size() - 1; ++i) // skip last brick\\n            min_bricks = min(min_bricks, wall.size() - (++edges[width += row[i]]));\\n    return min_bricks;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788421,
                "title": "python-3-dictionary-explanation",
                "content": "* The path that cuts through the minimum number of bricks is the path that passes through **the most brick edges/endpoints**.\\n* We can keep a map where we count where each brick ends as a distance from the left-most point (i.e. from 0).\\n\\t* We build this map on a **per-row basis**, as we want to find out where each brick ends, and how many times each brick ends on the same point.\\n\\t* We also want to ignore the right-most brick\\'s endpoint, since both the left-most and right-most edges of the wall are ignored as solutions.\\n* The solution is the number of rows of bricks (i.e. `len(wall)`) minus the maximum of the number of rows you can avoid by cutting through a certain `brickEndpoint`.\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        brickEndpointsToCount = {}\\n        \\n        for bricks in wall:\\n\\t\\t\\t# Initialise brickEndpoint to 0, i.e. the left-most point of the wall.\\n            brickEndpoint = 0\\n            \\n\\t\\t\\t# Ignore the very last brick for each row since their endpoints are always the right-most part of the wall.\\n            for i in range(len(bricks) - 1):\\n                brick = bricks[i]\\n\\t\\t\\t\\t# Update the brickEndpoint by adding the length of the current brick in the row.\\n                brickEndpoint += brick\\n                \\n\\t\\t\\t\\t# We\\'ve seen this endpoint before, so increment the count.\\n                if brickEndpoint in brickEndpointsToCount:\\n                    brickEndpointsToCount[brickEndpoint] += 1\\n\\t\\t\\t\\t# This brickEndpoint hasn\\'t been seen before, so initialise the count to 1.\\n                else:\\n                    brickEndpointsToCount[brickEndpoint] = 1\\n        \\n\\t\\t# Use this assignment to shorten the ternary operator in the return statement.\\n        counts = brickEndpointsToCount.values()\\n\\t\\t\\n\\t\\t# The solution is the number of rows of bricks (i.e. len(wall)) minus the maximum of the number of rows you can avoid by cutting through a certain brickEndpoint.\\n        return len(wall) - (max(counts) if counts else 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        brickEndpointsToCount = {}\\n        \\n        for bricks in wall:\\n\\t\\t\\t# Initialise brickEndpoint to 0, i.e. the left-most point of the wall.\\n            brickEndpoint = 0\\n            \\n\\t\\t\\t# Ignore the very last brick for each row since their endpoints are always the right-most part of the wall.\\n            for i in range(len(bricks) - 1):\\n                brick = bricks[i]\\n\\t\\t\\t\\t# Update the brickEndpoint by adding the length of the current brick in the row.\\n                brickEndpoint += brick\\n                \\n\\t\\t\\t\\t# We\\'ve seen this endpoint before, so increment the count.\\n                if brickEndpoint in brickEndpointsToCount:\\n                    brickEndpointsToCount[brickEndpoint] += 1\\n\\t\\t\\t\\t# This brickEndpoint hasn\\'t been seen before, so initialise the count to 1.\\n                else:\\n                    brickEndpointsToCount[brickEndpoint] = 1\\n        \\n\\t\\t# Use this assignment to shorten the ternary operator in the return statement.\\n        counts = brickEndpointsToCount.values()\\n\\t\\t\\n\\t\\t# The solution is the number of rows of bricks (i.e. len(wall)) minus the maximum of the number of rows you can avoid by cutting through a certain brickEndpoint.\\n        return len(wall) - (max(counts) if counts else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170889,
                "title": "js-python-java-c-easy-frequency-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIf the goal here is to find where a line will cross the fewest bricks, then we could also say that the goal is to find where the most brick edges line up. We can consider the edges to occur at an index representing the current running total of the previous elements of a given row of the wall. For example, if the row is defined as **[1,2,2,1]**, then the inside edges occur at **[1,1+2,1+2+2]**, or **[1,3,5]**.\\n\\nIf we now know how to find the edges, then we\\'re left with finding out which index has the highest frequency of edges, which naturally calls for a **frequency map.**\\n\\nSo we can iterate through each **row** in the **wall**, keep a running total of the current row (**rowSum**), and then update the frequency of each edge\\'s index in our frequency map (**freq**).\\n\\nOnce we\\'re done filling **freq**, we just need to iterate through it to find the highest value (**best**), which represents the number of edges aligned on a single index. Our actual answer, however, is the number of bricks, not edges, so we should **return** the total number of rows minus **best**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Javascript, it\\'s more performant to iterate through the finished **freq** looking for the **best** result\\n\\nIn Python it\\'s easier to run **max()** directly on **freq**.\\n\\nFor Java and C++ it\\'s faster to keep track of **best** as we add values to **freq**.\\n\\nFor Java, it\\'s also weirdly more performant to extract the **row** processing to a helper function.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **88ms / 44.6MB** (beats 96% / 62%).\\n```javascript\\nvar leastBricks = function(wall) {\\n    let freq = new Map(), best = 0\\n    for (let i = 0; i < wall.length; i++) {\\n        let row = wall[i], rowSum = row[0]\\n        for (let j = 1; j < row.length; j++) {\\n            freq.set(rowSum, (freq.get(rowSum) || 0) + 1)\\n            rowSum += row[j]\\n        } \\n    }\\n    for (let [k,v] of freq)\\n        if (v > best) best = v\\n    return wall.length - best\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **172ms / 19.1MB** (beats 92% / 86%).\\n```python\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for row in wall:\\n            rowSum = row[0]\\n            for j in range(1, len(row)):\\n                freq[rowSum] += 1\\n                rowSum += row[j]\\n        return len(wall) - max(freq.values() or [0])\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **4ms / 41.9MB** (beats 100% / 79%).\\n```java\\nclass Solution {\\n    int best = 0;\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    public int leastBricks(List<List<Integer>> wall) {\\n        for (int i = 0; i < wall.size(); i++)\\n            processRow(wall.get(i));\\n        return wall.size() - best;\\n    }\\n    public void processRow(List<Integer> row) {\\n        int rowSum = row.get(0);\\n        for (int j = 1; j < row.size(); j++) {\\n            int f = freq.getOrDefault(rowSum, 0) + 1;\\n            freq.put(rowSum, f);\\n            if (f > best) best = f;\\n            rowSum += row.get(j);\\n        } \\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **36ms / 21.5MB** (beats 97% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> freq;\\n        int best = 0;\\n        for (int i = 0; i < wall.size(); i++) {\\n            int rowSum = wall[i][0];\\n            for (int j = 1; j < wall[i].size(); j++) {\\n                freq[rowSum]++;\\n                best = max(best, freq[rowSum]);\\n                rowSum += wall[i][j];\\n            };\\n        };\\n        return wall.size() - best;\\n    };\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar leastBricks = function(wall) {\\n    let freq = new Map(), best = 0\\n    for (let i = 0; i < wall.length; i++) {\\n        let row = wall[i], rowSum = row[0]\\n        for (let j = 1; j < row.length; j++) {\\n            freq.set(rowSum, (freq.get(rowSum) || 0) + 1)\\n            rowSum += row[j]\\n        } \\n    }\\n    for (let [k,v] of freq)\\n        if (v > best) best = v\\n    return wall.length - best\\n};\\n```\n```python\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for row in wall:\\n            rowSum = row[0]\\n            for j in range(1, len(row)):\\n                freq[rowSum] += 1\\n                rowSum += row[j]\\n        return len(wall) - max(freq.values() or [0])\\n```\n```java\\nclass Solution {\\n    int best = 0;\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    public int leastBricks(List<List<Integer>> wall) {\\n        for (int i = 0; i < wall.size(); i++)\\n            processRow(wall.get(i));\\n        return wall.size() - best;\\n    }\\n    public void processRow(List<Integer> row) {\\n        int rowSum = row.get(0);\\n        for (int j = 1; j < row.size(); j++) {\\n            int f = freq.getOrDefault(rowSum, 0) + 1;\\n            freq.put(rowSum, f);\\n            if (f > best) best = f;\\n            rowSum += row.get(j);\\n        } \\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> freq;\\n        int best = 0;\\n        for (int i = 0; i < wall.size(); i++) {\\n            int rowSum = wall[i][0];\\n            for (int j = 1; j < wall[i].size(); j++) {\\n                freq[rowSum]++;\\n                best = max(best, freq[rowSum]);\\n                rowSum += wall[i][j];\\n            };\\n        };\\n        return wall.size() - best;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170867,
                "title": "brick-wall-short-simple-hashmap-solution-w-explanation-comments-beats-100",
                "content": "We are given a brick wall with different width of bricks inside it. We are required to draw a line from top to bottom which intersects the least number of bricks. Passing the line thorugh the edges of brick don\\'t count as intersections.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution (Using HashMap)***\\n\\nIn each row of *Brick Wall*, there maybe a brick-edge (where one brick ends and next one starts) at any index from **`[0, W]`** (where `W` is the width of Brick Wall). \\n\\nNow, to get the least number of intersections, we must draw a line starting at top from some wall index `idx` such that the **number of brick edges at that index is maximum**. This will ensure that we have least number of brick intersections.\\n\\nFor this, we can use a **hashmap to store each index** and **map it with frequency of brick edges at that index**. This can be done by iterating each row of wall. For each brick-edge on that row, increment frequncy for the corresponding index `idx`. The next index can be successively found by adding the current brick width to `idx`\\n\\nLastly, we draw a line starting from the brick index where maximum number of brick edges frequency was found.\\n\\n```\\nint leastBricks(vector<vector<int>>& wall) {\\n\\tint rows = size(wall), maxBrickEdges = 0, idx;\\n\\tunordered_map<int, int> edgesFrequency; // will map index to count of brick edges at that index\\n\\tfor(auto& row : wall) {\\n\\t\\t// idx: denotes index of wall. We add each brick-width of row to find the next index having brick edge\\n\\t\\tidx = 0; \\n\\t\\tfor(int i = 0; i < size(row) - 1; i++) // ignore last brick, since we don\\'t want to count wall edge index\\n\\t\\t    idx += row[i], edgesFrequency[idx]++;\\n    }\\n\\t// Lastly find the maximum number of brickEdges found at any index\\n\\tfor(auto& pair : edgesFrequency) maxBrickEdges = max(maxBrickEdges, pair.second);\\n\\t// Rest of the bricks(excluding maxBrickEdges) would be intersected which is the minimum answer\\n\\treturn rows - maxBrickEdges;\\n}\\n```\\n\\n***Time Complexity :*** **`O(R*W)`**, where *`R`* is the number of rows in Brick Wall and *`W`* is the width of each row.\\n***Space Complexity :*** **`O(W)`**, required to maintain hashmap.\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (HashMap in One-Pass)***\\n\\nThis solution is exactly the same as above except that we are doing it in a single pass -\\n\\n**C++**\\n```\\nint leastBricks(vector<vector<int>>& wall) {\\n\\tint rows = size(wall), maxEdges = 0;\\n\\tunordered_map<int, int> edgeFreq;\\n\\tfor(auto& row : wall)\\n\\t\\tfor(int i = 0, idx = 0; i < size(row) - 1; i++)\\n\\t\\t    idx += row[i], edgeFreq[idx]++, maxEdges = max(maxEdges, edgeFreq[idx]);\\n\\treturn rows - maxEdges;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef leastBricks(self, wall: List[List[int]]) -> int:\\n\\tedges, maxEdges = defaultdict(int), 0\\n\\tfor row in wall:\\n\\t\\tfor idx in accumulate(row[:-1]):\\n\\t\\t\\tedges[idx] += 1\\n\\t\\t\\tmaxEdges = max(maxEdges, edges[idx])\\n\\treturn len(wall) - maxEdges\\n```\\n\\n\\n***Time Complexity :*** **`O(R*W)`**\\n***Space Complexity :*** **`O(W)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/41d56264-83af-4b62-862c-9cf46df0cd42_1619079060.8913374.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint leastBricks(vector<vector<int>>& wall) {\\n\\tint rows = size(wall), maxBrickEdges = 0, idx;\\n\\tunordered_map<int, int> edgesFrequency; // will map index to count of brick edges at that index\\n\\tfor(auto& row : wall) {\\n\\t\\t// idx: denotes index of wall. We add each brick-width of row to find the next index having brick edge\\n\\t\\tidx = 0; \\n\\t\\tfor(int i = 0; i < size(row) - 1; i++) // ignore last brick, since we don\\'t want to count wall edge index\\n\\t\\t    idx += row[i], edgesFrequency[idx]++;\\n    }\\n\\t// Lastly find the maximum number of brickEdges found at any index\\n\\tfor(auto& pair : edgesFrequency) maxBrickEdges = max(maxBrickEdges, pair.second);\\n\\t// Rest of the bricks(excluding maxBrickEdges) would be intersected which is the minimum answer\\n\\treturn rows - maxBrickEdges;\\n}\\n```\n```\\nint leastBricks(vector<vector<int>>& wall) {\\n\\tint rows = size(wall), maxEdges = 0;\\n\\tunordered_map<int, int> edgeFreq;\\n\\tfor(auto& row : wall)\\n\\t\\tfor(int i = 0, idx = 0; i < size(row) - 1; i++)\\n\\t\\t    idx += row[i], edgeFreq[idx]++, maxEdges = max(maxEdges, edgeFreq[idx]);\\n\\treturn rows - maxEdges;\\n}\\n```\n```\\ndef leastBricks(self, wall: List[List[int]]) -> int:\\n\\tedges, maxEdges = defaultdict(int), 0\\n\\tfor row in wall:\\n\\t\\tfor idx in accumulate(row[:-1]):\\n\\t\\t\\tedges[idx] += 1\\n\\t\\t\\tmaxEdges = max(maxEdges, edges[idx])\\n\\treturn len(wall) - maxEdges\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1170890,
                "title": "brick-wall-js-python-java-c-easy-frequency-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIf the goal here is to find where a line will cross the fewest bricks, then we could also say that the goal is to find where the most brick edges line up. We can consider the edges to occur at an index representing the current running total of the previous elements of a given row of the wall. For example, if the row is defined as **[1,2,2,1]**, then the inside edges occur at **[1,1+2,1+2+2]**, or **[1,3,5]**.\\n\\nIf we now know how to find the edges, then we\\'re left with finding out which index has the highest frequency of edges, which naturally calls for a **frequency map.**\\n\\nSo we can iterate through each **row** in the **wall**, keep a running total of the current row (**rowSum**), and then update the frequency of each edge\\'s index in our frequency map (**freq**).\\n\\nOnce we\\'re done filling **freq**, we just need to iterate through it to find the highest value (**best**), which represents the number of edges aligned on a single index. Our actual answer, however, is the number of bricks, not edges, so we should **return** the total number of rows minus **best**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Javascript, it\\'s more performant to iterate through the finished **freq** looking for the **best** result\\n\\nIn Python it\\'s easier to run **max()** directly on **freq**.\\n\\nFor Java and C++ it\\'s faster to keep track of **best** as we add values to **freq**.\\n\\nFor Java, it\\'s also weirdly more performant to extract the **row** processing to a helper function.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **88ms / 44.6MB** (beats 96% / 62%).\\n```javascript\\nvar leastBricks = function(wall) {\\n    let freq = new Map(), best = 0\\n    for (let i = 0; i < wall.length; i++) {\\n        let row = wall[i], rowSum = row[0]\\n        for (let j = 1; j < row.length; j++) {\\n            freq.set(rowSum, (freq.get(rowSum) || 0) + 1)\\n            rowSum += row[j]\\n        } \\n    }\\n    for (let [k,v] of freq)\\n        if (v > best) best = v\\n    return wall.length - best\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **172ms / 19.1MB** (beats 92% / 86%).\\n```python\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for row in wall:\\n            rowSum = row[0]\\n            for j in range(1, len(row)):\\n                freq[rowSum] += 1\\n                rowSum += row[j]\\n        return len(wall) - max(freq.values() or [0])\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **4ms / 41.9MB** (beats 100% / 79%).\\n```java\\nclass Solution {\\n    int best = 0;\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    public int leastBricks(List<List<Integer>> wall) {\\n        for (int i = 0; i < wall.size(); i++)\\n            processRow(wall.get(i));\\n        return wall.size() - best;\\n    }\\n    public void processRow(List<Integer> row) {\\n        int rowSum = row.get(0);\\n        for (int j = 1; j < row.size(); j++) {\\n            int f = freq.getOrDefault(rowSum, 0) + 1;\\n            freq.put(rowSum, f);\\n            if (f > best) best = f;\\n            rowSum += row.get(j);\\n        } \\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **36ms / 21.5MB** (beats 97% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> freq;\\n        int best = 0;\\n        for (int i = 0; i < wall.size(); i++) {\\n            int rowSum = wall[i][0];\\n            for (int j = 1; j < wall[i].size(); j++) {\\n                freq[rowSum]++;\\n                best = max(best, freq[rowSum]);\\n                rowSum += wall[i][j];\\n            };\\n        };\\n        return wall.size() - best;\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar leastBricks = function(wall) {\\n    let freq = new Map(), best = 0\\n    for (let i = 0; i < wall.length; i++) {\\n        let row = wall[i], rowSum = row[0]\\n        for (let j = 1; j < row.length; j++) {\\n            freq.set(rowSum, (freq.get(rowSum) || 0) + 1)\\n            rowSum += row[j]\\n        } \\n    }\\n    for (let [k,v] of freq)\\n        if (v > best) best = v\\n    return wall.length - best\\n};\\n```\n```python\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for row in wall:\\n            rowSum = row[0]\\n            for j in range(1, len(row)):\\n                freq[rowSum] += 1\\n                rowSum += row[j]\\n        return len(wall) - max(freq.values() or [0])\\n```\n```java\\nclass Solution {\\n    int best = 0;\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    public int leastBricks(List<List<Integer>> wall) {\\n        for (int i = 0; i < wall.size(); i++)\\n            processRow(wall.get(i));\\n        return wall.size() - best;\\n    }\\n    public void processRow(List<Integer> row) {\\n        int rowSum = row.get(0);\\n        for (int j = 1; j < row.size(); j++) {\\n            int f = freq.getOrDefault(rowSum, 0) + 1;\\n            freq.put(rowSum, f);\\n            if (f > best) best = f;\\n            rowSum += row.get(j);\\n        } \\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> freq;\\n        int best = 0;\\n        for (int i = 0; i < wall.size(); i++) {\\n            int rowSum = wall[i][0];\\n            for (int j = 1; j < wall[i].size(); j++) {\\n                freq[rowSum]++;\\n                best = max(best, freq[rowSum]);\\n                rowSum += wall[i][j];\\n            };\\n        };\\n        return wall.size() - best;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133819,
                "title": "my-java-solution-with-explanation",
                "content": "**Idea**\\nBasic idea is in each row, we need to know if a line falls at the edge of a brick or goes through any brick. If we compute prefix sum for each row, we can say if a line going through any brick or falls at the edge of a brick - how? \"falls at the edge of a brick\" meaning the length of that brick must be part of prefix sum for all such rows.\\n\\n**So all we need is a brick whose length ends at the same point across maximum rows.**\\nSo we just record prefix sum frequency and choose the maximum. But for the answer, we need how many rows are touched. So total# of rows - max rows not touched.\\nAlso note that we shouldn\\'t consider the line passing at the edge of all rows, that is why\\n`if(key == pre) continue;`\\n\\n```\\npublic int leastBricks(List<List<Integer>> wall) {\\n        int max = 0;\\n        //not found = touch\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int pre = 0;\\n        for(List<Integer> row : wall){\\n            pre = 0;\\n            for(int n : row){\\n                pre += n;\\n                freq.put(pre, freq.getOrDefault(pre, 0)+1);\\n            }\\n        }\\n        for(int key : freq.keySet()){\\n            //System.out.println(key+\" \" + freq.get(key));\\n            if(key == pre) continue;\\n            max = Math.max(max, freq.get(key));\\n        }\\n        return wall.size()-max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int leastBricks(List<List<Integer>> wall) {\\n        int max = 0;\\n        //not found = touch\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int pre = 0;\\n        for(List<Integer> row : wall){\\n            pre = 0;\\n            for(int n : row){\\n                pre += n;\\n                freq.put(pre, freq.getOrDefault(pre, 0)+1);\\n            }\\n        }\\n        for(int key : freq.keySet()){\\n            //System.out.println(key+\" \" + freq.get(key));\\n            if(key == pre) continue;\\n            max = Math.max(max, freq.get(key));\\n        }\\n        return wall.size()-max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170842,
                "title": "python-easy-solution-with-counter-explained",
                "content": "It is the same as finding vertical line which crosses maximum number of junctures between bricks. So, we just traverse all bricks in all levels and add frequencies to counter. Also we need to be careful with case, when our counter is empty: it means that we can not put vertical line nowhere in junctures, so we need to put it in the middle of bricks, for example for `[[1],[1],[1]]` case we can put it in `0.5` place, so total number of crossed bricks is `3`.\\nIn the end we return total number of layers minus maximum in our counter.\\n\\n#### Complexity\\nTime complexity is `O(n)`, where `n` is total number of bricks, space complexity as well.\\n\\n#### Code\\n```\\nclass Solution:\\n    def leastBricks(self, wall):\\n        cnt = Counter()\\n        \\n        for line in wall:\\n            for place in list(accumulate(line))[:-1]:\\n                cnt[place] += 1\\n                \\n        return len(wall) - max(cnt.values()) if cnt else len(wall)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall):\\n        cnt = Counter()\\n        \\n        for line in wall:\\n            for place in list(accumulate(line))[:-1]:\\n                cnt[place] += 1\\n                \\n        return len(wall) - max(cnt.values()) if cnt else len(wall)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101794,
                "title": "verbose-java-solution-priorityqueue",
                "content": "```\\npublic class Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int R = wall.size(), min = R;\\n        if (R == 1 && wall.get(0).size() > 1) return 0;\\n        \\n        // [0: end, 1: row, 2: col]\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        \\n        for (int i = 0; i < R; i++) {\\n            pq.add(new int[] {wall.get(i).get(0), i, 0});\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            int end = pq.peek()[0], count = 0;\\n            \\n            while (!pq.isEmpty() && pq.peek()[0] == end) {\\n                count++;\\n                int[] brick = pq.poll();\\n                if (brick[2] < wall.get(brick[1]).size() - 1) {\\n                    pq.add(new int[] {end + wall.get(brick[1]).get(brick[2] + 1), brick[1], brick[2] + 1});\\n                }\\n            }\\n            \\n            if (!pq.isEmpty()) {\\n                min = Math.min(min, R - count);\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int R = wall.size(), min = R;\\n        if (R == 1 && wall.get(0).size() > 1) return 0;\\n        \\n        // [0: end, 1: row, 2: col]\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        \\n        for (int i = 0; i < R; i++) {\\n            pq.add(new int[] {wall.get(i).get(0), i, 0});\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            int end = pq.peek()[0], count = 0;\\n            \\n            while (!pq.isEmpty() && pq.peek()[0] == end) {\\n                count++;\\n                int[] brick = pq.poll();\\n                if (brick[2] < wall.get(brick[1]).size() - 1) {\\n                    pq.add(new int[] {end + wall.get(brick[1]).get(brick[2] + 1), brick[1], brick[2] + 1});\\n                }\\n            }\\n            \\n            if (!pq.isEmpty()) {\\n                min = Math.min(min, R - count);\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132143,
                "title": "invalid-test-case",
                "content": "@fallcreek\\nFollowing test case is invalid as per this note in problem statement.\\nYou cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.\\n\\n```\\nInput:\\n[[1],[1],[1]]\\nOutput:\\n0\\nExpected:\\n3\\n```",
                "solutionTags": [],
                "code": "```\\nInput:\\n[[1],[1],[1]]\\nOutput:\\n0\\nExpected:\\n3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170940,
                "title": "c-simple-short-and-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> m;\\n        int res = wall.size(), n = wall.size();\\n        \\n        for (auto row : wall) {\\n            \\n            int curr_width = 0;\\n            for (int i = 0; i < row.size()-1; i++) {\\n                \\n                curr_width += row[i];\\n                res = min(res, n - (++m[curr_width]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> m;\\n        int res = wall.size(), n = wall.size();\\n        \\n        for (auto row : wall) {\\n            \\n            int curr_width = 0;\\n            for (int i = 0; i < row.size()-1; i++) {\\n                \\n                curr_width += row[i];\\n                res = min(res, n - (++m[curr_width]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171502,
                "title": "java-hashmap-solution",
                "content": "**IDEA:**\\n![image](https://assets.leetcode.com/users/images/f130bcce-9c74-4b0a-9633-3f11a2f4fc1c_1619104906.6125433.png)\\n**Goal** is to minimize the cut of brick by drawing a line parallel to y axis.\\nSo draw a line such that where maximum number of bricks are ending as we can see in the example.\\n`NOTE: we cannot draw at end  that is invalid (mentioned in the question) because then answer will be zero `\\nSteps to follow :\\n1. Make a hashmap<Integer,Integer> to store xcoordinate vs count.\\n2. find out maxbrickskip through this this.(maximum count of xcoordinate)\\n3. then return minimum number of bricks to cut by wall.size()-maxskip .\\n\\nCode will help you to understand more properly.\\n**CODE:**\\n```\\npublic int leastBricks(List<List<Integer>> wall) {\\n       HashMap<Integer,Integer> map=new HashMap<>(); // key:xcoordinate value:count\\n        int maxbrickSkip=0;\\n        \\n        for(int r=0;r<wall.size();r++){\\n            int xcoordinate=0;\\n            for(int c=0;c<wall.get(r).size()-1;c++){  //wall.get(r).size()-1 because we dont want to include last  brick .  \\n                xcoordinate+=wall.get(r).get(c);      \\n              map.put(xcoordinate,map.getOrDefault(xcoordinate,0)+1);\\n                maxbrickSkip=Math.max(map.get(xcoordinate),maxbrickSkip);\\n            }\\n        }\\n        \\n        int ans=wall.size()-maxbrickSkip;\\n        return ans;   \\n    }\\n```\\n\\n**Complexity:**\\n`Time:O(n*m) and Space:O(n*m)`\\n\\nPlease UPVOTE if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int leastBricks(List<List<Integer>> wall) {\\n       HashMap<Integer,Integer> map=new HashMap<>(); // key:xcoordinate value:count\\n        int maxbrickSkip=0;\\n        \\n        for(int r=0;r<wall.size();r++){\\n            int xcoordinate=0;\\n            for(int c=0;c<wall.get(r).size()-1;c++){  //wall.get(r).size()-1 because we dont want to include last  brick .  \\n                xcoordinate+=wall.get(r).get(c);      \\n              map.put(xcoordinate,map.getOrDefault(xcoordinate,0)+1);\\n                maxbrickSkip=Math.max(map.get(xcoordinate),maxbrickSkip);\\n            }\\n        }\\n        \\n        int ans=wall.size()-maxbrickSkip;\\n        return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101764,
                "title": "simple-javascript-o-n-using-map",
                "content": "The most frequent prefix sum location crosses the fewest bricks:\\n```\\nvar leastBricks = function(wall) {\\n    const counts = {};\\n    let max = 0;\\n    for (let row of wall) {\\n        let sum = 0;\\n        for (let i = 0; i < row.length - 1; i++) {\\n            sum += row[i];\\n            counts[sum] = (counts[sum] || 0) + 1;\\n            max = Math.max(max, counts[sum]);\\n        }\\n    }\\n    return wall.length - max;\\n};\\n```\\nThis is O(n) in the number of bricks.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar leastBricks = function(wall) {\\n    const counts = {};\\n    let max = 0;\\n    for (let row of wall) {\\n        let sum = 0;\\n        for (let i = 0; i < row.length - 1; i++) {\\n            sum += row[i];\\n            counts[sum] = (counts[sum] || 0) + 1;\\n            max = Math.max(max, counts[sum]);\\n        }\\n    }\\n    return wall.length - max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101752,
                "title": "neat-java-solution-o-n-using-hashmap",
                "content": "```\\npublic class Solution {\\n    public int leastBricks(List < List < Integer >> wall) {\\n        HashMap < Integer, Integer > map = new HashMap < > ();\\n        for (List < Integer > row: wall) {\\n            int sum = 0;\\n            for (int i = 0; i < row.size() - 1; i++) {\\n                sum += row.get(i);\\n                if (map.containsKey(sum))\\n                    map.put(sum, map.get(sum) + 1);\\n                else\\n                    map.put(sum, 1);\\n            }\\n        }\\n        int res = wall.size();\\n        for (int key: map.keySet())\\n            res = Math.min(res, wall.size() - map.get(key));\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int leastBricks(List < List < Integer >> wall) {\\n        HashMap < Integer, Integer > map = new HashMap < > ();\\n        for (List < Integer > row: wall) {\\n            int sum = 0;\\n            for (int i = 0; i < row.size() - 1; i++) {\\n                sum += row.get(i);\\n                if (map.containsKey(sum))\\n                    map.put(sum, map.get(sum) + 1);\\n                else\\n                    map.put(sum, 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1170904,
                "title": "brick-wall-simple-solution-easy-to-understand-explained",
                "content": "The first thing that comes to my mind is, we need to minimize the number of crosses, So, Iam finding the maximum numbers of ending for each prefix sum for all the rows of bricks.\\n\\nLets Take the sample example:\\n```\\nInput: [[1,2,2,1], [3,1,2], [1,3,2],[2,4],[3,1,2], [1,3,1,1]]\\nHere we know every row\\'s sum is equal, \\nSo, Lets prefix sum of rows will be, \\nRow1: [1,3,5,6]\\nRow2:[3,4,6]\\nRow3: [1,4,6]\\nRow4:[2,6]\\nRow5: [3,4,6]\\nRow6:[1,4,5,6]\\nNow, we find the frequency of bricks that are ending at a sum by using a map.\\n```\\nAs, we found the maximum number of edges of bricks at `sum = 4 i.e, 4bricks.`\\n Inorder to minimize crosses, `total rows - maximum edges => 6-4 =2.`\\n \\n **Do Upvote if you find it helpful!!**\\n \\n```\\nint leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>m;\\n        for(vector<int>temp:wall){\\n            int sum =0;\\n            for(int i=0;i<temp.size()-1;i++){\\n                sum += temp[i];\\n                m[sum]++;\\n            }\\n        }\\n        int maxi = 0;\\n        for(auto it:m){\\n            maxi = max(maxi,it.second);\\n        }\\n        return wall.size()-maxi;\\n    }\\n```\\nFeel free to comment any doubts and improvements in the code!!",
                "solutionTags": [],
                "code": "```\\nInput: [[1,2,2,1], [3,1,2], [1,3,2],[2,4],[3,1,2], [1,3,1,1]]\\nHere we know every row\\'s sum is equal, \\nSo, Lets prefix sum of rows will be, \\nRow1: [1,3,5,6]\\nRow2:[3,4,6]\\nRow3: [1,4,6]\\nRow4:[2,6]\\nRow5: [3,4,6]\\nRow6:[1,4,5,6]\\nNow, we find the frequency of bricks that are ending at a sum by using a map.\\n```\n```\\nint leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>m;\\n        for(vector<int>temp:wall){\\n            int sum =0;\\n            for(int i=0;i<temp.size()-1;i++){\\n                sum += temp[i];\\n                m[sum]++;\\n            }\\n        }\\n        int maxi = 0;\\n        for(auto it:m){\\n            maxi = max(maxi,it.second);\\n        }\\n        return wall.size()-maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314060,
                "title": "swift-brick-wall-test-cases",
                "content": "```swift\\nclass Solution {\\n    func leastBricks(_ wall: [[Int]]) -> Int {\\n        var path = [Int:Int]()\\n        for row in wall {\\n            var index = 0\\n            for i in (0..<row.count-1) {\\n                index += row[i]\\n                path[index, default: 0] += 1\\n            }\\n        }\\n        let result = wall.count - path.reduce(0) { max($0, $1.1)}\\n        return result\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n//      Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let result = s.leastBricks([[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]])\\n        XCTAssertEqual(result, 2)\\n    }\\n    func test2() {\\n        let result = s.leastBricks([[1],[1],[1]])\\n        XCTAssertEqual(result, 3)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func leastBricks(_ wall: [[Int]]) -> Int {\\n        var path = [Int:Int]()\\n        for row in wall {\\n            var index = 0\\n            for i in (0..<row.count-1) {\\n                index += row[i]\\n                path[index, default: 0] += 1\\n            }\\n        }\\n        let result = wall.count - path.reduce(0) { max($0, $1.1)}\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n//      Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let result = s.leastBricks([[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]])\\n        XCTAssertEqual(result, 2)\\n    }\\n    func test2() {\\n        let result = s.leastBricks([[1],[1],[1]])\\n        XCTAssertEqual(result, 3)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171478,
                "title": "java-solution-using-hashmap-detailed-iteration-over-the-given-example-for-better-understanding",
                "content": "Intuition: \\nThe idea is to calculate and store all the edge indices in the wall and figure out which edge index is the most common.\\n\\n![image](https://assets.leetcode.com/users/images/e28211ed-a6fa-4b13-b7d1-998a9f128cc0_1619104441.9586296.png)\\n\\n\\nIteration - In the example given in the problem description, we iterate like this: \\nStarting in first row, from edge 0. \\nGo to Edge 1, then Edge 3, then edge 5 - Store each edge in the hashmap with it\\'s respective count. \\nCurrent Map is - \\n1, 1\\n3, 1\\n5, 1\\n\\nProceeding to the second row:\\nGo to Edge 3, then Edge 4 - Update the map count for each edge\\nCurrent Map is - \\n1, 1\\n3, 2\\n4, 1\\n5, 1\\n\\nProceeding to the third row:\\nGo to Edge 1, then edge 4 - Update the map count for each edge\\nCurrent Map is - \\n1, 2\\n3, 2\\n4, 2\\n5, 1\\n\\nProceed to the fourth row:\\nGo to edge 2 - Update the map count\\nCurrent Map is - \\n1, 2\\n2, 1\\n3, 2\\n4, 2\\n5, 1\\n\\nProceed to the fifth row:\\nGo to Edge 3, then edge 4 - Update the map count for each edge\\nCurrent Map is \\n1, 2\\n2, 1\\n3, 3\\n4, 3\\n5, 1\\n\\nProceed to the sixth row:\\nGo to Edge 1, then Edge 4, then edge 5 - Update the map count for each edge\\nCurrent Map is \\n1, 3\\n2, 1\\n3, 3\\n4, 4\\n5, 2\\n\\nEdge 4 has the highest count, which means that edge 4 is the edge through which the line can pass without hitting other bricks. \\nTotal rows in the wall = 6 \\nMax Rows we can pass without hitting bricks = 4\\nThus, rows we can pass with hitting the minimum number of bricks = 6-4 = 2. \\n\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int count = 0;\\n        for (List<Integer> row : wall) {\\n            int currentEdge = 0;\\n            for (int i = 0; i < row.size() - 1; i++) { //row.size() -1 since we do not want to consider borders. \\n                int currentBrickLength = row.get(i);\\n                currentEdge += currentBrickLength; \\n                map.put(currentEdge, map.getOrDefault(currentEdge, 0) + 1);\\n                count = Math.max(count, map.get(currentEdge));\\n            }\\n        }\\n        \\n        return wall.size() - count;\\n    }\\n}\\n```\\n\\nPlease comment if you have any questions. \\nTime Complexity - O(m*n), where m is the number of rows, and n is the number of columns\\nSpace Complexity - O(n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int count = 0;\\n        for (List<Integer> row : wall) {\\n            int currentEdge = 0;\\n            for (int i = 0; i < row.size() - 1; i++) { //row.size() -1 since we do not want to consider borders. \\n                int currentBrickLength = row.get(i);\\n                currentEdge += currentBrickLength; \\n                map.put(currentEdge, map.getOrDefault(currentEdge, 0) + 1);\\n                count = Math.max(count, map.get(currentEdge));\\n            }\\n        }\\n        \\n        return wall.size() - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171054,
                "title": "python-go-o-mn-by-dictionary-w-visualization",
                "content": "**Hint**:\\n\\n1. Build a **dictionary** where **key** is **boundary**, as well as **value** is **occurrence of boundary**\\n\\n2. Scan each brick rows and **update brick boundary** into **dictionary**\\n\\n3. Compute **minimal crossing** based on **maximal occurrence of boundary**\\n\\n---\\n\\n**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/images/264c6301-500f-4dc3-a322-6d50cf966900_1619082904.2048347.png)\\n\\n---\\n\\n**Implementation** by dictionary in Python:\\n\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        \\n        ## dictioanry\\n        # key: boundary\\n        # value: occurrence of boundary\\n        boundary_occ_dict = defaultdict(int)\\n        \\n        brick_rows = len(wall)\\n        \\n        # sacn each brick row\\n        for cur_brick_row in wall:\\n            \\n            # reset current bounary to zero\\n            cur_boundary = 0\\n            \\n            # update boundary into dictionary\\n            # Take care that final boundary is excluded to satisfy definition\\n            for cur_brick_length in cur_brick_row[:-1]:\\n            \\n                cur_boundary += cur_brick_length\\n            \\n                boundary_occ_dict[cur_boundary] += 1\\n        \\n        # get occurrence of boundary\\n        boundary_occurrence = boundary_occ_dict.values()\\n        \\n        \\n        # compute minimal crossing by occurrence of boundary\\n        \\n        if boundary_occurrence:\\n            # general cases: mutiple bricks on each row\\n            min_crossing = brick_rows - max(boundary_occurrence)\\n            \\n        else:\\n            # corner case: only one brick on each row\\n            min_crossing = brick_rows\\n        \\n        return min_crossing\\n            \\n```\\n\\n---\\n\\n**Implementation** by map (so-called dictionary) in Go:\\n\\n```\\nfunc Max(x, y int) int{\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc leastBricks(wall [][]int) int {\\n    \\n    //// dictioanry\\n    // key: bounday\\n    // value: occurrence of boundary\\n    \\n    boundaryOccDict := make(map[int]int)\\n    \\n    brickRows := len(wall)\\n    \\n    // scan each brick row\\n    for _, curBrickRow := range wall{\\n        \\n        // reset current boundary to zero for each row\\n        curBoundary := 0\\n        \\n        // update boundary into dictionary\\n        // Take care that final boundary is excluded to satisfy definition\\n        for _, curBrickLength := range curBrickRow[:len(curBrickRow)-1]{\\n            \\n            curBoundary += curBrickLength\\n            \\n            boundaryOccDict[curBoundary] += 1\\n            \\n        }\\n        \\n    }\\n    \\n    // get occurrence of boundary\\n    maxBoundaryOccurrence := -1\\n    \\n    for _, curBoundaryOccurrence := range boundaryOccDict{\\n        maxBoundaryOccurrence = Max(maxBoundaryOccurrence, curBoundaryOccurrence)\\n    }\\n    \\n    // compute minimal crossing by occurrence of boundary\\n    minCrossing := 0\\n    \\n    if maxBoundaryOccurrence != -1{\\n        // general cases: mutiple bricks on each row\\n        minCrossing = brickRows - maxBoundaryOccurrence\\n        \\n    }else{\\n        // corner case: only one brick on each row\\n        minCrossing = brickRows\\n    }\\n    \\n    return minCrossing\\n}\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about dictionary](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)\\n\\n[2] [Python official docs about defaultdict( ... )](https://docs.python.org/3/library/collections.html#collections.defaultdict)\\n\\n[3] [Golang official docs about map[]](https://blog.golang.org/maps)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        \\n        ## dictioanry\\n        # key: boundary\\n        # value: occurrence of boundary\\n        boundary_occ_dict = defaultdict(int)\\n        \\n        brick_rows = len(wall)\\n        \\n        # sacn each brick row\\n        for cur_brick_row in wall:\\n            \\n            # reset current bounary to zero\\n            cur_boundary = 0\\n            \\n            # update boundary into dictionary\\n            # Take care that final boundary is excluded to satisfy definition\\n            for cur_brick_length in cur_brick_row[:-1]:\\n            \\n                cur_boundary += cur_brick_length\\n            \\n                boundary_occ_dict[cur_boundary] += 1\\n        \\n        # get occurrence of boundary\\n        boundary_occurrence = boundary_occ_dict.values()\\n        \\n        \\n        # compute minimal crossing by occurrence of boundary\\n        \\n        if boundary_occurrence:\\n            # general cases: mutiple bricks on each row\\n            min_crossing = brick_rows - max(boundary_occurrence)\\n            \\n        else:\\n            # corner case: only one brick on each row\\n            min_crossing = brick_rows\\n        \\n        return min_crossing\\n            \\n```\n```\\nfunc Max(x, y int) int{\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc leastBricks(wall [][]int) int {\\n    \\n    //// dictioanry\\n    // key: bounday\\n    // value: occurrence of boundary\\n    \\n    boundaryOccDict := make(map[int]int)\\n    \\n    brickRows := len(wall)\\n    \\n    // scan each brick row\\n    for _, curBrickRow := range wall{\\n        \\n        // reset current boundary to zero for each row\\n        curBoundary := 0\\n        \\n        // update boundary into dictionary\\n        // Take care that final boundary is excluded to satisfy definition\\n        for _, curBrickLength := range curBrickRow[:len(curBrickRow)-1]{\\n            \\n            curBoundary += curBrickLength\\n            \\n            boundaryOccDict[curBoundary] += 1\\n            \\n        }\\n        \\n    }\\n    \\n    // get occurrence of boundary\\n    maxBoundaryOccurrence := -1\\n    \\n    for _, curBoundaryOccurrence := range boundaryOccDict{\\n        maxBoundaryOccurrence = Max(maxBoundaryOccurrence, curBoundaryOccurrence)\\n    }\\n    \\n    // compute minimal crossing by occurrence of boundary\\n    minCrossing := 0\\n    \\n    if maxBoundaryOccurrence != -1{\\n        // general cases: mutiple bricks on each row\\n        minCrossing = brickRows - maxBoundaryOccurrence\\n        \\n    }else{\\n        // corner case: only one brick on each row\\n        minCrossing = brickRows\\n    }\\n    \\n    return minCrossing\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717467,
                "title": "clean-solution-with-full-explanation",
                "content": "**Idea:**\\n* Think in reverse, find maximum number of bricks which are starting from the same position along the x-axis. If we subtract this number from `numRows`, we get our answer.\\n* In order to maintain the maximum number of bricks which are starting from a position along the x-axis, we need to maintain a hashmap of position vs count.\\n* Also, ignore the last brick, because we can\\'t have the start/end vertical line as our answer.\\n\\n```\\npublic int leastBricks(List<List<Integer>> wall) {\\n\\tif (wall.isEmpty()) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tMap<Integer, Integer> openingMap = new HashMap<>();\\n\\tint maxOpening = 0;\\n\\n\\tfor (List<Integer> row : wall) {\\n\\t\\tint pos = 0;\\n\\t\\tfor (int i = 0; i < row.size()-1; i++) {\\n\\t\\t\\tint b = row.get(i);\\n\\t\\t\\tpos += b;\\n\\t\\t\\topeningMap.put(pos, openingMap.getOrDefault(pos, 0) + 1);\\n\\t\\t\\tmaxOpening = Math.max(maxOpening, openingMap.get(pos));\\n\\t\\t}\\n\\t}\\n\\n\\treturn wall.size() - maxOpening;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int leastBricks(List<List<Integer>> wall) {\\n\\tif (wall.isEmpty()) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tMap<Integer, Integer> openingMap = new HashMap<>();\\n\\tint maxOpening = 0;\\n\\n\\tfor (List<Integer> row : wall) {\\n\\t\\tint pos = 0;\\n\\t\\tfor (int i = 0; i < row.size()-1; i++) {\\n\\t\\t\\tint b = row.get(i);\\n\\t\\t\\tpos += b;\\n\\t\\t\\topeningMap.put(pos, openingMap.getOrDefault(pos, 0) + 1);\\n\\t\\t\\tmaxOpening = Math.max(maxOpening, openingMap.get(pos));\\n\\t\\t}\\n\\t}\\n\\n\\treturn wall.size() - maxOpening;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297070,
                "title": "554-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an empty dictionary called edge_counts.\\n2. Loop through each row in the wall list:\\na. Create a variable called edge_pos and set it to 0.\\nb. Loop through each brick width in the current row up to the second to last brick (since the last brick cannot form an edge).\\ni. Add the current brick width to edge_pos.\\nii. Add 1 to the value in the edge_counts dictionary at the key of edge_pos, or add a new key-value pair with key edge_pos and value 1 if it doesn\\'t exist.\\n3. Return the difference between the length of the wall list and the maximum value in the edge_counts dictionary. If the edge_counts dictionary is empty, return the length of the wall list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        edge_counts = {}\\n        for row in wall:\\n            edge_pos = 0\\n            for brick_width in row[:-1]:\\n                edge_pos += brick_width\\n                edge_counts[edge_pos] = edge_counts.get(edge_pos, 0) + 1\\n        return len(wall) - max(edge_counts.values(), default=0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        edge_counts = {}\\n        for row in wall:\\n            edge_pos = 0\\n            for brick_width in row[:-1]:\\n                edge_pos += brick_width\\n                edge_counts[edge_pos] = edge_counts.get(edge_pos, 0) + 1\\n        return len(wall) - max(edge_counts.values(), default=0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955492,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> map;\\n        int n=wall.size();\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<wall[i].size()-1;j++){\\n                sum+=wall[i][j];\\n                map[sum]++;\\n            }\\n        }\\n        int maxi=0;\\n        for(auto m: map){\\n            if(m.second>maxi)\\n                maxi=m.second;\\n        }\\n        return n-maxi;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> map;\\n        int n=wall.size();\\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<wall[i].size()-1;j++){\\n                sum+=wall[i][j];\\n                map[sum]++;\\n            }\\n        }\\n        int maxi=0;\\n        for(auto m: map){\\n            if(m.second>maxi)\\n                maxi=m.second;\\n        }\\n        return n-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517320,
                "title": "simple-python-solution-using-hashmap",
                "content": "Intuition: The count of the cumulative sum of at each level should be maximum. This means that bricks will end at that sum. \\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        sumMap, maxSum = {}, 0\\n        for i in range(len(wall)):\\n            currSum = 0\\n            for j in range(len(wall[i])-1):\\n                currSum += wall[i][j]\\n                if currSum not in sumMap:\\n                    sumMap[currSum] = 0\\n                sumMap[currSum] += 1\\n                maxSum = max(maxSum, sumMap[currSum])\\n        return len(wall) - maxSum\\n```\\n\\nTime Complexity: O(nm) ; n-> Height of the wall, m-> Width of the wall\\nSpace Complexity: O(m) ; m-> Width of the wall",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        sumMap, maxSum = {}, 0\\n        for i in range(len(wall)):\\n            currSum = 0\\n            for j in range(len(wall[i])-1):\\n                currSum += wall[i][j]\\n                if currSum not in sumMap:\\n                    sumMap[currSum] = 0\\n                sumMap[currSum] += 1\\n                maxSum = max(maxSum, sumMap[currSum])\\n        return len(wall) - maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313272,
                "title": "c-map-solution",
                "content": "We will track the edges \\n\\nThe edges are obviously where a brick ends\\n\\nThe more the point where most of the brick ends the lower bricks it will cross\\n\\nWe track these edges through our map\\n\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int wall_height = wall.size();\\n\\n        int ans = 0;\\n\\n        unordered_map<int,int> s;\\n\\n        for(int i=0; i<wall_height; i++)\\n        {\\n            int total_width = 0;\\n            for(int k=0; k<wall[i].size()-1; k++)\\n            {\\n                 total_width = total_width + wall[i][k];\\n                 s[total_width]++;\\n\\n                 ans = max(ans, s[total_width]);\\n            } \\n        }\\n\\n        return wall_height - ans;\\n\\n\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int wall_height = wall.size();\\n\\n        int ans = 0;\\n\\n        unordered_map<int,int> s;\\n\\n        for(int i=0; i<wall_height; i++)\\n        {\\n            int total_width = 0;\\n            for(int k=0; k<wall[i].size()-1; k++)\\n            {\\n                 total_width = total_width + wall[i][k];\\n                 s[total_width]++;\\n\\n                 ans = max(ans, s[total_width]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2622573,
                "title": "intuition-explained-in-detailed-java-c-python-with-pics-and-comments",
                "content": "**UPVOTE PLEASE**\\n```\\n\\nIntuition:-\\nThe above wall is represented in a 2D Array where each element is the size of the respective brick :\\n[[1,2,2,1],\\n[3,1,2],\\n[1,3,2],\\n[2,4],\\n[3,1,2],\\n[1,3,1,1]]\\n\\nNote : Size of each brick is at least 1 unit.\\n\\nSo to mininize the number of bricks crossed by line, we want the line to pass through as many edges as possible.\\nFor this approach the edge postion will be defined with respect to the leftmost edge.\\n\\nAny edge position can be calculated by the sum of the lenghts of bricks observed till that edge.\\nLike in the above diagram :\\nEdge Position = Length of 1st Brick + Length of 2nd Brick\\n=> Edge Position = 1 + 2\\n=> Edge Position = 3\\n\\nNOTE: You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.\\nBecause of this note we won\\'t consider the edge 0 & edge 6 to solve the question.\\n\\nOne interesting observation is that for calculating next edge position, we don\\'t have to start adding the lengths from the very first brick of the row. Instead, we can add the \"Sum of lengths of bricks obervered till the previous edge\" + current brick\\'s length.\\nSo,\\nNext Edge Position = (Sum of lengths of bricks observered till the previous edge) + Current Brick\\'s Length.\\n=> Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n\\nThe edge which happens to be in multiple rows will contribute to the optimal solution as the line passing through that common edge will result in minimun crossing/cutting of bricks.\\nHence we wanna find the edge that has higest frequency in the wall.\\n\\nNow comes an important question, which data structure should we use and why?\\nSuggestion :\\nHow about using a data-structure that stores the 2-dimentional grid information via which we can access any position\\'s info (whether its a brick or an edge) in a constant time?\\nAnalysis of Suggestion :\\nThe problem of using a 2D grid is that we will be storing the edge\\'s positions as well as the brick\\'s positions. So we are wasting space in storing all the brick\\'s coordinates.\\nOptimizing the Suggestion :\\nSo if we look into our requirement, we are only concerned with the pair of \"position of the edge\" & \"its frequency in the wall\". We don\\'t care about the brick\\'s position. HashMap seems like a perfect data structure to store the pair\\n\\nHence we will store every calculated edge in a HashMap.\\nStructure of the HashMap :\\nKey of HashMap = Edge Position\\nValue of HashMap = Frequency of Edge in the Entire Wall\\n```\\n![image](https://assets.leetcode.com/users/images/df9521b3-320b-4964-8418-dd9546955975_1664105118.9177434.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/393d9dad-f96e-4af7-9ab0-fa5f9c224ea1_1664105106.2278066.png)\\n\\n![image](https://assets.leetcode.com/users/images/35a20312-cdf2-4344-9e3b-5ba69531381e_1664105082.3085716.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/b865ad3f-9e12-4728-9165-08a7025bf85a_1664104769.061507.png)\\n\\n```\\nNow we are sure that the line passing from edge 4 will result in minimum crossing of bricks.\\nBut we need to return the number of crossing the line makes.\\nIn the above diagram,\\nRed Box = Line passing through an edge\\nBlue Box = Line crossing through a brick\\n\\nHence a fomulae can be derived:\\nNumber of Blue Boxes+ Number of Red Boxes = Number of Rows in Wall\\n=> Number of Blue Boxes + (Frequency of Most Occuring Edge) = Number of Rows in Wall\\n=> (Number of Bricks Crossed by Line) + (Frequency of Most Occuring Edge) = Number of Rows in Wall\\n=> (Number of Bricks Crossed by Line) = Number of Rows in Wall - (Frequency of Most Occuring Edge)\\n\\nNumber of Bricks Crossed by Line = Number of Rows in Wall - Frequency of Most Occuring Edge\\n\\nHence\\nNumber of Bricks Crossed by Line = Number of Rows in Wall - Frequency of Most Occuring Edge\\n=> Number of Bricks Crossed by Line = 6 - 4\\n=> Number of Bricks Crossed by Line = 2 (We return this answer)\\n\\n```\\n![image](https://assets.leetcode.com/users/images/9e274d0c-ecd4-418e-aeaa-d8c67f457a8f_1664105034.9857256.png)\\n\\n```\\n\\nBelow is the C++ Code of the above mentioned logic :\\n\\n\\ncpp:\\n\\nint leastBricks(vector<vector<int>>& wall) {\\nunordered_map<int, int> edge_frequency;     //HashMap to store the number of common edges among the rows\\n\\n        int max_frequency = 0;         //Variable to store the frequency of most occuring edge\\n        \\n        for(int row=0; row<wall.size(); row++)        //Iterating through each row\\n        {\\n            int edge_postion = 0;       //Variable to store different edge postion\\n            \\n            for(int brick_no=0; brick_no< wall[row].size() -1; brick_no++)    //Iterating through each brick inside a row\\n            { \\n                int current_brick_length = wall[row][brick_no];  //Length of the current brick\\n                \\n                edge_postion = edge_postion + current_brick_length ;  //Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n                \\n                edge_frequency[edge_postion]++;  //Incrementing the Frequency of just calculated Edge Postion\\n                \\n                max_frequency = max(edge_frequency[edge_postion],max_frequency);  //Comparing the \"Frequency of just calculated Edge Postion\" with \"Max Frequency seen till now\" & storing whichever is greater.\\n            }\\n        }\\n        return wall.size() - max_frequency; // returning (Number of Bricks Crossed by Line) i.e. (Number of Rows in Wall - Frequency of Most Occuring Edge) \\n    }\\n\\nJava:\\n\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        var edge_frequency=new HashMap<Integer,Integer>();     //HashMap to store the number of common edges among the rows\\n\\n        int max_frequency = 0;         //Variable to store the frequency of most occuring edge\\n        \\n        for(int row=0; row<wall.size(); row++)        //Iterating through each row\\n        {\\n            int edge_postion = 0;       //Variable to store different edge postion\\n            \\n            for(int brick_no=0; brick_no< wall.get(row).size() -1; brick_no++)    //Iterating through each brick inside a row\\n            { \\n                int current_brick_length = wall.get(row).get(brick_no);  //Length of the current brick\\n                \\n                edge_postion = edge_postion + current_brick_length ;  //Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n                \\n                edge_frequency.put(edge_postion,edge_frequency.getOrDefault(edge_postion,0)+1);  //Incrementing the Frequency of just calculated Edge Postion\\n                \\n                max_frequency = Math.max(edge_frequency.get(edge_postion),max_frequency);  //Comparing the \"Frequency of just calculated Edge Postion\" with \"Max Frequency seen till now\" & storing whichever is greater.\\n            }\\n        }\\n        return wall.size() - max_frequency; // returning (Number of Bricks Crossed by Line) i.e. (Number of Rows in Wall - Frequency of Most Occuring Edge) \\n    \\n    }\\n}\\n\\nPY:\\n\\ndef leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = collections.defaultdict(int)\\n        for line in wall:\\n            i = 0\\n            for brick in line[:-1]:\\n                i += brick\\n                d[i] += 1\\n        # print len(wall), d\\n        return len(wall)-max(d.values()+[0])\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n\\nIntuition:-\\nThe above wall is represented in a 2D Array where each element is the size of the respective brick :\\n[[1,2,2,1],\\n[3,1,2],\\n[1,3,2],\\n[2,4],\\n[3,1,2],\\n[1,3,1,1]]\\n\\nNote : Size of each brick is at least 1 unit.\\n\\nSo to mininize the number of bricks crossed by line, we want the line to pass through as many edges as possible.\\nFor this approach the edge postion will be defined with respect to the leftmost edge.\\n\\nAny edge position can be calculated by the sum of the lenghts of bricks observed till that edge.\\nLike in the above diagram :\\nEdge Position = Length of 1st Brick + Length of 2nd Brick\\n=> Edge Position = 1 + 2\\n=> Edge Position = 3\\n\\nNOTE: You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.\\nBecause of this note we won\\'t consider the edge 0 & edge 6 to solve the question.\\n\\nOne interesting observation is that for calculating next edge position, we don\\'t have to start adding the lengths from the very first brick of the row. Instead, we can add the \"Sum of lengths of bricks obervered till the previous edge\" + current brick\\'s length.\\nSo,\\nNext Edge Position = (Sum of lengths of bricks observered till the previous edge) + Current Brick\\'s Length.\\n=> Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n\\nThe edge which happens to be in multiple rows will contribute to the optimal solution as the line passing through that common edge will result in minimun crossing/cutting of bricks.\\nHence we wanna find the edge that has higest frequency in the wall.\\n\\nNow comes an important question, which data structure should we use and why?\\nSuggestion :\\nHow about using a data-structure that stores the 2-dimentional grid information via which we can access any position\\'s info (whether its a brick or an edge) in a constant time?\\nAnalysis of Suggestion :\\nThe problem of using a 2D grid is that we will be storing the edge\\'s positions as well as the brick\\'s positions. So we are wasting space in storing all the brick\\'s coordinates.\\nOptimizing the Suggestion :\\nSo if we look into our requirement, we are only concerned with the pair of \"position of the edge\" & \"its frequency in the wall\". We don\\'t care about the brick\\'s position. HashMap seems like a perfect data structure to store the pair\\n\\nHence we will store every calculated edge in a HashMap.\\nStructure of the HashMap :\\nKey of HashMap = Edge Position\\nValue of HashMap = Frequency of Edge in the Entire Wall\\n```\n```\\nNow we are sure that the line passing from edge 4 will result in minimum crossing of bricks.\\nBut we need to return the number of crossing the line makes.\\nIn the above diagram,\\nRed Box = Line passing through an edge\\nBlue Box = Line crossing through a brick\\n\\nHence a fomulae can be derived:\\nNumber of Blue Boxes+ Number of Red Boxes = Number of Rows in Wall\\n=> Number of Blue Boxes + (Frequency of Most Occuring Edge) = Number of Rows in Wall\\n=> (Number of Bricks Crossed by Line) + (Frequency of Most Occuring Edge) = Number of Rows in Wall\\n=> (Number of Bricks Crossed by Line) = Number of Rows in Wall - (Frequency of Most Occuring Edge)\\n\\nNumber of Bricks Crossed by Line = Number of Rows in Wall - Frequency of Most Occuring Edge\\n\\nHence\\nNumber of Bricks Crossed by Line = Number of Rows in Wall - Frequency of Most Occuring Edge\\n=> Number of Bricks Crossed by Line = 6 - 4\\n=> Number of Bricks Crossed by Line = 2 (We return this answer)\\n\\n```\n```\\n\\nBelow is the C++ Code of the above mentioned logic :\\n\\n\\ncpp:\\n\\nint leastBricks(vector<vector<int>>& wall) {\\nunordered_map<int, int> edge_frequency;     //HashMap to store the number of common edges among the rows\\n\\n        int max_frequency = 0;         //Variable to store the frequency of most occuring edge\\n        \\n        for(int row=0; row<wall.size(); row++)        //Iterating through each row\\n        {\\n            int edge_postion = 0;       //Variable to store different edge postion\\n            \\n            for(int brick_no=0; brick_no< wall[row].size() -1; brick_no++)    //Iterating through each brick inside a row\\n            { \\n                int current_brick_length = wall[row][brick_no];  //Length of the current brick\\n                \\n                edge_postion = edge_postion + current_brick_length ;  //Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n                \\n                edge_frequency[edge_postion]++;  //Incrementing the Frequency of just calculated Edge Postion\\n                \\n                max_frequency = max(edge_frequency[edge_postion],max_frequency);  //Comparing the \"Frequency of just calculated Edge Postion\" with \"Max Frequency seen till now\" & storing whichever is greater.\\n            }\\n        }\\n        return wall.size() - max_frequency; // returning (Number of Bricks Crossed by Line) i.e. (Number of Rows in Wall - Frequency of Most Occuring Edge) \\n    }\\n\\nJava:\\n\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        var edge_frequency=new HashMap<Integer,Integer>();     //HashMap to store the number of common edges among the rows\\n\\n        int max_frequency = 0;         //Variable to store the frequency of most occuring edge\\n        \\n        for(int row=0; row<wall.size(); row++)        //Iterating through each row\\n        {\\n            int edge_postion = 0;       //Variable to store different edge postion\\n            \\n            for(int brick_no=0; brick_no< wall.get(row).size() -1; brick_no++)    //Iterating through each brick inside a row\\n            { \\n                int current_brick_length = wall.get(row).get(brick_no);  //Length of the current brick\\n                \\n                edge_postion = edge_postion + current_brick_length ;  //Next Edge Position = Previous Edge Position + Current Brick\\'s Length\\n                \\n                edge_frequency.put(edge_postion,edge_frequency.getOrDefault(edge_postion,0)+1);  //Incrementing the Frequency of just calculated Edge Postion\\n                \\n                max_frequency = Math.max(edge_frequency.get(edge_postion),max_frequency);  //Comparing the \"Frequency of just calculated Edge Postion\" with \"Max Frequency seen till now\" & storing whichever is greater.\\n            }\\n        }\\n        return wall.size() - max_frequency; // returning (Number of Bricks Crossed by Line) i.e. (Number of Rows in Wall - Frequency of Most Occuring Edge) \\n    \\n    }\\n}\\n\\nPY:\\n\\ndef leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = collections.defaultdict(int)\\n        for line in wall:\\n            i = 0\\n            for brick in line[:-1]:\\n                i += brick\\n                d[i] += 1\\n        # print len(wall), d\\n        return len(wall)-max(d.values()+[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172289,
                "title": "ruby-o-mn",
                "content": "```\\n# @param {Integer[][]} wall\\n# @return {Integer}\\ndef least_bricks(wall)\\n  boundary_occ_h = Hash.new(0)\\n  \\n  wall.each do |brick_row|\\n    boundary = 0\\n    \\n    brick_row[0..-2].each do |brick_length|\\n      boundary += brick_length\\n      boundary_occ_h[boundary] += 1\\n    end\\n  end\\n  \\n  boundary_occurrence = boundary_occ_h.values\\n  \\n  if boundary_occurrence.empty?\\n    wall.count\\n  else\\n    wall.count - boundary_occurrence.max\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} wall\\n# @return {Integer}\\ndef least_bricks(wall)\\n  boundary_occ_h = Hash.new(0)\\n  \\n  wall.each do |brick_row|\\n    boundary = 0\\n    \\n    brick_row[0..-2].each do |brick_length|\\n      boundary += brick_length\\n      boundary_occ_h[boundary] += 1\\n    end\\n  end\\n  \\n  boundary_occurrence = boundary_occ_h.values\\n  \\n  if boundary_occurrence.empty?\\n    wall.count\\n  else\\n    wall.count - boundary_occurrence.max\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 674168,
                "title": "java-hashmap",
                "content": "```\\n\\tpublic int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for (List<Integer> l : wall) {\\n            for (int i = 0, len = 0; i < l.size() - 1; i++) {\\n                len += l.get(i);\\n                map.put(len, map.getOrDefault(len, 0) + 1);\\n            }\\n        }\\n        for (int i : map.keySet()) max = Math.max(max, map.get(i));\\n        return wall.size() - max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for (List<Integer> l : wall) {\\n            for (int i = 0, len = 0; i < l.size() - 1; i++) {\\n                len += l.get(i);\\n                map.put(len, map.getOrDefault(len, 0) + 1);\\n            }\\n        }\\n        for (int i : map.keySet()) max = Math.max(max, map.get(i));\\n        return wall.size() - max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270808,
                "title": "c-hashmap-solution-beats-96-73-time-and-98-81-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int numOfRows = wall.size();\\n        unordered_map<int, int> numToCount;\\n        for(int i = 0; i < numOfRows; i++) {\\n            int offset = 0;\\n            for(int j = 0; j < wall[i].size()-1; j++) {\\n                offset += wall[i][j]; \\n                numToCount[offset]++;\\n            }\\n        }\\n        int maxCount = 0;\\n        for(auto it = numToCount.begin(); it != numToCount.end(); it++) {\\n            if(it->second > maxCount) {\\n                maxCount = it->second;\\n            }\\n        }\\n        \\n        int res = numOfRows - maxCount;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int numOfRows = wall.size();\\n        unordered_map<int, int> numToCount;\\n        for(int i = 0; i < numOfRows; i++) {\\n            int offset = 0;\\n            for(int j = 0; j < wall[i].size()-1; j++) {\\n                offset += wall[i][j]; \\n                numToCount[offset]++;\\n            }\\n        }\\n        int maxCount = 0;\\n        for(auto it = numToCount.begin(); it != numToCount.end(); it++) {\\n            if(it->second > maxCount) {\\n                maxCount = it->second;\\n            }\\n        }\\n        \\n        int res = numOfRows - maxCount;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101746,
                "title": "c-java-clean-code",
                "content": "for every row, whenever add a brick, record the end position as +1.\\ngoal is to find the position where most row have a break on that position.\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int, int> ends;\\n        int maxend = 0;\\n        for (int i = 0; i < wall.size(); i++) {\\n            int sum = 0;\\n            for (int j = 0; j + 1 < wall[i].size(); j++) {\\n                ends[sum += wall[i][j]]++;\\n                maxend = max(maxend, ends[sum]);\\n            }\\n        }\\n\\n        return wall.size() - maxend;\\n    }\\n};\\n```\\n**Java**\\n```\\npublic class Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> ends = new HashMap<Integer, Integer>();\\n        int maxend = 0;\\n        for (int i = 0; i < wall.size(); i++) {\\n            int sum = 0;\\n            for (int j = 0; j + 1 < wall.get(i).size(); j++) {\\n                sum += wall.get(i).get(j);\\n                ends.put(sum, ends.getOrDefault(sum, 0) + 1);\\n                maxend = Math.max(maxend, ends.get(sum));\\n            }\\n        }\\n\\n        return wall.size() - maxend;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int, int> ends;\\n        int maxend = 0;\\n        for (int i = 0; i < wall.size(); i++) {\\n            int sum = 0;\\n            for (int j = 0; j + 1 < wall[i].size(); j++) {\\n                ends[sum += wall[i][j]]++;\\n                maxend = max(maxend, ends[sum]);\\n            }\\n        }\\n\\n        return wall.size() - maxend;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> ends = new HashMap<Integer, Integer>();\\n        int maxend = 0;\\n        for (int i = 0; i < wall.size(); i++) {\\n            int sum = 0;\\n            for (int j = 0; j + 1 < wall.get(i).size(); j++) {\\n                sum += wall.get(i).get(j);\\n                ends.put(sum, ends.getOrDefault(sum, 0) + 1);\\n                maxend = Math.max(maxend, ends.get(sum));\\n            }\\n        }\\n\\n        return wall.size() - maxend;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562527,
                "title": "python-dictionary-with-explanation",
                "content": "# Intuition\\nYou have to find the best coloumn basically through which we can draw a line so we cross the least number of walls.\\nSo why not we store all the number of bricks which end at that particular coloumn.\\n\\n`Why? Because if we choose a coloumn where max brick ends then we have to cross the least number of bricks.`\\n\\nSo Make a dict to store all the number of bricks ending at particular coloumn and then choose the max brick ending and subtract it with n.\\n\\n`Why? Becuase n is the number of rows so it will denote the total number of bricks it have to cross`\\n# Code\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        n = len(wall)\\n        m = sum(wall[0])\\n        col0 = defaultdict(int)\\n        for i in range(n):\\n            prev = 0\\n            for j in range(len(wall[i])):\\n                col0[prev + wall[i][j]] += 1\\n                prev += wall[i][j] # update the ending of particular brick for each row \\n        col0[m] = 0\\n        bricks = max(v for v in col0.values())\\n        return n - bricks\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        n = len(wall)\\n        m = sum(wall[0])\\n        col0 = defaultdict(int)\\n        for i in range(n):\\n            prev = 0\\n            for j in range(len(wall[i])):\\n                col0[prev + wall[i][j]] += 1\\n                prev += wall[i][j] # update the ending of particular brick for each row \\n        col0[m] = 0\\n        bricks = max(v for v in col0.values())\\n        return n - bricks\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400046,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int len = 0, n = wall.size();\\n        for(int i = 0; i < wall[0].size(); ++i){\\n            len += wall[0][i];\\n        }\\n        unordered_map<int, int> freq{};\\n        for(int i = 0; i < n; ++i){\\n            int cur = -1;\\n            for(int j = 0; j < wall[i].size() - 1; ++j){\\n                cur += wall[i][j];\\n                ++freq[cur];\\n            }\\n        }\\n        int ans = n;\\n        int m = 0;\\n        for(auto& a : freq){\\n            m = max(m, a.second);\\n        }\\n        return ans - m;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        countGap = { 0 : 0 }\\n\\n        for r in wall:\\n            total = 0\\n            for b in r[:-1]:\\n                total += b\\n                countGap[total] = 1 + countGap.get(total, 0)\\n\\n        return len(wall) - max(countGap.values())\\n```\\n\\n```Java []\\nclass Solution {\\n    int best = 0;\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    public int leastBricks(List<List<Integer>> wall) {\\n        for (int i = 0; i < wall.size(); i++)\\n            processRow(wall.get(i));\\n        return wall.size() - best;\\n    }\\n    public void processRow(List<Integer> row) {\\n        int rowSum = row.get(0);\\n        for (int j = 1; j < row.size(); j++) {\\n            int f = freq.getOrDefault(rowSum, 0) + 1;\\n            freq.put(rowSum, f);\\n            if (f > best) best = f;\\n            rowSum += row.get(j);\\n        } \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int len = 0, n = wall.size();\\n        for(int i = 0; i < wall[0].size(); ++i){\\n            len += wall[0][i];\\n        }\\n        unordered_map<int, int> freq{};\\n        for(int i = 0; i < n; ++i){\\n            int cur = -1;\\n            for(int j = 0; j < wall[i].size() - 1; ++j){\\n                cur += wall[i][j];\\n                ++freq[cur];\\n            }\\n        }\\n        int ans = n;\\n        int m = 0;\\n        for(auto& a : freq){\\n            m = max(m, a.second);\\n        }\\n        return ans - m;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        countGap = { 0 : 0 }\\n\\n        for r in wall:\\n            total = 0\\n            for b in r[:-1]:\\n                total += b\\n                countGap[total] = 1 + countGap.get(total, 0)\\n\\n        return len(wall) - max(countGap.values())\\n```\n```Java []\\nclass Solution {\\n    int best = 0;\\n    Map<Integer, Integer> freq = new HashMap<>();\\n    public int leastBricks(List<List<Integer>> wall) {\\n        for (int i = 0; i < wall.size(); i++)\\n            processRow(wall.get(i));\\n        return wall.size() - best;\\n    }\\n    public void processRow(List<Integer> row) {\\n        int rowSum = row.get(0);\\n        for (int j = 1; j < row.size(); j++) {\\n            int f = freq.getOrDefault(rowSum, 0) + 1;\\n            freq.put(rowSum, f);\\n            if (f > best) best = f;\\n            rowSum += row.get(j);\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372096,
                "title": "python-elegant-short-prefix-sum",
                "content": "# Complexity\\n- Time complexity: $$O(n * m)$$\\n- Space complexity: $$O(m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        n, m = len(wall), sum(wall[0])\\n        bricks = defaultdict(int)\\n\\n        for row in wall:\\n            for acc in accumulate(row):\\n                bricks[acc] += 1\\n\\n        return n - max((val for i, val in bricks.items() if 0 < i < m), default=0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        n, m = len(wall), sum(wall[0])\\n        bricks = defaultdict(int)\\n\\n        for row in wall:\\n            for acc in accumulate(row):\\n                bricks[acc] += 1\\n\\n        return n - max((val for i, val in bricks.items() if 0 < i < m), default=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828227,
                "title": "java-hashmap-easy",
                "content": "### **Please Upvote** :D\\nThe hashmap stores at which places the bricks split. The place where the most number of bricks split is the place where we draw the line and we cross minimum bricks from within.\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int maxUntouched = 0;\\n\\n        for (List<Integer> row : wall) {\\n            int brickEnd = 0;\\n\\n            for (int i = 0; i < row.size() - 1; i++) {\\n                brickEnd += row.get(i);     // row.get(i) = brick size\\n                map.put(brickEnd, map.getOrDefault(brickEnd, 0) + 1);\\n                maxUntouched = Math.max(maxUntouched, map.get(brickEnd));\\n            }\\n        }\\n\\n        return wall.size() - maxUntouched;\\n    }\\n}\\n\\n// TC: O(m * n), O(n)\\n// m -> height of the wall\\n// n -> width of the wall\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int maxUntouched = 0;\\n\\n        for (List<Integer> row : wall) {\\n            int brickEnd = 0;\\n\\n            for (int i = 0; i < row.size() - 1; i++) {\\n                brickEnd += row.get(i);     // row.get(i) = brick size\\n                map.put(brickEnd, map.getOrDefault(brickEnd, 0) + 1);\\n                maxUntouched = Math.max(maxUntouched, map.get(brickEnd));\\n            }\\n        }\\n\\n        return wall.size() - maxUntouched;\\n    }\\n}\\n\\n// TC: O(m * n), O(n)\\n// m -> height of the wall\\n// n -> width of the wall\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746477,
                "title": "easy-python-solution-95-faster",
                "content": "```\\nclass Solution:\\n    def leastBricks(self, A: List[List[int]]) -> int:\\n        x = sum(A[0])\\n        arr = {}\\n        mx=0\\n        for i in range(len(A)):\\n            for j in range(len(A[i])-1):\\n                if j!=0:\\n                    A[i][j]+=A[i][j-1]\\n                if A[i][j]-1 not in arr:\\n                    arr[A[i][j]-1]=0\\n                arr[A[i][j]-1]+=1\\n                mx = max(mx,arr[A[i][j]-1])\\n        return len(A)-mx\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, A: List[List[int]]) -> int:\\n        x = sum(A[0])\\n        arr = {}\\n        mx=0\\n        for i in range(len(A)):\\n            for j in range(len(A[i])-1):\\n                if j!=0:\\n                    A[i][j]+=A[i][j-1]\\n                if A[i][j]-1 not in arr:\\n                    arr[A[i][j]-1]=0\\n                arr[A[i][j]-1]+=1\\n                mx = max(mx,arr[A[i][j]-1])\\n        return len(A)-mx\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394991,
                "title": "easy-sol-using-hashmap-and-prefix-sum",
                "content": "*STEPS:\\n1) CALCULATE THE PREFIX SUM OF EACH OF THE ROW OF THE GIVEN WALL AND STRE IT\\n2) USING A MAP COUNT COUNT THE NUMBER OF OCCURRENCES OF EACH OF THE PREFIX SUM\\n3) THE SUM WHICH OCCURS MOST FREQUENTLY HAS MOST NUMBER OF EDGES PASSING..OR JUST TOUCHING IT.\\n4) FINALLY SUBTRACT IT FROM THE SIZE OF VECTOR..OR THE NUMBER OF ROWS IN OUR WALLS.\\n*\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>mp;//prefxi sum found and its count\\n        vector<vector<int>>pre;//vector to store the prefix sum\\n        for(auto row:wall)\\n        {\\n            int sum=0;\\n            vector<int>res;\\n            for(auto i:row)\\n            {\\n                sum+=i;\\n                res.push_back(sum);\\n            }\\n            pre.push_back(res);\\n        }\\n        int maxfrq=0;\\n        //we have the prefix sum for every row of the wall\\n        for(int i=0;i<size(pre);i++)//iterate through prefix sum of every wall\\n        {\\n            vector<int>&x=pre[i];//taking the 1st wall\\n            for(int j=0;j<x.size()-1;j++)\\n            {\\n                mp[x[j]]++;\\n                maxfrq=max(maxfrq,mp[x[j]]);\\n            }\\n        }\\n        return wall.size()-maxfrq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>mp;//prefxi sum found and its count\\n        vector<vector<int>>pre;//vector to store the prefix sum\\n        for(auto row:wall)\\n        {\\n            int sum=0;\\n            vector<int>res;\\n            for(auto i:row)\\n            {\\n                sum+=i;\\n                res.push_back(sum);\\n            }\\n            pre.push_back(res);\\n        }\\n        int maxfrq=0;\\n        //we have the prefix sum for every row of the wall\\n        for(int i=0;i<size(pre);i++)//iterate through prefix sum of every wall\\n        {\\n            vector<int>&x=pre[i];//taking the 1st wall\\n            for(int j=0;j<x.size()-1;j++)\\n            {\\n                mp[x[j]]++;\\n                maxfrq=max(maxfrq,mp[x[j]]);\\n            }\\n        }\\n        return wall.size()-maxfrq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871177,
                "title": "c-very-very-simple-code-easy-to-understand",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n````\\nint leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> mp;\\n        int n=wall.size(),ans=0;\\n        for(int i=0;i<n;++i){\\n            int sm=0;\\n            for(int j=0;j<wall[i].size();++j){\\n                sm+=wall[i][j];\\n                mp[sm]++;\\n                if(j==wall[i].size()-1) continue;\\n                ans=max(ans,mp[sm]);\\n            }\\n        }\\n        return n-ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n````\\nint leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> mp;\\n        int n=wall.size(),ans=0;\\n        for(int i=0;i<n;++i){\\n            int sm=0;\\n            for(int j=0;j<wall[i].size();++j){\\n                sm+=wall[i][j];\\n                mp[sm]++;\\n                if(j==wall[i].size()-1) continue;\\n                ans=max(ans,mp[sm]);\\n            }\\n        }\\n        return n-ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1656300,
                "title": "java-explained-with-picture-hashmap-with-edge-count",
                "content": "// The point here to consider is the most EDGES the line crosses the less bricks the line goes through.\\n// For all the rows of bricks, find each edge index and store in a map with its freq. \\n// Do it for every row and store all the edges in each row and if you find an edge index already in map, UPDATE the count\\n// The MAX COUNT for some edge index will help in drawing the line\\n\\n// Thanks @kunalchand234 for amazing explanation. The pictures are utilized from his post.\\n\\n![image](https://assets.leetcode.com/users/images/597fa89f-1895-46a7-965c-4f4424424dfb_1640854273.8434193.png)\\n\\n![image](https://assets.leetcode.com/users/images/f091b4dc-2d36-4c69-9250-1c0f848924d1_1640854289.3657134.png)\\n\\nThe blue box in below pictures which bricks the line crosses\\n![image](https://assets.leetcode.com/users/images/cb2710ea-5f0b-4839-9e2c-c1bc3cfa97b8_1640854354.414998.png)\\n\\n\\n// See here for detailed solution : https://leetcode.com/problems/brick-wall/discuss/888577/IntuitionC%2B%2BWith-PicturesHashMapDetailed-ExplanationCommentsSolutionCode\\n\\n// TC : O(M * N) -> M = walls.length, N = avg num of bricks in each row\\n// SC : O(N) -> N = avg num of bricks in each row\\n\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> edgeMap = new HashMap<>(); // key -> edge, value -> freq of edge\\n        \\n        int count = 0; // max count for edge index\\n        \\n        for(List<Integer> bricks : wall) {\\n            int edge = 0;\\n            for(int i = 0; i < bricks.size() - 1; i++) { // -1 because we do not want to use last edge\\n                edge += bricks.get(i); // every time adding brick size will gice next edge\\n                edgeMap.put(edge, edgeMap.getOrDefault(edge, 0) + 1);\\n                count = Math.max(count, edgeMap.get(edge));\\n            }\\n        }\\n        \\n        return wall.size() - count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> edgeMap = new HashMap<>(); // key -> edge, value -> freq of edge\\n        \\n        int count = 0; // max count for edge index\\n        \\n        for(List<Integer> bricks : wall) {\\n            int edge = 0;\\n            for(int i = 0; i < bricks.size() - 1; i++) { // -1 because we do not want to use last edge\\n                edge += bricks.get(i); // every time adding brick size will gice next edge\\n                edgeMap.put(edge, edgeMap.getOrDefault(edge, 0) + 1);\\n                count = Math.max(count, edgeMap.get(edge));\\n            }\\n        }\\n        \\n        return wall.size() - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517696,
                "title": "java-using-hashmap",
                "content": "Using HashMap Logic behind this prefix sum\\nIn this find the maximum number of bricks have that skips gap and then subtract max from the total bricks.\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<wall.size();i++){\\n            int val=0;\\n            for(int j=0;j<wall.get(i).size()-1;j++){\\n                val+=wall.get(i).get(j);\\n                if(map.containsKey(val)){\\n                    map.put(val,map.get(val)+1);\\n                }\\n                else{\\n                    map.put(val,1);\\n                }\\n                max=Math.max(max,map.get(val));\\n            }\\n        }\\n        return wall.size()-max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<wall.size();i++){\\n            int val=0;\\n            for(int j=0;j<wall.get(i).size()-1;j++){\\n                val+=wall.get(i).get(j);\\n                if(map.containsKey(val)){\\n                    map.put(val,map.get(val)+1);\\n                }\\n                else{\\n                    map.put(val,1);\\n                }\\n                max=Math.max(max,map.get(val));\\n            }\\n        }\\n        return wall.size()-max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172035,
                "title": "c-frequency-map-solution-explained-100-time-30-space",
                "content": "This problem might tempt you to go for some complex logic in which you compute intervals one step at a time, but in the end all you need to get is the position and thus the frequency of all the gaps in the wall, then return the total number of layers in the wall minus the minimum amount of them.\\n\\nTo do so, we will first of all define a few support variables:\\n* `len` will store the length of the wall (in levels);\\n* `res` is were we will store our best result - initially set to be equal to `len` (edge/worst case: no gaps);\\n* `c` is going to store the cumulative total of all the elements of each layer (save for the last);\\n* `um` is where we will store the frequency of each gap.\\n\\nWe will then iterate through each `level` of `wall` and:\\n* set `c` to be `0`;\\n* loop through all the elements of `level` but the last one (which is never needed) and:\\n\\t* increase the cumulative length of the current `level` with `c += level[i]`;\\n\\t* increase the frequency of that length in `um`.\\n\\nNext, we will just iterate through all the frequencies we found (with `e.second`) and update `res` to be the minimum between its current value and `len - e.second` (i.e.: the amount of gaps not present for that layer).\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        // support variables\\n        int len = wall.size(), res = len, c;\\n        unordered_map<int, int> um;\\n        // getting the frequencies of each gap\\n        for (auto &level: wall) {\\n            c = 0;\\n            for (int i = 0, lmt = level.size() - 1; i < lmt; i++) um[c += level[i]]++;\\n        }\\n        // getting the most frequent gap\\n        for (auto e: um) {\\n            res = min(res, len - e.second);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nMicro-optimised alternative in which we just subtract from `len` in the end, instead of doing so every time we update `res`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        // support variables\\n        int len = wall.size(), res = 0, c;\\n        unordered_map<int, int> um;\\n        // getting the frequencies of each gap\\n        for (auto &level: wall) {\\n            c = 0;\\n            for (int i = 0, lmt = level.size() - 1; i < lmt; i++) um[c += level[i]]++;\\n        }\\n        // getting the most frequent gap\\n        for (auto e: um) {\\n            res = max(res, e.second);\\n        }\\n        return len - res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        // support variables\\n        int len = wall.size(), res = len, c;\\n        unordered_map<int, int> um;\\n        // getting the frequencies of each gap\\n        for (auto &level: wall) {\\n            c = 0;\\n            for (int i = 0, lmt = level.size() - 1; i < lmt; i++) um[c += level[i]]++;\\n        }\\n        // getting the most frequent gap\\n        for (auto e: um) {\\n            res = min(res, len - e.second);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        // support variables\\n        int len = wall.size(), res = 0, c;\\n        unordered_map<int, int> um;\\n        // getting the frequencies of each gap\\n        for (auto &level: wall) {\\n            c = 0;\\n            for (int i = 0, lmt = level.size() - 1; i < lmt; i++) um[c += level[i]]++;\\n        }\\n        // getting the most frequent gap\\n        for (auto e: um) {\\n            res = max(res, e.second);\\n        }\\n        return len - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171864,
                "title": "python-one-liners-counter-vs-numpy",
                "content": "Counter:\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - max(Counter(chain.from_iterable(map(lambda x: accumulate(x[:-1]), wall))).values(), default=0)\\n```\\nNumPy:\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - np.max(np.bincount(np.concatenate([np.cumsum(row[:-1], dtype=int) for row in wall])), initial=0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - max(Counter(chain.from_iterable(map(lambda x: accumulate(x[:-1]), wall))).values(), default=0)\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - np.max(np.bincount(np.concatenate([np.cumsum(row[:-1], dtype=int) for row in wall])), initial=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171247,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        vector<int> v(110001);\\n        int line = 0;\\n        for(int i=0; i<wall.size(); i++)\\n        {\\n            int sum = 0;\\n            for(int j=0; j<wall[i].size()-1; j++)\\n            {\\n                sum += wall[i][j];\\n                v[sum] += 1;\\n                line = max(line , v[sum]);\\n            }\\n        }\\n        return wall.size() - line;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        vector<int> v(110001);\\n        int line = 0;\\n        for(int i=0; i<wall.size(); i++)\\n        {\\n            int sum = 0;\\n            for(int j=0; j<wall[i].size()-1; j++)\\n            {\\n                sum += wall[i][j];\\n                v[sum] += 1;\\n                line = max(line , v[sum]);\\n            }\\n        }\\n        return wall.size() - line;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170905,
                "title": "easy-brick-wall-unordered-map",
                "content": "**Approach**\\nWe are going to keep track of the frequency of each edge size. We are concerned with the edge which occurs in most of the rows, as that would pass though minimum bricks. So we keep track of frequency of all edges in a row and keep updating the maximum frequency. At last, we have to find out number of crossed bricks which will be equal to total no. of rows - maximum frequency.\\n\\n**Solution**\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> frequency;\\n        int max_frequency=0;\\n        for(int i=0;i<wall.size();i++){\\n            int edge_size=0;\\n            for(int j=0;j<wall[i].size()-1;j++){\\n                edge_size+=wall[i][j];\\n                frequency[edge_size]++;\\n                max_frequency=max(max_frequency,frequency[edge_size]);\\n            }\\n        }\\n        return wall.size()-max_frequency;\\n    }\\n};\\n```\\n\\n**Time Complexity**: O(n*m)\\n**Space Complexity**: O(m)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> frequency;\\n        int max_frequency=0;\\n        for(int i=0;i<wall.size();i++){\\n            int edge_size=0;\\n            for(int j=0;j<wall[i].size()-1;j++){\\n                edge_size+=wall[i][j];\\n                frequency[edge_size]++;\\n                max_frequency=max(max_frequency,frequency[edge_size]);\\n            }\\n        }\\n        return wall.size()-max_frequency;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682662,
                "title": "c-easy-hashmap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& v) {\\n        map<int,int>mp;\\n        int ans=INT_MIN;\\n        for(int i=0;i<v.size();i++){\\n            int sum=0;\\n            for(int j=0;j<v[i].size()-1;j++){\\n                sum=sum+v[i][j];\\n                if(!mp.count(sum)) mp[sum]=1;\\n                else mp[sum]++;\\n                ans=max(ans,mp[sum]);\\n            }\\n        }\\n        if(ans==INT_MIN) return v.size();\\n        return v.size()-ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& v) {\\n        map<int,int>mp;\\n        int ans=INT_MIN;\\n        for(int i=0;i<v.size();i++){\\n            int sum=0;\\n            for(int j=0;j<v[i].size()-1;j++){\\n                sum=sum+v[i][j];\\n                if(!mp.count(sum)) mp[sum]=1;\\n                else mp[sum]++;\\n                ans=max(ans,mp[sum]);\\n            }\\n        }\\n        if(ans==INT_MIN) return v.size();\\n        return v.size()-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613228,
                "title": "easy-c-implementation-using-map-with-explanation",
                "content": "The question at first might sound different to you once you go through it (atleast it sound me difficult at first), but its approach is way simple.\\n***Intuition:-***\\nLook at this example,\\n[[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\\n\\nJust focus on the first row, you will found that the 1st brick ends at width 1, 2nd brick ends at width 3, 3rd brich ends at width 5 and last brick ends at width 6. Thus if you start drawing the vertical line from position 1,3,5,6 than you are not crossing any brick in row 1. Now find this thing for every row.\\n\\nYou will get :-\\n1 3 5 6\\n3 4 6\\n1 4 6\\n2 6\\n3 4 6\\n1 4 5 6\\n\\nHere I have shown the ending width of last brick but it is mentioned that we should not consider this,\\n***You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.***\\n\\n1 3 5\\n3 4\\n1 4\\n2\\n3 4\\n1 4 5\\n\\nWe are left with these values, store these value as key and their frequency in a map.\\n\\nLet n   = wall.size();\\nFind max frequency in the map let it be maxFreq.\\nand return n - maxFreq.\\n\\nThe maxFreq element shows the edge of the bricks in different rows that are ending at that location, i.e. if we draw our line at the location corresponding to the keye of maxFreq in map, that maxFreq number of bricks will not be cut.\\nThus bricks that will cut are\\nn - maxFreq\\n\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n = wall.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            int sumBias = 0;\\n            for(int j=0;j<wall[i].size()-1;j++){\\n                int currWidth = sumBias + wall[i][j];\\n                if(mp.find(currWidth) == mp.end()){\\n                    mp[currWidth] = 1;\\n                }else{\\n                    mp[currWidth]++;\\n                }\\n                sumBias += wall[i][j];\\n            }\\n            \\n        }\\n        \\n        unordered_map<int,int>::iterator it;\\n        int maxFreq = 0;\\n        int maxCut = 0;\\n        \\n        for(it=mp.begin();it!=mp.end();it++){\\n            int currCut = it->first;\\n            int currFreq = it->second;\\n            if(currFreq > maxFreq){\\n                maxFreq = currFreq;\\n                maxCut = currCut;\\n            }\\n        }\\n        return n-maxFreq;\\n    }\\n};\\n```\\n\\nhope it helps!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n = wall.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            int sumBias = 0;\\n            for(int j=0;j<wall[i].size()-1;j++){\\n                int currWidth = sumBias + wall[i][j];\\n                if(mp.find(currWidth) == mp.end()){\\n                    mp[currWidth] = 1;\\n                }else{\\n                    mp[currWidth]++;\\n                }\\n                sumBias += wall[i][j];\\n            }\\n            \\n        }\\n        \\n        unordered_map<int,int>::iterator it;\\n        int maxFreq = 0;\\n        int maxCut = 0;\\n        \\n        for(it=mp.begin();it!=mp.end();it++){\\n            int currCut = it->first;\\n            int currFreq = it->second;\\n            if(currFreq > maxFreq){\\n                maxFreq = currFreq;\\n                maxCut = currCut;\\n            }\\n        }\\n        return n-maxFreq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453655,
                "title": "java-easy-to-understand-solution-with-explanation-faster-than-98-7",
                "content": "My code basically finds  the maximum occuring cumulative sum across all rows of bricks in the wall. \\n```\\npublic int leastBricks(List<List<Integer>> wall) {\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tint max = 0;\\n\\tfor(List<Integer> l : wall) {\\n\\t\\tint sum = 0;\\n\\t\\tfor(int i=0; i<l.size()-1; i++) {\\n\\t\\t\\tsum += l.get(i);\\n\\t\\t\\tint val = hm.getOrDefault(sum, 0)+1;\\n\\t\\t\\thm.put(sum, val);\\n\\t\\t\\tmax = Math.max(max, val);\\n\\t\\t}\\n\\t}\\n\\treturn wall.size()-max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int leastBricks(List<List<Integer>> wall) {\\n\\tHashMap<Integer, Integer> hm = new HashMap<>();\\n\\tint max = 0;\\n\\tfor(List<Integer> l : wall) {\\n\\t\\tint sum = 0;\\n\\t\\tfor(int i=0; i<l.size()-1; i++) {\\n\\t\\t\\tsum += l.get(i);\\n\\t\\t\\tint val = hm.getOrDefault(sum, 0)+1;\\n\\t\\t\\thm.put(sum, val);\\n\\t\\t\\tmax = Math.max(max, val);\\n\\t\\t}\\n\\t}\\n\\treturn wall.size()-max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382414,
                "title": "easy-peasy-python-solution",
                "content": "\\tdef leastBricks(self, wall: List[List[int]]) -> int:\\n        if len(wall) == 0:\\n            return 0\\n        mp = {}\\n        for w in wall:\\n            sm = 0\\n            # no need to check the last brick, \\n            # because we can\\'t put a line at the end\\n            for i in range(len(w)-1):\\n                brick = w[i]\\n                sm += brick\\n                mp[sm] = mp.get(sm, 0) + 1\\n        \\n        rs = 0\\n        for key, val in mp.items():\\n            rs = max(rs, val)\\n        \\n        return len(wall) - rs",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef leastBricks(self, wall: List[List[int]]) -> int:\\n        if len(wall) == 0:\\n            return 0\\n        mp = {}\\n        for w in wall:\\n            sm = 0\\n            # no need to check the last brick, \\n            # because we can\\'t put a line at the end\\n            for i in range(len(w)-1):\\n                brick = w[i]\\n                sm += brick\\n                mp[sm] = mp.get(sm, 0) + 1\\n        \\n        rs = 0\\n        for key, val in mp.items():\\n            rs = max(rs, val)\\n        \\n        return len(wall) - rs",
                "codeTag": "Python3"
            },
            {
                "id": 352032,
                "title": "solved-it-using-heap-stupid-solution-but-worth-checking",
                "content": "**My initial attempt was using heap , did not gave too much thought and just coded.\\nThan realized than dictionary could have been much easier to code.**\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        countToBrickIds = collections.defaultdict(list)\\n        \\n        for row in range(len(wall)):\\n            countToBrickIds[wall[row][0]].append((row,0))\\n        \\n        \\n        heap = []\\n        visited = set()\\n        for count in countToBrickIds:\\n            visited.add(count)\\n            heapq.heappush(heap,count)\\n        \\n        result = 0\\n        limit = sum(wall[0])\\n    \\n        while len(heap) > 0:\\n            minCount = heapq.heappop(heap)\\n            indices = countToBrickIds[minCount]\\n            if minCount != limit:\\n                result = max(result,len(indices))\\n            for row,col in indices:\\n                if col+1 < len(wall[row]):\\n                    newCount = minCount+wall[row][col+1]\\n                    if newCount not in visited:\\n                        heapq.heappush(heap,newCount)\\n                        visited.add(newCount)\\n                    countToBrickIds[newCount].append((row,col+1))\\n            countToBrickIds[minCount] = []\\n\\n        return len(wall)-result\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        countToBrickIds = collections.defaultdict(list)\\n        \\n        for row in range(len(wall)):\\n            countToBrickIds[wall[row][0]].append((row,0))\\n        \\n        \\n        heap = []\\n        visited = set()\\n        for count in countToBrickIds:\\n            visited.add(count)\\n            heapq.heappush(heap,count)\\n        \\n        result = 0\\n        limit = sum(wall[0])\\n    \\n        while len(heap) > 0:\\n            minCount = heapq.heappop(heap)\\n            indices = countToBrickIds[minCount]\\n            if minCount != limit:\\n                result = max(result,len(indices))\\n            for row,col in indices:\\n                if col+1 < len(wall[row]):\\n                    newCount = minCount+wall[row][col+1]\\n                    if newCount not in visited:\\n                        heapq.heappush(heap,newCount)\\n                        visited.add(newCount)\\n                    countToBrickIds[newCount].append((row,col+1))\\n            countToBrickIds[minCount] = []\\n\\n        return len(wall)-result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 101780,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Brick Wall** https://leetcode.com/problems/brick-wall/#/description\\n\\n**Optimized Approach**\\n* Create a hash-table with key as a potential brick edge and value as a set of rows which share that edge.\\n* How do we get a potential brick edge? Consider row (0) = [1,2,2,1], the edges are 1,3,5,6. So we add all these edges as keys to the cache. The value set will have row 0. Repeat the process for all rows. Note we would not want to add edge 6 (the final boundary) just like we dont want to add edge 0 - it is a common edge for all lines.\\n* Now we would want the line to pass through atleast one edge. Therefore the potential start points for the line are the keys in the cache. How many bricks will a line with a start point st cross? Answer: len(wall) - the rows where it is an edge. The latter can be answered from the cache we developed in the previous step.\\n\\n```\\nfrom collections import defaultdict        \\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if wall == []:\\n            return 0\\n        cache, csum, min_so_far = defaultdict(set), 0, len(wall)\\n        for idx, row in enumerate(wall):\\n            csum = 0\\n            for x in row:\\n                csum += x\\n                cache[csum].add(idx)\\n        del cache[csum]\\n        for st in cache.keys():\\n            min_so_far = min(min_so_far, len(wall)-len(cache[st]))\\n        return min_so_far\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict        \\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if wall == []:\\n            return 0\\n        cache, csum, min_so_far = defaultdict(set), 0, len(wall)\\n        for idx, row in enumerate(wall):\\n            csum = 0\\n            for x in row:\\n                csum += x\\n                cache[csum].add(idx)\\n        del cache[csum]\\n        for st in cache.keys():\\n            min_so_far = min(min_so_far, len(wall)-len(cache[st]))\\n        return min_so_far\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866967,
                "title": "beginners-method-by-a-guy-who-is-still-trying-with-explanation-and-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int,int>m; //making a map to store the frequencies\\n        int sum=accumulate(wall[0].begin(),wall[0].end(),0); //stroing the sum to know about the end of the wall. As we do not have to go from there.\\n        for(auto i:wall){ //just iterate through the wall and generate the coordinates accordingly.\\n            int pre=0;\\n            for(int j=0; j<i.size(); j++){\\n                \\n                m[pre+i[j]]++; //building the oordinate so that it will be easy to track\\n                pre+=i[j];\\n            }\\n        }\\n        m.erase(sum); //just remove the end of the wall so that we will be tension free and will directly find out the maximum\\n        if(m.size()==0) return wall.size(); //if map is empty that means we have only one one brick wall aso we have no option we have to go through all the walls.\\n        int maxi=INT_MIN;\\n        for(auto i: m){\\n            cout<<i.first<<\" \"<<i.second<<endl;\\n            maxi=max(maxi,i.second);\\n        }\\n        return wall.size()-maxi; //just return the proper answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int,int>m; //making a map to store the frequencies\\n        int sum=accumulate(wall[0].begin(),wall[0].end(),0); //stroing the sum to know about the end of the wall. As we do not have to go from there.\\n        for(auto i:wall){ //just iterate through the wall and generate the coordinates accordingly.\\n            int pre=0;\\n            for(int j=0; j<i.size(); j++){\\n                \\n                m[pre+i[j]]++; //building the oordinate so that it will be easy to track\\n                pre+=i[j];\\n            }\\n        }\\n        m.erase(sum); //just remove the end of the wall so that we will be tension free and will directly find out the maximum\\n        if(m.size()==0) return wall.size(); //if map is empty that means we have only one one brick wall aso we have no option we have to go through all the walls.\\n        int maxi=INT_MIN;\\n        for(auto i: m){\\n            cout<<i.first<<\" \"<<i.second<<endl;\\n            maxi=max(maxi,i.second);\\n        }\\n        return wall.size()-maxi; //just return the proper answer\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3763249,
                "title": "c-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O (m*n + k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LeastBricks(IList<IList<int>> wall) {\\n          Dictionary<int,int> dict = new ();\\n          foreach(var col in wall)\\n          {\\n              var sum = 0;\\n              //we don\\'t consider the last brick\\n              for(var i = 0;i<col.Count-1;i++)\\n              {\\n                sum+=col[i];\\n                if(!dict.ContainsKey(sum))\\n                {\\n                    dict.Add(sum,0);\\n                }\\n                dict[sum]++;\\n              }\\n          }\\n\\n        var res = wall.Count;\\n        foreach (var dic in dict) \\n        {\\n            res = Math.Min(res, wall.Count - dic.Value);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LeastBricks(IList<IList<int>> wall) {\\n          Dictionary<int,int> dict = new ();\\n          foreach(var col in wall)\\n          {\\n              var sum = 0;\\n              //we don\\'t consider the last brick\\n              for(var i = 0;i<col.Count-1;i++)\\n              {\\n                sum+=col[i];\\n                if(!dict.ContainsKey(sum))\\n                {\\n                    dict.Add(sum,0);\\n                }\\n                dict[sum]++;\\n              }\\n          }\\n\\n        var res = wall.Count;\\n        foreach (var dic in dict) \\n        {\\n            res = Math.Min(res, wall.Count - dic.Value);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128301,
                "title": "easy-solution-c-prefix-sum-unordered-map-best-approch",
                "content": "# prefix sum /row wise.. unordered_map ||c++||easy approch\\n**minimizing the brick crossing == maximinzing the split crossing **\\n*best approch -> store prefix sum value frequency in map  then maximize split crossing*\\n```\\n\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n     int n= wall.size();\\n        // map for store prefix sum frequency \\n        \\n        unordered_map<int,int>mp;\\n        \\n        int maxi=0;// store maximum freq. value\\n        for(int i=0;i<n;i++){\\n            int ps=0;// prefix sum\\n            \\n            \\n            for(int j=0;j<wall[i].size()-1;j++){\\n                int val= wall[i][j];// value\\n                ps+=val;// sum\\n                mp[ps]++;// store freq.\\n                maxi= max(maxi,mp[ps]);// updaupdate \\n            }\\n        }\\n        return n-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n     int n= wall.size();\\n        // map for store prefix sum frequency \\n        \\n        unordered_map<int,int>mp;\\n        \\n        int maxi=0;// store maximum freq. value\\n        for(int i=0;i<n;i++){\\n            int ps=0;// prefix sum\\n            \\n            \\n            for(int j=0;j<wall[i].size()-1;j++){\\n                int val= wall[i][j];// value\\n                ps+=val;// sum\\n                mp[ps]++;// store freq.\\n                maxi= max(maxi,mp[ps]);// updaupdate \\n            }\\n        }\\n        return n-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625137,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nint leastBricks(vector<vector<int>>& wall) {\\n        \\n        map<int,int> m;\\n        for(auto arr:wall)\\n        {\\n            int sum=0;\\n            for(int j=0;j<arr.size();j++)  //har row ka prefix sum nikalte rho \\n            {\\n                sum+=arr[j];\\n                \\n//bas total sum mat dalo map me kuki vo sbka hi same hai vaha se hum cross hi nahi kr skte\\n                if(j!=arr.size()-1)  \\n                m[sum]++;\\n            }\\n        }\\n        int maxo=0;\\n        for(auto i:m)\\n             maxo=max(maxo,i.second);  \\n        \\n        \\n        //jo prefix sum max aara bht rows me vaha se jayege agar k rows me 5 prefix sum aa rha aur 8 rows hai to hum 5 value se jayege k rows me hum bricks ko nahi katege baaki bchi hui rows me bricks ko katte hue jayege (8-k)  \\n        \\n        return wall.size()-maxo;\\n    }",
                "solutionTags": [],
                "code": "```\\nint leastBricks(vector<vector<int>>& wall) {\\n        \\n        map<int,int> m;\\n        for(auto arr:wall)\\n        {\\n            int sum=0;\\n            for(int j=0;j<arr.size();j++)  //har row ka prefix sum nikalte rho \\n            {\\n                sum+=arr[j];\\n                \\n//bas total sum mat dalo map me kuki vo sbka hi same hai vaha se hum cross hi nahi kr skte\\n                if(j!=arr.size()-1)  \\n                m[sum]++;\\n            }\\n        }\\n        int maxo=0;\\n        for(auto i:m)\\n             maxo=max(maxo,i.second);  \\n        \\n        \\n        //jo prefix sum max aara bht rows me vaha se jayege agar k rows me 5 prefix sum aa rha aur 8 rows hai to hum 5 value se jayege k rows me hum bricks ko nahi katege baaki bchi hui rows me bricks ko katte hue jayege (8-k)  \\n        \\n        return wall.size()-maxo;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2565412,
                "title": "java-simple-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> partitionCount = new HashMap<>();\\n        int rowLen=wall.size();\\n        int cols = 0;\\n        int max = 0;\\n        for(int brick: wall.get(0))\\n            cols += brick;\\n        for(List<Integer> row: wall){\\n            int partition = 0;\\n            for(int brick: row){\\n                partition += brick;\\n                if(partition < cols){\\n                    partitionCount.put(partition, partitionCount.getOrDefault(partition, 0)+1);\\n                    max = Math.max(max, partitionCount.get(partition));\\n                }\\n            }\\n        }\\n        return rowLen-max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> partitionCount = new HashMap<>();\\n        int rowLen=wall.size();\\n        int cols = 0;\\n        int max = 0;\\n        for(int brick: wall.get(0))\\n            cols += brick;\\n        for(List<Integer> row: wall){\\n            int partition = 0;\\n            for(int brick: row){\\n                partition += brick;\\n                if(partition < cols){\\n                    partitionCount.put(partition, partitionCount.getOrDefault(partition, 0)+1);\\n                    max = Math.max(max, partitionCount.get(partition));\\n                }\\n            }\\n        }\\n        return rowLen-max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459694,
                "title": "o-nm-time-o-nm-space-clear-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/0073661a-0e06-4ab2-b37f-e0890a9d193f_1661096703.526322.png)\\n\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        \"\"\" O(NM)TS \"\"\"\\n        cnt = collections.Counter(itertools.chain.from_iterable((itertools.accumulate(row[:-1]) for row in wall)))\\n        return len(wall) - max(cnt.values(), default=0)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/0073661a-0e06-4ab2-b37f-e0890a9d193f_1661096703.526322.png)\\n\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        \"\"\" O(NM)TS \"\"\"\\n        cnt = collections.Counter(itertools.chain.from_iterable((itertools.accumulate(row[:-1]) for row in wall)))\\n        return len(wall) - max(cnt.values(), default=0)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2331059,
                "title": "c-easiest-one-pass-solution-hashmap",
                "content": "```\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> m;\\n        int n=wall.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0 , l = wall[i].size();\\n            for(int j=0;j<l-1;j++)\\n            {\\n                sum+=wall[i][j];\\n                ans=max(ans,++m[sum]);\\n            }\\n        }\\n        return n-ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> m;\\n        int n=wall.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0 , l = wall[i].size();\\n            for(int j=0;j<l-1;j++)\\n            {\\n                sum+=wall[i][j];\\n                ans=max(ans,++m[sum]);\\n            }\\n        }\\n        return n-ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2118774,
                "title": "c-short-and-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //use hashmap\\n    //to minimize to number of crossed bricks- we need to maximize the passing through splits. So lets count the max number of splits I can pass through if i draw a line vertically at any coloumn along the given rows.\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>mp;\\n        int maxi=0;\\n        for(auto row:wall)\\n        {\\n            //prefix sum of cols used for finding splits\\n            int presum=0;\\n            for(int i = 0; i < size(row) - 1; i++)\\n            {\\n                presum+=row[i];\\n                mp[presum]++;\\n                maxi=max(maxi,mp[presum]);\\n            }\\n        }\\n        //finally we found a col through which if we pass a vertical line , it will pass through max number of splits in all rows\\n        //now final answer=number of rows(bricks)-number of splits line passes through\\n        return wall.size()-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //use hashmap\\n    //to minimize to number of crossed bricks- we need to maximize the passing through splits. So lets count the max number of splits I can pass through if i draw a line vertically at any coloumn along the given rows.\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>mp;\\n        int maxi=0;\\n        for(auto row:wall)\\n        {\\n            //prefix sum of cols used for finding splits\\n            int presum=0;\\n            for(int i = 0; i < size(row) - 1; i++)\\n            {\\n                presum+=row[i];\\n                mp[presum]++;\\n                maxi=max(maxi,mp[presum]);\\n            }\\n        }\\n        //finally we found a col through which if we pass a vertical line , it will pass through max number of splits in all rows\\n        //now final answer=number of rows(bricks)-number of splits line passes through\\n        return wall.size()-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048045,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        hmap = defaultdict(int)\\n        length = None   \\n        \\n        for bricks in wall:\\n            count = 0\\n            for brick in bricks:\\n                count += brick\\n                hmap[count] += 1\\n            length = count\\n        \\n        minVal = len(wall)\\n        for key in hmap.keys():\\n            if key == length:\\n                continue\\n            minVal = min(minVal, len(wall) - hmap[key])\\n            \\n        return minVal",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        hmap = defaultdict(int)\\n        length = None   \\n        \\n        for bricks in wall:\\n            count = 0\\n            for brick in bricks:\\n                count += brick\\n                hmap[count] += 1\\n            length = count\\n        \\n        minVal = len(wall)\\n        for key in hmap.keys():\\n            if key == length:\\n                continue\\n            minVal = min(minVal, len(wall) - hmap[key])\\n            \\n        return minVal",
                "codeTag": "Java"
            },
            {
                "id": 2022981,
                "title": "c-fully-explained-hashmap-approach",
                "content": "```\\n/*\\nexplanation:\\n\\n-> here we use a prefix sum method to find the gap in each row \\n  i.e in [1,2,2,1] -> the gaps are present in 1,3(1+2),5(3+2) postions\\n  and last gap(ending col line) will not be considered acc. to question.\\n \\n \\n-> now similarly we will find the gaps for all rows from 1 to n.\\n\\n-> the gap that is most frequent will lead to less bricks to be cut.\\n\\n-> to find the freq. of gaps,we will use hashmap or unordered map and \\n   n-  max_gaps will give the result.\\n*/\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n     unordered_map<int,int>gap;\\n     int n=wall.size()  ;\\n      \\n     for(int row=0;row<n;++row){\\n         int sum=0; //to count the prefix sum in each row\\n         for(int col=0;col<wall[row].size()-1;++col){\\n             sum+=wall[row][col];\\n             ++gap[sum]; //frequency of the gap is increased.\\n         } }\\n        \\n      int res=n;\\nfor(auto it:gap) res=min(res,n-it.second); //min brick => n-max_gap.\\n      return res;  }};\\n```\\n//if liked please upvote.  :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\nexplanation:\\n\\n-> here we use a prefix sum method to find the gap in each row \\n  i.e in [1,2,2,1] -> the gaps are present in 1,3(1+2),5(3+2) postions\\n  and last gap(ending col line) will not be considered acc. to question.\\n \\n \\n-> now similarly we will find the gaps for all rows from 1 to n.\\n\\n-> the gap that is most frequent will lead to less bricks to be cut.\\n\\n-> to find the freq. of gaps,we will use hashmap or unordered map and \\n   n-  max_gaps will give the result.\\n*/\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n     unordered_map<int,int>gap;\\n     int n=wall.size()  ;\\n      \\n     for(int row=0;row<n;++row){\\n         int sum=0; //to count the prefix sum in each row\\n         for(int col=0;col<wall[row].size()-1;++col){\\n             sum+=wall[row][col];\\n             ++gap[sum]; //frequency of the gap is increased.\\n         } }\\n        \\n      int res=n;\\nfor(auto it:gap) res=min(res,n-it.second); //min brick => n-max_gap.\\n      return res;  }};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736767,
                "title": "python-easy-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        count = defaultdict(int)\\n        tot = len(wall)\\n        if tot == 1 and len(wall[0]) > 1:\\n            return 0\\n        elif tot == 1 and len(wall[0]) == 1:\\n            return 1\\n        \\n        for w in wall:\\n            s = 0 \\n            for i in range(len(w)):\\n                s += w[i]\\n                count[s] += 1\\n            count[s] -= 1\\n\\n        return tot - max(count.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        count = defaultdict(int)\\n        tot = len(wall)\\n        if tot == 1 and len(wall[0]) > 1:\\n            return 0\\n        elif tot == 1 and len(wall[0]) == 1:\\n            return 1\\n        \\n        for w in wall:\\n            s = 0 \\n            for i in range(len(w)):\\n                s += w[i]\\n                count[s] += 1\\n            count[s] -= 1\\n\\n        return tot - max(count.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575674,
                "title": "c-using-map",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> m;\\n        int max_sum;\\n        for(int i=0;i<wall.size();++i){\\n            int sum=0;\\n            for(int j=0;j<wall[i].size();++j){\\n                sum+=wall[i][j];\\n                m[sum]++;\\n            }\\n            max_sum=sum;\\n        }\\n        int ans=INT_MAX;\\n        int row=wall.size();\\n        unordered_map<int,int>:: iterator it=m.begin();\\n        while(it!=m.end()){\\n            if(it->first!=max_sum)\\n                ans=min(ans,(row-it->second));\\n            it++;\\n        }\\n        if(ans==INT_MAX)return wall.size();\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> m;\\n        int max_sum;\\n        for(int i=0;i<wall.size();++i){\\n            int sum=0;\\n            for(int j=0;j<wall[i].size();++j){\\n                sum+=wall[i][j];\\n                m[sum]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1556605,
                "title": "prefix-sum-hashmap-c",
                "content": "```\\n    unordered_map<int, int> mp;\\n    int res = INT_MAX;\\n    \\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        for(int i = 0 ; i < wall.size() ; i++) \\n            for(int j = 0 ; j < wall[i].size() ; j++) {\\n                \\n                wall[i][j] += j == 0? 0 : wall[i][j - 1];\\n\\n                if(j != wall[i].size() - 1) {\\n                    mp[wall[i][j]]++; \\n                    res = min(res, (int)wall.size() - mp[wall[i][j]]);\\n                } \\n            }\\n    \\n        return res == INT_MAX? (int) wall.size() : res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    unordered_map<int, int> mp;\\n    int res = INT_MAX;\\n    \\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        for(int i = 0 ; i < wall.size() ; i++) \\n            for(int j = 0 ; j < wall[i].size() ; j++) {\\n                \\n                wall[i][j] += j == 0? 0 : wall[i][j - 1];\\n\\n                if(j != wall[i].size() - 1) {\\n                    mp[wall[i][j]]++; \\n                    res = min(res, (int)wall.size() - mp[wall[i][j]]);\\n                } \\n            }\\n    \\n        return res == INT_MAX? (int) wall.size() : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550207,
                "title": "simple-java-solution-using-hashmap-with-explanation",
                "content": "class Solution {\\n\\n    public int leastBricks(List<List<Integer>> wall) {\\n        \\n\\t\\tint maxCount = 0; //maximum bricks ending at a single boundary\\n\\t\\t\\n        Map<Integer , Integer> map = new HashMap<>();//to store count of no. of bricks ending at same boundary\\n        \\n\\t\\tfor(List<Integer> row : wall){\\n\\t\\t\\n            int boundary = 0; //boundary is cumulative \\n\\t\\t\\t\\n            for(int brick = 0 ; brick < row.size() - 1 ; brick++){          //leaving last brick as we can\\'t consider last edge\\n\\t\\t\\t\\n                boundary += row.get(brick);                                 //finding edge of each brick\\n                map.put(boundary , map.getOrDefault(boundary , 0) + 1);     //updating edge count in map\\n                maxCount = Math.max(maxCount , map.get(boundary));          //updating maxCount if possible\\n\\t\\t\\t\\t\\n            }\\n        }\\n        return wall.size() - maxCount; //minimum number of bricks crossed\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int leastBricks(List<List<Integer>> wall) {\\n        \\n\\t\\tint maxCount = 0; //maximum bricks ending at a single boundary\\n\\t\\t\\n        Map<Integer , Integer> map = new HashMap<>();//to store count of no. of bricks ending at same boundary\\n        \\n\\t\\tfor(List<Integer> row : wall){\\n\\t\\t\\n            int boundary = 0; //boundary is cumulative \\n\\t\\t\\t\\n            for(int brick = 0 ; brick < row.size() - 1 ; brick++){          //leaving last brick as we can\\'t consider last edge\\n\\t\\t\\t\\n                boundary += row.get(brick);                                 //finding edge of each brick\\n                map.put(boundary , map.getOrDefault(boundary , 0) + 1);     //updating edge count in map\\n                maxCount = Math.max(maxCount , map.get(boundary));          //updating maxCount if possible\\n\\t\\t\\t\\t\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1529326,
                "title": "using-hashmap-easy-to-understand-commented-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        //number of bricks crossed by line + number of brick edges(end or start position of brick) crossed by line = wall.size()\\n        //problem is reduced to : max number of brick edges on a vertical line\\n        //vertcial line is represented by pos from y axis\\n        \\n        //it will keep count of number of brick edges corresponding to each position\\n        unordered_map<int,int>map;\\n        int pos , max_val=0;\\n        \\n        //treversing wall level by level\\n        for(int i=0 ; i<wall.size();i++){\\n            //for each level ,process all brick at that level\\n            //we are not taking last brick of each level\\n            \\n            pos=0; //it keep tracks of position where brick edge is present at each level\\n            for(int j=0 ;j<wall[i].size()-1 ; j++){\\n                pos+= wall[i][j];\\n                \\n                //incrementing brick edges count at that position\\n                map[pos]++;\\n                \\n                max_val = max(max_val , map[pos]);\\n            }\\n        }\\n        \\n        //we have to return minimum no of bricks crossed by line\\n        return wall.size()-max_val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        //number of bricks crossed by line + number of brick edges(end or start position of brick) crossed by line = wall.size()\\n        //problem is reduced to : max number of brick edges on a vertical line\\n        //vertcial line is represented by pos from y axis\\n        \\n        //it will keep count of number of brick edges corresponding to each position\\n        unordered_map<int,int>map;\\n        int pos , max_val=0;\\n        \\n        //treversing wall level by level\\n        for(int i=0 ; i<wall.size();i++){\\n            //for each level ,process all brick at that level\\n            //we are not taking last brick of each level\\n            \\n            pos=0; //it keep tracks of position where brick edge is present at each level\\n            for(int j=0 ;j<wall[i].size()-1 ; j++){\\n                pos+= wall[i][j];\\n                \\n                //incrementing brick edges count at that position\\n                map[pos]++;\\n                \\n                max_val = max(max_val , map[pos]);\\n            }\\n        }\\n        \\n        //we have to return minimum no of bricks crossed by line\\n        return wall.size()-max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466102,
                "title": "java-easy-map",
                "content": "```\\n/*Key Idea : Find maximum number of gaps so that you can minimize the number of crossing through bricks*/\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        \\n        Map<Integer,Integer> mp = new HashMap<>();\\n        for(List<Integer> brick : wall){\\n            int pos = 0 ; //position of gap in every row\\n          for(int i = 0; i < brick.size() - 1; i++){\\n             int p = brick.get(i);\\n             pos = pos + p;\\n            //Mark the position for the gap and maintain the freq of a particular gap\\n             mp.put(pos,mp.getOrDefault(pos,0) + 1);\\n          }\\n        }\\n       int max = 0 ; //maximum number of gaps\\n      \\n       for(int key : mp.keySet()){\\n          max = Math.max(max,mp.get(key));\\n       }\\n      // answer will be the number of rows - the max number of gaps for a vertical line (As your vertical line will pass through maximum number of gaps thus reduces the number of bricks)\\n      return wall.size() - max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*Key Idea : Find maximum number of gaps so that you can minimize the number of crossing through bricks*/\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        \\n        Map<Integer,Integer> mp = new HashMap<>();\\n        for(List<Integer> brick : wall){\\n            int pos = 0 ; //position of gap in every row\\n          for(int i = 0; i < brick.size() - 1; i++){\\n             int p = brick.get(i);\\n             pos = pos + p;\\n            //Mark the position for the gap and maintain the freq of a particular gap\\n             mp.put(pos,mp.getOrDefault(pos,0) + 1);\\n          }\\n        }\\n       int max = 0 ; //maximum number of gaps\\n      \\n       for(int key : mp.keySet()){\\n          max = Math.max(max,mp.get(key));\\n       }\\n      // answer will be the number of rows - the max number of gaps for a vertical line (As your vertical line will pass through maximum number of gaps thus reduces the number of bricks)\\n      return wall.size() - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373084,
                "title": "c-simple-solution-using-maps",
                "content": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        unordered_map<int, int> m;\\n        int n = wall.size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int tmp = 0;\\n            for(int j = 0; j < wall[i].size() - 1; j++)\\n                tmp += wall[i][j], m[tmp]++;\\n        }    \\n        \\n        int ans = n;\\n        for(auto i : m)\\n            ans = min(ans, n - i.second);\\n            \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        unordered_map<int, int> m;\\n        int n = wall.size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int tmp = 0;\\n            for(int j = 0; j < wall[i].size() - 1; j++)\\n                tmp += wall[i][j], m[tmp]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1368152,
                "title": "easy-to-understand-c-8-line-solution-using-map",
                "content": "Do upvote if you like it\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int,int> v;\\n        for(int i=0;i<wall.size();i++){\\n            for(int sum=0, j=0; j<wall[i].size()-1; j++){\\n                sum+=wall[i][j];\\n                v[sum]++;\\n            }\\n        }\\n        int mx=0;\\n        for(auto z:v)mx= max(mx,z.second);\\n    return wall.size()-mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int,int> v;\\n        for(int i=0;i<wall.size();i++){\\n            for(int sum=0, j=0; j<wall[i].size()-1; j++){\\n                sum+=wall[i][j];\\n                v[sum]++;\\n            }\\n        }\\n        int mx=0;\\n        for(auto z:v)mx= max(mx,z.second);\\n    return wall.size()-mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218825,
                "title": "c-o-n-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> mp;\\n        for(auto& a: wall){\\n            for(int i = 0; i < a.size()-1; i++){\\n                mp[a[i]] += 1;\\n                a[i+1] += a[i];\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(auto a: mp){\\n            ans = max(ans, a.second);\\n        }\\n        if(ans == INT_MIN) return wall.size();\\n        return wall.size() - ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> mp;\\n        for(auto& a: wall){\\n            for(int i = 0; i < a.size()-1; i++){\\n                mp[a[i]] += 1;\\n                a[i+1] += a[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1172499,
                "title": "kotlin-100-in-execution-time-and-space-easy-peasy-explained",
                "content": "The key to this problem is to keep track of  how many bricks start and end at each particular position.  A hash map is the perfect data structure for this.  And, you only need to go through each list once, leaving out the beginning (0), and the end, which is the sum of all the lengths.  I set \"start\" to 0 at the beginning of each list, and add the length of each brick, which is where the current one ends and the next one starts.  At this position, increment the count in the hash map.  I decided to keep track of the max count as I went, and that easily beat the time of all the other Kotlin solutions.  One easy shortcut is to check if the wall is only one brick high (has only one list).  In that case, if you have only one brick, the answer is 1, if there is more than one, the answer is 0.\\n\\nWhen you\\'ve found the max number of bricks ending and starting at a position, you subtract that from the height of the wall (number of lists in the list), and you have your answer.\\n\\nHere\\'s the code:\\n```\\n\\tvar map = HashMap<Int, Int>()\\n\\tif (wall.size == 1) {\\n\\t\\tif (wall.get(0).size == 1) {\\n\\t\\t\\treturn 1\\n\\t\\t} else {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t}\\n\\tvar start : Int\\n\\tvar count : Int\\n\\tvar max = 0\\n\\tfor (list in wall) {\\n\\t\\tstart = 0\\n\\t\\tfor (x in 0..list.lastIndex - 1) {\\n\\t\\t\\tstart += list.get(x)\\n\\t\\t\\tcount = map.getOrDefault(start, 0) + 1\\n\\t\\t\\tif (count > max) {\\n\\t\\t\\t\\tmax = count\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(start, count)\\n\\t\\t}\\n\\t}\\n\\treturn wall.size - max\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n\\tvar map = HashMap<Int, Int>()\\n\\tif (wall.size == 1) {\\n\\t\\tif (wall.get(0).size == 1) {\\n\\t\\t\\treturn 1\\n\\t\\t} else {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t}\\n\\tvar start : Int\\n\\tvar count : Int\\n\\tvar max = 0\\n\\tfor (list in wall) {\\n\\t\\tstart = 0\\n\\t\\tfor (x in 0..list.lastIndex - 1) {\\n\\t\\t\\tstart += list.get(x)\\n\\t\\t\\tcount = map.getOrDefault(start, 0) + 1\\n\\t\\t\\tif (count > max) {\\n\\t\\t\\t\\tmax = count\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(start, count)\\n\\t\\t}\\n\\t}\\n\\treturn wall.size - max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172472,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        dict={}\\n        for row in wall:\\n            start=0\\n            for bricks in row[:-1]:\\n                start+=bricks\\n                if start in dict:\\n                    dict[start]+=1\\n                else:\\n                    dict[start]=1\\n        try:\\n            m=max(list(dict.values()))\\n        except:\\n            return len(wall)\\n        return len(wall)-m",
                "solutionTags": [],
                "code": "class Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        dict={}",
                "codeTag": "Java"
            },
            {
                "id": 1172325,
                "title": "python-easy-understanding-omn-solution",
                "content": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        table = dict()\\n        for row in wall:\\n            tmp_sum = 0\\n            for item in row:\\n                tmp_sum += item\\n                if tmp_sum not in table:\\n                    table[tmp_sum] = 1\\n                else:\\n                    table[tmp_sum] += 1\\n        output = len(wall)\\n        for key in table:\\n            if len(wall) - table[key] < output and key != sum(wall[0]):\\n                output = len(wall) - table[key]\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        table = dict()\\n        for row in wall:\\n            tmp_sum = 0\\n            for item in row:\\n                tmp_sum += item\\n                if tmp_sum not in table:\\n                    table[tmp_sum] = 1\\n                else:\\n                    table[tmp_sum] += 1\\n        output = len(wall)\\n        for key in table:\\n            if len(wall) - table[key] < output and key != sum(wall[0]):\\n                output = len(wall) - table[key]\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171818,
                "title": "aptitude-based-approach-no-hashmap-used-java-code",
                "content": "A lot of people have posted solution to this problem using Map. But to be honest, I treated this problem as an aptitude problem rather than a coding question.\\nI felt like , \"Okay!! , how would I solve this problem in real life if I encountered this situation\" and Bingo!!!! I solved it in a way that involves none of the fancy coding knowledge.\\n\\nOkay, Lets see the intuition behind solving this problem:\\n1. So, in every row, after placing the first brick of the repective sizes in each row, HOW to ascertain the least number of bricks crossing vertical line??\\n\\n2. Here an important observation is that the  **the number of the minimum length of combined bricks in each row** gives us the maximum number of bricks through which a line can be drawn without crossing. This gives is the minimum number of bricks through which a line can be drawn crossing them. **This is the determinant of the problem.** \\n\\n3. This is true only if we first try to fill the rows which have the minimum length after placing bricks in each row.\\n\\n4. But why **Minimum** ???? Because with each row having bricks till a minimum length, the minimum number of bricks through which a line can be drawn can be determined. Lets take an example:\\nConsider a brick length of 1 unit as #.\\n1st row :  ################################\\n2nd row:  #################\\n3rd row:  #################\\n4th row:  #######################################\\n5th row:  #################\\n\\nHere 2nd, 3rd and 5th are minimum. So, the Number of the minimum length of combined bricks in each row=3.\\nSo the minimum number of bricks crossing the line would be= \\nNumber of rows-Number of the minimum length of combined bricks in each row=5-3=2\\n\\n**Here we took the help of minimum length because if we consider other lengths, then we are never sure whether the row having bricks of length shorter than that will cross the vertical line or not if a line was drawn from larger length edge.**\\nAnd BINGO!!! It hits you!!!\\n\\n3. Now, the thing that makes us think that the solution is DIFFICULT is that if a Map is not used and the above intuition is used, then how to traverse the given list???\\n\\n4. To answer this Qs, Read point number 3 carefully.\\n\\n5. We keep track of the length of bricks in each row in an Array **value[]** and the last index whose size that has been taken into value array in array **index[]**\\n\\nJava Code:\\n```\\npublic int leastBricks(List<List<Integer>> wall) {\\n\\n        //min is the required answer...\\n        int min=Integer.MAX_VALUE;\\n        int row=wall.size();\\n        int col=0;\\n        for(int i=0;i<wall.get(0).size();i++){\\n            col=col+wall.get(0).get(i);\\n        }\\n\\n\\t\\t//Contains the last index of each row that has been added to value\\n        int index[]=new int[row];\\n\\t\\t\\n\\t\\t//Contains the length of bricks in each row\\n        int value[]=new int[row];\\n\\t\\t\\n\\t\\t//minimum brick length in each row\\n        int minimumTillNow=Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t//count the number of minimum brick length in each row\\n        int count=0;\\n\\t\\t\\n\\t\\t//Adding first brick in each row\\n        for(int i=0;i<row;i++){\\n            int x=wall.get(i).get(0);\\n            value[i]=x;\\n            if(minimumTillNow>x){\\n                count=1;\\n                minimumTillNow=x;\\n            }\\n            else if(minimumTillNow==x){\\n                count++;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Base case [[1], [1], [1]]\\n\\t\\t//In this case, the line will cross bricks=number of rows=row\\n        if(minimumTillNow==col){\\n            return row;\\n        }\\n        min=Math.min(min,row-count);\\n        \\n\\t\\t//Loop until all the bricks are added to the arangement\\n        while(true){\\n            count=0;\\n            int tempMin=Integer.MAX_VALUE;\\n\\t\\t\\t\\n\\t\\t\\t//In this loop, we use the Point 3 i.e\\n\\t\\t   //we try to fill up rows with minimum length bricks first\\n            for(int i=0;i<row;i++){\\n                if(value[i]==minimumTillNow&&index[i]<(wall.get(i).size()-1)){\\n                    value[i]=value[i]+wall.get(i).get(index[i]+1);\\n                    index[i]++;\\n                }\\n                if(tempMin>value[i]){\\n                count=1;\\n                tempMin=value[i];\\n                }\\n                else if(tempMin==value[i]){\\n                    count++;\\n                }\\n                \\n            }\\n            minimumTillNow=tempMin;\\n\\t\\t\\t\\n\\t\\t\\t//All bricks have been added to the arrangement\\n\\t\\t\\t//So, minimumTillNow will become equal to the number of columns\\n\\t\\t\\t//So, this is the right boundary case, Break the loop here.\\n            if(minimumTillNow==col){\\n                break;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//This is obvious\\n            min=Math.min(min,row-count);\\n        }\\n        return min;\\n    }\\n```\\n*Time Complexity:  O(RowXCol)\\nSpace Complexity: O(Row)  \\n\\nI know the explanation is a bit lengthy. Its because there are a lot of things that people understand but they fail to apply those small things to solve this problem.\\nI have tried my best to solve this problem. Still any suggestions or doubts are welcome.",
                "solutionTags": [],
                "code": "```\\npublic int leastBricks(List<List<Integer>> wall) {\\n\\n        //min is the required answer...\\n        int min=Integer.MAX_VALUE;\\n        int row=wall.size();\\n        int col=0;\\n        for(int i=0;i<wall.get(0).size();i++){\\n            col=col+wall.get(0).get(i);\\n        }\\n\\n\\t\\t//Contains the last index of each row that has been added to value\\n        int index[]=new int[row];\\n\\t\\t\\n\\t\\t//Contains the length of bricks in each row\\n        int value[]=new int[row];\\n\\t\\t\\n\\t\\t//minimum brick length in each row\\n        int minimumTillNow=Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t//count the number of minimum brick length in each row\\n        int count=0;\\n\\t\\t\\n\\t\\t//Adding first brick in each row\\n        for(int i=0;i<row;i++){\\n            int x=wall.get(i).get(0);\\n            value[i]=x;\\n            if(minimumTillNow>x){\\n                count=1;\\n                minimumTillNow=x;\\n            }\\n            else if(minimumTillNow==x){\\n                count++;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Base case [[1], [1], [1]]\\n\\t\\t//In this case, the line will cross bricks=number of rows=row\\n        if(minimumTillNow==col){\\n            return row;\\n        }\\n        min=Math.min(min,row-count);\\n        \\n\\t\\t//Loop until all the bricks are added to the arangement\\n        while(true){\\n            count=0;\\n            int tempMin=Integer.MAX_VALUE;\\n\\t\\t\\t\\n\\t\\t\\t//In this loop, we use the Point 3 i.e\\n\\t\\t   //we try to fill up rows with minimum length bricks first\\n            for(int i=0;i<row;i++){\\n                if(value[i]==minimumTillNow&&index[i]<(wall.get(i).size()-1)){\\n                    value[i]=value[i]+wall.get(i).get(index[i]+1);\\n                    index[i]++;\\n                }\\n                if(tempMin>value[i]){\\n                count=1;\\n                tempMin=value[i];\\n                }\\n                else if(tempMin==value[i]){\\n                    count++;\\n                }\\n                \\n            }\\n            minimumTillNow=tempMin;\\n\\t\\t\\t\\n\\t\\t\\t//All bricks have been added to the arrangement\\n\\t\\t\\t//So, minimumTillNow will become equal to the number of columns\\n\\t\\t\\t//So, this is the right boundary case, Break the loop here.\\n            if(minimumTillNow==col){\\n                break;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//This is obvious\\n            min=Math.min(min,row-count);\\n        }\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171812,
                "title": "a-few-solutions",
                "content": "Accumulate each `j`<sup>th</sup> column\\'s asbolute offset for each `i`<sup>th</sup> row of the input `A`.  Then use the absolute offset `A[i][j]` as the key of a map `m` used as a counter to determine the maximum absolute offset count in common with each potential candidate \"wall\".  The `last` absolute offset of the right-most `j`<sup>th</sup> column is *not* a valid wall candidate (per the constraints of the problem statement, assuming the bricks align uniformally ending at the same `last` absolute offset at the `j`<sup>th</sup> column), so the `last` absolute offset is erased from the map `m`.  Then, if there exists a valid wall (ie. if the map `m` is not empty after erasing `last`), then return the best valid wall as the amount of rows `N` minus the maximum `j`<sup>th</sup> column\\'s asbolute offset count (ie. there is no penalty for each `j`<sup>th</sup> column which aligns properly with the \"wall\"), otherwise if there is no valid \"wall\" then return `N` since all `j`<sup>th</sup> column\\'s asbolute offset are the same value (for example, the input `A = [[1],[1],[1]]` has no valid \"wall\").\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun leastBricks(input: List<List<Int>>): Int {\\n        var N = input.size\\n        var m = mutableMapOf<Int, Int>()\\n        var A = Array(N) { mutableListOf<Int>() }\\n        for (i in 0 until N) {\\n            for (j in 0 until input[i].size) {\\n                A[i].add(input[i][j] + if (0 < A[i].size) A[i].last() else 0)  // \\uD83D\\uDD11 absolute offset\\n                m[A[i].last()] = 1 + m.getOrDefault(A[i].last(), 0)            // \\uD83D\\uDDFA absolute offset count\\n            }\\n        }\\n        var last = m.keys.max()!!; m.remove(last)                              // \\uD83D\\uDEAB last absolute offset is invalid\\n        var best = m.values.max()\\n        return N - (best ?: 0)                                                 // \\uD83C\\uDFAF N rows minus max same absolute offset count\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet leastBricks = (A, m = new Map()) => {\\n    let N = A.length;\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0; j < A[i].length; ++j)\\n            A[i][j] += 0 < j ? A[i][j - 1] : 0,                 // \\uD83D\\uDD11 absolute offset\\n            m.set(A[i][j], 1 + (m.get(A[i][j]) || 0));          // \\uD83D\\uDDFA absolute offset count\\n    let last = Math.max(...[...m].map(([key, _]) => key));\\n    m.delete(last);                                             // \\uD83D\\uDEAB last absolute offset is invalid\\n    let best = m.size ? Math.max(...[...m].map(([_, cnt]) => cnt)) : null;\\n    return N - (best || 0);                                     // \\uD83C\\uDFAF N rows minus max same absolute offset count\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def leastBricks(self, A: List[List[int]]) -> int:\\n        N = len(A)\\n        m = {}\\n        for i in range(N):\\n            for j in range(0, len(A[i])):\\n                A[i][j] += A[i][j - 1] if 0 < j else 0              # \\uD83D\\uDD11 absolute offset\\n                m[A[i][j]] = 1 + m[A[i][j]] if A[i][j] in m else 1  # \\uD83D\\uDDFA absolute offset count\\n        last = max(m.keys()); del m[last]                           # \\uD83D\\uDEAB last absolute offset is invalid\\n        return N - max(m.values()) if len(m) else N                 # \\uD83C\\uDFAF N rows minus max same absolute offset count\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, int>;\\n    int leastBricks(VVI& A, Map m = {}, int last = -1, int best = -1) {\\n        int N = A.size();\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto j{ 0 }; j < A[i].size(); ++j)\\n                A[i][j] += 0 < j ? A[i][j - 1] : 0,  // \\uD83D\\uDD11 absolute offset\\n                ++m[A[i][j]];                        // \\uD83D\\uDDFA absolute offset count\\n        for (auto [key, _]: m)\\n            last = max(last, key);\\n        m.erase(last);                               // \\uD83D\\uDEAB last absolute offset is invalid\\n        for (auto [_, cnt]: m)\\n            best = max(best, cnt);\\n        return !m.empty() ? N - best : N;            // \\uD83C\\uDFAF N rows minus max same absolute offset count\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun leastBricks(input: List<List<Int>>): Int {\\n        var N = input.size\\n        var m = mutableMapOf<Int, Int>()\\n        var A = Array(N) { mutableListOf<Int>() }\\n        for (i in 0 until N) {\\n            for (j in 0 until input[i].size) {\\n                A[i].add(input[i][j] + if (0 < A[i].size) A[i].last() else 0)  // \\uD83D\\uDD11 absolute offset\\n                m[A[i].last()] = 1 + m.getOrDefault(A[i].last(), 0)            // \\uD83D\\uDDFA absolute offset count\\n            }\\n        }\\n        var last = m.keys.max()!!; m.remove(last)                              // \\uD83D\\uDEAB last absolute offset is invalid\\n        var best = m.values.max()\\n        return N - (best ?: 0)                                                 // \\uD83C\\uDFAF N rows minus max same absolute offset count\\n    }\\n}\\n```\n```\\nlet leastBricks = (A, m = new Map()) => {\\n    let N = A.length;\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0; j < A[i].length; ++j)\\n            A[i][j] += 0 < j ? A[i][j - 1] : 0,                 // \\uD83D\\uDD11 absolute offset\\n            m.set(A[i][j], 1 + (m.get(A[i][j]) || 0));          // \\uD83D\\uDDFA absolute offset count\\n    let last = Math.max(...[...m].map(([key, _]) => key));\\n    m.delete(last);                                             // \\uD83D\\uDEAB last absolute offset is invalid\\n    let best = m.size ? Math.max(...[...m].map(([_, cnt]) => cnt)) : null;\\n    return N - (best || 0);                                     // \\uD83C\\uDFAF N rows minus max same absolute offset count\\n};\\n```\n```\\nclass Solution:\\n    def leastBricks(self, A: List[List[int]]) -> int:\\n        N = len(A)\\n        m = {}\\n        for i in range(N):\\n            for j in range(0, len(A[i])):\\n                A[i][j] += A[i][j - 1] if 0 < j else 0              # \\uD83D\\uDD11 absolute offset\\n                m[A[i][j]] = 1 + m[A[i][j]] if A[i][j] in m else 1  # \\uD83D\\uDDFA absolute offset count\\n        last = max(m.keys()); del m[last]                           # \\uD83D\\uDEAB last absolute offset is invalid\\n        return N - max(m.values()) if len(m) else N                 # \\uD83C\\uDFAF N rows minus max same absolute offset count\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, int>;\\n    int leastBricks(VVI& A, Map m = {}, int last = -1, int best = -1) {\\n        int N = A.size();\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto j{ 0 }; j < A[i].size(); ++j)\\n                A[i][j] += 0 < j ? A[i][j - 1] : 0,  // \\uD83D\\uDD11 absolute offset\\n                ++m[A[i][j]];                        // \\uD83D\\uDDFA absolute offset count\\n        for (auto [key, _]: m)\\n            last = max(last, key);\\n        m.erase(last);                               // \\uD83D\\uDEAB last absolute offset is invalid\\n        for (auto [_, cnt]: m)\\n            best = max(best, cnt);\\n        return !m.empty() ? N - best : N;            // \\uD83C\\uDFAF N rows minus max same absolute offset count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171789,
                "title": "python-3-counter",
                "content": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        counter: Counter[int] = collections.Counter()\\n        for row in wall:\\n            width: int = 0\\n            for brick in row[:-1]:\\n                width += brick\\n                counter[width] += 1\\n        return len(wall) - max(counter.values(), default=0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        counter: Counter[int] = collections.Counter()\\n        for row in wall:\\n            width: int = 0\\n            for brick in row[:-1]:\\n                width += brick\\n                counter[width] += 1\\n        return len(wall) - max(counter.values(), default=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171728,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (List<Integer> line : wall) {\\n            int cur = 0;\\n            for (int i = 0; i < line.size() - 1; i++) {\\n                cur += line.get(i);\\n                map.put(cur, map.getOrDefault(cur, 0) + 1);\\n            }\\n        }\\n        int max = 0;\\n        for (int val : map.values()) {\\n            max = Math.max(max, val);\\n        }\\n        return wall.size() - max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (List<Integer> line : wall) {\\n            int cur = 0;\\n            for (int i = 0; i < line.size() - 1; i++) {\\n                cur += line.get(i);\\n                map.put(cur, map.getOrDefault(cur, 0) + 1);\\n            }\\n        }\\n        int max = 0;\\n        for (int val : map.values()) {\\n            max = Math.max(max, val);\\n        }\\n        return wall.size() - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171691,
                "title": "python-3-priority-queue-space-o-h",
                "content": "- To optimize space usage we can collect horizontal coordinates of the leftmost vertical brick edges of every row. \\n- Then iteratively count identical coordinates in ascending order.\\n- Minimum number of crossed bricks is the height of the wall minus maximum count of identical coordinates.\\n- The last bricks of the rows are not needed.\\n- Time complexity is `O(n*log h)`. Space complexity is `O(h)`. `h` - height of the wall.\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        heap = [(w[0], i, 0) for i, w in enumerate(wall) if len(w) > 1] \\n        heapify(heap); count = mx = 0; prev = heap and heap[0][0]\\n        while heap:\\n            x, i, j = heappop(heap)\\n            if j+2 < len(wall[i]): heappush(heap, (x + wall[i][j+1], i, j+1))\\n            if x != prev: mx = max(mx, count); count = 0; prev = x\\n            count += 1 \\n            \\n        return len(wall) - max(mx, count)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        heap = [(w[0], i, 0) for i, w in enumerate(wall) if len(w) > 1] \\n        heapify(heap); count = mx = 0; prev = heap and heap[0][0]\\n        while heap:\\n            x, i, j = heappop(heap)\\n            if j+2 < len(wall[i]): heappush(heap, (x + wall[i][j+1], i, j+1))\\n            if x != prev: mx = max(mx, count); count = 0; prev = x\\n            count += 1 \\n            \\n        return len(wall) - max(mx, count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171687,
                "title": "c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n = wall.size(), max_edges = 0;\\n        unordered_map<int,int>mp;\\n        for(vector<int>brick : wall)\\n        { \\n            int num = 0;\\n            for(int j = 0; j < brick.size()-1; j++)\\n            {\\n                num += brick[j];\\n                mp[num]++;\\n            }\\n        }\\n        for(auto i : mp)\\n            max_edges = max(max_edges, i.second);\\n        \\n        return n-max_edges;\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n = wall.size(), max_edges = 0;\\n        unordered_map<int,int>mp;\\n        for(vector<int>brick : wall)\\n        { \\n            int num = 0;\\n            for(int j = 0; j < brick.size()-1; j++)\\n            {\\n                num += brick[j];\\n                mp[num]++;\\n                max_edges = max(max_edges, mp[num]);\\n            }\\n        }\\n        return n-max_edges;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n = wall.size(), max_edges = 0;\\n        unordered_map<int,int>mp;\\n        for(vector<int>brick : wall)\\n        { \\n            int num = 0;\\n            for(int j = 0; j < brick.size()-1; j++)\\n            {\\n                num += brick[j];\\n                mp[num]++;\\n            }\\n        }\\n        for(auto i : mp)\\n            max_edges = max(max_edges, i.second);\\n        \\n        return n-max_edges;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n = wall.size(), max_edges = 0;\\n        unordered_map<int,int>mp;\\n        for(vector<int>brick : wall)\\n        { \\n            int num = 0;\\n            for(int j = 0; j < brick.size()-1; j++)\\n            {\\n                num += brick[j];\\n                mp[num]++;\\n                max_edges = max(max_edges, mp[num]);\\n            }\\n        }\\n        return n-max_edges;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171681,
                "title": "easy-c-solution-using-maps",
                "content": "```\\n/*Count number of edges and store the frequency in the map. The place that has the most amount of edges has the least number of bricks. \\n*/\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n = wall.size();\\n        int ans=0;\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<wall.size();i++) {\\n            int temp=0;\\n            for(int j=0;j<wall[i].size()-1;j++) { //ignore last brick in each row becuase we cannot consider the edges\\n                temp+=wall[i][j];\\n                freq[temp]++;\\n                ans = max(ans,freq[temp]);\\n            }\\n        }\\n        return n-ans;            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*Count number of edges and store the frequency in the map. The place that has the most amount of edges has the least number of bricks. \\n*/\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n = wall.size();\\n        int ans=0;\\n        unordered_map<int,int> freq;\\n        for(int i=0;i<wall.size();i++) {\\n            int temp=0;\\n            for(int j=0;j<wall[i].size()-1;j++) { //ignore last brick in each row becuase we cannot consider the edges\\n                temp+=wall[i][j];\\n                freq[temp]++;\\n                ans = max(ans,freq[temp]);\\n            }\\n        }\\n        return n-ans;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171471,
                "title": "python-3-using-hash-map-explained",
                "content": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def leastBricks(self, wall) -> int:\\n        \"\"\"\\n        Given a brick wall (wall) consisting of layers of bricks\\n        with each layer being the same width, this program uses\\n        a hash map to determine the least number of bricks crossed\\n        by a vertical straight line.\\n\\n        :param wall: array of arrays of bricks\\n        :type wall: list[list[int]]\\n        :return: least number of bricks crossed by a\\n                 vertical straight line\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - layers defines the number of layers in the brick wall.\\n        - width defines the width of each layer. Note that each\\n          layer has the same width.\\n        \"\"\"\\n        layers = len(wall)\\n        width = sum(wall[0])\\n\\n        \"\"\"\\n        Build the Hash Map (brick_hash):\\n        - brick_hash maps each edge location to its frequency\\n          over the entire wall.\\n        - edges are numbered from 0 to width. For example, a\\n          brick of length 2 at the start of a layer will have\\n          edges at 0 and 2.\\n        - Only edges between adjacent bricks are included in\\n          brick_hash.\\n        \"\"\"\\n        brick_hash = defaultdict(int)\\n        for layer in wall:\\n            sum_bricks = 0\\n            for brick in layer:\\n                sum_bricks += brick\\n                if sum_bricks < width:\\n                    brick_hash[sum_bricks] += 1\\n\\n        \"\"\"\\n        Use brick_hash to find the vertical line with the maximum\\n        number of edges (max_edges). Use this result to determine\\n        the least number of bricks crossed by a vertical line.\\n        \"\"\"\\n        max_edges = 0\\n        for hash in brick_hash:\\n            max_edges = max(max_edges, brick_hash[hash])\\n        return layers - max_edges\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def leastBricks(self, wall) -> int:\\n        \"\"\"\\n        Given a brick wall (wall) consisting of layers of bricks\\n        with each layer being the same width, this program uses\\n        a hash map to determine the least number of bricks crossed\\n        by a vertical straight line.\\n\\n        :param wall: array of arrays of bricks\\n        :type wall: list[list[int]]\\n        :return: least number of bricks crossed by a\\n                 vertical straight line\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - layers defines the number of layers in the brick wall.\\n        - width defines the width of each layer. Note that each\\n          layer has the same width.\\n        \"\"\"\\n        layers = len(wall)\\n        width = sum(wall[0])\\n\\n        \"\"\"\\n        Build the Hash Map (brick_hash):\\n        - brick_hash maps each edge location to its frequency\\n          over the entire wall.\\n        - edges are numbered from 0 to width. For example, a\\n          brick of length 2 at the start of a layer will have\\n          edges at 0 and 2.\\n        - Only edges between adjacent bricks are included in\\n          brick_hash.\\n        \"\"\"\\n        brick_hash = defaultdict(int)\\n        for layer in wall:\\n            sum_bricks = 0\\n            for brick in layer:\\n                sum_bricks += brick\\n                if sum_bricks < width:\\n                    brick_hash[sum_bricks] += 1\\n\\n        \"\"\"\\n        Use brick_hash to find the vertical line with the maximum\\n        number of edges (max_edges). Use this result to determine\\n        the least number of bricks crossed by a vertical line.\\n        \"\"\"\\n        max_edges = 0\\n        for hash in brick_hash:\\n            max_edges = max(max_edges, brick_hash[hash])\\n        return layers - max_edges\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171405,
                "title": "rust-hashmap-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn least_bricks(wall: Vec<Vec<i32>>) -> i32 {\\n        wall.len() as i32\\n            - wall\\n                .iter()\\n                .fold(std::collections::HashMap::new(), |mut acc, row| {\\n                    row.iter()\\n                        .take(row.len() - 1)\\n                        .scan(0, |state, &x| {\\n                            *state += x;\\n                            Some(*state)\\n                        })\\n                        .for_each(|x| *acc.entry(x).or_default() += 1);\\n                    acc\\n                })\\n                .values()\\n                .max()\\n                .unwrap_or(&0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn least_bricks(wall: Vec<Vec<i32>>) -> i32 {\\n        wall.len() as i32\\n            - wall\\n                .iter()\\n                .fold(std::collections::HashMap::new(), |mut acc, row| {\\n                    row.iter()\\n                        .take(row.len() - 1)\\n                        .scan(0, |state, &x| {\\n                            *state += x;\\n                            Some(*state)\\n                        })\\n                        .for_each(|x| *acc.entry(x).or_default() += 1);\\n                    acc\\n                })\\n                .values()\\n                .max()\\n                .unwrap_or(&0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171383,
                "title": "easy-to-understand-o-n-solution",
                "content": "Lets simplify it.\\n\\nWe need to find a edge whose position is common in all rows.\\n\\nLet\\'s understand with an example:\\nrow 1 -> [1,2,2,1] -> edges after width from start = [1,3,5] (Not counting start and end of wall)\\nrow 2 -> [3,1,2]   -> [3,4]\\nrow 3 -> [1,3,2]   -> [1,4]\\nrow 4 -> [2,4]      -> [2]\\nrow 5 -> [3,1,2]   -> [3,4]\\nrow 6 -> [1,3,1,1] -> [1,4,5]\\n\\nSo we need most common width because it reflects the common edge in all the rows.\\n\\nSo best data structure to count frequencies is Hash Table.\\nPlease go through the code, if clear understanding\\n\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        # maintaining a dictionary with default values\\n        mp = defaultdict(int)\\n        for i in wall:\\n            len_ =len(i)\\n            # If number of bricks in a row is 1 then no edges\\n            if len_ <= 1:\\n                continue\\n            # start finding the edges and count the occurences simultaneously\\n            prefSum = i[0]\\n            mp[prefSum]+=1\\n            for j in range(1, len_):\\n                prefSum+=i[j]\\n                if j!=len_-1:\\n                    mp[prefSum]+=1\\n        wall_len = len(wall)\\n        # if no edges in any of the row, then return number of rows\\n        if len(mp) == 0: return wall_len\\n        # find number of bricks crossed\\n        return wall_len - max(mp.values())\\n```\\n\\nTime complexity: O(n)   \\n(ideally O(nk) where n is the number of rows and max number of bricks)\\nSpace complexity: O(n)    \\n(ideally O(nk) where n is the number of rows and max number of bricks)\\n\\nPlease upvote! if it helps.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        # maintaining a dictionary with default values\\n        mp = defaultdict(int)\\n        for i in wall:\\n            len_ =len(i)\\n            # If number of bricks in a row is 1 then no edges\\n            if len_ <= 1:\\n                continue\\n            # start finding the edges and count the occurences simultaneously\\n            prefSum = i[0]\\n            mp[prefSum]+=1\\n            for j in range(1, len_):\\n                prefSum+=i[j]\\n                if j!=len_-1:\\n                    mp[prefSum]+=1\\n        wall_len = len(wall)\\n        # if no edges in any of the row, then return number of rows\\n        if len(mp) == 0: return wall_len\\n        # find number of bricks crossed\\n        return wall_len - max(mp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171234,
                "title": "easy-short-and-clean-code-using-map",
                "content": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n       unordered_map<int,int>m;\\n        int cut=0;\\n        for(auto x:wall)\\n        {\\n            int sum=0;\\n            for(int j=0;j<x.size()-1;j++)\\n            {\\n                sum+=x[j];\\n                m[sum]++;\\n                cut=max(cut,m[sum]);\\n            }\\n        }            \\n        return wall.size()-cut;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n       unordered_map<int,int>m;\\n        int cut=0;\\n        for(auto x:wall)\\n        {\\n            int sum=0;\\n            for(int j=0;j<x.size()-1;j++)\\n            {\\n                sum+=x[j];\\n                m[sum]++;\\n                cut=max(cut,m[sum]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1171227,
                "title": "hashmaps-easy-to-understand",
                "content": "```\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>mp;\\n        int m=INT_MIN;\\n        \\n        for(auto i:wall){\\n            int sum=0;\\n            for(int k=0;k<i.size()-1;k++){\\n                sum+=i[k];\\n                mp[sum]++;\\n                m=max(m,mp[sum]);\\n                \\n            }\\n        }\\n\\n        if(m==INT_MIN)return wall.size();\\n\\n        return wall.size()-m;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>mp;\\n        int m=INT_MIN;\\n        \\n        for(auto i:wall){\\n            int sum=0;\\n            for(int k=0;k<i.size()-1;k++){\\n                sum+=i[k];\\n                mp[sum]++;\\n                m=max(m,mp[sum]);\\n                \\n            }\\n        }\\n\\n        if(m==INT_MIN)return wall.size();\\n\\n        return wall.size()-m;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171211,
                "title": "python-3-counter-accumulator-1-line",
                "content": "- To get the least bricks crossed by a vertial line we can find out maximum number of vertical edges.\\n- Straightforward solution is to find horizontal coordinates of all vertical edges, except the last one. \\n- Time complexity is `O(n)`. Space complexity is `O(w)`. `w` - number of vertical edges.\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - max(Counter(chain.from_iterable(accumulate(w[:-1]) for w in wall)).values(), default=0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - max(Counter(chain.from_iterable(accumulate(w[:-1]) for w in wall)).values(), default=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170967,
                "title": "python3-cumulative-sum-except-last-column",
                "content": "If there are n rows, in each row wall[i], first k[i] bricks can be summed and we need to find maximum number of equal such sums, when one taken from each row. So we need to find the maximum number of rows that share a common value of cumulative row sum.\\nSize of a brick>0, so cumulative sum for every row is strictly increasing, i.e. every row has unique elements or frequency of one number in one row is atmost 1.\\nFind cumulative sum of each row before last column (because sum of each row is same and if this is also taken, it will always return 0) and for each number in the cumulative sum, store its frequency among all rows.\\nn - maximum_frequency is the answer.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n\\t\\tn = len(wall)\\n        for i in range(n):\\n            if len(wall[i])>1:  # exclude last if first is last\\n                freq[wall[i][0]] += 1  # update freq\\n            for j in range(1,len(wall[i])-1):  # exclude last\\n                wall[i][j] += wall[i][j-1]\\n                freq[wall[i][j]] += 1  # update freq\\n        return n-max(freq.values())\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n\\t\\tn = len(wall)\\n        for i in range(n):\\n            if len(wall[i])>1:  # exclude last if first is last\\n                freq[wall[i][0]] += 1  # update freq\\n            for j in range(1,len(wall[i])-1):  # exclude last\\n                wall[i][j] += wall[i][j-1]\\n                freq[wall[i][j]] += 1  # update freq\\n        return n-max(freq.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170959,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int leastBricks(vector<vector<int>>& wall) \\n    {\\n        unordered_map<int, int> m;\\n        int res = wall.size(), n = wall.size();\\n        \\n        for (auto row : wall) \\n        {\\n            \\n            int curr_width = 0;\\n            for (int i = 0; i < row.size()-1; i++) \\n            {\\n                \\n                curr_width += row[i];\\n                res = min(res, n - (++m[curr_width]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int leastBricks(vector<vector<int>>& wall) \\n    {\\n        unordered_map<int, int> m;\\n        int res = wall.size(), n = wall.size();\\n        \\n        for (auto row : wall) \\n        {\\n            \\n            int curr_width = 0;\\n            for (int i = 0; i < row.size()-1; i++) \\n            {\\n                \\n                curr_width += row[i];\\n                res = min(res, n - (++m[curr_width]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148578,
                "title": "short-js-solution",
                "content": "```\\n/**\\n * @param {number[][]} wall\\n * @return {number}\\n */\\nvar leastBricks = function (wall) {\\n  const map = {}\\n\\n  wall.forEach(row => {\\n    row.slice(0, -1).reduce((width, current) => {\\n      const point = width + current\\n      map[point] = ++map[point] || 1\\n\\n      return point\\n    }, 0)\\n  })\\n\\n  return wall.length - Math.max(...Object.values(map), 0)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} wall\\n * @return {number}\\n */\\nvar leastBricks = function (wall) {\\n  const map = {}\\n\\n  wall.forEach(row => {\\n    row.slice(0, -1).reduce((width, current) => {\\n      const point = width + current\\n      map[point] = ++map[point] || 1\\n\\n      return point\\n    }, 0)\\n  })\\n\\n  return wall.length - Math.max(...Object.values(map), 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1006745,
                "title": "c-hash-map-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> gaps;\\n        int maxGap = 0;\\n        \\n        for (auto& row : wall) {\\n            int border = 0;\\n            \\n            for (int i = 0; i < row.size() - 1; i++) {\\n                border += row[i];\\n                maxGap = max(maxGap, ++gaps[border]);\\n            }\\n        }\\n        \\n        return wall.size() - maxGap;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> gaps;\\n        int maxGap = 0;\\n        \\n        for (auto& row : wall) {\\n            int border = 0;\\n            \\n            for (int i = 0; i < row.size() - 1; i++) {\\n                border += row[i];\\n                maxGap = max(maxGap, ++gaps[border]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 973937,
                "title": "python-heap-solution",
                "content": "Not the best solution out there. But the initital attempt was using heap and a brick counter.\\n\\nMake a prefix sum of all the bricks in a row which marks the end territory of each brick. Then add them to a heap to find the minimum end territory brick. The brick counter is incremented if the min end territory is same as the current popped end territory.\\n\\nCheck if the next brick in the heap has same end territory value as the current brick. If yes then increment the brick counter. If no then \\nreset the counter and set the `cur_min_edge` to the current brick territory. Also calculate the result by `len(wall)-same_edge_counter`\\n```\\nimport heapq\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        \\n        heap = []\\n        for row in wall:\\n            last_num = 0\\n            for brick in row:\\n                last_num = last_num + brick\\n                heapq.heappush(heap, last_num)\\n        \\n        cur_min_edge = heapq.heappop(heap)\\n        result = float(\\'inf\\')\\n        same_edge_counter = 1\\n        while heap:\\n            current_edge = heapq.heappop(heap)\\n            if cur_min_edge != current_edge:\\n                result = min(len(wall)-same_edge_counter, result)\\n                cur_min_edge = current_edge\\n                same_edge_counter = 1\\n            else:\\n                same_edge_counter += 1\\n        if result == float(\\'inf\\'):\\n            return same_edge_counter\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        \\n        heap = []\\n        for row in wall:\\n            last_num = 0\\n            for brick in row:\\n                last_num = last_num + brick\\n                heapq.heappush(heap, last_num)\\n        \\n        cur_min_edge = heapq.heappop(heap)\\n        result = float(\\'inf\\')\\n        same_edge_counter = 1\\n        while heap:\\n            current_edge = heapq.heappop(heap)\\n            if cur_min_edge != current_edge:\\n                result = min(len(wall)-same_edge_counter, result)\\n                cur_min_edge = current_edge\\n                same_edge_counter = 1\\n            else:\\n                same_edge_counter += 1\\n        if result == float(\\'inf\\'):\\n            return same_edge_counter\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939689,
                "title": "python-3-in-just-two-lines-really-fast",
                "content": "```python\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        c = collections.Counter(j for row in wall for j in itertools.accumulate(row[:-1]))\\n        return len(wall) - max(c.values(), default=0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        c = collections.Counter(j for row in wall for j in itertools.accumulate(row[:-1]))\\n        return len(wall) - max(c.values(), default=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937166,
                "title": "sharing-my-java-solution",
                "content": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        // find frequency of gaps\\n        Map<Integer, Integer> gaps = new HashMap<>();\\n        int mostGaps = 0;\\n        for(List<Integer> bricks : wall)\\n        {\\n            int n = 0;\\n            for(int i=0;i<bricks.size()-1;i++)\\n            {\\n                n += bricks.get(i);\\n                gaps.put(n, gaps.getOrDefault(n, 0) + 1);\\n                mostGaps = Math.max(mostGaps, gaps.get(n));\\n            }\\n        }\\n        \\n        return wall.size() - mostGaps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        // find frequency of gaps\\n        Map<Integer, Integer> gaps = new HashMap<>();\\n        int mostGaps = 0;\\n        for(List<Integer> bricks : wall)\\n        {\\n            int n = 0;\\n            for(int i=0;i<bricks.size()-1;i++)\\n            {\\n                n += bricks.get(i);\\n                gaps.put(n, gaps.getOrDefault(n, 0) + 1);\\n                mostGaps = Math.max(mostGaps, gaps.get(n));\\n            }\\n        }\\n        \\n        return wall.size() - mostGaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920502,
                "title": "simple-c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        // Cumulate all the bricks width\\n        for(auto& vec : wall){\\n            for(int i = 1 ; i < vec.size() ; ++i){\\n                vec[i] += vec[i-1];\\n            }\\n        }\\n        \\n        // Use a hashmap to keep track of how many times did we see that width\\n        unordered_map<int,int> mp;\\n        for(auto& vec : wall){\\n            for(int i = 0 ; i < vec.size() - 1 ; ++i){\\n                mp[vec[i]]++;\\n            }\\n        }\\n        \\n        // Find the maximum value\\n        int maxm = 0;\\n        for(auto& p : mp){\\n            if(p.second > maxm)\\n                maxm = p.second;\\n        }\\n        \\n\\t\\t//Answer is wall.size() - maxm\\n        return wall.size() - maxm;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        // Cumulate all the bricks width\\n        for(auto& vec : wall){\\n            for(int i = 1 ; i < vec.size() ; ++i){\\n                vec[i] += vec[i-1];\\n            }\\n        }\\n        \\n        // Use a hashmap to keep track of how many times did we see that width\\n        unordered_map<int,int> mp;\\n        for(auto& vec : wall){\\n            for(int i = 0 ; i < vec.size() - 1 ; ++i){\\n                mp[vec[i]]++;\\n            }\\n        }\\n        \\n        // Find the maximum value\\n        int maxm = 0;\\n        for(auto& p : mp){\\n            if(p.second > maxm)\\n                maxm = p.second;\\n        }\\n        \\n\\t\\t//Answer is wall.size() - maxm\\n        return wall.size() - maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917966,
                "title": "java-beat-98-with-11-lines-of-code",
                "content": "```\\n    public int leastBricks(List<List<Integer>> wall) {\\n        \\n        HashMap<Integer,Integer> resultMap = new HashMap<>();\\n        int ans = 0;\\n        for(int i = 0; i<wall.size(); i++){\\n            int count = 0;\\n            for(int k = 0; k<wall.get(i).size()-1; k++){\\n                count+=wall.get(i).get(k);\\n                resultMap.put(count, resultMap.containsKey(count)?resultMap.get(count)+1:1);\\n                ans = Math.max(ans,resultMap.get(count));\\n            }\\n        }\\n        return wall.size()-ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    public int leastBricks(List<List<Integer>> wall) {\\n        \\n        HashMap<Integer,Integer> resultMap = new HashMap<>();\\n        int ans = 0;\\n        for(int i = 0; i<wall.size(); i++){\\n            int count = 0;\\n            for(int k = 0; k<wall.get(i).size()-1; k++){\\n                count+=wall.get(i).get(k);\\n                resultMap.put(count, resultMap.containsKey(count)?resultMap.get(count)+1:1);\\n                ans = Math.max(ans,resultMap.get(count));\\n            }\\n        }\\n        return wall.size()-ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 886349,
                "title": "c-simple-hashmap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n=wall.size();\\n        int m=0;\\n        for(int i=0;i<wall[0].size();i++){\\n            m+=wall[0][i];\\n        }\\n        cout << m << \"\\\\n\";\\n        unordered_map<int,int>out;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int a=0;\\n            for(int j=0;j<wall[i].size();j++){\\n                a+=wall[i][j];\\n                out[a-1]++;\\n                if(a!=m){\\n                    ans=max(ans,out[a-1]);\\n                }\\n            }\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int n=wall.size();\\n        int m=0;\\n        for(int i=0;i<wall[0].size();i++){\\n            m+=wall[0][i];\\n        }\\n        cout << m << \"\\\\n\";\\n        unordered_map<int,int>out;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int a=0;\\n            for(int j=0;j<wall[i].size();j++){\\n                a+=wall[i][j];\\n                out[a-1]++;\\n                if(a!=m){\\n                    ans=max(ans,out[a-1]);\\n                }\\n            }\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 840094,
                "title": "c-easy-to-understand-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n     unordered_map<int,int>edge_end;//To store the number of rows where bricks end at a particular position\\n     int n=wall.size();\\n     int result=n;//Maximum result is equal to the number of rows\\n     for(int i=0;i<wall.size();i++)\\n     {\\n       int csum=0;\\n       for(int j=0;j<wall[i].size()-1;j++)\\n       {\\n           csum+=wall[i][j];//End position of jth brick in ith row\\n           edge_end[csum]++;//No of bricks above with its end at the same position\\n           result=min(result,n-edge_end[csum]);\\n       }\\n     }\\n    return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n     unordered_map<int,int>edge_end;//To store the number of rows where bricks end at a particular position\\n     int n=wall.size();\\n     int result=n;//Maximum result is equal to the number of rows\\n     for(int i=0;i<wall.size();i++)\\n     {\\n       int csum=0;\\n       for(int j=0;j<wall[i].size()-1;j++)\\n       {\\n           csum+=wall[i][j];//End position of jth brick in ith row\\n           edge_end[csum]++;//No of bricks above with its end at the same position\\n           result=min(result,n-edge_end[csum]);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 764140,
                "title": "viable-java-solution-o-n-time-and-o-m-space-using-map",
                "content": "```\\n\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> mapping = new TreeMap();\\n        \\n        //get the total width of the wall\\n        int totalwidth = 0;\\n        for(int i : wall.get(0))\\n            totalwidth += i;\\n        \\n        for(int k = 0; k < wall.size(); k++){\\n            int vertical = 0;//keep a variable to track the different verticals a row creates\\n            for(int m = 0; m < wall.get(k).size(); m++){\\n                \\n                vertical = vertical + wall.get(k).get(m);\\n                \\n                if(vertical < totalwidth)//check that this is not an edge to the entire rectangle\\n                    mapping.put(vertical,mapping.getOrDefault(vertical,0)+1);\\n            }\\n        }\\n        \\n        //get the key with the maximum verticals\\n        int max = 0; \\n        for(int temp : mapping.keySet())\\n            if(mapping.get(temp) > max)\\n                max = mapping.get(temp);\\n        \\n        \\n        return wall.size() - max;//difference gives the least crosssed bricks\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> mapping = new TreeMap();\\n        \\n        //get the total width of the wall\\n        int totalwidth = 0;\\n        for(int i : wall.get(0))\\n            totalwidth += i;\\n        \\n        for(int k = 0; k < wall.size(); k++){\\n            int vertical = 0;//keep a variable to track the different verticals a row creates\\n            for(int m = 0; m < wall.get(k).size(); m++){\\n                \\n                vertical = vertical + wall.get(k).get(m);\\n                \\n                if(vertical < totalwidth)//check that this is not an edge to the entire rectangle\\n                    mapping.put(vertical,mapping.getOrDefault(vertical,0)+1);\\n            }\\n        }\\n        \\n        //get the key with the maximum verticals\\n        int max = 0; \\n        for(int temp : mapping.keySet())\\n            if(mapping.get(temp) > max)\\n                max = mapping.get(temp);\\n        \\n        \\n        return wall.size() - max;//difference gives the least crosssed bricks\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757711,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i=0; i<wall.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<wall.get(i).size()-1; j++) {\\n                sum+=(wall.get(i).get(j));\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for (int key: map.keySet()) {\\n            max = Math.max(max, map.get(key));\\n        }\\n        \\n        return max == Integer.MIN_VALUE ? wall.size() : wall.size() - max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i=0; i<wall.size(); i++) {\\n            int sum = 0;\\n            for (int j=0; j<wall.get(i).size()-1; j++) {\\n                sum+=(wall.get(i).get(j));\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for (int key: map.keySet()) {\\n            max = Math.max(max, map.get(key));\\n        }\\n        \\n        return max == Integer.MIN_VALUE ? wall.size() : wall.size() - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751974,
                "title": "java-hashmap-count-max-frequency-of-prefix-sum",
                "content": "```\\nclass Solution {\\n    // prefix sum of each row\\n    // count frequency with a map\\n    // keep track of highest frequency\\n    // cannot be 0 or sum -> exclude 0 and sum from max collision point\\n    // return : height - frequency\\n\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int maxFrequencyCount = Integer.MIN_VALUE;\\n\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int i = 0 ; i < wall.size(); i++) {\\n            int sum = 0;\\n            List<Integer> row = wall.get(i);\\n            for(int j = 0; j < row.size(); j++) {\\n                sum += row.get(j);\\n                count.put(sum, count.getOrDefault(sum, 0) + 1);\\n                if(j != row.size() - 1\\n                        && sum != 0\\n                        && count.get(sum) > maxFrequencyCount) {\\n                    maxFrequencyCount = count.get(sum);\\n                }\\n            }\\n        }\\n        if(maxFrequencyCount > 0) {\\n            return wall.size() - maxFrequencyCount;\\n        } \\n        return wall.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // prefix sum of each row\\n    // count frequency with a map\\n    // keep track of highest frequency\\n    // cannot be 0 or sum -> exclude 0 and sum from max collision point\\n    // return : height - frequency\\n\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int maxFrequencyCount = Integer.MIN_VALUE;\\n\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int i = 0 ; i < wall.size(); i++) {\\n            int sum = 0;\\n            List<Integer> row = wall.get(i);\\n            for(int j = 0; j < row.size(); j++) {\\n                sum += row.get(j);\\n                count.put(sum, count.getOrDefault(sum, 0) + 1);\\n                if(j != row.size() - 1\\n                        && sum != 0\\n                        && count.get(sum) > maxFrequencyCount) {\\n                    maxFrequencyCount = count.get(sum);\\n                }\\n            }\\n        }\\n        if(maxFrequencyCount > 0) {\\n            return wall.size() - maxFrequencyCount;\\n        } \\n        return wall.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737344,
                "title": "clean-solution-using-cpp-map-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        int rows = wall.size();       //define the wall height\\n        \\n        map<int, int> m;              //map m to store the number of common edges among the rows\\n\\n        int max_edge = 0;             //variable to store the greatest number of common edges\\n        \\n        for(int i=0;i<rows;i++){                //for loop down the wall\\n            \\n            int curr = 0;                       //variable to accumulate the row widths\\n            \\n            for(int j=0;j<wall[i].size()-1;j++){    //nested for loop looking at each row\\n                \\n                curr += wall[i][j];                 //accumulating the width of each row\\n                \\n                m[curr]++;                          //populating the map with incremental edge counts per row\\n                \\n                max_edge = max(max_edge, m[curr]);  //finding the largest edge count site\\n            \\n            }\\n            \\n        }\\n        \\n        int ans = rows-max_edge;                    //define the answer as total rows minus max edge count location\\n    \\n        return ans;                                 //return the answer\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        int rows = wall.size();       //define the wall height\\n        \\n        map<int, int> m;              //map m to store the number of common edges among the rows\\n\\n        int max_edge = 0;             //variable to store the greatest number of common edges\\n        \\n        for(int i=0;i<rows;i++){                //for loop down the wall\\n            \\n            int curr = 0;                       //variable to accumulate the row widths\\n            \\n            for(int j=0;j<wall[i].size()-1;j++){    //nested for loop looking at each row\\n                \\n                curr += wall[i][j];                 //accumulating the width of each row\\n                \\n                m[curr]++;                          //populating the map with incremental edge counts per row\\n                \\n                max_edge = max(max_edge, m[curr]);  //finding the largest edge count site\\n            \\n            }\\n            \\n        }\\n        \\n        int ans = rows-max_edge;                    //define the answer as total rows minus max edge count location\\n    \\n        return ans;                                 //return the answer\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736052,
                "title": "c-easy-understand-solution",
                "content": "Intuition- Line will pass through that point where maximum row\\'s bricks are ending with same sum from start of the row.\\n``` \\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> m;\\n        int mx=0;\\n        for(int i=0;i<wall.size();i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<wall[i].size()-1;j++)\\n            {\\n                sum+=wall[i][j];\\n                m[sum]++;\\n                mx=max(mx,m[sum]);\\n            }\\n        }\\n        return wall.size()-mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> m;\\n        int mx=0;\\n        for(int i=0;i<wall.size();i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<wall[i].size()-1;j++)\\n            {\\n                sum+=wall[i][j];\\n                m[sum]++;\\n                mx=max(mx,m[sum]);\\n            }\\n        }\\n        return wall.size()-mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726976,
                "title": "c-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> count;\\n        int mcount = 0;\\n        for(auto row : wall){\\n            int psum = 0;\\n            for(int i=0;i<row.size()-1;i++){\\n                psum += row[i];\\n                count[psum]++;\\n                mcount = max(mcount, count[psum]);\\n            }\\n        }\\n        return wall.size() - mcount;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> count;\\n        int mcount = 0;\\n        for(auto row : wall){\\n            int psum = 0;\\n            for(int i=0;i<row.size()-1;i++){\\n                psum += row[i];\\n                count[psum]++;\\n                mcount = max(mcount, count[psum]);\\n            }\\n        }\\n        return wall.size() - mcount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714661,
                "title": "python-dictionary",
                "content": "\\tclass Solution:\\n\\t\\tdef leastBricks(self, wall: List[List[int]]) -> int:\\n\\t\\t\\tseen = collections.defaultdict(int)\\n\\t\\t\\tfor i in range(len(wall)):\\n\\t\\t\\t\\ts = 0\\n\\t\\t\\t\\tfor j in range(len(wall[i])):\\n\\t\\t\\t\\t\\ts += wall[i][j]\\n\\t\\t\\t\\t\\tseen[s] += 1\\n\\t\\t\\tdel seen[sum(wall[0])]\\n\\t\\t\\tif not seen:\\n\\t\\t\\t\\treturn len(wall)\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn len(wall) - max(seen.values())",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef leastBricks(self, wall: List[List[int]]) -> int:\\n\\t\\t\\tseen = collections.defaultdict(int)\\n\\t\\t\\tfor i in range(len(wall)):\\n\\t\\t\\t\\ts = 0\\n\\t\\t\\t\\tfor j in range(len(wall[i])):\\n\\t\\t\\t\\t\\ts += wall[i][j]\\n\\t\\t\\t\\t\\tseen[s] += 1\\n\\t\\t\\tdel seen[sum(wall[0])]\\n\\t\\t\\tif not seen:\\n\\t\\t\\t\\treturn len(wall)\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn len(wall) - max(seen.values())",
                "codeTag": "Java"
            },
            {
                "id": 699729,
                "title": "very-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        m = {}\\n        for rows in wall:\\n            summ = 0\\n            for i in rows:\\n                summ += i\\n                if summ in m:\\n                    m[summ] += 1\\n                else:\\n                    m[summ] = 1\\n        m.pop(sum(wall[0]))\\n        maxx = max(m.values()) if m else 0\\n        return len(wall) - maxx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        m = {}\\n        for rows in wall:\\n            summ = 0\\n            for i in rows:\\n                summ += i\\n                if summ in m:\\n                    m[summ] += 1\\n                else:\\n                    m[summ] = 1\\n        m.pop(sum(wall[0]))\\n        maxx = max(m.values()) if m else 0\\n        return len(wall) - maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673899,
                "title": "python-4-lines-with-itertools-accumulate",
                "content": "```python\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        count = Counter()\\n        for row in wall:\\n            count += Counter(itertools.accumulate(row[:-1]))\\n        return len(wall) - (count.most_common(1)[0][1] if count.most_common(1) else 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        count = Counter()\\n        for row in wall:\\n            count += Counter(itertools.accumulate(row[:-1]))\\n        return len(wall) - (count.most_common(1)[0][1] if count.most_common(1) else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653732,
                "title": "c-hashmap-prefix-sum-concise-solution",
                "content": "**Intuition:**\\n\\nCalculate prefix sums for each row till second last value in the row (as we cannot draw at end).\\nStore prefix sums in hash table. Get the value which came maximum number of times. (suppose val)\\nNumber of row minus val is the result.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        int n = wall.size();\\n        unordered_map<int, int>mp;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < wall[i].size()-1; j++) {\\n                wall[i][j] = j == 0 ? wall[i][j] : wall[i][j] + wall[i][j-1];\\n                mp[wall[i][j]]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (auto it = mp.begin(); it != mp.end(); it++)\\n            res = max(res, it->second);\\n        \\n        return n-res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        int n = wall.size();\\n        unordered_map<int, int>mp;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < wall[i].size()-1; j++) {\\n                wall[i][j] = j == 0 ? wall[i][j] : wall[i][j] + wall[i][j-1];\\n                mp[wall[i][j]]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (auto it = mp.begin(); it != mp.end(); it++)\\n            res = max(res, it->second);\\n        \\n        return n-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520699,
                "title": "c-sweep-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int,int> brick;\\n        int nums = wall.size(), maxBrick = 0;\\n        for(int i = 0; i<wall.size(); i++){\\n            int sum = 0;\\n            for(int j = 0; j < wall[i].size()-1; j++){\\n                sum += wall[i][j];\\n                brick[sum]++;\\n                maxBrick = max(maxBrick, brick[sum]);\\n            }\\n        }\\n        return nums - maxBrick;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int,int> brick;\\n        int nums = wall.size(), maxBrick = 0;\\n        for(int i = 0; i<wall.size(); i++){\\n            int sum = 0;\\n            for(int j = 0; j < wall[i].size()-1; j++){\\n                sum += wall[i][j];\\n                brick[sum]++;\\n                maxBrick = max(maxBrick, brick[sum]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 514295,
                "title": "92-73-time-100-memory-java-solution",
                "content": "\\n    public int leastBricks(List<List<Integer>> wall) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < wall.size(); i++) {\\n            List<Integer> subList = wall.get(i);\\n            int index = 0;\\n            for (int j = 0; j < subList.size() - 1; j++) {\\n                index += subList.get(j);\\n                map.put(index, map.getOrDefault(index, 0) + 1);\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int key : map.keySet()) {\\n            int v = map.get(key);\\n            if (v >= max) {\\n                max = v;\\n            }\\n        }\\n        \\n        return wall.size() - max;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int leastBricks(List<List<Integer>> wall) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < wall.size(); i++) {\\n            List<Integer> subList = wall.get(i);\\n            int index = 0;\\n            for (int j = 0; j < subList.size() - 1; j++) {\\n                index += subList.get(j);\\n                map.put(index, map.getOrDefault(index, 0) + 1);\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int key : map.keySet()) {\\n            int v = map.get(key);\\n            if (v >= max) {\\n                max = v;\\n            }\\n        }\\n        \\n        return wall.size() - max;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 501223,
                "title": "c-solution-by-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int height=wall.size();\\n        unordered_map<int,int>hash;\\n        int width=0;int maximum=0;\\n        for(int &n:wall[0])width+=n;\\n        for(vector<int>&row:wall){\\n            int sum=0;\\n            for(int &n:row){\\n                sum+=n;\\n                if(sum==width)break;\\n                if(hash.find(sum)==hash.end()){\\n                    hash[sum]=1;\\n                }\\n                else{\\n                    hash[sum]++;\\n                }\\n            }\\n        }\\n        for(auto it=hash.begin();it!=hash.end();it++){\\n            maximum=max(maximum,it->second);\\n        }\\n        return height-maximum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int height=wall.size();\\n        unordered_map<int,int>hash;\\n        int width=0;int maximum=0;\\n        for(int &n:wall[0])width+=n;\\n        for(vector<int>&row:wall){\\n            int sum=0;\\n            for(int &n:row){\\n                sum+=n;\\n                if(sum==width)break;\\n                if(hash.find(sum)==hash.end()){\\n                    hash[sum]=1;\\n                }\\n                else{\\n                    hash[sum]++;\\n                }\\n            }\\n        }\\n        for(auto it=hash.begin();it!=hash.end();it++){\\n            maximum=max(maximum,it->second);\\n        }\\n        return height-maximum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411891,
                "title": "easy-to-understand-javascript",
                "content": "map stores the count of edges distances from the start. For example, a row [1, 2, 4, 5] will have the edge distances [1, 3, 7]. A row cannot count the same distance more than once, so each count comes from a unique row.\\n\\nThe max count will be the column where a vertical line can be drawn going through the most edges, and thus crossing the least number of bricks.\\n```\\nvar leastBricks = function(wall) {\\n    let map = {};\\n    let max = 0;\\n    wall.forEach(row => {\\n        let sum = 0;\\n        for (let n = 0; n < row.length - 1; n++) {\\n            sum += row[n];\\n            map[sum] = sum in map ? map[sum] + 1 : 1;\\n            max = Math.max(map[sum], max);\\n        }\\n    });\\n    return wall.length - max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar leastBricks = function(wall) {\\n    let map = {};\\n    let max = 0;\\n    wall.forEach(row => {\\n        let sum = 0;\\n        for (let n = 0; n < row.length - 1; n++) {\\n            sum += row[n];\\n            map[sum] = sum in map ? map[sum] + 1 : 1;\\n            max = Math.max(map[sum], max);\\n        }\\n    });\\n    return wall.length - max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 393969,
                "title": "solution-in-python-3-three-lines",
                "content": "_Six Line Version:_ (beats ~97%)\\n```\\nclass Solution:\\n    def leastBricks(self, W: List[List[int]]) -> int:\\n    \\tL, C = len(W), collections.defaultdict(int)\\n    \\tfor w in W:\\n    \\t\\ts = 0\\n    \\t\\tfor b in w: s += b; C[s] += 1\\n    \\tC[s] = 0\\n    \\treturn L - max(C.values())\\n\\t\\t\\n\\t\\t\\n```\\n_Three Line Version:_\\n```\\nclass Solution:\\n    def leastBricks(self, W: List[List[int]]) -> int:\\n    \\tL, C = len(W), collections.Counter(sum([list(itertools.accumulate(w)) for w in W],[]))\\n    \\tC[sum(W[0])] = 0\\n    \\treturn L - max(C.values())\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, W: List[List[int]]) -> int:\\n    \\tL, C = len(W), collections.defaultdict(int)\\n    \\tfor w in W:\\n    \\t\\ts = 0\\n    \\t\\tfor b in w: s += b; C[s] += 1\\n    \\tC[s] = 0\\n    \\treturn L - max(C.values())\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388514,
                "title": "c-using-priority-queue-o-nlog-m",
                "content": "n is the total number of bricks, m is the row number\\n\\nHere I use a priority queue to indicate the current visited length in each row.\\nWhen pop a visisted length from queue, we store it in a temp cache, and push all records in temp cache to queue when a higher value of length occurs.\\n\\nFor example:\\n1,2,1\\n2,2\\n1,3\\n\\nqueue will be init like [1, 1, 2]\\nand we get  (brick count == 1) when pop two 1 from queue\\nthen push them into queue again\\nqueue will be like [2, 3, 4]\\n\\n\\n```\\nstruct Node {\\n\\tint val;\\n\\tint i;\\n\\tint j;\\n\\tNode(int val, int i, int j) : val(val), i(i), j(j) {}\\n};\\n\\nstruct cmp {\\n\\tbool operator() (Node& n1, Node& n2) {\\n\\t\\treturn n1.val > n2.val;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\tvoid myPrint(vector<vector<int>>& wall) {\\n\\t\\tfor (const auto& t : wall) {\\n\\t\\t\\tfor (const auto& p : t) {\\n\\t\\t\\t\\tcout << p << \",\";\\n\\t\\t\\t}\\n\\t\\t\\tcout << endl;\\n\\t\\t}\\n\\t}\\n\\tint leastBricks(vector<vector<int>>& wall) {\\n\\t\\tint m = wall.size();\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tint n = wall[i].size();\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\twall[i][j] += wall[i][j - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//myPrint(wall);\\n\\t\\tint width = wall[0].back();\\n\\t\\tpriority_queue<Node, vector<Node>, cmp> q;\\n\\t\\tint ans = m;\\n\\t\\tint cnt = m;\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tq.push(Node(wall[i][0], i, 0));\\n\\t\\t}\\n\\t\\tvector<Node> temp;\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tNode node = q.top();\\n\\t\\t\\tif (node.val == width)break;\\n\\t\\t\\tif (temp.empty() || temp[0].val == node.val) {\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\tcnt--;\\n\\t\\t\\t\\tans = min(ans, cnt);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\twhile (!temp.empty()) {\\n\\t\\t\\t\\t\\tNode nn = temp.back(); temp.pop_back();\\n\\t\\t\\t\\t\\tnn.j++;\\n\\t\\t\\t\\t\\tnn.val = wall[nn.i][nn.j];\\n\\t\\t\\t\\t\\tq.push(nn);\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//cout << \"pop:\" << node.i << \"(\" << cnt << \")\" << node.val << endl;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n\\tint val;\\n\\tint i;\\n\\tint j;\\n\\tNode(int val, int i, int j) : val(val), i(i), j(j) {}\\n};\\n\\nstruct cmp {\\n\\tbool operator() (Node& n1, Node& n2) {\\n\\t\\treturn n1.val > n2.val;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\tvoid myPrint(vector<vector<int>>& wall) {\\n\\t\\tfor (const auto& t : wall) {\\n\\t\\t\\tfor (const auto& p : t) {\\n\\t\\t\\t\\tcout << p << \",\";\\n\\t\\t\\t}\\n\\t\\t\\tcout << endl;\\n\\t\\t}\\n\\t}\\n\\tint leastBricks(vector<vector<int>>& wall) {\\n\\t\\tint m = wall.size();\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tint n = wall[i].size();\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\twall[i][j] += wall[i][j - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//myPrint(wall);\\n\\t\\tint width = wall[0].back();\\n\\t\\tpriority_queue<Node, vector<Node>, cmp> q;\\n\\t\\tint ans = m;\\n\\t\\tint cnt = m;\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tq.push(Node(wall[i][0], i, 0));\\n\\t\\t}\\n\\t\\tvector<Node> temp;\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tNode node = q.top();\\n\\t\\t\\tif (node.val == width)break;\\n\\t\\t\\tif (temp.empty() || temp[0].val == node.val) {\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\tcnt--;\\n\\t\\t\\t\\tans = min(ans, cnt);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\twhile (!temp.empty()) {\\n\\t\\t\\t\\t\\tNode nn = temp.back(); temp.pop_back();\\n\\t\\t\\t\\t\\tnn.j++;\\n\\t\\t\\t\\t\\tnn.val = wall[nn.i][nn.j];\\n\\t\\t\\t\\t\\tq.push(nn);\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//cout << \"pop:\" << node.i << \"(\" << cnt << \")\" << node.val << endl;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 352573,
                "title": "java-priority-queue-solution-similar-to-minimum-meeting-rooms-required",
                "content": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        \\n        List<Tuple> flat = new ArrayList<>();\\n        for(List<Integer> list : wall) {\\n            int begin = 0;\\n            for(int i : list) {\\n                int end = begin + i;\\n                flat.add(new Tuple(begin, end));\\n                begin = end;\\n            }\\n        }\\n        \\n        PriorityQueue<Tuple> pq = new PriorityQueue<>((o1, o2) -> (o1.end - o2.end));\\n        Collections.sort(flat);\\n        \\n        int result = Integer.MAX_VALUE;\\n        for(int i=0; i<flat.size(); i++) {\\n            Tuple tuple = flat.get(i);\\n            if(tuple.start == 0) {\\n                pq.add(tuple);\\n                continue;\\n            }\\n            \\n            while(!pq.isEmpty() && pq.peek().end <= tuple.start) {\\n                pq.poll();\\n            }\\n            result = Math.min(result, pq.size());\\n            pq.add(tuple);\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? pq.size() : result;\\n    }\\n    \\n    class Tuple implements Comparable<Tuple> {\\n        int start;\\n        int end;\\n        \\n        public Tuple(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n        \\n        public int compareTo(Tuple tuple) {\\n            return this.start > tuple.start ? 1 : this.start < tuple.start ? -1 : 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        \\n        List<Tuple> flat = new ArrayList<>();\\n        for(List<Integer> list : wall) {\\n            int begin = 0;\\n            for(int i : list) {\\n                int end = begin + i;\\n                flat.add(new Tuple(begin, end));\\n                begin = end;\\n            }\\n        }\\n        \\n        PriorityQueue<Tuple> pq = new PriorityQueue<>((o1, o2) -> (o1.end - o2.end));\\n        Collections.sort(flat);\\n        \\n        int result = Integer.MAX_VALUE;\\n        for(int i=0; i<flat.size(); i++) {\\n            Tuple tuple = flat.get(i);\\n            if(tuple.start == 0) {\\n                pq.add(tuple);\\n                continue;\\n            }\\n            \\n            while(!pq.isEmpty() && pq.peek().end <= tuple.start) {\\n                pq.poll();\\n            }\\n            result = Math.min(result, pq.size());\\n            pq.add(tuple);\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? pq.size() : result;\\n    }\\n    \\n    class Tuple implements Comparable<Tuple> {\\n        int start;\\n        int end;\\n        \\n        public Tuple(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n        \\n        public int compareTo(Tuple tuple) {\\n            return this.start > tuple.start ? 1 : this.start < tuple.start ? -1 : 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351480,
                "title": "javascript-beats-100-8lines-simple-and-clean",
                "content": "```\\n\\n```var leastBricks = function(wall) {\\n    let map=new Map(), size=wall.length, max=0;\\n    for(let i=0; i<size; i++){\\n        let sum=0;\\n        for(let j=0; j<wall[i].length-1; j++){\\n            sum+= wall[i][j];\\n            map.set(sum, (map.get(sum) || 0)+1);\\n            max=Math.max(max, map.get(sum));\\n        }\\n    }\\n    return size-max;\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311585,
                "title": "python-beats-92-82",
                "content": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        if not wall:\\n            return 0\\n        holes = collections.defaultdict(int)\\n        for layer in wall:\\n            pos = 0\\n            for i in range(len(layer)-1):\\n                pos += layer[i]\\n                holes[pos] += 1\\n        n = len(wall)        \\n        thicks = [n - val for val in holes.values()]\\n        return min(thicks) if thicks else n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        if not wall:\\n            return 0\\n        holes = collections.defaultdict(int)\\n        for layer in wall:\\n            pos = 0\\n            for i in range(len(layer)-1):\\n                pos += layer[i]\\n                holes[pos] += 1\\n        n = len(wall)        \\n        thicks = [n - val for val in holes.values()]\\n        return min(thicks) if thicks else n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269086,
                "title": "python-1-liner-beats-90",
                "content": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - max(collections.Counter(sm for row in wall for sm in itertools.accumulate(row[:-1])).values(), default = 0)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - max(collections.Counter(sm for row in wall for sm in itertools.accumulate(row[:-1])).values(), default = 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 266478,
                "title": "python-2-lines-brick-end-point-counter",
                "content": "Choose the point of the highest frequency of end points of bricks in each layer of the wall. \\n```\\ndef leastBricks(self, wall: List[List[int]]) -> int:\\n\\tc = collections.Counter(itertools.chain(*[itertools.accumulate(layer[:-1]) for layer in wall]))\\n    return len(wall) if not c else len(wall) - c.most_common(1)[0][1] \\n```",
                "solutionTags": [],
                "code": "```\\ndef leastBricks(self, wall: List[List[int]]) -> int:\\n\\tc = collections.Counter(itertools.chain(*[itertools.accumulate(layer[:-1]) for layer in wall]))\\n    return len(wall) if not c else len(wall) - c.most_common(1)[0][1] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 242127,
                "title": "python-clean-solution-using-hashmap",
                "content": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        counter = collections.defaultdict(int)\\n        ans = 0\\n        for i in range(len(wall)):\\n            count = 0\\n            for j in range(len(wall[i])-1):\\n                count += wall[i][j]\\n                counter[count] += 1\\n                ans = max(ans,counter[count])\\n        return len(wall)-ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        counter = collections.defaultdict(int)\\n        ans = 0\\n        for i in range(len(wall)):\\n            count = 0\\n            for j in range(len(wall[i])-1):\\n                count += wall[i][j]\\n                counter[count] += 1\\n                ans = max(ans,counter[count])\\n        return len(wall)-ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212914,
                "title": "java-simple-code-with-hashmap",
                "content": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> edgeMap = new HashMap<>();\\n        int max = 0;\\n        for (List<Integer> row : wall) {\\n            int width = 0;\\n            for (int i = 0; i < row.size() - 1; i++) {\\n                width += row.get(i);\\n                edgeMap.put(width, edgeMap.getOrDefault(width, 0) + 1);\\n                max = Math.max(max, edgeMap.get(width));\\n            }\\n        }\\n        return wall.size() - max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> edgeMap = new HashMap<>();\\n        int max = 0;\\n        for (List<Integer> row : wall) {\\n            int width = 0;\\n            for (int i = 0; i < row.size() - 1; i++) {\\n                width += row.get(i);\\n                edgeMap.put(width, edgeMap.getOrDefault(width, 0) + 1);\\n                max = Math.max(max, edgeMap.get(width));\\n            }\\n        }\\n        return wall.size() - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202705,
                "title": "java-faster-than-100-9-ms",
                "content": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int[] a = new int[65536];\\n        for(List<Integer> b: wall)\\n        {\\n            int sum = 0;\\n            for(int i = 0;i < b.size() - 1;i++)\\n            {\\n                sum += b.get(i);\\n                a[sum]++;\\n            }\\n        }\\n        int max = 0;\\n        for(int j = 0;j < a.length;j++)\\n            if(max < a[j])\\n                max = a[j];\\n        return wall.size()-max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int[] a = new int[65536];\\n        for(List<Integer> b: wall)\\n        {\\n            int sum = 0;\\n            for(int i = 0;i < b.size() - 1;i++)\\n            {\\n                sum += b.get(i);\\n                a[sum]++;\\n            }\\n        }\\n        int max = 0;\\n        for(int j = 0;j < a.length;j++)\\n            if(max < a[j])\\n                max = a[j];\\n        return wall.size()-max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175031,
                "title": "c-99-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        if(wall.size()==0)\\n            return 0;\\n        unordered_map<int,int> m;\\n        for(auto j:wall) {\\n            int count=0;\\n            for(int k=0;k<j.size()-1;k++) {\\n                \\n                count = count+j[k];\\n                m[count]++;\\n            }\\n        }\\n        int max = 0;\\n        for(auto i:m) {\\n            if(max<i.second)\\n                max = i.second;\\n        }\\n        return wall.size()-max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        if(wall.size()==0)\\n            return 0;\\n        unordered_map<int,int> m;\\n        for(auto j:wall) {\\n            int count=0;\\n            for(int k=0;k<j.size()-1;k++) {\\n                \\n                count = count+j[k];\\n                m[count]++;\\n            }\\n        }\\n        int max = 0;\\n        for(auto i:m) {\\n            if(max<i.second)\\n                max = i.second;\\n        }\\n        return wall.size()-max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117055,
                "title": "a-simple-c-solution-beats-100-00-accepted-runtime-12ms",
                "content": "```\n#define SIZE 1000   \nstruct HashArray\n{\n    int key;\n    int count;\n    struct HashArray* next;\n}Hash[SIZE];       \nvoid addHash(int num)    \n{\n    int temp=abs(num%SIZE);     \n    if(Hash[temp].key==0)\n    {\n        Hash[temp].key=num;\n        Hash[temp].count++;\n    }else if(Hash[temp].key==num)\n    {\n        Hash[temp].count++;     \n    }else\n    {\n        struct HashArray *p=&Hash[temp]; \n        while(p->key!=num&&p->next!=NULL)    \n        {p=p->next;}\n        if(p->key==num)\n        {p->count++;}\n        else\n        {\n            p->next=(struct HashArray*)malloc(sizeof(struct HashArray));\n            p=p->next;\n            p->key=num;\n            p->count=1;\n            p->next=NULL;\n        }\n    }   \n}\nint leastBricks(int** wall, int wallRowSize, int *wallColSizes) {\n    int maxCount=0;\n    int sum=0;\n    struct HashArray *p;\n    for(int i=0;i<SIZE;i++){\n        Hash[i].key=0;\n        Hash[i].count=0;\n        Hash[i].next=NULL;\n    }\n    for(int i=0;i<wallRowSize;i++){\n        sum=0;\n        for(int j=0;j<wallColSizes[i]-1;j++){\n            sum=sum+wall[i][j];\n            addHash(sum);\n        }\n    }\n    for(int i=0;i<SIZE;i++){\n        if(Hash[i].count!=0)\n        {  \n            if(maxCount<Hash[i].count){\n                maxCount=Hash[i].count;\n            }\n            if(Hash[i].next!=NULL){\n                p=&Hash[i];\n                while(p->next!=NULL)    \n                {\n                    p=p->next;\n                    if(maxCount<p->count){\n                        maxCount=p->count;\n                    }\n                }\n            }  \n        }\n    }\n    return wallRowSize-maxCount;\n}\n````",
                "solutionTags": [],
                "code": "```\n#define SIZE 1000   \nstruct HashArray\n{\n    int key;\n    int count;\n    struct HashArray* next;\n}Hash[SIZE];       \nvoid addHash(int num)    \n{\n    int temp=abs(num%SIZE);     \n    if(Hash[temp].key==0)\n    {\n        Hash[temp].key=num;\n        Hash[temp].count++;\n    }else if(Hash[temp].key==num)\n    {\n        Hash[temp].count++;     \n    }else\n    {\n        struct HashArray *p=&Hash[temp]; \n        while(p->key!=num&&p->next!=NULL)    \n        {p=p->next;}\n        if(p->key==num)\n        {p->count++;}\n        else\n        {\n            p->next=(struct HashArray*)malloc(sizeof(struct HashArray));\n            p=p->next;\n            p->key=num;\n            p->count=1;\n            p->next=NULL;\n        }\n    }   \n}\nint leastBricks(int** wall, int wallRowSize, int *wallColSizes) {\n    int maxCount=0;\n    int sum=0;\n    struct HashArray *p;\n    for(int i=0;i<SIZE;i++){\n        Hash[i].key=0;\n        Hash[i].count=0;\n        Hash[i].next=NULL;\n    }\n    for(int i=0;i<wallRowSize;i++){\n        sum=0;\n        for(int j=0;j<wallColSizes[i]-1;j++){\n            sum=sum+wall[i][j];\n            addHash(sum);\n        }\n    }\n    for(int i=0;i<SIZE;i++){\n        if(Hash[i].count!=0)\n        {  \n            if(maxCount<Hash[i].count){\n                maxCount=Hash[i].count;\n            }\n            if(Hash[i].next!=NULL){\n                p=&Hash[i];\n                while(p->next!=NULL)    \n                {\n                    p=p->next;\n                    if(maxCount<p->count){\n                        maxCount=p->count;\n                    }\n                }\n            }  \n        }\n    }\n    return wallRowSize-maxCount;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101739,
                "title": "draw-a-line-through-the-most-common-sum",
                "content": "Find the most common sum of all the rows.\\nReturn the difference of wall size and most common sum.\\nThats it!!\\n```\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int max = Integer.MIN_VALUE;\\n        int sum = 0;        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(List<Integer> l : wall) {\\n            sum = 0;\\n            for(int i=0;i<l.size()-1;i++) {\\n                sum += l.get(i);\\n                map.put(sum, map.getOrDefault(sum,0)+1);\\n                max = Math.max(max, map.get(sum));\\n            }\\n        }\\n        return (max==Integer.MIN_VALUE)?wall.size():wall.size()-max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int max = Integer.MIN_VALUE;\\n        int sum = 0;        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(List<Integer> l : wall) {\\n            sum = 0;\\n            for(int i=0;i<l.size()-1;i++) {\\n                sum += l.get(i);\\n                map.put(sum, map.getOrDefault(sum,0)+1);\\n                max = Math.max(max, map.get(sum));\\n            }\\n        }\\n        return (max==Integer.MIN_VALUE)?wall.size():wall.size()-max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101742,
                "title": "easy-python-with-dictionary",
                "content": "## Brute Force way\\nMy first idea was to go through each column of the whole wall, but it would lead to TLE, since the length of a brick could be very huge:\\n```py\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        least = len(wall)\\n        while wall[0] and not (wall[0][0] == 1 and len(wall[0]) == 1):\\n            count = 0\\n            for row in wall:\\n                if row[0] == 1:\\n                    row.pop(0)\\n                else:\\n                    row[0] -= 1\\n                    count += 1\\n            least = min(least, count)\\n        return least\\n```\\n\\n## Using hashtable\\nThen I realized I only needed to count the occurrence of each brick space and used the height of wall to subtract the max occurrence of the space\\n```py\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        spaceMap = dict()\\n        for row in wall:\\n            spacelen = 0\\n            for brick in row[:-1]: # avoid counting wall edge\\n                spacelen += brick\\n                if spacelen not in spaceMap:\\n                    spaceMap[spacelen] = 1\\n                else:\\n                    spaceMap[spacelen] += 1\\n        least = len(wall) - max(spaceMap.values())\\n        return least\\n```\\n> Time Complexity: O(n), n for number of bricks\\n> Space Complexity: O(n)",
                "solutionTags": [],
                "code": "```py\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        least = len(wall)\\n        while wall[0] and not (wall[0][0] == 1 and len(wall[0]) == 1):\\n            count = 0\\n            for row in wall:\\n                if row[0] == 1:\\n                    row.pop(0)\\n                else:\\n                    row[0] -= 1\\n                    count += 1\\n            least = min(least, count)\\n        return least\\n```\n```py\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        spaceMap = dict()\\n        for row in wall:\\n            spacelen = 0\\n            for brick in row[:-1]: # avoid counting wall edge\\n                spacelen += brick\\n                if spacelen not in spaceMap:\\n                    spaceMap[spacelen] = 1\\n                else:\\n                    spaceMap[spacelen] += 1\\n        least = len(wall) - max(spaceMap.values())\\n        return least\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101745,
                "title": "simple-python",
                "content": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ans = len(wall)\\n        count = 0\\n        d = {}\\n        for w in wall:\\n            coverage = 0\\n            for brick in w[:-1]:\\n                coverage += brick\\n                d[coverage] = d.get(coverage, 0) + 1\\n                count = max(count, d.get(coverage, 0))\\n        return ans - count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ans = len(wall)\\n        count = 0\\n        d = {}\\n        for w in wall:\\n            coverage = 0\\n            for brick in w[:-1]:\\n                coverage += brick\\n                d[coverage] = d.get(coverage, 0) + 1\\n                count = max(count, d.get(coverage, 0))\\n        return ans - count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101751,
                "title": "consice-c-solution-using-unordered-map",
                "content": "The worst case scenario is that we have # of rows cuts which will basically cut every brick from each row. So we keep an unordered_set to store the possible cuts and how many time this cut has been visited by all the rows. Then # of rows + mincut (which is a minus number here) will get us the minimal cuts.\\n```\\n    int leastBricks(vector<vector<int>>& wall) \\n    {\\n        if(wall.empty()) return 0;\\n        int row = wall.size(), width = 0, minCut = 0;\\n        unordered_map<int, int> cut;\\n        for(int i=0; i<row; i++)\\n        {\\n            int rowWidth = 0;\\n            for(int j=0; j<wall[i].size()-1; j++) \\n            {\\n                rowWidth += wall[i][j];\\n                cut[rowWidth]--;\\n                minCut = min(minCut, cut[rowWidth]);\\n            }\\n        }\\n        return row+minCut;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int leastBricks(vector<vector<int>>& wall) \\n    {\\n        if(wall.empty()) return 0;\\n        int row = wall.size(), width = 0, minCut = 0;\\n        unordered_map<int, int> cut;\\n        for(int i=0; i<row; i++)\\n        {\\n            int rowWidth = 0;\\n            for(int j=0; j<wall[i].size()-1; j++) \\n            {\\n                rowWidth += wall[i][j];\\n                cut[rowWidth]--;\\n                minCut = min(minCut, cut[rowWidth]);\\n            }\\n        }\\n        return row+minCut;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101759,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        map = {}\\n        for i in range(len(wall)):\\n            sum = 0\\n            for j in range(0, len(wall[i])-1):\\n                sum += wall[i][j]\\n                if map.get(sum) is not None:\\n                    map[sum] += 1\\n                else:\\n                    map[sum] = 1\\n        return len(wall) - max(map.values()) if map.values() else len(wall)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        \"\"\"\\n        :type wall: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        map = {}\\n        for i in range(len(wall)):\\n            sum = 0\\n            for j in range(0, len(wall[i])-1):\\n                sum += wall[i][j]\\n                if map.get(sum) is not None:\\n                    map[sum] += 1\\n                else:\\n                    map[sum] = 1\\n        return len(wall) - max(map.values()) if map.values() else len(wall)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101768,
                "title": "c-hash-map-solution",
                "content": "```\\n    public int LeastBricks(IList<IList<int>> wall) {\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        int max = 0;\\n        \\n        foreach (IList<int> row in wall)\\n        {\\n            int sum = 0;\\n            for (int c = 0; c < row.Count - 1; c++)\\n            {\\n                sum += row[c];\\n                if (!map.ContainsKey(sum))\\n                {\\n                    map[sum] = 0;\\n                }\\n                map[sum]++;\\n                \\n                if (map[sum] > max) max = map[sum];\\n            }\\n        }\\n        \\n        return wall.Count - max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int LeastBricks(IList<IList<int>> wall) {\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        int max = 0;\\n        \\n        foreach (IList<int> row in wall)\\n        {\\n            int sum = 0;\\n            for (int c = 0; c < row.Count - 1; c++)\\n            {\\n                sum += row[c];\\n                if (!map.ContainsKey(sum))\\n                {\\n                    map[sum] = 0;\\n                }\\n                map[sum]++;\\n                \\n                if (map[sum] > max) max = map[sum];\\n            }\\n        }\\n        \\n        return wall.Count - max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102908,
                "title": "c-using-dictionary",
                "content": "# Intuition\\nCalculate all possible numbers of cells (where the sum of each row is the same and equals the total number of cells). Iterate through each row and identify positions where cutting is unnecessary. Save these positions in a dictionary. Finally, go through all items in the dictionary and find the position with the largest value, which indicates the fewest bricks to cut.\\n\\n# Approach\\nUse Dictionary to keep number of briks we do not need to cut.\\n\\n# Complexity\\n- Time complexity:\\nO(N * K) where K average number of element in row.\\n\\n- Space complexity:\\nDepends on number of cuts, possibly max = 10^8.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LeastBricks(IList<IList<int>> wall) {\\n        var cellsNumber = 0;\\n        for(var i = 0; i < wall[0].Count; i++) {\\n            cellsNumber += wall[0][i];\\n        }\\n\\n        if(cellsNumber == 1) {\\n            return wall.Count;\\n        }\\n\\n        var acc = new Dictionary<int, int>();\\n\\n        for(var i = 0; i < wall.Count; i++) {\\n            var runnigSum = 0;\\n            for(var j = 0; j < wall[i].Count; j++) {\\n                runnigSum += wall[i][j];\\n                if(runnigSum == cellsNumber) {\\n                    break;\\n                }\\n                if(!acc.ContainsKey(runnigSum)) {\\n                    acc.Add(runnigSum, 0);\\n                }\\n                acc[runnigSum]++;\\n            }\\n        }\\n\\n        var max = 0;\\n        foreach(var pair in acc) {\\n            max = Math.Max(max, pair.Value);\\n        }\\n\\n        return (wall.Count - max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LeastBricks(IList<IList<int>> wall) {\\n        var cellsNumber = 0;\\n        for(var i = 0; i < wall[0].Count; i++) {\\n            cellsNumber += wall[0][i];\\n        }\\n\\n        if(cellsNumber == 1) {\\n            return wall.Count;\\n        }\\n\\n        var acc = new Dictionary<int, int>();\\n\\n        for(var i = 0; i < wall.Count; i++) {\\n            var runnigSum = 0;\\n            for(var j = 0; j < wall[i].Count; j++) {\\n                runnigSum += wall[i][j];\\n                if(runnigSum == cellsNumber) {\\n                    break;\\n                }\\n                if(!acc.ContainsKey(runnigSum)) {\\n                    acc.Add(runnigSum, 0);\\n                }\\n                acc[runnigSum]++;\\n            }\\n        }\\n\\n        var max = 0;\\n        foreach(var pair in acc) {\\n            max = Math.Max(max, pair.Value);\\n        }\\n\\n        return (wall.Count - max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095945,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int maxGaps = 0;\\n\\n        for(List<Integer> row : wall) {\\n            int pos = 0;\\n            for(int i=0; i<row.size()-1; i++) {\\n                pos += row.get(i);\\n                map.put(pos, map.getOrDefault(pos, 0)+1);\\n                maxGaps = Math.max(maxGaps, map.get(pos));\\n            }\\n        }\\n\\n        return wall.size() - maxGaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int maxGaps = 0;\\n\\n        for(List<Integer> row : wall) {\\n            int pos = 0;\\n            for(int i=0; i<row.size()-1; i++) {\\n                pos += row.get(i);\\n                map.put(pos, map.getOrDefault(pos, 0)+1);\\n                maxGaps = Math.max(maxGaps, map.get(pos));\\n            }\\n        }\\n\\n        return wall.size() - maxGaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091098,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} wall\\n * @return {number}\\n */\\nvar leastBricks = function(wall) {\\n    const map = {};\\n    let max = 0;\\n\\n    for (const row of wall) {\\n      let sum = 0;\\n      for (let i = 0; i < row.length - 1; i++) {\\n        sum += row[i]; \\n        map[sum] = map[sum] + 1 || 1;\\n        max = Math.max(max, map[sum]);\\n      }\\n    }\\n\\n    return wall.length - max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} wall\\n * @return {number}\\n */\\nvar leastBricks = function(wall) {\\n    const map = {};\\n    let max = 0;\\n\\n    for (const row of wall) {\\n      let sum = 0;\\n      for (let i = 0; i < row.length - 1; i++) {\\n        sum += row[i]; \\n        map[sum] = map[sum] + 1 || 1;\\n        max = Math.max(max, map[sum]);\\n      }\\n    }\\n\\n    return wall.length - max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079520,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        myDict = {}\\n        myDict[0] = 0\\n        for i in range(len(wall)):\\n            var = 0\\n            for j in range(len(wall[i])-1):\\n                var += wall[i][j]\\n                if var not in myDict:\\n                    myDict[var] = 0\\n                myDict[var]+=1\\n        return len(wall) - max(myDict.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        myDict = {}\\n        myDict[0] = 0\\n        for i in range(len(wall)):\\n            var = 0\\n            for j in range(len(wall[i])-1):\\n                var += wall[i][j]\\n                if var not in myDict:\\n                    myDict[var] = 0\\n                myDict[var]+=1\\n        return len(wall) - max(myDict.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075300,
                "title": "easy-solution-using-hashmap",
                "content": "hash\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int sum=0;\\n        for(int i=0;i<wall.size();i++){\\n            sum=0;\\n            for(int j=0;j<wall.get(i).size();j++){\\n                sum+=wall.get(i).get(j);\\n                map.put(sum ,map.getOrDefault(sum,0)+1);\\n            }\\n        }\\n\\n        ArrayList<Integer> list = new ArrayList<>(map.values());\\n        Collections.sort(list,(b,a)->a-b);\\n        return list.size()==1?list.get(0):wall.size()-list.get(1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int sum=0;\\n        for(int i=0;i<wall.size();i++){\\n            sum=0;\\n            for(int j=0;j<wall.get(i).size();j++){\\n                sum+=wall.get(i).get(j);\\n                map.put(sum ,map.getOrDefault(sum,0)+1);\\n            }\\n        }\\n\\n        ArrayList<Integer> list = new ArrayList<>(map.values());\\n        Collections.sort(list,(b,a)->a-b);\\n        return list.size()==1?list.get(0):wall.size()-list.get(1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070026,
                "title": "c-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int, int> cross;\\n        int sum;\\n        for(vector<int> w: wall) {\\n            sum = 0;\\n            for(int a: w) {\\n                sum += a;\\n                cross[sum]++;\\n            }\\n        } \\n        int maxEdge = 0;\\n        for(auto iter: cross) {\\n            if(iter.first != sum)\\n                maxEdge = max(maxEdge, iter.second);\\n        }\\n        return wall.size() - maxEdge;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> cross;\\n        int ans = wall.size();\\n        for(vector<int> w: wall) {\\n            int sum = 0;\\n            for(int i = 0; i < w.size() - 1; i++) {\\n                sum += w[i];\\n                cross[sum]++;\\n                ans = min(ans, (int)wall.size() - cross[sum]);\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int, int> cross;\\n        int sum;\\n        for(vector<int> w: wall) {\\n            sum = 0;\\n            for(int a: w) {\\n                sum += a;\\n                cross[sum]++;\\n            }\\n        } \\n        int maxEdge = 0;\\n        for(auto iter: cross) {\\n            if(iter.first != sum)\\n                maxEdge = max(maxEdge, iter.second);\\n        }\\n        return wall.size() - maxEdge;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int, int> cross;\\n        int ans = wall.size();\\n        for(vector<int> w: wall) {\\n            int sum = 0;\\n            for(int i = 0; i < w.size() - 1; i++) {\\n                sum += w[i];\\n                cross[sum]++;\\n                ans = min(ans, (int)wall.size() - cross[sum]);\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069769,
                "title": "hashmap-easy-consice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        HashMap<Integer,Integer> map =new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<wall.size();i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<wall.get(i).size()-1;j++)\\n            {\\n               sum+= wall.get(i).get(j);\\n               map.put(sum,map.getOrDefault(sum,0)+1);\\n               //System.out.println(max);\\n               max=Math.max(max,map.get(sum));\\n            }\\n        }\\n        return wall.size()-max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        HashMap<Integer,Integer> map =new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<wall.size();i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<wall.get(i).size()-1;j++)\\n            {\\n               sum+= wall.get(i).get(j);\\n               map.put(sum,map.getOrDefault(sum,0)+1);\\n               //System.out.println(max);\\n               max=Math.max(max,map.get(sum));\\n            }\\n        }\\n        return wall.size()-max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063405,
                "title": "java-easy-upvote",
                "content": "# Code\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int r = wall.size();\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<r;i++){\\n            int count = 0;\\n            for(int j=0;j<wall.get(i).size()-1;j++){\\n                count+=wall.get(i).get(j);\\n                map.put(count,map.getOrDefault(count,0)+1);\\n            }\\n        }\\n        int n = wall.size();\\n        int max = 0;\\n        for(var v : map.values()){\\n            max=Math.max(max,v);\\n        }\\n        return r-max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> wall) {\\n        int r = wall.size();\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<r;i++){\\n            int count = 0;\\n            for(int j=0;j<wall.get(i).size()-1;j++){\\n                count+=wall.get(i).get(j);\\n                map.put(count,map.getOrDefault(count,0)+1);\\n            }\\n        }\\n        int n = wall.size();\\n        int max = 0;\\n        for(var v : map.values()){\\n            max=Math.max(max,v);\\n        }\\n        return r-max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032276,
                "title": "python-1-liner-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, use `accumulate` to calculate a prefix sum for each row (skip the last elements as these just bring us to the end of the wall). Then `chain` these and use a `Counter` to keep track of the number of edges. Finally, find the `max` number of edges and subtract it from the wall\\'s height to get the final result.\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$ - as we iterate over all the rows\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(n) $$ - for the `Counter`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - max(Counter(chain.from_iterable(accumulate(row[:-1]) for row in wall)).values(), default=0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        return len(wall) - max(Counter(chain.from_iterable(accumulate(row[:-1]) for row in wall)).values(), default=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031884,
                "title": "solution-using-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        #let n denote number of rows\\n        n = len(wall)\\n        #the answer will be n - maxNumberGoingThrough\\n        #use counter to track\\n        count = collections.Counter()\\n\\n        #let m denote the width of wall\\n        #so we can delete this entry in counter after the loop\\n        m = sum(wall[0])\\n        for row in wall:\\n            currIndex = 0\\n            for opening in row:\\n                currIndex += opening\\n                count[currIndex] += 1\\n        del count[m]\\n        if not count:\\n            return n\\n        return n - max(count.values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        #let n denote number of rows\\n        n = len(wall)\\n        #the answer will be n - maxNumberGoingThrough\\n        #use counter to track\\n        count = collections.Counter()\\n\\n        #let m denote the width of wall\\n        #so we can delete this entry in counter after the loop\\n        m = sum(wall[0])\\n        for row in wall:\\n            currIndex = 0\\n            for opening in row:\\n                currIndex += opening\\n                count[currIndex] += 1\\n        del count[m]\\n        if not count:\\n            return n\\n        return n - max(count.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023093,
                "title": "masum-code-c-easy-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>mp;\\n        int crosess=0;\\n        int maxi=0;\\n        for(int i=0;i<wall.size();i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<wall[i].size()-1;j++)\\n            {\\n                sum+=wall[i][j];\\n                mp[sum]++;\\n                maxi=max(maxi,mp[sum]);\\n            }\\n        }\\n        crosess=wall.size()-maxi;\\n        return crosess;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int>mp;\\n        int crosess=0;\\n        int maxi=0;\\n        for(int i=0;i<wall.size();i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<wall[i].size()-1;j++)\\n            {\\n                sum+=wall[i][j];\\n                mp[sum]++;\\n                maxi=max(maxi,mp[sum]);\\n            }\\n        }\\n        crosess=wall.size()-maxi;\\n        return crosess;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023063,
                "title": "c-simple-and-direct-brick-wall-solution-90-speed-99-memory",
                "content": "# Approach\\nThis is a simple **Sweep Line** problem. \\n\\nIn order to solve this problem, we can find the indices of the gaps between the bricks and find the maximum number of them at a given moment.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int size = wall.size();\\n\\n        vector<int>v;\\n        for(int i = 0; i < size; i++){\\n            int n = wall[i].size();\\n            int s = 0;\\n            for (int j = 0; j < n - 1; j++) {\\n                s+= wall[i][j];\\n                v.push_back(s);\\n            }\\n        }\\n\\n        sort(v.begin(), v.end());\\n\\n        int last = -1;\\n        int count = 0;\\n        int maxCount = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            if (v[i] == last) {\\n                count ++;\\n            } else {\\n                if (count > maxCount)\\n                    maxCount = count;\\n\\n                last = v[i];\\n                count = 1;\\n            }\\n        }\\n\\n        if (count > maxCount)\\n            maxCount = count;\\n\\n        return size - maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        int size = wall.size();\\n\\n        vector<int>v;\\n        for(int i = 0; i < size; i++){\\n            int n = wall[i].size();\\n            int s = 0;\\n            for (int j = 0; j < n - 1; j++) {\\n                s+= wall[i][j];\\n                v.push_back(s);\\n            }\\n        }\\n\\n        sort(v.begin(), v.end());\\n\\n        int last = -1;\\n        int count = 0;\\n        int maxCount = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            if (v[i] == last) {\\n                count ++;\\n            } else {\\n                if (count > maxCount)\\n                    maxCount = count;\\n\\n                last = v[i];\\n                count = 1;\\n            }\\n        }\\n\\n        if (count > maxCount)\\n            maxCount = count;\\n\\n        return size - maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018718,
                "title": "python3-simple-counting",
                "content": "# Code\\n```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        width = sum(wall[0])\\n        cnt = collections.defaultdict(int)\\n        \\n        for row in wall:\\n            cur = 0\\n            for j in row:\\n                cur += j\\n                if cur == width: continue\\n                cnt[cur]+=1\\n\\n        maxCnt = 0\\n        for k, v in cnt.items():\\n            maxCnt = max(maxCnt, v)\\n\\n        return len(wall) - maxCnt\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        width = sum(wall[0])\\n        cnt = collections.defaultdict(int)\\n        \\n        for row in wall:\\n            cur = 0\\n            for j in row:\\n                cur += j\\n                if cur == width: continue\\n                cnt[cur]+=1\\n\\n        maxCnt = 0\\n        for k, v in cnt.items():\\n            maxCnt = max(maxCnt, v)\\n\\n        return len(wall) - maxCnt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018031,
                "title": "c-easy-to-understand-self-explanatory",
                "content": "![Screenshot (1117).png](https://assets.leetcode.com/users/images/1e3d2cb8-28de-4df6-8dab-7f95384ae832_1694173050.1851647.png)\\nstep1) here i have to count number of cross as in question if i somehow manage to find the number of no cross line then we will be able to return the answer\\nstep2) here after observation we can see that we will be able to cross it . we count how much such sum exist . \\nhere we find total sum as the sum after sum of each line should not be counted as this will lead ouside our range so we try to avoid this by ignoring this while finding the number of ways\\nstwp3) we have to return total number of cross which will be nothing but wallsize-number of gap bars\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int,int>mp;\\n  int sum1=accumulate(wall[0].begin(),wall[0].end(),0);\\n  int sum2=wall.size();\\n     \\n        int ans=0;\\n        for(auto value:wall){\\n            int sum=0;\\n            for(int value1:value){\\n                sum+=value1;\\n                mp[sum]++;\\n            }\\n        }\\n        for(auto value:mp){\\n            if(value.first!=sum1){\\n            ans=max(ans,value.second);\\n            }\\n            \\n        }\\n        return sum2-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        map<int,int>mp;\\n  int sum1=accumulate(wall[0].begin(),wall[0].end(),0);\\n  int sum2=wall.size();\\n     \\n        int ans=0;\\n        for(auto value:wall){\\n            int sum=0;\\n            for(int value1:value){\\n                sum+=value1;\\n                mp[sum]++;\\n            }\\n        }\\n        for(auto value:mp){\\n            if(value.first!=sum1){\\n            ans=max(ans,value.second);\\n            }\\n            \\n        }\\n        return sum2-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007518,
                "title": "simple-javascript-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nPEDAC Process\\n\\nUnderstand the Problem (P):\\n\\nWe have a rectangular wall composed of rows of bricks.\\nWe want to draw a vertical line from the top to the bottom and cross the least number of bricks.\\nThe width of the wall is the length of the longest row.\\nWe are given a list of lists wall where each sublist represents a row of bricks.\\nWe need to find the minimum number of crossed bricks after drawing the vertical line.\\nExamples/Test Cases (E):\\n\\nLet\\'s consider some examples to understand the problem better:\\n\\nwall = [[1,2,2,1], [3,1,2], [1,3,2], [2,4], [3,1,2], [1,3,1,1]]\\nDrawing the vertical line at the 4th index (1-indexed) avoids crossing any bricks, so the result is 0.\\nwall = [[1], [1], [1]]\\nIn this case, there is only one column, so the line will cross all the bricks. The result is 3.\\nData Structure (D):\\n\\nTo solve this problem, we may use a dictionary (or map) to keep track of the number of times we encounter a specific position while iterating through the rows.\\n\\nAlgorithm (A):\\n\\nInitialize a dictionary to store the frequency of positions where the vertical line crosses.\\nIterate through each row in the wall.\\nFor each row, calculate the cumulative sum of brick widths from left to right.\\nFor each cumulative sum (position), update the dictionary to record how many times we\\'ve encountered that position.\\nFind the position with the highest frequency in the dictionary.\\nReturn the total number of rows minus the highest frequency (minimum number of crossed bricks).\\n*/\\n\\n/**\\n * @param {number[][]} wall\\n * @return {number}\\n */\\nvar leastBricks = function(wall) {\\n    let countGaps = { 0: 0};\\n\\n    for (let i = 0; i < wall.length; i += 1) {\\n        let sum = 0;\\n        for (let j = 0; j < wall[i].length - 1; j += 1) {\\n            sum += wall[i][j];\\n            if (String(sum) in countGaps) {\\n                let value = countGaps[String(sum)];\\n                value += 1;\\n                countGaps[String(sum)] = value;\\n            } else {\\n                countGaps[String(sum)] = 1;\\n            }\\n        }\\n    }\\n\\n    console.log(countGaps);\\n\\n    let gaps = Object.values(countGaps);\\n    let maxGap = Math.max(...gaps);\\n    console.log(`maximum gap is ${maxGap}.`);\\n    return wall.length - maxGap;\\n};\\n\\n// time coplexity O(n^2) or the number of bricks we have in our input.\\n// space complexity: whatever the length of the rows happend to be.\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nPEDAC Process\\n\\nUnderstand the Problem (P):\\n\\nWe have a rectangular wall composed of rows of bricks.\\nWe want to draw a vertical line from the top to the bottom and cross the least number of bricks.\\nThe width of the wall is the length of the longest row.\\nWe are given a list of lists wall where each sublist represents a row of bricks.\\nWe need to find the minimum number of crossed bricks after drawing the vertical line.\\nExamples/Test Cases (E):\\n\\nLet\\'s consider some examples to understand the problem better:\\n\\nwall = [[1,2,2,1], [3,1,2], [1,3,2], [2,4], [3,1,2], [1,3,1,1]]\\nDrawing the vertical line at the 4th index (1-indexed) avoids crossing any bricks, so the result is 0.\\nwall = [[1], [1], [1]]\\nIn this case, there is only one column, so the line will cross all the bricks. The result is 3.\\nData Structure (D):\\n\\nTo solve this problem, we may use a dictionary (or map) to keep track of the number of times we encounter a specific position while iterating through the rows.\\n\\nAlgorithm (A):\\n\\nInitialize a dictionary to store the frequency of positions where the vertical line crosses.\\nIterate through each row in the wall.\\nFor each row, calculate the cumulative sum of brick widths from left to right.\\nFor each cumulative sum (position), update the dictionary to record how many times we\\'ve encountered that position.\\nFind the position with the highest frequency in the dictionary.\\nReturn the total number of rows minus the highest frequency (minimum number of crossed bricks).\\n*/\\n\\n/**\\n * @param {number[][]} wall\\n * @return {number}\\n */\\nvar leastBricks = function(wall) {\\n    let countGaps = { 0: 0};\\n\\n    for (let i = 0; i < wall.length; i += 1) {\\n        let sum = 0;\\n        for (let j = 0; j < wall[i].length - 1; j += 1) {\\n            sum += wall[i][j];\\n            if (String(sum) in countGaps) {\\n                let value = countGaps[String(sum)];\\n                value += 1;\\n                countGaps[String(sum)] = value;\\n            } else {\\n                countGaps[String(sum)] = 1;\\n            }\\n        }\\n    }\\n\\n    console.log(countGaps);\\n\\n    let gaps = Object.values(countGaps);\\n    let maxGap = Math.max(...gaps);\\n    console.log(`maximum gap is ${maxGap}.`);\\n    return wall.length - maxGap;\\n};\\n\\n// time coplexity O(n^2) or the number of bricks we have in our input.\\n// space complexity: whatever the length of the rows happend to be.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3995713,
                "title": "best-java-solution-hashmap-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> arr) {\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<arr.size(); i++){\\n            int count = 0;\\n            for(int j=0; j<arr.get(i).size()-1; j++){\\n                count+= arr.get(i).get(j);\\n                hp.put(count,hp.getOrDefault(count,0)+1);\\n            }\\n        }\\n\\n        int n = arr.size();\\n        int max = 0;\\n\\n        for(var a : hp.values()){\\n            max = Math.max(max,a);\\n        }\\n\\n        return n-max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int leastBricks(List<List<Integer>> arr) {\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<arr.size(); i++){\\n            int count = 0;\\n            for(int j=0; j<arr.get(i).size()-1; j++){\\n                count+= arr.get(i).get(j);\\n                hp.put(count,hp.getOrDefault(count,0)+1);\\n            }\\n        }\\n\\n        int n = arr.size();\\n        int max = 0;\\n\\n        for(var a : hp.values()){\\n            max = Math.max(max,a);\\n        }\\n\\n        return n-max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972734,
                "title": "c-easiest-solution",
                "content": "# Intuition\\nSelect the most occuring boundary. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> ump; \\n        int tsum = 0;\\n        for(auto row : wall) {\\n            int csm = 0;\\n            for(int width: row) {\\n                csm += width;\\n                ump[csm]++;\\n            }\\n            tsum = csm;\\n        }\\n        int mx = 0, sm = 0;\\n        for(auto pr : ump) {\\n            if(pr.first == tsum) continue;\\n            if(pr.second > mx) {\\n                mx = pr.second;\\n                sm = pr.first;\\n            }\\n        }\\n\\n        return (int)wall.size() - mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> ump; \\n        int tsum = 0;\\n        for(auto row : wall) {\\n            int csm = 0;\\n            for(int width: row) {\\n                csm += width;\\n                ump[csm]++;\\n            }\\n            tsum = csm;\\n        }\\n        int mx = 0, sm = 0;\\n        for(auto pr : ump) {\\n            if(pr.first == tsum) continue;\\n            if(pr.second > mx) {\\n                mx = pr.second;\\n                sm = pr.first;\\n            }\\n        }\\n\\n        return (int)wall.size() - mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971535,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSaving number of bricks ending at a perticular width of a row. Total rows - the maximum of that length is the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nm: number of rows\\nn: total width of a row\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        dp, mx = {}, 0\\n        for row in wall:\\n            width = 0\\n            for brick in row[:-1]:\\n                width += brick\\n                dp.setdefault(width, 0)\\n                dp[width] += 1\\n                mx = max(mx, dp[width])\\n        return len(wall) - mx\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def leastBricks(self, wall):\\n        dp, mx = {}, 0\\n        for row in wall:\\n            width = 0\\n            for brick in row[:-1]:\\n                width += brick\\n                dp.setdefault(width, 0)\\n                dp[width] += 1\\n                mx = max(mx, dp[width])\\n        return len(wall) - mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970350,
                "title": "c-solution-using-hashmap",
                "content": "// Time complexity: O(n x m)\\n// Space complexity: O(n x m)\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        // Create a hashmap to count gaps in each row\\n        unordered_map<int, int> countGap;\\n        \\n        int rows = wall.size();  // Get the number of rows in the wall\\n        int cols;  // Initialize variable to store the number of columns in each row\\n        int maxGap = 0;  // Initialize a variable to track the maximum gap count\\n        \\n        // Iterate through each row in the wall\\n        for (int i = 0; i < rows; i++) {\\n            int total = 0;  // Initialize a variable to keep track of the current total\\n            \\n            // \\'-1\\' because the edge of the wall is not considered\\n            cols = wall[i].size() - 1;  // Calculate the number of columns in the current row\\n            \\n            // Iterate through the columns in the current row\\n            for (int j = 0; j < cols; j++) {\\n                total += wall[i][j];  // Increment the total with the current brick\\'s width\\n                \\n                // Check if the current total already exists in the hashmap\\n                if (countGap.find(total) != countGap.end()) {\\n                    countGap[total]++;  // If yes, increment the gap count at that position\\n                } else {\\n                    countGap[total] = 1;  // If not, create a new entry with gap count 1\\n                }\\n                \\n                // Update the maximum gap count with the current gap count\\n                maxGap = max(maxGap, countGap[total]);\\n            }\\n        }\\n        \\n        // Return the difference between the total number of rows and the maximum gap count\\n        return rows - maxGap;\\n    }\\n};\\n\\n/*\\n\\nint main() {\\n    Solution solution;\\n    \\n    // Create a 2D vector representing the wall\\n    vector<vector<int>> wall = {\\n        {1, 2, 2, 1},\\n        {3, 1, 2},\\n        {1, 3, 2},\\n        {2, 4},\\n        {3, 1, 2},\\n        {1, 3, 1, 1}\\n    };\\n    \\n    // Call the leastBricks function to find the minimum number of bricks to cross\\n    int result = solution.leastBricks(wall);\\n    \\n    // Print the result\\n    cout << \"Minimum number of bricks to cross: \" << result << endl;\\n    \\n    return 0;\\n}\\n*/\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        // Create a hashmap to count gaps in each row\\n        unordered_map<int, int> countGap;\\n        \\n        int rows = wall.size();  // Get the number of rows in the wall\\n        int cols;  // Initialize variable to store the number of columns in each row\\n        int maxGap = 0;  // Initialize a variable to track the maximum gap count\\n        \\n        // Iterate through each row in the wall\\n        for (int i = 0; i < rows; i++) {\\n            int total = 0;  // Initialize a variable to keep track of the current total\\n            \\n            // \\'-1\\' because the edge of the wall is not considered\\n            cols = wall[i].size() - 1;  // Calculate the number of columns in the current row\\n            \\n            // Iterate through the columns in the current row\\n            for (int j = 0; j < cols; j++) {\\n                total += wall[i][j];  // Increment the total with the current brick\\'s width\\n                \\n                // Check if the current total already exists in the hashmap\\n                if (countGap.find(total) != countGap.end()) {\\n                    countGap[total]++;  // If yes, increment the gap count at that position\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3963315,
                "title": "c-solution-using-hashmap",
                "content": "#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        unordered_map<int , int> countGap;\\n        \\n        for(const auto& r : wall){\\n            int total = 0;\\n            \\n            for(int b : r){\\n                total += b;\\n                countGap[total]++;\\n            }\\n        }\\n        \\n        int maxGap = 0;\\n        \\n        for(const auto& map : countGap){\\n            maxGap = max(maxGap , map.second);\\n        }\\n        \\n        return wall.size() - maxGap;\\n        \\n    }\\n};\\n\\n/*\\nint main()\\n{\\n    vector<vector<int>> wall = {\\n        {1, 2, 2, 1},\\n        {3, 1, 2},\\n        {1, 3, 2},\\n        {2, 4},\\n        {3, 1, 2},\\n        {1, 3, 1, 1}\\n    };\\n\\n    Solution solution;\\n    int result = solution.leastBricks(wall);\\n    \\n    // Debug prints\\n    for (const auto& r : wall) {\\n        for (int b : r) {\\n            cout << b << \" \";\\n        }\\n        cout << endl;\\n    }\\n    \\n    cout << \"Result: \" << result << endl;\\n\\n    return 0;\\n}\\n*/\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        \\n        unordered_map<int , int> countGap;\\n        \\n        for(const auto& r : wall){\\n            int total = 0;\\n            \\n            for(int b : r){\\n                total += b;\\n                countGap[total]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3963282,
                "title": "python3-solution-using-hashmaps",
                "content": "class Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        \\n        ## create a hashmap for counting gaps at every postion \\n        ## initialize it with 0,0\\n        \\n        countGap = {0:0}\\n        \\n        for r in wall:\\n            total = 0\\n            ## every brick position except the last because its mentioned in the question\\n            for b in r[:-1]:\\n                total+=b\\n                countGap[total] = 1 + countGap.get(total,0)\\n                \\n        return len(wall) - max(countGap.values())      \\n        \\n# Create an instance of the Solution class\\n##solution = Solution()\\n\\n# Example wall\\n##wall = [\\n##    [1, 2, 2, 1],\\n##    [3, 1, 2],\\n##    [1, 3, 2],\\n##    [2, 4],\\n##    [3, 1, 2],\\n##    [1, 3, 1, 1]\\n##]\\n\\n##result = solution.leastBricks(wall)\\n##print(result)  # Debug print to see the final result##",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def leastBricks(self, wall: List[List[int]]) -> int:\\n        \\n        ## create a hashmap for counting gaps at every postion \\n        ## initialize it with 0,0\\n        \\n        countGap = {0:0}",
                "codeTag": "Java"
            },
            {
                "id": 3959160,
                "title": "easy-solution-beginner-friendly-hash-map-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> end_count;\\n        int end_brick = 0, maks = 0;\\n        int row = wall.size(), col;\\n        for(int i=0; i<row; i++){\\n            end_brick = 0;\\n            col = wall[i].size() - 1;\\n            for(int j=0; j<col; j++){\\n                end_brick += wall[i][j];\\n                if(end_count.find(end_brick)!=end_count.end()){\\n                    end_count[end_brick]++;\\n                }\\n                else{\\n                    end_count[end_brick] = 1;\\n                }\\n                maks = max(maks,end_count[end_brick]);\\n            }\\n        }\\n        return row - maks;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leastBricks(vector<vector<int>>& wall) {\\n        unordered_map<int,int> end_count;\\n        int end_brick = 0, maks = 0;\\n        int row = wall.size(), col;\\n        for(int i=0; i<row; i++){\\n            end_brick = 0;\\n            col = wall[i].size() - 1;\\n            for(int j=0; j<col; j++){\\n                end_brick += wall[i][j];\\n                if(end_count.find(end_brick)!=end_count.end()){\\n                    end_count[end_brick]++;\\n                }\\n                else{\\n                    end_count[end_brick] = 1;\\n                }\\n                maks = max(maks,end_count[end_brick]);\\n            }\\n        }\\n        return row - maks;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1794897,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1573455,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1998671,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1847600,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1684120,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 2035314,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1880897,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1784749,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1574316,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 2044922,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1794897,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1573455,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1998671,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1847600,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1684120,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 2035314,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1880897,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1784749,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 1574316,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            },
            {
                "id": 2044922,
                "content": [
                    {
                        "username": "godshiva",
                        "content": "I think problem would be a lot easier to understand if it weren\\'t for that picture\\ndrawing [problem] bricks as multiple [real] bricks seems like a poor idea for explanatory purposes"
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "WHY IN THE SWEET WORLD IS THIS MEDIUM , ITS JUST RAW COUNTING !"
                    },
                    {
                        "username": "ridhamkhandar18",
                        "content": "WHat the hell is this question -_-"
                    },
                    {
                        "username": "neeravjain1999",
                        "content": "The image just makes it a lot more confusing, Its a normal problem!"
                    },
                    {
                        "username": "apjo2009",
                        "content": "im not able to understand the first input and output. how is one \"drawing\" a f***g line??? sorry but really getting frustrated, first the tiny url encode/decode shit, and now this!"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Prefix Sum will help you, think about it. "
                    },
                    {
                        "username": "harsh-fbx",
                        "content": "Ban gaya bhaiiiiii, maza aaa gaya \\uD83D\\uDE02"
                    },
                    {
                        "username": "apjo2009",
                        "content": "There used to be a time when some examples had a 1 line explanation, why aren\\'t examples having explanations anymore it still confuses the F out of me./rant"
                    },
                    {
                        "username": "amarao",
                        "content": "I'm a single person thought about not counting last brick at all, I'm not?\n\n```rust\n\n            for brick in row[..row.len()-1].iter() {  // End of last brick is not counted\n```\n\nThe trick is to ignore last brick, because we can't use 'gap' after last brick to draw a line.\n\nAlso, I completely baffled by 'wall.len'. According to the picture it should be 'wall.height'."
                    },
                    {
                        "username": "vivekyadav7272",
                        "content": "Nice to see another fellow coding in Rust.\nAnd no you're not the only one."
                    },
                    {
                        "username": "jordanNg",
                        "content": "So after learning the hard way that this problem requires us to use a hash map, I looked it up and found that you are able to map keys to values and on average have constant-time complexity. Pretty great! \\n\\nBut I was wondering why this doesn\\'t use up as much memory as a dynamically allocated array would, even though both containers are required to store the same number of values?"
                    },
                    {
                        "username": "madiii",
                        "content": "correct me if I\\'m wrong but i don\\'t think they both require same space as map will be storing only all possible prefix sum values whereas array will be of the size of the wall length"
                    },
                    {
                        "username": "geeky8",
                        "content": "I have a doubt, if the max(wall.length)= 10^4 and in worst case scenario all rows max(wall[i].length) = 10^4 then how does it fit under the given complexity?\\nIf someone can explain"
                    }
                ]
            }
        ]
    }
]