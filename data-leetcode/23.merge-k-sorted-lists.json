[
    {
        "title": "Merge k Sorted Lists",
        "question_content": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\n&nbsp;\nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\nExample 2:\n\nInput: lists = []\nOutput: []\n\nExample 3:\n\nInput: lists = [[]]\nOutput: []\n\n&nbsp;\nConstraints:\n\n\tk == lists.length\n\t0 <= k <= 104\n\t0 <= lists[i].length <= 500\n\t-104 <= lists[i][j] <= 104\n\tlists[i] is sorted in ascending order.\n\tThe sum of lists[i].length will not exceed 104.",
        "solutions": [
            {
                "id": 10528,
                "title": "a-java-solution-based-on-priority-queue",
                "content": "If someone understand how priority queue works, then it would be trivial to walk through the codes. \\n\\nMy question: is that possible to solve this question under the same time complexity without implementing the priority queue?\\n\\n\\n    public class Solution {\\n        public ListNode mergeKLists(List<ListNode> lists) {\\n            if (lists==null||lists.size()==0) return null;\\n            \\n            PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){\\n                @Override\\n                public int compare(ListNode o1,ListNode o2){\\n                    if (o1.val<o2.val)\\n                        return -1;\\n                    else if (o1.val==o2.val)\\n                        return 0;\\n                    else \\n                        return 1;\\n                }\\n            });\\n            \\n            ListNode dummy = new ListNode(0);\\n            ListNode tail=dummy;\\n            \\n            for (ListNode node:lists)\\n                if (node!=null)\\n                    queue.add(node);\\n                \\n            while (!queue.isEmpty()){\\n                tail.next=queue.poll();\\n                tail=tail.next;\\n                \\n                if (tail.next!=null)\\n                    queue.add(tail.next);\\n            }\\n            return dummy.next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode mergeKLists(List<ListNode> lists) {\\n            if (lists==null||lists.size()==0) return null;\\n            \\n            PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){\\n                @Override\\n                public int compare(ListNode o1,ListNode o2){\\n                    if (o1.val<o2.val)\\n                        return -1;\\n                    else if (o1.val==o2.val)\\n                        return 0;\\n                    else \\n                        return 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 10531,
                "title": "sharing-my-straightforward-c-solution-without-data-structure-other-than-vector",
                "content": "    ListNode *mergeKLists(vector<ListNode *> &lists) {\\n        if(lists.empty()){\\n            return nullptr;\\n        }\\n        while(lists.size() > 1){\\n            lists.push_back(mergeTwoLists(lists[0], lists[1]));\\n            lists.erase(lists.begin());\\n            lists.erase(lists.begin());\\n        }\\n        return lists.front();\\n    }\\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\\n        if(l1 == nullptr){\\n            return l2;\\n        }\\n        if(l2 == nullptr){\\n            return l1;\\n        }\\n        if(l1->val <= l2->val){\\n            l1->next = mergeTwoLists(l1->next, l2);\\n            return l1;\\n        }\\n        else{\\n            l2->next = mergeTwoLists(l1, l2->next);\\n            return l2;\\n        }\\n    }\\n\\nThe second function is from Merge Two Sorted Lists. \\n\\nThe basic idea is really simple. We can merge first two lists and then push it back. Keep doing this until there is only one list left in vector. Actually, we can regard this as an iterative divide-and-conquer solution.",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "    ListNode *mergeKLists(vector<ListNode *> &lists) {\\n        if(lists.empty()){\\n            return nullptr;\\n        }\\n        while(lists.size() > 1){\\n            lists.push_back(mergeTwoLists(lists[0], lists[1]));\\n            lists.erase(lists.begin());\\n            lists.erase(lists.begin());\\n        }\\n        return lists.front();\\n    }\\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\\n        if(l1 == nullptr){\\n            return l2;\\n        }\\n        if(l2 == nullptr){\\n            return l1;\\n        }\\n        if(l1->val <= l2->val){\\n            l1->next = mergeTwoLists(l1->next, l2);\\n            return l1;\\n        }\\n        else{\\n            l2->next = mergeTwoLists(l1, l2->next);\\n            return l2;\\n        }\\n    }\\n\\nThe second function is from Merge Two Sorted Lists. \\n\\nThe basic idea is really simple. We can merge first two lists and then push it back. Keep doing this until there is only one list left in vector. Actually, we can regard this as an iterative divide-and-conquer solution.",
                "codeTag": "Unknown"
            },
            {
                "id": 10522,
                "title": "my-simple-java-solution-use-recursion",
                "content": "    public static ListNode mergeKLists(ListNode[] lists){\\n        return partion(lists,0,lists.length-1);\\n    }\\n\\n    public static ListNode partion(ListNode[] lists,int s,int e){\\n        if(s==e)  return lists[s];\\n        if(s<e){\\n            int q=(s+e)/2;\\n            ListNode l1=partion(lists,s,q);\\n            ListNode l2=partion(lists,q+1,e);\\n            return merge(l1,l2);\\n        }else\\n            return null;\\n    }\\n\\n    //This function is from Merge Two Sorted Lists.\\n    public static ListNode merge(ListNode l1,ListNode l2){\\n        if(l1==null) return l2;\\n        if(l2==null) return l1;\\n        if(l1.val<l2.val){\\n            l1.next=merge(l1.next,l2);\\n            return l1;\\n        }else{\\n            l2.next=merge(l1,l2.next);\\n            return l2;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static ListNode mergeKLists(ListNode[] lists){\\n        return partion(lists,0,lists.length-1);\\n    }\\n\\n    public static ListNode partion(ListNode[] lists,int s,int e){\\n        if(s==e)  return lists[s];\\n        if(s<e){\\n            int q=(s+e)/2;\\n            ListNode l1=partion(lists,s,q);\\n            ListNode l2=partion(lists,q+1,e);\\n            return merge(l1,l2);\\n        }else\\n            return null;\\n    }\\n\\n    //This function is from Merge Two Sorted Lists.\\n    public static ListNode merge(ListNode l1,ListNode l2){\\n        if(l1==null) return l2;\\n        if(l2==null) return l1;\\n        if(l1.val<l2.val){\\n            l1.next=merge(l1.next,l2);\\n            return l1;\\n        }else{\\n            l2.next=merge(l1,l2.next);\\n            return l2;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10919,
                "title": "python-easy-to-understand-divide-and-conquer-solution",
                "content": "```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        if not lists:\\n            return None\\n        if len(lists) == 1:\\n            return lists[0]\\n        mid = len(lists) // 2\\n        l, r = self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:])\\n        return self.merge(l, r)\\n    \\n    def merge(self, l, r):\\n        dummy = p = ListNode()\\n        while l and r:\\n            if l.val < r.val:\\n                p.next = l\\n                l = l.next\\n            else:\\n                p.next = r\\n                r = r.next\\n            p = p.next\\n        p.next = l or r\\n        return dummy.next\\n    \\n    def merge1(self, l, r):\\n        if not l or not r:\\n            return l or r\\n        if l.val< r.val:\\n            l.next = self.merge(l.next, r)\\n            return l\\n        r.next = self.merge(l, r.next)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        if not lists:\\n            return None\\n        if len(lists) == 1:\\n            return lists[0]\\n        mid = len(lists) // 2\\n        l, r = self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:])\\n        return self.merge(l, r)\\n    \\n    def merge(self, l, r):\\n        dummy = p = ListNode()\\n        while l and r:\\n            if l.val < r.val:\\n                p.next = l\\n                l = l.next\\n            else:\\n                p.next = r\\n                r = r.next\\n            p = p.next\\n        p.next = l or r\\n        return dummy.next\\n    \\n    def merge1(self, l, r):\\n        if not l or not r:\\n            return l or r\\n        if l.val< r.val:\\n            l.next = self.merge(l.next, r)\\n            return l\\n        r.next = self.merge(l, r.next)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10527,
                "title": "difference-between-priority-queue-and-heap-and-c-implementation",
                "content": "I have seen lots of solutions confuse `priority queue` with `heap`. I find a good [link][1] and list the talk below.\\n\\n**Concept:**\\n\\n1.`Heap` is a kind of `data structure`. It is a name for a particular way of storing data that makes certain operations very efficient. We can use a tree or array to describe it.\\n\\n       18\\n      /\\t\\\\\\n     10\\t 16\\n    / \\\\   / \\\\\\n    9  5  8  12\\n    \\n    18, 10, 16, 9, 5, 8, 12\\n\\n2.`Priority queue` is an `abstract datatype`. It is a shorthand way of describing a particular interface and behavior, and says nothing about the underlying implementation.\\n\\nA heap is a very good data structure to implement a priority queue. The operations which are made efficient by the heap data structure are the operations that the priority queue interface needs.\\n\\n\\n**Implementation: c++** \\n\\n1.`priority_queue`: we can only get the top element (from ChiangKaiShrek's [solution][2])\\n\\n    struct compare {\\n        bool operator()(const ListNode* l, const ListNode* r) {\\n            return l->val > r->val;\\n        }\\n    };\\n    ListNode *mergeKLists(vector<ListNode *> &lists) { //priority_queue\\n        priority_queue<ListNode *, vector<ListNode *>, compare> q;\\n        for(auto l : lists) {\\n            if(l)  q.push(l);\\n        }\\n        if(q.empty())  return NULL;\\n\\n        ListNode* result = q.top();\\n        q.pop();\\n        if(result->next) q.push(result->next);\\n        ListNode* tail = result;            \\n        while(!q.empty()) {\\n            tail->next = q.top();\\n            q.pop();\\n            tail = tail->next;\\n            if(tail->next) q.push(tail->next);\\n        }\\n        return result;\\n    }\\n\\n2.`make_heap`: we can access all the elements (from my answer for that solution)\\n\\n    static bool heapComp(ListNode* a, ListNode* b) {\\n            return a->val > b->val;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) { //make_heap\\n        ListNode head(0);\\n        ListNode *curNode = &head;\\n        vector<ListNode*> v;   \\n        for(int i =0; i<lists.size(); i++){\\n            if(lists[i]) v.push_back(lists[i]);\\n        }\\n        make_heap(v.begin(), v.end(), heapComp); //vector -> heap data strcture\\n    \\n        while(v.size()>0){\\n            curNode->next=v.front();\\n            pop_heap(v.begin(), v.end(), heapComp); \\n            v.pop_back(); \\n            curNode = curNode->next;\\n            if(curNode->next) {\\n                v.push_back(curNode->next); \\n                push_heap(v.begin(), v.end(), heapComp);\\n            }\\n        }\\n        return head.next;\\n    }\\n\\nIf there is something wrong, please figure it out. Hoping to learn more about them.\\n\\n\\n  [1]: http://stackoverflow.com/questions/18993269/difference-between-priority-queue-and-a-heap\\n  [2]: https://leetcode.com/discuss/21363/brief-c-solution-with-priority_queue",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "I have seen lots of solutions confuse `priority queue` with `heap`. I find a good [link][1] and list the talk below.\\n\\n**Concept:**\\n\\n1.`Heap` is a kind of `data structure`. It is a name for a particular way of storing data that makes certain operations very efficient. We can use a tree or array to describe it.\\n\\n       18\\n      /\\t\\\\\\n     10\\t 16\\n    / \\\\   / \\\\\\n    9  5  8  12\\n    \\n    18, 10, 16, 9, 5, 8, 12\\n\\n2.`Priority queue` is an `abstract datatype`. It is a shorthand way of describing a particular interface and behavior, and says nothing about the underlying implementation.\\n\\nA heap is a very good data structure to implement a priority queue. The operations which are made efficient by the heap data structure are the operations that the priority queue interface needs.\\n\\n\\n**Implementation: c++** \\n\\n1.`priority_queue`: we can only get the top element (from ChiangKaiShrek's [solution][2])\\n\\n    struct compare {\\n        bool operator()(const ListNode* l, const ListNode* r) {\\n            return l->val > r->val;\\n        }\\n    };\\n    ListNode *mergeKLists(vector<ListNode *> &lists) { //priority_queue\\n        priority_queue<ListNode *, vector<ListNode *>, compare> q;\\n        for(auto l : lists) {\\n            if(l)  q.push(l);\\n        }\\n        if(q.empty())  return NULL;\\n\\n        ListNode* result = q.top();\\n        q.pop();\\n        if(result->next) q.push(result->next);\\n        ListNode* tail = result;            \\n        while(!q.empty()) {\\n            tail->next = q.top();\\n            q.pop();\\n            tail = tail->next;\\n            if(tail->next) q.push(tail->next);\\n        }\\n        return result;\\n    }\\n\\n2.`make_heap`: we can access all the elements (from my answer for that solution)\\n\\n    static bool heapComp(ListNode* a, ListNode* b) {\\n            return a->val > b->val;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) { //make_heap\\n        ListNode head(0);\\n        ListNode *curNode = &head;\\n        vector<ListNode*> v;   \\n        for(int i =0; i<lists.size(); i++){\\n            if(lists[i]) v.push_back(lists[i]);\\n        }\\n        make_heap(v.begin(), v.end(), heapComp); //vector -> heap data strcture\\n    \\n        while(v.size()>0){\\n            curNode->next=v.front();\\n            pop_heap(v.begin(), v.end(), heapComp); \\n            v.pop_back(); \\n            curNode = curNode->next;\\n            if(curNode->next) {\\n                v.push_back(curNode->next); \\n                push_heap(v.begin(), v.end(), heapComp);\\n            }\\n        }\\n        return head.next;\\n    }\\n\\nIf there is something wrong, please figure it out. Hoping to learn more about them.\\n\\n\\n  [1]: http://stackoverflow.com/questions/18993269/difference-between-priority-queue-and-a-heap\\n  [2]: https://leetcode.com/discuss/21363/brief-c-solution-with-priority_queue",
                "codeTag": "Unknown"
            },
            {
                "id": 10511,
                "title": "10-line-python-solution-with-priority-queue",
                "content": "    from Queue import PriorityQueue\\n    class Solution(object):\\n        def mergeKLists(self, lists):\\n            dummy = ListNode(None)\\n            curr = dummy\\n            q = PriorityQueue()\\n            for node in lists:\\n                if node: q.put((node.val,node))\\n            while q.qsize()>0:\\n                curr.next = q.get()[1]\\n                curr=curr.next\\n                if curr.next: q.put((curr.next.val, curr.next))\\n            return dummy.next",
                "solutionTags": [],
                "code": "    from Queue import PriorityQueue\\n    class Solution(object):\\n        def mergeKLists(self, lists):\\n            dummy = ListNode(None)\\n            curr = dummy\\n            q = PriorityQueue()\\n            for node in lists:\\n                if node: q.put((node.val,node))\\n            while q.qsize()>0:\\n                curr.next = q.get()[1]\\n                curr=curr.next\\n                if curr.next: q.put((curr.next.val, curr.next))\\n            return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 429518,
                "title": "java-summary-of-all-solutions-b-f-minpq-divide-and-conquer",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/merge-k-sorted-lists/) <span class=\"gray\">EPI 10.1</span>\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n\\n## Problem\\n\\n> Merge `k` sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\\n\\n**Example:** \\n\\n```java\\nInput:\\n[\\n  1->4->5,\\n  1->3->4,\\n  2->6\\n]\\nOutput: 1->1->2->3->4->4->5->6\\n```\\n\\n\\n## Analysis\\n\\n**Focus on the third and fifth solution.**\\n\\n**Test Case:**\\n\\n```java\\n// 1\\n[[1,4,5],[1,3,4],[2,6]]\\n[1,2,4,4,5]\\n// 2\\n[[], [], []]\\n[]\\n// 3\\n[[1,2],[],[5]]\\n[1,2,5]\\n// 4\\n[[1,4,5],[2,4]]\\n[1,2,4,4,5]\\n// 5\\n[[1]]\\n[1]\\n// 6 ---- Be careful of this one\\n[]\\n```\\n\\n### Brute-Force\\n\\nIt is okay if `N` is not too large.\\n\\n- Traverse all the linked lists and collect the values of the nodes into an `array`. - `O(N)`\\n- Sort the array. - `O(N\\\\log{N})`\\n- Traverse the array and make the linked list. - `O(N)`\\n\\n**Time:** `O(N\\\\log{N})` where `N` is the total number of nodes.\\n**Space:** `O(N)` since we need an array and a new linked list.\\n\\n\\n\\n\\n### Compare One-By-One\\n\\n(if `k` is much less than `N`, `k` is the number of lists)\\n\\nCompare every `k` nodes (head of every list) and get the smallest node.\\n\\n**Note:**\\n\\n- Use `minIdx` to record the location and to check if the list is empty.\\n\\n```java\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n\\n  while (true) {\\n    ListNode minNode = null;\\n    int minIdx = -1;\\n    \\n    // Iterate over lists\\n    for (int i = 0; i < lists.length; ++i) {\\n      ListNode currList = lists[i];\\n      if (currList == null) continue;\\n      if (minNode == null || currList.val < minNode.val) {\\n        minNode = currList;\\n        minIdx = i;\\n      }\\n    }\\n    // check if finished\\n    if (minNode == null) break;\\n\\n    // link\\n    prev.next = minNode;\\n    prev = prev.next;\\n\\n    // delete\\n    lists[minIdx] = minNode.next; // may be null\\n  }\\n  return dummy.next;\\n}\\n```\\n\\n\\n**Time:** `O(kN)` where `k` is the number of linked lists. `311 ms`\\n**Space:** `O(N)` creating a new linked list. Or `O(1)` if we apply an in-place method. Connect selected nodes instead of creating new nodes.\\n\\n\\n\\n### Compare One-By-One (minPQ)\\n\\nUse a minimum `priority queue` to store `k` nodes. Pop the smallest node and offer its next node if it is not `null`.\\n\\n```java\\n// Compare One-By-One (PQ)\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n\\n  PriorityQueue<ListNode> minPQ = new PriorityQueue<>((o1, o2) -> {\\n    return o1.val - o2.val;\\n  });\\n\\n  // Init PQ\\n  for (int i = 0; i < lists.length; ++i) {\\n    if (lists[i] != null) {\\n      minPQ.offer(lists[i]);\\n    }\\n  }\\n\\n  // Play with PQ\\n  while (minPQ.size() > 0) {\\n    ListNode curr = pq.poll();\\n    prev.next = curr;\\n    prev = prev.next; // update\\n\\n    // you don\\'t need to set curr.next as null since the last node is always be one of the last node of each list. Its next must be null.\\n    if (curr.next != null) {\\n      minPQ.offer(curr.next);\\n    }\\n  }\\n  \\n  return dummy.next;\\n}\\n```\\n\\n**Time:** `O(N\\\\log{k})` `34 ms`\\n- Initializing the priority queue takes `O(k\\\\log{k})`\\n- Pop `N` nodes from the priority queue takes `O(N\\\\log{k})`\\n\\n**Space:** `O(k)` since priority queue stores `k` nodes. `O(1)` or `O(N)` depends on the input `N` and `k` and whether we create a new linked list.\\n\\n\\n\\n### Merge Lists One-By-One\\n\\nWe need to merge `k` lists by merging `(k-1)` times.\\n\\n**Note:**\\n\\n- `mergeList(dummy.next, n)` is thoughtful. At the beginning, `dummy.next` is null, but it does not matter.\\n- Alternatively, we can use the first place of the array to store merged list.\\n\\n```java\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  // Use the 0-th list as a return list\\n  for (int i = 1; i < lists.length; ++i) {\\n    lists[0] = mergeList(lists[0], lists[i]);\\n  }\\n\\n  return lists[0];\\n}\\n\\nprivate ListNode mergeList(ListNode n1, ListNode n2) {\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n  while (n1 != null && n2 != null) {\\n    if (n1.val < n2.val) {\\n      prev.next = n1;\\n      n1 = n1.next;\\n    } else {\\n      prev.next = n2;\\n      n2 = n2.next;\\n    }\\n    prev = prev.next;\\n  }\\n  prev.next = (n1 != null) ? n1 : n2;\\n\\n  return dummy.next;\\n}\\n```\\n\\n\\n**Time:** `O(kN)` `250 ms`\\n- Merge two sorted lists in `O(n)` time where `n` is the total number of nodes in two lists. (worst case)\\n- To sum up we have: `O(\\\\sum_{i=1}^{k-1}(i * \\\\frac{N}{k} + \\\\frac{N}{k}) = O(kN)`. (key: `n = \\\\frac{N}{k}`) `skip it...`\\n\\n**Space:** `O(1)` since we merge in place.\\n\\n\\n\\n\\n### Merge Lists with Divide And Conquer\\n\\nIn effect, we don\\'t need to traverse most nodes many times repeatedly. We can divide lists in half until there is only one list. Merge them one by one to get the final result. It\\'s similar to mergesort.\\n\\n\\n**Note:**\\n\\n- Recall of the `left-leaning` and `right-leaning` cases.\\n- The base case is thoughtful. `lo > hi` actually won\\'t occur. And `lists[lo]` won\\'t change other elements on the other side.\\n- `lists.length == 0` condition is very important.\\n  - Input case: `[]`.\\n\\n```java\\n// mergeDivideAndConquer - O(kN)\\npublic ListNode mergeDivideAndConquer(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  return divideAndConquer(lists, 0, lists.length - 1);\\n}\\n\\nprivate ListNode divideAndConquer(ListNode[] lists, int lo, int hi) {\\n  if (lo > hi) { // invalid\\n    return null;\\n  }\\n  if (lo == hi) { // size = 1\\n    return lists[lo];\\n  }\\n  int mid = lo + (hi - lo) / 2; // left-leaning\\n  ListNode left = divideAndConquer(lists, lo, mid);\\n  ListNode right = divideAndConquer(lists, mid + 1, hi);\\n  return mergeList(left, right);\\n}\\n\\nprivate ListNode mergeList(ListNode n1, ListNode n2) { ... }\\n```\\n\\n\\n**Time:** `O(N\\\\log{k})` `2 ms`\\n**Space:** `O(\\\\log{k})` if we use recursion (depth of the recursion tree).\\n    \\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/qpogs.jpg \"Merge with Divide And Conquer\")\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```java\\nInput:\\n[\\n  1->4->5,\\n  1->3->4,\\n  2->6\\n]\\nOutput: 1->1->2->3->4->4->5->6\\n```\n```java\\n// 1\\n[[1,4,5],[1,3,4],[2,6]]\\n[1,2,4,4,5]\\n// 2\\n[[], [], []]\\n[]\\n// 3\\n[[1,2],[],[5]]\\n[1,2,5]\\n// 4\\n[[1,4,5],[2,4]]\\n[1,2,4,4,5]\\n// 5\\n[[1]]\\n[1]\\n// 6 ---- Be careful of this one\\n[]\\n```\n```java\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n\\n  while (true) {\\n    ListNode minNode = null;\\n    int minIdx = -1;\\n    \\n    // Iterate over lists\\n    for (int i = 0; i < lists.length; ++i) {\\n      ListNode currList = lists[i];\\n      if (currList == null) continue;\\n      if (minNode == null || currList.val < minNode.val) {\\n        minNode = currList;\\n        minIdx = i;\\n      }\\n    }\\n    // check if finished\\n    if (minNode == null) break;\\n\\n    // link\\n    prev.next = minNode;\\n    prev = prev.next;\\n\\n    // delete\\n    lists[minIdx] = minNode.next; // may be null\\n  }\\n  return dummy.next;\\n}\\n```\n```java\\n// Compare One-By-One (PQ)\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n\\n  PriorityQueue<ListNode> minPQ = new PriorityQueue<>((o1, o2) -> {\\n    return o1.val - o2.val;\\n  });\\n\\n  // Init PQ\\n  for (int i = 0; i < lists.length; ++i) {\\n    if (lists[i] != null) {\\n      minPQ.offer(lists[i]);\\n    }\\n  }\\n\\n  // Play with PQ\\n  while (minPQ.size() > 0) {\\n    ListNode curr = pq.poll();\\n    prev.next = curr;\\n    prev = prev.next; // update\\n\\n    // you don\\'t need to set curr.next as null since the last node is always be one of the last node of each list. Its next must be null.\\n    if (curr.next != null) {\\n      minPQ.offer(curr.next);\\n    }\\n  }\\n  \\n  return dummy.next;\\n}\\n```\n```java\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  // Use the 0-th list as a return list\\n  for (int i = 1; i < lists.length; ++i) {\\n    lists[0] = mergeList(lists[0], lists[i]);\\n  }\\n\\n  return lists[0];\\n}\\n\\nprivate ListNode mergeList(ListNode n1, ListNode n2) {\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n  while (n1 != null && n2 != null) {\\n    if (n1.val < n2.val) {\\n      prev.next = n1;\\n      n1 = n1.next;\\n    } else {\\n      prev.next = n2;\\n      n2 = n2.next;\\n    }\\n    prev = prev.next;\\n  }\\n  prev.next = (n1 != null) ? n1 : n2;\\n\\n  return dummy.next;\\n}\\n```\n```java\\n// mergeDivideAndConquer - O(kN)\\npublic ListNode mergeDivideAndConquer(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  return divideAndConquer(lists, 0, lists.length - 1);\\n}\\n\\nprivate ListNode divideAndConquer(ListNode[] lists, int lo, int hi) {\\n  if (lo > hi) { // invalid\\n    return null;\\n  }\\n  if (lo == hi) { // size = 1\\n    return lists[lo];\\n  }\\n  int mid = lo + (hi - lo) / 2; // left-leaning\\n  ListNode left = divideAndConquer(lists, lo, mid);\\n  ListNode right = divideAndConquer(lists, mid + 1, hi);\\n  return mergeList(left, right);\\n}\\n\\nprivate ListNode mergeList(ListNode n1, ListNode n2) { ... }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 465094,
                "title": "problems-with-python3-and-multiple-solutions",
                "content": "**Python 2 Solution:**\\n```\\ndef mergeKLists_Python2(self, lists):\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in lists:\\n\\t\\tif i:\\n\\t\\t\\theapq.heappush(h, (i.val, i))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)[1]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\theapq.heappush(h, (node.next.val, node.next))\\n\\n\\treturn head.next\\n```\\n\\n**Python 3:** \\nThe above solution works fine with Python 2.However, with Python3 it gives Type Error:\\nTypeError: \\'<\\' not supported between instances of \\'ListNode\\' and \\'ListNode\\'\\n**This error occurs because the cmp() special method is no longer honored in Python 3**\\n\\nHere are the two ways we can solve this problem:\\n**a) Implement eq, lt methods** \\n\\t\\nOne of the solution would be to provide `__eq__ and __lt__` method implementation to `ListNode` class\\n```\\ndef mergeKLists_Python3(self, lists):\\n\\tListNode.__eq__ = lambda self, other: self.val == other.val\\n\\tListNode.__lt__ = lambda self, other: self.val < other.val\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in lists:\\n\\t\\tif i:\\n\\t\\t\\theapq.heappush(h, (i.val, i))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)[1]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\theapq.heappush(h, (node.next.val, node.next))\\n\\n\\treturn head.next\\n```\\n\\n**b) Fix heapq** \\n\\nThe problem while adding `ListNode` objects as tasks is that the Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. The solution is to store entries as 3-element list including the priority, an entry count, and the task.\\nThe entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were added.\\nAnd since no two entry counts are the same, the tuple comparison will never attempt to directly compare two tasks.\\n\\n```\\ndef mergeKLists_heapq(self, lists):\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in range(len(lists)):\\n\\t\\theapq.heappush(h, (lists[i].val, i, lists[i]))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)\\n\\t\\tnode = node[2]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\ti+=1\\n\\t\\t\\theapq.heappush(h, (node.next.val, i, node.next))\\n\\n\\treturn head.next\\n```\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef mergeKLists_Python2(self, lists):\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in lists:\\n\\t\\tif i:\\n\\t\\t\\theapq.heappush(h, (i.val, i))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)[1]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\theapq.heappush(h, (node.next.val, node.next))\\n\\n\\treturn head.next\\n```\n```\\ndef mergeKLists_Python3(self, lists):\\n\\tListNode.__eq__ = lambda self, other: self.val == other.val\\n\\tListNode.__lt__ = lambda self, other: self.val < other.val\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in lists:\\n\\t\\tif i:\\n\\t\\t\\theapq.heappush(h, (i.val, i))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)[1]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\theapq.heappush(h, (node.next.val, node.next))\\n\\n\\treturn head.next\\n```\n```\\ndef mergeKLists_heapq(self, lists):\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in range(len(lists)):\\n\\t\\theapq.heappush(h, (lists[i].val, i, lists[i]))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)\\n\\t\\tnode = node[2]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\ti+=1\\n\\t\\t\\theapq.heappush(h, (node.next.val, i, node.next))\\n\\n\\treturn head.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1746240,
                "title": "c-solution-w-explanation-step-by-step-optimisation-three-different-approaches",
                "content": "***Brief note about Question-***\\n\\nWe have to ***Merge all the linked-lists into one sorted linked-list and return it.***\\n```\\nTake an example -\\nGiven: k number of sorted linked list in ascending order.\\nAim: Merge them into a single sorted linked list.\\n\\nTake anthor example which is not given in question-\\nL1: 1 -> 5 -> 7 -> 9 -> N\\nL2: 2 -> 4 -> 8 -> N\\nL3: 3 -> 6 -> N\\n\\nSo our answer should like this:\\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> N\\n```\\n________________________\\n***Solution - I (Most basic approach, Accepted)-***\\n* Okay, so the most basic approach we can think of is, we are obedient person, and not to do anything extra from ourself,\\n* We will simply do what the question wants us to do, we create an array which store all the elements of all \\'k\\' linked list present in the array.\\n* After storing all elements, we sort them a/c to their vaules.\\n*  Now, the only task which is left is to link them, so we start linking them.\\n\\n**Okay, I got the approach, but how i will implement this or code these words-**\\n\\n1. We take help of a `vector pair` which of value and Node type.\\n1. But why vector pair?\\n1. See,  *Here we have k different linked list na and each linked list contain some elements so to observe that we need a vector pair.*\\n1. Okay good, I take a vector pair,so now what i have to do?\\n1. Now we start storing each value in this vector pair.\\n1. After this, by using `sort function` (present in STL) we sort this vectorAnd at last, i start linking them, it can be done simply by putting next pointer i.e `arr[i].second -> next = arr[i + 1].second`.\\n\\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log n) // as sorting takes (n log n) time\\nSpace Complexity --> O(n) // to store nodes of the all linked list\\nIt paases [ 133 / 133] in built test cases\\n```\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); // taking size of the list\\n        if(k == 0) // if size is zero\\n            return NULL; // simply return NULL\\n        \\n        // making a vector pair where first contain value and second contain node\\n        vector<pair<int, ListNode*>> arr; \\n        \\n        for(int i = 0; i < k; i++) // traverse all over the list\\n        {\\n            ListNode* curr_list = lists[i]; // extracting current linked list\\n            \\n            while(curr_list != NULL) // while current linked list is NOT NULL\\n            {\\n                arr.push_back({curr_list -> val, curr_list}); // push into vector\\n                curr_list = curr_list -> next;\\n            }\\n        }\\n        \\n        // this does not gurantee that k is zero, \\n        // suppose an array like this [[],[],[],],here k = 3 and size of array is 0\\n        if(arr.size() == 0) // if their is no element i.e zero element\\n            return NULL;\\n        \\n        sort(arr.begin(), arr.end()); // sort the vector on the basis of values\\n        \\n        // start making links b/w the elements of vector\\n        for(int i = 0; i < arr.size() - 1; i++)\\n        {\\n            arr[i].second -> next = arr[i + 1].second;\\n        }\\n        \\n        // in the next of last node put NULL\\n        arr[arr.size() - 1].second -> next = NULL;\\n        \\n        return arr[0].second; // return first node of the vector\\n    }\\n};\\n```\\n___________________________\\n***Solution - II (Further optimization in time as well as in space, Using priority queue, Accepted)-***\\n* Now, we want to become a good programmer and anyhow we want to optimize our soloution.\\n* The main point is to observe here is that ***every linked list is already sorted*** and our task is just to merge them.\\n* Our approach to merge linked list is same as about merge function of merge sort.\\n* In merge sort, we have just two arrays / linked list but here we have \\'k\\' linked list.\\n* So by using `min heap` we compare k node values and add the smallest one to the final list.\\n* One property of min heap we have to remember here is that, ***it keeps smallest element always on the top,*** so using that property we merge our k sorted linked list.\\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log k) // as we are using min heap\\nSpace Complexity --> O(k) // at a single point of time min heap always handle the k elements\\nIt paases [ 133 / 133] in built test cases\\n```\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    // we define pair as pi\\n    #define pi pair<int, ListNode* >\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); // taking the size of the linked list\\n        \\n        if(k == 0) // if no linked list is present\\n            return NULL; // simply return null\\n        \\n        priority_queue<pi, vector<pi>, greater<pi>> minh; // making priority queue\\n        \\n        for(int i = 0; i < k; i++) // traverse from the whole array \\n        {\\n            ListNode* curr_list = lists[i]; // extracting current linked list\\n            \\n            if(curr_list != NULL) // if element present in the linked list\\n            {\\n                minh.push({curr_list -> val, curr_list}); // push into min heap\\n            }\\n        }\\n        \\n        // this does not gurantee that k is zero, \\n        // suppose an array like this [[],[],[],],here k = 3 and size of array is 0\\n        if(minh.size() == 0) // if their is no element i.e zero element\\n            return NULL;\\n        \\n        ListNode* head = new ListNode(); // can also be called as dummy\\n        ListNode* curr = head; // make a pointer pointing to head\\n        \\n        while(minh.empty() == false) // adding further most elements to min heap\\n        {\\n            pair<int, ListNode*> temp = minh.top(); // extracting top pair\\n            minh.pop(); // pop that pair\\n            \\n            if(temp.second -> next != NULL) // if elements still remaining in the linked list then push them\\n            {\\n                minh.push({temp.second -> next -> val, temp.second -> next});\\n            }\\n            \\n            curr -> next = temp.second;\\n            curr = curr -> next;\\n        }\\n        \\n        curr -> next = NULL; \\n        head = head -> next; // move head, which is actually containg the list\\n        \\n        return head; // return head\\n    }\\n};\\n```\\n___________________________\\n***Solution - III (Further optimization in space, Accepted)-***\\n* Okay, the question arises, if we just have to merge k linked list, \\n* Is the use of priority queue is necesssary? Can\\'t we do it without using the priority queue?\\n* The answer is ***YES***, we can do further optimization in space complexity as well.\\n* We use `two pointers` for doing this.\\n* First we put start pointer to zero index and last pointer to last index and after that we start merging them thinking of as two sorted linked list.\\n* And again we will continue this task until we get a single linked list.\\n* See commented code, you will get it easily.\\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log k)\\nSpace Complexity --> O(1) \\nIt paases [ 133 / 133] in built test cases\\n```\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // this do the same work as merge function of merging two values\\n    ListNode* merge(ListNode* first, ListNode* second)\\n    {\\n        ListNode* result = NULL;\\n        \\n        if(first == nullptr)\\n            return second;\\n        \\n        if(second == nullptr)\\n            return first;\\n        \\n        \\n        if(first -> val <= second -> val)\\n        {\\n            result = first;\\n            result -> next = merge(first -> next, second);\\n        }\\n        else\\n        {\\n            result = second;\\n            result -> next = merge(first, second -> next);\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& arr) {\\n        int k = arr.size(); // extracting size of array\\n        if(k == 0) // if size of array is value\\n            return NULL;\\n        \\n        int start = 0; // start pointer\\n        int last = k -1; // last pointer\\n        int temp;\\n        while(last != 0) // if last pointer not becomes zero\\n        {\\n            start = 0;\\n            temp = last;\\n            while(start < temp)\\n            {\\n                // merge them and store in one of the linked list\\n                arr[start] = merge(arr[start],arr[temp]);\\n                start++; // increment start\\n                temp--; // decrese start\\n                \\n                if(start >= temp) // if at any point start passes the temp\\n                {\\n                    last = temp;\\n                }\\n            }\\n        }\\n        return arr[0]; // return first linked list of the aray as now it contains the all nodes in the sorted order.\\n        \\n    }\\n};\\n```\\n\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTake an example -\\nGiven: k number of sorted linked list in ascending order.\\nAim: Merge them into a single sorted linked list.\\n\\nTake anthor example which is not given in question-\\nL1: 1 -> 5 -> 7 -> 9 -> N\\nL2: 2 -> 4 -> 8 -> N\\nL3: 3 -> 6 -> N\\n\\nSo our answer should like this:\\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> N\\n```\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log n) // as sorting takes (n log n) time\\nSpace Complexity --> O(n) // to store nodes of the all linked list\\nIt paases [ 133 / 133] in built test cases\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); // taking size of the list\\n        if(k == 0) // if size is zero\\n            return NULL; // simply return NULL\\n        \\n        // making a vector pair where first contain value and second contain node\\n        vector<pair<int, ListNode*>> arr; \\n        \\n        for(int i = 0; i < k; i++) // traverse all over the list\\n        {\\n            ListNode* curr_list = lists[i]; // extracting current linked list\\n            \\n            while(curr_list != NULL) // while current linked list is NOT NULL\\n            {\\n                arr.push_back({curr_list -> val, curr_list}); // push into vector\\n                curr_list = curr_list -> next;\\n            }\\n        }\\n        \\n        // this does not gurantee that k is zero, \\n        // suppose an array like this [[],[],[],],here k = 3 and size of array is 0\\n        if(arr.size() == 0) // if their is no element i.e zero element\\n            return NULL;\\n        \\n        sort(arr.begin(), arr.end()); // sort the vector on the basis of values\\n        \\n        // start making links b/w the elements of vector\\n        for(int i = 0; i < arr.size() - 1; i++)\\n        {\\n            arr[i].second -> next = arr[i + 1].second;\\n        }\\n        \\n        // in the next of last node put NULL\\n        arr[arr.size() - 1].second -> next = NULL;\\n        \\n        return arr[0].second; // return first node of the vector\\n    }\\n};\\n```\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log k) // as we are using min heap\\nSpace Complexity --> O(k) // at a single point of time min heap always handle the k elements\\nIt paases [ 133 / 133] in built test cases\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    // we define pair as pi\\n    #define pi pair<int, ListNode* >\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); // taking the size of the linked list\\n        \\n        if(k == 0) // if no linked list is present\\n            return NULL; // simply return null\\n        \\n        priority_queue<pi, vector<pi>, greater<pi>> minh; // making priority queue\\n        \\n        for(int i = 0; i < k; i++) // traverse from the whole array \\n        {\\n            ListNode* curr_list = lists[i]; // extracting current linked list\\n            \\n            if(curr_list != NULL) // if element present in the linked list\\n            {\\n                minh.push({curr_list -> val, curr_list}); // push into min heap\\n            }\\n        }\\n        \\n        // this does not gurantee that k is zero, \\n        // suppose an array like this [[],[],[],],here k = 3 and size of array is 0\\n        if(minh.size() == 0) // if their is no element i.e zero element\\n            return NULL;\\n        \\n        ListNode* head = new ListNode(); // can also be called as dummy\\n        ListNode* curr = head; // make a pointer pointing to head\\n        \\n        while(minh.empty() == false) // adding further most elements to min heap\\n        {\\n            pair<int, ListNode*> temp = minh.top(); // extracting top pair\\n            minh.pop(); // pop that pair\\n            \\n            if(temp.second -> next != NULL) // if elements still remaining in the linked list then push them\\n            {\\n                minh.push({temp.second -> next -> val, temp.second -> next});\\n            }\\n            \\n            curr -> next = temp.second;\\n            curr = curr -> next;\\n        }\\n        \\n        curr -> next = NULL; \\n        head = head -> next; // move head, which is actually containg the list\\n        \\n        return head; // return head\\n    }\\n};\\n```\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log k)\\nSpace Complexity --> O(1) \\nIt paases [ 133 / 133] in built test cases\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // this do the same work as merge function of merging two values\\n    ListNode* merge(ListNode* first, ListNode* second)\\n    {\\n        ListNode* result = NULL;\\n        \\n        if(first == nullptr)\\n            return second;\\n        \\n        if(second == nullptr)\\n            return first;\\n        \\n        \\n        if(first -> val <= second -> val)\\n        {\\n            result = first;\\n            result -> next = merge(first -> next, second);\\n        }\\n        else\\n        {\\n            result = second;\\n            result -> next = merge(first, second -> next);\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& arr) {\\n        int k = arr.size(); // extracting size of array\\n        if(k == 0) // if size of array is value\\n            return NULL;\\n        \\n        int start = 0; // start pointer\\n        int last = k -1; // last pointer\\n        int temp;\\n        while(last != 0) // if last pointer not becomes zero\\n        {\\n            start = 0;\\n            temp = last;\\n            while(start < temp)\\n            {\\n                // merge them and store in one of the linked list\\n                arr[start] = merge(arr[start],arr[temp]);\\n                start++; // increment start\\n                temp--; // decrese start\\n                \\n                if(start >= temp) // if at any point start passes the temp\\n                {\\n                    last = temp;\\n                }\\n            }\\n        }\\n        return arr[0]; // return first linked list of the aray as now it contains the all nodes in the sorted order.\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032540,
                "title": "c-simplest-easy-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        if (!l1) return l2;\\n        if (!l2) return l1;\\n        ListNode* head = l1->val <= l2->val? l1 : l2;\\n        head->next = l1->val <= l2->val ? merge2Lists(l1->next, l2) : merge2Lists(l1, l2->next);\\n        return head;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0) return NULL;\\n        \\n        ListNode* head = lists[0];\\n        \\n        for (int i = 1; i < lists.size(); i++)\\n            head = merge2Lists(head, lists[i]);\\n        \\n        return head;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        if (!l1) return l2;\\n        if (!l2) return l1;\\n        ListNode* head = l1->val <= l2->val? l1 : l2;\\n        head->next = l1->val <= l2->val ? merge2Lists(l1->next, l2) : merge2Lists(l1, l2->next);\\n        return head;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0) return NULL;\\n        \\n        ListNode* head = lists[0];\\n        \\n        for (int i = 1; i < lists.size(); i++)\\n            head = merge2Lists(head, lists[i]);\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424567,
                "title": "super-easy-min-heap-c-solution",
                "content": "```\\nListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        if(lists.empty()) return nullptr;\\n        \\n        priority_queue<pair<int,ListNode*>> pq;\\n        int n=lists.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(lists[i]!=nullptr)\\n            {\\n                pq.push({-lists[i]->val,lists[i]});\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        \\n        \\n        ListNode* head=nullptr;\\n        ListNode* k=nullptr;\\n        \\n        if(pq.empty()) return head;\\n        \\n        head=pq.top().second;\\n        k=pq.top().second;\\n        pq.pop();\\n        \\n     \\n        while(!pq.empty())\\n        {\\n            k->next=pq.top().second;\\n            k=pq.top().second;\\n            pq.pop();\\n            \\n        }\\n        k->next=NULL;\\n        \\n        return head==NULL?nullptr:head;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        if(lists.empty()) return nullptr;\\n        \\n        priority_queue<pair<int,ListNode*>> pq;\\n        int n=lists.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(lists[i]!=nullptr)\\n            {\\n                pq.push({-lists[i]->val,lists[i]});\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        \\n        \\n        ListNode* head=nullptr;\\n        ListNode* k=nullptr;\\n        \\n        if(pq.empty()) return head;\\n        \\n        head=pq.top().second;\\n        k=pq.top().second;\\n        pq.pop();\\n        \\n     \\n        while(!pq.empty())\\n        {\\n            k->next=pq.top().second;\\n            k=pq.top().second;\\n            pq.pop();\\n            \\n        }\\n        k->next=NULL;\\n        \\n        return head==NULL?nullptr:head;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285930,
                "title": "100-faster-c-java-python",
                "content": "# Code\\n\\nPlease **Upvote** And **Comment** ....!\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n```JAVA []\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeKListsHelper(lists, start, mid);\\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        \\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        curr.next = (l1 != null) ? l1 : l2;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n\\n```\\n```python []\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        if len(lists) == 1:\\n            return lists[0]\\n        \\n        mid = len(lists) // 2\\n        left = self.mergeKLists(lists[:mid])\\n        right = self.mergeKLists(lists[mid:])\\n        \\n        return self.merge(left, right)\\n    \\n    def merge(self, l1, l2):\\n        dummy = ListNode(0)\\n        curr = dummy\\n        \\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                curr.next = l1\\n                l1 = l1.next\\n            else:\\n                curr.next = l2\\n                l2 = l2.next\\n            curr = curr.next\\n        \\n        curr.next = l1 or l2\\n        \\n        return dummy.next\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return nullptr;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.size() - 1);\\n    }\\n    \\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        \\n        while (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                curr->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                curr->next = l2;\\n                l2 = l2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        curr->next = l1 ? l1 : l2;\\n        \\n        return dummy->next;\\n    }\\n};\\n\\n```\\n![8873f9b1-dfa4-4d9c-bb67-1b6db9d65e35_1674992431.3815322.jpeg](https://assets.leetcode.com/users/images/ae87d327-68b0-485b-959d-21ff0ad8af6e_1678582147.0744655.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```JAVA []\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeKListsHelper(lists, start, mid);\\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        \\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        curr.next = (l1 != null) ? l1 : l2;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n\\n```\n```python []\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        if len(lists) == 1:\\n            return lists[0]\\n        \\n        mid = len(lists) // 2\\n        left = self.mergeKLists(lists[:mid])\\n        right = self.mergeKLists(lists[mid:])\\n        \\n        return self.merge(left, right)\\n    \\n    def merge(self, l1, l2):\\n        dummy = ListNode(0)\\n        curr = dummy\\n        \\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                curr.next = l1\\n                l1 = l1.next\\n            else:\\n                curr.next = l2\\n                l2 = l2.next\\n            curr = curr.next\\n        \\n        curr.next = l1 or l2\\n        \\n        return dummy.next\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return nullptr;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.size() - 1);\\n    }\\n    \\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        \\n        while (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                curr->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                curr->next = l2;\\n                l2 = l2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        curr->next = l1 ? l1 : l2;\\n        \\n        return dummy->next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10513,
                "title": "108ms-python-solution-with-heapq-and-avoid-changing-heap-size",
                "content": "    def mergeKLists(self, lists):\\n        from heapq import heappush, heappop, heapreplace, heapify\\n        dummy = node = ListNode(0)\\n        h = [(n.val, n) for n in lists if n]\\n        heapify(h)\\n        while h:\\n            v, n = h[0]\\n            if n.next is None:\\n                heappop(h) #only change heap size when necessary\\n            else:\\n                heapreplace(h, (n.next.val, n.next))\\n            node.next = n\\n            node = node.next\\n    \\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def mergeKLists(self, lists):\\n        from heapq import heappush, heappop, heapreplace, heapify\\n        dummy = node = ListNode(0)\\n        h = [(n.val, n) for n in lists if n]\\n        heapify(h)\\n        while h:\\n            v, n = h[0]\\n            if n.next is None:\\n                heappop(h) #only change heap size when necessary\\n            else:\\n                heapreplace(h, (n.next.val, n.next))\\n            node.next = n\\n            node = node.next\\n    \\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 3286058,
                "title": "image-explanation-5-methods-divide-conquer-priority-queue-complete-intuition",
                "content": "# Video Solution\\nhttps://youtu.be/wIimE9hKcl4\\n\\n# Approach & Complete Inutuition\\nMethod 1: Brute Force\\nMethod 2: Compare K elements One By One\\nMethod 3: Compare K elements by Priority Queue\\nMethod 4: Merge 2 Lists at a time\\nMethod 5: Merge K lists by Divide & Conquer (**`Most Optimal`**)\\n\\n# Image Explanation\\n![image.png](https://assets.leetcode.com/users/images/46885295-5e87-479a-8884-963030ac6b18_1678586862.7911444.png)\\n![image.png](https://assets.leetcode.com/users/images/0051b520-4469-4725-86bd-fb606fb591f8_1678586878.7285347.png)\\n![image.png](https://assets.leetcode.com/users/images/79bc054d-ad53-4525-9611-f128de5fd3b5_1678586890.0865543.png)\\n![image.png](https://assets.leetcode.com/users/images/dfc83aae-06ff-48b0-981c-6fc83aafbac0_1678586902.1306381.png)\\n![image.png](https://assets.leetcode.com/users/images/4d2b0950-93cb-4d94-abf4-03d94f60ddf9_1678586913.2264328.png)\\n![image.png](https://assets.leetcode.com/users/images/1367ca55-aaba-496a-a78e-000d970c2587_1678586925.7524848.png)\\n![image.png](https://assets.leetcode.com/users/images/9cd1e449-e965-4b84-b784-c2fbdc6d6628_1678586935.1948905.png)\\n![image.png](https://assets.leetcode.com/users/images/f64cdbaf-f12d-4777-bad5-38610db30d87_1678586948.0475173.png)\\n![image.png](https://assets.leetcode.com/users/images/7dd6025c-2362-4956-a4f3-bd3e74f7e075_1678586961.0338929.png)\\n![image.png](https://assets.leetcode.com/users/images/d4636fc5-48da-4c57-b482-bdd2e610e00e_1678586977.6893442.png)\\n![image.png](https://assets.leetcode.com/users/images/9d283a96-29a5-4e55-ba99-77bbc9b0851a_1678586986.6568656.png)\\n![image.png](https://assets.leetcode.com/users/images/2d477989-3163-4c7e-9a0e-52e5a0b5215f_1678587002.2201269.png)\\n![image.png](https://assets.leetcode.com/users/images/06dfa807-5026-4469-8b19-62f3debc59ea_1678587012.1176128.png)\\n![image.png](https://assets.leetcode.com/users/images/2439d09b-7e90-4664-b935-0f4eb58e5d20_1678587047.020193.png)\\n![image.png](https://assets.leetcode.com/users/images/97149ca1-bbef-4995-91e8-86cedec6ce24_1678587054.8823147.png)\\n\\n\\n# Method 5 - Code (Divide & Conquer)\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n        return mergeKListsHelper(lists, 0, lists.size()-1);\\n    }\\n\\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if(start>end) return NULL; \\n        if(start==end) return lists[start];\\n\\n        int mid = start + (end-start)/2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n\\n    ListNode* merge(ListNode* list1Head, ListNode* list2Head) {\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n\\n        while(list1Head!=NULL && list2Head!=NULL){\\n            if(list1Head->val < list2Head->val){\\n                dummyTail->next = list1Head;\\n                list1Head = list1Head->next;\\n            }else{\\n                dummyTail->next = list2Head;\\n                list2Head = list2Head->next;\\n            }\\n            dummyTail = dummyTail->next;\\n        }\\n        dummyTail->next = (list1Head != NULL) ? list1Head : list2Head;\\n        return dummyHead->next;\\n    }\\n};\\n```\\n\\n# Method 3 - Code (Priority Queue)\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\\n        for(auto head : lists)  if(head != NULL) pq.push({head->val, head});\\n\\n        while(!pq.empty()){\\n            ListNode* minNode = pq.top().second;\\n            pq.pop();\\n            if(minNode->next != NULL) pq.push({minNode->next->val, minNode->next});\\n\\n            dummyTail->next = minNode;\\n            dummyTail = dummyTail->next;\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n        return mergeKListsHelper(lists, 0, lists.size()-1);\\n    }\\n\\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if(start>end) return NULL; \\n        if(start==end) return lists[start];\\n\\n        int mid = start + (end-start)/2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n\\n    ListNode* merge(ListNode* list1Head, ListNode* list2Head) {\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n\\n        while(list1Head!=NULL && list2Head!=NULL){\\n            if(list1Head->val < list2Head->val){\\n                dummyTail->next = list1Head;\\n                list1Head = list1Head->next;\\n            }else{\\n                dummyTail->next = list2Head;\\n                list2Head = list2Head->next;\\n            }\\n            dummyTail = dummyTail->next;\\n        }\\n        dummyTail->next = (list1Head != NULL) ? list1Head : list2Head;\\n        return dummyHead->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\\n        for(auto head : lists)  if(head != NULL) pq.push({head->val, head});\\n\\n        while(!pq.empty()){\\n            ListNode* minNode = pq.top().second;\\n            pq.pop();\\n            if(minNode->next != NULL) pq.push({minNode->next->val, minNode->next});\\n\\n            dummyTail->next = minNode;\\n            dummyTail = dummyTail->next;\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152022,
                "title": "brute-force-merge-sort-heap",
                "content": "## Brute Force\\nWe might merge two sorted list among `lists` each round, until there is only one list.\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0)\\n            return null;\\n        ListNode merged = null;\\n        for (ListNode head : lists) {\\n            merged = mergeTwoLists(merged, head);\\n        }\\n        return merged;\\n    }\\n    \\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null)\\n            return l2;\\n        if (l2 == null)\\n            return l1;\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```\\n## Merge Sort\\nSorting always reminds us of Merge Sort algorithm, the only difference between sorting numbers and sorting lists is the merging process, i.e. `mergeTwoLists`.\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0)\\n            return null;\\n        return mergeKLists(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n        if (end < start)\\n            return null;\\n        if (start == end)\\n            return lists[start];\\n        if (start + 1 == end)\\n            return mergeTwoLists(lists[start], lists[end]);\\n        \\n        int mid = start + ((end - start) >> 1);\\n        ListNode lower = mergeKLists(lists, start, mid);\\n        ListNode upper = mergeKLists(lists, mid + 1, end);\\n        \\n        return mergeTwoLists(lower, upper);\\n    }\\n    \\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null)\\n            return l2;\\n        if (l2 == null)\\n            return l1;\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```\\n## Heap\\nIn order to build one sorted list, we always want the minimum node among heads of lists.\\nThat\\'s natural to Min Heap.\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0) {\\n            return null;\\n        }\\n        \\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        for (ListNode head : lists) {\\n            if (head != null) // Ensures no \"null\" in minHeap\\n                minHeap.offer(head);\\n        }\\n        \\n        ListNode dummyHead = new ListNode(), cur = dummyHead;\\n        while (!minHeap.isEmpty()) {\\n            ListNode min = minHeap.poll();\\n            cur.next = min;\\n            cur = cur.next;\\n            \\n            if (min.next != null) // Ensures no \"null\" in minHeap\\n                minHeap.offer(min.next);\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0)\\n            return null;\\n        ListNode merged = null;\\n        for (ListNode head : lists) {\\n            merged = mergeTwoLists(merged, head);\\n        }\\n        return merged;\\n    }\\n    \\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null)\\n            return l2;\\n        if (l2 == null)\\n            return l1;\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0)\\n            return null;\\n        return mergeKLists(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n        if (end < start)\\n            return null;\\n        if (start == end)\\n            return lists[start];\\n        if (start + 1 == end)\\n            return mergeTwoLists(lists[start], lists[end]);\\n        \\n        int mid = start + ((end - start) >> 1);\\n        ListNode lower = mergeKLists(lists, start, mid);\\n        ListNode upper = mergeKLists(lists, mid + 1, end);\\n        \\n        return mergeTwoLists(lower, upper);\\n    }\\n    \\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null)\\n            return l2;\\n        if (l2 == null)\\n            return l1;\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0) {\\n            return null;\\n        }\\n        \\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        for (ListNode head : lists) {\\n            if (head != null) // Ensures no \"null\" in minHeap\\n                minHeap.offer(head);\\n        }\\n        \\n        ListNode dummyHead = new ListNode(), cur = dummyHead;\\n        while (!minHeap.isEmpty()) {\\n            ListNode min = minHeap.poll();\\n            cur.next = min;\\n            cur = cur.next;\\n            \\n            if (min.next != null) // Ensures no \"null\" in minHeap\\n                minHeap.offer(min.next);\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10640,
                "title": "simple-java-merge-sort",
                "content": "For this problem, use merge sort is simple and fast, I wonder why some guys solve it use PriorityQueue.\\n\\nI think the complexity is k * n * logk. Because the recursion depth is logK,  and in each level, every element will be compared.\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n        return mergeKLists(lists, 0, lists.length - 1);\\n    }\\n\\tprivate ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n\\t\\tif (start == end) {\\n\\t\\t\\treturn lists[start];\\n\\t\\t} else if (start < end){\\n\\t\\t\\tint mid = (end - start) / 2 + start;\\n\\t\\t\\tListNode left = mergeKLists(lists, start, mid);\\n\\t\\t\\tListNode right = mergeKLists(lists, mid + 1, end);\\n\\t\\t\\treturn mergeTwoLists(left, right);\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\nmergeTwoLists is base on the Merge Two Sorted Lists problem.",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "For this problem, use merge sort is simple and fast, I wonder why some guys solve it use PriorityQueue.\\n\\nI think the complexity is k * n * logk. Because the recursion depth is logK,  and in each level, every element will be compared.\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n        return mergeKLists(lists, 0, lists.length - 1);\\n    }\\n\\tprivate ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n\\t\\tif (start == end) {\\n\\t\\t\\treturn lists[start];\\n\\t\\t} else if (start < end){\\n\\t\\t\\tint mid = (end - start) / 2 + start;\\n\\t\\t\\tListNode left = mergeKLists(lists, start, mid);\\n\\t\\t\\tListNode right = mergeKLists(lists, mid + 1, end);\\n\\t\\t\\treturn mergeTwoLists(left, right);\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\nmergeTwoLists is base on the Merge Two Sorted Lists problem.",
                "codeTag": "Unknown"
            },
            {
                "id": 2281039,
                "title": "c-all-5-standard-approaches-only-in-single-post-most-learning",
                "content": "\\u2714 ***All codes are running successfully !***\\n*if you find that this post to be helpful for you, So, please take out **one second** for single UPVOTE.* \\n\\n----\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n```\\n\\n----\\n**Approach-1 : USING MIN HEAP**\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    struct compare\\n    {\\n        bool operator()(ListNode* a, ListNode *b)\\n        {\\n            return a->val > b->val;   // min heap  \\n        }\\n    };\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& arr) // saari linked list ka head arr mai hai\\n    {\\n        int j;\\n        for(j = 0;j< arr.size();j++){\\n            if(arr[j] != NULL)\\n                break;\\n        }\\n        if(j == arr.size()){ // all list empty\\n            return NULL;\\n        }\\n        \\n        priority_queue<ListNode*, vector<ListNode*>, compare>pq;   \\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] != NULL)\\n                pq.push(arr[i]);\\n        }\\n        \\n        ListNode *mergeH = new ListNode(0);\\n        ListNode *last = mergeH;\\n        while(!pq.empty())\\n        {\\n            ListNode* curr = pq.top();\\n            pq.pop();\\n            \\n            last->next = curr;\\n            last = last->next;\\n            \\n            if(curr != NULL && curr->next != NULL){\\n                pq.push(curr->next);\\n            }\\n            \\n        }\\n        return mergeH->next;\\n    }\\n};\\n```\\n\\n----\\n**Approach - 2 : Using simple Merging of 2 sorted array**\\n**Time : `381 ms`**\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *a, ListNode* b)\\n    {\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        \\n        if(a->val<=b->val){\\n            a->next = mergeTwoSorted(a->next, b);\\n            return a;\\n        }\\n        else{\\n            b->next = mergeTwoSorted(a, b->next);\\n            return b;\\n        }\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        if(lists.size()==0) return NULL;\\n        while(lists.size() > 1){\\n            lists.push_back(mergeTwoSorted(lists[0], lists[1])); // time consuming \\n            // erase first 2 heads of lists\\n            lists.erase(lists.begin()); // time consuming \\n            lists.erase(lists.begin());\\n        }\\n        return lists[0];\\n    }\\n};\\n```\\n\\n\\n----\\n**Approach - 3 : Optimization of Approach 2**\\nwithout using **push_back**, **erase**, which is time consuming,\\n**Time : `47 ms`**\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *a, ListNode* b)\\n    {\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        \\n        if(a->val<=b->val){\\n            a->next = mergeTwoSorted(a->next, b);\\n            return a;\\n        }\\n        else{\\n            b->next = mergeTwoSorted(a, b->next);\\n            return b;\\n        }\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        int n=lists.size();\\n        if(lists.size()==0) return NULL;\\n        while(n>1){\\n            \\n            for(int i=0;i<n/2;i++)\\n                lists[i] = mergeTwoSorted(lists[i], lists[n-i-1]);\\n            n = (n+1)/2;\\n        }\\n        return lists.front();\\n    }\\n};\\n```\\n\\n----\\n**Approach - 4 : Iterative Merging of 2 lists**\\n**Time  :** **`17ms`**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *l1, ListNode* l2)\\n    {\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* last = dummy;\\n        \\n        while(l1 and l2)\\n        {\\n            if(l1->val <= l2->val){\\n                last->next = l1;\\n                last = l1;\\n                l1=l1->next;\\n            }\\n            else{\\n                last->next = l2;\\n                last = l2;\\n                l2=l2->next;\\n            }\\n        }\\n        \\n        if(!l1)\\n            last->next = l2;\\n        else\\n            last->next = l1;\\n        return dummy->next;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        int n=lists.size();\\n        if(lists.size()==0) return NULL;\\n        while(n>1){\\n            \\n            for(int i=0;i<n/2;i++)\\n                lists[i] = mergeTwoSorted(lists[i], lists[n-i-1]);\\n            n = (n+1)/2;\\n        }\\n        return lists.front();\\n    }\\n};\\n```\\n\\n----\\n**Approach - 5 : USING MAX HEAP**\\n**Time  :** **`35 ms`**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        if(lists.empty()) return NULL;\\n        \\n        // MAX heap\\n        priority_queue<pair<int, ListNode*>> pq; // (value, Node address)\\n        int n=lists.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ListNode *p = lists[i];\\n            while(p)\\n            {\\n                pq.push({-p->val, p}); // acts as min heap\\n                p = p->next;\\n            }\\n        }\\n                \\n        ListNode* head=NULL;\\n        ListNode* last=NULL;\\n        \\n        if(pq.empty()) return head;\\n        \\n        head=pq.top().second;\\n        last=pq.top().second;\\n        pq.pop();\\n        \\n        \\n        while(!pq.empty())\\n        {\\n            last->next = pq.top().second;\\n            last = pq.top().second;\\n            pq.pop();\\n            \\n        }\\n        last->next=NULL;\\n        \\n        return head;\\n        \\n    }\\n};\\n```\\n*Thanks for Upvoting !*\\n\\uD83D\\uDE42\\n**It highly motivates me for writing a such clustered posts in which all approaches will be present in a single place.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    struct compare\\n    {\\n        bool operator()(ListNode* a, ListNode *b)\\n        {\\n            return a->val > b->val;   // min heap  \\n        }\\n    };\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& arr) // saari linked list ka head arr mai hai\\n    {\\n        int j;\\n        for(j = 0;j< arr.size();j++){\\n            if(arr[j] != NULL)\\n                break;\\n        }\\n        if(j == arr.size()){ // all list empty\\n            return NULL;\\n        }\\n        \\n        priority_queue<ListNode*, vector<ListNode*>, compare>pq;   \\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] != NULL)\\n                pq.push(arr[i]);\\n        }\\n        \\n        ListNode *mergeH = new ListNode(0);\\n        ListNode *last = mergeH;\\n        while(!pq.empty())\\n        {\\n            ListNode* curr = pq.top();\\n            pq.pop();\\n            \\n            last->next = curr;\\n            last = last->next;\\n            \\n            if(curr != NULL && curr->next != NULL){\\n                pq.push(curr->next);\\n            }\\n            \\n        }\\n        return mergeH->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *a, ListNode* b)\\n    {\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        \\n        if(a->val<=b->val){\\n            a->next = mergeTwoSorted(a->next, b);\\n            return a;\\n        }\\n        else{\\n            b->next = mergeTwoSorted(a, b->next);\\n            return b;\\n        }\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        if(lists.size()==0) return NULL;\\n        while(lists.size() > 1){\\n            lists.push_back(mergeTwoSorted(lists[0], lists[1])); // time consuming \\n            // erase first 2 heads of lists\\n            lists.erase(lists.begin()); // time consuming \\n            lists.erase(lists.begin());\\n        }\\n        return lists[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *a, ListNode* b)\\n    {\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        \\n        if(a->val<=b->val){\\n            a->next = mergeTwoSorted(a->next, b);\\n            return a;\\n        }\\n        else{\\n            b->next = mergeTwoSorted(a, b->next);\\n            return b;\\n        }\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        int n=lists.size();\\n        if(lists.size()==0) return NULL;\\n        while(n>1){\\n            \\n            for(int i=0;i<n/2;i++)\\n                lists[i] = mergeTwoSorted(lists[i], lists[n-i-1]);\\n            n = (n+1)/2;\\n        }\\n        return lists.front();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *l1, ListNode* l2)\\n    {\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* last = dummy;\\n        \\n        while(l1 and l2)\\n        {\\n            if(l1->val <= l2->val){\\n                last->next = l1;\\n                last = l1;\\n                l1=l1->next;\\n            }\\n            else{\\n                last->next = l2;\\n                last = l2;\\n                l2=l2->next;\\n            }\\n        }\\n        \\n        if(!l1)\\n            last->next = l2;\\n        else\\n            last->next = l1;\\n        return dummy->next;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        int n=lists.size();\\n        if(lists.size()==0) return NULL;\\n        while(n>1){\\n            \\n            for(int i=0;i<n/2;i++)\\n                lists[i] = mergeTwoSorted(lists[i], lists[n-i-1]);\\n            n = (n+1)/2;\\n        }\\n        return lists.front();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        if(lists.empty()) return NULL;\\n        \\n        // MAX heap\\n        priority_queue<pair<int, ListNode*>> pq; // (value, Node address)\\n        int n=lists.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ListNode *p = lists[i];\\n            while(p)\\n            {\\n                pq.push({-p->val, p}); // acts as min heap\\n                p = p->next;\\n            }\\n        }\\n                \\n        ListNode* head=NULL;\\n        ListNode* last=NULL;\\n        \\n        if(pq.empty()) return head;\\n        \\n        head=pq.top().second;\\n        last=pq.top().second;\\n        pq.pop();\\n        \\n        \\n        while(!pq.empty())\\n        {\\n            last->next = pq.top().second;\\n            last = pq.top().second;\\n            pq.pop();\\n            \\n        }\\n        last->next=NULL;\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032723,
                "title": "python-heap-solution-explained",
                "content": "There are a bunch of different solutions for this problem, let us discuss solution, using **heaps** here. We need to iterate over `k` lists and on each step to choose the minimum element among `k` candidates, think of it as extention of classical merge stage in merge sort. If each time we find this minimum element, using lists, overall complexity will be `O(nk)`, where `n` is total number of elements in all lists. However we can do better: we create heap with the following tuples as elements:\\n1. First value of tuple is our value of nodes, because we want to sort using these values\\n2. Second value of tuple is index in `lists`, form where we choose this element. Why we need this? Because when we will merge this element, we need to go to the next element in the corresponding list.\\n\\nNow, let us discuss main steps of algorithm:\\n1. Create `dummy` node in linked list, which will help us to deal with border cases, such as empty lists and so on.\\n2. `curr` is current element in linked list where are in now.\\n3. Put all starts of `k` linked lists to heap (actually there can be less than `k`, because some of lists can be empty)\\n4. Extract `val, ind` element from our heap: it will be current minumum element, and attach it to the end of constucted merged least so far, move `curr` iterator to the right.\\n5. If we still did not reach the end of current list, move one step to the right in this list and put new candidate to heap.\\n6. Return `dummy.next`.\\n\\n**Complexity**: time complexity is `O(n log k)`, because we have `O(n)` steps, where we put and remove from heap, which have at most `k` elements. Space complexity is `O(n)`: because we need to return newly constructed linked list.\\n\\n```\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        dummy = curr = ListNode(0)\\n        heap = []\\n        for ind, el in enumerate(lists):\\n            if el: heappush(heap, (el.val, ind))\\n                \\n        while heap:\\n            val, ind = heappop(heap)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n            if lists[ind].next:\\n                lists[ind] = lists[ind].next\\n                heappush(heap, (lists[ind].val, ind))\\n                \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        dummy = curr = ListNode(0)\\n        heap = []\\n        for ind, el in enumerate(lists):\\n            if el: heappush(heap, (el.val, ind))\\n                \\n        while heap:\\n            val, ind = heappop(heap)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n            if lists[ind].next:\\n                lists[ind] = lists[ind].next\\n                heappush(heap, (lists[ind].val, ind))\\n                \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032502,
                "title": "python-simple-heap-solution",
                "content": "```html5\\n<b>Time Complexity: O(n&middot;log(m))</b> where n is the total number of elements and m is the number of lists\\n<b>Space Complexity: O(n)</b>\\n```\\n\\nQuestions are welcome.\\n\\n**Approach:**\\n\\n1. Take the first node of each of the linked lists\\nand add it into a heap.  When you add it to the heap\\nadd (node.val, i) where i is the i<sup>th</sup> list.\\n\\n2. Create a dummy node ```head```.  \\n\\n3. Pop the first node from the heap and make it the\\nnext node in the dummy-list.  Remember to add the\\nfirst node from the i<sup>th</sup> linked list into the heap\\nsince we just removed a node from this list from the heap.\\n\\n4. Repeat until the heap is empty.\\n\\n```python\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        head = ListNode(None)\\n        curr = head\\n        h = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i))\\n                lists[i] = lists[i].next\\n        \\n        while h:\\n            val, i = heapq.heappop(h)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i))\\n                lists[i] = lists[i].next\\n        \\n        return head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```html5\\n<b>Time Complexity: O(n&middot;log(m))</b> where n is the total number of elements and m is the number of lists\\n<b>Space Complexity: O(n)</b>\\n```\n```head```\n```python\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        head = ListNode(None)\\n        curr = head\\n        h = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i))\\n                lists[i] = lists[i].next\\n        \\n        while h:\\n            val, i = heapq.heappop(h)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i))\\n                lists[i] = lists[i].next\\n        \\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114606,
                "title": "extremely-simple-javascript-solution",
                "content": "### Solution\\nIn JS, an array has the shift() and pop() method that allows user to remove the head and tail element from the original array. \\n\\n```javascript\\nfunction mergeLists(a, b) {\\n    const dummy = new ListNode(0);\\n    let temp = dummy;\\n     while (a !== null && b !== null) {\\n         if (a.val < b.val) {\\n             temp.next = a;\\n             a = a.next;\\n         } else {\\n             temp.next = b;\\n             b = b.next;\\n         }\\n         temp = temp.next;\\n     }\\n    if (a !== null) {\\n        temp.next = a;\\n    }\\n    if (b !== null) {\\n        temp.next = b;\\n    }\\n    return dummy.next;\\n}\\n\\nvar mergeKLists = function(lists) {\\n    if (lists.length === 0 ) {\\n        return null;\\n    }\\n    // two two\\n    // priority queue\\n    while (lists.length > 1) {\\n        let a = lists.shift(); // the head will contains the \"less\" length list\\n        let b = lists.shift(); // acturally, we can use the linkedlist to replace it, the while loop will be the while( list.header.next !== null || lists.length > 0)\\n        const h = mergeLists(a, b);\\n        lists.push(h);\\n    }\\n    return lists[0];\\n};\\n```\\nAnother devide and conquer solution\\n```javascript\\nfunction merge (left, right) {\\n    if (!left) {\\n        return right;\\n    } else if (!right) {\\n        return left;\\n    } else if (left.val < right.val){\\n        left.next = merge(left.next, right);\\n        return left;\\n    } else {\\n        right.next = merge(left, right.next);\\n        return right;\\n    }\\n}\\n\\n\\nfunction helper(lists, start, end) {\\n    if (start === end) {\\n        return lists[start];\\n    } else if (start < end) {\\n        const mid = parseInt((start + end) / 2);\\n        const left = helper(lists, start, mid);\\n        const right = helper(lists, mid + 1, end);\\n        return merge(left, right);\\n    } else {\\n        return null;\\n    }\\n    \\n}\\n\\nvar mergeKLists = function(lists) {\\n    return helper(lists, 0, lists.length - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nfunction mergeLists(a, b) {\\n    const dummy = new ListNode(0);\\n    let temp = dummy;\\n     while (a !== null && b !== null) {\\n         if (a.val < b.val) {\\n             temp.next = a;\\n             a = a.next;\\n         } else {\\n             temp.next = b;\\n             b = b.next;\\n         }\\n         temp = temp.next;\\n     }\\n    if (a !== null) {\\n        temp.next = a;\\n    }\\n    if (b !== null) {\\n        temp.next = b;\\n    }\\n    return dummy.next;\\n}\\n\\nvar mergeKLists = function(lists) {\\n    if (lists.length === 0 ) {\\n        return null;\\n    }\\n    // two two\\n    // priority queue\\n    while (lists.length > 1) {\\n        let a = lists.shift(); // the head will contains the \"less\" length list\\n        let b = lists.shift(); // acturally, we can use the linkedlist to replace it, the while loop will be the while( list.header.next !== null || lists.length > 0)\\n        const h = mergeLists(a, b);\\n        lists.push(h);\\n    }\\n    return lists[0];\\n};\\n```\n```javascript\\nfunction merge (left, right) {\\n    if (!left) {\\n        return right;\\n    } else if (!right) {\\n        return left;\\n    } else if (left.val < right.val){\\n        left.next = merge(left.next, right);\\n        return left;\\n    } else {\\n        right.next = merge(left, right.next);\\n        return right;\\n    }\\n}\\n\\n\\nfunction helper(lists, start, end) {\\n    if (start === end) {\\n        return lists[start];\\n    } else if (start < end) {\\n        const mid = parseInt((start + end) / 2);\\n        const left = helper(lists, start, mid);\\n        const right = helper(lists, mid + 1, end);\\n        return merge(left, right);\\n    } else {\\n        return null;\\n    }\\n    \\n}\\n\\nvar mergeKLists = function(lists) {\\n    return helper(lists, 0, lists.length - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286070,
                "title": "day-71-divide-and-conquer-easiest-beginner-friendly-sol",
                "content": "**NOTE 1 - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n**NOTE 2 - BEFORE SOLVING THIS PROBELM, I WILL HIGHLY RECOMMEND YOU TO SOLVE BELOW PROBLEM FOR BETTER UNDERSTANDING.**\\n**21. Merge Two Sorted Lists :** https://leetcode.com/problems/merge-two-sorted-lists/description/ \\n**SOLUTION :** https://leetcode.com/problems/merge-two-sorted-lists/solutions/3288537/o-m-n-time-and-o-1-space-easiest-beginner-friendly-solution/\\n\\n# Intuition of this Problem:\\n**This solution uses the merge sort algorithm to merge all the linked lists in the input vector into a single sorted linked list. The merge sort algorithm works by recursively dividing the input into halves, sorting each half separately, and then merging the two sorted halves into a single sorted output.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Define a function merge that takes two pointers to linked lists as input and merges them in a sorted manner.\\n    - a. Create a dummy node with a value of -1 and a temporary node pointing to it.\\n    - b. Compare the first node of the left and right linked lists, and append the smaller one to the temporary node.\\n    - c. Continue this process until either of the lists becomes empty.\\n    - d. Append the remaining nodes of the non-empty list to the temporary node.\\n    - e. Return the next node of the dummy node.\\n\\n1. Define a function mergeSort that takes three arguments - a vector of linked lists, a starting index, and an ending index. It performs merge sort on the linked lists from the starting index to the ending index.\\n    - a. If the starting index is equal to the ending index, return the linked list at that index.\\n    - b. Calculate the mid index and call mergeSort recursively on the left and right halves of the vector.\\n    - c. Merge the two sorted linked lists obtained from the recursive calls using the merge function and return the result.\\n\\n1. Define the main function mergeKLists that takes the vector of linked lists as input and returns a single sorted linked list.\\n    - a. If the input vector is empty, return a null pointer.\\n    - b. Call the mergeSort function on the entire input vector, from index 0 to index k-1, where k is the size of the input vector.\\n    - c. Return the merged linked list obtained from the mergeSort function call.\\n1. End of algorithm.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode *left, ListNode *right) {\\n        ListNode *dummy = new ListNode(-1);\\n        ListNode *temp = dummy;\\n        while (left != nullptr && right != nullptr) {\\n            if (left -> val < right -> val) {\\n                temp -> next = left;\\n                temp = temp -> next;\\n                left = left -> next;\\n            }\\n            else {\\n                temp -> next = right;\\n                temp = temp -> next;\\n                right = right -> next;\\n            }\\n        }\\n        while (left != nullptr) {\\n            temp -> next = left;\\n            temp = temp -> next;\\n            left = left -> next;\\n        }\\n        while (right != nullptr) {\\n            temp -> next = right;\\n            temp = temp -> next;\\n            right = right -> next;\\n        }\\n        return dummy -> next;\\n    }\\n    ListNode* mergeSort(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) \\n            return lists[start];\\n        int mid = start + (end - start) / 2;\\n        ListNode *left = mergeSort(lists, start, mid);\\n        ListNode *right = mergeSort(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0)\\n            return nullptr;\\n        return mergeSort(lists, 0, lists.size() - 1);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode merge(ListNode left, ListNode right) {\\n        ListNode dummy = new ListNode(-1);\\n        ListNode temp = dummy;\\n        while (left != null && right != null) {\\n            if (left.val < right.val) {\\n                temp.next = left;\\n                temp = temp.next;\\n                left = left.next;\\n            } else {\\n                temp.next = right;\\n                temp = temp.next;\\n                right = right.next;\\n            }\\n        }\\n        while (left != null) {\\n            temp.next = left;\\n            temp = temp.next;\\n            left = left.next;\\n        }\\n        while (right != null) {\\n            temp.next = right;\\n            temp = temp.next;\\n            right = right.next;\\n        }\\n        return dummy.next;\\n    }\\n    \\n    public ListNode mergeSort(List<ListNode> lists, int start, int end) {\\n        if (start == end) {\\n            return lists.get(start);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeSort(lists, start, mid);\\n        ListNode right = mergeSort(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    public ListNode mergeKLists(List<ListNode> lists) {\\n        if (lists.size() == 0) {\\n            return null;\\n        }\\n        return mergeSort(lists, 0, lists.size() - 1);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def merge(self, left: ListNode, right: ListNode) -> ListNode:\\n        dummy = ListNode(-1)\\n        temp = dummy\\n        while left and right:\\n            if left.val < right.val:\\n                temp.next = left\\n                temp = temp.next\\n                left = left.next\\n            else:\\n                temp.next = right\\n                temp = temp.next\\n                right = right.next\\n        while left:\\n            temp.next = left\\n            temp = temp.next\\n            left = left.next\\n        while right:\\n            temp.next = right\\n            temp = temp.next\\n            right = right.next\\n        return dummy.next\\n    \\n    def mergeSort(self, lists: List[ListNode], start: int, end: int) -> ListNode:\\n        if start == end:\\n            return lists[start]\\n        mid = start + (end - start) // 2\\n        left = self.mergeSort(lists, start, mid)\\n        right = self.mergeSort(lists, mid + 1, end)\\n        return self.merge(left, right)\\n    \\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        return self.mergeSort(lists, 0, len(lists) - 1)\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(N log k)**, where N is the total number of nodes in all the linked lists, and k is the number of linked lists in the input vector. This is because the merge sort algorithm requires O(N log N) time to sort N items, and in this case, N is the total number of nodes in all the linked lists. The number of levels in the recursion tree of the merge sort algorithm is log k, where k is the number of linked lists in the input vector. Each level of the recursion tree requires O(N) time to merge the sorted lists, so the total time complexity is O(N log k).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(log k)**, which is the maximum depth of the recursion tree of the merge sort algorithm. The space used by each recursive call is constant, so the total space used by the algorithm is proportional to the maximum depth of the recursion tree. Since the depth of the tree is log k, the space complexity of the algorithm is O(log k).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode *left, ListNode *right) {\\n        ListNode *dummy = new ListNode(-1);\\n        ListNode *temp = dummy;\\n        while (left != nullptr && right != nullptr) {\\n            if (left -> val < right -> val) {\\n                temp -> next = left;\\n                temp = temp -> next;\\n                left = left -> next;\\n            }\\n            else {\\n                temp -> next = right;\\n                temp = temp -> next;\\n                right = right -> next;\\n            }\\n        }\\n        while (left != nullptr) {\\n            temp -> next = left;\\n            temp = temp -> next;\\n            left = left -> next;\\n        }\\n        while (right != nullptr) {\\n            temp -> next = right;\\n            temp = temp -> next;\\n            right = right -> next;\\n        }\\n        return dummy -> next;\\n    }\\n    ListNode* mergeSort(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) \\n            return lists[start];\\n        int mid = start + (end - start) / 2;\\n        ListNode *left = mergeSort(lists, start, mid);\\n        ListNode *right = mergeSort(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0)\\n            return nullptr;\\n        return mergeSort(lists, 0, lists.size() - 1);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode merge(ListNode left, ListNode right) {\\n        ListNode dummy = new ListNode(-1);\\n        ListNode temp = dummy;\\n        while (left != null && right != null) {\\n            if (left.val < right.val) {\\n                temp.next = left;\\n                temp = temp.next;\\n                left = left.next;\\n            } else {\\n                temp.next = right;\\n                temp = temp.next;\\n                right = right.next;\\n            }\\n        }\\n        while (left != null) {\\n            temp.next = left;\\n            temp = temp.next;\\n            left = left.next;\\n        }\\n        while (right != null) {\\n            temp.next = right;\\n            temp = temp.next;\\n            right = right.next;\\n        }\\n        return dummy.next;\\n    }\\n    \\n    public ListNode mergeSort(List<ListNode> lists, int start, int end) {\\n        if (start == end) {\\n            return lists.get(start);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeSort(lists, start, mid);\\n        ListNode right = mergeSort(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    public ListNode mergeKLists(List<ListNode> lists) {\\n        if (lists.size() == 0) {\\n            return null;\\n        }\\n        return mergeSort(lists, 0, lists.size() - 1);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def merge(self, left: ListNode, right: ListNode) -> ListNode:\\n        dummy = ListNode(-1)\\n        temp = dummy\\n        while left and right:\\n            if left.val < right.val:\\n                temp.next = left\\n                temp = temp.next\\n                left = left.next\\n            else:\\n                temp.next = right\\n                temp = temp.next\\n                right = right.next\\n        while left:\\n            temp.next = left\\n            temp = temp.next\\n            left = left.next\\n        while right:\\n            temp.next = right\\n            temp = temp.next\\n            right = right.next\\n        return dummy.next\\n    \\n    def mergeSort(self, lists: List[ListNode], start: int, end: int) -> ListNode:\\n        if start == end:\\n            return lists[start]\\n        mid = start + (end - start) // 2\\n        left = self.mergeSort(lists, start, mid)\\n        right = self.mergeSort(lists, mid + 1, end)\\n        return self.merge(left, right)\\n    \\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        return self.mergeSort(lists, 0, len(lists) - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10809,
                "title": "13-lines-in-java",
                "content": "Hi guys!\\n\\nThe approach is standard - PriorityQueue, but I noticed that solutions presented before are kind of a bit long. So that's the concise version. :)\\n\\nHope it helps!\\n\\n----------\\n\\n    public class Solution {\\n        public ListNode mergeKLists(List<ListNode> lists) {\\n            Queue<ListNode> heap = new PriorityQueue(new Comparator<ListNode>(){\\n                @Override public int compare(ListNode l1, ListNode l2) { \\n                    return l1.val - l2.val; \\n                }\\n            });\\n            ListNode head = new ListNode(0), tail = head;\\n            for (ListNode node : lists) if (node != null) heap.offer(node);\\n            while (!heap.isEmpty()) {\\n                tail.next = heap.poll();\\n                tail = tail.next;\\n                if (tail.next != null) heap.offer(tail.next);\\n            }\\n            return head.next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode mergeKLists(List<ListNode> lists) {\\n            Queue<ListNode> heap = new PriorityQueue(new Comparator<ListNode>(){\\n                @Override public int compare(ListNode l1, ListNode l2) { \\n                    return l1.val - l2.val; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 10543,
                "title": "brief-c-solution-with-priority-queue",
                "content": "We just need to define a comparison struct for ListNodes, then managing the priority\\\\_queue is quite straightforward. After filling the priority\\\\_queue, if it is non-empty, we set the head and tail. Then we repeatedly pop the top off the queue and append that to the tail. If the next node is not null, we push it onto the queue.\\n\\n\\n\\n    class Solution {\\n        struct compare {\\n            bool operator()(const ListNode* l, const ListNode* r) {\\n                return l->val > r->val;\\n            }\\n        };\\n        \\n    public:\\n        ListNode *mergeKLists(vector<ListNode *> &lists) {\\n            priority_queue<ListNode *, vector<ListNode *>, compare> q;\\n            for (auto l : lists) {\\n                if (l) {\\n                    q.push(l);\\n                }\\n            }\\n            \\n            if (q.empty()) {\\n                return NULL;\\n            }\\n            \\n            ListNode* result = q.top();\\n            q.pop();\\n            if (result->next) {\\n                q.push(result->next);\\n            }\\n\\n            ListNode* tail = result;            \\n            while (!q.empty()) {\\n                tail->next = q.top();\\n                q.pop();\\n                tail = tail->next;\\n                if (tail->next) {\\n                    q.push(tail->next);\\n                }\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        struct compare {\\n            bool operator()(const ListNode* l, const ListNode* r) {\\n                return l->val > r->val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1745539,
                "title": "python3-priority-queue-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main challenge in the problem is the fact that the number of lists `k` can be huge and iterating over list heads every time attaching a new node to the result would be time-consuming. Essentially what is important to know on every merging step is what is the smallest node among all list heads. We can utilize the priority queue to fast access the current smallest node. \\n\\nFirst, we form the initial heap with tuples containing val and node itself. Notice that in Python implementation of the heap, the first element of the tuple is considered as a priority. In case the heap already has an element with the same priority, the Python compares the next element of the tuple. That is why we need index `i` in the second place.\\n\\nThen we run a cycle until the heap is empty. On every step, we pop out the smallest node and attach it to the result. Right away we push to the heap the next node.\\n\\nTime: **O(k * n * log(k))** - scan and manipulation with heap\\nSpace: **O(k)** - for the heap\\n\\nRuntime: 96 ms, faster than **93.66%** of Python3 online submissions for Merge k Sorted Lists.\\nMemory Usage: 17.9 MB, less than **61.96%** of Python3 online submissions for Merge k Sorted Lists.\\n\\n```\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n\\theap, res = [], ListNode()\\n\\tfor i, list in enumerate(lists):\\n\\t\\tif list: \\n\\t\\t\\theappush(heap, (list.val, i, list))\\n\\n\\tcur = res\\n\\twhile heap:\\n\\t\\t_, i, list = heappop(heap)\\n\\t\\tif list.next:\\n\\t\\t\\theappush(heap, (list.next.val, i, list.next))\\n\\n\\t\\tcur.next, cur = list, list\\n\\n\\treturn res.next\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n\\theap, res = [], ListNode()\\n\\tfor i, list in enumerate(lists):\\n\\t\\tif list: \\n\\t\\t\\theappush(heap, (list.val, i, list))\\n\\n\\tcur = res\\n\\twhile heap:\\n\\t\\t_, i, list = heappop(heap)\\n\\t\\tif list.next:\\n\\t\\t\\theappush(heap, (list.next.val, i, list.next))\\n\\n\\t\\tcur.next, cur = list, list\\n\\n\\treturn res.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 611161,
                "title": "fast-c-solution-95-with-comments-and-explanation-uses-minheap",
                "content": "The implementation beats 85% in terms of speed.\\nComplexity: **nlog(k)**\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *mergeKLists(vector<ListNode *> &lists)\\n    {\\n        if (lists.empty() || lists.size() == 0)\\n        {\\n            return NULL;\\n        }\\n\\n        // This comparator will be used to build MIN HEAP.\\n        // We use a LAMBDA to define the comparator.\\n        auto comp = [&](ListNode *a, ListNode *b) {\\n            return a->val > b->val;\\n        };\\n\\n        // This priority queue is our MIN HEAP\\n        priority_queue<ListNode *, vector<ListNode *>, decltype(comp)> pq(comp);\\n\\n        /*\\n        * We iterate the list of LinkedLists and add the head\\n        * of every list to the heap (the heap becomes of size k)\\n        */\\n        for (int i = 0; i < lists.size(); i++)\\n        {\\n            if (lists[i])\\n            {\\n                pq.push(lists[i]);\\n            }\\n        }\\n\\n        ListNode dummyHead(0);\\n        ListNode *tail = &dummyHead;\\n\\n        // Simply start popping the nodes from the heap and keep adding them to the list;\\n        while (!pq.empty())\\n        {\\n            // Pop the top element and store it in temp\\n            auto temp = pq.top();\\n            pq.pop();\\n\\n            // Add it to the list\\n            tail->next = temp;\\n            // Move the tail to the newly added element\\n            tail = tail->next;\\n\\n            // if there are more nodes attached to this node in the list\\n            // Push the next node of the list into the heap\\n            if (temp->next)\\n            {\\n                pq.push(temp->next);\\n            }\\n        }\\n\\n        // Make sure you set the next pointer of the last added node to NULL\\n        tail->next = NULL;\\n\\n        // We used the dummyHead to keep track of the start of the list.\\n        return dummyHead.next;\\n    }\\n};\\n```\\n\\nWe can think of an even faster solution though.\\nWe can store the values of all the nodes in an **ordered map**, with the second value as the frequency and after going over all the nodes of all the linked lists, simply iterate over that map and keep creating new ListNodes for every value (depending on the frequency).\\nRuns faster than 95% submissions\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        // Create an ordered map\\n        map<int, int> nodes;\\n        \\n        // Add all nodes of all the LinkedLists to the map with\\n        // with the ListNode->val as the key & that value\\'s frequency as the mapped value\\n        for(int i = 0; i < lists.size(); ++i){\\n            auto node = lists[i];\\n            while(node){\\n                int temp = node->val;\\n                nodes[temp]++;\\n                node = node->next;\\n            }\\n        }\\n        \\n        ListNode dummyHead(0);\\n        ListNode* tail = &dummyHead;\\n        \\n        for(auto it: nodes){\\n            while(it.second != 0){\\n                ListNode* newNode= new ListNode(it.first);\\n                tail->next = newNode;\\n                tail = tail->next;\\n                it.second--;\\n            }\\n        }\\n        return dummyHead.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    ListNode *mergeKLists(vector<ListNode *> &lists)\\n    {\\n        if (lists.empty() || lists.size() == 0)\\n        {\\n            return NULL;\\n        }\\n\\n        // This comparator will be used to build MIN HEAP.\\n        // We use a LAMBDA to define the comparator.\\n        auto comp = [&](ListNode *a, ListNode *b) {\\n            return a->val > b->val;\\n        };\\n\\n        // This priority queue is our MIN HEAP\\n        priority_queue<ListNode *, vector<ListNode *>, decltype(comp)> pq(comp);\\n\\n        /*\\n        * We iterate the list of LinkedLists and add the head\\n        * of every list to the heap (the heap becomes of size k)\\n        */\\n        for (int i = 0; i < lists.size(); i++)\\n        {\\n            if (lists[i])\\n            {\\n                pq.push(lists[i]);\\n            }\\n        }\\n\\n        ListNode dummyHead(0);\\n        ListNode *tail = &dummyHead;\\n\\n        // Simply start popping the nodes from the heap and keep adding them to the list;\\n        while (!pq.empty())\\n        {\\n            // Pop the top element and store it in temp\\n            auto temp = pq.top();\\n            pq.pop();\\n\\n            // Add it to the list\\n            tail->next = temp;\\n            // Move the tail to the newly added element\\n            tail = tail->next;\\n\\n            // if there are more nodes attached to this node in the list\\n            // Push the next node of the list into the heap\\n            if (temp->next)\\n            {\\n                pq.push(temp->next);\\n            }\\n        }\\n\\n        // Make sure you set the next pointer of the last added node to NULL\\n        tail->next = NULL;\\n\\n        // We used the dummyHead to keep track of the start of the list.\\n        return dummyHead.next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        // Create an ordered map\\n        map<int, int> nodes;\\n        \\n        // Add all nodes of all the LinkedLists to the map with\\n        // with the ListNode->val as the key & that value\\'s frequency as the mapped value\\n        for(int i = 0; i < lists.size(); ++i){\\n            auto node = lists[i];\\n            while(node){\\n                int temp = node->val;\\n                nodes[temp]++;\\n                node = node->next;\\n            }\\n        }\\n        \\n        ListNode dummyHead(0);\\n        ListNode* tail = &dummyHead;\\n        \\n        for(auto it: nodes){\\n            while(it.second != 0){\\n                ListNode* newNode= new ListNode(it.first);\\n                tail->next = newNode;\\n                tail = tail->next;\\n                it.second--;\\n            }\\n        }\\n        return dummyHead.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327596,
                "title": "javascript-3-solutions",
                "content": "1\\uFE0F\\u20E3push to array and sort\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_sort = function(lists) {\\n    if(!lists || !lists.length) return null;\\n    let arr = [], res = new ListNode(-1);\\n    \\n    lists.forEach(list => {\\n        let cur = list;\\n        while(cur) {\\n            arr.push(cur.val);\\n            cur = cur.next;\\n        }\\n    });\\n    \\n    let cur = res;\\n    arr.sort((a,b) => a - b)\\n        .forEach(n => {\\n        let temp = new ListNode(n);\\n        cur.next = temp;\\n        cur = cur.next;\\n    });\\n    return res.next;\\n};\\n```\\n\\n2\\uFE0F\\u20E3compare one by one\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_compare_one_by_one = function(lists) {\\n    if(!lists || !lists.length) return null;\\n    const findMinNode = (lists = lists) => {\\n        let index = -1, \\n            min = Number.MAX_SAFE_INTEGER;\\n        for(let i = 0; i < lists.length; i++) {\\n            if(!lists[i]) continue;\\n            if(lists[i].val <= min) {\\n                min = lists[i].val;\\n                index = i;\\n            }\\n        }\\n        \\n        let resNode = null;\\n        if(index !== -1) {\\n            resNode = lists[index];\\n            lists[index] = lists[index].next;\\n        }\\n        return resNode;\\n    };\\n    \\n    let res = new ListNode(-1),\\n        cur = res,\\n        temp = findMinNode(lists);\\n    while(temp) {\\n        cur.next = temp;\\n        cur = cur.next;\\n        temp = findMinNode(lists);\\n    }\\n    return res.next;\\n}\\n```\\n\\n\\n3\\uFE0F\\u20E3use priority queue (min heap)\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_priority_queue = function(lists) {\\n    let queue = new PriorityQueue();\\n    lists.forEach(list => {\\n        if(list) queue.enqueue(list, list.val)\\n    });\\n\\n    let res = new ListNode(-1);\\n    let cur = res;\\n    while(!queue.isEmpty()) {\\n        cur.next = queue.dequeue();\\n        cur = cur.next;\\n        if(cur.next) queue.enqueue(cur.next, cur.next.val);\\n    }\\n    return res.next;\\n}\\n\\nclass Node {\\n\\tconstructor(val, priority) {\\n\\t\\tthis.val = val;\\n\\t\\tthis.priority = priority;\\n\\t}\\n}\\n\\nclass PriorityQueue {\\n\\tconstructor() {\\n\\t\\tthis.values = [];\\n\\t}\\n\\n\\tenqueue(val, priority) {\\n\\t\\tlet node = new Node(val, priority);\\n\\t\\tthis.values.push(node);\\n\\t\\tthis.bubbleUp();\\n\\t}\\n\\n\\tdequeue() {\\n\\t\\tlet max = this.values[0];\\n\\t\\tlet end = this.values.pop();\\n\\t\\tif(this.values.length) {\\n\\t\\t\\tthis.values[0] = end;\\n\\t\\t\\tthis.bubbleDown();\\n\\t\\t}\\n\\t\\treturn max.val;\\n\\t}\\n    \\n    isEmpty() {\\n        return !this.values.length;\\n    }\\n    \\n    bubbleUp(index = this.values.length - 1) {\\n\\t\\tif(index <= 0) return;\\n\\t\\tlet parentIndex = Math.floor((index - 1) / 2);\\n\\t\\tif(this.values[index].priority <= this.values[parentIndex].priority) {\\n\\t\\t\\t[this.values[index], this.values[parentIndex]] = [this.values[parentIndex], this.values[index]];\\n\\t\\t\\tthis.bubbleUp(parentIndex);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tbubbleDown(index = 0, swapIndex = null) {\\n\\t\\tlet leftIndex = index * 2 + 1,\\n\\t\\t\\trightIndex = index * 2 + 2,\\n\\t\\t\\tlength = this.values.length;\\n\\n\\t\\tif(leftIndex < length) {\\n\\t\\t\\tif(this.values[leftIndex].priority <= this.values[index].priority) {\\n\\t\\t\\t\\tswapIndex = leftIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(rightIndex < length) {\\n\\t\\t\\tif((swapIndex === null && this.values[rightIndex].priority <= this.values[index].priority) || (swapIndex !== null && this.values[rightIndex].priority <= this.values[leftIndex].priority)) {\\n\\t\\t\\t\\tswapIndex = rightIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(swapIndex !== null) {\\n\\t\\t\\t[this.values[index], this.values[swapIndex]] = [this.values[swapIndex], this.values[index]];\\n\\t\\t\\tthis.bubbleDown(swapIndex, null);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_sort = function(lists) {\\n    if(!lists || !lists.length) return null;\\n    let arr = [], res = new ListNode(-1);\\n    \\n    lists.forEach(list => {\\n        let cur = list;\\n        while(cur) {\\n            arr.push(cur.val);\\n            cur = cur.next;\\n        }\\n    });\\n    \\n    let cur = res;\\n    arr.sort((a,b) => a - b)\\n        .forEach(n => {\\n        let temp = new ListNode(n);\\n        cur.next = temp;\\n        cur = cur.next;\\n    });\\n    return res.next;\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_compare_one_by_one = function(lists) {\\n    if(!lists || !lists.length) return null;\\n    const findMinNode = (lists = lists) => {\\n        let index = -1, \\n            min = Number.MAX_SAFE_INTEGER;\\n        for(let i = 0; i < lists.length; i++) {\\n            if(!lists[i]) continue;\\n            if(lists[i].val <= min) {\\n                min = lists[i].val;\\n                index = i;\\n            }\\n        }\\n        \\n        let resNode = null;\\n        if(index !== -1) {\\n            resNode = lists[index];\\n            lists[index] = lists[index].next;\\n        }\\n        return resNode;\\n    };\\n    \\n    let res = new ListNode(-1),\\n        cur = res,\\n        temp = findMinNode(lists);\\n    while(temp) {\\n        cur.next = temp;\\n        cur = cur.next;\\n        temp = findMinNode(lists);\\n    }\\n    return res.next;\\n}\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_priority_queue = function(lists) {\\n    let queue = new PriorityQueue();\\n    lists.forEach(list => {\\n        if(list) queue.enqueue(list, list.val)\\n    });\\n\\n    let res = new ListNode(-1);\\n    let cur = res;\\n    while(!queue.isEmpty()) {\\n        cur.next = queue.dequeue();\\n        cur = cur.next;\\n        if(cur.next) queue.enqueue(cur.next, cur.next.val);\\n    }\\n    return res.next;\\n}\\n\\nclass Node {\\n\\tconstructor(val, priority) {\\n\\t\\tthis.val = val;\\n\\t\\tthis.priority = priority;\\n\\t}\\n}\\n\\nclass PriorityQueue {\\n\\tconstructor() {\\n\\t\\tthis.values = [];\\n\\t}\\n\\n\\tenqueue(val, priority) {\\n\\t\\tlet node = new Node(val, priority);\\n\\t\\tthis.values.push(node);\\n\\t\\tthis.bubbleUp();\\n\\t}\\n\\n\\tdequeue() {\\n\\t\\tlet max = this.values[0];\\n\\t\\tlet end = this.values.pop();\\n\\t\\tif(this.values.length) {\\n\\t\\t\\tthis.values[0] = end;\\n\\t\\t\\tthis.bubbleDown();\\n\\t\\t}\\n\\t\\treturn max.val;\\n\\t}\\n    \\n    isEmpty() {\\n        return !this.values.length;\\n    }\\n    \\n    bubbleUp(index = this.values.length - 1) {\\n\\t\\tif(index <= 0) return;\\n\\t\\tlet parentIndex = Math.floor((index - 1) / 2);\\n\\t\\tif(this.values[index].priority <= this.values[parentIndex].priority) {\\n\\t\\t\\t[this.values[index], this.values[parentIndex]] = [this.values[parentIndex], this.values[index]];\\n\\t\\t\\tthis.bubbleUp(parentIndex);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tbubbleDown(index = 0, swapIndex = null) {\\n\\t\\tlet leftIndex = index * 2 + 1,\\n\\t\\t\\trightIndex = index * 2 + 2,\\n\\t\\t\\tlength = this.values.length;\\n\\n\\t\\tif(leftIndex < length) {\\n\\t\\t\\tif(this.values[leftIndex].priority <= this.values[index].priority) {\\n\\t\\t\\t\\tswapIndex = leftIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(rightIndex < length) {\\n\\t\\t\\tif((swapIndex === null && this.values[rightIndex].priority <= this.values[index].priority) || (swapIndex !== null && this.values[rightIndex].priority <= this.values[leftIndex].priority)) {\\n\\t\\t\\t\\tswapIndex = rightIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(swapIndex !== null) {\\n\\t\\t\\t[this.values[index], this.values[swapIndex]] = [this.values[swapIndex], this.values[index]];\\n\\t\\t\\tthis.bubbleDown(swapIndex, null);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286803,
                "title": "python3-and-c-95-ms-beats-95-60-and-easy",
                "content": "# Please UPVOTE\\uD83D\\uDE0A\\n![image.png](https://assets.leetcode.com/users/images/71bb105c-bbdb-4f07-9d29-893ea49c0174_1678597927.929296.png)\\n\\n\\n# Python3\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        v=[]\\n        for i in lists:\\n            x=i\\n            while x:\\n                v+=[x.val]\\n                x=x.next\\n        v=sorted(v,reverse=True)\\n        ans=None\\n        for i in v:\\n            ans=ListNode(i,ans)\\n        return ans\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int>v;\\n        for(int i=0;i<lists.size();i++){\\n            while(lists[i]){\\n                v.push_back(lists[i]->val);\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        sort(rbegin(v),rend(v));\\n        ListNode* ans=nullptr;\\n        for(int i=0;i<v.size();i++){\\n            ans=new ListNode(v[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        v=[]\\n        for i in lists:\\n            x=i\\n            while x:\\n                v+=[x.val]\\n                x=x.next\\n        v=sorted(v,reverse=True)\\n        ans=None\\n        for i in v:\\n            ans=ListNode(i,ans)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int>v;\\n        for(int i=0;i<lists.size();i++){\\n            while(lists[i]){\\n                v.push_back(lists[i]->val);\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        sort(rbegin(v),rend(v));\\n        ListNode* ans=nullptr;\\n        for(int i=0;i<v.size();i++){\\n            ans=new ListNode(v[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032551,
                "title": "c-3-sols-brute-force-priority-queue-divide-and-conquer-method",
                "content": "Solution 1:\\n**Brute Force**\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* merge(ListNode* a,ListNode* b) {\\n        if(!a) return b;\\n        if(!b) return a;\\n        ListNode* temp=NULL;\\n        if(a->val<=b->val) \\n        {\\n            temp =a;\\n            temp->next = merge(a->next,b);\\n        }\\n        else \\n        {\\n            temp = b;\\n            temp->next = merge(a,b->next);\\n        }\\n        return temp;        \\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0) return NULL;\\n        if(lists.size()==1) return lists[0];\\n        ListNode* ans=NULL;\\n        for(auto l : lists) \\n        {\\n            ans = merge(ans,l);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nSolution 2:\\n**Priority queue**\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0) return NULL;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<lists.size();i++)\\n        {\\n            ListNode* head = lists[i];\\n            while(head!=NULL)\\n            {\\n                pq.push(head->val);\\n                head = head->next;\\n            }\\n        }\\n        ListNode* start = NULL;\\n        ListNode* end = NULL;\\n        while(!pq.empty()) {\\n            if(start==NULL)\\n            {\\n                start = new ListNode(pq.top());\\n                end = start;\\n                pq.pop();\\n            }\\n            else{\\n                end->next = new ListNode(pq.top());\\n                pq.pop();\\n                end = end->next;\\n            }\\n        }\\n            return start;\\n    }\\n};\\n```\\nSolution 3:\\n**Divide and Conquer**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergesort(ListNode* a  , ListNode* b) {\\n        if(!a) \\n            return b;\\n        if(!b)\\n            return a;\\n        ListNode* ans=NULL;\\n        if(a->val<=b->val)\\n        {\\n            ans=a;\\n            ans->next = mergesort(a->next,b);\\n        }\\n        else\\n        {\\n            ans=b;\\n            ans->next = mergesort(a,b->next);\\n        }\\n        return ans;\\n    }\\n    \\n    ListNode* mergeK(vector<ListNode*>& lists,int k) {\\n        while(k!=0) {\\n            int i = 0,j = k;\\n            while(i<j) {\\n                lists[i]=mergesort(lists[i],lists[j]);\\n                i++;\\n                j--;\\n                if(i>=j) \\n                    k=j;\\n            }\\n        }\\n        return lists[0];\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==1)\\n            return lists[0];\\n        if(lists.size()==0) \\n            return NULL;\\n        ListNode*newhead = mergeK(lists,lists.size()-1);\\n        return newhead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* merge(ListNode* a,ListNode* b) {\\n        if(!a) return b;\\n        if(!b) return a;\\n        ListNode* temp=NULL;\\n        if(a->val<=b->val) \\n        {\\n            temp =a;\\n            temp->next = merge(a->next,b);\\n        }\\n        else \\n        {\\n            temp = b;\\n            temp->next = merge(a,b->next);\\n        }\\n        return temp;        \\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0) return NULL;\\n        if(lists.size()==1) return lists[0];\\n        ListNode* ans=NULL;\\n        for(auto l : lists) \\n        {\\n            ans = merge(ans,l);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0) return NULL;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<lists.size();i++)\\n        {\\n            ListNode* head = lists[i];\\n            while(head!=NULL)\\n            {\\n                pq.push(head->val);\\n                head = head->next;\\n            }\\n        }\\n        ListNode* start = NULL;\\n        ListNode* end = NULL;\\n        while(!pq.empty()) {\\n            if(start==NULL)\\n            {\\n                start = new ListNode(pq.top());\\n                end = start;\\n                pq.pop();\\n            }\\n            else{\\n                end->next = new ListNode(pq.top());\\n                pq.pop();\\n                end = end->next;\\n            }\\n        }\\n            return start;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergesort(ListNode* a  , ListNode* b) {\\n        if(!a) \\n            return b;\\n        if(!b)\\n            return a;\\n        ListNode* ans=NULL;\\n        if(a->val<=b->val)\\n        {\\n            ans=a;\\n            ans->next = mergesort(a->next,b);\\n        }\\n        else\\n        {\\n            ans=b;\\n            ans->next = mergesort(a,b->next);\\n        }\\n        return ans;\\n    }\\n    \\n    ListNode* mergeK(vector<ListNode*>& lists,int k) {\\n        while(k!=0) {\\n            int i = 0,j = k;\\n            while(i<j) {\\n                lists[i]=mergesort(lists[i],lists[j]);\\n                i++;\\n                j--;\\n                if(i>=j) \\n                    k=j;\\n            }\\n        }\\n        return lists[0];\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==1)\\n            return lists[0];\\n        if(lists.size()==0) \\n            return NULL;\\n        ListNode*newhead = mergeK(lists,lists.size()-1);\\n        return newhead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030987,
                "title": "javascript-minpriorityqueue",
                "content": "Following Approach 3 from the solution set\\n\\nThis uses `MinPriorityQueue` class from the `datastructures-js` library that is available in the LeetCode runtime. I would argue that since these datastructures are available in other languages I would not expect to have to write my own implementation in an interview and it should be sufficient to \"stub\" a class as long as I can explain the underlying data structure\\n\\n```\\nconst mergeKLists = function(lists) {\\n  const queue = new MinPriorityQueue({ priority: x => x.val })\\n\\n  for (const head of lists) {\\n    if (head) {\\n      queue.enqueue(head)\\n    }\\n  }\\n\\n  let result = new ListNode()\\n  const head = result\\n\\n  while (!queue.isEmpty()) {\\n    const { val, next } = queue.dequeue().element\\n\\n    result.next = new ListNode(val)\\n    result = result.next\\n\\n    if (next) {\\n      queue.enqueue(next)\\n    }\\n  }\\n\\n  return head.next\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst mergeKLists = function(lists) {\\n  const queue = new MinPriorityQueue({ priority: x => x.val })\\n\\n  for (const head of lists) {\\n    if (head) {\\n      queue.enqueue(head)\\n    }\\n  }\\n\\n  let result = new ListNode()\\n  const head = result\\n\\n  while (!queue.isEmpty()) {\\n    const { val, next } = queue.dequeue().element\\n\\n    result.next = new ListNode(val)\\n    result = result.next\\n\\n    if (next) {\\n      queue.enqueue(next)\\n    }\\n  }\\n\\n  return head.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447503,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Merge Two Sorted Lists  K-1 times**\\n- Use the idea from [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/discuss/1447438).\\n```python\\nclass Solution:\\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while l1 != None and l2 != None:\\n            if l1.val <= l2.val:\\n                curHead.next = l1\\n                curHead = curHead.next\\n                l1 = l1.next\\n            else:\\n                curHead.next = l2\\n                curHead = curHead.next\\n                l2 = l2.next\\n                \\n        if l1 != None: curHead.next = l1\\n        if l2 != None: curHead.next = l2\\n        return dummyHead.next\\n    \\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        k = len(lists)\\n        if k == 0: return None\\n        if k == 1: return lists[0]\\n        \\n        curList = lists[0]\\n        for i in range(1, k):\\n            curList = self.mergeTwoLists(curList, lists[i])\\n        return curList\\n```\\nComplexity:\\n- Time: `O(K^2 * M)`, where `K <= 10^4` is length of `lists`, `M <= 500` is number of elements each list.\\n\\t- Explain: `mergeTwoLists(list1, list2)` take `O(|list1|+|list2|)`.\\n\\t- We merge `k` lists\\n\\t\\t- Merge first list and second list: `M + M = 2M`\\n\\t\\t- Merge current list and third list: `2M + M = 3M`\\n\\t\\t- ...\\n\\t\\t- Merge current list and `k` list: `K*M`\\n\\t\\t- Total: `O(2M + 3M + ... + K * M) ~ O(M * K * (K+1)/2) ~ O(K^2 * M)`\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Merge with Divide and Conquer**\\n- Step = 1, \\n\\t- `lists[0] = mergeTwoLists(lists[0], lists[1])`.\\n\\t- `lists[2] = mergeTwoLists(lists[2], lists[3])`.\\n\\t- `lists[4] = mergeTwoLists(lists[4], lists[5])`.\\n\\t- ...\\n- Step = 2, \\n\\t- `lists[0] = mergeTwoLists(lists[0], lists[2])`.\\n\\t- `lists[4] = mergeTwoLists(lists[4], lists[6])`.\\n\\t- `lists[8] = mergeTwoLists(lists[8], lists[10])`.\\n- Step = 4, 8...\\n```python\\nclass Solution:\\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while l1 != None and l2 != None:\\n            if l1.val <= l2.val:\\n                curHead.next = l1\\n                curHead = curHead.next\\n                l1 = l1.next\\n            else:\\n                curHead.next = l2\\n                curHead = curHead.next\\n                l2 = l2.next\\n                \\n        if l1 != None: curHead.next = l1\\n        if l2 != None: curHead.next = l2\\n        return dummyHead.next\\n    \\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        k = len(lists)\\n        if k == 0: return None\\n        step = 1\\n        while step < k:\\n            for i in range(0, k-step, step + step):\\n                lists[i] = self.mergeTwoLists(lists[i], lists[i+step])\\n            step += step \\n        return lists[0]\\n```\\nComplexity:\\n- Time: `O(logK * M * K)`, where `K <= 10^4` is length of `lists`, `M <= 500` is number of elements each list.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while l1 != None and l2 != None:\\n            if l1.val <= l2.val:\\n                curHead.next = l1\\n                curHead = curHead.next\\n                l1 = l1.next\\n            else:\\n                curHead.next = l2\\n                curHead = curHead.next\\n                l2 = l2.next\\n                \\n        if l1 != None: curHead.next = l1\\n        if l2 != None: curHead.next = l2\\n        return dummyHead.next\\n    \\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        k = len(lists)\\n        if k == 0: return None\\n        if k == 1: return lists[0]\\n        \\n        curList = lists[0]\\n        for i in range(1, k):\\n            curList = self.mergeTwoLists(curList, lists[i])\\n        return curList\\n```\n```python\\nclass Solution:\\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while l1 != None and l2 != None:\\n            if l1.val <= l2.val:\\n                curHead.next = l1\\n                curHead = curHead.next\\n                l1 = l1.next\\n            else:\\n                curHead.next = l2\\n                curHead = curHead.next\\n                l2 = l2.next\\n                \\n        if l1 != None: curHead.next = l1\\n        if l2 != None: curHead.next = l2\\n        return dummyHead.next\\n    \\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        k = len(lists)\\n        if k == 0: return None\\n        step = 1\\n        while step < k:\\n            for i in range(0, k-step, step + step):\\n                lists[i] = self.mergeTwoLists(lists[i], lists[i+step])\\n            step += step \\n        return lists[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368112,
                "title": "simple-python-heapq-with-custom-comparator-function",
                "content": "We use a priority-queue (`heapq`) find the next element to add. To make the implementation simple we \"monkey patch\" the `ListNode` class to have a custom _less-than_ function using `setattr`. Note that, simply using the tuple trick and pushing `(node.val, node)` to the priority queue will not work because the lists have values in common.\\n\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        setattr(ListNode, \"__lt__\", lambda self, other: self.val <= other.val)\\n            \\n        pq = []\\n        for l in lists:\\n            if l:\\n                heapq.heappush(pq,  l)\\n        \\n        out = ListNode(None)\\n        head = out\\n        while pq:\\n            l = heapq.heappop(pq)\\n            head.next = l\\n            head = head.next\\n            if l and l.next:\\n                heapq.heappush( pq, l.next)\\n            \\n        return out.next\\n```\\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        setattr(ListNode, \"__lt__\", lambda self, other: self.val <= other.val)\\n            \\n        pq = []\\n        for l in lists:\\n            if l:\\n                heapq.heappush(pq,  l)\\n        \\n        out = ListNode(None)\\n        head = out\\n        while pq:\\n            l = heapq.heappop(pq)\\n            head.next = l\\n            head = head.next\\n            if l and l.next:\\n                heapq.heappush( pq, l.next)\\n            \\n        return out.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10610,
                "title": "c-code-o-nlogk-in-time-o-1-in-space-divide-conquer",
                "content": "    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = (int)lists.size();\\n        if(k==0) return NULL;\\n        if(k==1) return lists[0];\\n        return doMerge(lists, 0, (int)lists.size()-1);\\n    }\\n    \\n    \\n    ListNode* doMerge(vector<ListNode*>& lists, int left, int right) {\\n        if(left==right) return lists[left];\\n        else if(left+1==right) return merge2Lists(lists[left], lists[right]);\\n        ListNode* l1 = doMerge(lists, left, (left+right)/2);\\n        ListNode* l2 = doMerge(lists, (left+right)/2+1, right);\\n        return merge2Lists(l1, l2);\\n    }\\n    \\n    \\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        if(l1==l2) return l1;\\n        if(!l1) return l2;\\n        if(!l2) return l1;\\n        if(l1->val>l2->val) return merge2Lists(l2, l1);\\n        ListNode* newl2 = new ListNode(0); newl2->next = l2;\\n        ListNode* p1 = l1;\\n        while (p1->next && newl2->next) {\\n            if (p1->next->val<newl2->next->val) {\\n                p1 = p1->next;\\n            } else {\\n                ListNode* temp = p1->next;\\n                p1->next = newl2->next;\\n                newl2->next = newl2->next->next;\\n                p1->next->next = temp;\\n                p1 = p1->next;\\n            }\\n        }\\n        if(!p1->next) p1->next = newl2->next;\\n        delete newl2;\\n        return l1;\\n    }",
                "solutionTags": [],
                "code": "    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = (int)lists.size();\\n        if(k==0) return NULL;\\n        if(k==1) return lists[0];\\n        return doMerge(lists, 0, (int)lists.size()-1);\\n    }\\n    \\n    \\n    ListNode* doMerge(vector<ListNode*>& lists, int left, int right) {\\n        if(left==right) return lists[left];\\n        else if(left+1==right) return merge2Lists(lists[left], lists[right]);\\n        ListNode* l1 = doMerge(lists, left, (left+right)/2);\\n        ListNode* l2 = doMerge(lists, (left+right)/2+1, right);\\n        return merge2Lists(l1, l2);\\n    }\\n    \\n    \\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        if(l1==l2) return l1;\\n        if(!l1) return l2;\\n        if(!l2) return l1;\\n        if(l1->val>l2->val) return merge2Lists(l2, l1);\\n        ListNode* newl2 = new ListNode(0); newl2->next = l2;\\n        ListNode* p1 = l1;\\n        while (p1->next && newl2->next) {\\n            if (p1->next->val<newl2->next->val) {\\n                p1 = p1->next;\\n            } else {\\n                ListNode* temp = p1->next;\\n                p1->next = newl2->next;\\n                newl2->next = newl2->next->next;\\n                p1->next->next = temp;\\n                p1 = p1->next;\\n            }\\n        }\\n        if(!p1->next) p1->next = newl2->next;\\n        delete newl2;\\n        return l1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3435078,
                "title": "c-java-python-javascript-easy-solution-fully-explained",
                "content": "# Intuition:\\nThe problem can be solved by merging two sorted linked lists at a time. If we have K linked lists, we can merge the first and second linked lists, then merge the result with the third linked list, and so on. This process will result in a single sorted linked list containing all elements.\\n\\n# Approach:\\n\\n1. Define a function mergeTwoLists that takes two sorted linked lists as input and merges them into a single sorted linked list using a recursive approach.\\n2. In the mergeKLists function, initialize a pointer ans to NULL.\\n3. Iterate over the input vector lists, and at each iteration, merge ans with the current linked list using the mergeTwoLists function.\\n4. Return ans.\\n# Complexity:\\n\\n- Time complexity: \\nThe time complexity of this solution is O(N log k), where N is the total number of elements in all linked lists, and k is the number of linked lists. The reason for this complexity is that we are merging two lists at a time, and the number of merged lists is reduced by a factor of 2 at each iteration. Thus, the total number of iterations is log k. In each iteration, we perform N comparisons and updates, so the total time complexity is O(N log k).\\n\\n- Space Complexity:\\nThe space complexity of this solution is O(1) since we are not using any additional data structures. The only extra space used is the recursion stack space, which is O(log k) for the recursive approach used in mergeTwoLists.\\n\\n---\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        // Recursive Approach \\n        ListNode* ptr1 = list1;\\n        ListNode* ptr2 = list2;\\n        if(ptr1 == NULL){\\n            return list2;\\n        }\\n        if(ptr2 == NULL){\\n            return list1;\\n        }\\n        if(ptr1->val < ptr2->val){\\n            ptr1->next = mergeTwoLists(ptr1->next, ptr2);\\n            return ptr1;\\n        }\\n        else{\\n            ptr2->next = mergeTwoLists(ptr1, ptr2->next);\\n            return ptr2;\\n        }\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans = NULL;\\n        int count=0;\\n        while(count<lists.size()){\\n            ans = mergeTwoLists(ans,lists[count]);\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null) {\\n            return l2;\\n        }\\n        if (l2 == null) {\\n            return l1;\\n        }\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        ListNode ans = null;\\n        for (int i = 0; i < lists.length; i++) {\\n            ans = mergeTwoLists(ans, lists[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n---\\n# JavaScript\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeTwoLists = function(l1, l2) {\\n    if (!l1) {\\n        return l2;\\n    }\\n    if (!l2) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};\\n\\nvar mergeKLists = function(lists) {\\n    let ans = null;\\n    for (let i = 0; i < lists.length; i++) {\\n        ans = mergeTwoLists(ans, lists[i]);\\n    }\\n    return ans;\\n};\\n\\n```\\n---\\n# Python\\n### Different Approach\\n- To avoid the \"Time Limit Exceeded\" error, we can use a more efficient approach using a min-heap or priority queue.\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        # Create a min-heap and initialize it with the first node of each list\\n        heap = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heapq.heappush(heap, (lists[i].val, i))\\n\\n        # Create a dummy node to build the merged list\\n        dummy = ListNode(0)\\n        current = dummy\\n\\n        # Merge the lists using the min-heap\\n        while heap:\\n            val, index = heapq.heappop(heap)\\n            current.next = lists[index]\\n            current = current.next\\n            lists[index] = lists[index].next\\n            if lists[index]:\\n                heapq.heappush(heap, (lists[index].val, index))\\n\\n        return dummy.next\\n\\n```\\n> # ***Thanks For Voting***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        // Recursive Approach \\n        ListNode* ptr1 = list1;\\n        ListNode* ptr2 = list2;\\n        if(ptr1 == NULL){\\n            return list2;\\n        }\\n        if(ptr2 == NULL){\\n            return list1;\\n        }\\n        if(ptr1->val < ptr2->val){\\n            ptr1->next = mergeTwoLists(ptr1->next, ptr2);\\n            return ptr1;\\n        }\\n        else{\\n            ptr2->next = mergeTwoLists(ptr1, ptr2->next);\\n            return ptr2;\\n        }\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans = NULL;\\n        int count=0;\\n        while(count<lists.size()){\\n            ans = mergeTwoLists(ans,lists[count]);\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null) {\\n            return l2;\\n        }\\n        if (l2 == null) {\\n            return l1;\\n        }\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        ListNode ans = null;\\n        for (int i = 0; i < lists.length; i++) {\\n            ans = mergeTwoLists(ans, lists[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeTwoLists = function(l1, l2) {\\n    if (!l1) {\\n        return l2;\\n    }\\n    if (!l2) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};\\n\\nvar mergeKLists = function(lists) {\\n    let ans = null;\\n    for (let i = 0; i < lists.length; i++) {\\n        ans = mergeTwoLists(ans, lists[i]);\\n    }\\n    return ans;\\n};\\n\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        # Create a min-heap and initialize it with the first node of each list\\n        heap = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heapq.heappush(heap, (lists[i].val, i))\\n\\n        # Create a dummy node to build the merged list\\n        dummy = ListNode(0)\\n        current = dummy\\n\\n        # Merge the lists using the min-heap\\n        while heap:\\n            val, index = heapq.heappop(heap)\\n            current.next = lists[index]\\n            current = current.next\\n            lists[index] = lists[index].next\\n            if lists[index]:\\n                heapq.heappush(heap, (lists[index].val, index))\\n\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10882,
                "title": "c-solution-using-merge-sort",
                "content": "    class Solution {\\n    public:\\n        ListNode* mergeKLists(vector<ListNode*>& lists) {\\n            return partition(lists, 0, lists.size()-1);\\n        }\\n        \\n        ListNode* partition(vector<ListNode*>& lists, int start, int end){\\n            if(start == end){\\n                return lists[start];\\n            }\\n            \\n            if(start < end){\\n                int mid = (end+start)/2;\\n                \\n                ListNode* l1 = partition(lists, start, mid);\\n                ListNode* l2 = partition(lists, mid+1, end);\\n                return merge(l1, l2);\\n            }\\n            \\n            return NULL;\\n        }\\n        \\n        ListNode* merge(ListNode* l1, ListNode* l2){\\n            if(!l1) return l2;\\n            if(!l2) return l1;\\n            \\n            if(l1->val < l2->val){\\n                l1->next = merge(l1->next, l2);\\n                return l1;\\n            }else{\\n                l2->next = merge(l1, l2->next);\\n                return l2;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* mergeKLists(vector<ListNode*>& lists) {\\n            return partition(lists, 0, lists.size()-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2992596,
                "title": "solution",
                "content": "```C++ []\\nofstream ans(\"user.out\");\\nint main() {\\n    vector<int> v;\\n    v.reserve(1e4);\\n    string s;\\n    while (getline(cin, s)) {\\n        s.erase(remove(begin(s), end(s), \\'[\\'), end(s));\\n        s.erase(remove(begin(s), end(s), \\']\\'), end(s));\\n        for (auto &i: s) if (i == \\',\\') i = \\' \\';\\n        istringstream iss(s);\\n        int temp;\\n        v.clear();\\n        while (iss >> temp) v.push_back(temp);\\n        sort(v.begin(), v.end());\\n        ans << \\'[\\';\\n        for (int i = 0; i < v.size(); ++i) {\\n            if (i) ans << \\',\\';\\n            ans << v[i];\\n        }\\n        ans << \"]\\\\n\";\\n    }\\n}\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        return nullptr;\\n    }\\n};\\n```\\n\\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor s in sys.stdin:\\n    print(\\'[\\', \\',\\'.join(\\n        map(str, sorted(int(v) for v in s.rstrip().replace(\\'[\\', \\',\\').replace(\\']\\', \\',\\').split(\\',\\') if v))), \\']\\', sep=\\'\\',\\n          file=f)\\nexit(0)\\n```\\n\\n```Java []\\nclass Solution {\\n\\n    ListNode merge(ListNode list1, ListNode list2) {\\n\\n        if (list1 == null) {\\n            return list2;\\n        } else if (list2 == null) {\\n            return list1;\\n        }\\n\\n        ListNode head = null, curr = head;\\n        ListNode curr1 = list1, curr2 = list2;\\n        while (curr1 != null && curr2 != null) {\\n\\n            ListNode minNode = null;\\n            if (curr1.val < curr2.val) {\\n                minNode = curr1;\\n                curr1 = curr1.next;\\n            } else {\\n                minNode = curr2;\\n                curr2 = curr2.next;\\n            }\\n\\n            if (head == null) {\\n                curr = head = minNode;\\n            } else {\\n                curr.next = minNode;\\n                curr = curr.next;\\n            }\\n        }\\n\\n        if (curr1 != null) {\\n            curr.next = curr1;\\n        } else if (curr2 != null) {\\n            curr.next = curr2;\\n        }\\n\\n        return head;\\n    }\\n\\n    ListNode mergeSort(ListNode[] lists, int beg, int end) {\\n\\n        if (beg == end) {\\n            return lists[beg];\\n        }\\n\\n        int mid = (beg + end) / 2;\\n        ListNode list1 = mergeSort(lists, beg, mid);\\n        ListNode list2 = mergeSort(lists, mid + 1, end);\\n        ListNode head = merge(list1, list2);\\n        return head;\\n    }\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\n        if (lists.length == 0) {\\n            return null;\\n        }\\n        return mergeSort(lists, 0, lists.length - 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nofstream ans(\"user.out\");\\nint main() {\\n    vector<int> v;\\n    v.reserve(1e4);\\n    string s;\\n    while (getline(cin, s)) {\\n        s.erase(remove(begin(s), end(s), \\'[\\'), end(s));\\n        s.erase(remove(begin(s), end(s), \\']\\'), end(s));\\n        for (auto &i: s) if (i == \\',\\') i = \\' \\';\\n        istringstream iss(s);\\n        int temp;\\n        v.clear();\\n        while (iss >> temp) v.push_back(temp);\\n        sort(v.begin(), v.end());\\n        ans << \\'[\\';\\n        for (int i = 0; i < v.size(); ++i) {\\n            if (i) ans << \\',\\';\\n            ans << v[i];\\n        }\\n        ans << \"]\\\\n\";\\n    }\\n}\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        return nullptr;\\n    }\\n};\\n```\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor s in sys.stdin:\\n    print(\\'[\\', \\',\\'.join(\\n        map(str, sorted(int(v) for v in s.rstrip().replace(\\'[\\', \\',\\').replace(\\']\\', \\',\\').split(\\',\\') if v))), \\']\\', sep=\\'\\',\\n          file=f)\\nexit(0)\\n```\n```Java []\\nclass Solution {\\n\\n    ListNode merge(ListNode list1, ListNode list2) {\\n\\n        if (list1 == null) {\\n            return list2;\\n        } else if (list2 == null) {\\n            return list1;\\n        }\\n\\n        ListNode head = null, curr = head;\\n        ListNode curr1 = list1, curr2 = list2;\\n        while (curr1 != null && curr2 != null) {\\n\\n            ListNode minNode = null;\\n            if (curr1.val < curr2.val) {\\n                minNode = curr1;\\n                curr1 = curr1.next;\\n            } else {\\n                minNode = curr2;\\n                curr2 = curr2.next;\\n            }\\n\\n            if (head == null) {\\n                curr = head = minNode;\\n            } else {\\n                curr.next = minNode;\\n                curr = curr.next;\\n            }\\n        }\\n\\n        if (curr1 != null) {\\n            curr.next = curr1;\\n        } else if (curr2 != null) {\\n            curr.next = curr2;\\n        }\\n\\n        return head;\\n    }\\n\\n    ListNode mergeSort(ListNode[] lists, int beg, int end) {\\n\\n        if (beg == end) {\\n            return lists[beg];\\n        }\\n\\n        int mid = (beg + end) / 2;\\n        ListNode list1 = mergeSort(lists, beg, mid);\\n        ListNode list2 = mergeSort(lists, mid + 1, end);\\n        ListNode head = merge(list1, list2);\\n        return head;\\n    }\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\n        if (lists.length == 0) {\\n            return null;\\n        }\\n        return mergeSort(lists, 0, lists.length - 1);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1745569,
                "title": "very-detailed-explanation-going-from-o-nlogn-o-n-k-o-n-log-k",
                "content": "```\\nOkay, so for this problem we are given several linked list in our array. \\nEach linked list is sorted in asscending order & we merge all the list together to be one sorted linked list. \\nThere are many ways to solve this problem. \\n```\\nLet\\'s take an example,\\n\\n**Input**: lists = [[1,3,4],[5,6,7],[3,4,5]]\\n**Output**: [ 1, 3, 3, 4, 4, 5, 5, 6, 7 ]\\n```\\nThe brute force approach is,\\n```\\nWe can simply iterate over all the list node & add them into an array. Then we sort the array & loop through to make the connection b/w nodes. And this will take **Time complexity - BigO(NlogN)** & **Space complexity - BigO(N)**\\n\\n![image](https://assets.leetcode.com/users/images/8d98d812-2ad4-4405-a85f-d4b5ed0c2e57_1644023126.8413756.png)\\n\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0) return null;\\n        \\n        ListNode head = new ListNode(0); // dummy node head\\n        ListNode temp = head; // taking into temporary variable\\n        List<Integer> l = new ArrayList<>();\\n        for(ListNode list : lists){ // adding all the values in the list\\n            while(list != null){\\n                l.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        Collections.sort(l); // sorting that list we get above\\n        for(int val : l){ // iterating over the list & creating new single linked list\\n            temp.next = new ListNode(val);\\n            temp = temp.next;\\n        }\\n        return head.next;\\n    }\\n}\\n```\\n\\n\\n<hr>\\n<hr>\\n\\n```\\nLet\\'s Optimize a more bit.\\n```\\n\\n<hr>\\n<hr>\\n\\nLet\\'s take an example,\\n\\n**Input**: lists = [[1,2,3,4],[2,3,4,5],[1,1,2,3]]\\n**Output**: [ 1, 3, 3, 4, 4, 5, 5, 6, 7 ]\\n\\n![image](https://assets.leetcode.com/users/images/d727edf5-2cdd-4514-bcec-9dc0bb85e790_1644028027.4866238.png)\\n\\nAs you see that each of these 3 lists are sorted in itself. \\n* We compare the 1\\'st three values of the list & pick which ever is the lowest.\\n\\n\\n* We will have a dummy node to put that smallest value next to the dummy node. \\n* Now from which ever list we have selected this node will move the pointer to it\\'s next node\\n* Similarly, we will compare the value again & over again and which ever is the smallest we put that in result list.\\n\\n![image](https://assets.leetcode.com/users/images/d90a887b-818e-472f-bda0-d29b01de5267_1644028607.8243701.png)\\n\\nWe continuously doing this, until we reach end of all the list.\\n\\n*I hope you got the idea,* **let\\'s code it up:**\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0) return null; // base case\\n        \\n        ListNode head = new ListNode(0); // dummy node created & you can chose any value of your choice, I choose 0 \"Because we indian invented that\"\\n        ListNode temp = head;\\n        \\n        while(true){ // running infinite\\n            int p = 0; // point to list with minimum value\\n            for(int i = 0; i < lists.length; i++){\\n                if(lists[p] == null || (lists[i] != null && lists[p].val > lists[i].val)){\\n                p = i;\\n                }\\n            }\\n            if(lists[p] == null){ // it means no value present\\n                break;\\n            }\\n            temp.next = lists[p];\\n            temp = temp.next;\\n            lists[p] = lists[p].next;\\n        }\\n        return head.next;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N * K) where N is no. of nodes & K is size of the lists\\n\\n* **Space Complexity :-** BigO(N) \\n\\n\\n<hr>\\n<hr>\\n\\n```\\nLet\\'s move to more Optimal Approach. \\n```\\n\\n<hr>\\n<hr>\\n\\n\\n***So, the knowledge of Merge Sort Algorithm is very prevalent here. It will involved a divide n conquer approach.***\\n\\nSo, there are 2 step\\'s that we need to perform.\\n1. The 1st step is dividing the lists recursively until arriving at our base case.\\n2. And our 2nd step is to merge the lists together to be in sorted order.\\n\\nThe intution behind this approach is we will be merging together sorted lists in multiple parts of the array recursively, **hence we using divide and conquer.**\\n\\nLet\\'s take one more example:\\n```\\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\\nOutput: [1,1,2,3,4,4,5,6]\\n```\\n* So, what i say is, at each step we gonna have a start & end index. Start is going to be at 0 & end is going to be at 2.\\n\\n\\n* As you can see start is left most side of our array i.e. `[1, 4, 5]`\\n* And end is on our right most side of our array i.e. `[2, 6]`\\n* So, with the start & end values, we are now going to compute our mid point. If we do our mid =  start + end / 2 i.e. `mid = (0 + 2 ) / 2 = 1`\\n* And what this is telling us, we gonna split our array base on this mid point. So, the left side will be `[Start, mid] i.e. [ [1, 4, 5], [1, 3, 4] ]`\\n* And our right side will be `[mid + 1, end] i.e. [ [2, 6] ]`\\n\\n![image](https://assets.leetcode.com/users/images/635d1b3b-88aa-4950-8ef3-d65feff30a5d_1644024352.4191604.png)\\n\\nAnd we gonna continueosuly do this until we arrive at our base cases where our start index is equals to our end index\\n\\n* So, after splitting at index 1 we now have the following list **[ [1, 4, 5], [1, 3, 4] ]** & we do this same logic recursively over and over we arrive at the base cases. \\n* So, now let\\'s do the same thing with left side again. Now our **start = 0 & end = 1**. If we calculate mid again i.e. `mid = (0 + 1) / 2 = 0 `\\n* We gonna have one list which is `[ [1, 4, 5] ]` & another list which is `[ [1, 3, 4] ]`\\n* So, now as you can see after we did that, the division resulted it into 2 base cases, since each list is on it\\'s own.\\n\\n![image](https://assets.leetcode.com/users/images/64d6e6db-d064-48b7-a542-407de3182fb4_1644024724.0997772.png)\\n\\nWhat does this mean\\'s that we just need to go back, up the chain and merge the list together.\\n\\n* So, `[1,4,5]` get return from our recursive call\\n* And `[1,3,4]` get returns from a separate recursive call\\n* ANd then, we going to merge them back together and that would result in array of `[[1,,1,3,4,45]]`\\n* Now if we go back & look at our right subtree, in the previous division step we did. We were left with the base case of `[[2,6]]`, this will get return\\n\\n![image](https://assets.leetcode.com/users/images/e31a836f-303a-4be1-97ff-2fcb9d7d7711_1644025139.2216055.png)\\n\\nAnd finally we gonna merge `[[2,6]]` with previously merge array. And merging these together gives us `[ [ 1, 1, 2, 3, 4, 4, 5, 6 ] ]` which is our final answer.\\n\\n![image](https://assets.leetcode.com/users/images/24c24608-3638-4ad6-85ab-5a27dccadce4_1644025300.024822.png)\\n\\n*Now, I hope approach is crystal clear,* **let\\'s code it**\\n\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        // Base Condition\\n        if(lists == null || lists.length == 0) return null;\\n        // Creating helper function helps in dividing and conquer approach\\n        return getMid(lists, 0, lists.length - 1); // created start & end index\\n    }\\n    private ListNode getMid(ListNode lists[], int start, int end){\\n        // Handle base case, when start & end index are same\\n        if(start == end) return lists[start];\\n        int mid = start + (end - start) / 2; // calculating mid & why we writing in this way to handle index overflow\\n        ListNode left = getMid(lists, start, mid); // in left mid become our new end\\n        ListNode right = getMid(lists, mid + 1, end); // in right this time start is mid + 1\\n        \\n        return merge(left, right);// merge the left & right together\\n    }\\n    private ListNode merge(ListNode l1, ListNode l2){\\n        ListNode result = new ListNode(0); // created dummy node with any value of your choice, i choose 0 \"Because we indian invented that\"\\n        ListNode curr = result; // use this pointer to move over\\n        \\n        while(l1 != null || l2 != null){\\n            if(l1 == null){\\n                curr.next = l2; // bcz if l1 is null we know l2 must have value\\n                l2 = l2.next;\\n            }\\n            else if(l2 == null){\\n                curr.next = l1; // bcz if l2 is null we know l1 must have value\\n                l1 = l1.next;\\n            }else if(l1.val < l2.val){ // if we made up till this point we know they both have value & let\\'s compare them\\n                curr.next  = l1;\\n                l1 = l1.next;\\n            }\\n            else{\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        return result.next; // why we not return only result bcz, result has dummy value of 0\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N * log(K)) where N is no of nodes we have when we are merging 2 lists together. ANd log of K portion comes from our recursive func. getMid. K is the no. of recursive call that we going to have to make.\\n\\n* **Space Complexity :-** BigO(K) where K is also no. of recursive call that we going to have to make, since every time we make a recursive call it add to ours stack space",
                "solutionTags": [],
                "code": "```\\nOkay, so for this problem we are given several linked list in our array. \\nEach linked list is sorted in asscending order & we merge all the list together to be one sorted linked list. \\nThere are many ways to solve this problem. \\n```\n```\\nThe brute force approach is,\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0) return null;\\n        \\n        ListNode head = new ListNode(0); // dummy node head\\n        ListNode temp = head; // taking into temporary variable\\n        List<Integer> l = new ArrayList<>();\\n        for(ListNode list : lists){ // adding all the values in the list\\n            while(list != null){\\n                l.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        Collections.sort(l); // sorting that list we get above\\n        for(int val : l){ // iterating over the list & creating new single linked list\\n            temp.next = new ListNode(val);\\n            temp = temp.next;\\n        }\\n        return head.next;\\n    }\\n}\\n```\n```\\nLet\\'s Optimize a more bit.\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0) return null; // base case\\n        \\n        ListNode head = new ListNode(0); // dummy node created & you can chose any value of your choice, I choose 0 \"Because we indian invented that\"\\n        ListNode temp = head;\\n        \\n        while(true){ // running infinite\\n            int p = 0; // point to list with minimum value\\n            for(int i = 0; i < lists.length; i++){\\n                if(lists[p] == null || (lists[i] != null && lists[p].val > lists[i].val)){\\n                p = i;\\n                }\\n            }\\n            if(lists[p] == null){ // it means no value present\\n                break;\\n            }\\n            temp.next = lists[p];\\n            temp = temp.next;\\n            lists[p] = lists[p].next;\\n        }\\n        return head.next;\\n    }\\n}\\n```\n```\\nLet\\'s move to more Optimal Approach. \\n```\n```\\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\\nOutput: [1,1,2,3,4,4,5,6]\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        // Base Condition\\n        if(lists == null || lists.length == 0) return null;\\n        // Creating helper function helps in dividing and conquer approach\\n        return getMid(lists, 0, lists.length - 1); // created start & end index\\n    }\\n    private ListNode getMid(ListNode lists[], int start, int end){\\n        // Handle base case, when start & end index are same\\n        if(start == end) return lists[start];\\n        int mid = start + (end - start) / 2; // calculating mid & why we writing in this way to handle index overflow\\n        ListNode left = getMid(lists, start, mid); // in left mid become our new end\\n        ListNode right = getMid(lists, mid + 1, end); // in right this time start is mid + 1\\n        \\n        return merge(left, right);// merge the left & right together\\n    }\\n    private ListNode merge(ListNode l1, ListNode l2){\\n        ListNode result = new ListNode(0); // created dummy node with any value of your choice, i choose 0 \"Because we indian invented that\"\\n        ListNode curr = result; // use this pointer to move over\\n        \\n        while(l1 != null || l2 != null){\\n            if(l1 == null){\\n                curr.next = l2; // bcz if l1 is null we know l2 must have value\\n                l2 = l2.next;\\n            }\\n            else if(l2 == null){\\n                curr.next = l1; // bcz if l2 is null we know l1 must have value\\n                l1 = l1.next;\\n            }else if(l1.val < l2.val){ // if we made up till this point we know they both have value & let\\'s compare them\\n                curr.next  = l1;\\n                l1 = l1.next;\\n            }\\n            else{\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        return result.next; // why we not return only result bcz, result has dummy value of 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10607,
                "title": "three-ways-to-solve-this-problem-in-python-build-in-sort-merge-and-priority-queue",
                "content": "I figured out that OJ converts Python list into a ListNode automatically, so in my solution I return a list directly(Sorry for my laziness)\\n\\nThe first solution uses Python build-in sort, to my surprise it's the fastest one, although it's kind of a hack:\\n\\n    def mergeKLists(lists):\\n        ret = []\\n        for lst in lists:\\n            while lst:\\n                ret.append(lst.val)\\n                lst = lst.next\\n                \\n        return sorted(ret)\\n\\nThe second solution uses merge sort:\\n\\n    def mergeKLists(lists):\\n        \\n        def merge(lst1, lst2):\\n            dummy = pt = ListNode(-1)\\n            while lst1 and lst2:\\n                if lst1.val < lst2.val:\\n                    pt.next = lst1\\n                    lst1 = lst1.next\\n                else:\\n                    pt.next = lst2\\n                    lst2 = lst2.next\\n                pt = pt.next\\n                \\n            pt.next = lst1 if not lst2 else lst2\\n            return dummy.next\\n            \\n        \\n        if not lists:\\n            return None\\n\\n        if len(lists) == 1:\\n            return lists[0]\\n        mid = len(lists)/2\\n        left = mergeKLists(lists[:mid])\\n        right = mergeKLists(lists[mid:])\\n\\n        return merge(left, right)\\n\\nThe third one uses priority queue:\\n\\n        \\n    \\n\\n    import heapq\\n    def mergeKLists(lists):\\n            \\n        ret, heap = [], []\\n        for lst in lists:\\n            while lst:\\n                heapq.heappush(heap, lst.val)\\n                lst = lst.next\\n    \\n        while heap:\\n            ret.append(heapq.heappop(heap))\\n        return ret",
                "solutionTags": [],
                "code": "I figured out that OJ converts Python list into a ListNode automatically, so in my solution I return a list directly(Sorry for my laziness)\\n\\nThe first solution uses Python build-in sort, to my surprise it's the fastest one, although it's kind of a hack:\\n\\n    def mergeKLists(lists):\\n        ret = []\\n        for lst in lists:\\n            while lst:\\n                ret.append(lst.val)\\n                lst = lst.next\\n                \\n        return sorted(ret)\\n\\nThe second solution uses merge sort:\\n\\n    def mergeKLists(lists):\\n        \\n        def merge(lst1, lst2):\\n            dummy = pt = ListNode(-1)\\n            while lst1 and lst2:\\n                if lst1.val < lst2.val:\\n                    pt.next = lst1\\n                    lst1 = lst1.next\\n                else:\\n                    pt.next = lst2\\n                    lst2 = lst2.next\\n                pt = pt.next\\n                \\n            pt.next = lst1 if not lst2 else lst2\\n            return dummy.next\\n            \\n        \\n        if not lists:\\n            return None\\n\\n        if len(lists) == 1:\\n            return lists[0]\\n        mid = len(lists)/2\\n        left = mergeKLists(lists[:mid])\\n        right = mergeKLists(lists[mid:])\\n\\n        return merge(left, right)\\n\\nThe third one uses priority queue:\\n\\n        \\n    \\n\\n    import heapq\\n    def mergeKLists(lists):\\n            \\n        ret, heap = [], []\\n        for lst in lists:\\n            while lst:\\n                heapq.heappush(heap, lst.val)\\n                lst = lst.next\\n    \\n        while heap:\\n            ret.append(heapq.heappop(heap))\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 10630,
                "title": "c-using-minheap-priorityqueue-implemented-using-sorteddictionary",
                "content": "We need to keep track of the heads of all lists at all times and be able to do the following operations efficiently:\\n1- Get/Remove Min\\n2- Add (once you remove the head of one list, you need to add the next from that list)\\n\\nA min heap (or a priority queue) is obviously the data structure we need here, where the key of the dictionary is the value of the ListNode, and the value of the dictionary is a queue of ListNodes having that value. (we need to queue the ones with the same value since Dictionary cannot have dupes)\\nI implemented mine using a SortedDictionary of queues. \\nSortedDictionary is internally implemented using a binary tree, and provides O(logn) for Add() and O(1) for PopMin(), so it's as efficient as it gets. \\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    \\n    public class MinHeap\\n    {\\n        public SortedDictionary<int, Queue<ListNode>> map = new SortedDictionary<int, Queue<ListNode>>();\\n\\n        public void Add(int val, ListNode node)\\n        {\\n            if(!map.ContainsKey(val))\\n            {\\n                map.Add(val, new Queue<ListNode>());\\n            }\\n\\n            map[val].Enqueue(node);\\n        }\\n\\n        public ListNode PopMin()\\n        {\\n            int minKey = map.First().Key;\\n            ListNode node = map[minKey].Dequeue();\\n\\n            if (map[minKey].Count == 0)\\n                map.Remove(minKey);\\n\\n            return node;\\n        }\\n    }\\n    \\n    public ListNode MergeKLists(ListNode[] lists) \\n    {\\n        MinHeap heap = new MinHeap();\\n        foreach (var node in lists)\\n        {\\n            if(node == null)\\n                continue;\\n            \\n            heap.Add(node.val, node);\\n        }\\n\\n        ListNode curr = null, newHead = null;\\n\\n        while (heap.map.Count > 0)\\n        {\\n            ListNode node = heap.PopMin();\\n\\n            if (node.next != null)\\n            {\\n                heap.Add(node.next.val, node.next);\\n            }\\n\\n            if (curr == null)\\n            {\\n                curr = node;\\n                newHead = curr;\\n            }\\n            else\\n            {\\n                curr.next = node;\\n                curr = curr.next;\\n            }\\n        }\\n\\n        return newHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    \\n    public class MinHeap\\n    {\\n        public SortedDictionary<int, Queue<ListNode>> map = new SortedDictionary<int, Queue<ListNode>>();\\n\\n        public void Add(int val, ListNode node)\\n        {\\n            if(!map.ContainsKey(val))\\n            {\\n                map.Add(val, new Queue<ListNode>());\\n            }\\n\\n            map[val].Enqueue(node);\\n        }\\n\\n        public ListNode PopMin()\\n        {\\n            int minKey = map.First().Key;\\n            ListNode node = map[minKey].Dequeue();\\n\\n            if (map[minKey].Count == 0)\\n                map.Remove(minKey);\\n\\n            return node;\\n        }\\n    }\\n    \\n    public ListNode MergeKLists(ListNode[] lists) \\n    {\\n        MinHeap heap = new MinHeap();\\n        foreach (var node in lists)\\n        {\\n            if(node == null)\\n                continue;\\n            \\n            heap.Add(node.val, node);\\n        }\\n\\n        ListNode curr = null, newHead = null;\\n\\n        while (heap.map.Count > 0)\\n        {\\n            ListNode node = heap.PopMin();\\n\\n            if (node.next != null)\\n            {\\n                heap.Add(node.next.val, node.next);\\n            }\\n\\n            if (curr == null)\\n            {\\n                curr = node;\\n                newHead = curr;\\n            }\\n            else\\n            {\\n                curr.next = node;\\n                curr = curr.next;\\n            }\\n        }\\n\\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656809,
                "title": "solution-swift-merge-k-sorted-lists-test-cases",
                "content": "```swift\\nclass Solution {\\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        \\n        var arr: [Int] = []\\n        \\n        for list in lists.compactMap ({ $0 }) {\\n            var head: ListNode? = list\\n            while head != nil {\\n                arr.append(head!.val)\\n                head = head?.next\\n            }\\n        }\\n        arr.sort()\\n        if arr.isEmpty { return nil }\\n        \\n        let node = ListNode(0)\\n        var curr = ListNode(arr[0])\\n        node.next = curr\\n        \\n        for n in arr.dropFirst() {\\n            let tmp = ListNode(n)\\n            curr.next = tmp\\n            if let next = curr.next { curr = next }\\n        }\\n        return node.next\\n    }\\n}\\n```\\n\\n---\\n\\n<p><details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.021 (0.023) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// The linked-lists are:\\n    /// [\\n    ///   1->4->5,\\n    ///   1->3->4,\\n    ///   2->6\\n    /// ]\\n    /// merging them into one sorted list:\\n    /// 1->1->2->3->4->4->5->6\\n    func test0() {\\n        let lists = [ListNode([1, 4, 5]), ListNode([1, 3, 4]), ListNode([2, 6])]\\n        let value = solution.mergeKLists(lists)\\n        XCTAssertEqual(value?.val, ListNode([1,1,2,3,4,4,5,6])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.mergeKLists([ListNode([])])\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>\\n\\n<p>\\n<details>\\n<summary>\\n<b>ListNode</b>\\n</summary>\\n\\n<br>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        \\n        var arr: [Int] = []\\n        \\n        for list in lists.compactMap ({ $0 }) {\\n            var head: ListNode? = list\\n            while head != nil {\\n                arr.append(head!.val)\\n                head = head?.next\\n            }\\n        }\\n        arr.sort()\\n        if arr.isEmpty { return nil }\\n        \\n        let node = ListNode(0)\\n        var curr = ListNode(arr[0])\\n        node.next = curr\\n        \\n        for n in arr.dropFirst() {\\n            let tmp = ListNode(n)\\n            curr.next = tmp\\n            if let next = curr.next { curr = next }\\n        }\\n        return node.next\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// The linked-lists are:\\n    /// [\\n    ///   1->4->5,\\n    ///   1->3->4,\\n    ///   2->6\\n    /// ]\\n    /// merging them into one sorted list:\\n    /// 1->1->2->3->4->4->5->6\\n    func test0() {\\n        let lists = [ListNode([1, 4, 5]), ListNode([1, 3, 4]), ListNode([2, 6])]\\n        let value = solution.mergeKLists(lists)\\n        XCTAssertEqual(value?.val, ListNode([1,1,2,3,4,4,5,6])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.mergeKLists([ListNode([])])\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541375,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n        public ListNode MergeKLists(ListNode[] lists)\\n        {            \\n            if (lists == null || lists.Length == 0)\\n                return null;\\n         \\n            return Merge(lists, 0, lists.Length - 1);\\n        }\\n\\n        private ListNode Merge(ListNode[] lists, int i, int j)\\n        {\\n            if (j == i)\\n                return lists[i];\\n            else\\n            {\\n                int mid = i + (j - i) / 2;\\n\\n                ListNode left = Merge(lists, i, mid),\\n                         right = Merge(lists, mid + 1, j);\\n\\n                return Merge(left, right);\\n            }\\n        }\\n\\n        private ListNode Merge(ListNode list1, ListNode list2)\\n        {\\n            ListNode dummy = new ListNode(0),\\n                     cur = dummy;\\n\\n            while (list1 != null && list2 != null)\\n            {\\n                if (list1.val <= list2.val)\\n                {\\n                    cur.next = list1;\\n                    list1 = list1.next;\\n                }\\n                else\\n                {\\n                    cur.next = list2;\\n                    list2 = list2.next;\\n                }\\n\\n                cur = cur.next;\\n            }\\n\\n            if (list1 != null)\\n                cur.next = list1;\\n\\n            if (list2 != null)\\n                cur.next = list2;\\n\\n            return dummy.next;\\n        }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode MergeKLists(ListNode[] lists)\\n        {            \\n            if (lists == null || lists.Length == 0)\\n                return null;\\n         \\n            return Merge(lists, 0, lists.Length - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 427631,
                "title": "3-python-solutions-with-inline-comments-and-analysis-brute-force-brute-force-min-heap",
                "content": "**3 Python Solutions with Inline Comments and Analysis (Brute Force, Brute Force+, Min Heap), 99.85%, 5.01%, and 90.17%**\\n\\nI decided to write up the 3 solutions I came up with. I was a bit suprised that the \"brute force\" was so efficient, but I suppose the test inputs matter as well as the fact Python relies on C subroutines for some things like sorting.\\n\\nAny comments and advice appreciated!\\n\\n**Brute Force: convert to array list, sort, convert back to linked list**\\n*Asymptotic WC Runtime: O(NlgN)\\nBest Test Runtime: 68ms, 99.85%*\\n\\n```python\\n# Brute Force Approach\\n# O(NlgN) = O(aN + bNlgN + cN)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   1) Traverse all linked lists, \\n#       adding every element to an arraylist\\n#       O(N)\\n#   2) Sort the array list\\n#       O(NlgN)\\n#   3) Transform the array list into a linkedlist\\n#       O(N)\\n# Best Runtime\\n# Runtime: 68 ms, faster than 99.85% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.6 MB, less than 37.88% of Python online submissions for Merge k Sorted Lists.\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # Create an empty array and fill it with all the elements\\n        #     from the LinkedLists\\n        array = []\\n        for ll in lists:\\n            node = ll\\n            while node:\\n                array.append(node)\\n                node = node.next\\n        # Verify elements were actually added to the array (LL could have all been empty)\\n        if not array:\\n            return None                \\n\\n        # Sort the array\\n        array.sort(key=lambda node: node.val)\\n    \\n        # Create a new linked list from the array\\n        head = array[0]\\n        for i in xrange(1, len(array)):\\n            prev = array[i-1]\\n            node = array[i]\\n            prev.next = node\\n        return head\\n```\\nThis one\\'s runtime was pretty suprising considering the asymptotic runtime should be the worst (assuming k < N). A reminder to ALWAYS PROFILE your code in production and try a couple different ways when possible. And consider which of your variables will actually be larger in the data you have to deal with.\\n\\n**Brute Force+ Approach: while there are non-empty linked lists, choose the minimum element from all lists**\\n*Asymptotic WC Runtime: O(kN)\\nBest Test Runtime:  6968 ms, 5.01%*\\n\\n```python\\n# Brute Force+ Approach\\n# O(kN) = O(akN)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   1) Keep a list of pointers for your position in every list\\n#       and with it\\n#       O(N)\\n#   2) Go through all k lists choosing the smallest element \\n#       and adding it to your returned linked list\\n#       updating its pointer to point to its next\\n#       repeat until all N elements have been added\\n#       (i.e. all pointers point to None)\\n#       so N iterations of O(k) search\\n#       O(kN)\\n# Best Runtime\\n# Runtime: 6968 ms, faster than 5.01% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.4 MB, less than 80.30% of Python online submissions for Merge k Sorted Lists.\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # create a temporary head and a node pointer to track what\\n        #     elements we\\'ve added to the return list\\n        temp_head = ListNode(-1)\\n        node = temp_head\\n\\n        # while there are still linked lists with elements in them,\\n        #   choose the list with the smallest starting element\\n        #   and add that element to our return llist\\n        #   and move the list it came from\\'s pointer forward\\n        #   (note: we modify the input lists instead of keeping a pointer)\\n        while any((ll is not None for ll in lists)):\\n            smallest_val = float(\"inf\")\\n            smallest_index = None\\n            for index, ll in enumerate(lists):\\n                if ll is not None:\\n                    if ll.val < smallest_val:\\n                        smallest_val = ll.val\\n                        smallest_index = index\\n            node.next = lists[smallest_index]\\n            lists[smallest_index] = lists[smallest_index].next\\n            node = node.next\\n        # return all the items after our temporary head\\n        #     (i.e. our actual sorted list)\\n        return temp_head.next\\n```\\nThis algorithm suprisingly performed the worst.\\n\\n*Note:* You can get a slight speed up by removing all the empy elements from `list`, but it\\'s still pretty dreadful. (e.g. add `lists = filter(None, lists)` to the end of the while loop)\\n```\\n# Runtime: 5084 ms, faster than 5.01% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.4 MB, less than 71.21% of Python online submissions for Merge k Sorted Lists.\\n```\\n\\n**Minimum Heap/Priority Queue Approach**\\n*Asymptotic WC Runtime:  O(Nlgk)\\nBest Test Runtime:  84 ms, 90.17%*\\nThis algorithm is an extension of the previous idea, but instead of wasting work recomparing all the values, it uses a minimum heap to keep a ranking of all the smallest elements seen so far.\\n\\n```python\\n# Min Heap Approach\\n# O(Nlgk) = O(klgk + Nlgk)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   We can leverage a min heap to extend the BF+ approach while\\n#   maintaing a ranking of the k minimum elements remaining in each list\\n#   without having to do unnecessary additional work recomparing nodes\\n#   we\\'ve already considered.\\n#   1) Build a min-heap of the first node of each of the k LinkedLists\\n#       O(klgk)\\n#   2) While there\\'s a queue: (note all N elements added to it in total)\\n#       a) pop the minimum element from the heap O(lgk)\\n#       b) push its next node to the heap, if it exists O(lgk)\\n#       O(Nlgk)\\n# Best Runtime\\n# Runtime: 84 ms, faster than 90.17% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.5 MB, less than 40.91% of Python online submissions for Merge k Sorted Lists.\\nimport heapq\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # create a temporary head and a node pointer to track what\\n        #     elements we\\'ve added to the return list\\n        temp_head = ListNode(-1)\\n        node = temp_head\\n\\n        # Create a min-heap tracking the smallest elements seen so far\\n        #   (up to k elements adde)\\n        queue = []\\n        for ll in lists:\\n            if ll:\\n                heapq.heappush(queue, (ll.val, ll))\\n        \\n        # while there\\'s elts in the queue, \\n        #   pop its minimum element and add it to the return llist\\n        #   if it has a next element, add that to the priority queue in its place\\n        while queue:\\n            value, next_node = heapq.heappop(queue)\\n            node.next = next_node\\n            if next_node.next:\\n                heapq.heappush(queue, (next_node.next.val, next_node.next))\\n            node = node.next\\n        \\n        return temp_head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n# Brute Force Approach\\n# O(NlgN) = O(aN + bNlgN + cN)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   1) Traverse all linked lists, \\n#       adding every element to an arraylist\\n#       O(N)\\n#   2) Sort the array list\\n#       O(NlgN)\\n#   3) Transform the array list into a linkedlist\\n#       O(N)\\n# Best Runtime\\n# Runtime: 68 ms, faster than 99.85% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.6 MB, less than 37.88% of Python online submissions for Merge k Sorted Lists.\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # Create an empty array and fill it with all the elements\\n        #     from the LinkedLists\\n        array = []\\n        for ll in lists:\\n            node = ll\\n            while node:\\n                array.append(node)\\n                node = node.next\\n        # Verify elements were actually added to the array (LL could have all been empty)\\n        if not array:\\n            return None                \\n\\n        # Sort the array\\n        array.sort(key=lambda node: node.val)\\n    \\n        # Create a new linked list from the array\\n        head = array[0]\\n        for i in xrange(1, len(array)):\\n            prev = array[i-1]\\n            node = array[i]\\n            prev.next = node\\n        return head\\n```\n```python\\n# Brute Force+ Approach\\n# O(kN) = O(akN)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   1) Keep a list of pointers for your position in every list\\n#       and with it\\n#       O(N)\\n#   2) Go through all k lists choosing the smallest element \\n#       and adding it to your returned linked list\\n#       updating its pointer to point to its next\\n#       repeat until all N elements have been added\\n#       (i.e. all pointers point to None)\\n#       so N iterations of O(k) search\\n#       O(kN)\\n# Best Runtime\\n# Runtime: 6968 ms, faster than 5.01% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.4 MB, less than 80.30% of Python online submissions for Merge k Sorted Lists.\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # create a temporary head and a node pointer to track what\\n        #     elements we\\'ve added to the return list\\n        temp_head = ListNode(-1)\\n        node = temp_head\\n\\n        # while there are still linked lists with elements in them,\\n        #   choose the list with the smallest starting element\\n        #   and add that element to our return llist\\n        #   and move the list it came from\\'s pointer forward\\n        #   (note: we modify the input lists instead of keeping a pointer)\\n        while any((ll is not None for ll in lists)):\\n            smallest_val = float(\"inf\")\\n            smallest_index = None\\n            for index, ll in enumerate(lists):\\n                if ll is not None:\\n                    if ll.val < smallest_val:\\n                        smallest_val = ll.val\\n                        smallest_index = index\\n            node.next = lists[smallest_index]\\n            lists[smallest_index] = lists[smallest_index].next\\n            node = node.next\\n        # return all the items after our temporary head\\n        #     (i.e. our actual sorted list)\\n        return temp_head.next\\n```\n```\\n# Runtime: 5084 ms, faster than 5.01% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.4 MB, less than 71.21% of Python online submissions for Merge k Sorted Lists.\\n```\n```python\\n# Min Heap Approach\\n# O(Nlgk) = O(klgk + Nlgk)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   We can leverage a min heap to extend the BF+ approach while\\n#   maintaing a ranking of the k minimum elements remaining in each list\\n#   without having to do unnecessary additional work recomparing nodes\\n#   we\\'ve already considered.\\n#   1) Build a min-heap of the first node of each of the k LinkedLists\\n#       O(klgk)\\n#   2) While there\\'s a queue: (note all N elements added to it in total)\\n#       a) pop the minimum element from the heap O(lgk)\\n#       b) push its next node to the heap, if it exists O(lgk)\\n#       O(Nlgk)\\n# Best Runtime\\n# Runtime: 84 ms, faster than 90.17% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.5 MB, less than 40.91% of Python online submissions for Merge k Sorted Lists.\\nimport heapq\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # create a temporary head and a node pointer to track what\\n        #     elements we\\'ve added to the return list\\n        temp_head = ListNode(-1)\\n        node = temp_head\\n\\n        # Create a min-heap tracking the smallest elements seen so far\\n        #   (up to k elements adde)\\n        queue = []\\n        for ll in lists:\\n            if ll:\\n                heapq.heappush(queue, (ll.val, ll))\\n        \\n        # while there\\'s elts in the queue, \\n        #   pop its minimum element and add it to the return llist\\n        #   if it has a next element, add that to the priority queue in its place\\n        while queue:\\n            value, next_node = heapq.heappop(queue)\\n            node.next = next_node\\n            if next_node.next:\\n                heapq.heappush(queue, (next_node.next.val, next_node.next))\\n            node = node.next\\n        \\n        return temp_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11010,
                "title": "a-solution-use-divide-and-conquer-algorithm-in-java",
                "content": "    public ListNode mergeKLists(List<ListNode> lists) {\\n            int length = lists.size() ;\\n    \\n            if(length == 0)\\n                return null ;\\n            if(length == 1){\\n                return lists.get(0) ;\\n            }\\n    \\n            int mid = (length - 1)/2 ;\\n            ListNode l1 = mergeKLists(lists.subList(0,mid + 1)) ;\\n            ListNode l2 = mergeKLists(lists.subList(mid + 1,length)) ;\\n    \\n            return mergeTowLists(l1,l2) ;\\n    \\n        }\\n    \\n        public ListNode mergeTowLists(ListNode l1 , ListNode l2){\\n            ListNode result = new ListNode(0) ;\\n            ListNode list = result ;\\n            while(l1 != null && l2 != null){\\n                if(l1.val < l2.val){\\n                    list.next = l1 ;\\n                    l1 = l1.next ;\\n                }else{\\n                    list.next = l2 ;\\n                    l2 = l2.next ;\\n                }\\n                list = list.next ;\\n            }\\n    \\n            while(l1 != null){\\n                list.next = l1 ;\\n                l1 = l1.next ;\\n                list = list.next ;\\n            }\\n    \\n            while(l2 != null){\\n                list.next = l2 ;\\n                l2 = l2.next ;\\n                list = list.next ;\\n            }\\n    \\n            return result.next ;\\n        }",
                "solutionTags": [],
                "code": "    public ListNode mergeKLists(List<ListNode> lists) {\\n            int length = lists.size() ;\\n    \\n            if(length == 0)\\n                return null ;\\n            if(length == 1){\\n                return lists.get(0) ;\\n            }\\n    \\n            int mid = (length - 1)/2 ;\\n            ListNode l1 = mergeKLists(lists.subList(0,mid + 1)) ;\\n            ListNode l2 = mergeKLists(lists.subList(mid + 1,length)) ;\\n    \\n            return mergeTowLists(l1,l2) ;\\n    \\n        }\\n    \\n        public ListNode mergeTowLists(ListNode l1 , ListNode l2){\\n            ListNode result = new ListNode(0) ;\\n            ListNode list = result ;\\n            while(l1 != null && l2 != null){\\n                if(l1.val < l2.val){\\n                    list.next = l1 ;\\n                    l1 = l1.next ;\\n                }else{\\n                    list.next = l2 ;\\n                    l2 = l2.next ;\\n                }\\n                list = list.next ;\\n            }\\n    \\n            while(l1 != null){\\n                list.next = l1 ;\\n                l1 = l1.next ;\\n                list = list.next ;\\n            }\\n    \\n            while(l2 != null){\\n                list.next = l2 ;\\n                l2 = l2.next ;\\n                list = list.next ;\\n            }\\n    \\n            return result.next ;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1032578,
                "title": "simple-java-solution-with-explaination-4-ms-heap",
                "content": "The idea is to use minheap to store all the elements of the Lists and then just get min element one by one and start appending it to the List. here to save space we are just re-using listnode objects and add it to the heap. and later just update next pointer.\\nto save null checks dumy node is used\\n```\\n/**\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((o1,o2)->o1.val-o2.val);\\n        ListNode dummy = new ListNode(-1);\\n        ListNode head=dummy;\\n        for(ListNode list:lists) {\\n            while(list!=null) {\\n                minHeap.add(list);\\n                list=list.next;\\n            }\\n        }\\n        while(!minHeap.isEmpty()) {\\n            dummy.next=minHeap.poll();\\n            dummy=dummy.next;\\n            dummy.next=null;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((o1,o2)->o1.val-o2.val);\\n        ListNode dummy = new ListNode(-1);\\n        ListNode head=dummy;\\n        for(ListNode list:lists) {\\n            while(list!=null) {\\n                minHeap.add(list);\\n                list=list.next;\\n            }\\n        }\\n        while(!minHeap.isEmpty()) {\\n            dummy.next=minHeap.poll();\\n            dummy=dummy.next;\\n            dummy.next=null;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10617,
                "title": "javascript-o-n-log-k-time-and-o-k-space-using-min-heap",
                "content": "```\\nclass Heap {\\n    constructor(comparator) {\\n        this.data = [];\\n        this.comparator = comparator || ((parent, child) => parent - child);\\n    }\\n\\n    get size() {\\n        return this.data.length;\\n    }\\n\\n    bubbleUp(c) {\\n        if (c === 0) return;\\n        const p = Math.floor((c + 1) / 2) - 1;\\n        if (this.comparator(this.data[p], this.data[c]) > 0) {\\n            [this.data[p], this.data[c]] = [this.data[c], this.data[p]];\\n        }\\n        this.bubbleUp(p);\\n    }\\n\\n    bubbleDown(p) {\\n        const c = 2 * (p + 1) - 1;\\n        if (c >= this.data.length) return;\\n\\n        const leftDelta = this.comparator(this.data[p], this.data[c]);\\n        const rightDelta = c + 1 >= this.data.length ? 0 : this.comparator(this.data[p], this.data[c + 1]);\\n        if (leftDelta <= 0 && rightDelta <= 0) return;\\n\\n        const swapChildIndex = c + (leftDelta <= rightDelta);\\n        [this.data[p], this.data[swapChildIndex]] = [this.data[swapChildIndex], this.data[p]];\\n        this.bubbleDown(swapChildIndex);\\n    }\\n\\n    add(val) {\\n        this.data.push(val);\\n        this.bubbleUp(this.data.length - 1);\\n    }\\n\\n    poll() {\\n        if (this.size < 2) return this.data.pop();\\n        [this.data[0], this.data[this.size - 1]] = [this.data[this.size - 1], this.data[0]];\\n        const val = this.data.pop();\\n        this.bubbleDown(0);\\n        return val;\\n    }\\n}\\n\\nvar mergeKLists = function(lists) {\\n    if (!lists.length) return null;\\n    \\n    const minHeap = new Heap((parent, child) => parent.val - child.val);\\n    for (let node of lists) {\\n        if (node) minHeap.add(node);\\n    }\\n    \\n    const dummy = new ListNode();\\n    let tail = dummy;\\n    while (minHeap.size) {\\n        tail.next = minHeap.poll();\\n        tail = tail.next;\\n        if (tail.next) minHeap.add(tail.next);\\n    }\\n    \\n    return dummy.next;\\n};\\n```\\nThis is O(n log k) time where n is the total number of nodes and k is the number of lists or the maximum size of the heap.\\n\\nJavaScript doesn't have built-in priority queuing, so we use a heap from scratch here. I'm considering writing a JS package to fill some of these holes for LeetCode use.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Heap {\\n    constructor(comparator) {\\n        this.data = [];\\n        this.comparator = comparator || ((parent, child) => parent - child);\\n    }\\n\\n    get size() {\\n        return this.data.length;\\n    }\\n\\n    bubbleUp(c) {\\n        if (c === 0) return;\\n        const p = Math.floor((c + 1) / 2) - 1;\\n        if (this.comparator(this.data[p], this.data[c]) > 0) {\\n            [this.data[p], this.data[c]] = [this.data[c], this.data[p]];\\n        }\\n        this.bubbleUp(p);\\n    }\\n\\n    bubbleDown(p) {\\n        const c = 2 * (p + 1) - 1;\\n        if (c >= this.data.length) return;\\n\\n        const leftDelta = this.comparator(this.data[p], this.data[c]);\\n        const rightDelta = c + 1 >= this.data.length ? 0 : this.comparator(this.data[p], this.data[c + 1]);\\n        if (leftDelta <= 0 && rightDelta <= 0) return;\\n\\n        const swapChildIndex = c + (leftDelta <= rightDelta);\\n        [this.data[p], this.data[swapChildIndex]] = [this.data[swapChildIndex], this.data[p]];\\n        this.bubbleDown(swapChildIndex);\\n    }\\n\\n    add(val) {\\n        this.data.push(val);\\n        this.bubbleUp(this.data.length - 1);\\n    }\\n\\n    poll() {\\n        if (this.size < 2) return this.data.pop();\\n        [this.data[0], this.data[this.size - 1]] = [this.data[this.size - 1], this.data[0]];\\n        const val = this.data.pop();\\n        this.bubbleDown(0);\\n        return val;\\n    }\\n}\\n\\nvar mergeKLists = function(lists) {\\n    if (!lists.length) return null;\\n    \\n    const minHeap = new Heap((parent, child) => parent.val - child.val);\\n    for (let node of lists) {\\n        if (node) minHeap.add(node);\\n    }\\n    \\n    const dummy = new ListNode();\\n    let tail = dummy;\\n    while (minHeap.size) {\\n        tail.next = minHeap.poll();\\n        tail = tail.next;\\n        if (tail.next) minHeap.add(tail.next);\\n    }\\n    \\n    return dummy.next;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892010,
                "title": "java-divide-and-conquer-recursive-2ms-faster-than-92",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        int k = lists.length;\\n        if (k == 0) return null;\\n        \\n        return mergeKLists(lists, 0, k-1);\\n    }\\n    \\n    public ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n        if (end - start == 0) return lists[start];\\n        if (end - start == 1) {\\n            return mergeLists(lists[start], lists[end]);\\n        }  \\n        \\n        int mid = start + ((end - start) / 2);\\n        ListNode listA = mergeKLists(lists, start, mid);\\n        ListNode listB = mergeKLists(lists, mid+1, end);\\n        \\n        return mergeLists(listA, listB);\\n    }\\n\\n    \\n    \\n    public ListNode mergeLists(ListNode listA, ListNode listB) {\\n        if (listA == null) return listB;\\n        if (listB == null) return listA;\\n        \\n        if (listA.val < listB.val) {\\n            listA.next = mergeLists(listA.next, listB);\\n            return listA;\\n        } \\n        else {\\n            listB.next = mergeLists(listA, listB.next);\\n            return listB;\\n        } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        int k = lists.length;\\n        if (k == 0) return null;\\n        \\n        return mergeKLists(lists, 0, k-1);\\n    }\\n    \\n    public ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n        if (end - start == 0) return lists[start];\\n        if (end - start == 1) {\\n            return mergeLists(lists[start], lists[end]);\\n        }  \\n        \\n        int mid = start + ((end - start) / 2);\\n        ListNode listA = mergeKLists(lists, start, mid);\\n        ListNode listB = mergeKLists(lists, mid+1, end);\\n        \\n        return mergeLists(listA, listB);\\n    }\\n\\n    \\n    \\n    public ListNode mergeLists(ListNode listA, ListNode listB) {\\n        if (listA == null) return listB;\\n        if (listB == null) return listA;\\n        \\n        if (listA.val < listB.val) {\\n            listA.next = mergeLists(listA.next, listB);\\n            return listA;\\n        } \\n        else {\\n            listB.next = mergeLists(listA, listB.next);\\n            return listB;\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663722,
                "title": "python-3-heapq-implementation-with-tips-and-tricks",
                "content": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        heap = []  # create a heap\\n        new_list = ListNode()  # dummy node\\n        \\n        counter = 0  # This counter is to add an abitrary value to the heap more below\\n        \\'\\'\\'\\n        We will be passing a tuple into the queue. Originally, I wanted to do heap.push((node.val, node))\\n        But in this case, we\\'ll get a runtime error. heapq uses the first item of an inserted tuple. If two tuples are inserted,\\n        it compares by the next item in the tuple. (1, node1) and (1, node2) will generated a TypeError. This is becuase the node\\n        class Leetcode provided does not have a __lt__ function, that is, nodes can\\'t be compared! We remedy this by setting a counter\\n        as the second item in our tuple. So instead of (node.val, node), we will input (node.val, counter, node) then increment the counter.\\n        This way, if two nodes have the same val, we get the one that entered the heap first, which will have a lower counter val. \\n        In any case if we have items like this in there: (1, 0, node1), (2, 1, node), (-1, 3, node), when we pop, we will get in order:\\n        (-1, 3, node), (1, 0, node1), (2, 1, node). So regardless the counter value, we will get the smallest items first! The counter is more\\n        like the priorit in which we get them! Hope that made sense!\\n        \\'\\'\\'\\n        for linked_list in lists:\\n            if not linked_list:\\n                continue\\n            \\n            # push all head nodes in our priority queue\\n            list_val = linked_list.val\\n            heapq.heappush(heap, (list_val, counter, linked_list))\\n            counter += 1\\n        \\n        # If we have an empty heap after pushing all heads, that means there are no nodes at all!\\n        if not heap:\\n            return None\\n        \\n        # keep popping out of the heap\\n        cur_node = new_list\\n        while heap:\\n            node_tuple = heapq.heappop(heap)\\n            node = node_tuple[2]\\n            node_next = node.next\\n            cur_node.next = node\\n            cur_node = cur_node.next\\n            \\n            # whichever node was the smallest, its next will be added to the heap, if it is not null\\n            if node_next:\\n                list_val = node_next.val\\n                new_node_tuple = (list_val, counter, node_next)\\n                heapq.heappush(heap, new_node_tuple)\\n                counter += 1\\n        \\n        # get the dummy node\\'s next. Which is the head\\n        return new_list.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        heap = []  # create a heap\\n        new_list = ListNode()  # dummy node\\n        \\n        counter = 0  # This counter is to add an abitrary value to the heap more below\\n        \\'\\'\\'\\n        We will be passing a tuple into the queue. Originally, I wanted to do heap.push((node.val, node))\\n        But in this case, we\\'ll get a runtime error. heapq uses the first item of an inserted tuple. If two tuples are inserted,\\n        it compares by the next item in the tuple. (1, node1) and (1, node2) will generated a TypeError. This is becuase the node\\n        class Leetcode provided does not have a __lt__ function, that is, nodes can\\'t be compared! We remedy this by setting a counter\\n        as the second item in our tuple. So instead of (node.val, node), we will input (node.val, counter, node) then increment the counter.\\n        This way, if two nodes have the same val, we get the one that entered the heap first, which will have a lower counter val. \\n        In any case if we have items like this in there: (1, 0, node1), (2, 1, node), (-1, 3, node), when we pop, we will get in order:\\n        (-1, 3, node), (1, 0, node1), (2, 1, node). So regardless the counter value, we will get the smallest items first! The counter is more\\n        like the priorit in which we get them! Hope that made sense!\\n        \\'\\'\\'\\n        for linked_list in lists:\\n            if not linked_list:\\n                continue\\n            \\n            # push all head nodes in our priority queue\\n            list_val = linked_list.val\\n            heapq.heappush(heap, (list_val, counter, linked_list))\\n            counter += 1\\n        \\n        # If we have an empty heap after pushing all heads, that means there are no nodes at all!\\n        if not heap:\\n            return None\\n        \\n        # keep popping out of the heap\\n        cur_node = new_list\\n        while heap:\\n            node_tuple = heapq.heappop(heap)\\n            node = node_tuple[2]\\n            node_next = node.next\\n            cur_node.next = node\\n            cur_node = cur_node.next\\n            \\n            # whichever node was the smallest, its next will be added to the heap, if it is not null\\n            if node_next:\\n                list_val = node_next.val\\n                new_node_tuple = (list_val, counter, node_next)\\n                heapq.heappush(heap, new_node_tuple)\\n                counter += 1\\n        \\n        # get the dummy node\\'s next. Which is the head\\n        return new_list.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258407,
                "title": "100-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        //edge case []\\n        if (lists.length == 0) return null;\\n        return partition(lists, 0, lists.length-1);\\n    }\\n    \\n    public ListNode partition(ListNode[] lists, int start, int end) {\\n        if (start == end) return lists[start];\\n        \\n        // start will always be less than or equal to end\\n        int mid = (start + end) / 2;\\n        ListNode l1 = partition(lists, start, mid);\\n        ListNode l2 = partition(lists, mid+1, end);\\n        return mergeTwo(l1, l2);\\n    }\\n    \\n    public ListNode mergeTwo(ListNode l1, ListNode l2) {\\n        if (l1==null) return l2;\\n        if (l2==null) return l1;\\n        \\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwo(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = mergeTwo(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        //edge case []\\n        if (lists.length == 0) return null;\\n        return partition(lists, 0, lists.length-1);\\n    }\\n    \\n    public ListNode partition(ListNode[] lists, int start, int end) {\\n        if (start == end) return lists[start];\\n        \\n        // start will always be less than or equal to end\\n        int mid = (start + end) / 2;\\n        ListNode l1 = partition(lists, start, mid);\\n        ListNode l2 = partition(lists, mid+1, end);\\n        return mergeTwo(l1, l2);\\n    }\\n    \\n    public ListNode mergeTwo(ListNode l1, ListNode l2) {\\n        if (l1==null) return l2;\\n        if (l2==null) return l1;\\n        \\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwo(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = mergeTwo(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183195,
                "title": "python-heapq-solution",
                "content": "This Solution is for Python3 leetcode environment:\\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        q, h = len(lists), []\\n        for i in range(q):\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i, lists[i]))\\n        \\n        rhead = rtail = ListNode(0)\\n        \\n        while h:\\n            i, n = heapq.heappop(h)[1:]\\n            rtail.next = n\\n            rtail = rtail.next\\n            if n.next:\\n                heapq.heappush(h, (n.next.val, i, n.next))\\n                \\n        return rhead.next\\n\\n```\\nWe can also rewrite it in a following way:\\n```\\nclass ListNodeExtension(ListNode):\\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        ListNode.__lt__ = ListNodeExtension.__lt__\\n        heap = []\\n        for n in lists:\\n            if n:\\n                heapq.heappush(heap, n)\\n        \\n        head = tail = ListNode(0) # Result pointers\\n        while heap:\\n            tail.next = heapq.heappop(heap)\\n            tail = tail.next\\n            if tail.next:\\n                heapq.heappush(heap, tail.next)\\n                \\n        return head.next\\n```\\n\\nPython2 Solution.\\nSince Python2 version of ListNode class here has a __lt__ method implementation, the solution gets as simple as that:\\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        h = []\\n        for lst in lists:\\n            if lst:\\n                heapq.heappush(h, (lst.val, lst))\\n        \\n        rhead = rtail = ListNode(0)\\n        while h:\\n            _, n = heapq.heappop(h)\\n            rtail.next = n\\n            rtail = rtail.next\\n            if n.next:\\n                heapq.heappush(h, (n.next.val, n.next))\\n                \\n        return rhead.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        q, h = len(lists), []\\n        for i in range(q):\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i, lists[i]))\\n        \\n        rhead = rtail = ListNode(0)\\n        \\n        while h:\\n            i, n = heapq.heappop(h)[1:]\\n            rtail.next = n\\n            rtail = rtail.next\\n            if n.next:\\n                heapq.heappush(h, (n.next.val, i, n.next))\\n                \\n        return rhead.next\\n\\n```\n```\\nclass ListNodeExtension(ListNode):\\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        ListNode.__lt__ = ListNodeExtension.__lt__\\n        heap = []\\n        for n in lists:\\n            if n:\\n                heapq.heappush(heap, n)\\n        \\n        head = tail = ListNode(0) # Result pointers\\n        while heap:\\n            tail.next = heapq.heappop(heap)\\n            tail = tail.next\\n            if tail.next:\\n                heapq.heappush(heap, tail.next)\\n                \\n        return head.next\\n```\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        h = []\\n        for lst in lists:\\n            if lst:\\n                heapq.heappush(h, (lst.val, lst))\\n        \\n        rhead = rtail = ListNode(0)\\n        while h:\\n            _, n = heapq.heappop(h)\\n            rtail.next = n\\n            rtail = rtail.next\\n            if n.next:\\n                heapq.heappush(h, (n.next.val, n.next))\\n                \\n        return rhead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288787,
                "title": "java-easy-divide-and-conquer-similar-to-merge-sort",
                "content": "**Similar to merge sort (Divide and conquer)**\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return divideAndConquer(lists, 0, lists.length - 1);\\n    }\\n    public ListNode divideAndConquer(ListNode[] lists,int low,int high){\\n        if(low>high)\\n            return null;\\n        if(low==high)\\n            return lists[low];\\n        int mid=low+(high-low)/2;\\n        ListNode left=divideAndConquer(lists,low,mid);\\n        ListNode right=divideAndConquer(lists,mid+1,high);\\n        return merge(left,right);\\n    }\\n    public ListNode merge(ListNode n1, ListNode n2) {\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        while (n1!=null && n2!=null){\\n            if (n1.val<n2.val) {\\n                prev.next = n1;\\n                n1 = n1.next;\\n            }\\n            else{\\n                prev.next = n2;\\n                n2 = n2.next;\\n            }\\n            prev = prev.next;\\n        }\\n        if(n1!=null)\\n            prev.next=n1;\\n        if(n2!=null)\\n            prev.next=n2;\\n        return dummy.next;\\n    }\\n}\\n```\\n**Time Complexity: O(Nlog(k))\\nSpace Complexity: O(log(k)) as we use recursion (depth of the recursion tree)**\\n\\n![image](https://assets.leetcode.com/users/images/1bfc96ef-6cb6-4e21-a466-7bf1c9523336_1678634065.5824854.png)\\n\\n![image](https://assets.leetcode.com/users/images/658f2cdb-43a5-4c04-b850-bb85684bfe7c_1678634076.8951302.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return divideAndConquer(lists, 0, lists.length - 1);\\n    }\\n    public ListNode divideAndConquer(ListNode[] lists,int low,int high){\\n        if(low>high)\\n            return null;\\n        if(low==high)\\n            return lists[low];\\n        int mid=low+(high-low)/2;\\n        ListNode left=divideAndConquer(lists,low,mid);\\n        ListNode right=divideAndConquer(lists,mid+1,high);\\n        return merge(left,right);\\n    }\\n    public ListNode merge(ListNode n1, ListNode n2) {\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        while (n1!=null && n2!=null){\\n            if (n1.val<n2.val) {\\n                prev.next = n1;\\n                n1 = n1.next;\\n            }\\n            else{\\n                prev.next = n2;\\n                n2 = n2.next;\\n            }\\n            prev = prev.next;\\n        }\\n        if(n1!=null)\\n            prev.next=n1;\\n        if(n2!=null)\\n            prev.next=n2;\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902441,
                "title": "100-fastest-swift-solution-time-o-n-log-k-space-o-k",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(k)), where n is the total number of nodes in two linked lists, and k is the number of linked lists.\\n    //   - space: O(k), where k is the number of linked l43q   QAists.\\n    \\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        guard !lists.isEmpty else { return nil }\\n        let n = lists.count\\n        var lists = lists\\n        var interval = 1\\n        \\n        while interval < n {\\n            var i = 0\\n            while i + interval < n {\\n                lists[i] = mergeTwoLists(lists[i], lists[i + interval])\\n                i += interval * 2\\n            }\\n            interval *= 2\\n        }\\n        \\n        return lists[0]\\n    }\\n    \\n    \\n    private func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        let dummy = ListNode(-1)\\n        var cur: ListNode? = dummy\\n        var l1 = l1\\n        var l2 = l2\\n        \\n        while l1 != nil || l2 != nil {\\n            if let l1Val = l1?.val, let l2Val = l2?.val {\\n                if l1Val < l2Val {\\n                    cur?.next = l1\\n                    l1 = l1?.next\\n                } else {\\n                    cur?.next = l2\\n                    l2 = l2?.next\\n                }\\n                \\n            } else if l1 != nil {\\n                cur?.next = l1\\n                l1 = l1?.next\\n            } else if l2 != nil {\\n                cur?.next = l2\\n                l2 = l2?.next\\n            }\\n            cur = cur?.next\\n        }\\n        \\n        return dummy.next\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(k)), where n is the total number of nodes in two linked lists, and k is the number of linked lists.\\n    //   - space: O(k), where k is the number of linked l43q   QAists.\\n    \\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        guard !lists.isEmpty else { return nil }\\n        let n = lists.count\\n        var lists = lists\\n        var interval = 1\\n        \\n        while interval < n {\\n            var i = 0\\n            while i + interval < n {\\n                lists[i] = mergeTwoLists(lists[i], lists[i + interval])\\n                i += interval * 2\\n            }\\n            interval *= 2\\n        }\\n        \\n        return lists[0]\\n    }\\n    \\n    \\n    private func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        let dummy = ListNode(-1)\\n        var cur: ListNode? = dummy\\n        var l1 = l1\\n        var l2 = l2\\n        \\n        while l1 != nil || l2 != nil {\\n            if let l1Val = l1?.val, let l2Val = l2?.val {\\n                if l1Val < l2Val {\\n                    cur?.next = l1\\n                    l1 = l1?.next\\n                } else {\\n                    cur?.next = l2\\n                    l2 = l2?.next\\n                }\\n                \\n            } else if l1 != nil {\\n                cur?.next = l1\\n                l1 = l1?.next\\n            } else if l2 != nil {\\n                cur?.next = l2\\n                l2 = l2?.next\\n            }\\n            cur = cur?.next\\n        }\\n        \\n        return dummy.next\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284754,
                "title": "easy-c-solution-using-priority-queue",
                "content": "```\\ntypedef pair<int,ListNode *> node;\\nclass Solution\\n{\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) \\n    {\\n        priority_queue<node,vector<node>,greater<node>>q;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i])\\n            {\\n                q.push({lists[i]->val,lists[i]});\\n            }\\n        }\\n        ListNode *head=NULL,*tmp;\\n        while(!q.empty())\\n        {\\n            auto p=q.top();\\n            q.pop();\\n            if(!head)\\n            {\\n                head=p.second;\\n            }\\n            else\\n            {\\n                tmp->next=p.second;\\n            }\\n            tmp=p.second;\\n            if(p.second->next)\\n            {\\n                q.push({p.second->next->val,p.second->next});\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code.Thank you.***",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,ListNode *> node;\\nclass Solution\\n{\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) \\n    {\\n        priority_queue<node,vector<node>,greater<node>>q;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i])\\n            {\\n                q.push({lists[i]->val,lists[i]});\\n            }\\n        }\\n        ListNode *head=NULL,*tmp;\\n        while(!q.empty())\\n        {\\n            auto p=q.top();\\n            q.pop();\\n            if(!head)\\n            {\\n                head=p.second;\\n            }\\n            else\\n            {\\n                tmp->next=p.second;\\n            }\\n            tmp=p.second;\\n            if(p.second->next)\\n            {\\n                q.push({p.second->next->val,p.second->next});\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850425,
                "title": "simple-cpp-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    struct compare\\n    {\\n        bool operator()(ListNode* &a,ListNode* &b)\\n        {\\n            return a->val>b->val;\\n        }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,compare>minh;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n           if(lists[i]!=NULL) minh.push(lists[i]);\\n        }\\n        ListNode* head=new ListNode(0);\\n        ListNode* temp=head;\\n        while(minh.size()>0)\\n        {\\n            ListNode* p=minh.top();\\n            minh.pop();\\n            temp->next=new ListNode(p->val);\\n            temp=temp->next;\\n            if(p->next!=NULL) minh.push(p->next);\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct compare\\n    {\\n        bool operator()(ListNode* &a,ListNode* &b)\\n        {\\n            return a->val>b->val;\\n        }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,compare>minh;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n           if(lists[i]!=NULL) minh.push(lists[i]);\\n        }\\n        ListNode* head=new ListNode(0);\\n        ListNode* temp=head;\\n        while(minh.size()>0)\\n        {\\n            ListNode* p=minh.top();\\n            minh.pop();\\n            temp->next=new ListNode(p->val);\\n            temp=temp->next;\\n            if(p->next!=NULL) minh.push(p->next);\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203549,
                "title": "python-solution",
                "content": "We first put the heads of the `k` linked lists (more precisely the tuple `(val, index)`, where `val` is the value of the node, and `index` is the index of node in `lists`) into a min-heap. We initialize a node `head`. Then we continuously pop elements from `heap` until `heap` is empty, and each time we pop an element `(val, index)`, we create a new ListNode with value `val`, and append it to the linked list with head `head`. Before popping again from `heap`, we need to add the next node in `lists[index]` to `heap` if it exists. This is achieved by the lines:\\n```\\nif lists[index].next:\\n\\tlists[index] = lists[index].next\\n\\theapq.heappush(heap, (lists[index].val, index))\\n```\\nTime complexity: `O(N log k)`, space complexity: `O(N + k)`, where `N` is the total number of nodes in the `k` linked lists.\\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        heap = [(lists[i].val, i) for i in range(len(lists)) if lists[i]]\\n        heapq.heapify(heap)\\n        head = None\\n        while heap:\\n            nex = heapq.heappop(heap)\\n            node = ListNode(nex[0])\\n            index = nex[1]\\n            if not head:\\n                head = node\\n                trav = head\\n            else:\\n                trav.next = node\\n                trav = trav.next\\n            if lists[index].next:\\n                lists[index] = lists[index].next\\n                heapq.heappush(heap, (lists[index].val, index))\\n        return head \\n```",
                "solutionTags": [],
                "code": "```\\nif lists[index].next:\\n\\tlists[index] = lists[index].next\\n\\theapq.heappush(heap, (lists[index].val, index))\\n```\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        heap = [(lists[i].val, i) for i in range(len(lists)) if lists[i]]\\n        heapq.heapify(heap)\\n        head = None\\n        while heap:\\n            nex = heapq.heappop(heap)\\n            node = ListNode(nex[0])\\n            index = nex[1]\\n            if not head:\\n                head = node\\n                trav = head\\n            else:\\n                trav.next = node\\n                trav = trav.next\\n            if lists[index].next:\\n                lists[index] = lists[index].next\\n                heapq.heappush(heap, (lists[index].val, index))\\n        return head \\n```",
                "codeTag": "Java"
            },
            {
                "id": 10552,
                "title": "python-133ms-solution",
                "content": "\\n    from operator import attrgetter\\n    \\n    class Solution:\\n        # @param a list of ListNode\\n        # @return a ListNode\\n        def mergeKLists(self, lists):\\n            sorted_list = []\\n            for head in lists:\\n                curr = head\\n                while curr is not None:\\n                    sorted_list.append(curr)\\n                    curr = curr.next\\n    \\n            sorted_list = sorted(sorted_list, key=attrgetter('val'))\\n            for i, node in enumerate(sorted_list):\\n                try:\\n                    node.next = sorted_list[i + 1]\\n                except:\\n                    node.next = None\\n    \\n            if sorted_list:\\n                return sorted_list[0]\\n            else:\\n                return None",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    from operator import attrgetter\\n    \\n    class Solution:\\n        # @param a list of ListNode\\n        # @return a ListNode\\n        def mergeKLists(self, lists):\\n            sorted_list = []\\n            for head in lists:\\n                curr = head\\n                while curr is not None:\\n                    sorted_list.append(curr)\\n                    curr = curr.next\\n    \\n            sorted_list = sorted(sorted_list, key=attrgetter('val'))\\n            for i, node in enumerate(sorted_list):\\n                try:\\n                    node.next = sorted_list[i + 1]\\n                except:\\n                    node.next = None\\n    \\n            if sorted_list:\\n                return sorted_list[0]\\n            else:\\n                return None",
                "codeTag": "Java"
            },
            {
                "id": 3286192,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeKListsHelper(lists, start, mid);\\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        \\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        curr.next = (l1 != null) ? l1 : l2;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeKListsHelper(lists, start, mid);\\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        \\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        curr.next = (l1 != null) ? l1 : l2;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034920,
                "title": "c-sortedset-tuples",
                "content": "I really like the divide and conquer approach, it is probably the cleanest way to go about solving things IMO. The approach I came up with before seeing that way  was similar to the heap-based / priority queue solutions.\\n\\nThere is a slight issue trying to implement in C# that the language does not have the perfect data structure. A `SortedSet` keeps elements sorted, but does not allow duplicates without a bit of a hack. The hack being, to use a `SortedSet` of tuples, knowing that the default comparer compares elements left-to-right, returning the first inequality. For the first element of each tuple, use the value to compare, the second value is the list index that it belongs to. For example, the numbers `[1,2,3,3,2,3,4]` can be converted to `[(1,0),(2,1),(3,2),(3,3),(2,4),(3,5),(4,6)].` The `2` at index `1` will be considered less than the `2` at index `4`. With that in mind, here is my solution!\\n\\n```cs\\npublic ListNode MergeKLists(ListNode[] lists) {\\n    if (lists == null)\\n        return null;\\n\\n    var ss = new SortedSet<(int Value, int Index, ListNode Node)>();\\n    for (int i = 0; i < lists.Length; i++)\\n        if (lists[i] != null)\\n            ss.Add((lists[i].val, i, lists[i]));\\n\\n    ListNode head = new ListNode(), tail = head;\\n    while (ss.Count > 0) {\\n        var min = ss.Min;\\n        ss.Remove(min);\\n\\n        tail.next = min.Node;\\n        tail = tail.next;\\n\\n        var next = min.Node.next;\\n        if (next != null)\\n            ss.Add((next.val, min.Index, next));\\n    }\\n    return head.next;\\n}\\n```\\n\\n\\n**Update for .NET 6**\\n\\nStarting with .NET 6 we have access to a `PriorityQueue`. The above solution can be changed to take advante of the new data structure as follows:\\n\\n```cs\\npublic ListNode MergeKLists(ListNode[] lists) {\\n    if (lists == null)\\n        return null;\\n\\n    var pq = new PriorityQueue<ListNode, int>();\\n    foreach (var list in lists)\\n        if (list != null)\\n            pq.Enqueue(list, list.val);\\n\\n    ListNode head = new ListNode(), tail = head;\\n    while (pq.Count > 0) {\\n        var node = pq.Dequeue();\\n\\n        tail.next = node;\\n        tail = node;\\n\\n        if (node.next != null)\\n            pq.Enqueue(node.next, node.next.val);\\n    }\\n    return head.next;\\n}\\n```\\n\\nI also posted a divide and conquer solution here:\\n\\n* https://leetcode.com/problems/merge-k-sorted-lists/discuss/1037796/C-Divide-and-Conquer",
                "solutionTags": [
                    "C"
                ],
                "code": "```cs\\npublic ListNode MergeKLists(ListNode[] lists) {\\n    if (lists == null)\\n        return null;\\n\\n    var ss = new SortedSet<(int Value, int Index, ListNode Node)>();\\n    for (int i = 0; i < lists.Length; i++)\\n        if (lists[i] != null)\\n            ss.Add((lists[i].val, i, lists[i]));\\n\\n    ListNode head = new ListNode(), tail = head;\\n    while (ss.Count > 0) {\\n        var min = ss.Min;\\n        ss.Remove(min);\\n\\n        tail.next = min.Node;\\n        tail = tail.next;\\n\\n        var next = min.Node.next;\\n        if (next != null)\\n            ss.Add((next.val, min.Index, next));\\n    }\\n    return head.next;\\n}\\n```\n```cs\\npublic ListNode MergeKLists(ListNode[] lists) {\\n    if (lists == null)\\n        return null;\\n\\n    var pq = new PriorityQueue<ListNode, int>();\\n    foreach (var list in lists)\\n        if (list != null)\\n            pq.Enqueue(list, list.val);\\n\\n    ListNode head = new ListNode(), tail = head;\\n    while (pq.Count > 0) {\\n        var node = pq.Dequeue();\\n\\n        tail.next = node;\\n        tail = node;\\n\\n        if (node.next != null)\\n            pq.Enqueue(node.next, node.next.val);\\n    }\\n    return head.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258231,
                "title": "easy-understand-js-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists = function(lists) {\\n    if(lists.length===0)return null;\\n    return lists.reduce(mergeTwoLists);\\n};\\n\\nfunction mergeTwoLists(l1, l2) {\\n    let l3 = new ListNode();\\n    let curr = l3;\\n      \\n    while(l1&&l2) {\\n        if(l1.val < l2.val) {\\n          curr.next = l1\\n          l1 = l1.next;\\n        } else {\\n          curr.next = l2\\n          l2 = l2.next;\\n        }\\n        curr = curr.next;\\n      }\\n      \\n      curr.next = l1 || l2;\\n      return l3.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists = function(lists) {\\n    if(lists.length===0)return null;\\n    return lists.reduce(mergeTwoLists);\\n};\\n\\nfunction mergeTwoLists(l1, l2) {\\n    let l3 = new ListNode();\\n    let curr = l3;\\n      \\n    while(l1&&l2) {\\n        if(l1.val < l2.val) {\\n          curr.next = l1\\n          l1 = l1.next;\\n        } else {\\n          curr.next = l2\\n          l2 = l2.next;\\n        }\\n        curr = curr.next;\\n      }\\n      \\n      curr.next = l1 || l2;\\n      return l3.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10888,
                "title": "my-accepted-java-solution-using-priorityqueue",
                "content": "    public ListNode mergeKLists(ListNode[] lists) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        if (lists == null || lists.length < 1) {\\n            return null;\\n        }\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>(lists.length, new Comparator<ListNode>() {\\n            public int compare(ListNode l1, ListNode l2) {\\n                return l1.val - l2.val;\\n            }    \\n        });\\n        for (int i = 0; i < lists.length; i++) {\\n            if (lists[i] != null) {\\n                minHeap.offer(lists[i]);\\n            }\\n        }\\n        while (!minHeap.isEmpty()) {\\n            ListNode temp = minHeap.poll();\\n            cur.next = temp;\\n            if (temp.next != null) {\\n                minHeap.offer(temp.next);\\n            }\\n            cur = temp;\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode mergeKLists(ListNode[] lists) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        if (lists == null || lists.length < 1) {\\n            return null;\\n        }\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>(lists.length, new Comparator<ListNode>() {\\n            public int compare(ListNode l1, ListNode l2) {\\n                return l1.val - l2.val;\\n            }    \\n        });\\n        for (int i = 0; i < lists.length; i++) {\\n            if (lists[i] != null) {\\n                minHeap.offer(lists[i]);\\n            }\\n        }\\n        while (!minHeap.isEmpty()) {\\n            ListNode temp = minHeap.poll();\\n            cur.next = temp;\\n            if (temp.next != null) {\\n                minHeap.offer(temp.next);\\n            }\\n            cur = temp;\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1937005,
                "title": "python-easy-solution-faster-than-92",
                "content": "# Please upvote if it helps!\\n## Intuitive Approachs\\n- Traverse all the linked list and store into an array\\n- Sort the array and create a new linked list using the sorted array\\n- Return the linked list\\n- That\\'s all\\n\\n```\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        arr = []\\n        for l in lists:\\n            while l:\\n                arr.append(l.val)\\n                l = l.next\\n        \\n        arr.sort()\\n        res = ListNode(0)\\n        rNext = res\\n        for d in arr:\\n            rNext.next = ListNode(d)\\n            rNext = rNext.next\\n            \\n        return res.next\\n```\\n\\n## Leave a comment if you have any question.\\n![image](https://assets.leetcode.com/users/images/70dd5f90-c79b-4ab9-bc34-18ff03bf305d_1649697278.3938332.png)\\n",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        arr = []\\n        for l in lists:\\n            while l:\\n                arr.append(l.val)\\n                l = l.next\\n        \\n        arr.sort()\\n        res = ListNode(0)\\n        rNext = res\\n        for d in arr:\\n            rNext.next = ListNode(d)\\n            rNext = rNext.next\\n            \\n        return res.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1746156,
                "title": "easiest-solution-using-set-and-linkedlist-only",
                "content": "\\n**Simple Approach Here Is:**\\n\\n**In short:**\\n\\nGiven Vector of LinkedList Is Lists = [[1,4,5], [1,3,4], [2,6]] (Total 8 Elements (With **Repeated elements**) \\u2026 So, Store Value in **Multiset**)\\n\\n**Lists** : [[1,4,5], [1,3,4], [2,6]]\\n**MultiSet** : [1,1,2,3,4,4,5,6]\\nCreate **New LinkedList** : [1,1,2,3,4,4,5,6]\\n**Return Node** of LinkedList.\\n\\n**Full Explanation:**\\n\\nFirst Take All Element of LinkedList by LinkedList in One **Multiset** (i.e. Given Vector of LinkedList Is Lists = [[1,4,5], [1,3,4], [2,6]] So Total Element of Individual LinkedList Is 3,3 And 2 So That Our Set Has **Total** 3+3+2 = **8 Elements**. As We Know That **Set Has a property to Store Elements in Sorted Order** So Simply, We **Insert Element One by One in Set** and **Final Set Is [1,1,2,3,4,4,5,6]** So Here Our Answer Now We Only Have to **Store This Elements in One New LinkedList** and **Return Node of That LinkedList**.......Simple. **Don\\'t Forget To UpVote :)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        multiset<int> s;\\n        for(auto x:lists){\\n            while(x!=NULL){\\n                s.insert(x->val);\\n                x=x->next;\\n            }\\n        }\\n        ListNode *head = new ListNode(0); //head is set to zero so in last we return head->next;\\n        ListNode *temp = head;\\n        for(auto y:s){\\n            temp->next = new ListNode(y);\\n            temp=temp->next;\\n        }\\n        return head->next; //here head->next is our first node\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "Linked List",
                    "Merge Sort",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        multiset<int> s;\\n        for(auto x:lists){\\n            while(x!=NULL){\\n                s.insert(x->val);\\n                x=x->next;\\n            }\\n        }\\n        ListNode *head = new ListNode(0); //head is set to zero so in last we return head->next;\\n        ListNode *temp = head;\\n        for(auto y:s){\\n            temp->next = new ListNode(y);\\n            temp=temp->next;\\n        }\\n        return head->next; //here head->next is our first node\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283278,
                "title": "ruby-all-solutions-summarized-with-complexity",
                "content": "```ruby\\nclass ListNode\\n    attr_accessor :val, :next\\n    def initialize(val)\\n        @val = val\\n        @next = nil\\n    end\\nend\\n\\n# Approach 1 (Brute-Force)\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists)\\n    nodes = []\\n    lists.each do |l|\\n        while l\\n            nodes << l\\n            l = l.next\\n        end\\n    end\\n\\n    nodes = nodes.sort_by(&:val)\\n    dummy = tmp = ListNode.new(nil)\\n    nodes.each do |node|\\n        tmp.next = node\\n        tmp = tmp.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# Approach 5: Divide and Conquer (Merge Sort Way)\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists, s_idx = 0, e_idx = lists.size - 1)\\n    return if lists.empty?\\n    return lists[e_idx] if s_idx == e_idx\\n\\n    mid = (s_idx + e_idx) / 2\\n    left = merge_k_lists(lists, s_idx, mid)\\n    right = merge_k_lists(lists, mid + 1, e_idx)\\n\\n    merge_two_lists(left, right)\\nend\\n\\ndef merge_two_lists(l1, l2)\\n    dummy = curr = ListNode.new(nil)\\n\\n    while l1 || l2\\n        if (l1 && l2 && l1.val < l2.val) || !l2\\n            curr.next, l1 = l1, l1.next\\n        elsif (l1 && l2) || !l1\\n            curr.next, l2 = l2, l2.next\\n        end\\n        curr = curr.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# Approach 6: Divide and Conquer Iterative\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists)\\n    k, interval = lists.size, 1\\n\\n    while interval < k\\n        0.step(k - interval, interval * 2) do |i|\\n            l, r = lists[i], lists[i + interval]\\n            lists[i] = merge_two_lists(l, r)\\n        end\\n        interval *= 2\\n    end\\n\\n    k > 0 ? lists.first : lists\\nend\\n\\ndef merge_two_lists(l1, l2)\\n    dummy = curr = ListNode.new(nil)\\n\\n    while l1 || l2\\n        if (l1 && l2 && l1.val < l2.val) || !l2\\n            curr.next, l1 = l1, l1.next\\n        elsif (l1 && l2) || !l1\\n            curr.next, l2 = l2, l2.next\\n        end\\n        curr = curr.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# 23. Merge k Sorted Lists\\n# https://leetcode.com/problems/merge-k-sorted-lists/description/\\n\\n# There are 5 approaches\\n# Approach 1: Brute force, collect all nodes and sort by value. Approach from above.\\n# Time: O(nlog(n))\\n# Space: O(n)\\n\\n# Approach 2: Iterate through all the lists and take the minimum from the k lists \\n# Time: O(k * n)\\n# Space: O(1)\\n\\n# Approach 3: The comparison process can be optimized in the above process using priority queue.\\n# Time: O(nlogk)\\n# Space: O(1)\\n\\n# Approach 4: Divide and Conquer, Merge k lists k-1 times two at a time.\\n# Time: O(nk)\\n# Space: O(1)\\n\\n# Approach 5: Divide and Conquer, Merge sort way (Optimal)\\n# Time: O(nlogk)\\n# Space: O(log(k)), log(k) for stack\\n\\n# Approach 6: Divide and Conquer, Iterative\\n# Time: O(nlogk)\\n# Space: O(1)\\n```",
                "solutionTags": [],
                "code": "```ruby\\nclass ListNode\\n    attr_accessor :val, :next\\n    def initialize(val)\\n        @val = val\\n        @next = nil\\n    end\\nend\\n\\n# Approach 1 (Brute-Force)\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists)\\n    nodes = []\\n    lists.each do |l|\\n        while l\\n            nodes << l\\n            l = l.next\\n        end\\n    end\\n\\n    nodes = nodes.sort_by(&:val)\\n    dummy = tmp = ListNode.new(nil)\\n    nodes.each do |node|\\n        tmp.next = node\\n        tmp = tmp.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# Approach 5: Divide and Conquer (Merge Sort Way)\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists, s_idx = 0, e_idx = lists.size - 1)\\n    return if lists.empty?\\n    return lists[e_idx] if s_idx == e_idx\\n\\n    mid = (s_idx + e_idx) / 2\\n    left = merge_k_lists(lists, s_idx, mid)\\n    right = merge_k_lists(lists, mid + 1, e_idx)\\n\\n    merge_two_lists(left, right)\\nend\\n\\ndef merge_two_lists(l1, l2)\\n    dummy = curr = ListNode.new(nil)\\n\\n    while l1 || l2\\n        if (l1 && l2 && l1.val < l2.val) || !l2\\n            curr.next, l1 = l1, l1.next\\n        elsif (l1 && l2) || !l1\\n            curr.next, l2 = l2, l2.next\\n        end\\n        curr = curr.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# Approach 6: Divide and Conquer Iterative\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists)\\n    k, interval = lists.size, 1\\n\\n    while interval < k\\n        0.step(k - interval, interval * 2) do |i|\\n            l, r = lists[i], lists[i + interval]\\n            lists[i] = merge_two_lists(l, r)\\n        end\\n        interval *= 2\\n    end\\n\\n    k > 0 ? lists.first : lists\\nend\\n\\ndef merge_two_lists(l1, l2)\\n    dummy = curr = ListNode.new(nil)\\n\\n    while l1 || l2\\n        if (l1 && l2 && l1.val < l2.val) || !l2\\n            curr.next, l1 = l1, l1.next\\n        elsif (l1 && l2) || !l1\\n            curr.next, l2 = l2, l2.next\\n        end\\n        curr = curr.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# 23. Merge k Sorted Lists\\n# https://leetcode.com/problems/merge-k-sorted-lists/description/\\n\\n# There are 5 approaches\\n# Approach 1: Brute force, collect all nodes and sort by value. Approach from above.\\n# Time: O(nlog(n))\\n# Space: O(n)\\n\\n# Approach 2: Iterate through all the lists and take the minimum from the k lists \\n# Time: O(k * n)\\n# Space: O(1)\\n\\n# Approach 3: The comparison process can be optimized in the above process using priority queue.\\n# Time: O(nlogk)\\n# Space: O(1)\\n\\n# Approach 4: Divide and Conquer, Merge k lists k-1 times two at a time.\\n# Time: O(nk)\\n# Space: O(1)\\n\\n# Approach 5: Divide and Conquer, Merge sort way (Optimal)\\n# Time: O(nlogk)\\n# Space: O(log(k)), log(k) for stack\\n\\n# Approach 6: Divide and Conquer, Iterative\\n# Time: O(nlogk)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222324,
                "title": "javascript",
                "content": "```\\nvar mergeKLists = function(lists) {\\n  const merge = (l1, l2) => {\\n    if (!l1 || !l2) return l1 || l2;\\n    let node = {};\\n    const root = node;\\n    while (l1 && l2) {\\n      if (l1.val <= l2.val) {\\n        node.next = l1;\\n        l1 = l1.next;\\n      } else {\\n        node.next = l2;\\n        l2 = l2.next;\\n      }\\n      node = node.next;\\n    }\\n    if (l1) node.next = l1;\\n    if (l2) node.next = l2;\\n    return root.next;\\n  }\\n  \\n  let root = lists[0];\\n  for (let i = 1; i < lists.length; i++) {\\n    root = merge(root, lists[i]);\\n  }\\n  \\n  return root || null;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar mergeKLists = function(lists) {\\n  const merge = (l1, l2) => {\\n    if (!l1 || !l2) return l1 || l2;\\n    let node = {};\\n    const root = node;\\n    while (l1 && l2) {\\n      if (l1.val <= l2.val) {\\n        node.next = l1;\\n        l1 = l1.next;\\n      } else {\\n        node.next = l2;\\n        l2 = l2.next;\\n      }\\n      node = node.next;\\n    }\\n    if (l1) node.next = l1;\\n    if (l2) node.next = l2;\\n    return root.next;\\n  }\\n  \\n  let root = lists[0];\\n  for (let i = 1; i < lists.length; i++) {\\n    root = merge(root, lists[i]);\\n  }\\n  \\n  return root || null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10996,
                "title": "elegan-solution-based-on-a-heap-of-lists",
                "content": "I convert the vector of lists into an heap and I use it to generate the merged list:\\n\\n    class Solution {\\n        \\n    public:\\n        \\n        ListNode *mergeKLists(vector<ListNode *> &lists) {\\n            \\n            // Begin and end of our range of elements:\\n            auto it_begin = begin(lists);\\n            auto it_end = end(lists);\\n            \\n            // Removes empty lists:\\n            it_end = remove_if(it_begin, it_end, isNull);\\n            if (it_begin == it_end) return nullptr; // All lists where empty.\\n            \\n            // Head and tail of the merged list:\\n            ListNode *head = nullptr;\\n            ListNode *tail = nullptr;\\n            \\n            // Builds a min-heap over the list of lists:\\n            make_heap(it_begin, it_end, minHeapPred);\\n            \\n            // The first element in the heap is the head of our merged list:\\n            head = tail = *it_begin;\\n            \\n            while (distance(it_begin, it_end) > 1) {\\n                \\n                // Moves the heap's front list to its back:\\n                pop_heap(it_begin, it_end, minHeapPred);\\n                \\n                // And removes one node from it:\\n                --it_end;\\n                *it_end = (*it_end)->next;\\n                \\n                // If it is not empty it inserts it back into the heap:\\n                if (*it_end) {\\n                    \\n                    ++it_end;\\n                    push_heap(it_begin, it_end, minHeapPred);\\n                }\\n                \\n                // After  the push we have our next node in front of the heap:\\n                tail->next = *it_begin;\\n                tail = tail->next;\\n            }\\n            \\n            return head;\\n        }\\n        \\n    private:\\n        \\n        // Predicate to remove all null nodes from a vector:\\n        static bool isNull(const ListNode* a) {\\n            \\n            return a == nullptr;\\n        }\\n    \\n        // Predicate to generate a min heap of list node pointers:\\n        static bool minHeapPred(const ListNode* a,\\n                                const ListNode* b) {\\n    \\n            assert(a);\\n            assert(b);\\n            \\n            return a->val > b->val;\\n        }\\n        \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n    public:\\n        \\n        ListNode *mergeKLists(vector<ListNode *> &lists) {\\n            \\n            // Begin and end of our range of elements:\\n            auto it_begin = begin(lists);\\n            auto it_end = end(lists);\\n            \\n            // Removes empty lists:\\n            it_end = remove_if(it_begin, it_end, isNull);\\n            if (it_begin == it_end) return nullptr; // All lists where empty.\\n            \\n            // Head and tail of the merged list:\\n            ListNode *head = nullptr;\\n            ListNode *tail = nullptr;\\n            \\n            // Builds a min-heap over the list of lists:\\n            make_heap(it_begin, it_end, minHeapPred);\\n            \\n            // The first element in the heap is the head of our merged list:\\n            head = tail = *it_begin;\\n            \\n            while (distance(it_begin, it_end) > 1) {\\n                \\n                // Moves the heap's front list to its back:\\n                pop_heap(it_begin, it_end, minHeapPred);\\n                \\n                // And removes one node from it:\\n                --it_end;\\n                *it_end = (*it_end)->next;\\n                \\n                // If it is not empty it inserts it back into the heap:\\n                if (*it_end) {\\n                    \\n                    ++it_end;\\n                    push_heap(it_begin, it_end, minHeapPred);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 10849,
                "title": "8-lines-python-with-generators-and-heapq-merge",
                "content": "Solution 1\\n-\\nBuilding the new list with just the **values** from the old ones, leaving the old lists intact.\\n\\n    def mergeKLists(self, lists):\\n        def vals(node):\\n            while node:\\n                yield node.val\\n                node = node.next\\n        dummy = last = ListNode(None)\\n        for val in heapq.merge(*map(vals, lists)):\\n            last.next = last = ListNode(val)\\n        return dummy.next\\n\\n---\\n\\nSolution 2\\n-\\n\\nBuilding the new list with the **nodes** from the old ones.\\n\\n    def mergeKLists(self, lists):\\n        def gen(node):\\n            while node:\\n                yield node.val, node\\n                node = node.next\\n        dummy = last = ListNode(None)\\n        for _, last.next in heapq.merge(*map(gen, lists)):\\n            last = last.next\\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "Solution 1\\n-\\nBuilding the new list with just the **values** from the old ones, leaving the old lists intact.\\n\\n    def mergeKLists(self, lists):\\n        def vals(node):\\n            while node:\\n                yield node.val\\n                node = node.next\\n        dummy = last = ListNode(None)\\n        for val in heapq.merge(*map(vals, lists)):\\n            last.next = last = ListNode(val)\\n        return dummy.next\\n\\n---\\n\\nSolution 2\\n-\\n\\nBuilding the new list with the **nodes** from the old ones.\\n\\n    def mergeKLists(self, lists):\\n        def gen(node):\\n            while node:\\n                yield node.val, node\\n                node = node.next\\n        dummy = last = ListNode(None)\\n        for _, last.next in heapq.merge(*map(gen, lists)):\\n            last = last.next\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 3288425,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int>v;\\n        for(int i=0;i<lists.size();i++){\\n            while(lists[i]){\\n                v.push_back(lists[i]->val);\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        sort(rbegin(v),rend(v));\\n        ListNode* ans=nullptr;\\n        for(int i=0;i<v.size();i++){\\n            ans=new ListNode(v[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int>v;\\n        for(int i=0;i<lists.size();i++){\\n            while(lists[i]){\\n                v.push_back(lists[i]->val);\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        sort(rbegin(v),rend(v));\\n        ListNode* ans=nullptr;\\n        for(int i=0;i<v.size();i++){\\n            ans=new ListNode(v[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287717,
                "title": "merge-k-sorted-linked-lists-in-o-n-log-k-time-with-priority-queue-full-explanation",
                "content": "# Intuition\\nWe can use a min heap to store the head node of each linked list, and repeatedly extract the minimum node from the heap and append it to the output list until the heap is empty. At each step, we can add the next node in the corresponding linked list to the heap.\\n\\n# Approach\\nIn the code snippet below, we define a lambda function cmp to compare two ListNode pointers based on their val field. We create a priority_queue pq with the comparison function cmp. We then iterate over each list in lists and add its head node to pq if it\\'s not null.\\n\\nWe then create a dummy node dummy and a pointer curr to it. We repeatedly extract the minimum node from pq, append it to curr, and set curr to point to the appended node. If the extracted node has a non-null next, we add it to pq.\\n\\nFinally, we return the next pointer of dummy, which points to the first node of the merged list.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is O(N log k), where N is the total number of nodes in all the linked lists, and k is the number of linked lists.\\n\\n- Space complexity:\\nThe space complexity of this code is O(k), as we are storing at most k nodes in the min-heap at any given time. \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };\\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);\\n        \\n        for (auto list : lists) {\\n            if (list) pq.push(list);\\n        }\\n        \\n        ListNode dummy(0);\\n        ListNode* curr = &dummy;\\n        while (!pq.empty()) {\\n            auto node = pq.top();\\n            pq.pop();\\n            \\n            curr->next = node;\\n            curr = curr->next;\\n            \\n            if (node->next) pq.push(node->next);\\n        }\\n        \\n        return dummy.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };\\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);\\n        \\n        for (auto list : lists) {\\n            if (list) pq.push(list);\\n        }\\n        \\n        ListNode dummy(0);\\n        ListNode* curr = &dummy;\\n        while (!pq.empty()) {\\n            auto node = pq.top();\\n            pq.pop();\\n            \\n            curr->next = node;\\n            curr = curr->next;\\n            \\n            if (node->next) pq.push(node->next);\\n        }\\n        \\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459834,
                "title": "rust-0-ms-binaryheap-functions-for-debugging-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/779533796/) employs *BINARY (MIN) HEAP* data structure. It demonstrated **0 ms runtime (100%)** and used **3.1 MB memory (96.02%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n\\n```\\n// 1. to implement a PRIORITY QUEUE, the BINARY HEAP data structure is chosen\\nuse std::collections::BinaryHeap;\\n\\n// 2. entire Box<ListNode> is stored in the BINARY HEAP, not just ListNode.val;\\n//    this requires implementation of Ord and PartialOrd for ListNode\\nuse std::cmp::Ordering;\\n\\nimpl PartialOrd<ListNode> for ListNode \\n{\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> \\n    {\\n        other.val.partial_cmp(&self.val)     // - for MIN HEAP\\n        //self.val.partial_cmp(&other.val)   // - for MAX HEAP\\n    }\\n}\\n\\nimpl Ord for ListNode \\n{\\n    fn cmp(&self, other: &Self) -> Ordering \\n    {\\n        other.val.cmp(&self.val)             // - for MIN HEAP\\n        //self.val.cmp(&other.val)           // - for MAX HEAP\\n    }\\n}\\n\\nimpl Solution\\n{\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> \\n    {\\n        // 3. maximum heap capacity is known in advance\\n        let mut heap: BinaryHeap<Box<ListNode>> = BinaryHeap::with_capacity(lists.len());\\n\\n        // 4. initialize heap with first nodes from each ListNode\\n        for list in lists\\n        {\\n            match list\\n            {\\n                Some (node) => heap.push(node),\\n                None => {}\\n            }\\n        }\\n            \\n        // 5. initialize dummy node to reduce computations\\n        let mut dummy_node = Box::new(ListNode::new(0));\\n\\n        // 6. to further build a list of nodes, we keep track of the current node\\n        let mut curr_node = &mut dummy_node;\\n    \\n        // 7. interaction with BINARY HEAP\\n        while let Some(node) = heap.pop() \\n        {\\n            // 8. get min value from the heap\\n            let mut new_node = Box::new(ListNode::new(node.val));\\n            curr_node.next = Some(new_node);\\n            curr_node = curr_node.next.as_mut().unwrap();\\n\\n            // 9. push min.next value to heap\\n            if node.next.is_some()\\n            {\\n                heap.push(node.next.unwrap());\\n            }\\n        }\\n\\n        return dummy_node.next;\\n    }\\n}\\n```\\n\\nUseful debugging functions are also supplied.\\n```\\nfn listnode_from_vec(vec: &Vec<i32>) -> Option<Box<ListNode>>\\n{\\n    let mut dummy_node = ListNode::new(0);\\n    let mut curr = &mut dummy_node;\\n    \\n    for &v in vec\\n    {\\n        let node = ListNode::new(v);\\n        curr.next = Some(Box::new(node));\\n        curr = curr.next.as_mut().unwrap();\\n    }\\n\\n    return dummy_node.next;\\n}\\n\\nfn listnode_to_vec(listnode: &Option<Box<ListNode>>) -> Vec<i32>\\n{\\n    let mut vec: Vec<i32> = Vec::new();\\n    let mut curr = listnode;\\n    loop \\n    {\\n        match curr\\n        {\\n            Some(ref node) => vec.push(node.val),\\n            None => break\\n        }\\n        curr = &(curr.as_ref().unwrap().next);\\n    }\\n    return vec;\\n}\\n\\nfn print_listnode(listnode: &Option<Box<ListNode>>)\\n{\\n    let mut curr = listnode;\\n    loop \\n    {\\n        match curr\\n        {\\n            Some(ref node) => print!(\"{} \", node.val),\\n            None => break\\n        }\\n        curr = &(curr.as_ref().unwrap().next);\\n    }\\n    println!(\"\\\\n\");\\n}\\n```\\nUsage example:\\n```\\nfn main() \\n{\\n    let vec_1: Vec<i32> = Vec::from([1,2,6]);\\n    let vec_2: Vec<i32> = Vec::from([2,4]);\\n    let vec_3: Vec<i32> = Vec::from([-10,5,20]);\\n\\n    let l1: Option<Box<ListNode>> = listnode_from_vec(&vec_1);\\n    let l2: Option<Box<ListNode>> = listnode_from_vec(&vec_2);\\n    let l3: Option<Box<ListNode>> = listnode_from_vec(&vec_3);\\n\\n    let mut lists: Vec<Option<Box<ListNode>>> = Vec::new();\\n    lists.push(l1);\\n    lists.push(l2);\\n    lists.push(l3);\\n\\n    let sorted = Solution::merge_k_lists(lists);\\n    print_listnode(&sorted);\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// 1. to implement a PRIORITY QUEUE, the BINARY HEAP data structure is chosen\\nuse std::collections::BinaryHeap;\\n\\n// 2. entire Box<ListNode> is stored in the BINARY HEAP, not just ListNode.val;\\n//    this requires implementation of Ord and PartialOrd for ListNode\\nuse std::cmp::Ordering;\\n\\nimpl PartialOrd<ListNode> for ListNode \\n{\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> \\n    {\\n        other.val.partial_cmp(&self.val)     // - for MIN HEAP\\n        //self.val.partial_cmp(&other.val)   // - for MAX HEAP\\n    }\\n}\\n\\nimpl Ord for ListNode \\n{\\n    fn cmp(&self, other: &Self) -> Ordering \\n    {\\n        other.val.cmp(&self.val)             // - for MIN HEAP\\n        //self.val.cmp(&other.val)           // - for MAX HEAP\\n    }\\n}\\n\\nimpl Solution\\n{\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> \\n    {\\n        // 3. maximum heap capacity is known in advance\\n        let mut heap: BinaryHeap<Box<ListNode>> = BinaryHeap::with_capacity(lists.len());\\n\\n        // 4. initialize heap with first nodes from each ListNode\\n        for list in lists\\n        {\\n            match list\\n            {\\n                Some (node) => heap.push(node),\\n                None => {}\\n            }\\n        }\\n            \\n        // 5. initialize dummy node to reduce computations\\n        let mut dummy_node = Box::new(ListNode::new(0));\\n\\n        // 6. to further build a list of nodes, we keep track of the current node\\n        let mut curr_node = &mut dummy_node;\\n    \\n        // 7. interaction with BINARY HEAP\\n        while let Some(node) = heap.pop() \\n        {\\n            // 8. get min value from the heap\\n            let mut new_node = Box::new(ListNode::new(node.val));\\n            curr_node.next = Some(new_node);\\n            curr_node = curr_node.next.as_mut().unwrap();\\n\\n            // 9. push min.next value to heap\\n            if node.next.is_some()\\n            {\\n                heap.push(node.next.unwrap());\\n            }\\n        }\\n\\n        return dummy_node.next;\\n    }\\n}\\n```\n```\\nfn listnode_from_vec(vec: &Vec<i32>) -> Option<Box<ListNode>>\\n{\\n    let mut dummy_node = ListNode::new(0);\\n    let mut curr = &mut dummy_node;\\n    \\n    for &v in vec\\n    {\\n        let node = ListNode::new(v);\\n        curr.next = Some(Box::new(node));\\n        curr = curr.next.as_mut().unwrap();\\n    }\\n\\n    return dummy_node.next;\\n}\\n\\nfn listnode_to_vec(listnode: &Option<Box<ListNode>>) -> Vec<i32>\\n{\\n    let mut vec: Vec<i32> = Vec::new();\\n    let mut curr = listnode;\\n    loop \\n    {\\n        match curr\\n        {\\n            Some(ref node) => vec.push(node.val),\\n            None => break\\n        }\\n        curr = &(curr.as_ref().unwrap().next);\\n    }\\n    return vec;\\n}\\n\\nfn print_listnode(listnode: &Option<Box<ListNode>>)\\n{\\n    let mut curr = listnode;\\n    loop \\n    {\\n        match curr\\n        {\\n            Some(ref node) => print!(\"{} \", node.val),\\n            None => break\\n        }\\n        curr = &(curr.as_ref().unwrap().next);\\n    }\\n    println!(\"\\\\n\");\\n}\\n```\n```\\nfn main() \\n{\\n    let vec_1: Vec<i32> = Vec::from([1,2,6]);\\n    let vec_2: Vec<i32> = Vec::from([2,4]);\\n    let vec_3: Vec<i32> = Vec::from([-10,5,20]);\\n\\n    let l1: Option<Box<ListNode>> = listnode_from_vec(&vec_1);\\n    let l2: Option<Box<ListNode>> = listnode_from_vec(&vec_2);\\n    let l3: Option<Box<ListNode>> = listnode_from_vec(&vec_3);\\n\\n    let mut lists: Vec<Option<Box<ListNode>>> = Vec::new();\\n    lists.push(l1);\\n    lists.push(l2);\\n    lists.push(l3);\\n\\n    let sorted = Solution::merge_k_lists(lists);\\n    print_listnode(&sorted);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087622,
                "title": "short-and-simple-pq-solution-java",
                "content": "### Logic:\\nTo merge two lists A and B, we simply need to compare A.val and B.val and iterate accordingly. What about three lists? Four? We find ourselves having k different conditions to allow for the appropriate comparissons of k lists. No matter how you do this, naively comparing nodes one at a time for k lists takes O(Nk) time. With two lists, this is fine. But there\\'s a simple way we can make these comparissons easier. \\n\\nWouldn\\'t it be nice if we had easy access to the smallest node at any given point? We can skip doing all these k comparissons if this was the case. Well turns out there is a way to simulate this! We can use a priority queue. \\n___\\n### Why a Priority Queue?:\\nPriority queues (or min-heaps) work by bubbling up the smallest value to the top of the queue. This allows us to access the smallest value in constant time. The only con is that insertion, or the act of bubbling up, takes logarithmic time. \\n\\nThis is useful for us since we can get the smallest ListNode value (and the list corresponding to that value) in just `O(logk)`. Do this N times and you have your resultant list! The first step is to chuck all the non-null heads from the input to our priority queue and work from there; polling the current ListNode from the top of the priority queue and passing in the next ListNode of that corresponding list.\\n___\\n### Code:\\nFor the priority queue to work, we must modify our priority queue to be of type ListNode and compare for type ListNode.val. \\nIf you have any questions, suggestions or improvements, feel free to let me know!\\n```java\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        int n = lists.length;\\n        if (lists == null || n == 0) return null;\\n        \\n        // Ensure our pq takes in ListNodes and compares their values.\\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((ListNode a, ListNode b) -> a.val - b.val);\\n        \\n        // Add the head of all non-null lists to the pq to begin.\\n        for (ListNode list: lists)\\n            if (list != null) pq.add(list);\\n        \\n        // Dummy node pointer to help add to our output list.\\n        ListNode ptr = new ListNode(-1);\\n        ListNode head = ptr;\\n        \\n        // 1) Get the smallest node from the PriorityQueue.\\n        // 2) Add it to our output list.\\n        // 3) Add the next node of the current list to the pq if it\\'s not null\\n        // 4) Repeat\\n        while (!pq.isEmpty()) {\\n            ListNode curr = pq.poll();\\n            ptr.next = new ListNode(curr.val);\\n            ptr = ptr.next;\\n            if (curr.next != null) pq.add(curr.next);\\n        }\\n        \\n        return head.next;\\n    }\\n}\\n```\\n**Time Complexity:** `O(nlogk)` where `n` is the total number of nodes and `k` is the number of lists.\\n**Space Complexity:** `O(n)` to create the new list (or `O(1)` extra space).",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        int n = lists.length;\\n        if (lists == null || n == 0) return null;\\n        \\n        // Ensure our pq takes in ListNodes and compares their values.\\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((ListNode a, ListNode b) -> a.val - b.val);\\n        \\n        // Add the head of all non-null lists to the pq to begin.\\n        for (ListNode list: lists)\\n            if (list != null) pq.add(list);\\n        \\n        // Dummy node pointer to help add to our output list.\\n        ListNode ptr = new ListNode(-1);\\n        ListNode head = ptr;\\n        \\n        // 1) Get the smallest node from the PriorityQueue.\\n        // 2) Add it to our output list.\\n        // 3) Add the next node of the current list to the pq if it\\'s not null\\n        // 4) Repeat\\n        while (!pq.isEmpty()) {\\n            ListNode curr = pq.poll();\\n            ptr.next = new ListNode(curr.val);\\n            ptr = ptr.next;\\n            if (curr.next != null) pq.add(curr.next);\\n        }\\n        \\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606044,
                "title": "python-divide-and-conquer-based-on-merge-sort-easy-to-understand-solution",
                "content": "Below is a divide and conquer soution based on Merge sort.\\n\\nIn Merge sort we basically divide a list into two smaller lists. And then we divide the smaller lists further. This division of list stops when we have just one element left in the list. We stop at that time because we know single element in a list will always be sorted. Now coming to this question, each of the linked lists are sorted. So if we consider every linked list as a single entity, this becomes similar to our general merge sort. \\ne.g - \\nGiven LLs - \\n [\\t[1, 4],\\t[2, 3, 4], [5] ]\\n\\nAssume it as:\\n[\\tA,\\tB,\\tC ]  \\n\\nWe have to apply merge sort on this. So this is easy now, right? :)\\n\\nTime complexity - nklogk assuming n elements in all the k lists. or Nlogk where N is total numbers of elements in result List\\n\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        length = len(lists)\\n        \\n\\t\\t# The list is empty. \\n        if not length:\\n            return None\\n        # There is only one Linked list - base condition. return the Linked list as is, because this is sorted\\n        if length == 1:\\n            return lists[0]\\n        \\n        mid = length//2\\n\\t\\t# get the left sorted half and right sorted half\\n        left = self.mergeKLists(lists[0:mid])\\n        right = self.mergeKLists(lists[mid:])\\n        \\n        return self.mergeTwolists(left,right)\\n        \\n    # Merge two lists is another Leetcode question.  Visit - https://leetcode.com/problems/merge-two-sorted-lists/\\n    def mergeTwolists(self, l1, l2):\\n        tail = head = ListNode(0)        \\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n                \\n            tail = tail.next\\n            \\n        tail.next = l1 or l2\\n            \\n        return head.next\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        length = len(lists)\\n        \\n\\t\\t# The list is empty. \\n        if not length:\\n            return None\\n        # There is only one Linked list - base condition. return the Linked list as is, because this is sorted\\n        if length == 1:\\n            return lists[0]\\n        \\n        mid = length//2\\n\\t\\t# get the left sorted half and right sorted half\\n        left = self.mergeKLists(lists[0:mid])\\n        right = self.mergeKLists(lists[mid:])\\n        \\n        return self.mergeTwolists(left,right)\\n        \\n    # Merge two lists is another Leetcode question.  Visit - https://leetcode.com/problems/merge-two-sorted-lists/\\n    def mergeTwolists(self, l1, l2):\\n        tail = head = ListNode(0)        \\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n                \\n            tail = tail.next\\n            \\n        tail.next = l1 or l2\\n            \\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527470,
                "title": "simple-c-solution-with-explanation",
                "content": "## Method 1 (Brute Force)\\nA simple way of doing this is to make a big list by iterating over the vector and then sorting it using any of the sorting techniques lijke merge sort or quick sort. \\n**TIme Complexity** : O(n * k) [for iterating over vector of size n and average linked list size k) + O(p * log p) [sorting the big list of size p = n * k)\\n\\n## Method 2 (Optimized)\\nAnother way of doing this is to make use of the fact that linked lists are k sorted. We\\'ll use a min priority queue. Since we know that linked list is k sorted , we first push head of all the lists in the priority queue. The minimum of these will be the first node of the list. After that we move this min node to its next (if exists) and push that next node again to the priority queue. This way we keep adding nodes to the resultant list and the moment priority queue becomes empty, we get our resulting list.\\nThe code for same is as follows :\\n\\n```\\n#define pi pair<int,ListNode *>\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int n = lists.size();\\n\\t\\t//intitalizing our resultant list\\n        ListNode *newHead = new ListNode(0);\\n        ListNode *tail = newHead;\\n        \\n\\t\\t//min ority queue which stores {node->val , node} \\n\\t\\t// that it isn arranged by node\\'s val\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t\\t//pushing all non-null nodes into the priority queue\\n            if(lists[i]) pq.push({lists[i]->val , lists[i]});\\n        }\\n        \\n        \\n        while(!pq.empty())\\n        {\\n\\t\\t\\t//here we pop out the current min node present in pq\\n            ListNode *node = pq.top().second;\\n            pq.pop();\\n\\t\\t\\t//add this min node to resultant list\\n            tail->next = node;\\n            tail = tail->next;\\n            \\n\\t\\t\\t//if next of this node exist push it in pq\\n            if(node->next) pq.push({node->next->val,node->next});\\n        }\\n        \\n        //when pq becomes empty we get our required list.\\n        return newHead->next;\\n    }\\n```\\n\\n**Time Complexity :** O(k* log k) [for pushing elements in pq]  + O(N * log k) [logK for popping min node and pushing it\\'s next back, and we are doing this N times]\\n\\n**Space Complexity :** O(k) [at any momemnt pq will have max k elements]\\n",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pi pair<int,ListNode *>\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int n = lists.size();\\n\\t\\t//intitalizing our resultant list\\n        ListNode *newHead = new ListNode(0);\\n        ListNode *tail = newHead;\\n        \\n\\t\\t//min ority queue which stores {node->val , node} \\n\\t\\t// that it isn arranged by node\\'s val\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t\\t//pushing all non-null nodes into the priority queue\\n            if(lists[i]) pq.push({lists[i]->val , lists[i]});\\n        }\\n        \\n        \\n        while(!pq.empty())\\n        {\\n\\t\\t\\t//here we pop out the current min node present in pq\\n            ListNode *node = pq.top().second;\\n            pq.pop();\\n\\t\\t\\t//add this min node to resultant list\\n            tail->next = node;\\n            tail = tail->next;\\n            \\n\\t\\t\\t//if next of this node exist push it in pq\\n            if(node->next) pq.push({node->next->val,node->next});\\n        }\\n        \\n        //when pq becomes empty we get our required list.\\n        return newHead->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1237414,
                "title": "c-merge-sort-like-solution-intuition",
                "content": "## Intuition\\nMerging two sorted lists is easy, so if we could somehow divide this problem into a similar structure, we could have a good solution. This is what merge sort does, in the merge step, we merge k sorted lists.\\n\\nWe pair up the k lists into k/2 pairs, with 2n/k elements on average, and then merge the pairs. Then we pass the resulting list of linked lists to a recursive call of the mergekSortedLists  function, and so on, until we reach just two linked lists, or one linked list. Then we return either the merged list in case of two lists, or just the remaining list, in  case of single list left.\\n\\nIf you are having trouble merging two sorted linked lists, here is the algorithm for it:\\n```\\nAlgorithm merge2Lists(list1, list2):\\n1. while both list1 and list2 point to a non null node:\\n\\t2. if list1.val <= list2.val add list1.val to the resulting list, and advance the list1 pointer\\n\\t3. else if list1.val > list2.val add list2.val to the resulting list and advance the list2 pointer\\n4. for any elements remaining in either of the lists:\\n\\t5. add the element to the tail of the resulting list and advance the pointer.\\n6. return the head of the result list.\\n```\\n\\n<br>\\n\\n## Code \\n```\\nListNode * merge2Lists(ListNode *l1, ListNode *l2) {\\n\\tif(!l1) return l2;\\n\\telse if(!l2) return l1;\\n\\tListNode *ptr1 = l1, *ptr2 = l2;\\n\\tListNode *l3 = new ListNode(-1);\\n\\tListNode *ptr3 = l3;\\n\\twhile(ptr1 && ptr2) {\\n\\t\\tif(ptr1->val <= ptr2->val) {\\n\\t\\t\\tptr3->next = new ListNode(ptr1->val);\\n\\t\\t\\tptr3 = ptr3->next;\\n\\t\\t\\tptr1 = ptr1->next;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tptr3->next = new ListNode(ptr2->val);\\n\\t\\t\\tptr3 = ptr3->next;\\n\\t\\t\\tptr2 = ptr2->next;\\n\\t\\t}\\n\\t}\\n\\twhile(ptr1) {\\n\\t\\tptr3->next = new ListNode(ptr1->val);\\n\\t\\tptr3 = ptr3->next;\\n\\t\\tptr1 = ptr1->next;\\n\\t}\\n\\twhile(ptr2) {\\n\\t\\tptr3->next = new ListNode(ptr2->val);\\n\\t\\tptr3 = ptr3->next;\\n\\t\\tptr2 = ptr2->next;\\n\\t}\\n\\tptr3 = l3->next;\\n\\tdelete l3;\\n\\treturn ptr3;\\n}\\nListNode* mergeKLists(vector<ListNode*>& lists) {\\n\\tint k = lists.size();\\n\\tif(k == 0) return nullptr;\\n\\telse if(k == 1) return lists[0];\\n\\telse if(k == 2) {\\n\\t\\treturn merge2Lists(lists[0], lists[1]);\\n\\t}\\n\\tvector<ListNode *> mergedLists;\\n\\tfor(int i = 0; i<k; i+=2) {\\n\\t\\tif(i<k-1) {\\n\\t\\t\\t//at least two left\\n\\t\\t\\tmergedLists.push_back(merge2Lists(lists[i], lists[i+1]));\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tmergedLists.push_back(lists[i]);\\n\\t\\t}\\n\\t}\\n\\treturn mergeKLists(mergedLists);\\n}\\n```\\n\\n<br>\\n\\n## Complexity\\n**Time: O(nlogk)** where n is the total number of elements, and k is the number of lists initially given\\n**Space: O(nlogk)** since the merging requires an extra space of O(n) for the result list and there are O(logk) calls to it.\\n<br>\\n\\n**Upvote** if you learned something from this post, and feel free to ask any doubts, or suggest any corrections/improvements in the comments.\\n",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\nAlgorithm merge2Lists(list1, list2):\\n1. while both list1 and list2 point to a non null node:\\n\\t2. if list1.val <= list2.val add list1.val to the resulting list, and advance the list1 pointer\\n\\t3. else if list1.val > list2.val add list2.val to the resulting list and advance the list2 pointer\\n4. for any elements remaining in either of the lists:\\n\\t5. add the element to the tail of the resulting list and advance the pointer.\\n6. return the head of the result list.\\n```\n```\\nListNode * merge2Lists(ListNode *l1, ListNode *l2) {\\n\\tif(!l1) return l2;\\n\\telse if(!l2) return l1;\\n\\tListNode *ptr1 = l1, *ptr2 = l2;\\n\\tListNode *l3 = new ListNode(-1);\\n\\tListNode *ptr3 = l3;\\n\\twhile(ptr1 && ptr2) {\\n\\t\\tif(ptr1->val <= ptr2->val) {\\n\\t\\t\\tptr3->next = new ListNode(ptr1->val);\\n\\t\\t\\tptr3 = ptr3->next;\\n\\t\\t\\tptr1 = ptr1->next;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tptr3->next = new ListNode(ptr2->val);\\n\\t\\t\\tptr3 = ptr3->next;\\n\\t\\t\\tptr2 = ptr2->next;\\n\\t\\t}\\n\\t}\\n\\twhile(ptr1) {\\n\\t\\tptr3->next = new ListNode(ptr1->val);\\n\\t\\tptr3 = ptr3->next;\\n\\t\\tptr1 = ptr1->next;\\n\\t}\\n\\twhile(ptr2) {\\n\\t\\tptr3->next = new ListNode(ptr2->val);\\n\\t\\tptr3 = ptr3->next;\\n\\t\\tptr2 = ptr2->next;\\n\\t}\\n\\tptr3 = l3->next;\\n\\tdelete l3;\\n\\treturn ptr3;\\n}\\nListNode* mergeKLists(vector<ListNode*>& lists) {\\n\\tint k = lists.size();\\n\\tif(k == 0) return nullptr;\\n\\telse if(k == 1) return lists[0];\\n\\telse if(k == 2) {\\n\\t\\treturn merge2Lists(lists[0], lists[1]);\\n\\t}\\n\\tvector<ListNode *> mergedLists;\\n\\tfor(int i = 0; i<k; i+=2) {\\n\\t\\tif(i<k-1) {\\n\\t\\t\\t//at least two left\\n\\t\\t\\tmergedLists.push_back(merge2Lists(lists[i], lists[i+1]));\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tmergedLists.push_back(lists[i]);\\n\\t\\t}\\n\\t}\\n\\treturn mergeKLists(mergedLists);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1034139,
                "title": "c-priority-queue-simple-and-easy-to-understand-solution",
                "content": "```\\nclass comparator{\\n    public:\\n    bool operator()(ListNode *x,ListNode *y){\\n        return (x->val>y->val);\\n    }\\n};\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,comparator> pq;\\n        \\n        for(int i=0;i<lists.size();i++){\\n            if(lists[i])\\n                pq.push(lists[i]);\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        ListNode *tail=dummy;\\n        \\n        while(!pq.empty()){\\n            ListNode *top=pq.top();\\n            pq.pop();\\n            tail->next=top;\\n            tail=tail->next;\\n            if(top->next)\\n                pq.push(top->next);\\n        }   \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass comparator{\\n    public:\\n    bool operator()(ListNode *x,ListNode *y){\\n        return (x->val>y->val);\\n    }\\n};\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,comparator> pq;\\n        \\n        for(int i=0;i<lists.size();i++){\\n            if(lists[i])\\n                pq.push(lists[i]);\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        ListNode *tail=dummy;\\n        \\n        while(!pq.empty()){\\n            ListNode *top=pq.top();\\n            pq.pop();\\n            tail->next=top;\\n            tail=tail->next;\\n            if(top->next)\\n                pq.push(top->next);\\n        }   \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522375,
                "title": "c-using-priority-queue",
                "content": "By using priority queue, time complexity is `O(n log k)`, additional space complexity is `O(k)`, where `n` is the total number of nodes, `k` is the number of linked lists.\\n```c++\\n\\tListNode* mergeKLists(vector<ListNode*>& lists) {\\n        // min priority queue\\n        auto cmp = [](ListNode* a, ListNode* b){return a->val > b->val;};\\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> q(cmp);\\n        \\n        for(int i = 0; i < lists.size(); i++)\\n            if(lists[i] != nullptr) \\n                q.push(lists[i]);\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* cursor = dummy;\\n        while(!q.empty()){\\n            ListNode* curr = q.top();\\n            q.pop();\\n            if(curr->next != nullptr) q.push(curr->next);\\n            cursor->next = curr;\\n            cursor = curr;\\n        }\\n        return dummy->next;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```c++\\n\\tListNode* mergeKLists(vector<ListNode*>& lists) {\\n        // min priority queue\\n        auto cmp = [](ListNode* a, ListNode* b){return a->val > b->val;};\\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> q(cmp);\\n        \\n        for(int i = 0; i < lists.size(); i++)\\n            if(lists[i] != nullptr) \\n                q.push(lists[i]);\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* cursor = dummy;\\n        while(!q.empty()){\\n            ListNode* curr = q.top();\\n            q.pop();\\n            if(curr->next != nullptr) q.push(curr->next);\\n            cursor->next = curr;\\n            cursor = curr;\\n        }\\n        return dummy->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468082,
                "title": "test-cases",
                "content": "Make these work before you hit `submit`:\\n\\n```\\n[[1,4,5,9],[1,2,3,4,6]]\\n[[1,4,5],[1,3,4],[2,6]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[]]\\n[[1,4,5],[],[1,3,4],[],[2,6],[],[1,2,3,4,6],[],[-88,-53,22,99,1025],[],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[]]\\n[[],[],[],[],[],[],[1,4,5],[],[],[1,3,4],[],[],[2,6],[],[],[1,2,3,4,6],[],[],[-88,-53,22,99,1025],[],[],[1,3,4],[],[],[-33,-17,-9,-3,18,25,39,44,654],[],[],[1,5,567],[],[],[]]\\n[[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567]]\\n[[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567]]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n[[1,4,5,9],[1,2,3,4,6]]\\n[[1,4,5],[1,3,4],[2,6]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[]]\\n[[1,4,5],[],[1,3,4],[],[2,6],[],[1,2,3,4,6],[],[-88,-53,22,99,1025],[],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[]]\\n[[],[],[],[],[],[],[1,4,5],[],[],[1,3,4],[],[],[2,6],[],[],[1,2,3,4,6],[],[],[-88,-53,22,99,1025],[],[],[1,3,4],[],[],[-33,-17,-9,-3,18,25,39,44,654],[],[],[1,5,567],[],[],[]]\\n[[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567]]\\n[[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286856,
                "title": "java-solution-8ms-runtime-beginner-friendly-sorting",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have followed the basic approach to just traverse the array `lists` and store all elements in an temporary array `l1`.\\nNow i will just sort the array and store in resultant ListNode `ans`.\\n# Complexity\\n- Time complexity: O(MN Log MN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`M` is the length of `lists` array and `N` is the length of maximum  `linkedlist`. \\n- Space complexity: O(MN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince we store all the elements in an additional array. Maximum number of elements will be `M*N`. \\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n    if(lists.length == 0) return null;\\n    List<Integer> l1 = new ArrayList<>();\\n      for(ListNode arr : lists){\\n          while(arr != null){\\n              l1.add(arr.val);\\n              arr = arr.next;\\n          }\\n      }\\n      Collections.sort(l1); \\n      \\n      ListNode ans = null;\\n      ListNode temp = null;\\n      for (Integer i : l1){\\n          if(temp == null){\\n              temp = new ListNode(i);\\n              ans = temp;\\n          }\\n          else{\\n              temp.next = new ListNode(i);\\n              temp = temp.next;\\n          }\\n      }\\n      return ans;\\n    }\\n}\\n```\\n\\nIf any query or suggestions for better approach, Please do comment !!\\n\\n**PLEASE DO UPVOTE ME !!**\\n\\nThank You",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n    if(lists.length == 0) return null;\\n    List<Integer> l1 = new ArrayList<>();\\n      for(ListNode arr : lists){\\n          while(arr != null){\\n              l1.add(arr.val);\\n              arr = arr.next;\\n          }\\n      }\\n      Collections.sort(l1); \\n      \\n      ListNode ans = null;\\n      ListNode temp = null;\\n      for (Integer i : l1){\\n          if(temp == null){\\n              temp = new ListNode(i);\\n              ans = temp;\\n          }\\n          else{\\n              temp.next = new ListNode(i);\\n              temp = temp.next;\\n          }\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511383,
                "title": "java-solution-using-priorityqueue-with-explanation",
                "content": "# Approach : Priority Queue\\n**Algo : step-1 : Store the values of ListNode[] in PriorityQueue\\n               Step-2 : Make a new List Using these Values**\\n\\t\\t\\t\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(ListNode list : lists)\\n        {\\n            while(list!=null)\\n            {\\n                pq.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n        if(pq.size()==0) return null;\\n        else{\\n            ListNode temp = ans;\\n            while(pq.size()!=0){\\n            temp.next = new ListNode(pq.poll());\\n            temp = temp.next;\\n        }\\n    }\\n     return ans.next;   \\n  }\\n    \\n}\\n```\\t\\t\\t",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(ListNode list : lists)\\n        {\\n            while(list!=null)\\n            {\\n                pq.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n        if(pq.size()==0) return null;\\n        else{\\n            ListNode temp = ans;\\n            while(pq.size()!=0){\\n            temp.next = new ListNode(pq.poll());\\n            temp = temp.next;\\n        }\\n    }\\n     return ans.next;   \\n  }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330932,
                "title": "simple-java-solution-using-divide-and-conquer-technique-1ms",
                "content": "```\\nclass Solution {\\n    public static ListNode mergetwosll(ListNode l1, ListNode l2){\\n        if(l1 == null || l2 == null){\\n                return l1 != null ? l1 : l2;\\n            }\\n        \\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        ListNode c1 = l1;\\n        ListNode c2 = l2;\\n        \\n        while(c1 != null && c2 != null){\\n            if(c1.val < c2.val){\\n                prev.next = c1;\\n                c1 = c1.next;\\n            }\\n            else{\\n                prev.next = c2;\\n                c2 = c2.next;\\n            }\\n            prev = prev.next;\\n        }\\n        \\n        prev.next = c1 != null ? c1 : c2;\\n        \\n        return dummy.next;\\n        \\n    }\\n    \\n    public static ListNode mergeKListshelper(ListNode[] lists, int si, int ei){\\n        if(si == ei){\\n            return lists[si];\\n        }\\n        \\n        int mid = (si + ei) / 2;\\n        \\n        ListNode l1 = mergeKListshelper(lists, si, mid);\\n        ListNode l2 = mergeKListshelper(lists, mid + 1, ei);\\n        \\n        return mergetwosll(l1, l2);\\n        \\n    }\\n    \\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists.length == 0){\\n            return null;\\n        }\\n        \\n        return mergeKListshelper(lists, 0, lists.length - 1);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public static ListNode mergetwosll(ListNode l1, ListNode l2){\\n        if(l1 == null || l2 == null){\\n                return l1 != null ? l1 : l2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 908846,
                "title": "python-3-commented-o-n-log-k-faster-than-90-64",
                "content": "*Runtime: 96 ms, faster than 90.64% of Python3 online submissions for Merge k Sorted Lists.\\nMemory Usage: 18.8 MB, less than 12.86% of Python3 online submissions for Merge k Sorted Lists.*\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nimport heapq\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        # initialize heap\\n        heap = [(node.val, i) for i, node in enumerate(lists) if node]\\n        heapq.heapify(heap)\\n        # initialize nodelist to return\\n        head = ListNode()\\n        node = head\\n\\t\\t# merge\\n        while heap:\\n            # pop the min from heap\\n            value, i = heapq.heappop(heap)\\n            # add node to output chain\\n            node.next = ListNode(value)\\n            node = node.next\\n            # move the pointer to the next node if there is one\\n            if lists[i].next:\\n                lists[i] = lists[i].next\\n                new_value = lists[i].val\\n\\t\\t\\t\\t# push next element into the heap\\n                heapq.heappush(heap, (new_value, i))\\n        return head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nimport heapq\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        # initialize heap\\n        heap = [(node.val, i) for i, node in enumerate(lists) if node]\\n        heapq.heapify(heap)\\n        # initialize nodelist to return\\n        head = ListNode()\\n        node = head\\n\\t\\t# merge\\n        while heap:\\n            # pop the min from heap\\n            value, i = heapq.heappop(heap)\\n            # add node to output chain\\n            node.next = ListNode(value)\\n            node = node.next\\n            # move the pointer to the next node if there is one\\n            if lists[i].next:\\n                lists[i] = lists[i].next\\n                new_value = lists[i].val\\n\\t\\t\\t\\t# push next element into the heap\\n                heapq.heappush(heap, (new_value, i))\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858669,
                "title": "python-heap",
                "content": "```\\nfrom heapq import heappush, heappop\\n\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        h = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heappush(h, [lists[i].val, i])\\n                lists[i] = lists[i].next\\n        \\n        head = p = ListNode()\\n        while h:\\n            v, i = heappop(h)\\n            p.next = ListNode(v)\\n            p = p.next\\n            if lists[i]:\\n                heappush(h, [lists[i].val, i])\\n                lists[i] = lists[i].next\\n        \\n        return head.next",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        h = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heappush(h, [lists[i].val, i])\\n                lists[i] = lists[i].next\\n        \\n        head = p = ListNode()\\n        while h:\\n            v, i = heappop(h)\\n            p.next = ListNode(v)\\n            p = p.next\\n            if lists[i]:\\n                heappush(h, [lists[i].val, i])\\n                lists[i] = lists[i].next\\n        \\n        return head.next",
                "codeTag": "Java"
            },
            {
                "id": 800817,
                "title": "javascript-3-clean-solutions",
                "content": "# Solution 1: Append the minimum node at each round\\n```javascript\\nvar mergeKLists = function(lists) {\\n    const dummyHead = new ListNode();\\n    let curr = dummyHead;\\n    \\n    function findMin(arr) {\\n        let min = Infinity;\\n        \\n        for(let node of arr) {\\n            if(!node) continue;\\n            min = Math.min(min, node.val);\\n        }\\n        return min;\\n    }\\n    \\n    while(true) {\\n        const min = findMin(lists);\\n        if(min === Infinity) return dummyHead.next;\\n        \\n        for(let i = 0; i < lists.length; i++) {\\n            if(!lists[i] || lists[i].val > min) continue; \\n            curr.next = lists[i];\\n            curr = curr.next;\\n            lists[i] = lists[i].next;\\n        }\\n    }\\n};\\n```\\n\\n# Solution 2: Divide and conquer\\n```javascript\\nvar mergeKLists = function(lists) {\\n    if(!lists.length) return null;\\n  \\n    function merge(left, right) {\\n        if(!left) return right;\\n        if(!right) return left;\\n        \\n        if(left.val < right.val) {\\n            left.next = merge(left.next, right);\\n            return left;\\n        }\\n        right.next = merge(left, right.next);\\n        return right;\\n    }\\n    \\n    function recurse(start, end) {\\n        if(start === end) return lists[start];\\n        const mid = Math.floor((start+end)/2);\\n        const left = recurse(start, mid);\\n        const right = recurse(mid+1, end);\\n        return merge(left, right);\\n    }\\n    return recurse(0, lists.length-1)\\n};\\n```\\n# Solution 3: Merge 2 lists at a time\\n```javascript\\nvar mergeKLists = function(lists) {\\n    if(!lists.length) return null;\\n    \\n    function mergeTwoLists(a, b) {\\n        const dummyHead = new ListNode();\\n        let curA = a, curB = b, curD = dummyHead;\\n        \\n        while(curA && curB) {\\n            if(curA.val < curB.val) {\\n                curD.next = curA;\\n                curA = curA.next;\\n            } else {\\n                curD.next = curB;\\n                curB = curB.next;\\n            }\\n            curD = curD.next;\\n        }\\n        if(curA) curD.next = curA;\\n        if(curB) curD.next = curB;\\n        return dummyHead.next;\\n    }\\n    \\n    while(lists.length > 1) {\\n        const a = lists.shift();\\n        const b = lists.shift();\\n        const res = mergeTwoLists(a, b);\\n        lists.push(res);\\n    }\\n    return lists[0];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar mergeKLists = function(lists) {\\n    const dummyHead = new ListNode();\\n    let curr = dummyHead;\\n    \\n    function findMin(arr) {\\n        let min = Infinity;\\n        \\n        for(let node of arr) {\\n            if(!node) continue;\\n            min = Math.min(min, node.val);\\n        }\\n        return min;\\n    }\\n    \\n    while(true) {\\n        const min = findMin(lists);\\n        if(min === Infinity) return dummyHead.next;\\n        \\n        for(let i = 0; i < lists.length; i++) {\\n            if(!lists[i] || lists[i].val > min) continue; \\n            curr.next = lists[i];\\n            curr = curr.next;\\n            lists[i] = lists[i].next;\\n        }\\n    }\\n};\\n```\n```javascript\\nvar mergeKLists = function(lists) {\\n    if(!lists.length) return null;\\n  \\n    function merge(left, right) {\\n        if(!left) return right;\\n        if(!right) return left;\\n        \\n        if(left.val < right.val) {\\n            left.next = merge(left.next, right);\\n            return left;\\n        }\\n        right.next = merge(left, right.next);\\n        return right;\\n    }\\n    \\n    function recurse(start, end) {\\n        if(start === end) return lists[start];\\n        const mid = Math.floor((start+end)/2);\\n        const left = recurse(start, mid);\\n        const right = recurse(mid+1, end);\\n        return merge(left, right);\\n    }\\n    return recurse(0, lists.length-1)\\n};\\n```\n```javascript\\nvar mergeKLists = function(lists) {\\n    if(!lists.length) return null;\\n    \\n    function mergeTwoLists(a, b) {\\n        const dummyHead = new ListNode();\\n        let curA = a, curB = b, curD = dummyHead;\\n        \\n        while(curA && curB) {\\n            if(curA.val < curB.val) {\\n                curD.next = curA;\\n                curA = curA.next;\\n            } else {\\n                curD.next = curB;\\n                curB = curB.next;\\n            }\\n            curD = curD.next;\\n        }\\n        if(curA) curD.next = curA;\\n        if(curB) curD.next = curB;\\n        return dummyHead.next;\\n    }\\n    \\n    while(lists.length > 1) {\\n        const a = lists.shift();\\n        const b = lists.shift();\\n        const res = mergeTwoLists(a, b);\\n        lists.push(res);\\n    }\\n    return lists[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 622057,
                "title": "c-simple-approach-94-faster-explained",
                "content": "### For solving this problem we have followed following steps:-\\n* Traverse all the nodes one by one and and push down into a vector.\\n* Sort the vector.\\n* Store sorted node one by one into the new linked list.\\n\\n**IF YOU UNDERSTOOD THE SOLUTION, DON\\'T FORGET TO UPVOTE:)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int> v;\\n        if(lists.size()==0)\\n            return NULL;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            ListNode* temp=lists[i];\\n            while(temp!=NULL)\\n            {\\n                v.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(v.size()==0)    //if there exist no node within the lists then return null.//\\n            return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* start=new ListNode(v[0]);\\n        ListNode* temp1=start;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp1->next=new ListNode(v[i]);\\n            temp1=temp1->next;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int> v;\\n        if(lists.size()==0)\\n            return NULL;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            ListNode* temp=lists[i];\\n            while(temp!=NULL)\\n            {\\n                v.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(v.size()==0)    //if there exist no node within the lists then return null.//\\n            return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* start=new ListNode(v[0]);\\n        ListNode* temp1=start;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp1->next=new ListNode(v[i]);\\n            temp1=temp1->next;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434487,
                "title": "kotlin-simple-recursive-approach",
                "content": "It\\'s not the fastest approach but no extra memory is used, code it\\'s also a lot simpler to understand than other solutions.\\n```\\nfun mergeKLists(lists: Array<ListNode?>): ListNode? {\\n    return when {\\n        lists.size == 1 -> lists.first()\\n        lists.isEmpty() -> null\\n        else -> lists.reduce { l1, l2 -> merge2Lists(l1, l2) }\\n    }\\n}\\n\\nfun merge2Lists(l1: ListNode?, l2: ListNode?): ListNode? {\\n    if (l1 == null || l2 == null) {\\n        return l1 ?: l2\\n    }\\n\\n    return if (l1.`val` < l2.`val`) {\\n        l1.next = merge2Lists(l1.next, l2)\\n        l1\\n    } else {\\n        l2.next = merge2Lists(l1, l2.next)\\n        l2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nfun mergeKLists(lists: Array<ListNode?>): ListNode? {\\n    return when {\\n        lists.size == 1 -> lists.first()\\n        lists.isEmpty() -> null\\n        else -> lists.reduce { l1, l2 -> merge2Lists(l1, l2) }\\n    }\\n}\\n\\nfun merge2Lists(l1: ListNode?, l2: ListNode?): ListNode? {\\n    if (l1 == null || l2 == null) {\\n        return l1 ?: l2\\n    }\\n\\n    return if (l1.`val` < l2.`val`) {\\n        l1.next = merge2Lists(l1.next, l2)\\n        l1\\n    } else {\\n        l2.next = merge2Lists(l1, l2.next)\\n        l2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 388339,
                "title": "an-example-of-overwriting-listnode-to-make-customized-heap-happen",
                "content": "```\\ndef __lt__(self,other):\\n    return self.val<other.val\\nListNode.__lt__ = __lt__\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        h = []\\n        for n in lists:\\n            if n:\\n                heapq.heappush(h,n)\\n        dummy = head = ListNode(0)\\n        while h:\\n            cur = heapq.heappop(h)\\n            head.next = cur\\n            head = head.next\\n            if cur and cur.next:\\n                heapq.heappush(h,cur.next)\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\ndef __lt__(self,other):\\n    return self.val<other.val\\nListNode.__lt__ = __lt__\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        h = []\\n        for n in lists:\\n            if n:\\n                heapq.heappush(h,n)\\n        dummy = head = ListNode(0)\\n        while h:\\n            cur = heapq.heappop(h)\\n            head.next = cur\\n            head = head.next\\n            if cur and cur.next:\\n                heapq.heappush(h,cur.next)\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265225,
                "title": "easy-python-heapq-with-listnode-in-leetcode-environment",
                "content": "```\\nimport heapq     \\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        \\n        def my_lt(self, other):\\n            return self.val<other.val\\n        \\n        setattr(ListNode, \"__lt__\", my_lt)\\n        sortedList = curr = ListNode(\"Dummy\")\\n        h = []\\n        for head in lists:\\n            if head:\\n                h.append(head)\\n        heapq.heapify(h)\\n        while h:\\n            top = heapq.heappop(h)\\n            curr.next = top\\n            curr = top\\n            if top.next:\\n                heapq.heappush(h, top.next)\\n        return sortedList.next\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq     \\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        \\n        def my_lt(self, other):\\n            return self.val<other.val\\n        \\n        setattr(ListNode, \"__lt__\", my_lt)\\n        sortedList = curr = ListNode(\"Dummy\")\\n        h = []\\n        for head in lists:\\n            if head:\\n                h.append(head)\\n        heapq.heapify(h)\\n        while h:\\n            top = heapq.heappop(h)\\n            curr.next = top\\n            curr = top\\n            if top.next:\\n                heapq.heappush(h, top.next)\\n        return sortedList.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244840,
                "title": "c-4-solutions",
                "content": "The first idea is very simple: traverse the head of the k lists and pick up the one with the minimum value, append it to the merged list and update that head to the next node. Once every head of the k lists is `NULL`, we are done.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        int n = lists.size(), min = INT_MAX, idx = 0;\\n        while (true) {\\n            for (int i = 0; i < n; i++) {\\n                if (lists[i] && lists[i] -> val < min) {\\n                    min = lists[i] -> val;\\n                    idx = i;\\n                }\\n            }\\n            if (min == INT_MAX) {\\n                break;\\n            }\\n            cur -> next = lists[idx];\\n            cur = cur -> next;\\n            lists[idx] = lists[idx] -> next;\\n            min = INT_MAX;\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\\n\\nSince you are looking for the minimum among k values, you may also want to use a `priority_queue` (a heap) to optimize this process.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>> pq;\\n        for (ListNode* l : lists) {\\n            if (l) {\\n                pq.push({-l -> val, l});\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ListNode* node = pq.top().second;\\n            pq.pop();\\n            cur -> next = node;\\n            cur = cur -> next;\\n            node = node -> next;\\n            if (node) {\\n                pq.push({-node -> val, node});\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\\n\\nNote that `priority_queue` is by default a max heap and when it stores a `pair`, the `first` element will be used for comparison. So I negate the value of the node when I add the pair to `pq`.\\n\\nYou may also have your custom comparator for comparing `ListNode` directly.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        priority_queue<ListNode*, vector<ListNode*>, comapre> pq;\\n        for (ListNode* l : lists) {\\n            if (l) {\\n                pq.push(l);\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ListNode* node = pq.top();\\n            pq.pop();\\n            cur -> next = node;\\n            cur = cur -> next;\\n            if (node -> next) {\\n                pq.push(node -> next);\\n            }\\n        }\\n        return dummy -> next;\\n    }\\nprivate:\\n    struct comapre {\\n        bool operator()(ListNode* l, ListNode* r) {\\n            return l -> val > r -> val;\\n        }\\n    };\\n};\\n```\\n\\nIf you have solved [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/), you may apply that function to this problem by merging every two lists until only one is remaining.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return NULL;\\n        }\\n        for (int n = lists.size(); n > 1; n = (n + 1) / 2) {\\n            for (int i = 0; i < n / 2; i++) {\\n                lists[i] = mergeTwoLists(lists[i], lists[n - 1 - i]);\\n            }\\n        }\\n        return lists[0];\\n    }\\nprivate:\\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        while (l1 && l2) {\\n            if (l1 -> val < l2 -> val) {\\n                cur -> next = l1;\\n                l1 = l1 -> next;\\n            } else {\\n                cur -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n            cur = cur -> next;\\n        }\\n        cur -> next = l1 ? l1 : l2;\\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        int n = lists.size(), min = INT_MAX, idx = 0;\\n        while (true) {\\n            for (int i = 0; i < n; i++) {\\n                if (lists[i] && lists[i] -> val < min) {\\n                    min = lists[i] -> val;\\n                    idx = i;\\n                }\\n            }\\n            if (min == INT_MAX) {\\n                break;\\n            }\\n            cur -> next = lists[idx];\\n            cur = cur -> next;\\n            lists[idx] = lists[idx] -> next;\\n            min = INT_MAX;\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>> pq;\\n        for (ListNode* l : lists) {\\n            if (l) {\\n                pq.push({-l -> val, l});\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ListNode* node = pq.top().second;\\n            pq.pop();\\n            cur -> next = node;\\n            cur = cur -> next;\\n            node = node -> next;\\n            if (node) {\\n                pq.push({-node -> val, node});\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        priority_queue<ListNode*, vector<ListNode*>, comapre> pq;\\n        for (ListNode* l : lists) {\\n            if (l) {\\n                pq.push(l);\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ListNode* node = pq.top();\\n            pq.pop();\\n            cur -> next = node;\\n            cur = cur -> next;\\n            if (node -> next) {\\n                pq.push(node -> next);\\n            }\\n        }\\n        return dummy -> next;\\n    }\\nprivate:\\n    struct comapre {\\n        bool operator()(ListNode* l, ListNode* r) {\\n            return l -> val > r -> val;\\n        }\\n    };\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return NULL;\\n        }\\n        for (int n = lists.size(); n > 1; n = (n + 1) / 2) {\\n            for (int i = 0; i < n / 2; i++) {\\n                lists[i] = mergeTwoLists(lists[i], lists[n - 1 - i]);\\n            }\\n        }\\n        return lists[0];\\n    }\\nprivate:\\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        while (l1 && l2) {\\n            if (l1 -> val < l2 -> val) {\\n                cur -> next = l1;\\n                l1 = l1 -> next;\\n            } else {\\n                cur -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n            cur = cur -> next;\\n        }\\n        cur -> next = l1 ? l1 : l2;\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201087,
                "title": "8ms-in-c",
                "content": "```\\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {\\n    if (l1 == NULL) {\\n        return l2;\\n    }else if (l2 == NULL){\\n        return l1;\\n    }else if (l1->val < l2->val){\\n        l1->next = mergeTwoLists(l1->next, l2);\\n        return l1;\\n    }else{\\n        l2->next = mergeTwoLists(l1, l2->next);\\n        return l2;\\n    }\\n}\\n\\nstruct ListNode *mergeKLists(struct ListNode **lists, int listsSize) {\\n    if (listsSize == 0)  {\\n        return NULL;\\n    }\\n    if (listsSize == 1)   {\\n        return lists[0];\\n    }\\n    for (int i = 0,j = listsSize - 1; i < j; i++, j--) {\\n        lists[i] = mergeTwoLists(lists[i], lists[j]);\\n        listsSize--;\\n    }\\n    return mergeKLists(lists, listsSize);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {\\n    if (l1 == NULL) {\\n        return l2;\\n    }else if (l2 == NULL){\\n        return l1;\\n    }else if (l1->val < l2->val){\\n        l1->next = mergeTwoLists(l1->next, l2);\\n        return l1;\\n    }else{\\n        l2->next = mergeTwoLists(l1, l2->next);\\n        return l2;\\n    }\\n}\\n\\nstruct ListNode *mergeKLists(struct ListNode **lists, int listsSize) {\\n    if (listsSize == 0)  {\\n        return NULL;\\n    }\\n    if (listsSize == 1)   {\\n        return lists[0];\\n    }\\n    for (int i = 0,j = listsSize - 1; i < j; i++, j--) {\\n        lists[i] = mergeTwoLists(lists[i], lists[j]);\\n        listsSize--;\\n    }\\n    return mergeKLists(lists, listsSize);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181149,
                "title": "python-heapq-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nimport heapq\\n\\nclass MyListNode(ListNode):\\n    def __init__(self, val, nex):\\n        self.val = val\\n        self.next = nex\\n    \\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        heap = [MyListNode(l.val, l.next) for l in lists if l is not None]\\n        heapq.heapify(heap)\\n        \\n        res = ListNode(-1)\\n        cur = res\\n        while heap:\\n            smallest = heapq.heappop(heap)\\n            if smallest.next is not None:\\n                heapq.heappush(heap, MyListNode(smallest.next.val, smallest.next.next))\\n            cur.next= smallest\\n            cur = cur.next\\n        cur.next = None\\n        return res.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nimport heapq\\n\\nclass MyListNode(ListNode):\\n    def __init__(self, val, nex):\\n        self.val = val\\n        self.next = nex\\n    \\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        heap = [MyListNode(l.val, l.next) for l in lists if l is not None]\\n        heapq.heapify(heap)\\n        \\n        res = ListNode(-1)\\n        cur = res\\n        while heap:\\n            smallest = heapq.heappop(heap)\\n            if smallest.next is not None:\\n                heapq.heappush(heap, MyListNode(smallest.next.val, smallest.next.next))\\n            cur.next= smallest\\n            cur = cur.next\\n        cur.next = None\\n        return res.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10655,
                "title": "golang-concise-solutions-priority-queue-and-using-merge-two-lists-method",
                "content": "Two ways to solve,\\n1) Use priority queue by using `container/heap` \\n\\n```\\nfunc mergeKLists(lists []*ListNode) *ListNode {\\n\\tpq := make(PQ, 0)\\n\\tfor _, node := range lists {\\n\\t\\tif node != nil {\\n\\t\\t\\tpq = append(pq, node)\\n\\t\\t}\\n\\t}\\n\\n\\tif len(pq) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\theap.Init(&pq)\\n\\n\\thead := &ListNode{}\\n\\tdummyHead := head\\n\\n\\tfor len(pq) > 0 {\\n\\t\\tmin := heap.Pop(&pq)\\n\\t\\tminNode := min.(*ListNode)\\n\\t\\thead.Next = minNode\\n\\t\\thead = head.Next\\n\\n\\t\\tif minNode.Next != nil {\\n\\t\\t\\theap.Push(&pq, minNode.Next)\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.Next\\n}\\n\\ntype PQ []*ListNode\\n\\nfunc (pq PQ) Len() int {\\n\\treturn len(pq)\\n}\\n\\nfunc (pq PQ) Swap(a, b int) {\\n\\tpq[a], pq[b] = pq[b], pq[a]\\n}\\n\\nfunc (pq PQ) Less(a, b int) bool {\\n\\treturn pq[a].Val < pq[b].Val\\n}\\n\\nfunc (pq *PQ) Push(nodeInterface interface{}) {\\n\\tnode := nodeInterface.(*ListNode)\\n\\t*pq = append(*pq, node)\\n}\\n\\nfunc (pq *PQ) Pop() interface{} {\\n\\told := *pq\\n\\tlastNode := old[len(*pq)-1]\\n\\t*pq = old[:len(*pq)-1]\\n\\treturn lastNode\\n}\\n```\\n\\n2. Apply the same algorithm as \"merge two lists\" while taking 2 lists , until we can merge all.\\n\\n```\\nfunc mergeKLists(lists []*ListNode) *ListNode {\\n\\tlistsLen := len(lists)\\n\\tif listsLen == 0 {\\n\\t\\treturn nil\\n\\t} else if listsLen == 1 {\\n\\t\\treturn lists[0]\\n\\t}\\n\\n\\tfor len(lists) > 1 {\\n\\t\\tlist1, list2 := lists[0], lists[1]\\n\\t\\tmerged := mergeLists(list1, list2)\\n\\n\\t\\tlists = lists[2:]\\n\\t\\tlists = append(lists, merged)\\n\\t}\\n\\treturn lists[0]\\n}\\n\\nfunc mergeLists(listA, listB *ListNode) *ListNode {\\n\\tres := &ListNode{}\\n\\tdummyHead := res\\n\\tfor listA != nil || listB != nil {\\n\\t\\tif listA == nil {\\n\\t\\t\\tres.Next = listB\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif listB == nil {\\n\\t\\t\\tres.Next = listA\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif listA.Val < listB.Val {\\n\\t\\t\\tres.Next = listA\\n\\t\\t\\tres = res.Next\\n\\t\\t\\tlistA = listA.Next\\n\\t\\t} else {\\n\\t\\t\\tres.Next = listB\\n\\t\\t\\tres = res.Next\\n\\t\\t\\tlistB = listB.Next\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.Next\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeKLists(lists []*ListNode) *ListNode {\\n\\tpq := make(PQ, 0)\\n\\tfor _, node := range lists {\\n\\t\\tif node != nil {\\n\\t\\t\\tpq = append(pq, node)\\n\\t\\t}\\n\\t}\\n\\n\\tif len(pq) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\theap.Init(&pq)\\n\\n\\thead := &ListNode{}\\n\\tdummyHead := head\\n\\n\\tfor len(pq) > 0 {\\n\\t\\tmin := heap.Pop(&pq)\\n\\t\\tminNode := min.(*ListNode)\\n\\t\\thead.Next = minNode\\n\\t\\thead = head.Next\\n\\n\\t\\tif minNode.Next != nil {\\n\\t\\t\\theap.Push(&pq, minNode.Next)\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.Next\\n}\\n\\ntype PQ []*ListNode\\n\\nfunc (pq PQ) Len() int {\\n\\treturn len(pq)\\n}\\n\\nfunc (pq PQ) Swap(a, b int) {\\n\\tpq[a], pq[b] = pq[b], pq[a]\\n}\\n\\nfunc (pq PQ) Less(a, b int) bool {\\n\\treturn pq[a].Val < pq[b].Val\\n}\\n\\nfunc (pq *PQ) Push(nodeInterface interface{}) {\\n\\tnode := nodeInterface.(*ListNode)\\n\\t*pq = append(*pq, node)\\n}\\n\\nfunc (pq *PQ) Pop() interface{} {\\n\\told := *pq\\n\\tlastNode := old[len(*pq)-1]\\n\\t*pq = old[:len(*pq)-1]\\n\\treturn lastNode\\n}\\n```\n```\\nfunc mergeKLists(lists []*ListNode) *ListNode {\\n\\tlistsLen := len(lists)\\n\\tif listsLen == 0 {\\n\\t\\treturn nil\\n\\t} else if listsLen == 1 {\\n\\t\\treturn lists[0]\\n\\t}\\n\\n\\tfor len(lists) > 1 {\\n\\t\\tlist1, list2 := lists[0], lists[1]\\n\\t\\tmerged := mergeLists(list1, list2)\\n\\n\\t\\tlists = lists[2:]\\n\\t\\tlists = append(lists, merged)\\n\\t}\\n\\treturn lists[0]\\n}\\n\\nfunc mergeLists(listA, listB *ListNode) *ListNode {\\n\\tres := &ListNode{}\\n\\tdummyHead := res\\n\\tfor listA != nil || listB != nil {\\n\\t\\tif listA == nil {\\n\\t\\t\\tres.Next = listB\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif listB == nil {\\n\\t\\t\\tres.Next = listA\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif listA.Val < listB.Val {\\n\\t\\t\\tres.Next = listA\\n\\t\\t\\tres = res.Next\\n\\t\\t\\tlistA = listA.Next\\n\\t\\t} else {\\n\\t\\t\\tres.Next = listB\\n\\t\\t\\tres = res.Next\\n\\t\\t\\tlistB = listB.Next\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.Next\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10896,
                "title": "17-line-c-solution-220ms-by-using-sortedset-as-a-priorityqueue",
                "content": "    public class NodeIndex{\\n        public ListNode Node { get; set; }\\n        public int Index { get; set; }\\n        public NodeIndex(ListNode node, int index) { Node = node; Index = index; }\\n    }\\n    public ListNode MergeKLists(ListNode[] lists) {\\n        SortedSet<NodeIndex> ss = new SortedSet<NodeIndex>(Comparer<NodeIndex>.Create((a, b) => a.Node.val == b.Node.val ? a.Index - b.Index : a.Node.val - b.Node.val));\\n        ListNode head = new ListNode(int.MinValue), p = head;\\n        for(int i = 0; i < lists.Length; i++)\\n            if(lists[i] != null) ss.Add(new NodeIndex(lists[i], i));\\n        while(ss.Count != 0){\\n            NodeIndex nextMerge = ss.Min;\\n            p.next = nextMerge.Node;\\n            p = p.next;\\n            ss.Remove(nextMerge);\\n            if((nextMerge.Node = nextMerge.Node.next) != null) ss.Add(nextMerge);\\n        }\\n        return head.next;\\n    }",
                "solutionTags": [],
                "code": "    public class NodeIndex{\\n        public ListNode Node { get; set; }\\n        public int Index { get; set; }\\n        public NodeIndex(ListNode node, int index) { Node = node; Index = index; }\\n    }\\n    public ListNode MergeKLists(ListNode[] lists) {\\n        SortedSet<NodeIndex> ss = new SortedSet<NodeIndex>(Comparer<NodeIndex>.Create((a, b) => a.Node.val == b.Node.val ? a.Index - b.Index : a.Node.val - b.Node.val));\\n        ListNode head = new ListNode(int.MinValue), p = head;\\n        for(int i = 0; i < lists.Length; i++)\\n            if(lists[i] != null) ss.Add(new NodeIndex(lists[i], i));\\n        while(ss.Count != 0){\\n            NodeIndex nextMerge = ss.Min;\\n            p.next = nextMerge.Node;\\n            p = p.next;\\n            ss.Remove(nextMerge);\\n            if((nextMerge.Node = nextMerge.Node.next) != null) ss.Add(nextMerge);\\n        }\\n        return head.next;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 10983,
                "title": "python-solutions-in-divide-and-conquer-and-heapq",
                "content": "Divide and conquer:\\n\\n    \\n    def mergeKLists(self, lists):\\n        if not lists:\\n            return None\\n            \\n        sentinel = ListNode('0')\\n        while len(lists) > 1:\\n            merged = []\\n            while len(lists) > 1:\\n                merged.append(self.merge(lists.pop(), lists.pop(), sentinel))\\n            lists += merged\\n        return lists[0]\\n        \\n        \\n    def merge(self, x, y, s):\\n        current = s\\n        while x and y:\\n            if x.val < y.val:\\n                current.next = x\\n                x = x.next\\n            else:\\n                current.next = y\\n                y = y.next\\n            current = current.next\\n        current.next = x if x else y\\n        return s.next\\n\\n\\nHeap:\\n \\n    def mergeKLists(self, lists):\\n        current = sentinel = ListNode(0)\\n        lists = [(i.val, i) for i in lists if i]\\n        heapq.heapify(lists)\\n        while lists:\\n            current.next = heapq.heappop(lists)[1]\\n            current = current.next\\n            if current.next:\\n                heapq.heappush(lists, (current.next.val, current.next))\\n        return sentinel.next",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "Divide and conquer:\\n\\n    \\n    def mergeKLists(self, lists):\\n        if not lists:\\n            return None\\n            \\n        sentinel = ListNode('0')\\n        while len(lists) > 1:\\n            merged = []\\n            while len(lists) > 1:\\n                merged.append(self.merge(lists.pop(), lists.pop(), sentinel))\\n            lists += merged\\n        return lists[0]\\n        \\n        \\n    def merge(self, x, y, s):\\n        current = s\\n        while x and y:\\n            if x.val < y.val:\\n                current.next = x\\n                x = x.next\\n            else:\\n                current.next = y\\n                y = y.next\\n            current = current.next\\n        current.next = x if x else y\\n        return s.next\\n\\n\\nHeap:\\n \\n    def mergeKLists(self, lists):\\n        current = sentinel = ListNode(0)\\n        lists = [(i.val, i) for i in lists if i]\\n        heapq.heapify(lists)\\n        while lists:\\n            current.next = heapq.heappop(lists)[1]\\n            current = current.next\\n            if current.next:\\n                heapq.heappush(lists, (current.next.val, current.next))\\n        return sentinel.next",
                "codeTag": "Python3"
            },
            {
                "id": 3288414,
                "title": "python-easy-intuitive-approach",
                "content": "# Intuition\\nSince the constraints were:\\n* length of lists, $$k = 10^4$$\\n* length of each linked lists say $$n = 500$$\\n \\nIt was not a difficult choice to go for time complexity of $$O(kn)$$ \\n\\nAs we will get a TLE in python (generally) if we try to exceed $$O(10^8)$$.\\nBut our solution takes $$O(10^4 * 500) < O(10^8)$$\\n\\n\\n\\n# Approach\\n1. We will iterate through the lists and use the first element of each linked list to find the minimum among them, which will take $$O(k)$$ as length of list is $$k$$.\\n2. We will follow step 1 till all the linked lists are completely explored. We will be able to do it in $$O(n)$$ time as length of any listed list is upper bounded by $$n$$.\\n\\n# Complexity\\n- Time complexity: $$O(kn)$$ as both step 1 and step 2 are performed simultaneously.\\n\\n- Space complexity: $$O(n)$$ to create a new linked list whose length is upper bounded by n.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        l = ListNode() # the new list that we want to return\\n        t = l # taking a temporary copy of the new list as we need to move to next pointers to store data.\\n\\n        # get the minimum front value of all linked lists in the input list.\\n        def get_min():\\n            min_val, min_indx = float(\\'inf\\'), -1\\n            for i in range(len(lists)):\\n                if lists[i] != None and lists[i].val < min_val:\\n                    min_val = lists[i].val\\n                    min_indx = i\\n            if min_indx != -1:\\n                # when a min value is found, \\n                # increment the linked list \\n                # so that we don\\'t consider the same min value the next time \\n                # and also the next value of linked list comes at the front\\n                lists[min_indx] = lists[min_indx].next\\n            return min_val\\n        \\n        while(1):\\n            x = get_min() # get the mim value to add to new list\\n            if (x == float(\\'inf\\')): \\n                # if min value is not obtained that means all the linked lists are traversed so break\\n                break\\n            c = ListNode(val=x)\\n            t.next = c\\n            t = t.next\\n        return l.next # as we made l to be just a head for our actual linked list\\n        \\n\\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        l = ListNode() # the new list that we want to return\\n        t = l # taking a temporary copy of the new list as we need to move to next pointers to store data.\\n\\n        # get the minimum front value of all linked lists in the input list.\\n        def get_min():\\n            min_val, min_indx = float(\\'inf\\'), -1\\n            for i in range(len(lists)):\\n                if lists[i] != None and lists[i].val < min_val:\\n                    min_val = lists[i].val\\n                    min_indx = i\\n            if min_indx != -1:\\n                # when a min value is found, \\n                # increment the linked list \\n                # so that we don\\'t consider the same min value the next time \\n                # and also the next value of linked list comes at the front\\n                lists[min_indx] = lists[min_indx].next\\n            return min_val\\n        \\n        while(1):\\n            x = get_min() # get the mim value to add to new list\\n            if (x == float(\\'inf\\')): \\n                # if min value is not obtained that means all the linked lists are traversed so break\\n                break\\n            c = ListNode(val=x)\\n            t.next = c\\n            t = t.next\\n        return l.next # as we made l to be just a head for our actual linked list\\n        \\n\\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286229,
                "title": "best-solution-c",
                "content": "Beats >98% of submissions in time\\n\\n# C++ Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return nullptr;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.size() - 1);\\n    }\\n    \\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        \\n        while (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                curr->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                curr->next = l2;\\n                l2 = l2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        curr->next = l1 ? l1 : l2;\\n        \\n        return dummy->next;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return nullptr;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.size() - 1);\\n    }\\n    \\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        \\n        while (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                curr->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                curr->next = l2;\\n                l2 = l2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        curr->next = l1 ? l1 : l2;\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285913,
                "title": "stepwise-explanation-with-images-simple-priorityqueue",
                "content": "![image](https://assets.leetcode.com/users/images/c65c1ac8-cedd-48eb-b93b-c236b31ffffc_1678584072.5289342.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        //min heap based on Node value, the minimum value will be at the top in priority queue\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\\n        for (ListNode* listHead : lists) \\n        {\\n            if (listHead != NULL) pq.push({listHead->val, listHead});\\n        }\\n        //=================================================================================\\n        ListNode* newHead = new ListNode(-1); //dummy node for the new Linked List\\n        ListNode* newTail = newHead;\\n        while(!pq.empty())\\n        {\\n            int minVal = pq.top().first;\\n            ListNode* minNode = pq.top().second;\\n            pq.pop();\\n            if (minNode->next != NULL) \\n                pq.push({minNode->next->val, minNode->next});\\n            \\n            newTail->next = minNode;  //append the min Node to the new Linked List\\n            newTail = minNode; //make the minNode as the new tail of new Linked List\\n        }\\n        //=======================================================================================\\n        return newHead->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        //min heap based on Node value, the minimum value will be at the top in priority queue\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\\n        for (ListNode* listHead : lists) \\n        {\\n            if (listHead != NULL) pq.push({listHead->val, listHead});\\n        }\\n        //=================================================================================\\n        ListNode* newHead = new ListNode(-1); //dummy node for the new Linked List\\n        ListNode* newTail = newHead;\\n        while(!pq.empty())\\n        {\\n            int minVal = pq.top().first;\\n            ListNode* minNode = pq.top().second;\\n            pq.pop();\\n            if (minNode->next != NULL) \\n                pq.push({minNode->next->val, minNode->next});\\n            \\n            newTail->next = minNode;  //append the min Node to the new Linked List\\n            newTail = minNode; //make the minNode as the new tail of new Linked List\\n        }\\n        //=======================================================================================\\n        return newHead->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099666,
                "title": "efficient-solution-97-o-nlogk-o-1",
                "content": "# Approach\\nLet **pN - n\\'th pointer**\\n1. lists = [p1, p2, p3, p4, p5, p6, p7]\\n2. lists = [p1, null, p3, null, p5, null, p7]\\nmerge lists[i] with lists[i + 1] and save in lists[i]\\nand set counter **cnt** that will be actual positions iterator.\\nWe just swap lists[i] and lists[cnt] every iteration **swap(lists[i])**.\\nIf there was odd number of lists, then just leave it,\\nwe will merge it when there will be even number of elements in lists.\\n2. [p1, p3, p5, p7, null, null, null]\\n**cnt = 3, lists[cnt] = p7.**\\nActually we dont need to set nullptr to trash elements (lists[i], where i is odd), i wrote null just for explanation.\\n2. [p1, null, p5, null, null, null, null]\\n3. [p1, p5, null, null, null, null, null]\\n4. [p1, null, null, null, null, null, null]\\n**So p1 is answer.**\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(k))\\nn - lists number, k - max nodes in list\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // O(nlogk) - time complexity\\n    // O(1) - memory complexity\\n    ListNode* mergeKLists(std::vector<ListNode*>& lists) {\\n        int n = static_cast<int>(lists.size());\\n        if (!n || n == 1 && lists.front() == nullptr) return nullptr;\\n        ListNode* last = nullptr;\\n        while(n > 1) {\\n            int cnt = 0;\\n            for(int i = 0; i < n - 1; i+=2) {\\n                lists[i] = merge2Lists(lists[i], lists[i + 1]);\\n                swap(lists[i], lists[cnt]);\\n                ++cnt;\\n            }\\n            swap(lists[n-1], lists[cnt]);\\n            n = n/2 + n%2;\\n        }\\n        return lists.front();\\n    }\\n\\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        start = nullptr;\\n        if (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                start = l1;\\n                l1 = l1->next;\\n            } else {\\n                start = l2;\\n                l2 = l2->next;\\n            }\\n        } else if (l1) { return l1; }\\n        else if (l2) { return l2; }\\n        else return nullptr;\\n        ListNode* cur = start;\\n        while(true) {\\n            if (l1 && l2) {\\n                if (l1->val < l2->val) {\\n                    cur->next = l1;\\n                    cur = cur->next;\\n                    l1 = l1->next;\\n                } else {\\n                    cur->next = l2;\\n                    cur = cur->next;\\n                    l2 = l2->next;\\n                }\\n            } else if (l1) {\\n                cur->next = l1;\\n                break;\\n            } else if (l2) {\\n                cur->next = l2;\\n                break;\\n            } else break;\\n        }\\n        return start;\\n    }\\n    ListNode* start = nullptr;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(nlogk) - time complexity\\n    // O(1) - memory complexity\\n    ListNode* mergeKLists(std::vector<ListNode*>& lists) {\\n        int n = static_cast<int>(lists.size());\\n        if (!n || n == 1 && lists.front() == nullptr) return nullptr;\\n        ListNode* last = nullptr;\\n        while(n > 1) {\\n            int cnt = 0;\\n            for(int i = 0; i < n - 1; i+=2) {\\n                lists[i] = merge2Lists(lists[i], lists[i + 1]);\\n                swap(lists[i], lists[cnt]);\\n                ++cnt;\\n            }\\n            swap(lists[n-1], lists[cnt]);\\n            n = n/2 + n%2;\\n        }\\n        return lists.front();\\n    }\\n\\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        start = nullptr;\\n        if (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                start = l1;\\n                l1 = l1->next;\\n            } else {\\n                start = l2;\\n                l2 = l2->next;\\n            }\\n        } else if (l1) { return l1; }\\n        else if (l2) { return l2; }\\n        else return nullptr;\\n        ListNode* cur = start;\\n        while(true) {\\n            if (l1 && l2) {\\n                if (l1->val < l2->val) {\\n                    cur->next = l1;\\n                    cur = cur->next;\\n                    l1 = l1->next;\\n                } else {\\n                    cur->next = l2;\\n                    cur = cur->next;\\n                    l2 = l2->next;\\n                }\\n            } else if (l1) {\\n                cur->next = l1;\\n                break;\\n            } else if (l2) {\\n                cur->next = l2;\\n                break;\\n            } else break;\\n        }\\n        return start;\\n    }\\n    ListNode* start = nullptr;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049884,
                "title": "java-priorityqueue-minheap-clean-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        \\n        // Initiate a minheap based on the val of the node\\n        PriorityQueue<ListNode> queue = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        \\n        // put the first node of every list into queue\\n        for (ListNode node : lists) {\\n            if (node == null) continue;\\n            queue.add(node);\\n        }\\n        \\n        // dummy head to carry the result\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode curr = dummyHead;\\n        \\n        // link the root of minheap to he dummyHead, add the root.next to the minheap, repeate this process untill minheap runs out of nodes\\n        while(!queue.isEmpty()) {\\n            curr.next = queue.poll();\\n            curr = curr.next;\\n            if (curr.next != null) queue.add(curr.next);\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        \\n        // Initiate a minheap based on the val of the node\\n        PriorityQueue<ListNode> queue = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        \\n        // put the first node of every list into queue\\n        for (ListNode node : lists) {\\n            if (node == null) continue;\\n            queue.add(node);\\n        }\\n        \\n        // dummy head to carry the result\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode curr = dummyHead;\\n        \\n        // link the root of minheap to he dummyHead, add the root.next to the minheap, repeate this process untill minheap runs out of nodes\\n        while(!queue.isEmpty()) {\\n            curr.next = queue.poll();\\n            curr = curr.next;\\n            if (curr.next != null) queue.add(curr.next);\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560894,
                "title": "python-3-simple-solution-using-array-beats-97",
                "content": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists: return \\n        result=[]\\n        for i in lists:\\n            while i:\\n                result.append(i.val)\\n                i=i.next\\n        if not result: return\\n        result.sort()\\n        head=ListNode(result.pop(0))\\n        m=head\\n        while result:\\n            m.next=ListNode(result.pop(0))\\n            m=m.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists: return \\n        result=[]\\n        for i in lists:\\n            while i:\\n                result.append(i.val)\\n                i=i.next\\n        if not result: return\\n        result.sort()\\n        head=ListNode(result.pop(0))\\n        m=head\\n        while result:\\n            m.next=ListNode(result.pop(0))\\n            m=m.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507469,
                "title": "python-using-min-heap-or-sort",
                "content": "**Min Heap**\\n```\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        values, head, pointer = [], None, None\\n        \\n        for l in lists:\\n            while l:\\n                heappush(values, l.val)\\n                l = l.next\\n        \\n        while values:\\n            if head == None:\\n                head = ListNode(heappop(values))\\n                pointer = head\\n            else:\\n                pointer.next = ListNode(heappop(values))\\n                pointer = pointer.next\\n        \\n        return head\\n```\\n\\n\\n**Sort**\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        values, head, pointer = [], None, None\\n        \\n        for l in lists:\\n            while l:\\n                values.append(l.val)\\n                l = l.next\\n                \\n        values.sort()\\n        \\n        while values:\\n            if head == None:\\n                head = ListNode(values.pop(0))\\n                pointer = head\\n            else:\\n                pointer.next = ListNode(values.pop(0))\\n                pointer = pointer.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        values, head, pointer = [], None, None\\n        \\n        for l in lists:\\n            while l:\\n                heappush(values, l.val)\\n                l = l.next\\n        \\n        while values:\\n            if head == None:\\n                head = ListNode(heappop(values))\\n                pointer = head\\n            else:\\n                pointer.next = ListNode(heappop(values))\\n                pointer = pointer.next\\n        \\n        return head\\n```\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        values, head, pointer = [], None, None\\n        \\n        for l in lists:\\n            while l:\\n                values.append(l.val)\\n                l = l.next\\n                \\n        values.sort()\\n        \\n        while values:\\n            if head == None:\\n                head = ListNode(values.pop(0))\\n                pointer = head\\n            else:\\n                pointer.next = ListNode(values.pop(0))\\n                pointer = pointer.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281817,
                "title": "swift-solution",
                "content": "```\\nfunc mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        //base checks\\n        var input = lists\\n        if(input.count == 0) {\\n            return nil\\n        }\\n        if(input.count == 1) {\\n            return input[0]\\n        }\\n        \\n        return partition(lists,0,input.count - 1)\\n    }\\n    \\n    \\n    func partition(_ list:[ListNode?], _ start:Int, _ end:Int) -> ListNode?{\\n        if(start == end) {\\n            return list[start]\\n        }\\n        if(start < end) {\\n            let middle = (start + end)/2\\n            let l1 = partition(list, start,middle)\\n            let l2 = partition(list, middle + 1,end)\\n            return mergeTwoList(l1,l2)\\n        }\\n        return nil\\n    }\\n    \\n    func mergeTwoList(_ l1:ListNode?, _ l2:ListNode?) ->ListNode? {\\n        if(l1 == nil) {return l2}\\n        if(l2 == nil) {return l1}\\n        var result:ListNode?\\n        \\n        if(l1!.val <= l2!.val) {\\n            result = l1\\n            result!.next = mergeTwoList(l1!.next,l2)\\n        }\\n        else {\\n            result = l2\\n            result!.next = mergeTwoList(l1,l2!.next)\\n        }\\n        return result\\n    }\\n\\t```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        //base checks\\n        var input = lists\\n        if(input.count == 0) {\\n            return nil\\n        }\\n        if(input.count == 1) {\\n            return input[0]\\n        }\\n        \\n        return partition(lists,0,input.count - 1)\\n    }\\n    \\n    \\n    func partition(_ list:[ListNode?], _ start:Int, _ end:Int) -> ListNode?{\\n        if(start == end) {\\n            return list[start]\\n        }\\n        if(start < end) {\\n            let middle = (start + end)/2\\n            let l1 = partition(list, start,middle)\\n            let l2 = partition(list, middle + 1,end)\\n            return mergeTwoList(l1,l2)\\n        }\\n        return nil\\n    }\\n    \\n    func mergeTwoList(_ l1:ListNode?, _ l2:ListNode?) ->ListNode? {\\n        if(l1 == nil) {return l2}\\n        if(l2 == nil) {return l1}\\n        var result:ListNode?\\n        \\n        if(l1!.val <= l2!.val) {\\n            result = l1\\n            result!.next = mergeTwoList(l1!.next,l2)\\n        }\\n        else {\\n            result = l2\\n            result!.next = mergeTwoList(l1,l2!.next)\\n        }\\n        return result\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 208936,
                "title": "why-am-i-getting-undefined-for-testcase-input",
                "content": "```\\nvar mergeKLists = function(lists) {\\n    let i = 0, last = lists.length - 1, j = last;\\n    if (!lists.length) return lists;\\n    while (last > 0) {\\n        i = 0; j = last;\\n        while (i < j) {\\n            lists[i] = merge2Lists(lists[i], lists[j]);\\n            i++; j--;\\n            if (i >= j) {\\n                last = j;\\n            }\\n        }\\n    }\\n    return lists[0];\\n};\\n```\\n\\nWhen lists length is zero I just return lists which is []. For some odd reason, LeetCode says output of my code is [undefined] which is not same as the expected []. \\n\\nEven if I return an explicit empty array i.e.  `if (!lists.length) return return [];`, I get the same error i.e. \\n\\nInput: []\\nOutput: [undefined]\\nExpected: []\\n\\nAnother strange thing is that final code, used to work for the same test case. But even for it I am getting same error now. I feel like someone has messed up the test case. \\n\\n```\\nvar mergeKLists = function(lists) {\\n    let len = lists.length;\\n    if (!len) return lists;  \\n    while (lists.length > 1) {\\n        lists.push(merge2Lists(lists[0], lists[1]));\\n        lists.shift();\\n        lists.shift();\\n    }\\n    return lists[0];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar mergeKLists = function(lists) {\\n    let i = 0, last = lists.length - 1, j = last;\\n    if (!lists.length) return lists;\\n    while (last > 0) {\\n        i = 0; j = last;\\n        while (i < j) {\\n            lists[i] = merge2Lists(lists[i], lists[j]);\\n            i++; j--;\\n            if (i >= j) {\\n                last = j;\\n            }\\n        }\\n    }\\n    return lists[0];\\n};\\n```\n```\\nvar mergeKLists = function(lists) {\\n    let len = lists.length;\\n    if (!len) return lists;  \\n    while (lists.length > 1) {\\n        lists.push(merge2Lists(lists[0], lists[1]));\\n        lists.shift();\\n        lists.shift();\\n    }\\n    return lists[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142187,
                "title": "javascript-es6-clean-code-using-divide-conquer-approach-beating-98",
                "content": "```\\nconst mergeKLists = (lists, lo = 0, hi = lists.length - 1) => {\\n    if (lists.length === 0) {\\n        return lists;\\n    }\\n    \\n    if (lo === hi) {\\n        return lists[lo];\\n    }\\n    \\n    const mid = Math.floor((hi + lo) / 2);\\n    const left = mergeKLists(lists, lo, mid);\\n    const right = mergeKLists(lists, mid + 1, hi);\\n    \\n    return mergeTwoLists(left, right);\\n};\\n\\nconst mergeTwoLists = (l1, l2) => {\\n    if (l1 === null) {\\n        return l2;\\n    }\\n    if (l2 === null) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst mergeKLists = (lists, lo = 0, hi = lists.length - 1) => {\\n    if (lists.length === 0) {\\n        return lists;\\n    }\\n    \\n    if (lo === hi) {\\n        return lists[lo];\\n    }\\n    \\n    const mid = Math.floor((hi + lo) / 2);\\n    const left = mergeKLists(lists, lo, mid);\\n    const right = mergeKLists(lists, mid + 1, hi);\\n    \\n    return mergeTwoLists(left, right);\\n};\\n\\nconst mergeTwoLists = (l1, l2) => {\\n    if (l1 === null) {\\n        return l2;\\n    }\\n    if (l2 === null) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10805,
                "title": "beat-94-84-3ms-divide-conquer-java-solution",
                "content": "    public class Solution {\\n        public ListNode mergeKLists(ListNode[] lists) {\\n            if(lists == null || lists.length == 0){\\n                return null;\\n            }\\n            return reduce(map(lists, 0, lists.length / 2), map(lists, lists.length / 2 + 1, lists.length - 1));\\n        }\\n        private ListNode map(ListNode[] lists, int from, int to){\\n            if(from > to){\\n                return null;\\n            }\\n            if(from == to){\\n                return lists[from];\\n            }\\n            if(from + 1 == to){\\n                return reduce(lists[from], lists[to]);\\n            }\\n            return reduce(map(lists, from, (from + to) / 2), map(lists, (from + to) / 2 + 1, to));\\n        }\\n        \\n        private ListNode reduce(ListNode first, ListNode second){\\n            if(first == null){\\n                return second;\\n            }\\n            if(second == null){\\n                return first;\\n            }\\n            ListNode head, pre;\\n            if(first.val < second.val){\\n                head = first;\\n                pre = first;\\n                first = first.next;\\n            }else{\\n                head = second;\\n                pre = second;\\n                second = second.next;\\n            }\\n            while(true){\\n                if(first == null){\\n                    pre.next = second;\\n                    break;\\n                }\\n                if(second == null){\\n                    pre.next = first;\\n                    break;\\n                }\\n                if(first.val < second.val){\\n                    pre.next = first;\\n                    pre = pre.next;\\n                    first = first.next;\\n                }else{\\n                    pre.next = second;\\n                    pre = pre.next;\\n                    second = second.next;\\n                }\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n        public ListNode mergeKLists(ListNode[] lists) {\\n            if(lists == null || lists.length == 0){\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 10758,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "There are 2 ways to merge all the #lists linked-list:\\n\\n-1- we can merge the lists[0] with the lists[i] additively and record the results with the cur-pointer\\n\\n-2-  we can merge the top of the linked-lists and push the merged-linked-lists to the tail of the vector.\\n\\n**I can not figure out why the method-1- have TLE problem while the method-2- is OK ?**\\n\\nSolution:\\n\\n     because the method-1- merge-one-list-one-time, but the method-2- merge-2-list-one-time\\n\\nHere is my implementation:\\n\\n       class Solution {\\n        public:\\n            ListNode* mergeKLists(vector<ListNode*>& lists) {\\n                //merge way -1-\\n                if(lists.empty())   return NULL;\\n                ListNode* cur=lists[0];\\n                cout<<lists.size()<<endl;\\n                for(int i=1; i<lists.size(); i++){\\n                    cur=mergeTwoLists(cur, lists[i]);\\n                }\\n                return cur;\\n                \\n                //merge way -2-\\n                if(lists.empty()){\\n                    return nullptr;\\n                }\\n                while(lists.size() > 1){\\n                    lists.push_back(mergeTwoLists(lists[0], lists[1]));\\n                    lists.erase(lists.begin());\\n                    lists.erase(lists.begin());\\n                }\\n                return lists.front();\\n            }\\n         \\n            \\n            ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\\n                ListNode* dummy=new ListNode(-1);\\n                ListNode* cur=dummy;\\n                while(l1 && l2){\\n                    if(l1->val < l2->val){\\n                        cur->next=l1;\\n                        cur=l1;\\n                        l1=l1->next;\\n                    }\\n                    else{\\n                        cur->next=l2;\\n                        cur=l2;\\n                        l2=l2->next;\\n                    }\\n                }\\n                if(!l1)  cur->next=l2;\\n                if(!l2)  cur->next=l1;\\n                return dummy->next;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            ListNode* mergeKLists(vector<ListNode*>& lists) {\\n                //merge way -1-\\n                if(lists.empty())   return NULL;\\n                ListNode* cur=lists[0];\\n                cout<<lists.size()<<endl;\\n                for(int i=1; i<lists.size(); i++){\\n                    cur=mergeTwoLists(cur, lists[i]);\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 3590066,
                "title": "easiest-intutive-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int length(ListNode* h){\\n        ListNode* l=h;\\n        int c=0;\\n        while(l){\\n            c+=1;\\n            l=l->next;\\n        }\\n        return c;\\n    }\\n\\n    ListNode* merge(ListNode* l1,ListNode* l2){\\n        ListNode* h1=l1,*h2=l2;\\n        ListNode* ll=new ListNode(0);\\n        ListNode* ans=ll;\\n        while(h1 and h2){\\n            if(h1->val <=h2->val){\\n                ans->next=h1;\\n                h1=h1->next;\\n            } else{\\n                ans->next=h2;\\n                h2=h2->next;\\n            }\\n            ans=ans->next;\\n        }\\n\\n        if(h1)\\n        ans->next=h1;\\n        if(h2)\\n        ans->next=h2;\\n\\n        return ll->next;\\n        \\n    }\\n\\n    ListNode* mergeKLists(vector<ListNode*>& a) {\\n        ListNode* st,temp;\\n        if(a.size()==0)\\n        return NULL;\\n        ListNode* l1=a[0];\\n        for(int i=1;i<a.size();i+=1){\\n            \\n            ListNode* l2=a[i];\\n            if(length(l1)<length(l2)){\\n            l1=merge(l2,l1);\\n        } else\\n            l1=merge(l1,l2);\\n\\n        }\\n        return l1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int length(ListNode* h){\\n        ListNode* l=h;\\n        int c=0;\\n        while(l){\\n            c+=1;\\n            l=l->next;\\n        }\\n        return c;\\n    }\\n\\n    ListNode* merge(ListNode* l1,ListNode* l2){\\n        ListNode* h1=l1,*h2=l2;\\n        ListNode* ll=new ListNode(0);\\n        ListNode* ans=ll;\\n        while(h1 and h2){\\n            if(h1->val <=h2->val){\\n                ans->next=h1;\\n                h1=h1->next;\\n            } else{\\n                ans->next=h2;\\n                h2=h2->next;\\n            }\\n            ans=ans->next;\\n        }\\n\\n        if(h1)\\n        ans->next=h1;\\n        if(h2)\\n        ans->next=h2;\\n\\n        return ll->next;\\n        \\n    }\\n\\n    ListNode* mergeKLists(vector<ListNode*>& a) {\\n        ListNode* st,temp;\\n        if(a.size()==0)\\n        return NULL;\\n        ListNode* l1=a[0];\\n        for(int i=1;i<a.size();i+=1){\\n            \\n            ListNode* l2=a[i];\\n            if(length(l1)<length(l2)){\\n            l1=merge(l2,l1);\\n        } else\\n            l1=merge(l1,l2);\\n\\n        }\\n        return l1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285953,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* head1,ListNode* head2){\\n        ListNode* head=NULL;\\n        ListNode* tail=NULL;\\n        while(head1&&head2){\\n            if(head1->val<=head2->val){\\n                if(!head){\\n                    head=head1;\\n                    tail=head;\\n                }\\n                else{\\n                    tail->next=head1;\\n                    tail=tail->next;\\n                }\\n                head1=head1->next;\\n            }\\n            else{\\n                if(!head){\\n                    head=head2;\\n                    tail=head;\\n                }\\n                else{\\n                    tail->next=head2;\\n                    tail=tail->next;\\n                }\\n                head2=head2->next;\\n            }\\n        }\\n        while(head1){\\n            if(!head){\\n                head=head1;\\n                tail=head;\\n            }\\n            else{\\n                tail->next=head1;\\n                tail=tail->next;\\n            }\\n            head1=head1->next;\\n        }\\n        while(head2){\\n            if(!head){\\n                head=head2;\\n                tail=head;\\n            }\\n            else{\\n                tail->next=head2;\\n                tail=tail->next;\\n            }\\n            head2=head2->next;            \\n        }\\n        return head;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int n=lists.size();\\n        if(lists.empty()) return NULL;\\n        ListNode* head=lists[0];\\n        for(int i=1;i<n;i++){\\n            head=merge(head,lists[i]);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* head1,ListNode* head2){\\n        ListNode* head=NULL;\\n        ListNode* tail=NULL;\\n        while(head1&&head2){\\n            if(head1->val<=head2->val){\\n                if(!head){\\n                    head=head1;\\n                    tail=head;\\n                }\\n                else{\\n                    tail->next=head1;\\n                    tail=tail->next;\\n                }\\n                head1=head1->next;\\n            }\\n            else{\\n                if(!head){\\n                    head=head2;\\n                    tail=head;\\n                }\\n                else{\\n                    tail->next=head2;\\n                    tail=tail->next;\\n                }\\n                head2=head2->next;\\n            }\\n        }\\n        while(head1){\\n            if(!head){\\n                head=head1;\\n                tail=head;\\n            }\\n            else{\\n                tail->next=head1;\\n                tail=tail->next;\\n            }\\n            head1=head1->next;\\n        }\\n        while(head2){\\n            if(!head){\\n                head=head2;\\n                tail=head;\\n            }\\n            else{\\n                tail->next=head2;\\n                tail=tail->next;\\n            }\\n            head2=head2->next;            \\n        }\\n        return head;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int n=lists.size();\\n        if(lists.empty()) return NULL;\\n        ListNode* head=lists[0];\\n        for(int i=1;i<n;i++){\\n            head=merge(head,lists[i]);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285878,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def mergeKLists(self,lists:List[Optional[ListNode]])->Optional[ListNode]:\\n        values,head,pointer=[],None,None\\n        for l in lists:\\n            while l:\\n                heappush(values,l.val)\\n                l=l.next\\n\\n        while values:\\n            if head is None:\\n                head=ListNode(heappop(values))\\n                pointer=head\\n\\n            else:\\n                pointer.next=ListNode(heappop(values))\\n                pointer=pointer.next\\n\\n        return head                              \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def mergeKLists(self,lists:List[Optional[ListNode]])->Optional[ListNode]:\\n        values,head,pointer=[],None,None\\n        for l in lists:\\n            while l:\\n                heappush(values,l.val)\\n                l=l.next\\n\\n        while values:\\n            if head is None:\\n                head=ListNode(heappop(values))\\n                pointer=head\\n\\n            else:\\n                pointer.next=ListNode(heappop(values))\\n                pointer=pointer.next\\n\\n        return head                              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056025,
                "title": "c-using-vector-simple-and-easy-approach",
                "content": "# Intuition\\nJust insert all the elements in a vector and sort it. Then make a new LL using vector\\'s elements.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int> v;\\n        \\n        for(auto i:lists){\\n            while(i != NULL){\\n                v.push_back(i->val);\\n                i=i->next;\\n            }\\n        }\\n        \\n        if(v.size() == 0) return NULL;\\n        sort(v.begin(), v.end());\\n        \\n        ListNode* head = new ListNode(v[0]);\\n        ListNode* temp = head;\\n        \\n        for(int i=1; i<v.size(); i++){\\n            ListNode* num = new ListNode(v[i]);\\n            temp->next = num;\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int> v;\\n        \\n        for(auto i:lists){\\n            while(i != NULL){\\n                v.push_back(i->val);\\n                i=i->next;\\n            }\\n        }\\n        \\n        if(v.size() == 0) return NULL;\\n        sort(v.begin(), v.end());\\n        \\n        ListNode* head = new ListNode(v[0]);\\n        ListNode* temp = head;\\n        \\n        for(int i=1; i<v.size(); i++){\\n            ListNode* num = new ListNode(v[i]);\\n            temp->next = num;\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755021,
                "title": "merge-the-lists",
                "content": "```\\nclass Solution {\\npublic:\\n    void it(ListNode* &t,int v){\\n        ListNode* s=new ListNode(v);\\n        t->next=s;\\n        t=t->next;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& l) {\\n        vector<int>v;\\n        if(l.size()==0){//base case\\n            return NULL;\\n        }\\n        for(int p=0;p<l.size();p++){\\n            ListNode* a=l[p];\\n            while(a){\\n                v.push_back(a->val);\\n                a=a->next;\\n            }\\n        }\\n        if(v.size()==0){\\n            return NULL;\\n        }\\n        sort(v.begin(),v.end());\\n\\t\\t//sorted vector\\n        ListNode* s=new ListNode(v[0]);\\n        ListNode* t=s;\\n        for(int p=1;p<v.size();p++){\\n            it(t,v[p]);//adding to tail\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void it(ListNode* &t,int v){\\n        ListNode* s=new ListNode(v);\\n        t->next=s;\\n        t=t->next;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& l) {\\n        vector<int>v;\\n        if(l.size()==0){//base case\\n            return NULL;\\n        }\\n        for(int p=0;p<l.size();p++){\\n            ListNode* a=l[p];\\n            while(a){\\n                v.push_back(a->val);\\n                a=a->next;\\n            }\\n        }\\n        if(v.size()==0){\\n            return NULL;\\n        }\\n        sort(v.begin(),v.end());\\n\\t\\t//sorted vector\\n        ListNode* s=new ListNode(v[0]);\\n        ListNode* t=s;\\n        for(int p=1;p<v.size();p++){\\n            it(t,v[p]);//adding to tail\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702610,
                "title": "beats-97-easy-c-priority-queue-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    class MyCmp{\\n        public:\\n            bool operator()(ListNode *l1,ListNode *l2){\\n                return l1->val>l2->val;\\n            }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int l=lists.size();\\n        priority_queue<ListNode*,vector<ListNode*>,MyCmp>pq;\\n        for(int i=0;i<l;i++){\\n            if(lists[i]!=NULL){\\n                pq.push(lists[i]);\\n            }\\n        }\\n        ListNode *head=new ListNode();\\n        ListNode* curr=head;\\n        while(!pq.empty()){\\n            curr->next=pq.top();\\n            curr=curr->next;\\n            pq.pop();\\n            if(curr->next!=NULL){\\n                pq.push(curr->next);\\n            }\\n        }\\n        return head->next;\\n        \\n\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    class MyCmp{\\n        public:\\n            bool operator()(ListNode *l1,ListNode *l2){\\n                return l1->val>l2->val;\\n            }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int l=lists.size();\\n        priority_queue<ListNode*,vector<ListNode*>,MyCmp>pq;\\n        for(int i=0;i<l;i++){\\n            if(lists[i]!=NULL){\\n                pq.push(lists[i]);\\n            }\\n        }\\n        ListNode *head=new ListNode();\\n        ListNode* curr=head;\\n        while(!pq.empty()){\\n            curr->next=pq.top();\\n            curr=curr->next;\\n            pq.pop();\\n            if(curr->next!=NULL){\\n                pq.push(curr->next);\\n            }\\n        }\\n        return head->next;\\n        \\n\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812229,
                "title": "3-approaches-with-comments-min-heap-divide-conquer-c",
                "content": "Implementation\\n\\n**1st Approach\\nTime Complexity = O(N * max(k.length))\\nSpace Complexity = O(max(k.length)), bcz of the recursive mergeTwoLists()**\\n\\nIdea : Iterating over the k lists from 1 to N, and adding all the lists into lists[0], and in last returning that lists[0], bcz all other k lists are getting merged into this lists[0]\\n\\n```\\nclass Solution {\\nprivate:\\n    // Recursive Approach to merge the sorted lists\\n    // Time Complexity = O(max(first, second))\\n    // Space Complexity = O(max(first, second)), bcz of stack trace\\n    ListNode* mergeTwoLists(ListNode* first, ListNode* second){\\n        if(!first) return second;\\n        if(!second) return first;        \\n        \\n        if(first->val < second->val){\\n            first->next = mergeTwoLists(first->next, second);\\n            return first;\\n        }\\n        else{\\n            second->next = mergeTwoLists(first, second->next);\\n            return second;\\n        }\\n    }\\n    \\npublic:    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n        if(lists.size() == 1) return lists[0];\\n        \\n        // traversing over the lists\\n        for(int itr = 1; itr < lists.size(); itr++){\\n            lists[0] = mergeTwoLists(lists[0], lists[itr]);\\n        }\\n        \\n        return lists[0];\\n    }\\n};\\n```\\n\\n\\n**2nd Approach\\nUsing Priority Queue(Min Heap)\\nTime Complexity = O(N * logK)\\nSpace Complexity = O(max(k.length))**\\n\\nIdea : Storing all k nodes into the Priority Queue and after that just looping until its size become 0, while looping storing the top node into the dummy list, bcz it will be a smallest node, and adding the next of the kth node into Priority Queue, if its not null\\n\\n```\\nclass Solution {\\nprivate:\\n    // using this stuct to compare the data of the node, bcz we are storing the list into the Priority Queue\\n    struct compare {\\n        bool operator()(const ListNode* l, const ListNode* r) {\\n            return l->val > r->val;\\n        }\\n    };\\n    \\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        // using pq to store the nodes in the ascending order, by default priority queue stores elements into ascending order only\\n        priority_queue<ListNode*, vector<ListNode*>, compare> pq;\\n        \\n        // storing the first node of every k lists into pq\\n        for(int itr = 0; itr < lists.size(); itr++){\\n            if(lists[itr]) pq.push(lists[itr]);\\n        }\\n        \\n        // Using a dummy list to store the result\\n        ListNode* dummy = new ListNode(0);\\n        \\n        // using the res list to return the result\\n        ListNode* res = dummy;\\n        \\n        // iterating over the pq, and storing the nodes into dummy, and if particular kth node is having more nodes then storing those nodes into the pq\\n        while(pq.size()){\\n\\n            // getting the node which is on the top of pq, bcz that will be our smallest node\\n            ListNode* temp = pq.top();\\n            \\n            // removing the top node\\n            pq.pop();\\n            \\n            // storing the temp node into dummy\\n            dummy->next = temp;\\n            \\n            // moving dummy one step ahead\\n            dummy = dummy->next;\\n            \\n            // if particular kth node(temp) is having more nodes then storing the node into the pq\\n            if(temp->next){\\n                pq.push(temp->next);\\n            }\\n        }\\n        \\n        // returning the result\\n        return res->next;\\n    }\\n};\\n```\\n\\n\\n**3rd Approach\\nUsing Divide & Conquer Strategy\\nTime Complexity = O(N * logK)\\nSpace Complexity = O(max(k.length))**\\n\\nIdea : divide the list, take two pointers one from start, another from last, and merge the lists of both start and end index, and store into the start index and increment start by 1 and decrement end by 1, so in the last will be having the all k lists at 0th index in sorted form.\\n\\n```\\nclass Solution {\\nprivate:\\n    // Recursive Approach to merge the sorted lists\\n    // Time Complexity = O(max(first, second))\\n    // Space Complexity = O(max(first, second)), bcz of stack trace\\n    ListNode* mergeTwoLists(ListNode* first, ListNode* second){\\n        if(!first) return second;\\n        if(!second) return first;        \\n        \\n        if(first->val < second->val){\\n            first->next = mergeTwoLists(first->next, second);\\n            return first;\\n        }\\n        else{\\n            second->next = mergeTwoLists(first, second->next);\\n            return second;\\n        }\\n    }\\n    \\npublic:    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        // base case\\n        if(lists.size() == 0) return NULL;\\n        \\n        // start will always start from 0th node, and end will start from last node\\n        int start = 0, end = lists.size()-1;\\n        \\n        while(end > 0){\\n            \\n            // intialize start to 0 everytime\\n            start = 0;\\n            \\n            // run the loop till the time, start is less than the end\\n            while(start < end){\\n                \\n                // merge the start index and end index node and store the merged list into the start index\\n                lists[start] = mergeTwoLists(lists[start], lists[end]);\\n                \\n                // increment start by 1\\n                start++;\\n                \\n                // decrement end by 1\\n                end--;\\n            }\\n        }\\n        \\n        // at the end will be having the all merged nodes on the 0th index\\n        return lists[0];\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Divide and Conquer",
                    "Recursion",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Recursive Approach to merge the sorted lists\\n    // Time Complexity = O(max(first, second))\\n    // Space Complexity = O(max(first, second)), bcz of stack trace\\n    ListNode* mergeTwoLists(ListNode* first, ListNode* second){\\n        if(!first) return second;\\n        if(!second) return first;        \\n        \\n        if(first->val < second->val){\\n            first->next = mergeTwoLists(first->next, second);\\n            return first;\\n        }\\n        else{\\n            second->next = mergeTwoLists(first, second->next);\\n            return second;\\n        }\\n    }\\n    \\npublic:    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n        if(lists.size() == 1) return lists[0];\\n        \\n        // traversing over the lists\\n        for(int itr = 1; itr < lists.size(); itr++){\\n            lists[0] = mergeTwoLists(lists[0], lists[itr]);\\n        }\\n        \\n        return lists[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    // using this stuct to compare the data of the node, bcz we are storing the list into the Priority Queue\\n    struct compare {\\n        bool operator()(const ListNode* l, const ListNode* r) {\\n            return l->val > r->val;\\n        }\\n    };\\n    \\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        // using pq to store the nodes in the ascending order, by default priority queue stores elements into ascending order only\\n        priority_queue<ListNode*, vector<ListNode*>, compare> pq;\\n        \\n        // storing the first node of every k lists into pq\\n        for(int itr = 0; itr < lists.size(); itr++){\\n            if(lists[itr]) pq.push(lists[itr]);\\n        }\\n        \\n        // Using a dummy list to store the result\\n        ListNode* dummy = new ListNode(0);\\n        \\n        // using the res list to return the result\\n        ListNode* res = dummy;\\n        \\n        // iterating over the pq, and storing the nodes into dummy, and if particular kth node is having more nodes then storing those nodes into the pq\\n        while(pq.size()){\\n\\n            // getting the node which is on the top of pq, bcz that will be our smallest node\\n            ListNode* temp = pq.top();\\n            \\n            // removing the top node\\n            pq.pop();\\n            \\n            // storing the temp node into dummy\\n            dummy->next = temp;\\n            \\n            // moving dummy one step ahead\\n            dummy = dummy->next;\\n            \\n            // if particular kth node(temp) is having more nodes then storing the node into the pq\\n            if(temp->next){\\n                pq.push(temp->next);\\n            }\\n        }\\n        \\n        // returning the result\\n        return res->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    // Recursive Approach to merge the sorted lists\\n    // Time Complexity = O(max(first, second))\\n    // Space Complexity = O(max(first, second)), bcz of stack trace\\n    ListNode* mergeTwoLists(ListNode* first, ListNode* second){\\n        if(!first) return second;\\n        if(!second) return first;        \\n        \\n        if(first->val < second->val){\\n            first->next = mergeTwoLists(first->next, second);\\n            return first;\\n        }\\n        else{\\n            second->next = mergeTwoLists(first, second->next);\\n            return second;\\n        }\\n    }\\n    \\npublic:    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        // base case\\n        if(lists.size() == 0) return NULL;\\n        \\n        // start will always start from 0th node, and end will start from last node\\n        int start = 0, end = lists.size()-1;\\n        \\n        while(end > 0){\\n            \\n            // intialize start to 0 everytime\\n            start = 0;\\n            \\n            // run the loop till the time, start is less than the end\\n            while(start < end){\\n                \\n                // merge the start index and end index node and store the merged list into the start index\\n                lists[start] = mergeTwoLists(lists[start], lists[end]);\\n                \\n                // increment start by 1\\n                start++;\\n                \\n                // decrement end by 1\\n                end--;\\n            }\\n        }\\n        \\n        // at the end will be having the all merged nodes on the 0th index\\n        return lists[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745592,
                "title": "c",
                "content": "```\\nListNode* mergeTwoLists(ListNode* a, ListNode* b){\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        ListNode* head=NULL;\\n        if(a->val <= b->val)\\n        {   head=a;\\n            head->next = mergeTwoLists(a->next, b);\\n            \\n        }\\n        else{\\n            head=b;\\n            head->next = mergeTwoLists(a, b->next);\\n            \\n        }\\n        return head;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0){\\n            return NULL;\\n        }\\n        if(lists.size()==1){\\n            return lists[0];\\n        }\\n        \\n        ListNode* res=lists[0];\\n        \\n        for(int i=1;i<lists.size();i++){\\n            res=mergeTwoLists(res,lists[i]);\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* mergeTwoLists(ListNode* a, ListNode* b){\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        ListNode* head=NULL;\\n        if(a->val <= b->val)\\n        {   head=a;\\n            head->next = mergeTwoLists(a->next, b);\\n            \\n        }\\n        else{\\n            head=b;\\n            head->next = mergeTwoLists(a, b->next);\\n            \\n        }\\n        return head;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0){\\n            return NULL;\\n        }\\n        if(lists.size()==1){\\n            return lists[0];\\n        }\\n        \\n        ListNode* res=lists[0];\\n        \\n        for(int i=1;i<lists.size();i++){\\n            res=mergeTwoLists(res,lists[i]);\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1201446,
                "title": "python-divide-and-conquer-easy-understand-o-nlogk",
                "content": "```\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        if not lists: # handle []\\n            return None  \\n        \\n        if len(lists) == 1:  # it can handle [[]], len([[]])=1\\n            return lists[0] # return the nodes\\n        \\n        if len(lists) == 2:\\n            return self.merge2Lists(lists[0], lists[1])\\n        \\n        left, right = 0, len(lists)-1\\n        mid = (left+right) // 2\\n        leftSide = lists[:mid]\\n        rightSide = lists[mid:]\\n        leftDone = self.mergeKLists(leftSide)\\n        rightDone = self.mergeKLists(rightSide)\\n            \\n        return self.merge2Lists(leftDone, rightDone)\\n        \\n        \\n    def merge2Lists(self, list1, list2):\\n        \\n        pre = dummy = ListNode(\\'a\\')\\n        \\n        while list1 and list2:\\n            if list1.val <= list2.val:\\n                dummy.next = list1\\n                list1 = list1.next\\n            else:\\n                dummy.next = list2\\n                list2 = list2.next\\n            dummy = dummy.next \\n        \\n        \\n        if list1 and not list2:\\n            dummy.next = list1\\n\\n        if not list1 and list2:\\n            dummy.next = list2\\n        \\n        return pre.next\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        if not lists: # handle []\\n            return None  \\n        \\n        if len(lists) == 1:  # it can handle [[]], len([[]])=1\\n            return lists[0] # return the nodes\\n        \\n        if len(lists) == 2:\\n            return self.merge2Lists(lists[0], lists[1])\\n        \\n        left, right = 0, len(lists)-1\\n        mid = (left+right) // 2\\n        leftSide = lists[:mid]\\n        rightSide = lists[mid:]\\n        leftDone = self.mergeKLists(leftSide)\\n        rightDone = self.mergeKLists(rightSide)\\n            \\n        return self.merge2Lists(leftDone, rightDone)\\n        \\n        \\n    def merge2Lists(self, list1, list2):\\n        \\n        pre = dummy = ListNode(\\'a\\')\\n        \\n        while list1 and list2:\\n            if list1.val <= list2.val:\\n                dummy.next = list1\\n                list1 = list1.next\\n            else:\\n                dummy.next = list2\\n                list2 = list2.next\\n            dummy = dummy.next \\n        \\n        \\n        if list1 and not list2:\\n            dummy.next = list1\\n\\n        if not list1 and list2:\\n            dummy.next = list2\\n        \\n        return pre.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1198189,
                "title": "merge-sort-min-heap",
                "content": "To achive this, just try first to implement mergeSort at your own, then you\\'ll see is very easy to achive it iterative.\\n```\\nvar mergeKLists = function(lists) {\\n    \\n    const mergeSort = (arr) => {\\n        if(arr.length === 0) return null;\\n        if(arr.length === 1) return arr[0];\\n        const left = arr.splice(0, arr.length / 2);\\n        return merge(mergeSort(left), mergeSort(arr));\\n    }\\n    \\n    const merge = (a,b) => {\\n        const root = new ListNode();\\n        let aux = root;\\n        while(a && b) {\\n            if(a.val < b.val) {\\n                aux.next = a;\\n                a = a.next;\\n            } else {\\n                aux.next = b;\\n                b = b.next;\\n            }\\n            aux = aux.next;\\n        }\\n        aux.next =  a || b;\\n        return root.next;\\n    }\\n    \\n    return mergeSort(lists);\\n};\\n```\\n\\nThis was my first though to be honest.\\n```\\nvar mergeKListsMinHeap = function(lists) {\\n    let root = new ListNode();\\n    let aux = root;\\n    const heap = new MinHeap();\\n    \\n    for(const h of lists) {\\n        if(h) {\\n            heap.push(h);\\n        }\\n    }\\n\\n    while(!heap.isEmpty()) {\\n        const node = heap.pop();\\n        aux.next = node;\\n        aux = aux.next;\\n        if(node.next)\\n            heap.push(node.next);\\n    }\\n    \\n    return root.next;\\n};\\n\\nclass MinHeap {\\n    constructor() {\\n        this.heap = new Array(500);\\n        this.idx = 0;\\n    }\\n    \\n    size = () => this.idx;\\n    isEmpty = () => this.idx === 0;\\n    parent = (i) => (i-1) / 2 | 0;\\n    left = (i) => (i * 2) + 1;\\n    right = (i) => (i * 2) + 2;\\n\\n    isMin = (i, j) => this.heap[i].val < this.heap[j].val;\\n    swap = (a,b) => {\\n        const tmp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = tmp;\\n    }\\n\\n    push = (node) => {\\n        let i = this.idx;\\n        this.heap[this.idx++] = node;\\n        let p = this.parent(i);\\n        while(i > 0 && this.isMin(i, p)) {\\n            this.swap(i, p);\\n            p = this.parent(i = p);\\n        }\\n    }\\n    \\n    min = (i) => {\\n        let l = this.left(i);\\n        let r = this.right(i);\\n        let best = i;\\n        if(l < this.size() && this.isMin(l, best)) best = l;\\n        if(r < this.size() && this.isMin(r, best)) best = r;\\n        \\n        return this.isMin(i, best) ? i : best;\\n    }\\n    \\n    heapify = (i = 0) => {\\n        let best = this.min(i);\\n        while(best !== i) {\\n            this.swap(i, best);\\n            best = this.min(i = best);\\n        }\\n    }\\n    \\n    pop = () => {\\n        if(this.isEmpty()) return null;\\n        const n = this.heap[0];\\n        this.swap(0, --this.idx);\\n        this.heapify();\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeKLists = function(lists) {\\n    \\n    const mergeSort = (arr) => {\\n        if(arr.length === 0) return null;\\n        if(arr.length === 1) return arr[0];\\n        const left = arr.splice(0, arr.length / 2);\\n        return merge(mergeSort(left), mergeSort(arr));\\n    }\\n    \\n    const merge = (a,b) => {\\n        const root = new ListNode();\\n        let aux = root;\\n        while(a && b) {\\n            if(a.val < b.val) {\\n                aux.next = a;\\n                a = a.next;\\n            } else {\\n                aux.next = b;\\n                b = b.next;\\n            }\\n            aux = aux.next;\\n        }\\n        aux.next =  a || b;\\n        return root.next;\\n    }\\n    \\n    return mergeSort(lists);\\n};\\n```\n```\\nvar mergeKListsMinHeap = function(lists) {\\n    let root = new ListNode();\\n    let aux = root;\\n    const heap = new MinHeap();\\n    \\n    for(const h of lists) {\\n        if(h) {\\n            heap.push(h);\\n        }\\n    }\\n\\n    while(!heap.isEmpty()) {\\n        const node = heap.pop();\\n        aux.next = node;\\n        aux = aux.next;\\n        if(node.next)\\n            heap.push(node.next);\\n    }\\n    \\n    return root.next;\\n};\\n\\nclass MinHeap {\\n    constructor() {\\n        this.heap = new Array(500);\\n        this.idx = 0;\\n    }\\n    \\n    size = () => this.idx;\\n    isEmpty = () => this.idx === 0;\\n    parent = (i) => (i-1) / 2 | 0;\\n    left = (i) => (i * 2) + 1;\\n    right = (i) => (i * 2) + 2;\\n\\n    isMin = (i, j) => this.heap[i].val < this.heap[j].val;\\n    swap = (a,b) => {\\n        const tmp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = tmp;\\n    }\\n\\n    push = (node) => {\\n        let i = this.idx;\\n        this.heap[this.idx++] = node;\\n        let p = this.parent(i);\\n        while(i > 0 && this.isMin(i, p)) {\\n            this.swap(i, p);\\n            p = this.parent(i = p);\\n        }\\n    }\\n    \\n    min = (i) => {\\n        let l = this.left(i);\\n        let r = this.right(i);\\n        let best = i;\\n        if(l < this.size() && this.isMin(l, best)) best = l;\\n        if(r < this.size() && this.isMin(r, best)) best = r;\\n        \\n        return this.isMin(i, best) ? i : best;\\n    }\\n    \\n    heapify = (i = 0) => {\\n        let best = this.min(i);\\n        while(best !== i) {\\n            this.swap(i, best);\\n            best = this.min(i = best);\\n        }\\n    }\\n    \\n    pop = () => {\\n        if(this.isEmpty()) return null;\\n        const n = this.heap[0];\\n        this.swap(0, --this.idx);\\n        this.heapify();\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125283,
                "title": "rust-simple-solution-without-box-new",
                "content": "```\\nimpl Solution {\\n    pub fn merge_k_lists(mut xs: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let i = xs.iter().enumerate().min_by_key(|(_, x)| x.as_ref().map_or(std::i32::MAX, |x| x.val))?.0;\\n        let mut h = xs[i].take()?;\\n        xs[i] = h.next;\\n        h.next = Self::merge_k_lists(xs);\\n        Some(h)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn merge_k_lists(mut xs: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let i = xs.iter().enumerate().min_by_key(|(_, x)| x.as_ref().map_or(std::i32::MAX, |x| x.val))?.0;\\n        let mut h = xs[i].take()?;\\n        xs[i] = h.next;\\n        h.next = Self::merge_k_lists(xs);\\n        Some(h)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 862394,
                "title": "simple-java-solution-using-a-priority-queue",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(ListNode list: lists) {\\n            while(list != null) {\\n                pq.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        \\n        ListNode curr = new ListNode(0);\\n        ListNode head = curr;\\n        while(!pq.isEmpty()) {\\n            ListNode t = new ListNode(pq.poll());\\n            curr.next = t;\\n            curr = curr.next;\\n        }\\n        return head.next;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(ListNode list: lists) {\\n            while(list != null) {\\n                pq.add(list.val);\\n                list = list.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 659745,
                "title": "rust-binaryheap-solution",
                "content": "```rust\\nuse std::{cmp::Reverse, collections::BinaryHeap};\\n\\nimpl PartialOrd for ListNode {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        self.val.partial_cmp(&other.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.val.cmp(&other.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut min_heap = BinaryHeap::new();\\n        for list in lists {\\n            if let Some(node) = list {\\n                min_heap.push(Reverse(node));\\n            }\\n        }\\n        let mut dummy_head = ListNode::new(0);\\n        let mut cur = &mut dummy_head;\\n        while let Some(Reverse(node)) = min_heap.pop() {\\n            cur.next = Some(Box::new(ListNode::new(node.val)));\\n            cur = cur.next.as_mut().unwrap();\\n            if let Some(next) = node.next {\\n                min_heap.push(Reverse(next));\\n            }\\n        }\\n        return dummy_head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```rust\\nuse std::{cmp::Reverse, collections::BinaryHeap};\\n\\nimpl PartialOrd for ListNode {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        self.val.partial_cmp(&other.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.val.cmp(&other.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut min_heap = BinaryHeap::new();\\n        for list in lists {\\n            if let Some(node) = list {\\n                min_heap.push(Reverse(node));\\n            }\\n        }\\n        let mut dummy_head = ListNode::new(0);\\n        let mut cur = &mut dummy_head;\\n        while let Some(Reverse(node)) = min_heap.pop() {\\n            cur.next = Some(Box::new(ListNode::new(node.val)));\\n            cur = cur.next.as_mut().unwrap();\\n            if let Some(next) = node.next {\\n                min_heap.push(Reverse(next));\\n            }\\n        }\\n        return dummy_head.next;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502167,
                "title": "java-priority-queue-custom-comparing-class-as-min-heap-simple",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(new NodeComaprator());\\n\\n        for (ListNode listNode : lists) {\\n            ListNode node = listNode;\\n\\n            while (node != null) {\\n                minHeap.add(new ListNode(node.val));\\n                node = node.next;\\n            }\\n        }\\n        \\n        ListNode head = minHeap.isEmpty() ? null : minHeap.poll();\\n        ListNode curr = head;\\n        \\n        while(!minHeap.isEmpty()){\\n            curr.next = minHeap.poll();\\n            curr = curr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n\\nclass NodeComaprator implements Comparator<ListNode> {\\n    @Override\\n    public int compare(ListNode o1, ListNode o2) {\\n       return o1.val - o2.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(new NodeComaprator());\\n\\n        for (ListNode listNode : lists) {\\n            ListNode node = listNode;\\n\\n            while (node != null) {\\n                minHeap.add(new ListNode(node.val));\\n                node = node.next;\\n            }\\n        }\\n        \\n        ListNode head = minHeap.isEmpty() ? null : minHeap.poll();\\n        ListNode curr = head;\\n        \\n        while(!minHeap.isEmpty()){\\n            curr.next = minHeap.poll();\\n            curr = curr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n\\nclass NodeComaprator implements Comparator<ListNode> {\\n    @Override\\n    public int compare(ListNode o1, ListNode o2) {\\n       return o1.val - o2.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420969,
                "title": "rust-min-heap",
                "content": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap; // BinaryHeap is Max Heap in default\\n\\nimpl PartialOrd<ListNode> for ListNode {\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.val.cmp(&self.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut res = Box::new(ListNode::new(0));\\n        if lists.len() == 0 {\\n            return None;\\n        }\\n        let mut minHeap = BinaryHeap::new();\\n        for mut list in lists {\\n            if list.is_some() {\\n                minHeap.push(list.take()?); // Storing as Option<Box<ListNode>>\\n            }\\n        }\\n        let mut cur = &mut res;\\n        while !minHeap.is_empty() {\\n            cur.next = minHeap.pop(); // Return as Option<Box<ListNode>>\\n            cur = cur.next.as_mut()?;\\n            if cur.next.is_some() {\\n                minHeap.push(cur.next.take()?);\\n            }\\n        }\\n        res.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap; // BinaryHeap is Max Heap in default\\n\\nimpl PartialOrd<ListNode> for ListNode {\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.val.cmp(&self.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut res = Box::new(ListNode::new(0));\\n        if lists.len() == 0 {\\n            return None;\\n        }\\n        let mut minHeap = BinaryHeap::new();\\n        for mut list in lists {\\n            if list.is_some() {\\n                minHeap.push(list.take()?); // Storing as Option<Box<ListNode>>\\n            }\\n        }\\n        let mut cur = &mut res;\\n        while !minHeap.is_empty() {\\n            cur.next = minHeap.pop(); // Return as Option<Box<ListNode>>\\n            cur = cur.next.as_mut()?;\\n            if cur.next.is_some() {\\n                minHeap.push(cur.next.take()?);\\n            }\\n        }\\n        res.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278855,
                "title": "c-divide-and-conquer",
                "content": "```\\npublic class Solution {\\n    public ListNode MergeKLists(ListNode[] lists) {\\n        if (lists.Length == 0) return null;\\n        return DFS(lists, 0, lists.Length - 1);\\n    }\\n\\n    private ListNode DFS(ListNode[] lists, int left, int right) {\\n        if (left == right) {\\n            return lists[left];\\n        }\\n        var mid = left + (right - left) / 2;\\n        var leftSortedListNode = DFS(lists, left, mid);\\n        var rightSortedListNode = DFS(lists, mid + 1, right);\\n\\n        var mergedSortedListNode = MergeTwoLists(leftSortedListNode, rightSortedListNode);\\n        return mergedSortedListNode;\\n    }\\n\\n    private ListNode MergeTwoLists(ListNode l1, ListNode l2) {\\n        var dummy = new ListNode(-1);\\n\\n        var cur = dummy;\\n        var cur1 = l1;\\n        var cur2 = l2;\\n\\n        while (cur1 != null && cur2 != null) {\\n            if (cur1.val <= cur2.val) {\\n                cur.next = cur1;\\n                cur1 = cur1.next;\\n            } else {\\n                cur.next = cur2;\\n                cur2 = cur2.next;\\n            }\\n\\n            cur = cur.next;\\n        }\\n\\n        while (cur1 != null) {\\n            cur.next = cur1;\\n            cur = cur.next;\\n            cur1 = cur1.next;\\n        }\\n\\n        while (cur2 != null) {\\n            cur.next = cur2;\\n            cur = cur.next;\\n            cur2 = cur2.next;\\n        }\\n\\n        var newHead = dummy.next;\\n        dummy.next = null;\\n\\n        return newHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode MergeKLists(ListNode[] lists) {\\n        if (lists.Length == 0) return null;\\n        return DFS(lists, 0, lists.Length - 1);\\n    }\\n\\n    private ListNode DFS(ListNode[] lists, int left, int right) {\\n        if (left == right) {\\n            return lists[left];\\n        }\\n        var mid = left + (right - left) / 2;\\n        var leftSortedListNode = DFS(lists, left, mid);\\n        var rightSortedListNode = DFS(lists, mid + 1, right);\\n\\n        var mergedSortedListNode = MergeTwoLists(leftSortedListNode, rightSortedListNode);\\n        return mergedSortedListNode;\\n    }\\n\\n    private ListNode MergeTwoLists(ListNode l1, ListNode l2) {\\n        var dummy = new ListNode(-1);\\n\\n        var cur = dummy;\\n        var cur1 = l1;\\n        var cur2 = l2;\\n\\n        while (cur1 != null && cur2 != null) {\\n            if (cur1.val <= cur2.val) {\\n                cur.next = cur1;\\n                cur1 = cur1.next;\\n            } else {\\n                cur.next = cur2;\\n                cur2 = cur2.next;\\n            }\\n\\n            cur = cur.next;\\n        }\\n\\n        while (cur1 != null) {\\n            cur.next = cur1;\\n            cur = cur.next;\\n            cur1 = cur1.next;\\n        }\\n\\n        while (cur2 != null) {\\n            cur.next = cur2;\\n            cur = cur.next;\\n            cur2 = cur2.next;\\n        }\\n\\n        var newHead = dummy.next;\\n        dummy.next = null;\\n\\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221538,
                "title": "rust-4ms-no-clone",
                "content": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\n\\nimpl PartialOrd<ListNode> for ListNode {\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.val.cmp(&self.val)\\n    }\\n}\\n\\nimpl Solution {\\n    #[allow(dead_code)]\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut heap = BinaryHeap::new();\\n        for mut node in lists {\\n            if node.is_some() {\\n                heap.push(node.take()?)\\n            }\\n        }\\n        let mut head = heap.pop()?;\\n        let mut pointer = &mut head;\\n        while !heap.is_empty() {\\n            if pointer.next.is_some() {\\n                heap.push(pointer.next.take()?);\\n            }\\n            pointer.next = Some(heap.pop()?);\\n            pointer = pointer.next.as_mut()?;\\n        }\\n        Some(head)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\n\\nimpl PartialOrd<ListNode> for ListNode {\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.val.cmp(&self.val)\\n    }\\n}\\n\\nimpl Solution {\\n    #[allow(dead_code)]\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut heap = BinaryHeap::new();\\n        for mut node in lists {\\n            if node.is_some() {\\n                heap.push(node.take()?)\\n            }\\n        }\\n        let mut head = heap.pop()?;\\n        let mut pointer = &mut head;\\n        while !heap.is_empty() {\\n            if pointer.next.is_some() {\\n                heap.push(pointer.next.take()?);\\n            }\\n            pointer.next = Some(heap.pop()?);\\n            pointer = pointer.next.as_mut()?;\\n        }\\n        Some(head)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155642,
                "title": "python-beats-98-79",
                "content": "```\\n        if len(lists) == 0 : return None\\n        ls =[]\\n        for oneList in lists:\\n            while oneList:\\n                ls.append(oneList.val)\\n                oneList = oneList.next\\n        ls.sort()\\n        head = dumphead = ListNode(None)\\n        for one in ls:\\n            head.next = ListNode(one)\\n            head = head.next\\n        return dumphead.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        if len(lists) == 0 : return None\\n        ls =[]\\n        for oneList in lists:\\n            while oneList:\\n                ls.append(oneList.val)\\n                oneList = oneList.next\\n        ls.sort()\\n        head = dumphead = ListNode(None)\\n        for one in ls:\\n            head.next = ListNode(one)\\n            head = head.next\\n        return dumphead.next\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10833,
                "title": "java-easy-version-to-understand-two-methods",
                "content": "## Method1 ##\\n\\n    public static ListNode21 MergeSort(ListNode21 head1, ListNode21 head2) {\\n\\t\\tListNode21 head = new ListNode21(0), rear = head, p = head1, q = head2;\\n\\t\\thead.next = null;\\n\\t\\twhile (p != null && q != null) {\\n\\t\\t\\tif (p.val <= q.val) {\\n\\t\\t\\t\\trear.next = p;\\n\\t\\t\\t\\trear = rear.next;\\n\\t\\t\\t\\tp = p.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trear.next = q;\\n\\t\\t\\t\\trear = rear.next;\\n\\t\\t\\t\\tq = q.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (p != null)\\n\\t\\t\\trear.next = p;\\n\\t\\tif (q != null)\\n\\t\\t\\trear.next = q;\\n\\t\\treturn head.next;\\n\\t}\\n\\n\\tpublic static ListNode21 Sort(ListNode21[] lists, int low, int high) {\\n\\t\\tif (low < high) {\\n\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\tListNode21 head1 = Sort(lists, low, mid);\\n\\t\\t\\tListNode21 head2 = Sort(lists, mid + 1, high);\\n\\t\\t\\treturn MergeSort(head1, head2);\\n\\t\\t} else\\n\\t\\t\\treturn lists[low];\\n\\t}\\n\\n\\tpublic static ListNode21 mergeKLists(ListNode21[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tif (lists.length == 1)\\n\\t\\t\\treturn lists[0];\\n\\n\\t\\treturn Sort(lists, 0, lists.length - 1);\\n\\n\\t}\\n## Method2 ##\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tif (lists.length == 1)\\n\\t\\t\\treturn lists[0];\\n\\t\\tPriorityQueue<ListNode> heap = new PriorityQueue<>(new Comparator<ListNode>() {\\n\\t\\t\\tpublic int compare(ListNode o1, ListNode o2) {\\n\\t\\t\\t\\treturn o1.val - o2.val;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tListNode head = new ListNode(0), rear = head;\\n\\t\\thead.next = null;\\n\\t\\tfor (ListNode node : lists) {\\n\\t\\t      if (node != null)\\n\\t\\t\\t\\theap.offer(node);\\n\\t\\t}\\n\\n\\t\\twhile (!heap.isEmpty()) {\\n\\t\\t\\tListNode p = heap.poll();\\n\\t\\t\\trear.next = p;\\n\\t\\t\\trear = rear.next;\\n\\t\\t\\tp = p.next;\\n\\t\\t\\tif (p != null)\\n\\t\\t\\t\\theap.offer(p);\\n\\t\\t}\\n\\t\\trear.next = null;\\n\\t\\treturn head.next;\\n\\t}",
                "solutionTags": [],
                "code": "## Method1 ##\\n\\n    public static ListNode21 MergeSort(ListNode21 head1, ListNode21 head2) {\\n\\t\\tListNode21 head = new ListNode21(0), rear = head, p = head1, q = head2;\\n\\t\\thead.next = null;\\n\\t\\twhile (p != null && q != null) {\\n\\t\\t\\tif (p.val <= q.val) {\\n\\t\\t\\t\\trear.next = p;\\n\\t\\t\\t\\trear = rear.next;\\n\\t\\t\\t\\tp = p.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trear.next = q;\\n\\t\\t\\t\\trear = rear.next;\\n\\t\\t\\t\\tq = q.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (p != null)\\n\\t\\t\\trear.next = p;\\n\\t\\tif (q != null)\\n\\t\\t\\trear.next = q;\\n\\t\\treturn head.next;\\n\\t}\\n\\n\\tpublic static ListNode21 Sort(ListNode21[] lists, int low, int high) {\\n\\t\\tif (low < high) {\\n\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\tListNode21 head1 = Sort(lists, low, mid);\\n\\t\\t\\tListNode21 head2 = Sort(lists, mid + 1, high);\\n\\t\\t\\treturn MergeSort(head1, head2);\\n\\t\\t} else\\n\\t\\t\\treturn lists[low];\\n\\t}\\n\\n\\tpublic static ListNode21 mergeKLists(ListNode21[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tif (lists.length == 1)\\n\\t\\t\\treturn lists[0];\\n\\n\\t\\treturn Sort(lists, 0, lists.length - 1);\\n\\n\\t}\\n## Method2 ##\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tif (lists.length == 1)\\n\\t\\t\\treturn lists[0];\\n\\t\\tPriorityQueue<ListNode> heap = new PriorityQueue<>(new Comparator<ListNode>() {\\n\\t\\t\\tpublic int compare(ListNode o1, ListNode o2) {\\n\\t\\t\\t\\treturn o1.val - o2.val;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tListNode head = new ListNode(0), rear = head;\\n\\t\\thead.next = null;\\n\\t\\tfor (ListNode node : lists) {\\n\\t\\t      if (node != null)\\n\\t\\t\\t\\theap.offer(node);\\n\\t\\t}\\n\\n\\t\\twhile (!heap.isEmpty()) {\\n\\t\\t\\tListNode p = heap.poll();\\n\\t\\t\\trear.next = p;\\n\\t\\t\\trear = rear.next;\\n\\t\\t\\tp = p.next;\\n\\t\\t\\tif (p != null)\\n\\t\\t\\t\\theap.offer(p);\\n\\t\\t}\\n\\t\\trear.next = null;\\n\\t\\treturn head.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 10836,
                "title": "javascript-solution-with-graph-explanation",
                "content": "    var mergeKLists = function(lists) {\\n        \\n        var tempArry = [], listsLength;\\n        \\n        //Delete all empty entries.\\n        for (var i = 0; i < lists.length; ) {\\n            if (lists[i]) {\\n                i++;\\n            } else {\\n                lists.splice(i, 1);\\n            }\\n        }\\n        if (lists.length === 0) return [];\\n        \\n        while (lists.length > 1) {\\n            listsLength = lists.length;\\n            if (listsLength % 2 !== 0) {\\n                lists.push(null);\\n                listsLength++;\\n            }\\n            for (var i = 0; i < listsLength; i += 2) {\\n                tempArry.push(merge2Lists(lists[i], lists[i + 1]));\\n            }\\n            lists = tempArry;\\n            tempArry = [];\\n        }\\n        return lists[0];\\n        \\n        function merge2Lists(list1, list2) {\\n            var head = new ListNode(0), temp = head;\\n            while (list1 && list2) {\\n                if (list1.val < list2.val) {\\n                    temp.next = new ListNode(list1.val);\\n                    list1 = list1.next;\\n                } else {\\n                    temp.next = new ListNode(list2.val);\\n                    list2 = list2.next;\\n                }\\n                temp = temp.next;\\n            }\\n            temp.next = list1 ? list1 : list2;\\n            return head.next;\\n        }\\n    };\\n\\n\\n\\n    1  |   |  |   |  |   .\\n    2    |      |      |     .\\n    3        |            |\\n    4              |\\n\\nLine1 is an array, each element is a ListNode (as \"|\" in the graph). If the length of current array is odd, add an null element(as \".\" in the graph), compare them two by two ,put the results into a new array (line2). Keep doing until the length of the result array is 1, which means we merged all elements, and it is the result.",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "    var mergeKLists = function(lists) {\\n        \\n        var tempArry = [], listsLength;\\n        \\n        //Delete all empty entries.\\n        for (var i = 0; i < lists.length; ) {\\n            if (lists[i]) {\\n                i++;\\n            } else {\\n                lists.splice(i, 1);\\n            }\\n        }\\n        if (lists.length === 0) return [];\\n        \\n        while (lists.length > 1) {\\n            listsLength = lists.length;\\n            if (listsLength % 2 !== 0) {\\n                lists.push(null);\\n                listsLength++;\\n            }\\n            for (var i = 0; i < listsLength; i += 2) {\\n                tempArry.push(merge2Lists(lists[i], lists[i + 1]));\\n            }\\n            lists = tempArry;\\n            tempArry = [];\\n        }\\n        return lists[0];\\n        \\n        function merge2Lists(list1, list2) {\\n            var head = new ListNode(0), temp = head;\\n            while (list1 && list2) {\\n                if (list1.val < list2.val) {\\n                    temp.next = new ListNode(list1.val);\\n                    list1 = list1.next;\\n                } else {\\n                    temp.next = new ListNode(list2.val);\\n                    list2 = list2.next;\\n                }\\n                temp = temp.next;\\n            }\\n            temp.next = list1 ? list1 : list2;\\n            return head.next;\\n        }\\n    };\\n\\n\\n\\n    1  |   |  |   |  |   .\\n    2    |      |      |     .\\n    3        |            |\\n    4              |\\n\\nLine1 is an array, each element is a ListNode (as \"|\" in the graph). If the length of current array is odd, add an null element(as \".\" in the graph), compare them two by two ,put the results into a new array (line2). Keep doing until the length of the result array is 1, which means we merged all elements, and it is the result.",
                "codeTag": "Unknown"
            },
            {
                "id": 10924,
                "title": "java-merge-sort-version",
                "content": "    public class Solution {\\n    \\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0 ){\\n            return null;\\n        }\\n        return mergeKLists(lists,0,lists.length-1);\\n    }\\n    \\n    public ListNode mergeKLists(ListNode[] lists, int left, int right){\\n        if(left < right){\\n            int mid = (left + right)/2;\\n            return merge(mergeKLists(lists,left,mid),mergeKLists(lists,mid+1,right));\\n        }\\n        return lists[left];\\n    }\\n    \\n    public ListNode merge(ListNode n1, ListNode n2){\\n        ListNode head =  new ListNode(0);\\n        ListNode n = head;\\n        while(n1 != null && n2 != null){\\n            if(n1.val < n2.val){\\n                n.next = n1;\\n                n1 = n1.next;\\n                n = n.next;\\n            }else{\\n                n.next = n2;\\n                n = n.next;\\n                n2 = n2.next;\\n            }\\n        }\\n        if( n1 != null){\\n            n.next = n1;\\n        }else{\\n            n.next = n2;\\n        }\\n        return head.next;\\n    }\\n \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0 ){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3896470,
                "title": "map",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        map<int, int> mp;\\n        int k = lists.size();\\n\\n        for (int i=0; i<k; i++) {\\n            ListNode *node = lists[i];\\n            while (node) {\\n                mp[node->val]++;\\n                node = node->next;\\n            }\\n        }\\n\\n        ListNode* res = new ListNode();\\n        ListNode* head = res;\\n\\n        for (auto [num, freq]: mp) {\\n            while (freq--) {\\n                res->next = new ListNode(num);\\n                res = res->next;\\n            }\\n        }\\n\\n        return head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        map<int, int> mp;\\n        int k = lists.size();\\n\\n        for (int i=0; i<k; i++) {\\n            ListNode *node = lists[i];\\n            while (node) {\\n                mp[node->val]++;\\n                node = node->next;\\n            }\\n        }\\n\\n        ListNode* res = new ListNode();\\n        ListNode* head = res;\\n\\n        for (auto [num, freq]: mp) {\\n            while (freq--) {\\n                res->next = new ListNode(num);\\n                res = res->next;\\n            }\\n        }\\n\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289037,
                "title": "easy-python-solution-using-lists-runtime-67ms-97-85-conversion-of-linked-list-to-list",
                "content": "![image.png](https://assets.leetcode.com/users/images/e935d42c-c04e-45e9-b216-b33d31fe1917_1678638712.3862686.png)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        lst=[]\\n        for i in lists:\\n            while i:\\n                lst.append(i.val)\\n                i=i.next\\n        lst.sort()\\n        a=ListNode(0)\\n        tmp=a\\n        for i in lst:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return a.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Divide and Conquer",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        lst=[]\\n        for i in lists:\\n            while i:\\n                lst.append(i.val)\\n                i=i.next\\n        lst.sort()\\n        a=ListNode(0)\\n        tmp=a\\n        for i in lst:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return a.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287123,
                "title": "python-short-and-clean-heap-priority-queue",
                "content": "# Approach\\n1. Throw the head of each non empty `LinkedList` into a `min_heap`.\\n\\n2. Pop the `node` with smallest value and append it to the `Merged LinkedList`.\\n\\n3. Put back the `node.next` into the `min_heap`.\\n\\n4. Continue until the heap is empty.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(k))$$\\n\\n- Space complexity: $$O(k)$$\\n\\nwhere,\\n`k is the number of LinkedLists in lists`,\\n`n is the total number of nodes across all lists`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def mergeKLists(self, lists: list[ListNode | None]) -> ListNode | None:\\n        ListNode.__lt__ = lambda self, x: self.val < x.val\\n\\n        merged_head = merged_tail = ListNode()\\n        hq = [ll for ll in lists if ll is not None]\\n        heapify(hq)\\n\\n        while hq:\\n            node = heappop(hq)\\n            if node.next: heappush(hq, node.next)\\n            \\n            merged_tail.next = ListNode(node.val)\\n            merged_tail = merged_tail.next\\n        \\n        return merged_head.next\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def mergeKLists(self, lists: list[ListNode | None]) -> ListNode | None:\\n        ListNode.__lt__ = lambda self, x: self.val < x.val\\n\\n        merged_head = merged_tail = ListNode()\\n        hq = [ll for ll in lists if ll is not None]\\n        heapify(hq)\\n\\n        while hq:\\n            node = heappop(hq)\\n            if node.next: heappush(hq, node.next)\\n            \\n            merged_tail.next = ListNode(node.val)\\n            merged_tail = merged_tail.next\\n        \\n        return merged_head.next\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286924,
                "title": "two-pointer-approach-o-n-c-fully-explained",
                "content": "# Intuition\\nGiven that the input linked lists are already sorted, a simple approach to merge them would be to repeatedly merge pairs of lists until only one is left, and return the final merged list. This can be achieved by iterating over the input list of linked lists, and merging the current list with the previously merged list. The merged list can then be used as the input for the next iteration, until all the lists have been merged into one. Once the merging is complete, the final merged list can be returned.link\\n\\n# Approach\\nThe $$solver()$$ function takes in two ListNode pointers, a and b, which represent the heads of two sorted linked lists. It then iteratively compares the values of the nodes in the two linked lists and merges them into a new linked list in sorted order. Once one of the linked lists is exhausted, the remaining nodes in the other list are appended to the new linked list. Finally, the function returns the head of the new merged linked list.\\n\\nThe $$solver()$$ function creates a new dummy node with a value of -1 to serve as the head of the new merged linked list. The new nodes are then appended to this dummy node, and its next pointer is updated to point to the next new node. At the end of the function, the head of the merged list is returned by accessing the next pointer of the dummy node.\\n\\nThe $$mergeKLists()$$ function creates a new dummy node with a value of -100000 to serve as the head of the final merged linked list. It then iterates over the vector of ListNode pointers, repeatedly merging pairs of linked lists using the $$solver()$$ function. The final merged linked list is returned by accessing the next pointer of the dummy node.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* solver(ListNode* a, ListNode* b){\\n        if(!a) return b;\\n        if(!b) return a;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* r = res;\\n        while(a && b){\\n            if(a->val<b->val){\\n                res->next = a;\\n                res = res->next;\\n                a = a->next;\\n            }\\n            else{\\n                res->next = b;\\n                res = res->next;\\n                b = b->next;\\n            }\\n        }\\n        while(a){\\n            res->next = a;\\n            res = res->next;\\n            a = a->next;\\n        }\\n        while(b){\\n            res->next = b;\\n            res = res->next;\\n            b = b->next;\\n        }\\n        return r->next;\\n    }\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* res = new ListNode(-100000);\\n        for(int i =0;i<lists.size();i++){\\n            res = solver(res,lists[i]);\\n        }\\n        return res->next;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if it helped you.**",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* solver(ListNode* a, ListNode* b){\\n        if(!a) return b;\\n        if(!b) return a;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* r = res;\\n        while(a && b){\\n            if(a->val<b->val){\\n                res->next = a;\\n                res = res->next;\\n                a = a->next;\\n            }\\n            else{\\n                res->next = b;\\n                res = res->next;\\n                b = b->next;\\n            }\\n        }\\n        while(a){\\n            res->next = a;\\n            res = res->next;\\n            a = a->next;\\n        }\\n        while(b){\\n            res->next = b;\\n            res = res->next;\\n            b = b->next;\\n        }\\n        return r->next;\\n    }\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* res = new ListNode(-100000);\\n        for(int i =0;i<lists.size();i++){\\n            res = solver(res,lists[i]);\\n        }\\n        return res->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286172,
                "title": "java-solution-using-priorityqueue",
                "content": "# code\\n- just use priority queue\\n- make a list node of ans\\n- then keep curr to add the elements to ans\\n- then pop from the  priority queue and then move curr to next check if the next element of curr is not null if not null then offer the next element to queue\\n- if this was helpful like++\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode>pq= new PriorityQueue<ListNode>((a,b)-> a.val-b.val);\\n        if(lists==null || lists.length==0) return null;\\n        for(ListNode x:lists)\\n        {\\n            if(x!=null)\\n            pq.offer(x);\\n        }\\n        ListNode ans=new ListNode(-1);\\n        ListNode curr=ans;\\n        while(!pq.isEmpty())\\n        {\\n            curr.next=pq.poll();\\n            curr=curr.next;\\n            if(curr.next!=null)\\n                pq.offer(curr.next);\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode>pq= new PriorityQueue<ListNode>((a,b)-> a.val-b.val);\\n        if(lists==null || lists.length==0) return null;\\n        for(ListNode x:lists)\\n        {\\n            if(x!=null)\\n            pq.offer(x);\\n        }\\n        ListNode ans=new ListNode(-1);\\n        ListNode curr=ans;\\n        while(!pq.isEmpty())\\n        {\\n            curr.next=pq.poll();\\n            curr=curr.next;\\n            if(curr.next!=null)\\n                pq.offer(curr.next);\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286041,
                "title": "two-solutions-using-minheap-and-ordered-set",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogK), where K is the number of Sorted Lists/lists.size(), since at a time *atmost* K elements in MinHeap or OrderedSet\\n\\n- Space complexity:\\nO(N)\\n\\n# Using Min_Heap\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>&lists) \\n    {\\n        //instead of checking everytime k lists and appending minimum of all to our answer list, maintain priority queue which gives us the minimum element in O(1) instead of O(K), where K is number of lists.\\n        //Sure O(logN) time would be required to insert and delete but its far off better than linear time\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minheap;//value,index of ListNode in vector\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                minheap.push({lists[i]->val,i});\\n            }\\n        }\\n        if(minheap.empty())//Edge Case Handling\\n        {\\n            return NULL;\\n        }\\n        ListNode* node=new ListNode();\\n        ListNode* head=node;//store the head of ans\\n        while(1)\\n        {\\n            pair<int,int>x=minheap.top();\\n            minheap.pop();\\n            node->val=x.first;\\n            if(lists[x.second]->next!=NULL)//check if end of list not reached\\n            {\\n                lists[x.second]=lists[x.second]->next;//traverse list further\\n                minheap.push({lists[x.second]->val,x.second});//push value of current pointer at this list\\n            }\\n            if(!minheap.empty())//still elements exist to insert in list\\n            {\\n                node->next=new ListNode();\\n                node=node->next;\\n            }\\n            else//all elements inserted and lists traversed\\n            {\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n# Using Ordered_Set\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>&lists) \\n    {\\n        //same concept of pair as before\\n        set<pair<int,int>>listmin;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                listmin.insert({lists[i]->val,i});\\n            }\\n        }\\n        if(listmin.empty())\\n        {\\n            return NULL;\\n        }\\n        ListNode* node=new ListNode();\\n        ListNode* head=node;\\n        while(1)\\n        {\\n            pair<int,int>x=*(listmin.begin());\\n            listmin.erase(listmin.begin());\\n            node->val=x.first;\\n            if(lists[x.second]->next!=NULL)\\n            {\\n                lists[x.second]=lists[x.second]->next;\\n                listmin.insert({lists[x.second]->val,x.second});\\n            }\\n            if(!listmin.empty())\\n            {\\n                node->next=new ListNode();\\n                node=node->next;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>&lists) \\n    {\\n        //instead of checking everytime k lists and appending minimum of all to our answer list, maintain priority queue which gives us the minimum element in O(1) instead of O(K), where K is number of lists.\\n        //Sure O(logN) time would be required to insert and delete but its far off better than linear time\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minheap;//value,index of ListNode in vector\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                minheap.push({lists[i]->val,i});\\n            }\\n        }\\n        if(minheap.empty())//Edge Case Handling\\n        {\\n            return NULL;\\n        }\\n        ListNode* node=new ListNode();\\n        ListNode* head=node;//store the head of ans\\n        while(1)\\n        {\\n            pair<int,int>x=minheap.top();\\n            minheap.pop();\\n            node->val=x.first;\\n            if(lists[x.second]->next!=NULL)//check if end of list not reached\\n            {\\n                lists[x.second]=lists[x.second]->next;//traverse list further\\n                minheap.push({lists[x.second]->val,x.second});//push value of current pointer at this list\\n            }\\n            if(!minheap.empty())//still elements exist to insert in list\\n            {\\n                node->next=new ListNode();\\n                node=node->next;\\n            }\\n            else//all elements inserted and lists traversed\\n            {\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>&lists) \\n    {\\n        //same concept of pair as before\\n        set<pair<int,int>>listmin;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                listmin.insert({lists[i]->val,i});\\n            }\\n        }\\n        if(listmin.empty())\\n        {\\n            return NULL;\\n        }\\n        ListNode* node=new ListNode();\\n        ListNode* head=node;\\n        while(1)\\n        {\\n            pair<int,int>x=*(listmin.begin());\\n            listmin.erase(listmin.begin());\\n            node->val=x.first;\\n            if(lists[x.second]->next!=NULL)\\n            {\\n                lists[x.second]=lists[x.second]->next;\\n                listmin.insert({lists[x.second]->val,x.second});\\n            }\\n            if(!listmin.empty())\\n            {\\n                node->next=new ListNode();\\n                node=node->next;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219544,
                "title": "easy-peasy-python-solution-cheers",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if not lists or len(lists)==0:\\n            return None\\n        while len(lists)>1:\\n            combined_lists=[]\\n            for i in range(0,len(lists),2):\\n                list1=lists[i]\\n                list2=lists[i+1] if (i+1) <len(lists) else None\\n                combined_lists.append(self.merge_list(list1,list2))\\n            lists=combined_lists\\n        return lists[0]\\n\\n\\n    def merge_list(self,x,y):\\n        dummy=ListNode()\\n        tail=dummy  \\n        while x and y:\\n            if x.val < y.val:\\n                tail.next=x\\n                x=x.next\\n            else:\\n                tail.next=y\\n                y=y.next\\n            tail=tail.next\\n        if x:\\n            tail.next=x\\n        if y:\\n            tail.next=y\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if not lists or len(lists)==0:\\n            return None\\n        while len(lists)>1:\\n            combined_lists=[]\\n            for i in range(0,len(lists),2):\\n                list1=lists[i]\\n                list2=lists[i+1] if (i+1) <len(lists) else None\\n                combined_lists.append(self.merge_list(list1,list2))\\n            lists=combined_lists\\n        return lists[0]\\n\\n\\n    def merge_list(self,x,y):\\n        dummy=ListNode()\\n        tail=dummy  \\n        while x and y:\\n            if x.val < y.val:\\n                tail.next=x\\n                x=x.next\\n            else:\\n                tail.next=y\\n                y=y.next\\n            tail=tail.next\\n        if x:\\n            tail.next=x\\n        if y:\\n            tail.next=y\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207548,
                "title": "c-hash-map-solution-95-96",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        map<int, int> mp;\\n        for(auto& ln : lists){\\n            while(ln){\\n                mp[ln->val]++;\\n                ln = ln->next;\\n            }\\n        }\\n        if(!mp.size())  return nullptr;\\n        ListNode* ans = new ListNode();\\n        ListNode* p = ans;\\n        for(auto& v: mp){\\n            for(int i{}; i<v.second; i++){\\n                p->next = new ListNode(v.first);\\n                p = p->next;\\n            }\\n            \\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        map<int, int> mp;\\n        for(auto& ln : lists){\\n            while(ln){\\n                mp[ln->val]++;\\n                ln = ln->next;\\n            }\\n        }\\n        if(!mp.size())  return nullptr;\\n        ListNode* ans = new ListNode();\\n        ListNode* p = ans;\\n        for(auto& v: mp){\\n            for(int i{}; i<v.second; i++){\\n                p->next = new ListNode(v.first);\\n                p = p->next;\\n            }\\n            \\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173495,
                "title": "easy-min-heap-c-solution-step-wise-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPick the smallest node from the head of `k` lists and then move the `head` of the smallest node to `head->next`. We can continue doing this process till we exhaust all lists.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a min heap of `k` size .\\n- To the tail of answer list , append the top of the min heap.\\n- Save the top pointer of min heap as `temp`.\\n- pop the top of heap .\\n- Append next pointer of `temp` i.e `temp->next` again to min heap if its not NULL.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Compare {\\n    public:\\n       bool operator()(ListNode* a, ListNode* b){\\n           \\n           return a->val > b->val;\\n      }\\n};\\nclass Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k=lists.size();\\n        ListNode *head=NULL;\\n        ListNode *tail=NULL;\\n        priority_queue< ListNode*, vector<ListNode*> , Compare > pq;\\n        for(int i=0 ; i<k ;i++)\\n        {\\n            if(lists[i]!=NULL)\\n                pq.push(lists[i]);\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            ListNode* temp=pq.top();  \\n            pq.pop();\\n\\n            if(head==NULL && tail==NULL){\\n                head=temp;\\n                tail=temp;\\n            }\\n            else{\\n                tail->next=temp;\\n                tail=tail->next;\\n            }\\n\\n            temp=temp->next;\\n            if(temp!=NULL)\\n                pq.push(temp);\\n        }\\n\\n        return head;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: `O( N log k ) `\\n    - `O(log k)` for inserting one node in the min heap.\\n    - There are `N` node to be inserted.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`\\n    - `N` new nodes are created for answer list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Note\\n- Instead of using a custom comparator class for a min heap we can use a `pair< -value , list_pointer >` based priority_queue.\\n ```\\n priority_queue< pair<int,ListNode*> > pq;\\n```\\n- while pushing the value in priority queue make sure you push the negative values because this is a max heap and adding a `- value` of the list will make sure the smallest absolute value `|-value|` is at the top of heap.\\n```\\npq.push( { -lists[i]->val , lists[i] } );\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Compare {\\n    public:\\n       bool operator()(ListNode* a, ListNode* b){\\n           \\n           return a->val > b->val;\\n      }\\n};\\nclass Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k=lists.size();\\n        ListNode *head=NULL;\\n        ListNode *tail=NULL;\\n        priority_queue< ListNode*, vector<ListNode*> , Compare > pq;\\n        for(int i=0 ; i<k ;i++)\\n        {\\n            if(lists[i]!=NULL)\\n                pq.push(lists[i]);\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            ListNode* temp=pq.top();  \\n            pq.pop();\\n\\n            if(head==NULL && tail==NULL){\\n                head=temp;\\n                tail=temp;\\n            }\\n            else{\\n                tail->next=temp;\\n                tail=tail->next;\\n            }\\n\\n            temp=temp->next;\\n            if(temp!=NULL)\\n                pq.push(temp);\\n        }\\n\\n        return head;\\n    }\\n};\\n```\n```\\n priority_queue< pair<int,ListNode*> > pq;\\n```\n```\\npq.push( { -lists[i]->val , lists[i] } );\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682524,
                "title": "simple-cpp-approach-using-priority-queue",
                "content": "My solution took 39ms and faster that 69.61 % and is easy to understand and implement\\n* * In the below solution i have used min heap which will traverse all the linked list and create a min heap of values \\n* After storing all the values we can traverse min heap extract value from there create node of the value and generate a new linked list\\nNote:- In starting we also initialize a dummy node (-1) and we keep on adding our nodes into its next till the min heap become empty and at last return dummy->next\\n\\nBelow is the CPP Code\\n```\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        \\n        ListNode *head = new ListNode(-1);\\n        ListNode *node = head;\\n        int n = lists.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            ListNode *newhead = lists[i];\\n            while(newhead!=NULL)\\n            {\\n                pq.push(newhead->val);\\n                newhead = newhead->next;\\n            }\\n        }\\n        while(pq.empty()!=true)\\n        {\\n            node->next = new ListNode(pq.top());\\n            pq.pop();\\n            node = node->next;\\n        }\\n        return head->next;\\n    }\\n```\\n**If you find my solution helpful and understood well please dont forget to upvote and comment or if you have any suggestion to give**\\n**Happy Coding  !!!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        \\n        ListNode *head = new ListNode(-1);\\n        ListNode *node = head;\\n        int n = lists.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            ListNode *newhead = lists[i];\\n            while(newhead!=NULL)\\n            {\\n                pq.push(newhead->val);\\n                newhead = newhead->next;\\n            }\\n        }\\n        while(pq.empty()!=true)\\n        {\\n            node->next = new ListNode(pq.top());\\n            pq.pop();\\n            node = node->next;\\n        }\\n        return head->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668940,
                "title": "c-priority-queue-easy-to-understand-well-explained",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n     \\n        int n = lists.size();\\n\\t\\t// if size of lists is zero then return zero.\\n        if(n == 0)\\n        {\\n            return NULL;\\n        }\\n\\t\\t// initialize min heap/ min(priority queue). \\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        int i;\\n\\t\\t// iterate the lists and store each element of each list in priority queue.\\n\\t\\t// in min heap/priority queue every time we pop element from the top the top element will the smallest of all elements in heap.\\n\\t\\t\\n        for(i=0;i<n;i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp != NULL)\\n            {\\n                pq.push(temp->val);\\n                temp = temp->next;\\n            }\\n        }\\n          // so we take the advantage of priority queue and every time pop the smallest element from the heap.\\n         // now make a new linked list and return  sorted linked list  .\\n      \\n\\t  ListNode* start = new ListNode(0);\\n        ListNode* head = start;\\n        while(!pq.empty())\\n        {\\n            head->next = new ListNode(pq.top());\\n            pq.pop();\\n            head = head->next;\\n        }\\n        return start->next;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n     \\n        int n = lists.size();\\n\\t\\t// if size of lists is zero then return zero.\\n        if(n == 0)\\n        {\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2642666,
                "title": "easy-to-understand-solution-for-beginners-using-vector-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); \\n        \\n        if(k==0) return NULL;\\n        vector<int> datum;\\n        \\n        for(int i=0; i<lists.size(); i++){\\n            ListNode* temp = lists[i];\\n            while(temp){\\n                datum.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(datum.size()==NULL) return NULL;\\n        sort(datum.begin(), datum.end());\\n        \\n        int cnt=0;\\n        ListNode* res = new ListNode();\\n        ListNode* head = res;\\n        \\n        for(int &i: datum){\\n            res->val = i;\\n            cnt++;\\n            if(cnt!=datum.size()){\\n                ListNode* newNode = new ListNode();\\n                res->next=newNode;\\n                res=res->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); \\n        \\n        if(k==0) return NULL;\\n        vector<int> datum;\\n        \\n        for(int i=0; i<lists.size(); i++){\\n            ListNode* temp = lists[i];\\n            while(temp){\\n                datum.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(datum.size()==NULL) return NULL;\\n        sort(datum.begin(), datum.end());\\n        \\n        int cnt=0;\\n        ListNode* res = new ListNode();\\n        ListNode* head = res;\\n        \\n        for(int &i: datum){\\n            res->val = i;\\n            cnt++;\\n            if(cnt!=datum.size()){\\n                ListNode* newNode = new ListNode();\\n                res->next=newNode;\\n                res=res->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515362,
                "title": "python-easy-o-n-logn",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        \\n        if not lists or len(lists)==0:\\n            return None\\n        \\n        \\n        while(len(lists)>1):\\n            mergedlist =[]\\n            \\n            for i in range(0,len(lists),2):\\n                \\n                l1 = lists[i]\\n                l2 = lists[i+1] if i+1<len(lists) else None\\n                \\n                mergedlist.append(self.mergetwo(l1,l2))\\n                \\n            lists = mergedlist\\n            \\n        return lists[0]\\n    \\n    def mergetwo(self,l1,l2):\\n        \\n        dummy = ListNode()\\n        tail = dummy\\n        \\n        while l1 and l2:\\n            if l1.val<l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n                \\n            tail = tail.next\\n            \\n            \\n        if l1:\\n            tail.next = l1\\n            \\n        if l2:\\n            tail.next = l2\\n            \\n        return dummy.next    \\n           \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        \\n        if not lists or len(lists)==0:\\n            return None\\n        \\n        \\n        while(len(lists)>1):\\n            mergedlist =[]\\n            \\n            for i in range(0,len(lists),2):\\n                \\n                l1 = lists[i]\\n                l2 = lists[i+1] if i+1<len(lists) else None\\n                \\n                mergedlist.append(self.mergetwo(l1,l2))\\n                \\n            lists = mergedlist\\n            \\n        return lists[0]\\n    \\n    def mergetwo(self,l1,l2):\\n        \\n        dummy = ListNode()\\n        tail = dummy\\n        \\n        while l1 and l2:\\n            if l1.val<l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n                \\n            tail = tail.next\\n            \\n            \\n        if l1:\\n            tail.next = l1\\n            \\n        if l2:\\n            tail.next = l2\\n            \\n        return dummy.next    \\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383609,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-july-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/f9u8nVkh/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/f9u8nVkh/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "codeTag": "Unknown"
            },
            {
                "id": 1848828,
                "title": "easy-python-min-heap-solution-faster-than-87",
                "content": "Heap is the best data structure for this problem.\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        min_heap = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                min_heap.append((lists[i].val, i))\\n        heapq.heapify(min_heap)\\n        \\n        res = current = ListNode()\\n        \\n        while len(min_heap): \\n            ID = heapq.heappop(min_heap)[1]\\n            current.next = lists[ID]\\n            current = current.next\\n            lists[ID] = lists[ID].next\\n            if lists[ID]:\\n                heapq.heappush(min_heap, (lists[ID].val, ID))\\n                \\n        return res.next\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        min_heap = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                min_heap.append((lists[i].val, i))\\n        heapq.heapify(min_heap)\\n        \\n        res = current = ListNode()\\n        \\n        while len(min_heap): \\n            ID = heapq.heappop(min_heap)[1]\\n            current.next = lists[ID]\\n            current = current.next\\n            lists[ID] = lists[ID].next\\n            if lists[ID]:\\n                heapq.heappush(min_heap, (lists[ID].val, ID))\\n                \\n        return res.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775553,
                "title": "merge-k-sorted-lists-min-priority-queue-brute-force-easy-way",
                "content": "So My approach was the simpler one,\\n\\nFirst traverse the all given linked list and store their values in a min priority queue and then make a linked list out of it.\\n\\n```\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<int, vector<int> ,greater<int>> pq;\\n        \\n        for(int i =0;i<lists.size();i++){\\n            ListNode* head= lists[i];\\n            while(head != NULL){\\n                pq.push(head->val);\\n                head=head->next;\\n            }\\n        }\\n        \\n        \\n       ListNode* head = NULL;\\n       ListNode* tail = NULL;\\n\\n        while(!pq.empty()){\\n            ListNode * newNode = new ListNode (pq.top());\\n            pq.pop();\\n            \\n            if(head== NULL){\\n                head= newNode;\\n                tail = newNode;\\n            }else{\\n                tail->next = newNode;\\n                tail = tail->next;\\n            }\\n            \\n        }\\n    return head;\\n    }\\n```\\nSuggestions are always welcomed ! :)\\nthank you for giving your time , If you liked this please upvote",
                "solutionTags": [
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<int, vector<int> ,greater<int>> pq;\\n        \\n        for(int i =0;i<lists.size();i++){\\n            ListNode* head= lists[i];\\n            while(head != NULL){\\n                pq.push(head->val);\\n                head=head->next;\\n            }\\n        }\\n        \\n        \\n       ListNode* head = NULL;\\n       ListNode* tail = NULL;\\n\\n        while(!pq.empty()){\\n            ListNode * newNode = new ListNode (pq.top());\\n            pq.pop();\\n            \\n            if(head== NULL){\\n                head= newNode;\\n                tail = newNode;\\n            }else{\\n                tail->next = newNode;\\n                tail = tail->next;\\n            }\\n            \\n        }\\n    return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747547,
                "title": "python-3-90ms-divide-and-conquer-approach",
                "content": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if not len(lists):\\n            return None\\n        \\n        while len(lists) > 1:\\n            newLists = [] \\n            for i in range(0, len(lists), 2):\\n                LL1 = lists[i]\\n                LL2 = lists[i + 1] if (i + 1) < len(lists) else None\\n                mergedList = self.merge2List(LL1, LL2)\\n                newLists.append(mergedList)\\n            lists = newLists\\n        return lists[0]\\n                \\n    def merge2List(self, l1, l2):\\n        dummy = ListNode()\\n        current = dummy\\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                current.next = l1\\n                l1 = l1.next\\n            else:\\n                current.next = l2\\n                l2 = l2.next\\n            current = current.next\\n        if l1:\\n            current.next = l1\\n        if l2:\\n            current.next = l2\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if not len(lists):\\n            return None\\n        \\n        while len(lists) > 1:\\n            newLists = [] \\n            for i in range(0, len(lists), 2):\\n                LL1 = lists[i]\\n                LL2 = lists[i + 1] if (i + 1) < len(lists) else None\\n                mergedList = self.merge2List(LL1, LL2)\\n                newLists.append(mergedList)\\n            lists = newLists\\n        return lists[0]\\n                \\n    def merge2List(self, l1, l2):\\n        dummy = ListNode()\\n        current = dummy\\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                current.next = l1\\n                l1 = l1.next\\n            else:\\n                current.next = l2\\n                l2 = l2.next\\n            current = current.next\\n        if l1:\\n            current.next = l1\\n        if l2:\\n            current.next = l2\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746615,
                "title": "c-simple-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* merge(ListNode* list1, ListNode* list2)\\n    {\\n        if(list1==NULL)\\n            return list2;\\n        if(list2==NULL)\\n            return list1;\\n        \\n        ListNode* res;\\n        if(list1->val < list2->val)\\n        {\\n            res=list1;\\n            res->next=merge(list1->next,list2);\\n        }\\n        else\\n        {\\n            res=list2;\\n            res->next=merge(list1,list2->next);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& v) {\\n        \\n        if(v.size()==0)\\n            return NULL;\\n        \\n        while(v.size()!=1)\\n        {\\n            ListNode* x=v[0];\\n            v.erase(v.begin());\\n            ListNode* y=v[0];\\n            v.erase(v.begin());\\n            ListNode* z=merge(x,y);\\n            v.push_back(z);\\n        }\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* merge(ListNode* list1, ListNode* list2)\\n    {\\n        if(list1==NULL)\\n            return list2;\\n        if(list2==NULL)\\n            return list1;\\n        \\n        ListNode* res;\\n        if(list1->val < list2->val)\\n        {\\n            res=list1;\\n            res->next=merge(list1->next,list2);\\n        }\\n        else\\n        {\\n            res=list2;\\n            res->next=merge(list1,list2->next);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& v) {\\n        \\n        if(v.size()==0)\\n            return NULL;\\n        \\n        while(v.size()!=1)\\n        {\\n            ListNode* x=v[0];\\n            v.erase(v.begin());\\n            ListNode* y=v[0];\\n            v.erase(v.begin());\\n            ListNode* z=merge(x,y);\\n            v.push_back(z);\\n        }\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746231,
                "title": "merge-sort-c",
                "content": "# C++\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeList(ListNode *p, ListNode *q) {\\n        ListNode *start = new ListNode(-1);\\n        ListNode *head = new ListNode;\\n        head = start;\\n        while (p && q) {\\n            if (p->val > q->val) {\\n                start->next = q;\\n                q = q->next;\\n            }\\n            else {\\n                start->next = p;\\n                p = p->next;\\n            }\\n            start = start->next;\\n        }\\n        while(p) {\\n            start->next = p;\\n            start = start->next;\\n            p = p->next;\\n        }\\n        while(q) {\\n            start->next = q;\\n            start = start->next;\\n            q = q->next;\\n        }\\n        return head->next;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0) return nullptr;\\n        \\n        ListNode *head = new ListNode;\\n        head = lists[0];\\n        \\n        for (int i = 1; i < lists.size(); i++) {\\n            head = mergeList(lists[i], head);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Feel free to ask doubts\\nAnd please share some suggetsions\\nHAPPY CODING :)**",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeList(ListNode *p, ListNode *q) {\\n        ListNode *start = new ListNode(-1);\\n        ListNode *head = new ListNode;\\n        head = start;\\n        while (p && q) {\\n            if (p->val > q->val) {\\n                start->next = q;\\n                q = q->next;\\n            }\\n            else {\\n                start->next = p;\\n                p = p->next;\\n            }\\n            start = start->next;\\n        }\\n        while(p) {\\n            start->next = p;\\n            start = start->next;\\n            p = p->next;\\n        }\\n        while(q) {\\n            start->next = q;\\n            start = start->next;\\n            q = q->next;\\n        }\\n        return head->next;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0) return nullptr;\\n        \\n        ListNode *head = new ListNode;\\n        head = lists[0];\\n        \\n        for (int i = 1; i < lists.size(); i++) {\\n            head = mergeList(lists[i], head);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399908,
                "title": "c-recursive-soln",
                "content": "If you have done merge two sorted lists then its so easy.\\nTake one node with nullptr(say ans);\\nWrite a function which takes two nodes ,merges them and return the head of the result list;\\nJust traverse through the vector call the function with ans and node in vector and assign the return value to ans;\\nAt last return ans;  **BINGO!!**\\n```\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0)\\n            return NULL;\\n        ListNode* head=lists[0];\\n        for(int i=1;i<lists.size();i++)\\n            head=solve(head,lists[i]);\\n        return head;\\n    }\\n    ListNode* solve(ListNode* l,ListNode* r){\\n        if(!l)\\n            return r;\\n        if(!r)\\n            return l;\\n        if(l->val>r->val)\\n            return solve(r,l);\\n        l->next=solve(l->next,r);\\n        return l;\\n    }\\n\\t```\\n\\t**UPVOTE!!**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0)\\n            return NULL;\\n        ListNode* head=lists[0];\\n        for(int i=1;i<lists.size();i++)\\n            head=solve(head,lists[i]);\\n        return head;\\n    }\\n    ListNode* solve(ListNode* l,ListNode* r){\\n        if(!l)\\n            return r;\\n        if(!r)\\n            return l;\\n        if(l->val>r->val)\\n            return solve(r,l);\\n        l->next=solve(l->next,r);\\n        return l;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389843,
                "title": "java-two-easy-approach-with-explanation-priority-queue-min-heap",
                "content": "```\\n1)//Brute force apprach, creating node//more space is required \\nclass Solution\\n{\\n  class Reff\\n  {\\n     ListNode node;//pointer node \\n     int list;//current list we are in\\n\\n     Reff(ListNode node, int list)//parameterised constructor to initialize\\n     {\\n       this.node= node;\\n       this.list= list;\\n     }\\n  }\\n  public ListNode mergeKLists(ListNode[] lists)\\n  {//T -> O(N log N) S -> O(N)//Slower\\n     PriorityQueue<Reff>  minHeap= new PriorityQueue<>((a,b)->{\\n        return a.node.val - b.node.val;\\n     });//customised sorting based on value \\n    \\n     ListNode root= new ListNode(-1, null);//dummy node to add the nodes in sequential manner \\n     ListNode trav= root;//trav to add the node one by one\\n       \\n     for(int i= 0; i< lists.length; i++){//traversing the lists\\n          if(lists[i] != null)\\n          minHeap.offer(new Reff(lists[i], i));//adding the first node of the lists into the min heap\\n     }\\n    \\n     while(!minHeap.isEmpty())//terminating contion, till all the nodes in the lists list is covered \\n     {\\n        Reff ref= minHeap.poll();//polling the smallest node, at each instant\\n\\n        trav.next= new ListNode(ref.node.val);//creating a new Node and linking with previous node \\n        trav= trav.next;//temp pointing to current node \\n       \\n        if(ref.node != null && ref.node.next != null)//if next element is present, pushing it to the min heap\\n           minHeap.offer(new Reff(ref.node.next, ref.list));\\n        \\n     }\\n     return root.next;//returning the new head, of the sorted list \\n  }\\n}//Please do Upvote, it helps a lot\\n```\\n```\\n2)//optimise approach without node creation, modifying the existing node \\nclass Solution\\n{\\n  public ListNode mergeKLists(ListNode[] lists)\\n  {//T -> O(N log N) S -> O(N)//Faster\\n     PriorityQueue<ListNode>  minHeap= new PriorityQueue<>((a,b)->{\\n        return a.val - b.val;\\n     });//customised sorting based on value \\n    \\n     ListNode root= new ListNode(-1, null);//dummy node to add the nodes in sequential manner \\n     ListNode trav= root;//trav to add the node one by one\\n       \\n     for(int i= 0; i< lists.length; i++){//traversing the lists\\n         if(lists[i] != null)\\n             minHeap.offer(lists[i]);//adding the first node of the lists into the min heap\\n     }\\n      \\n     while(!minHeap.isEmpty())//terminating contion, till all the nodes in the lists list is covered \\n     {\\n        ListNode temp= minHeap.poll();//polling the smallest node, at each instant  \\n       \\n        trav.next= temp;//linking with previous node\\n        trav= trav.next;//temp pointing to current node \\n       \\n        ListNode next= temp.next;.//storing the next pointer \\n        temp.next= null;//removing the forward link \\n       \\n        if(next != null)//if next element is present, pushing it to the min heap\\n           minHeap.offer(next);\\n     }\\n     return root.next;//returning the new head, of the sorted list \\n  }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n1)//Brute force apprach, creating node//more space is required \\nclass Solution\\n{\\n  class Reff\\n  {\\n     ListNode node;//pointer node \\n     int list;//current list we are in\\n\\n     Reff(ListNode node, int list)//parameterised constructor to initialize\\n     {\\n       this.node= node;\\n       this.list= list;\\n     }\\n  }\\n  public ListNode mergeKLists(ListNode[] lists)\\n  {//T -> O(N log N) S -> O(N)//Slower\\n     PriorityQueue<Reff>  minHeap= new PriorityQueue<>((a,b)->{\\n        return a.node.val - b.node.val;\\n     });//customised sorting based on value \\n    \\n     ListNode root= new ListNode(-1, null);//dummy node to add the nodes in sequential manner \\n     ListNode trav= root;//trav to add the node one by one\\n       \\n     for(int i= 0; i< lists.length; i++){//traversing the lists\\n          if(lists[i] != null)\\n          minHeap.offer(new Reff(lists[i], i));//adding the first node of the lists into the min heap\\n     }\\n    \\n     while(!minHeap.isEmpty())//terminating contion, till all the nodes in the lists list is covered \\n     {\\n        Reff ref= minHeap.poll();//polling the smallest node, at each instant\\n\\n        trav.next= new ListNode(ref.node.val);//creating a new Node and linking with previous node \\n        trav= trav.next;//temp pointing to current node \\n       \\n        if(ref.node != null && ref.node.next != null)//if next element is present, pushing it to the min heap\\n           minHeap.offer(new Reff(ref.node.next, ref.list));\\n        \\n     }\\n     return root.next;//returning the new head, of the sorted list \\n  }\\n}//Please do Upvote, it helps a lot\\n```\n```\\n2)//optimise approach without node creation, modifying the existing node \\nclass Solution\\n{\\n  public ListNode mergeKLists(ListNode[] lists)\\n  {//T -> O(N log N) S -> O(N)//Faster\\n     PriorityQueue<ListNode>  minHeap= new PriorityQueue<>((a,b)->{\\n        return a.val - b.val;\\n     });//customised sorting based on value \\n    \\n     ListNode root= new ListNode(-1, null);//dummy node to add the nodes in sequential manner \\n     ListNode trav= root;//trav to add the node one by one\\n       \\n     for(int i= 0; i< lists.length; i++){//traversing the lists\\n         if(lists[i] != null)\\n             minHeap.offer(lists[i]);//adding the first node of the lists into the min heap\\n     }\\n      \\n     while(!minHeap.isEmpty())//terminating contion, till all the nodes in the lists list is covered \\n     {\\n        ListNode temp= minHeap.poll();//polling the smallest node, at each instant  \\n       \\n        trav.next= temp;//linking with previous node\\n        trav= trav.next;//temp pointing to current node \\n       \\n        ListNode next= temp.next;.//storing the next pointer \\n        temp.next= null;//removing the forward link \\n       \\n        if(next != null)//if next element is present, pushing it to the min heap\\n           minHeap.offer(next);\\n     }\\n     return root.next;//returning the new head, of the sorted list \\n  }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387269,
                "title": "simple-but-fast-ruby-o-nlog-k-solution",
                "content": "Ideas\\n* always pop out min listnode from left of array\\n* insert next node into sorted array at correct index to keep it still a sorted array\\n* when array is empty means you already iterate all listnode\\n\\n```ruby\\ndef merge_k_lists(lists)\\n  # Prepare answer list\\n  head = ListNode.new\\n  tail = head\\n  \\n  # Remove empty list first\\n  lists.delete_if { |list| list.nil? }\\n  \\n  # Sort list from min to max\\n  lists.sort_by! { |list| list.val }\\n  \\n  while !lists.empty?\\n    # Get min node from left of array\\n    min_node = lists.shift\\n    \\n    # Add to answer list\\n    tail.next = min_node\\n    tail = tail.next\\n    \\n    # Prepare next node\\n    new_list = min_node.next\\n    next if new_list.nil?\\n\\n    # Want to insert next node into sorted array at correct index to keep it still a sorted array\\n    # Then we can still shift min node from left in next run\\n    # Using bsearch on a sorted array is very fast\\n    insert_at = lists.bsearch_index { |list| list.val >= new_list.val }\\n    if insert_at.nil?\\n      lists.push(new_list)\\n    else\\n      lists.insert(insert_at, new_list)\\n    end\\n  end\\n  \\n  head.next\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef merge_k_lists(lists)\\n  # Prepare answer list\\n  head = ListNode.new\\n  tail = head\\n  \\n  # Remove empty list first\\n  lists.delete_if { |list| list.nil? }\\n  \\n  # Sort list from min to max\\n  lists.sort_by! { |list| list.val }\\n  \\n  while !lists.empty?\\n    # Get min node from left of array\\n    min_node = lists.shift\\n    \\n    # Add to answer list\\n    tail.next = min_node\\n    tail = tail.next\\n    \\n    # Prepare next node\\n    new_list = min_node.next\\n    next if new_list.nil?\\n\\n    # Want to insert next node into sorted array at correct index to keep it still a sorted array\\n    # Then we can still shift min node from left in next run\\n    # Using bsearch on a sorted array is very fast\\n    insert_at = lists.bsearch_index { |list| list.val >= new_list.val }\\n    if insert_at.nil?\\n      lists.push(new_list)\\n    else\\n      lists.insert(insert_at, new_list)\\n    end\\n  end\\n  \\n  head.next\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1131843,
                "title": "javascript-faster-than-98-84-cjamm",
                "content": "```\\nconst mergeKLists = (lists) => {\\n    if (lists.length === 0) return null;\\n    \\n    const merge = (l1, l2) => {\\n        let temp = new ListNode(),\\n            curr = temp;\\n        while (l1 && l2) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        curr.next = l1 || l2;\\n        return temp.next;\\n    }\\n    \\n    while(lists.length > 1) {\\n        let a = lists.shift();\\n        let b = lists.shift();\\n        const h = merge(a, b)\\n        lists.push(h)\\n    }\\n    return lists[0]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mergeKLists = (lists) => {\\n    if (lists.length === 0) return null;\\n    \\n    const merge = (l1, l2) => {\\n        let temp = new ListNode(),\\n            curr = temp;\\n        while (l1 && l2) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        curr.next = l1 || l2;\\n        return temp.next;\\n    }\\n    \\n    while(lists.length > 1) {\\n        let a = lists.shift();\\n        let b = lists.shift();\\n        const h = merge(a, b)\\n        lists.push(h)\\n    }\\n    return lists[0]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 943926,
                "title": "simple-javascript-solution",
                "content": "```\\nvar mergeKLists = function(lists) {\\n    let i = 0;\\n    \\n    let result = null;\\n    \\n    lists.forEach(v => {\\n        result = mergeList(result, v);\\n    });  \\n    \\n    return result;\\n};\\n                \\nvar mergeList = (l1 , l2) => {\\n    if (l1 == null)\\n        return l2;\\n            \\n    if (l2 == null)\\n        return l1;\\n        \\n    if (l1.val < l2.val) {\\n        l1.next = mergeList(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeList(l1, l2.next);\\n        return l2;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeKLists = function(lists) {\\n    let i = 0;\\n    \\n    let result = null;\\n    \\n    lists.forEach(v => {\\n        result = mergeList(result, v);\\n    });  \\n    \\n    return result;\\n};\\n                \\nvar mergeList = (l1 , l2) => {\\n    if (l1 == null)\\n        return l2;\\n            \\n    if (l2 == null)\\n        return l1;\\n        \\n    if (l1.val < l2.val) {\\n        l1.next = mergeList(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeList(l1, l2.next);\\n        return l2;\\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820152,
                "title": "easy-cpp-solution-using-divide-and-conquer",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* merge_two(ListNode* a,ListNode* b){\\n        ListNode* res=NULL;\\n        if(a==NULL){\\n            return b;\\n        }\\n        if(b==NULL){\\n            return a;\\n        }\\n        if(a->val<=b->val){\\n            res=a;\\n            res->next=merge_two(a->next,b);\\n        }\\n        else{\\n            res=b;\\n            res->next=merge_two(a,b->next);\\n        }\\n        return res;\\n        \\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int i=0,j;\\n        int last=lists.size()-1;\\n        \\n        if(lists.empty()){\\n            return NULL;\\n        }\\n        while(last!=0){\\n            i=0,j=last;\\n            while(i<j){\\n                lists.at(i)=merge_two(lists.at(i),lists.at(j));\\n                i++;\\n                j--;\\n                if(i>=j){\\n                    last=j;\\n                }\\n            }\\n        }\\n        return lists.at(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* merge_two(ListNode* a,ListNode* b){\\n        ListNode* res=NULL;\\n        if(a==NULL){\\n            return b;\\n        }\\n        if(b==NULL){\\n            return a;\\n        }\\n        if(a->val<=b->val){\\n            res=a;\\n            res->next=merge_two(a->next,b);\\n        }\\n        else{\\n            res=b;\\n            res->next=merge_two(a,b->next);\\n        }\\n        return res;\\n        \\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int i=0,j;\\n        int last=lists.size()-1;\\n        \\n        if(lists.empty()){\\n            return NULL;\\n        }\\n        while(last!=0){\\n            i=0,j=last;\\n            while(i<j){\\n                lists.at(i)=merge_two(lists.at(i),lists.at(j));\\n                i++;\\n                j--;\\n                if(i>=j){\\n                    last=j;\\n                }\\n            }\\n        }\\n        return lists.at(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766538,
                "title": "easy-c-solution-using-priority-queue",
                "content": "# Using Priority Queue\\n**Approach \\n1.Store first element of every linked list in priority queue.\\n2.Then remove the minimum element and add the next element of that list.**\\n```\\nclass Solution\\n{\\npublic:\\n    struct compare\\n    {\\n        bool operator()(const ListNode* l1, const ListNode* l2)\\n        {\\n            return l1->val > l2->val;\\n        }\\n    };\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        priority_queue<ListNode*, vector<ListNode*>, compare> q;\\n\\t\\t\\n\\t\\t//Store first element of every linked list in priority queue\\n        for(auto l : lists)\\n        {  \\n             if(l)\\n                q.push(l);\\n        }\\n\\n        ListNode pre(0);\\n        ListNode *node = &pre;\\n\\t\\t\\n\\t\\t// remove the minimum element and add the next element of that list\\n        while (!q.empty())\\n        {\\n            ListNode *top = q.top();\\n            q.pop();\\n\\n            node->next = top;\\n            node = node->next;\\n            if(top->next)\\n                q.push(top->next);\\n\\n        }\\n\\n        return pre.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    struct compare\\n    {\\n        bool operator()(const ListNode* l1, const ListNode* l2)\\n        {\\n            return l1->val > l2->val;\\n        }\\n    };\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        priority_queue<ListNode*, vector<ListNode*>, compare> q;\\n\\t\\t\\n\\t\\t//Store first element of every linked list in priority queue\\n        for(auto l : lists)\\n        {  \\n             if(l)\\n                q.push(l);\\n        }\\n\\n        ListNode pre(0);\\n        ListNode *node = &pre;\\n\\t\\t\\n\\t\\t// remove the minimum element and add the next element of that list\\n        while (!q.empty())\\n        {\\n            ListNode *top = q.top();\\n            q.pop();\\n\\n            node->next = top;\\n            node = node->next;\\n            if(top->next)\\n                q.push(top->next);\\n\\n        }\\n\\n        return pre.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599557,
                "title": "c-solution-with-explanation-efficient",
                "content": "```\\nWe will first start by taking k=2.\\n1->2->3\\n2->7->11\\nWe proceed by picking the the smallest pointer value and moving the pointer of the linked list forward.\\nThe same procedure will follow for k increasing. We will be greedily picking the smallest value and moving the corresponding pointer forward.\\nBut the problem is for k=2 we can check the smaller value of the two just by using < or > symbol.\\nBut if k is large lets say 1 million using such a technique will take years to compute.\\nWe will have to using a smarter data structure to solve this question.\\nThink of a data structure which will take all the values and will be able to give the smallest value in the least time.\\na min heap would be of the right choice.\\n\\n1. We will push all the first pointer of each of the linked list into the heap.\\n2. We must also move the pointer of that list forward.\\n3. Then we start linkig all the smallest nodes and get our solution.\\nRemember that heaps are in the form of trees but for simplicity i have represent it like this. \\n\\nLet k=3\\n1->8->11\\n2->3->7\\n3->6->16\\n          |         |\\n          |    1    |\\n          |    2    |\\n          |    3    |  <-----min heap storing the values of the first with top value as 1\\n          |_________| \\n\\n       ans=   1->\\n\\n          |         |\\n          |    2    |\\n          |    3    |\\n          |    8    |  <-----1 is p0poed out and the next pointer points to 8 which is pushed to the heap with top element as 2.\\n          |_________| \\n\\n       ans=   1->2->\\n\\n          |         |\\n          |    3    |\\n          |    3    |\\n          |    8    |  <-----2 is p0poed out and the next pointer points to 3 which is pushed to the heap with top element as 3.\\n          |_________| \\n\\n\\n          ans = 1->2->3\\n\\n\\n          Similarly the approach follows and u get the final result.\\n\\n\\n    struct comp\\n    {\\n      bool operator()(const ListNode* a,ListNode* b)\\n      {\\n          return a->val>b->val;\\n      }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,comp> pq;\\n        for(auto x:lists)\\n        {\\n            if(x)pq.push(x);\\n        }\\n        if(pq.empty())return NULL;\\n        ListNode* result=pq.top();\\n        pq.pop();\\n        if(result->next)pq.push(result->next);\\n        ListNode* t=result;\\n        while(!pq.empty())\\n        {\\n            t->next=pq.top();\\n            pq.pop();\\n            t=t->next;\\n            if(t->next)pq.push(t->next);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nWe will first start by taking k=2.\\n1->2->3\\n2->7->11\\nWe proceed by picking the the smallest pointer value and moving the pointer of the linked list forward.\\nThe same procedure will follow for k increasing. We will be greedily picking the smallest value and moving the corresponding pointer forward.\\nBut the problem is for k=2 we can check the smaller value of the two just by using < or > symbol.\\nBut if k is large lets say 1 million using such a technique will take years to compute.\\nWe will have to using a smarter data structure to solve this question.\\nThink of a data structure which will take all the values and will be able to give the smallest value in the least time.\\na min heap would be of the right choice.\\n\\n1. We will push all the first pointer of each of the linked list into the heap.\\n2. We must also move the pointer of that list forward.\\n3. Then we start linkig all the smallest nodes and get our solution.\\nRemember that heaps are in the form of trees but for simplicity i have represent it like this. \\n\\nLet k=3\\n1->8->11\\n2->3->7\\n3->6->16\\n          |         |\\n          |    1    |\\n          |    2    |\\n          |    3    |  <-----min heap storing the values of the first with top value as 1\\n          |_________| \\n\\n       ans=   1->\\n\\n          |         |\\n          |    2    |\\n          |    3    |\\n          |    8    |  <-----1 is p0poed out and the next pointer points to 8 which is pushed to the heap with top element as 2.\\n          |_________| \\n\\n       ans=   1->2->\\n\\n          |         |\\n          |    3    |\\n          |    3    |\\n          |    8    |  <-----2 is p0poed out and the next pointer points to 3 which is pushed to the heap with top element as 3.\\n          |_________| \\n\\n\\n          ans = 1->2->3\\n\\n\\n          Similarly the approach follows and u get the final result.\\n\\n\\n    struct comp\\n    {\\n      bool operator()(const ListNode* a,ListNode* b)\\n      {\\n          return a->val>b->val;\\n      }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,comp> pq;\\n        for(auto x:lists)\\n        {\\n            if(x)pq.push(x);\\n        }\\n        if(pq.empty())return NULL;\\n        ListNode* result=pq.top();\\n        pq.pop();\\n        if(result->next)pq.push(result->next);\\n        ListNode* t=result;\\n        while(!pq.empty())\\n        {\\n            t->next=pq.top();\\n            pq.pop();\\n            t=t->next;\\n            if(t->next)pq.push(t->next);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1572702,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1572281,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1566937,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1565582,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1568841,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1804644,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1750039,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1569749,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1569647,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1568012,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1572702,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1572281,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1566937,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1565582,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1568841,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1804644,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1750039,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1569749,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1569647,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1568012,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1760895,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1829872,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1572338,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1571059,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1568076,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1569221,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1983767,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1576660,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1575407,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1575389,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1574112,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1574047,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1573349,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1572590,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1572267,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1571060,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2065192,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2065191,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2046672,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2039845,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2035383,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 2034597,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 2034313,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 2029023,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1980146,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1977923,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1975251,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1940425,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1926865,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1925244,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1900878,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1875481,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1874661,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1869081,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1860917,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1856810,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1855905,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1831817,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1830767,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1830584,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1830554,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830516,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830337,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830301,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830213,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830137,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830043,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1829969,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1829916,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1829747,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1829696,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829655,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829618,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829608,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829606,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829605,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829584,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829073,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1828196,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1815810,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1807115,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1804696,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1800907,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1795621,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1786798,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1779949,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1779947,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1779154,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1778851,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1777993,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1767944,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1760982,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1742800,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1734175,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1734034,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1729550,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1727169,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1725520,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1725479,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1724056,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1718192,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1711099,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1707291,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1703410,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1683079,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1679976,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1673501,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1671278,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1629408,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1576407,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            }
        ]
    }
]