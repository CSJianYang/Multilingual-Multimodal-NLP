[
    {
        "title": "Largest Perimeter Triangle",
        "question_content": "Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.\n&nbsp;\nExample 1:\n\nInput: nums = [2,1,2]\nOutput: 5\nExplanation: You can form a triangle with three side lengths: 1, 2, and 2.\n\nExample 2:\n\nInput: nums = [1,2,1,10]\nOutput: 0\nExplanation: \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 104\n\t1 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 217988,
                "title": "java-c-python-sort-and-try-biggest",
                "content": "For `a >= b >= c`, `a,b,c` can form a triangle if `a < b + c`.\\n\\n1. We sort the `A`\\n2. Try to get a triangle with 3 biggest numbers.\\n3. If `A[n-1] < A[n-2] + A[n-3]`, we get a triangle.\\n   If `A[n-1] >= A[n-2] + A[n-3] >= A[i] + A[j]`, we cannot get any triangle with `A[n-1]`\\n4. repeat step2 and step3 with the left numbers.\\n\\n\\n**Java:**\\n```\\n    public int largestPerimeter(int[] A) {\\n        Arrays.sort(A);\\n        for (int i = A.length - 1; i > 1; --i)\\n            if (A[i] < A[i - 1] + A[i - 2])\\n                return A[i] + A[i - 1] + A[i - 2];\\n        return 0;\\n    }\\n```\\n\\n**C++:**\\n```\\n    int largestPerimeter(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        for (int i = A.size() - 1 ; i > 1; --i)\\n            if (A[i] < A[i - 1] + A[i - 2])\\n                return A[i] + A[i - 1] + A[i - 2];\\n        return 0;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def largestPerimeter(self, A):\\n        A = sorted(A)[::-1]\\n        for i in range(len(A) - 2):\\n            if A[i] < A[i + 1] + A[i + 2]:\\n                return A[i] + A[i + 1] + A[i + 2]\\n        return 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int largestPerimeter(int[] A) {\\n        Arrays.sort(A);\\n        for (int i = A.length - 1; i > 1; --i)\\n            if (A[i] < A[i - 1] + A[i - 2])\\n                return A[i] + A[i - 1] + A[i - 2];\\n        return 0;\\n    }\\n```\n```\\n    int largestPerimeter(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        for (int i = A.size() - 1 ; i > 1; --i)\\n            if (A[i] < A[i - 1] + A[i - 2])\\n                return A[i] + A[i - 1] + A[i - 2];\\n        return 0;\\n    }\\n```\n```\\n    def largestPerimeter(self, A):\\n        A = sorted(A)[::-1]\\n        for i in range(len(A) - 2):\\n            if A[i] < A[i + 1] + A[i + 2]:\\n                return A[i] + A[i + 1] + A[i + 2]\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2692643,
                "title": "java-o-nlogn-easy-to-understand-simple-solution",
                "content": "IF YOU LIKE THE SOLUTION \\nDON\\'T FORGET TO UPVOTE IT.\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        //Sort the array first.\\n        Arrays.sort(nums);\\n        \\n        //Start traversing from back , so that we can get the largest value.\\n        for(int i = nums.length-1; i>1; i--){\\n            //Using triangle property to become valid sides\\n            // The sum of the length of the two sides of a triangle is greater than the length of the third side. \\n           if(nums[i] < nums[i-1] + nums[i-2])\\n               return  nums[i] + nums[i-1]+ nums[i-2];   \\n        }\\n        \\n        //If we didn\\'t found anything we return 0.\\n        return 0;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        //Sort the array first.\\n        Arrays.sort(nums);\\n        \\n        //Start traversing from back , so that we can get the largest value.\\n        for(int i = nums.length-1; i>1; i--){\\n            //Using triangle property to become valid sides\\n            // The sum of the length of the two sides of a triangle is greater than the length of the third side. \\n           if(nums[i] < nums[i-1] + nums[i-2])\\n               return  nums[i] + nums[i-1]+ nums[i-2];   \\n        }\\n        \\n        //If we didn\\'t found anything we return 0.\\n        return 0;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217972,
                "title": "c-4-lines-o-n-log-n",
                "content": "The goal is to find the largest number n1, where two other numbers, n2 and n3, exist, and  ```n1 > n2 && n1 > n3```, and ```n1 < n2 + n3```.\\nIf we sort our sizes, we just need to find the largest A[i] such as ```A[i] < A[i - 1] + A[i - 2]```. So, we analyze triplets largest to smallest, and return the perimeter for the first triplet that matches our criterion.\\n```\\nint largestPerimeter(vector<int>& A) {\\n  sort(begin(A), end(A));\\n  for (auto i = A.size() - 1; i >= 2; --i)\\n    if (A[i] < A[i - 1] + A[i - 2]) \\n        return A[i] + A[i - 1] + A[i - 2];\\n  return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```n1 > n2 && n1 > n3```\n```n1 < n2 + n3```\n```A[i] < A[i - 1] + A[i - 2]```\n```\\nint largestPerimeter(vector<int>& A) {\\n  sort(begin(A), end(A));\\n  for (auto i = A.size() - 1; i >= 2; --i)\\n    if (A[i] < A[i - 1] + A[i - 2]) \\n        return A[i] + A[i - 1] + A[i - 2];\\n  return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 230431,
                "title": "python-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort(reverse=True)\\n        for i, x in enumerate(A[:-2]):\\n            # Sum of any two sides should be greater than the third side.\\n            # Consider sides: A[i], A[i+1] and A[i+2] \\n            # A[i] >= A[i+1] >= A[i+2] since the list is sorted\\n            # A[i] >= A[i+1] so A[i] + A[i+2] > A[i+1] and also A[i] >= A[i+2] so A[i] + A[i+1] > A[i+2] hence\\n            # the only condition we need to check is that A[i] < A[i+1] + A[i+2] \\n            if x < A[i+1] + A[i+2]:\\n                return x + A[i+1] + A[i+2]\\n\\n            # Another thing to note here is that: we have reached this point that means, A[i] > A[i+1] + A[i+2]\\n            # So there is no way that A[i] < A[i+1] and A[j] where j > i+2 so we need not consider all permutations\\n            # of A[i], A[i+1], A[i+3] or A[i], A[i+1], A[i+4] and so on.\\n\\n            # Hence the next case to be considered would be A[i+1], A[i+2] and A[i+3]\\n            # hence just incrementing i would do the job\\n            \\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort(reverse=True)\\n        for i, x in enumerate(A[:-2]):\\n            # Sum of any two sides should be greater than the third side.\\n            # Consider sides: A[i], A[i+1] and A[i+2] \\n            # A[i] >= A[i+1] >= A[i+2] since the list is sorted\\n            # A[i] >= A[i+1] so A[i] + A[i+2] > A[i+1] and also A[i] >= A[i+2] so A[i] + A[i+1] > A[i+2] hence\\n            # the only condition we need to check is that A[i] < A[i+1] + A[i+2] \\n            if x < A[i+1] + A[i+2]:\\n                return x + A[i+1] + A[i+2]\\n\\n            # Another thing to note here is that: we have reached this point that means, A[i] > A[i+1] + A[i+2]\\n            # So there is no way that A[i] < A[i+1] and A[j] where j > i+2 so we need not consider all permutations\\n            # of A[i], A[i+1], A[i+3] or A[i], A[i+1], A[i+4] and so on.\\n\\n            # Hence the next case to be considered would be A[i+1], A[i+2] and A[i+3]\\n            # hence just incrementing i would do the job\\n            \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693008,
                "title": "c-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n----------------------------------------------------------------------------\\n\\n**APPROACH** - Sort the array and when a+b>c, return the perimeter (a+b+c) \\n\\n-------------------------------------------------------------------------\\n\\n\\tint largestPerimeter(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());                 //sort the array\\n        \\n        for(int i=nums.size()-3; i>=0; i--){            //traverse from n-3 to 0\\n            if(nums[i]+nums[i+1] > nums[i+2]) {         //if at any instant a + b > c, return perimenter (a+b+c)\\n                return  nums[i]+nums[i+1]+nums[i+2];    // a=nums[i], b=nums[i+1], c=nums[i+2];\\n            }\\n        }\\n        return 0;                                       //else return 0\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n----------------------------------------------------------------------------\\n\\n**APPROACH** - Sort the array and when a+b>c, return the perimeter (a+b+c) \\n\\n-------------------------------------------------------------------------\\n\\n\\tint largestPerimeter(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());                 //sort the array\\n        \\n        for(int i=nums.size()-3; i>=0; i--){            //traverse from n-3 to 0\\n            if(nums[i]+nums[i+1] > nums[i+2]) {         //if at any instant a + b > c, return perimenter (a+b+c)\\n                return  nums[i]+nums[i+1]+nums[i+2];    // a=nums[i], b=nums[i+1], c=nums[i+2];\\n            }\\n        }\\n        return 0;                                       //else return 0\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2692462,
                "title": "python-3-4-lines-geometry-w-explanation-t-m-100-61",
                "content": "Three line segments comprise a triangle if and only if the greatest length of the three sides is less than the sum of lengths of the other two sides. (A few sketches or playing with three sticks should convince you of this fact.)\\n\\nHere\\'s the Plan:\\n- Sort nums in non-increasing order.\\n- Iterate though the list and pop off the first element until nums[0] < nums[1]+nums[2]. The sum of these three nums is the solution.\\n - If no such three numbers exist, then return 0\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: list[int]) -> int:\\n        \\n        nums.sort(reverse = True)\\n        \\n        while len(nums) > 2 and nums[0] >= nums[1] + nums[2]:\\n            nums.pop(0)\\n            \\n        return 0 if len(nums) < 3 else sum(nums[:3])\\n```\\n[https://leetcode.com/submissions/detail/587973432/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: list[int]) -> int:\\n        \\n        nums.sort(reverse = True)\\n        \\n        while len(nums) > 2 and nums[0] >= nums[1] + nums[2]:\\n            nums.pop(0)\\n            \\n        return 0 if len(nums) < 3 else sum(nums[:3])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915905,
                "title": "python-3-98-better-explained-with-simple-logic",
                "content": "***Logic:***\\n1. Sort the List to get the top 3 lengths\\n2. Check if the largest length is less than sum of other two\\n\\t3. If 2 is false, drop the max length take next 3 largest length and repeat 1-2\\n\\t4. if 2 is true, return sum of all lengths\\n5. if loop ends, and no possible combination found, return 0\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        A.sort(reverse = True)\\n        for i in range(3,len(A)+1):\\n            if(A[i-3] < A[i-2] + A[i-1]):\\n                return sum(A[i-3:i])\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        A.sort(reverse = True)\\n        for i in range(3,len(A)+1):\\n            if(A[i-3] < A[i-2] + A[i-1]):\\n                return sum(A[i-3:i])\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987107,
                "title": "c-4-lines-sort-easy-understandable-single-pass",
                "content": "As, we know that the basic condition to make a triangle is (a+b>c).\\nNow, we sort the given array in the \"non-decreasing\" order to get the maximum values at right hand side only.\\nWe choose most three greatest side and checks whether it can form a triangle or not, If the sides forms a triangle we return the sum of those three sides.\\nMY CODE WITH **O(NlogN)** TIME COMPLEXITY IS GIVEN BELOW:\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423042,
                "title": "java-easy-solution-faster-than-99-57",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n     Arrays.sort(nums);\\n      for(int i = nums.length - 1; i > 1; i --) \\n        if(nums[i] < nums[i - 1] + nums[i - 2]) \\n          return nums[i] + nums[i - 1] + nums[i - 2];\\n      \\n      return 0;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n     Arrays.sort(nums);\\n      for(int i = nums.length - 1; i > 1; i --) \\n        if(nums[i] < nums[i - 1] + nums[i - 2]) \\n          return nums[i] + nums[i - 1] + nums[i - 2];\\n      \\n      return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218346,
                "title": "python-2-liner-comprehend-my-list-comprehension",
                "content": "**Hi fellas,\\nMy laptop is broken and i can\\'t participate Leetcode. I am writing this on my ipad and it\\'s been more than 20 mins for two line code to write correctly, such a pain in the ass LC mobile not responsive. Happy coding!**\\n```\\nclass Solution:\\n def largestPerimeter(self, A):\\n  A.sort()\\n  return ([0] + [a + b + c for a, b, c in zip(A, A[1:], A[2:]) if c < a + b])[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n def largestPerimeter(self, A):\\n  A.sort()\\n  return ([0] + [a + b + c for a, b, c in zip(A, A[1:], A[2:]) if c < a + b])[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693512,
                "title": "triangle-basic-property",
                "content": "The solution is based on one of the basic properties of a triangle:\\n*The sum of the length of any two sides of a triangle is greater than the length of the third side.*\\n\\n##### Java\\n```java\\npublic int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 3; i >= 0; --i) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) \\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n```\\n\\n##### C++\\n```c++\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = nums.size() - 3; i >= 0; --i) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) \\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n```\\n\\t\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 3; i >= 0; --i) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) \\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n```\n```c++\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = nums.size() - 3; i >= 0; --i) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) \\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692877,
                "title": "python-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'ve to find the largest perimeter of triangle & that\\'s why we need to first sort the list and loop from behind.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we\\'ll sort the program & take j as size of nums minus 3 and we\\'ll decrease the value after each loop and similarly take i as the last element and decrease the value after each loop.\\n\\nTill the j is greater than 0, go in the nums list. If nums[j]+nums[j+1]>nums[i] then return the sum of all these otherwise go on in the loop and will return 0 if no such condition found.\\n\\n==========================================================\\n\\nLet\\'s understand this with an example :-\\n\\nnums = [3,6,2,3]\\n\\nSo, we\\'ll first sort the array and it will now look like \\nnums = [2,3,3,6]\\n\\nNow, we\\'ll take i as the last element of the list and j as the (length of list-3) index.\\n\\n \\n![image.png](https://assets.leetcode.com/users/images/344f6d8f-6347-4a5f-acde-7219b2a4a83e_1665580667.2809658.png)\\n\\nSo j will point to 3 and i will point to 6.\\n\\nNow, we\\'ll check the first condition if nums[j]+nums[j+1]>nums[i] i.e., if 3+3>6, so that is false so we\\'ll decrement both the value of i and j by 1.\\n\\nNow, i will start pointing to 3 and j will point to 2.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/3029c91b-08bc-425b-9d17-74069a901eca_1665580695.550933.png)\\n\\nNow, we\\'ll check the condition if nums[j]+nums[j+1]>nums[i] i.e., if 2+3>3, so that is true as 5>3 so we\\'ll return the sum of all these like 2+3+3 i.e., we\\'ll return 8.\\n\\nAnd this is how we\\'ll look in the list for every element.\\n\\n**Corner Case :-**\\n\\nAnd suppose if this also won\\'t work like if suppose the list is like 1 2 3 6 and for every case this condition is false, like 2+3>6 is false and similarly 1+2>3 is also false so in that case we\\'ll return 0.\\n\\n==========================================================\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!--Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        \\n        i = n-1\\n        j = n-3\\n\\n        while(j>=0):\\n            if(nums[j]+nums[j+1]>nums[i]):\\n                return nums[j]+nums[j+1]+nums[i]\\n            i=i-1\\n            j=j-1\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        \\n        i = n-1\\n        j = n-3\\n\\n        while(j>=0):\\n            if(nums[j]+nums[j+1]>nums[i]):\\n                return nums[j]+nums[j+1]+nums[i]\\n            i=i-1\\n            j=j-1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836412,
                "title": "c-clean-easy-sorting",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint largestPerimeter(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tfor(int i=nums.size()-3;i>=0;i--){\\n\\t\\t\\t\\tif(nums[i]+nums[i+1]>nums[i+2])\\n\\t\\t\\t\\t\\treturn nums[i]+nums[i+1]+nums[i+2];\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint largestPerimeter(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tfor(int i=nums.size()-3;i>=0;i--){\\n\\t\\t\\t\\tif(nums[i]+nums[i+1]>nums[i+2])\\n\\t\\t\\t\\t\\treturn nums[i]+nums[i+1]+nums[i+2];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2488729,
                "title": "python-easy-solution",
                "content": "```\\ndef largestPerimeter(self, nums: List[int]) -> int: # nums = [3,6,2,3]\\n        # condition to create a triangle a < (b + c). where  a >= b >= c\\n        nums = sorted(nums, reverse=True) # nums after sorting = [6, 3, 3, 2]\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] +nums[i+2]: # When i =1 => 3 < 3+2 (True)\\n                return nums[i]+nums[i+1] +nums[i+2] # 3 + 3 + 2 = 8\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef largestPerimeter(self, nums: List[int]) -> int: # nums = [3,6,2,3]\\n        # condition to create a triangle a < (b + c). where  a >= b >= c\\n        nums = sorted(nums, reverse=True) # nums after sorting = [6, 3, 3, 2]\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] +nums[i+2]: # When i =1 => 3 < 3+2 (True)\\n                return nums[i]+nums[i+1] +nums[i+2] # 3 + 3 + 2 = 8\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 550885,
                "title": "python-java-js-go-c-o-n-log-n-by-sorting-w-visualization",
                "content": "O( n log n ) by sorting. \\n\\n---\\n**Hint**:\\n\\n**Sort** input side length in descending order.\\n\\n**Try and test** the side length combination of triangle **from the largest one**.\\n\\nIf we find the optimal one, then early return the sum of valid largest side length combination.\\nOtherwise, return 0 (i.e., impossible to make triangle)\\n\\n---\\n\\n**Recall**:\\n\\nBasic property of triangle:\\n\\n**[Triangle inequality](https://en.wikipedia.org/wiki/Triangle_inequality)**\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585128080.png)\\n\\n\\nZ < X + Y where X, Y, Z are valid side length of triangle.\\n\\n---\\nImplementation:\\n```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        \\n\\t\\t# sort side length in descending order\\n        A.sort( reverse = True )\\n        \\n\\t\\t# Try and test from largest side length\\n        for i in range( len(A) - 2):\\n            \\n            if A[i] < A[i+1] + A[i+2]:\\n                # Early return when we find largest perimeter triangle\\n                return A[i] + A[i+1] + A[i+2]\\n        \\n        # Reject: impossible to make triangle\\n        return 0\\n        \\n```\\n\\n---\\n\\nJava:\\n\\n```\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        \\n        // Java native int[] sort doesn\\'t support reverse option\\n        Arrays.sort( nums );\\n\\n        for( int i = nums.length-3 ; i >= 0 ; i--){\\n            \\n            if( nums[i+2] < ( nums[i+1] + nums[i] ) ){\\n                // Accept: find the triangle with largest perimeter\\n                return ( nums[i] + nums[i+1] + nums[i+2] );\\n            }\\n            \\n        }\\n        \\n        // Reject: impossible to make triangle\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar compareFn = function(a, b){\\n    // put larger element of the left hand side\\n    return b - a;    \\n}\\n\\nvar largestPerimeter = function(nums) {\\n    \\n    nums.sort( compareFn );\\n    \\n    for( let i = 0 ; i < nums.length-2 ; i++){\\n        \\n        if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n            \\n            // Accept: find the triangle with largest perimeter\\n            return ( nums[i] +  nums[i+1] + nums[i+2] )\\n        }\\n        \\n    }\\n    \\n    // Reject: impossible to make triangle\\n    return 0;\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nimport(\\n    \"sort\"\\n)\\n\\nfunc largestPerimeter(nums []int) int {\\n    \\n    // sort side length in descending order\\n    sort.Slice( nums, func( i, j int) bool{\\n        return nums[i] > nums[j]\\n    })\\n    \\n    \\n    for i := 0 ; i < len(nums)-2 ; i++ {\\n\\n        // Accept: find the triangle with largest perimeter\\n        if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n            return nums[i] + nums[i+1] + nums[i+2]\\n        }\\n\\n    }\\n    \\n    // Reject: impossible to make triangle\\n    return 0\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        // sort side length in descending order\\n        std::sort( nums.rbegin(), nums.rend() );\\n        \\n        for( int i = 0 ; i < nums.size()-2 ; i++ ){\\n            \\n            // Accept: find the triangle with largest perimeter\\n            if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }\\n            \\n        }\\n        \\n        // Reject: impossible to make triangle\\n        return 0;\\n    }\\n};\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #611 Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/)\\n\\n[Leetcode #812 Largest Triangle Area](https://leetcode.com/problems/largest-triangle-area/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about sort( ) with direction](https://docs.python.org/3/howto/sorting.html#ascending-and-descending)\\n\\n[2] [Wiki: Triangle inequality](https://en.wikipedia.org/wiki/Triangle_inequality)\\n\\n[3] [MDN docs: Javascript Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\\n\\n[4] [CPP plus docs: STL sort()](https://cplusplus.com/reference/algorithm/sort/)\\n\\n[5] [Go offical docs: sort](https://pkg.go.dev/sort)\\n\\n[6] [Java official docs: sort](https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#sort(int[],%20int,%20int))",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        \\n\\t\\t# sort side length in descending order\\n        A.sort( reverse = True )\\n        \\n\\t\\t# Try and test from largest side length\\n        for i in range( len(A) - 2):\\n            \\n            if A[i] < A[i+1] + A[i+2]:\\n                # Early return when we find largest perimeter triangle\\n                return A[i] + A[i+1] + A[i+2]\\n        \\n        # Reject: impossible to make triangle\\n        return 0\\n        \\n```\n```\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        \\n        // Java native int[] sort doesn\\'t support reverse option\\n        Arrays.sort( nums );\\n\\n        for( int i = nums.length-3 ; i >= 0 ; i--){\\n            \\n            if( nums[i+2] < ( nums[i+1] + nums[i] ) ){\\n                // Accept: find the triangle with largest perimeter\\n                return ( nums[i] + nums[i+1] + nums[i+2] );\\n            }\\n            \\n        }\\n        \\n        // Reject: impossible to make triangle\\n        return 0;\\n    }\\n}\\n```\n```\\nvar compareFn = function(a, b){\\n    // put larger element of the left hand side\\n    return b - a;    \\n}\\n\\nvar largestPerimeter = function(nums) {\\n    \\n    nums.sort( compareFn );\\n    \\n    for( let i = 0 ; i < nums.length-2 ; i++){\\n        \\n        if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n            \\n            // Accept: find the triangle with largest perimeter\\n            return ( nums[i] +  nums[i+1] + nums[i+2] )\\n        }\\n        \\n    }\\n    \\n    // Reject: impossible to make triangle\\n    return 0;\\n};\\n```\n```\\nimport(\\n    \"sort\"\\n)\\n\\nfunc largestPerimeter(nums []int) int {\\n    \\n    // sort side length in descending order\\n    sort.Slice( nums, func( i, j int) bool{\\n        return nums[i] > nums[j]\\n    })\\n    \\n    \\n    for i := 0 ; i < len(nums)-2 ; i++ {\\n\\n        // Accept: find the triangle with largest perimeter\\n        if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n            return nums[i] + nums[i+1] + nums[i+2]\\n        }\\n\\n    }\\n    \\n    // Reject: impossible to make triangle\\n    return 0\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        // sort side length in descending order\\n        std::sort( nums.rbegin(), nums.rend() );\\n        \\n        for( int i = 0 ; i < nums.size()-2 ; i++ ){\\n            \\n            // Accept: find the triangle with largest perimeter\\n            if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }\\n            \\n        }\\n        \\n        // Reject: impossible to make triangle\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906224,
                "title": "c-4-lines-very-very-simple-solution-with-explanation",
                "content": "* Before diving into code.. Let us recall the **basic rule** for lengths of sides of a triangle\\ni.e, sum of any two sides of a triangle should be greater than its third side.\\nSimply, ` a + b > c `\\n\\twhere *a, b, c are sides of triangle*\\n\\n**Approach**:\\n Since we need the largest perimter from the given nums. We sort the array and traverse from the end\\n*  `if nums[i] < nums[i-1] + nums[i-2]`, then \\n\\t we Stop and return the perimeter==> `nums[i] + nums[i-1] + nums[i-2]`\\n \\n*  if there is no values that satisfies the given condition then\\n\\twe `return 0`\\n \\n**C++:**\\n\\n```\\nint largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i = nums.size()-1; i>=2; i--)\\n\\t\\t\\t\\tif(nums[i] < nums[i-1] + nums[i-2])    return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;\\n    }\\n \\n```\\n\\n**Please UpVote Me if you like it : )**",
                "solutionTags": [
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i = nums.size()-1; i>=2; i--)\\n\\t\\t\\t\\tif(nums[i] < nums[i-1] + nums[i-2])    return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;\\n    }\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529793,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        for(int i = nums.length - 3; i >= 0; i--) {\\n            if(nums[i] + nums[i + 1] > nums[i + 2])\\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        for(int i = nums.length - 3; i >= 0; i--) {\\n            if(nums[i] + nums[i + 1] > nums[i + 2])\\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2692917,
                "title": "java-easy-solution-beginner-friendly-98-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n  public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums); // sort element and select largest sides to maximize perimeter.\\n        int maxperimeter = 0;\\n        for(int i=nums.length-1;i>1;i--) {\\n            if(nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums); // sort element and select largest sides to maximize perimeter.\\n        int maxperimeter = 0;\\n        for(int i=nums.length-1;i>1;i--) {\\n            if(nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692879,
                "title": "c-easy-to-understand-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n int largestPerimeter(vector<int>& nums) {\\n       \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int ans;\\n        \\n        \\n        for(int i = 0; i < nums.size()- 2; i++)\\n        {\\n            if(nums[i] < nums[i+1] + nums[i+2])\\n            {\\n                 ans = nums[i]+nums[i+1]+nums[i+2];\\n                return ans;\\n            }           \\n        }\\n     \\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int largestPerimeter(vector<int>& nums) {\\n       \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int ans;\\n        \\n        \\n        for(int i = 0; i < nums.size()- 2; i++)\\n        {\\n            if(nums[i] < nums[i+1] + nums[i+2])\\n            {\\n                 ans = nums[i]+nums[i+1]+nums[i+2];\\n                return ans;\\n            }           \\n        }\\n     \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417162,
                "title": "simple-c-solution-using-sorting",
                "content": "In this we first sort the array then we are checking for each interval of length 3 of array. By triangle property, i.e. sum of two sides must be greater than largest side of the triangle.\\n\\n```\\nint largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                sum=max(sum,nums[i]+nums[i+1]+nums[i+2]);\\n            }\\n        }\\n        return sum;\\n    }\\n```\\nIf any doubt then feel free to ask !!\\nIf you get some value from this, then show some love by upvoting it !!\\nHappy Coding \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                sum=max(sum,nums[i]+nums[i+1]+nums[i+2]);\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840745,
                "title": "python-faster-than-100",
                "content": "Sort the list, then go through the triples of numbers starting with the largest triple. \\n\\nReturn the perimeter of the first valid triangle.\\n\\n```\\ndef largestPerimeter(nums):\\n    if len(nums) < 3: return 0\\n    nums.sort(reverse=True)\\n    a, b = nums[:2]\\n    for c in nums[2:]:\\n        if b + c > a:\\n            return a + b + c\\n        a, b = b, c\\n    return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef largestPerimeter(nums):\\n    if len(nums) < 3: return 0\\n    nums.sort(reverse=True)\\n    a, b = nums[:2]\\n    for c in nums[2:]:\\n        if b + c > a:\\n            return a + b + c\\n        a, b = b, c\\n    return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 218037,
                "title": "javascript-4-lines-sort",
                "content": "The longest length of a side of a triangle is smaller than sum of  other two sides lengths.\\nthe array is sorted descending  and check each A[i]<A[i+1]+A[i+2], A[i] is always max(A[i+1],A[i+2])\\n```\\nvar largestPerimeter = function(A) {\\n\\tA.sort(function(a, b) { return b - a; });    \\n\\tfor(let i=0;i<A.length-2;i++){\\n\\t\\tlet sum = A[i+1] + A[i+2];\\n\\t\\tif (sum > A[i]) return sum + A[i];\\n\\t }\\n\\treturn 0;  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar largestPerimeter = function(A) {\\n\\tA.sort(function(a, b) { return b - a; });    \\n\\tfor(let i=0;i<A.length-2;i++){\\n\\t\\tlet sum = A[i+1] + A[i+2];\\n\\t\\tif (sum > A[i]) return sum + A[i];\\n\\t }\\n\\treturn 0;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693367,
                "title": "largest-perimeter-triangle-faster-than-97-3-pointers-c",
                "content": "# Intuition\\nThe basic intuition was to sort the array and check the elements from the end. If the sum of last second and last third element is greater than last element, then return the sum of all last three elements, else decrement all pointers by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n        int a = size - 3, b = size - 2, c = size - 1;\\n\\n        while(a >= 0){\\n            if(nums[a] + nums[b] > nums[c]) return nums[a] + nums[b] + nums[c];\\n            else{\\n                a--;\\n                b--;\\n                c--;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n        int a = size - 3, b = size - 2, c = size - 1;\\n\\n        while(a >= 0){\\n            if(nums[a] + nums[b] > nums[c]) return nums[a] + nums[b] + nums[c];\\n            else{\\n                a--;\\n                b--;\\n                c--;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671103,
                "title": "python-easy-solution-faster-than-88-59",
                "content": "Runtime: 209 ms, **faster than 88.59%** of Python3 online submissions for Largest Perimeter Triangle.\\nMemory Usage: 15.4 MB, **less than 91.33%** of Python3 online submissions for Largest Perimeter Triangle.\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return 0\\n        \\n        nums.sort(reverse = True)\\n        for i in range(3,len(nums)+1):\\n            if(nums[i-3] < nums[i-2] + nums[i-1]):\\n                return sum(nums[i-3:i])\\n        \\n        return 0\\n```\\nKindly upvote if it helped you. Thanks :)",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return 0\\n        \\n        nums.sort(reverse = True)\\n        for i in range(3,len(nums)+1):\\n            if(nums[i-3] < nums[i-2] + nums[i-1]):\\n                return sum(nums[i-3:i])\\n        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514283,
                "title": "javascript-easy-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\nvar largestPerimeter = function(A) {\\n  A.sort((a, b) => b - a);\\n  const N = A.length - 2;\\n  for (let i = 0; i < N; i++) {\\n    if (A[i] < A[i + 1] + A[i + 2]) return A[i] + A[i + 1] + A[i + 2];\\n  }\\n  return 0;\\n};\\n```\\n\\n* 84/84 cases passed (92 ms)\\n* Your runtime beats 86.17 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (38.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\nvar largestPerimeter = function(A) {\\n  A.sort((a, b) => b - a);\\n  const N = A.length - 2;\\n  for (let i = 0; i < N; i++) {\\n    if (A[i] < A[i + 1] + A[i + 2]) return A[i] + A[i + 1] + A[i + 2];\\n  }\\n  return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491556,
                "title": "easy-swift-solution",
                "content": "Easy Swift solution\\n```\\nclass Solution {\\n    func largestPerimeter(_ A: [Int]) -> Int {\\n        let a = A.sorted(by: >) // descending sort\\n        for i in 0..<(a.count - 2) { // loop every 3 of lengths from large to small\\n            if a[i + 1] + a[i + 2] - a[i] > 0 { // triangle is possible and non-empty\\n                return a[i + 1] + a[i + 2] + a[i]\\n            }\\n        }\\n        return 0 // there is no possible non-empty triangles\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestPerimeter(_ A: [Int]) -> Int {\\n        let a = A.sorted(by: >) // descending sort\\n        for i in 0..<(a.count - 2) { // loop every 3 of lengths from large to small\\n            if a[i + 1] + a[i + 2] - a[i] > 0 { // triangle is possible and non-empty\\n                return a[i + 1] + a[i + 2] + a[i]\\n            }\\n        }\\n        return 0 // there is no possible non-empty triangles\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694502,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        for(int i=n-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                return nums[i]+nums[i-1]+nums[i-2];\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        for(int i=n-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                return nums[i]+nums[i-1]+nums[i-2];\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693376,
                "title": "javascript-explained-with-comments-and-visualization",
                "content": "There is a great rule that\\'s called **Traingle Inequality** and it states the following:\\n\\n**In mathematics, the triangle inequality states that for any triangle, the sum of the lengths of any two sides must be greater than the length of the remaining side.**\\n**If x, y, and z are the lengths of the sides of the triangle, with no side being greater than z, then the triangle inequality states that z < x + y**\\n\\nFor example, we can take the next triangle for visualization:\\n\\n![image](https://assets.leetcode.com/users/images/411d9368-fecd-4970-b462-fcd2f2b1bde1_1665556972.1866663.png)\\n\\nThe rule states that **x + y > z**.\\n\\nTo answer the question, we first of all can sort the array in decreasing order, because we know that if **x + y > z**, then **x + z > y also**.\\nAfter that, we will loop through the array, we will declare three variables that will indicate the three sides of a triangle.\\nIf the sum b + c is greater than a (the last side of the triangle), then we know we have an answer (we just go by the rule I stated above).\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {    \\n\\t// Sort in DESC order\\n    nums.sort((a, b) => b - a);\\n        \\n    for(let i = 0; i < nums.length; i++) {\\n\\t\\n\\t\\t// Decalre the three sides of the triangle\\n        let a = nums[i], b = nums[i + 1], c = nums[i + 2];\\n        \\n\\t\\t// Perform the check depending on the rule\\n        if(a < b + c) return a + b + c;\\n    }\\n    \\n\\t// If we cannot form a triangle, we return 0\\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {    \\n\\t// Sort in DESC order\\n    nums.sort((a, b) => b - a);\\n        \\n    for(let i = 0; i < nums.length; i++) {\\n\\t\\n\\t\\t// Decalre the three sides of the triangle\\n        let a = nums[i], b = nums[i + 1], c = nums[i + 2];\\n        \\n\\t\\t// Perform the check depending on the rule\\n        if(a < b + c) return a + b + c;\\n    }\\n    \\n\\t// If we cannot form a triangle, we return 0\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692990,
                "title": "c-easy-math-rule-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        // as we know for creating a perfect Triangle two sides sum should be greater than the 3rd one\\n        // a+b>c   or     a+c>b    or   b+c>a\\n\\t\\t// now arrange values in increasing order , so no need to check for every combination\\n        sort(nums.begin(),nums.end());\\n        int mx = 0;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            if(nums[i]+nums[i+1]>nums[i+2]) mx = max(mx,nums[i]+nums[i+1]+nums[i+2]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        // as we know for creating a perfect Triangle two sides sum should be greater than the 3rd one\\n        // a+b>c   or     a+c>b    or   b+c>a\\n\\t\\t// now arrange values in increasing order , so no need to check for every combination\\n        sort(nums.begin(),nums.end());\\n        int mx = 0;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            if(nums[i]+nums[i+1]>nums[i+2]) mx = max(mx,nums[i]+nums[i+1]+nums[i+2]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692871,
                "title": "largest-perimeter-triangle-5-solutions-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 Largest Perimeter Triangle \\uD83D\\uDD25 || 5 Solutions || Simple Fast and Easy || with Explanation\\n\\n## Solution - 1\\n\\n### Explanation\\n- Before diving into code.. Let us recall the basic rule for lengths of sides of a triangle\\n i.e, sum of any two sides of a triangle should be greater than its third side.\\n Simply, a + b > c\\n-  where a, b, c are sides of triangle\\n ### Approach:\\n Since we need the largest perimeter from the given nums. We sort the array and traverse from the end\\n\\n-  if nums[i] < nums[i-1] + nums[i-2], then\\n we Stop and return the perimeter==> nums[i] + nums[i-1] + nums[i-2]\\n\\n-  if there is no values that satisfies the given condition then\\n we return 0\\n\\n```dart\\nclass Solution {\\n// Runtime: 426 ms, faster than 80.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 149.6 MB, less than 100.00% of Dart online submissions for Largest Perimeter Triangle.\\n\\n  int largestPerimeter(List<int> nums) {\\n    nums.sort();\\n    for (int i = nums.length - 1; i > 1; --i)\\n      if (nums[i] < nums[i - 1] + nums[i - 2])\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n    return 0;\\n  }\\n}\\n```\\n\\n## Solution - 2 Recursive\\n\\n```dart\\nclass Solution {\\n// Runtime: 514 ms, faster than 60.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 150.2 MB, less than 20.00% of Dart online submissions for Largest Perimeter Triangle.\\n\\n  //utility method to get max element at given index\\n  void swapToGetMax(List<int> nums, int index) {\\n    int max = 0, maxIndex = -1;\\n    for (int i = 0; i <= index; i++)\\n      if (max < nums[i]) {\\n        max = nums[i];\\n        maxIndex = i;\\n      }\\n    //actual swapping after finding max element in given range\\n    int temp = nums[index];\\n    nums[index] = max;\\n    nums[maxIndex] = temp;\\n  }\\n\\n  int largestPerimeter(List<int> nums) {\\n    //if array has only 3 elements\\n    if (nums.length == 3) {\\n      if (nums[0] < nums[1] + nums[2] &&\\n          nums[1] < nums[0] + nums[2] &&\\n          nums[2] < nums[1] + nums[0])\\n        return nums[0] + nums[1] + nums[2];\\n      else\\n        return 0;\\n    }\\n    //for more than 3 elements, without doing explicit sorting\\n    int n = nums.length;\\n    //here we are putting max element at last index\\n    swapToGetMax(nums, n - 1);\\n    //here we are putting max element at second last index\\n    swapToGetMax(nums, n - 2);\\n    //here we are putting max element at third last index\\n    swapToGetMax(nums, n - 3);\\n    //in loop checking if nums[i]<nums[i-1]+nums[i-2] which this triplet will form the max perimeter\\n    for (int i = n - 1; i >= 2; i--) {\\n      if (nums[i] < nums[i - 1] + nums[i - 2])\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n      //if not then will find max element as (i-3)th largest element\\n      else if (i > 2) swapToGetMax(nums, i - 3);\\n    }\\n    return 0;\\n  }\\n}\\n```\\n\\n## Solution - 3\\n\\n```dart\\nclass Solution {\\n// Runtime: 596 ms, faster than 40.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 150.3 MB, less than 20.00% of Dart online submissions for Largest Perimeter Triangle.\\n  int largestPerimeter(List<int> nums) {\\n    if (nums.length == 3) {\\n      if (nums[0] < nums[1] + nums[2] &&\\n          nums[1] < nums[0] + nums[2] &&\\n          nums[2] < nums[1] + nums[0])\\n        return nums[0] + nums[1] + nums[2];\\n      else\\n        return 0;\\n    }\\n    int n = nums.length;\\n    int maxi = 0;\\n    for (int i = 0; i < n - 2; i++) {\\n      for (int j = i + 1; j < n - 1; j++) {\\n        for (int k = j + 1; k < n; k++) {\\n          int a = nums[i];\\n          int b = nums[j];\\n          int c = nums[k];\\n          if (a < b + c && b < c + a && c < a + b) maxi = max(maxi, a + b + c);\\n        }\\n      }\\n    }\\n    if (maxi > 0) return maxi;\\n    return 0;\\n  }\\n}\\n```\\n\\n## Solution - 4\\n\\n```dart\\nclass Solution {\\n  int largestPerimeter(List<int> nums) {\\n    //sort the vector\\n    nums.sort();\\n    //any triangle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n    int maxPerimeter = 0;\\n\\n    for (int i = 0; i <= nums.length - 3; i++) {\\n      //check the triangle valid condition\\n      if (nums[i] + nums[i + 1] > nums[i + 2]) {\\n        maxPerimeter =\\n            max(maxPerimeter, nums[i] + nums[i + 1] + nums[i + 2]); //find max\\n      }\\n    }\\n\\n    return maxPerimeter; //return the result\\n  }\\n}\\n```\\n\\n## Solution - 5\\n\\n```dart\\nclass Solution {\\n  int largestPerimeter(List<int> nums) {\\n    nums.sort((a, b) => a - b);\\n    int i = nums.length - 1;\\n    while (i >= 0) {\\n      if (nums[i] < nums[i - 1] + nums[i - 2]) {\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n      } else {\\n        i--;\\n      }\\n    }\\n    return 0;\\n  }\\n}\\n```\\n## [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Recursion",
                    "Sorting"
                ],
                "code": "```dart\\nclass Solution {\\n// Runtime: 426 ms, faster than 80.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 149.6 MB, less than 100.00% of Dart online submissions for Largest Perimeter Triangle.\\n\\n  int largestPerimeter(List<int> nums) {\\n    nums.sort();\\n    for (int i = nums.length - 1; i > 1; --i)\\n      if (nums[i] < nums[i - 1] + nums[i - 2])\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n    return 0;\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n// Runtime: 514 ms, faster than 60.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 150.2 MB, less than 20.00% of Dart online submissions for Largest Perimeter Triangle.\\n\\n  //utility method to get max element at given index\\n  void swapToGetMax(List<int> nums, int index) {\\n    int max = 0, maxIndex = -1;\\n    for (int i = 0; i <= index; i++)\\n      if (max < nums[i]) {\\n        max = nums[i];\\n        maxIndex = i;\\n      }\\n    //actual swapping after finding max element in given range\\n    int temp = nums[index];\\n    nums[index] = max;\\n    nums[maxIndex] = temp;\\n  }\\n\\n  int largestPerimeter(List<int> nums) {\\n    //if array has only 3 elements\\n    if (nums.length == 3) {\\n      if (nums[0] < nums[1] + nums[2] &&\\n          nums[1] < nums[0] + nums[2] &&\\n          nums[2] < nums[1] + nums[0])\\n        return nums[0] + nums[1] + nums[2];\\n      else\\n        return 0;\\n    }\\n    //for more than 3 elements, without doing explicit sorting\\n    int n = nums.length;\\n    //here we are putting max element at last index\\n    swapToGetMax(nums, n - 1);\\n    //here we are putting max element at second last index\\n    swapToGetMax(nums, n - 2);\\n    //here we are putting max element at third last index\\n    swapToGetMax(nums, n - 3);\\n    //in loop checking if nums[i]<nums[i-1]+nums[i-2] which this triplet will form the max perimeter\\n    for (int i = n - 1; i >= 2; i--) {\\n      if (nums[i] < nums[i - 1] + nums[i - 2])\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n      //if not then will find max element as (i-3)th largest element\\n      else if (i > 2) swapToGetMax(nums, i - 3);\\n    }\\n    return 0;\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n// Runtime: 596 ms, faster than 40.00% of Dart online submissions for Largest Perimeter Triangle.\\n// Memory Usage: 150.3 MB, less than 20.00% of Dart online submissions for Largest Perimeter Triangle.\\n  int largestPerimeter(List<int> nums) {\\n    if (nums.length == 3) {\\n      if (nums[0] < nums[1] + nums[2] &&\\n          nums[1] < nums[0] + nums[2] &&\\n          nums[2] < nums[1] + nums[0])\\n        return nums[0] + nums[1] + nums[2];\\n      else\\n        return 0;\\n    }\\n    int n = nums.length;\\n    int maxi = 0;\\n    for (int i = 0; i < n - 2; i++) {\\n      for (int j = i + 1; j < n - 1; j++) {\\n        for (int k = j + 1; k < n; k++) {\\n          int a = nums[i];\\n          int b = nums[j];\\n          int c = nums[k];\\n          if (a < b + c && b < c + a && c < a + b) maxi = max(maxi, a + b + c);\\n        }\\n      }\\n    }\\n    if (maxi > 0) return maxi;\\n    return 0;\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n  int largestPerimeter(List<int> nums) {\\n    //sort the vector\\n    nums.sort();\\n    //any triangle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n    int maxPerimeter = 0;\\n\\n    for (int i = 0; i <= nums.length - 3; i++) {\\n      //check the triangle valid condition\\n      if (nums[i] + nums[i + 1] > nums[i + 2]) {\\n        maxPerimeter =\\n            max(maxPerimeter, nums[i] + nums[i + 1] + nums[i + 2]); //find max\\n      }\\n    }\\n\\n    return maxPerimeter; //return the result\\n  }\\n}\\n```\n```dart\\nclass Solution {\\n  int largestPerimeter(List<int> nums) {\\n    nums.sort((a, b) => a - b);\\n    int i = nums.length - 1;\\n    while (i >= 0) {\\n      if (nums[i] < nums[i - 1] + nums[i - 2]) {\\n        return nums[i] + nums[i - 1] + nums[i - 2];\\n      } else {\\n        i--;\\n      }\\n    }\\n    return 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738009,
                "title": "ruby-solution-several-variants-of-sliding-window",
                "content": "##### Leetcode: 976. Largest Perimeter Triangle.\\n\\n\\nIdea is in sorting input array. And sliding window of 3 elements from biggest to smallest elements. If in this window biggest element is less then sum of middle and small one - this means it is largest perimeter in this array, because it is already the biggest elements that granted by required criteria. \\n\\nRuby code:\\n```Ruby\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 88 ms, faster than 33.33% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 13.8 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(a)\\n  a.sort.reverse.each_cons(3).each{|(x,y,z)| \\n      return x+y+z if y+z > x\\n  }\\n 0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 116 ms, faster than 22.22% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 13.9 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(a)\\n  z = a.sort.reverse\\n  (2...z.size).each do |i|\\n      return z[i-2]+z[i-1]+z[i] if z[i-2] < z[i-1] + z[i]\\n  end\\n  0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 176 ms, faster than 11.11% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 12 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(z)\\n  z.sort_by!{|x| -x}\\n  (2...z.size).each do |i|\\n      return z[i-2]+z[i-1]+z[i] if z[i-2] < z[i-1] + z[i]\\n  end\\n  0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 124 ms, faster than 11.11% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 11.9 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(z)\\n  z.sort!\\n  bigest, middle, smallest = z.size-1, z.size-2, z.size-3;\\n  while smallest >= 0\\n     return z[bigest] + z[middle] + z[smallest] if z[bigest] < z[middle] + z[smallest]\\n      bigest -= 1; middle -= 1; smallest -= 1;\\n  end\\n  0\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Sliding Window"
                ],
                "code": "```Ruby\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 88 ms, faster than 33.33% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 13.8 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(a)\\n  a.sort.reverse.each_cons(3).each{|(x,y,z)| \\n      return x+y+z if y+z > x\\n  }\\n 0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 116 ms, faster than 22.22% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 13.9 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(a)\\n  z = a.sort.reverse\\n  (2...z.size).each do |i|\\n      return z[i-2]+z[i-1]+z[i] if z[i-2] < z[i-1] + z[i]\\n  end\\n  0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 176 ms, faster than 11.11% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 12 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(z)\\n  z.sort_by!{|x| -x}\\n  (2...z.size).each do |i|\\n      return z[i-2]+z[i-1]+z[i] if z[i-2] < z[i-1] + z[i]\\n  end\\n  0\\nend\\n# Leetcode: 976. Largest Perimeter Triangle.\\n# https://leetcode.com/problems/largest-perimeter-triangle/\\n# Runtime: 124 ms, faster than 11.11% of Ruby online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 11.9 MB, less than 25.00% of Ruby online submissions for Largest Perimeter Triangle.\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_perimeter(z)\\n  z.sort!\\n  bigest, middle, smallest = z.size-1, z.size-2, z.size-3;\\n  while smallest >= 0\\n     return z[bigest] + z[middle] + z[smallest] if z[bigest] < z[middle] + z[smallest]\\n      bigest -= 1; middle -= 1; smallest -= 1;\\n  end\\n  0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 473798,
                "title": "python-with-heap",
                "content": "1) No need to sort the entire array. We need 3 largest numbers, then may be next largerst etc. Therefore we build the heap, to pre-order data only. O(n) time. Though Python\\'s min heap needs to negate the number, another O(n) run\\n2) To check the triangle rule, no need need to check every 3 combinations of the sides a, b, c, one check is enough. if a is the largest side, then then b < a + c and c < a + b are guaranteed, only need to check if a < b + c holds true\\n\\n```\\nfrom heapq import heapify, heappop\\n\\n\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        for i, x in enumerate(A):\\n            A[i] = -x\\n        heapify(A)\\n        \\n        s0 = -heappop(A)\\n        s1 = -heappop(A)\\n        s2 = -heappop(A)\\n        \\n        try:\\n            while s0 >= s1 + s2:\\n                s0, s1, s2 = s1, s2, -heappop(A)\\n            return s0 + s1 + s2\\n        except IndexError:\\n            return 0\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heapify, heappop\\n\\n\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        for i, x in enumerate(A):\\n            A[i] = -x\\n        heapify(A)\\n        \\n        s0 = -heappop(A)\\n        s1 = -heappop(A)\\n        s2 = -heappop(A)\\n        \\n        try:\\n            while s0 >= s1 + s2:\\n                s0, s1, s2 = s1, s2, -heappop(A)\\n            return s0 + s1 + s2\\n        except IndexError:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741189,
                "title": "c-o-n-sorting-easy-basic-triangle-properties",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n\\t\\t\\n\\t\\t// Sort in reverse order.\\n        sort(nums.begin(), nums.end(), greater<int>()); \\n\\t\\t\\n        int n = nums.size();\\n        int i = 0;\\n\\t\\t\\n\\t\\t// Run loop until we satisfy the basic triangle property ( sum of 2 sides >= third side).\\n\\t\\t// As the array is sorted in reverse order we will always get the maximum perimeter.\\n        while (i < n - 2 && nums[i] >= nums[i + 1] + nums[i + 2]) {\\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// If the we are unable to satisfy the property return 0 else the sum of 3 sides.\\n        return i >= n - 2 ? 0 : nums[i] + nums[i + 1] + nums[i + 2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n\\t\\t\\n\\t\\t// Sort in reverse order.\\n        sort(nums.begin(), nums.end(), greater<int>()); \\n\\t\\t\\n        int n = nums.size();\\n        int i = 0;\\n\\t\\t\\n\\t\\t// Run loop until we satisfy the basic triangle property ( sum of 2 sides >= third side).\\n\\t\\t// As the array is sorted in reverse order we will always get the maximum perimeter.\\n        while (i < n - 2 && nums[i] >= nums[i + 1] + nums[i + 2]) {\\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// If the we are unable to satisfy the property return 0 else the sum of 3 sides.\\n        return i >= n - 2 ? 0 : nums[i] + nums[i + 1] + nums[i + 2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693108,
                "title": "c-java-kotlin-o-n-partial-sorting-using-fibonacci-optimization",
                "content": "The standard solution for this leetcode problem, as shown on the problem\\'s Solution tab and as used by most people\\'s solutions for this problem, is to first sort the entire `nums[]` array, then search for the highest three adjacent values that form a valid triangle.  The code below uses a slightly different algorithm which uses ony a partial heap sort of the `nums[]` array to only sort as many values as needed, with the maximum values to be sorted being 31 as defined by the Fibonacci test case shown further below.  The standard coding solution is O(NlogN) because of the full sort of all `nums[]` values, while the partial sort algorithm is O(N).\\n\\n--- PARTIAL SORT ALGORITHM ---\\nThe solution below optimizes runtime by only doing a partial heap sort to try to solve this problem, which appears to be faster than the standard coding solution for this problem.  In Java, the partial heap sort code below is 8 times faster than my standard solution code, using my fastest runtimes for both coding solutions.  The partial sorting routine `swapMaxElement()` is called each time the next highest number from `nums[]` is needed, and that next highest number is placed toward the end of the `nums[]` array.  The `nums[]` array becomes sorted from the end back toward the start of the array, one value at a time.\\n\\nFirst the three highest values are moved to the last three positions in the `nums[]` array, by calling `swapMaxElement()` three times.  Then we test the triplet made of those highest three values in `nums[]` to see if they form a valid triangle.  A valid triangle is formed if the highest value at `nums[i]` is less than the sum of the next two adjacent lower values in `nums[i-1]` and `nums[i-2]`, when those values are in their sort order within `nums[]`.  If the highest three values in `nums[]` don\\'t form a valid triangle, then call `swapMaxElement()` again to get the next higher value in `nums[]` into its sorted position, then test the next lower triplet of values in `nums[]` to see if they form a valid triangle.  Repeat this process of sorting one more value, then testing the next triplet of adjacent values for a valid triangle, until a valid triangle is found, or we run out of triplets to test.\\n\\n--- FIBONACCI TEST CASE WITHOUT ANY TRIANGLES ---\\nIn this leetcode problem, the longest possible test case which does not form any valid triangle, is shown in sorted order as:\\n```\\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \\n233, 377, 610, 987, 1597, 2584, 4181, 6765, \\n10946, 17711, 28657, 46368, 75025, 121393, \\n196418, 317811, 514229, 832040]\\n```\\nThis test case is formed by starting with 1, 1 then each successive number is the sum of the previous two numbers, which gives the Fibonacci sequence.  This process is repeated until a number exceeds the maximum value, which is defined in this leetcode problem\\'s description as 10^6.  Any test case formed this way will NOT be able to form a valid triangle from any triplet of the values.  **The above test case has 30 values**.\\n\\n--- WORST CASE FOR PARTIAL SORT ---\\nUsing the partial heap sort in the code below, which gets the next higher value for each call to the partial heap sort routine `swapMaxElement()`, we will have to **sort at most 31 values before finding a valid triangle**.  The longest test case without any valid triangle has 30 values, as shown in the example test case above.  If another value is appended to that test case, then that modified test case would contain a valid triangle.  In this leetcode problem, the passed `nums[]` array can have up to 10_000 values.  But in the partial-sorting algorithm in the code below, at most only 31 values would need to be sorted, and usually fewer would need sorting.  This implies that **any test case with 31 or more values MUST contain a valid triangle**.\\n\\nCurrently in this leetcode problem\\'s test cases in October 2022, the worst test case only has to search through 19 triplets before finding a valid triangle.  This means that the partial-sort routine `swapMaxElement` had to be called 19+2=21 times, which is once for each of the 19 triplets searched, plus 2 extra times to create the first triplet.\\n\\nAlthough the Fibonacci test case above is the longest possible test case without any valid triangles, it is not the only possible test case of this length.  For example, adding a positive integer to the last value in the above Fibonacci test case, will result in a test case that still doesn\\'t have any valid triangles.  Other values in that Fibonacci test case can also be increased, as long as all values in the test case are increased by at least the sum of the increase of the previous two values in the test case, which will still result in a test case without any valid triangles.  The Fibonacci test case is the lowest valued test case possible for length 30 while not having any valid triangles.\\n\\n--- EXECUTION TIMES ---\\nThe code below had fast runtimes in C++ (32ms 99%), Java (1ms 100%), and Kotlin (263ms 100%) based on the leetcode problem\\'s graph data on October 10, 2022.  These runtimes are the fastest runtimes from my multiple Submits, and the runtimes and percentages may change in the future as test cases are changed and as other people develop faster code.\\n\\nIf useful, please upvote.\\n\\n**C++ ----------------**\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        swapMaxElement(nums, nums.size() - 1);\\n        swapMaxElement(nums, nums.size() - 2);\\n        for (int i = nums.size() - 1; i >= 2; i--) {\\n            swapMaxElement(nums, i - 2);\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        }\\n        return 0;\\n    }\\n    \\n    void swapMaxElement(vector<int>& nums, int index) {\\n        int max = nums[0];\\n        int maxIndex = 0;\\n        for (int i = 1; i <= index; i++)\\n            if (nums[i] > max)\\n                max = nums[(maxIndex = i)];\\n        nums[maxIndex] = nums[index];\\n        nums[index] = max;\\n    }\\n};\\n```\\n**Java -----------------**\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        swapMaxElement(nums, nums.length - 1);\\n        swapMaxElement(nums, nums.length - 2);\\n        for (int i = nums.length - 1; i >= 2; i--) {\\n            swapMaxElement(nums, i - 2);\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        }\\n        return 0;\\n    }\\n    \\n    \\n    private void swapMaxElement(int[] nums, int index) {\\n        int max = nums[0];\\n        int maxIndex = 0;\\n        for (int i = 1; i <= index; i++)\\n            if (nums[i] > max)\\n                max = nums[(maxIndex = i)];\\n        nums[maxIndex] = nums[index];\\n        nums[index] = max;\\n    }\\n}\\n```\\n**Kotlin ----------------**\\n```\\nclass Solution {\\n    fun largestPerimeter(nums: IntArray): Int {\\n        swapMaxElement(nums, nums.lastIndex)\\n        swapMaxElement(nums, nums.lastIndex - 1)\\n        for (i in nums.lastIndex downTo 2) {\\n            swapMaxElement(nums, i - 2)\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2]\\n        }\\n        return 0\\n    }\\n    \\n    \\n    fun swapMaxElement(nums: IntArray, index: Int) {\\n        var max = nums[0]\\n        var maxIndex = 0\\n        for (i in 1..index)\\n            if (nums[i] > max) {\\n                max = nums[i]\\n                maxIndex = i\\n            }\\n        nums[maxIndex] = nums[index]\\n        nums[index] = max\\n    }\\n}\\n```\\n\\n\\n**Java (standard solution) --------------**\\nThe following Java code is the solution that most people use, and is the official solution on the Solution tab for this leetcode problem.  This code is much simpler than the faster code above.  It simply sorts the `nums[]` array in ascending order.  Then search backward in the array from highest to lowest values, to find the first three adjacent values in the sorted array which can form a valid triangle.\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = nums.length - 1; i >= 2; i--)\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        return 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Kotlin"
                ],
                "code": "```\\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \\n233, 377, 610, 987, 1597, 2584, 4181, 6765, \\n10946, 17711, 28657, 46368, 75025, 121393, \\n196418, 317811, 514229, 832040]\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        swapMaxElement(nums, nums.size() - 1);\\n        swapMaxElement(nums, nums.size() - 2);\\n        for (int i = nums.size() - 1; i >= 2; i--) {\\n            swapMaxElement(nums, i - 2);\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        }\\n        return 0;\\n    }\\n    \\n    void swapMaxElement(vector<int>& nums, int index) {\\n        int max = nums[0];\\n        int maxIndex = 0;\\n        for (int i = 1; i <= index; i++)\\n            if (nums[i] > max)\\n                max = nums[(maxIndex = i)];\\n        nums[maxIndex] = nums[index];\\n        nums[index] = max;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        swapMaxElement(nums, nums.length - 1);\\n        swapMaxElement(nums, nums.length - 2);\\n        for (int i = nums.length - 1; i >= 2; i--) {\\n            swapMaxElement(nums, i - 2);\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        }\\n        return 0;\\n    }\\n    \\n    \\n    private void swapMaxElement(int[] nums, int index) {\\n        int max = nums[0];\\n        int maxIndex = 0;\\n        for (int i = 1; i <= index; i++)\\n            if (nums[i] > max)\\n                max = nums[(maxIndex = i)];\\n        nums[maxIndex] = nums[index];\\n        nums[index] = max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun largestPerimeter(nums: IntArray): Int {\\n        swapMaxElement(nums, nums.lastIndex)\\n        swapMaxElement(nums, nums.lastIndex - 1)\\n        for (i in nums.lastIndex downTo 2) {\\n            swapMaxElement(nums, i - 2)\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2]\\n        }\\n        return 0\\n    }\\n    \\n    \\n    fun swapMaxElement(nums: IntArray, index: Int) {\\n        var max = nums[0]\\n        var maxIndex = 0\\n        for (i in 1..index)\\n            if (nums[i] > max) {\\n                max = nums[i]\\n                maxIndex = i\\n            }\\n        nums[maxIndex] = nums[index]\\n        nums[index] = max\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = nums.length - 1; i >= 2; i--)\\n            if (nums[i] < nums[i - 1] + nums[i - 2])\\n                return nums[i] + nums[i - 1] + nums[i - 2];\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692676,
                "title": "two-method-c-explanation-solution-sorting-greedy",
                "content": "**Approach 1**\\n\\n      int largestPerimeter(vector<int>& nums) {\\n        //sort the vector\\n        sort(nums.begin(),nums.end());\\n        //any tringle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n        int maxPerimeter=0;\\n        \\n        for(int i=0;i<=nums.size()-3;i++){\\n            //check the triangle valid condition\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                maxPerimeter=max(maxPerimeter,nums[i]+nums[i+1]+nums[i+2]); //find max\\n            }\\n        }\\n        \\n        return maxPerimeter; //return the result\\n    }\\n\\t\\n\\t\\n\\t\\n**Approach 2 : Sort the array**\\n**We know that max value gives maximum perimeter...so use greedy method...choose element from the last and if valid triangle then return the value**\\n\\n\\n\\n        int largestPerimeter(vector<int>& nums) {\\n        //sort the vector\\n        sort(nums.begin(),nums.end());\\n        //any tringle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n        \\n        \\n        for(int i=nums.size()-1;i>=2;i--){\\n            //check the triangle valid condition\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                return(nums[i]+nums[i-1]+nums[i-2]); //perimeter\\n            }\\n        }\\n        \\n        return 0; //return 0\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "**Approach 1**\\n\\n      int largestPerimeter(vector<int>& nums) {\\n        //sort the vector\\n        sort(nums.begin(),nums.end());\\n        //any tringle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n        int maxPerimeter=0;\\n        \\n        for(int i=0;i<=nums.size()-3;i++){\\n            //check the triangle valid condition\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                maxPerimeter=max(maxPerimeter,nums[i]+nums[i+1]+nums[i+2]); //find max\\n            }\\n        }\\n        \\n        return maxPerimeter; //return the result\\n    }\\n\\t\\n\\t\\n\\t\\n**Approach 2 : Sort the array**\\n**We know that max value gives maximum perimeter...so use greedy method...choose element from the last and if valid triangle then return the value**\\n\\n\\n\\n        int largestPerimeter(vector<int>& nums) {\\n        //sort the vector\\n        sort(nums.begin(),nums.end());\\n        //any tringle sum of smaller two side greater than 3rd side...so we check that condition, a+b>c where a<b<c\\n        \\n        \\n        for(int i=nums.size()-1;i>=2;i--){\\n            //check the triangle valid condition\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                return(nums[i]+nums[i-1]+nums[i-2]); //perimeter\\n            }\\n        }\\n        \\n        return 0; //return 0\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2692674,
                "title": "python-o-nlog-n-greedy-short",
                "content": "For a triangle to be valid it must satisfy the triangle inequality.\\n\\nWe sort the array in descending order and then iterate through looking for the largest perimeter triangle in a greedy fashion.\\n\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        # triange in-equality a+b > c\\n        # sum of 2 smallest > largest\\n        nums.sort(reverse=True)\\n        a,b,c = inf,inf,inf\\n        for n in nums:\\n            a, b, c = n, a, b\\n            if a + b > c:\\n                return a+b+c       \\n        return 0\\n         \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        # triange in-equality a+b > c\\n        # sum of 2 smallest > largest\\n        nums.sort(reverse=True)\\n        a,b,c = inf,inf,inf\\n        for n in nums:\\n            a, b, c = n, a, b\\n            if a + b > c:\\n                return a+b+c       \\n        return 0\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692525,
                "title": "c-solution-using-geometry",
                "content": "# **Steps**\\n* Sort the **array**\\n* Apply the geometry principe of triangle \"**The sum of the length of the two sides of a triangle is greater than the length of the third side**\" **A<B+C**\\n* Do the reverse iteration. \\n* Apply these logic `nums[i] + nums[i+1]>nums[i+2]` \\n*  `nums[i] + nums[i+1]>nums[i+2]` if it is true then return `nums[i] + nums[i+1] + nums[i+2]`\\n*  return `0`\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i= nums.size()-3;i>=0;i--){\\n            if(nums[i] + nums[i+1]>nums[i+2]){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Geometry",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i= nums.size()-3;i>=0;i--){\\n            if(nums[i] + nums[i+1]>nums[i+2]){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500264,
                "title": "c-faster-than-97-88-solution-easy-code-with-comments-o-1-space",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n\\t\\n\\t//Sort The Array\\n        sort(nums.begin(), nums.end());\\n        \\n        int i = nums.size()-1;\\n\\t\\t\\n\\t\\t//Traverse From back so that we get largest perimeter of valid Triangle\\n        while(i>=2)\\n        {\\n\\t\\t// s1 Will Be Largest Side\\n            int s1 = nums[i];\\n            int s2 = nums[i-1];\\n            int s3 = nums[i-2];\\n           \\n\\t\\t   // Apply Triangle Side i.e. Sum of Smaller Two Sides is greater Than Largest Side\\n            if(s1 < s3 + s2)\\n                return s1 + s2 +s3;\\n            i--;\\n        }\\n        \\n\\t\\t// if no valid triangle return 0\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n\\t\\n\\t//Sort The Array\\n        sort(nums.begin(), nums.end());\\n        \\n        int i = nums.size()-1;\\n\\t\\t\\n\\t\\t//Traverse From back so that we get largest perimeter of valid Triangle\\n        while(i>=2)\\n        {\\n\\t\\t// s1 Will Be Largest Side\\n            int s1 = nums[i];\\n            int s2 = nums[i-1];\\n            int s3 = nums[i-2];\\n           \\n\\t\\t   // Apply Triangle Side i.e. Sum of Smaller Two Sides is greater Than Largest Side\\n            if(s1 < s3 + s2)\\n                return s1 + s2 +s3;\\n            i--;\\n        }\\n        \\n\\t\\t// if no valid triangle return 0\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000126,
                "title": "python-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums):\\n        nums.sort(reverse=True)\\n        \\n        for i in range(len(nums)-2):\\n            base, side1, side2 = nums[i], nums[i+1], nums[i+2]\\n            if side1 + side2 > base:\\n                return base + side1 + side2\\n\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums):\\n        nums.sort(reverse=True)\\n        \\n        for i in range(len(nums)-2):\\n            base, side1, side2 = nums[i], nums[i+1], nums[i+2]\\n            if side1 + side2 > base:\\n                return base + side1 + side2\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910480,
                "title": "c-beginner-level-solution",
                "content": "Here I\\'ve sorted the vector nums and then searched triplets starting from the end.\\n\\nAs we know, for three sides to be a triangle it has to have **two sides sum that is bigger than the third one**.\\n\\n```\\nsort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2])\\n                return nums[i]+nums[i+1]+nums[i+2];            \\n        }\\n        return 0;\\n\\n```\\nupvote if you find this helpful. Thanks.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nsort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2])\\n                return nums[i]+nums[i+1]+nums[i+2];            \\n        }\\n        return 0;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1804033,
                "title": "easy-understanding-beginner-friendly-please-upvote-if-understood",
                "content": "class Solution {\\npublic:\\n\\n    int largestPerimeter(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        for(int i=n-1;i>1;i--){\\n            int c=v[i];\\n            int a=v[i-1];\\n            int b=v[i-2];\\n            if(c<a+b)\\n                return a+b+c;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int largestPerimeter(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        for(int i=n-1;i>1;i--){\\n            int c=v[i];\\n            int a=v[i-1];\\n            int b=v[i-2];\\n            if(c<a+b)\\n                return a+b+c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1554430,
                "title": "rust-solutions-8-ms-0-ms",
                "content": "1. Simple solution with sort (O(N logN)). Runtime =  **8 ms**\\n```\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable_by(|a, b| b.cmp(a));\\n        match nums.windows(3).find(|l| l[0] < l[1] + l[2]) {\\n            Some(l) => l.iter().sum(),\\n            None => 0,\\n        }\\n    }\\n}\\n```\\n2. Solution with BinaryHeap (O(N logK)). Runtime =  **0 ms**\\n```\\n impl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        let mut heap = std::collections::BinaryHeap::from(nums);\\n        let (mut b, mut c) = (-1, -1);\\n        while let Some(a) = heap.pop() {\\n            if a > 0 && b > 0 && c > 0 && c < b + a {\\n                return a + b + c;\\n            }\\n            c = b;\\n            b = a;\\n        }\\n        0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable_by(|a, b| b.cmp(a));\\n        match nums.windows(3).find(|l| l[0] < l[1] + l[2]) {\\n            Some(l) => l.iter().sum(),\\n            None => 0,\\n        }\\n    }\\n}\\n```\n```\\n impl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        let mut heap = std::collections::BinaryHeap::from(nums);\\n        let (mut b, mut c) = (-1, -1);\\n        while let Some(a) = heap.pop() {\\n            if a > 0 && b > 0 && c > 0 && c < b + a {\\n                return a + b + c;\\n            }\\n            c = b;\\n            b = a;\\n        }\\n        0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099407,
                "title": "c-5-2-lines-o-n-log-n-solution-use-qsort",
                "content": "```\\nbool comp(void*a,void*b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestPerimeter(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    for(int i=numsSize-3;i>=0;i--){\\n        if(nums[i]+nums[i+1]>nums[i+2]){\\n            return nums[i]+nums[i+1]+nums[i+2];\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool comp(void*a,void*b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestPerimeter(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    for(int i=numsSize-3;i>=0;i--){\\n        if(nums[i]+nums[i+1]>nums[i+2]){\\n            return nums[i]+nums[i+1]+nums[i+2];\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390818,
                "title": "two-solutions-in-python-3-beats-95",
                "content": "_One For Loop:_\\n```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n    \\tL, _ = len(A), A.sort()\\n    \\tfor i in range(L-1,1,-1):\\n    \\t\\tif A[i] < A[i-1] + A[i-2]: return sum(A[i-2:i+1])\\n    \\treturn 0\\n\\t\\t\\n\\t\\t\\n```\\n_Two For Loops:_\\n```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n    \\tL, _ = len(A), A.sort()\\n    \\tfor i in range(L-1,1,-1):\\n    \\t\\ta = A[i]\\n    \\t\\tfor j in range(i-1,0,-1):\\n    \\t\\t\\tb, m, c = A[j], a - A[j] + 1, A[j-1]\\n    \\t\\t\\tif m > b: break\\n    \\t\\t\\tif c >= m: return a + b + c\\n    \\treturn 0\\n\\t\\t\\n\\t\\t\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n    \\tL, _ = len(A), A.sort()\\n    \\tfor i in range(L-1,1,-1):\\n    \\t\\tif A[i] < A[i-1] + A[i-2]: return sum(A[i-2:i+1])\\n    \\treturn 0\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672612,
                "title": "80-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n    int n = nums.length;\\n    Arrays.sort(nums);\\n    if(n<3){\\n        return 0;\\n    }    \\n    for(int i=n-1;i>=2;i--){\\n        if(nums[i-1]+nums[i-2]>nums[i]){\\n            return nums[i]+nums[i-1]+nums[i-2];\\n        }\\n    }\\n    return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n    int n = nums.length;\\n    Arrays.sort(nums);\\n    if(n<3){\\n        return 0;\\n    }    \\n    for(int i=n-1;i>=2;i--){\\n        if(nums[i-1]+nums[i-2]>nums[i]){\\n            return nums[i]+nums[i-1]+nums[i-2];\\n        }\\n    }\\n    return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542385,
                "title": "precise-explanation-of-why-sort-used-from-scratch",
                "content": "## Explanation\\n```\\n    Assume a = 2, b = 1, c = 2\\n\\nNow we have to find out if it\\'s possible to make a triangle using a,b,c.\\n\\nIF \\'EVERY\\' TWO SIDE\\'S SUMMATION FROM (a,b,c) > THIRD SIDE, THEN IT\\'S POSSIBLE\\n\\na + b > c          a + c > b           b + c > a\\n2 + 1 > 2          2 + 2 > 1           1 + 2 > 2\\n3 > 2              4 > 1               3 > 2\\n\\nDoesn\\'t matter which 2 side we pick, it\\'s summation always strictly larger than\\nthe third side. BUT IF ANY TWO SIDE\\'S SUMMATION WAS NOT LARGER THAN THE THIRD\\nSIDE, THEN THE TRIANGLE IS NOT POSSIBLE!\\n\\nAssume a = 1, b = 1, c = 2\\n\\na + c > b       b + c > a       BUT   a + b > c ?\\n1 + 2 > 1       1 + 2 > 1             1 + 1 > 2 ? \\n                                      FALSEEEEEE\\n\\nHence, with a = 1, b = 1, c = 2 making triangle is not possible!\\n\\nSo first we have to find if there is one single variation ( from a+b>c, \\na+c>b, b+c>a) is FALSE or not.\\n\\nLook the last example where if a and b both 1 but c = 2, means if  we sum c with\\neither a or b then it will be always larger than the third side because \\nTHE VALUE OF C IS LARGER THAN A AND B, SO IT\\'S ALREADY LARGER AND IF WE SUM IT \\nWITH A OR B THEN IT WILL BE MORE LARGER THAN THE THIRD SIDE (A/B).\\nSO WE WILL DO SUM OF THE FIRST TWO SMALL VALUES, IF THEIR SUM > THIRD SIDE, \\nTHEN WE CAN CLEARLY SAY THE OTHER TWO VARIATIONS (a+c>b & b+c>a) IS TRUE!\\n\\na, b = first two small values in sorted order and c = equal or larger than b\\n\\nAssume a, b, c = 1, 2, 2 (in sorted order)\\nsince a + b > c then no need to check for a + c > b   &   b + c > a\\n      1 + 2 > 2                           1 + 2 > 2       2 + 2 > 1\\n      3 > 2\\n\\nalso say a, b, c = 1, 1, 1\\n                   a + b > c so also a + c > b    b + c > a\\n                   1 + 1 > 1         1 + 1 > 1    1 + 1 > 1\\n                   2 > 1\\n    \\nSo the key point is for every three value (a,b,c) we need to check ONLY \\nTHE FIRST 2 SMALL VALUES I.E. if a+b>c then we will compare the summation \\nof those a,b,c with the rest.. \" ONLY THE FIRST 2 SMALL VALUES \"\\nSO THAT MEANS WE NEED TO SORT THE list/vector FIRST! Then for each index \\n(except the last 2) just check if nums[i] + nums[i+1] > nums[i+2]...\\n```\\nThere is 3 type variation I showed, so in order to check JUST ONE, we need to\\nsort it first.\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(begin(nums),end(nums));\\n        int sum = 0, size = nums.size()-2, a, b, c;\\n        for(int i=0; i<size; i++)\\n        {\\n            a = nums[i], b = nums[i+1], c = nums[i+2];\\n            if(a+b>c)\\n                sum = max(a+b+c, sum);\\n        }\\n        return sum;\\n    }\\n}; \\n```\\n```Python []\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max( sum(nums[i:i+3]) if nums[i]+nums[i+1] > nums[i+2] else 0 for i in range(len(nums)-2) )\\n```\\n```\\nTime complexity  : O(sort)\\nSpace complexity : O(sort)\\n\\nO(sort) as the sort function is hybrid sort, so it depends which sorting \\ntechnique is being used in the sort function. \\n```\\n## If any of the information was wrong please leave a comment with correctness. If the post was helpful an upvote will really make me happy:)\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\n    Assume a = 2, b = 1, c = 2\\n\\nNow we have to find out if it\\'s possible to make a triangle using a,b,c.\\n\\nIF \\'EVERY\\' TWO SIDE\\'S SUMMATION FROM (a,b,c) > THIRD SIDE, THEN IT\\'S POSSIBLE\\n\\na + b > c          a + c > b           b + c > a\\n2 + 1 > 2          2 + 2 > 1           1 + 2 > 2\\n3 > 2              4 > 1               3 > 2\\n\\nDoesn\\'t matter which 2 side we pick, it\\'s summation always strictly larger than\\nthe third side. BUT IF ANY TWO SIDE\\'S SUMMATION WAS NOT LARGER THAN THE THIRD\\nSIDE, THEN THE TRIANGLE IS NOT POSSIBLE!\\n\\nAssume a = 1, b = 1, c = 2\\n\\na + c > b       b + c > a       BUT   a + b > c ?\\n1 + 2 > 1       1 + 2 > 1             1 + 1 > 2 ? \\n                                      FALSEEEEEE\\n\\nHence, with a = 1, b = 1, c = 2 making triangle is not possible!\\n\\nSo first we have to find if there is one single variation ( from a+b>c, \\na+c>b, b+c>a) is FALSE or not.\\n\\nLook the last example where if a and b both 1 but c = 2, means if  we sum c with\\neither a or b then it will be always larger than the third side because \\nTHE VALUE OF C IS LARGER THAN A AND B, SO IT\\'S ALREADY LARGER AND IF WE SUM IT \\nWITH A OR B THEN IT WILL BE MORE LARGER THAN THE THIRD SIDE (A/B).\\nSO WE WILL DO SUM OF THE FIRST TWO SMALL VALUES, IF THEIR SUM > THIRD SIDE, \\nTHEN WE CAN CLEARLY SAY THE OTHER TWO VARIATIONS (a+c>b & b+c>a) IS TRUE!\\n\\na, b = first two small values in sorted order and c = equal or larger than b\\n\\nAssume a, b, c = 1, 2, 2 (in sorted order)\\nsince a + b > c then no need to check for a + c > b   &   b + c > a\\n      1 + 2 > 2                           1 + 2 > 2       2 + 2 > 1\\n      3 > 2\\n\\nalso say a, b, c = 1, 1, 1\\n                   a + b > c so also a + c > b    b + c > a\\n                   1 + 1 > 1         1 + 1 > 1    1 + 1 > 1\\n                   2 > 1\\n    \\nSo the key point is for every three value (a,b,c) we need to check ONLY \\nTHE FIRST 2 SMALL VALUES I.E. if a+b>c then we will compare the summation \\nof those a,b,c with the rest.. \" ONLY THE FIRST 2 SMALL VALUES \"\\nSO THAT MEANS WE NEED TO SORT THE list/vector FIRST! Then for each index \\n(except the last 2) just check if nums[i] + nums[i+1] > nums[i+2]...\\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(begin(nums),end(nums));\\n        int sum = 0, size = nums.size()-2, a, b, c;\\n        for(int i=0; i<size; i++)\\n        {\\n            a = nums[i], b = nums[i+1], c = nums[i+2];\\n            if(a+b>c)\\n                sum = max(a+b+c, sum);\\n        }\\n        return sum;\\n    }\\n}; \\n```\n```Python []\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max( sum(nums[i:i+3]) if nums[i]+nums[i+1] > nums[i+2] else 0 for i in range(len(nums)-2) )\\n```\n```\\nTime complexity  : O(sort)\\nSpace complexity : O(sort)\\n\\nO(sort) as the sort function is hybrid sort, so it depends which sorting \\ntechnique is being used in the sort function. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105410,
                "title": "a-easy-python-solution",
                "content": "The below code is a class Solution that defines a method largestPerimeter which takes in an input array A representing the lengths of the sides of a triangle.\\n\\nThe first line of the function sorts the input array in descending order using the sort() method with the reverse=True argument. This is done so that the largest side of the triangle will be at the first index of the array after sorting.\\n\\nThen the function uses a for loop to iterate through the sorted array starting from the first index to the second last index, which is represented by the range (len(A)-2).\\n\\nThe loop assigns the first element of the array to the variable a, the second element to the variable b, and the third element to the variable c at each iteration.\\n\\nThen it checks if the variable a is less than the sum of b and c using an if statement. If this condition is true, it means that the sides b and c are longer than the side a and therefore can form a triangle. In this case, the function returns the sum of the three sides a, b, and c as the largest perimeter.\\n\\nIf the if statement is not true, the loop continues iterating through the array until it finds a combination of sides that can form a triangle or until it reaches the end of the array.\\n\\nIf the loop ends and no combination of sides that can form a triangle is found, the function returns 0 as the answer.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def largestPerimeter(self, A):\\n        A.sort(reverse=True)\\n\\n        for i in range(len(A)-2):\\n            a = A[i]\\n            b= A[i+1]\\n            c = A[i+2]\\n            if a< b+ c:\\n                return a+b+c\\n            \\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def largestPerimeter(self, A):\\n        A.sort(reverse=True)\\n\\n        for i in range(len(A)-2):\\n            a = A[i]\\n            b= A[i+1]\\n            c = A[i+2]\\n            if a< b+ c:\\n                return a+b+c\\n            \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944456,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        for(int i=0; i<nums.size()-2; i++) {\\n            if(nums[i] >= nums[i+1] + nums[i+2]) continue;\\n            return nums[i] + nums[i+1] + nums[i+2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        for(int i=0; i<nums.size()-2; i++) {\\n            if(nums[i] >= nums[i+1] + nums[i+2]) continue;\\n            return nums[i] + nums[i+1] + nums[i+2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695066,
                "title": "easy-java-solution-straight-forward-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = n-3; i >= 0; i --){\\n            if(nums[i] + nums[i+1] > nums[i+2]){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }   \\n        }\\n        return 0;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = n-3; i >= 0; i --){\\n            if(nums[i] + nums[i+1] > nums[i+2]){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }   \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694194,
                "title": "c-easy-solution-o-n-log-n",
                "content": "# Approach\\nSTEP-1: Sort the vector\\nSTEP-2: Traverse the vector from last elements, check if last 3 elements can for a triangle, if true return sum of elements.\\n\\n# Complexity\\n- Time complexity: O(n log(n))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& n) {\\n        sort(n.begin(), n.end());\\n\\n        for(int i = n.size()-3; i >= 0; i--)\\n        {\\n            if(n[i] + n[i+1] > n[i+2])\\n            {\\n                return n[i] + n[i+1] + n[i+2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& n) {\\n        sort(n.begin(), n.end());\\n\\n        for(int i = n.size()-3; i >= 0; i--)\\n        {\\n            if(n[i] + n[i+1] > n[i+2])\\n            {\\n                return n[i] + n[i+1] + n[i+2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694029,
                "title": "c-simple-sort-try-big-and-a-b-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1] > nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1] > nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693225,
                "title": "6-lines",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            a,b,c=nums[i],nums[i+1],nums[i+2]\\n            if( not (a+b<=c or b+c<=a or c+a<=b)):\\n                return a+b+c\\n        return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            a,b,c=nums[i],nums[i+1],nums[i+2]\\n            if( not (a+b<=c or b+c<=a or c+a<=b)):\\n                return a+b+c\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693009,
                "title": "python-c-java-faster-than-99-57-simple-short-solution-easy-to-understand",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q976. Largest Perimeter Triangle***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>1;i--)\\n        \\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        return 0;       \\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                sum=max(sum,nums[i]+nums[i+1]+nums[i+2]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)[::-1]\\n        for i in range(len(nums) - 2):\\n            if nums[i] < nums[i + 1] + nums[i + 2]:\\n                return nums[i] + nums[i + 1] + nums[i + 2]\\n        return 0\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>1;i--)\\n        \\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        return 0;       \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                sum=max(sum,nums[i]+nums[i+1]+nums[i+2]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692688,
                "title": "js-with-explanation-easy-to-understand-simple",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/largest-perimeter-triangle.html\\nIt is very useful, and I just wanted to share it with you. \\nYou can bookmark it as a resource \\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n      const N = nums.length - 2;\\n      for (let i = 0; i < N; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) return nums[i] + nums[i + 1] + nums[i + 2];\\n      }\\n      return 0;\\n};\\n```\\n\\n```\\nRuntime: 191 ms, faster than 13.37% of JavaScript online submissions for Largest Perimeter Triangle.\\nMemory Usage: 45.3 MB, less than 75.97% of JavaScript online submissions for Largest Perimeter Triangle.\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n      const N = nums.length - 2;\\n      for (let i = 0; i < N; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) return nums[i] + nums[i + 1] + nums[i + 2];\\n      }\\n      return 0;\\n};\\n```\n```\\nRuntime: 191 ms, faster than 13.37% of JavaScript online submissions for Largest Perimeter Triangle.\\nMemory Usage: 45.3 MB, less than 75.97% of JavaScript online submissions for Largest Perimeter Triangle.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692403,
                "title": "explained-java-solutions",
                "content": "**upvote if it helped**\\nask any query if u got\\n**--------------from naive to best solution---------------------------------**\\n\\n**Naive approach**\\n\\n* check for all combinations of 3 elements, whether it forms a triangle or not, and update the maximum perimeter if it forms a triangle. The complexity of the naive solution is O(n3). Below is the code for it. *\\n\\n**------------------------------------------------------------------------------------------CODE------------------------------------------------------------------------------------**\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        if(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        int n = nums.length;\\n        int max = 0;\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            for (int j = i + 1; j < n - 1; j++)\\n            {\\n                for (int k = j + 1; k < n; k++)\\n                {\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    int c = nums[k];\\n                    if (a < b+c && b < c+a && c < a+b)\\n                        max = Math.max(max, a+b+c);\\n                }\\n            }\\n        }\\n        if(max>0)\\n            return max;\\n        return 0;\\n    }\\n}\\n```\\n\\n**Approach for the efficient solution**\\n\\n*First, we can sort the array in non-increasing order. So, the first element will be the maximum and the last will be the minimum. Now if the first 3 elements of this sorted array form a triangle, then it will be the maximum perimeter triangle, as for all other combinations the sum of elements(i.e. the perimeter of that triangle) will be = b >= c). a, b,c can not form a triangle, so a >= b + c. As, b and c = c+d (if we drop b and take d) or a >= b+d (if we drop c and take d). So, we have to drop a and pick up d. \\n\\nAgain, the same set of analysis for b, c, and d. We can continue this till end and whenever we find a triangle forming a triple, then we can stop checking, as this triple gives a maximum perimeter. \\n\\nHence, if arr[i] < arr[i+1] + arr[i+2] (0 <= i <= n-3)in the sorted array, then arr[i], arr[i+1] and arr[i+2] form a triangle. *\\n\\n**------------------------------------------------------------------------------------------CODE------------------------------------------------------------------------------------**\\n\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\tif(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for(int i=nums.length-1;i>=2;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                max = Math.max(max, nums[i]+nums[i-1]+nums[i-2]);\\n                break;\\n            }\\n        }\\n        if(max>0)\\n            return max;\\n        return 0;\\n    }\\n}\\n```\\n\\nTime complexity: O(n*log(n)). This much time is required to sort the array.\\nSpace complexity: O(1) since constant space is used.\\n\\n**Even better solution(1ms solution)**\\n*Without explicit sorting, we can do it this way too*\\n\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        //if array has only 3 elements\\n        if(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        //for more than 3 elements, without doing explicit sorting\\n        int n = nums.length;\\n        //here we are putting max element at last index\\n        swapToGetMax(nums, n-1);\\n        //here we are putting max element at second last index\\n        swapToGetMax(nums, n-2);\\n        //here we are putting max element at third last index\\n        swapToGetMax(nums, n-3);\\n        //in loop checking if nums[i]<nums[i-1]+nums[i-2] which this triplet will form the max perimeter\\n        for(int i=n-1;i>=2;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n            //if not then will find max element as (i-3)th largest element\\n            else if(i>2)\\n                swapToGetMax(nums, i-3);\\n        }\\n        return 0;\\n    }\\n    \\n    //utility method to get max element at given index\\n    private void swapToGetMax(int[] nums, int index){\\n        int max=0, maxIndex=-1;\\n        for(int i=0;i<=index;i++)\\n            if(max<nums[i]){\\n                max=nums[i];\\n                maxIndex=i;\\n            }\\n        //actual awapping after finding max element in given range\\n        int temp = nums[index];\\n        nums[index] = max;\\n        nums[maxIndex] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        if(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        int n = nums.length;\\n        int max = 0;\\n        for (int i = 0; i < n - 2; i++)\\n        {\\n            for (int j = i + 1; j < n - 1; j++)\\n            {\\n                for (int k = j + 1; k < n; k++)\\n                {\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    int c = nums[k];\\n                    if (a < b+c && b < c+a && c < a+b)\\n                        max = Math.max(max, a+b+c);\\n                }\\n            }\\n        }\\n        if(max>0)\\n            return max;\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\tif(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for(int i=nums.length-1;i>=2;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                max = Math.max(max, nums[i]+nums[i-1]+nums[i-2]);\\n                break;\\n            }\\n        }\\n        if(max>0)\\n            return max;\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        //if array has only 3 elements\\n        if(nums.length==3){\\n            if(nums[0]<nums[1]+nums[2] && nums[1]<nums[0]+nums[2] && nums[2]<nums[1]+nums[0])\\n                return nums[0]+nums[1]+nums[2];\\n            else\\n                return 0;\\n        }\\n        //for more than 3 elements, without doing explicit sorting\\n        int n = nums.length;\\n        //here we are putting max element at last index\\n        swapToGetMax(nums, n-1);\\n        //here we are putting max element at second last index\\n        swapToGetMax(nums, n-2);\\n        //here we are putting max element at third last index\\n        swapToGetMax(nums, n-3);\\n        //in loop checking if nums[i]<nums[i-1]+nums[i-2] which this triplet will form the max perimeter\\n        for(int i=n-1;i>=2;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n            //if not then will find max element as (i-3)th largest element\\n            else if(i>2)\\n                swapToGetMax(nums, i-3);\\n        }\\n        return 0;\\n    }\\n    \\n    //utility method to get max element at given index\\n    private void swapToGetMax(int[] nums, int index){\\n        int max=0, maxIndex=-1;\\n        for(int i=0;i<=index;i++)\\n            if(max<nums[i]){\\n                max=nums[i];\\n                maxIndex=i;\\n            }\\n        //actual awapping after finding max element in given range\\n        int temp = nums[index];\\n        nums[index] = max;\\n        nums[maxIndex] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692401,
                "title": "ruby-1-liner",
                "content": "```ruby\\ndef largest_perimeter(nums)\\n    nums.sort!.reverse.each_cons(3) { |a, b, c| return a + b + c if a < b + c } && 0\\nend\\n```\\n<hr>\\n\\n# Tests:\\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_largest_perimeter < Test::Unit::TestCase\\n    def test_\\n        assert_equal 5, largest_perimeter([2,1,2])\\n        assert_equal 0, largest_perimeter([1,2,1])\\n    end\\nend\\n```\\n\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef largest_perimeter(nums)\\n    nums.sort!.reverse.each_cons(3) { |a, b, c| return a + b + c if a < b + c } && 0\\nend\\n```\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_largest_perimeter < Test::Unit::TestCase\\n    def test_\\n        assert_equal 5, largest_perimeter([2,1,2])\\n        assert_equal 0, largest_perimeter([1,2,1])\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295098,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        // declare variables\\n        int n = nums.size();\\n        int prev = n-3; // the smallest side of the triangle\\n        int next = n-2; // the second largest side of the triangle\\n        int last = n-1; // the largest side of the triangle\\n        \\n        sort(nums.begin(), nums.end()); // sorting an array\\n        \\n        while(nums[prev] + nums[next] <= nums[last]) { // The triangle inequality must be satisfied\\n            last--;\\n            next--;\\n            prev--;\\n            if(prev < 0) return 0; // if no such triple is found, return 0 as given in the condition\\n        }\\n        return nums[prev]+nums[next]+nums[last]; // return the perimeter\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        // declare variables\\n        int n = nums.size();\\n        int prev = n-3; // the smallest side of the triangle\\n        int next = n-2; // the second largest side of the triangle\\n        int last = n-1; // the largest side of the triangle\\n        \\n        sort(nums.begin(), nums.end()); // sorting an array\\n        \\n        while(nums[prev] + nums[next] <= nums[last]) { // The triangle inequality must be satisfied\\n            last--;\\n            next--;\\n            prev--;\\n            if(prev < 0) return 0; // if no such triple is found, return 0 as given in the condition\\n        }\\n        return nums[prev]+nums[next]+nums[last]; // return the perimeter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287707,
                "title": "swift-solution-with-explanation",
                "content": "```\\n/* The only geometory you need to know to solve this problem is that a \\'non-zero \\narea triangle\\' is any triangle where c < a + b.  If you take any one side of a \\ntriangle (C) and it\\'s less than the sum of the other two, (A + B) and then do the same\\nfor all sides, and if they\\'re all true, than it is a valid (non zero area) triangle.  \\nHowever, if you start with the highest Int in a set of 3 sides you don\\'t need to \\ntest all 3 sides. If the highest Int of the 3 sides is less than the sum of the other \\n2 than we can conclude that the triangle is non-zero area triangle.\\n*/\\n\\nclass Solution {\\n    \\n    func largestPerimeter(_ nums: [Int]) -> Int {\\n        \\n        // Sort array of ints in descending order\\n        let x = nums.sorted(by: >)\\n        \\n        /* Loop through the sorted array in chunks of 3 Ints checking if the \\n\\t\\tfirst (highest) Int is less than the sum of the second and third,  until \\n\\t\\tyou reach the end. At each iteration the largest int will always be at \\n\\t\\tthe front therefore if it is a non-zero triangle all other sides will also \\n\\t\\tresult in a non-zero solution in which case you can just reutrn the \\n\\t\\tsum of all sides for the highest perimeter triangle.\\n\\t\\t*/\\n        for (i, _) in x.enumerated() where i <= x.count - 3 {\\n            if x[i] < x[i + 1] + x[i + 2] {\\n                return x[i] + x[i + 1] + x[i + 2]\\n            }\\n        }\\n        // If we exit the loop without finding any non-zero solutions we return 0\\n        return 0\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/* The only geometory you need to know to solve this problem is that a \\'non-zero \\narea triangle\\' is any triangle where c < a + b.  If you take any one side of a \\ntriangle (C) and it\\'s less than the sum of the other two, (A + B) and then do the same\\nfor all sides, and if they\\'re all true, than it is a valid (non zero area) triangle.  \\nHowever, if you start with the highest Int in a set of 3 sides you don\\'t need to \\ntest all 3 sides. If the highest Int of the 3 sides is less than the sum of the other \\n2 than we can conclude that the triangle is non-zero area triangle.\\n*/\\n\\nclass Solution {\\n    \\n    func largestPerimeter(_ nums: [Int]) -> Int {\\n        \\n        // Sort array of ints in descending order\\n        let x = nums.sorted(by: >)\\n        \\n        /* Loop through the sorted array in chunks of 3 Ints checking if the \\n\\t\\tfirst (highest) Int is less than the sum of the second and third,  until \\n\\t\\tyou reach the end. At each iteration the largest int will always be at \\n\\t\\tthe front therefore if it is a non-zero triangle all other sides will also \\n\\t\\tresult in a non-zero solution in which case you can just reutrn the \\n\\t\\tsum of all sides for the highest perimeter triangle.\\n\\t\\t*/\\n        for (i, _) in x.enumerated() where i <= x.count - 3 {\\n            if x[i] < x[i + 1] + x[i + 2] {\\n                return x[i] + x[i + 1] + x[i + 2]\\n            }\\n        }\\n        // If we exit the loop without finding any non-zero solutions we return 0\\n        return 0\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243859,
                "title": "sort-then-o-1-space",
                "content": "```\\nfunc largestPerimeter(nums []int) int {\\n    if len(nums) < 3 { return 0 }\\n    \\n    sort.Ints(nums)\\n    \\n    right := len(nums)-1\\n    \\n    for right >= 2 {\\n        if nums[right-2] > nums[right-1]-nums[right] && nums[right-2] > nums[right]-nums[right-1] {\\n            return nums[right-2]+nums[right-1]+nums[right]\\n        }\\n        \\n        right--\\n    }\\n        \\n    return 0\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```\\nfunc largestPerimeter(nums []int) int {\\n    if len(nums) < 3 { return 0 }\\n    \\n    sort.Ints(nums)\\n    \\n    right := len(nums)-1\\n    \\n    for right >= 2 {\\n        if nums[right-2] > nums[right-1]-nums[right] && nums[right-2] > nums[right]-nums[right-1] {\\n            return nums[right-2]+nums[right-1]+nums[right]\\n        }\\n        \\n        right--\\n    }\\n        \\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2220814,
                "title": "python3-simple-naive-approach",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n        for i in range(len(A) - 2):\\n            if A[i] < A[i+1] + A[i+2]:\\n                return A[i] + A[i+1] + A[i+2]\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n        for i in range(len(A) - 2):\\n            if A[i] < A[i+1] + A[i+2]:\\n                return A[i] + A[i+1] + A[i+2]\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136139,
                "title": "python-easy-and-simple-solution",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        #sum of two side should always be greater than third side\\n        nums.sort()\\n        nums.reverse()\\n        for i in range(len(nums)-2):\\n            base,side1,side2 = nums[i],nums[i+1],nums[i+2] \\n            if side1+side2>base:\\n                return side1+side2+base\\n        return 0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        #sum of two side should always be greater than third side\\n        nums.sort()\\n        nums.reverse()\\n        for i in range(len(nums)-2):\\n            base,side1,side2 = nums[i],nums[i+1],nums[i+2] \\n            if side1+side2>base:\\n                return side1+side2+base\\n        return 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887575,
                "title": "c-easy-approach-with-explanation",
                "content": "##### Hola Coders!!\\n\\nThere is a property of triangle where **if two sides is greater then the third side** ***we can get the larget perimeter triangle***, to getting the lagest triangle we sort the array and start from the right most corner that is largest element in the array. Using this logic we first run the loop from **length of vector -1** to the **third element** *(after third element triangle not possible)*, we keep on decreasing loop value by **1**, use three variables to store values from the vetor to compare, *if we found the right combination* we return the value, if not then we *continue iteration till the end,* after completing iteration of the loop we simply **return 0**.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n            if(a+b>c)\\n            {\\n                return a+b+c;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```\\nWe can further optimize it by not storing values in the variables and can directly compare the values to the array in the if condition that way we can optimize the space. \\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n           \\n            if(nums[i-2]+nums[i-1]>nums[i])\\n            {\\n                return nums[i-2]+nums[i-1]+nums[i];\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n            if(a+b>c)\\n            {\\n                return a+b+c;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n           \\n            if(nums[i-2]+nums[i-1]>nums[i])\\n            {\\n                return nums[i-2]+nums[i-1]+nums[i];\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827946,
                "title": "python-o-nlog-n",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)-1, 1, -1):\\n            a, b, c = nums[i-2], nums[i-1], nums[i]\\n            if (c < a + b):\\n                return a + b + c\\n        return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)-1, 1, -1):\\n            a, b, c = nums[i-2], nums[i-1], nums[i]\\n            if (c < a + b):\\n                return a + b + c\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817714,
                "title": "java-solution-6-ms-faster-than-99-40-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] a) {\\n        Arrays.sort(a);\\n        for(int i=a.length - 1; i>1; i--){\\n             if(a[i] < (a[i-1] + a[i- 2])){\\n                  return (a[i]+a[i - 1]+ a[i - 2]);\\n             }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] a) {\\n        Arrays.sort(a);\\n        for(int i=a.length - 1; i>1; i--){\\n             if(a[i] < (a[i-1] + a[i- 2])){\\n                  return (a[i]+a[i - 1]+ a[i - 2]);\\n             }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700134,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        //select largest three that can form a triangle\\n        sort(nums.begin(),nums.end());\\n        //triangle property -> sum of smaller two > largest\\n        // first valid triplet from end will give maximum perimeter\\n        //other can not give maximum answer\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n            if(a+b>c) return a+b+c;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        //select largest three that can form a triangle\\n        sort(nums.begin(),nums.end());\\n        //triangle property -> sum of smaller two > largest\\n        // first valid triplet from end will give maximum perimeter\\n        //other can not give maximum answer\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n            if(a+b>c) return a+b+c;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489431,
                "title": "easy-sorting-c",
                "content": "Upvote will be highly appreciated\\n\\nclass Solution {\\npublic:\\n\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.rbegin(),nums.rend());\\n        \\n        \\n        for(int i = 0; i<nums.size()-2; i++){\\n            if(nums[i]<nums[i+1]+nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.rbegin(),nums.rend());\\n        \\n        \\n        for(int i = 0; i<nums.size()-2; i++){\\n            if(nums[i]<nums[i+1]+nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3274884,
                "title": "c-easy-sort-iterate",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n3 given sides A, B & Cform a triange iff -->>\\n**A + B > C**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort (nums.begin(), nums.end()) ; \\n\\n        for (int i = nums.size() - 3 ; i >= 0 ; i --)\\n        {\\n            if (nums[i] + nums[i + 1] > nums[i + 2])\\n            {\\n                return nums[i] + nums[i + 1] + nums[i + 2] ; \\n            }\\n        }\\n        return 0 ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/2150dec5-333c-46a4-bfc8-06195ebcc357_1678340224.2938855.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort (nums.begin(), nums.end()) ; \\n\\n        for (int i = nums.size() - 3 ; i >= 0 ; i --)\\n        {\\n            if (nums[i] + nums[i + 1] > nums[i + 2])\\n            {\\n                return nums[i] + nums[i + 1] + nums[i + 2] ; \\n            }\\n        }\\n        return 0 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265892,
                "title": "java-easy-and-explained-solution-speed-beats-99-7",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the array** after **sorting** it with  with `Arrays.sort()`. \\n\\n*At each iteration* we have to compare the three greater values:\\n1) If **is a triangle**, return  the perimeter. This happen if *the sum of two sides is larger than the last side*;\\n2) If **is not a triangle**, start the next iteration looking at the values at position `i--`;\\n\\n**Note:** In Java, we have **different ways to sort an array**, usually the best are `Arrays.sort()` and `Collection.sort()`. When we are working with primitive datatypes like int, `Arrays.sort()` proves to be way more time efficient than `Collections.sort()`\\n \\n**Arrays.sort():** make the sort inside the array.\\n**Collections.sort():** is used mainly to sort list, this means that it make more steps to do the same opeartion.\\n\\n# Complexity\\n- **Time complexity:** $O(n*log(n))$\\n- **Speed Beats:** 99.7%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 1; i >= 2; i--)\\n            if (nums[i] < nums[i-1] + nums[i-2])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 1; i >= 2; i--)\\n            if (nums[i] < nums[i-1] + nums[i-2])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924186,
                "title": "java-easy-solution",
                "content": "java, simple triangle property\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--){\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                return nums[i-1]+nums[i-2]+nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--){\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                return nums[i-1]+nums[i-2]+nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704786,
                "title": "java-72-15-faster-o-nlogn-beginner-friendly-with-comments",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);   \\n        int max=0;\\n        for(int i=0;i<=nums.length-3;i++){\\n            int a = nums[i];     \\n            int b = nums[i+1];\\n            int c = nums[i+2]; \\n            if((a+b)>c){        \\n                        int temp = a+b+c;\\n                        if(max<temp){\\n                            max = temp;      \\n                }\\n            }else{\\n             continue;   \\n            }\\n        }\\n        return max;       \\n    }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);   \\n        int max=0;\\n        for(int i=0;i<=nums.length-3;i++){\\n            int a = nums[i];     \\n            int b = nums[i+1];\\n            int c = nums[i+2]; \\n            if((a+b)>c){        \\n                        int temp = a+b+c;\\n                        if(max<temp){\\n                            max = temp;      \\n                }\\n            }else{\\n             continue;   \\n            }\\n        }\\n        return max;       \\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699306,
                "title": "true-o-n-in-c-better-than-o-n-log-n",
                "content": "By definition the Fibonacci sequence is an integer sequence that has no triplets making up a triangle of a non-zero area (triangle-triplets), as each number is the sum of the two preceding numbers:\\n\\n```\\n1 1 2 3 5 8 13 ...\\n```\\n\\nFor a given length `n`, among all sorted sequences of natural numbers with no triangle-triplets, the Fibonacci sequence is the sequence with the smallest number `a[i]` for `0 <= i < n`. In other words, it\\'s the lexicographically smallest sequence of numbers without triangle-triplets.\\n\\nKnowing the maximum possible number `x` in the array (1\\'000\\'000 for this problem), we can find the length `K` of the longest sequence that has no triangle-triplets using the next formula (or alternatively with the familiar Fibonacci number iterative algorithm):\\n\\n```\\nK = ceil(log(x * sqrt(5) - .5) / log(1.618))\\n```\\n\\nIf a sequence of numbers with a maximum element `x` has more than `K` elements, then it   contains triangle-triplets.\\n\\nNow I state that if there are no triangle-triplets in the top-K elements of an array of numbers, then there are no triangle-triplets in the whole array. To find the largest perimeter triangle we only need to consider the top-K elements of the array of numbers.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n    https://leetcode.com/qyryq/\\n        int k = min(invfib(1\\'000\\'000), nums.size());\\n        priority_queue<int, vector<int>, greater<>> q;\\n        for (auto n : nums)\\n            if (q.size() < k || n >= q.top()) {\\n                q.push(n);\\n                if (q.size() > k) q.pop();\\n            }\\n        vector<int> v;\\n        for (; !q.empty(); q.pop())\\n            v.emplace_back(q.top());\\n        for (size_t i = k-3; i < k; i--)\\n            if (v[i]+v[i+1] > v[i+2])\\n                return v[i]+v[i+1]+v[i+2];\\n        return 0;\\n    }\\nprivate:\\n    size_t invfib(size_t x) const {\\n        // https://stackoverflow.com/a/5162856/\\n        // https://en.wikipedia.org/wiki/Fibonacci_number#Relation_to_the_golden_ratio\\n        return ceil(log(x * sqrt(5) - .5) / log(1.618));\\n    }\\n};\\n```\\n\\nThe complexity of the algorithm is O(N * log( invfib(M) )), where N is the length of the `nums` vector and M is the maximum possible number in the vector. As M is fixed in this problem, we may consider the complexity of this algorithm to be O(N).\\n\\nOn large arrays the next approach is almost twice as fast as the priority queue one:\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n    https://leetcode.com/qyryq/\\n        const size_t k = 32ul;\\n        size_t imin = 0;\\n        vector<int> q(k, 0);\\n        for (const auto& n : nums)\\n            if (n > q[imin]) {\\n                q[imin] = n;\\n                imin = distance(begin(q), min_element(begin(q), end(q)));\\n            }\\n        sort(begin(q), end(q), greater{});\\n        for (size_t i = 0; i < k-2; i++)\\n            if (q[i] < q[i+1] + q[i+2])\\n                return q[i]+q[i+1]+q[i+2];\\n        return 0;\\n    }\\n};\\n```\\n\\nHere I use `32ul` constant instead of calling `invfib` function, but it\\'s not what makes the code faster. What does make it faster is the simplified loop body, that finds the smallest element in the `q` vector that holds the top-K elements. Asymptotically it should take more time that the priority queue approach, but I suppose the streamlined code is more \"comfortable\" for the modern CPU architecture to execute.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n1 1 2 3 5 8 13 ...\\n```\n```\\nK = ceil(log(x * sqrt(5) - .5) / log(1.618))\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n    https://leetcode.com/qyryq/\\n        int k = min(invfib(1\\'000\\'000), nums.size());\\n        priority_queue<int, vector<int>, greater<>> q;\\n        for (auto n : nums)\\n            if (q.size() < k || n >= q.top()) {\\n                q.push(n);\\n                if (q.size() > k) q.pop();\\n            }\\n        vector<int> v;\\n        for (; !q.empty(); q.pop())\\n            v.emplace_back(q.top());\\n        for (size_t i = k-3; i < k; i--)\\n            if (v[i]+v[i+1] > v[i+2])\\n                return v[i]+v[i+1]+v[i+2];\\n        return 0;\\n    }\\nprivate:\\n    size_t invfib(size_t x) const {\\n        // https://stackoverflow.com/a/5162856/\\n        // https://en.wikipedia.org/wiki/Fibonacci_number#Relation_to_the_golden_ratio\\n        return ceil(log(x * sqrt(5) - .5) / log(1.618));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n    https://leetcode.com/qyryq/\\n        const size_t k = 32ul;\\n        size_t imin = 0;\\n        vector<int> q(k, 0);\\n        for (const auto& n : nums)\\n            if (n > q[imin]) {\\n                q[imin] = n;\\n                imin = distance(begin(q), min_element(begin(q), end(q)));\\n            }\\n        sort(begin(q), end(q), greater{});\\n        for (size_t i = 0; i < k-2; i++)\\n            if (q[i] < q[i+1] + q[i+2])\\n                return q[i]+q[i+1]+q[i+2];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695633,
                "title": "super-average-solution-with-fastest-run-time-java",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0,n=nums.length;i<n-2;i++)\\n            if(nums[n-i-1]<nums[n-i-2]+nums[n-i-3])\\n                return nums[n-i-1]+nums[n-i-2]+nums[n-i-3];\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0,n=nums.length;i<n-2;i++)\\n            if(nums[n-i-1]<nums[n-i-2]+nums[n-i-3])\\n                return nums[n-i-1]+nums[n-i-2]+nums[n-i-3];\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695554,
                "title": "java-simple-solution-in-o-nlogn-with-easy-explanation",
                "content": "triangle sum property is used\\nwhich says side1+side2 > side3 when side3>side2>side1\\n\\nso to get the highest perimeter , we are first sorting the array first to get the maximum elements\\n\\n\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int per=0;// case where triangle will not be formed will be handled by per=0;\\n        for(int i=nums.length-1;i>=2; i--)\\n        {\\n            if(nums[i-1]+nums[i-2]>nums[i])\\n            {\\n                per=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n            \\n        }\\n        return per;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int per=0;// case where triangle will not be formed will be handled by per=0;\\n        for(int i=nums.length-1;i>=2; i--)\\n        {\\n            if(nums[i-1]+nums[i-2]>nums[i])\\n            {\\n                per=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n            \\n        }\\n        return per;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695058,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse=1)\\n        \\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] + nums[i+2]:\\n                return sum(nums[i:i+3])\\n\\t\\t\\t\\t\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse=1)\\n        \\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] + nums[i+2]:\\n                return sum(nums[i:i+3])\\n\\t\\t\\t\\t\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695028,
                "title": "c-using-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n         // for finding largest perimeter we are iterating arry from backwards\\n        for(int i=a.size()-1;i>1;i--)\\n        {\\n            if(a[i-2]+a[i-1]>a[i])\\n            {\\n             return a[i]+a[i-1]+a[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n         // for finding largest perimeter we are iterating arry from backwards\\n        for(int i=a.size()-1;i>1;i--)\\n        {\\n            if(a[i-2]+a[i-1]>a[i])\\n            {\\n             return a[i]+a[i-1]+a[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694351,
                "title": "python-5-liner-91-8-solution-sort",
                "content": "```python\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            if sum(nums[i:i+3])>2*nums[i]:\\n                return sum(nums[i:i+3])\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            if sum(nums[i:i+3])>2*nums[i]:\\n                return sum(nums[i:i+3])\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693695,
                "title": "java-easy-solution",
                "content": "Triangle property : sum of any two sides must be greater than the third side.\\nwe have to find out maximum perimter that\\'s why we sorted array and check property of triangle from last 3 elements of array if it\\'s satisfied then return because it would be maximum perimeter.\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 2; i--){\\n            int first = nums[i];\\n            int second = nums[i - 1];\\n            int third = nums[i - 2];\\n            if(second + third > first){\\n                return (second + third + first);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 2; i--){\\n            int first = nums[i];\\n            int second = nums[i - 1];\\n            int third = nums[i - 2];\\n            if(second + third > first){\\n                return (second + third + first);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693690,
                "title": "easiest-runtime-0-ms-faster-than-100-submissions-sorting",
                "content": "```\\nclass Solution {\\n   public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i =n-1; i>=2; i--) {\\n            if(nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n   public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i =n-1; i>=2; i--) {\\n            if(nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693372,
                "title": "93-3-in-runtime-and-91-6-in-space-for-begginers",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        #sort the array iin decreasing order\\n        #TRIANGLE RULE\\n        #sum of two arre greater than third side\\n        nums.sort(reverse=True)\\n        for i in range(3,len(nums)+1):\\n            if nums[i-3]<nums[i-2]+nums[i-1]:\\n                return sum(nums[i-3:i])\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        #sort the array iin decreasing order\\n        #TRIANGLE RULE\\n        #sum of two arre greater than third side\\n        nums.sort(reverse=True)\\n        for i in range(3,len(nums)+1):\\n            if nums[i-3]<nums[i-2]+nums[i-1]:\\n                return sum(nums[i-3:i])\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693105,
                "title": "java-simple-and-optimized-solution-3-lines-of-code",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i=nums.length-3; i >= 0; i--)\\n            if (nums[i] + nums[i+1] > nums[i+2])\\n                return nums[i] + nums[i+1] + nums[i+2];\\n        return 0;\\n    }\\n}\\n\\n/*\\nAlternate logic is that you can also use-\\nArrays.sort(nums);\\n        for (int i=nums.length-3; i >= 0; i--)\\n            if (nums[i-1] + nums[i-2] > nums[i])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;*/\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i=nums.length-3; i >= 0; i--)\\n            if (nums[i] + nums[i+1] > nums[i+2])\\n                return nums[i] + nums[i+1] + nums[i+2];\\n        return 0;\\n    }\\n}\\n\\n/*\\nAlternate logic is that you can also use-\\nArrays.sort(nums);\\n        for (int i=nums.length-3; i >= 0; i--)\\n            if (nums[i-1] + nums[i-2] > nums[i])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693092,
                "title": "simple-java-solution-with-explaination",
                "content": "**Logic used -**\\n* perimeter of triangle - summation of sides of triangle (**p = l1 + l2 + l3**)\\n* Triangle property - In order to create a triangle, largest side is always lesser than the summation of other two sides (**l1 < l2 + l3** considering l1 > l2, l3)\\n\\n**Explanation -**\\n\\n1.  we need largest three sides to form a triangle, so better to sort an array.\\n2.  loop from the last element and pick last three element, if they satisfy the triangle property then return it.\\n3.  Otherwise no solution found, return 0 \\n\\n\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int last = nums.length-1;\\n        while(last-1 > 0){\\n            if(nums[last] < nums[last-1] + nums[last-2]) // triangle property => largest size < addition of other two sides\\n                return nums[last] + nums[last-1] + nums[last-2];\\n            last--;\\n        }\\n        return 0;\\n    }\\n}\\n```\\nTC - O(nlogn)\\nSC - O(1)\\n***Please upvote if you understood the solution, comment if you have any doubt.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int last = nums.length-1;\\n        while(last-1 > 0){\\n            if(nums[last] < nums[last-1] + nums[last-2]) // triangle property => largest size < addition of other two sides\\n                return nums[last] + nums[last-1] + nums[last-2];\\n            last--;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692972,
                "title": "c-solution-time-complexity-o-n-log-n-clean-and-concise-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<nums.size()-2;i++)\\n             if(nums[i+2]+nums[i+1]>nums[i])\\n               return nums[i+2]+nums[i+1]+nums[i];\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<nums.size()-2;i++)\\n             if(nums[i+2]+nums[i+1]>nums[i])\\n               return nums[i+2]+nums[i+1]+nums[i];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692898,
                "title": "very-basic-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n Arrays.sort(nums);\\n \\n    for(int i=nums.length-1;i>1;i--){\\n        int a = nums[i-2];\\n        int b = nums[i-1];\\n        int c = nums[i];\\n\\t\\t\\n\\t\\t//sum of all the sides\\n\\t\\t\\tint s = a + b + c;\\n        \\n\\t\\t//condition for triangle\\n        if(a+b>c)\\n\\t\\t{\\n            return s;\\n        }\\n    }\\n\\n    return 0;\\n      \\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n Arrays.sort(nums);\\n \\n    for(int i=nums.length-1;i>1;i--){\\n        int a = nums[i-2];\\n        int b = nums[i-1];\\n        int c = nums[i];\\n\\t\\t\\n\\t\\t//sum of all the sides\\n\\t\\t\\tint s = a + b + c;\\n        \\n\\t\\t//condition for triangle\\n        if(a+b>c)\\n\\t\\t{\\n            return s;\\n        }\\n    }\\n\\n    return 0;\\n      \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692711,
                "title": "optimal-solution-c-easy-to-understand-complete-explanation",
                "content": "## Largest Perimeter Triangle - OPTIMAL SOLUTION \\u2705[ C++ ] \\u2705|| EASY TO UNDERSTAND || COMPLETE EXPLANATION\\n\\n***Please upvote if you like it.***\\n\\n### EXPLANATION:\\n![image](https://assets.leetcode.com/users/images/dba3a79b-c5fa-4532-9004-4d4b2dfb880a_1665544668.6957664.png)\\n![image](https://assets.leetcode.com/users/images/f88b382d-b97a-49b9-a2f7-ffc13717c120_1665544727.603764.png)\\n\\n\\n\\n#### Time Complexity : O(NlogN + N)    -------->Sort and traverse array\\n#### Space Complexity : O(logN) ----> While sorting \\n### </>CODE :\\n### \\n```\\n class Solution\\n{\\npublic:\\n    int largestPerimeter(vector<int> &a)\\n    {\\n        sort(a.begin(), a.end(), greater<int>());\\n        for(auto x: a)\\n        {\\n            cout<<x<<\" \";\\n        }\\n\\n        for (int i = 2; i < a.size(); i++)\\n        {\\n            // side 1 = a[i-2] ---> greatest side\\n            // side 2 = a[i-1]\\n            // side 3 = a[i]   \\n\\n            if (a[i-2] < (a[i - 1] + a[i]))\\n            {\\n                return a[i] + a[i - 1] + a[i - 2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n class Solution\\n{\\npublic:\\n    int largestPerimeter(vector<int> &a)\\n    {\\n        sort(a.begin(), a.end(), greater<int>());\\n        for(auto x: a)\\n        {\\n            cout<<x<<\" \";\\n        }\\n\\n        for (int i = 2; i < a.size(); i++)\\n        {\\n            // side 1 = a[i-2] ---> greatest side\\n            // side 2 = a[i-1]\\n            // side 3 = a[i]   \\n\\n            if (a[i-2] < (a[i - 1] + a[i]))\\n            {\\n                return a[i] + a[i - 1] + a[i - 2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2692697,
                "title": "c-99-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();  \\n        for(int i = n-1;i>1;i--)\\n\\t\\t      if(nums[i] < nums[i-1] + nums[i-2]) return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        int n = nums.size();  \\n        for(int i = n-1;i>1;i--)\\n\\t\\t      if(nums[i] < nums[i-1] + nums[i-2]) return nums[i] + nums[i-1] + nums[i-2];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692533,
                "title": "c-solution-3-lines",
                "content": "**Idea:** We can make a  triangle if we have arr[i+1] + arr[i+2] > arr[i] mean sum of two sides should be greater than third side.\\n```\\n int largestPerimeter(vector<int>& arr) {\\n         sort(arr.rbegin(),arr.rend());\\n         for(int i =0;i<arr.size()-2;i++)\\n             if(arr[i+1] + arr[i+2] > arr[i])return arr[i+1] + arr[i+2] + arr[i];\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int largestPerimeter(vector<int>& arr) {\\n         sort(arr.rbegin(),arr.rend());\\n         for(int i =0;i<arr.size()-2;i++)\\n             if(arr[i+1] + arr[i+2] > arr[i])return arr[i+1] + arr[i+2] + arr[i];\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692328,
                "title": "daily-leetcoding-challenge-october-day-12",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-perimeter-triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-perimeter-triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2625238,
                "title": "easiest-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);// Sort the array so as to fetch elements from last\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i-2]+nums[i-1]>nums[i]) //A figure is a triangle if sum of two sides is greater than third  checking for each case\\n                return (nums[i-2]+nums[i-1]+nums[i]);// returnunng the perimeter\\n        }\\n        return 0;// if no side found return 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);// Sort the array so as to fetch elements from last\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i-2]+nums[i-1]>nums[i]) //A figure is a triangle if sum of two sides is greater than third  checking for each case\\n                return (nums[i-2]+nums[i-1]+nums[i]);// returnunng the perimeter\\n        }\\n        return 0;// if no side found return 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615371,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i-2]+nums[i-1]>nums[i])\\n                return (nums[i-2]+nums[i-1]+nums[i]);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i-2]+nums[i-1]>nums[i])\\n                return (nums[i-2]+nums[i-1]+nums[i]);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584139,
                "title": "simplest-ruby-solution",
                "content": "Begin by sorting the array, then reversing.\\nThen we can look at one triplet at a time.  If that triplet can form a triangle, then it is the largest.\\n(They can form a triangle if the two shorter sides add to more than the longest side)\\n\\n\\ndef largest_perimeter(nums)\\n    nums = nums.sort.reverse\\n    useLength = nums.length - 3\\n    \\n    for i in 0..useLength do\\n        if nums[i+2] + nums[i+1] > nums[i]\\n            return nums[i+2] + nums[i+1] + nums[i]\\n        end\\n    end\\n    \\n    return 0\\n    \\nend",
                "solutionTags": [
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "Begin by sorting the array, then reversing.\\nThen we can look at one triplet at a time.  If that triplet can form a triangle, then it is the largest.\\n(They can form a triangle if the two shorter sides add to more than the longest side)\\n\\n\\ndef largest_perimeter(nums)\\n    nums = nums.sort.reverse\\n    useLength = nums.length - 3\\n    \\n    for i in 0..useLength do\\n        if nums[i+2] + nums[i+1] > nums[i]\\n            return nums[i+2] + nums[i+1] + nums[i]\\n        end\\n    end\\n    \\n    return 0\\n    \\nend",
                "codeTag": "Python3"
            },
            {
                "id": 2355621,
                "title": "python-short-simple",
                "content": "```\\ndef largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1]+nums[i+2]:\\n                return nums[i] + nums[i+1] + nums[i+2]\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1]+nums[i+2]:\\n                return nums[i] + nums[i+1] + nums[i+2]\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2340977,
                "title": "c-explaination",
                "content": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] nums) {\\n        // triangle = sum of 2 sides must be greater than the 3rd side\\n        // sort the array so that we can look for the max value at the end of it.\\n        // i = nums.Length - 3 => we need minimum 3 values for a triangle & to prevent index out of bound as well\\n        \\n        Array.Sort(nums);\\n        \\n        for(int i = nums.Length - 3; i >= 0; i--) {\\n            if(nums[i] + nums[i + 1] > nums[i + 2])\\n                return (nums[i] + nums[i + 1] + nums[i + 2]);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] nums) {\\n        // triangle = sum of 2 sides must be greater than the 3rd side\\n        // sort the array so that we can look for the max value at the end of it.\\n        // i = nums.Length - 3 => we need minimum 3 values for a triangle & to prevent index out of bound as well\\n        \\n        Array.Sort(nums);\\n        \\n        for(int i = nums.Length - 3; i >= 0; i--) {\\n            if(nums[i] + nums[i + 1] > nums[i + 2])\\n                return (nums[i] + nums[i + 1] + nums[i + 2]);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282650,
                "title": "python-faster-than-92-81-sorting",
                "content": "```\\nclass Solution:       \\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort() \\n        N = len(nums)\\n        res = 0\\n        for i in range(N - 1, 1, -1): \\n            if nums[i-2] + nums[i-1] > nums[i]:\\n                return nums[i-2] + nums[i-1] + nums[i]\\n            \\n        return 0\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:       \\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort() \\n        N = len(nums)\\n        res = 0\\n        for i in range(N - 1, 1, -1): \\n            if nums[i-2] + nums[i-1] > nums[i]:\\n                return nums[i-2] + nums[i-1] + nums[i]\\n            \\n        return 0\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281077,
                "title": "python-greedy-approach-easily-explained",
                "content": "# \\u2714PYTHON\\uD83D\\uDC0DGREEDY APPROACH, EASILY EXPLAINED.\\n\\nWe know `the condition to form a triangle of non-zero area is a + b > c`, meaning sum of two sides > remaing side.\\nSince we have to return the largest perimeter we sort nums in reverse order and take first 3 numbers and check the condition, \\nif true we return the sum of three sides(perimeter of a triangel) else after the loop we retutn 0.\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for a, b, c in zip(nums, nums[1: ], nums[2: ]):\\n            if b+c > a:\\n                return a+b+c\\n        return 0\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for a, b, c in zip(nums, nums[1: ], nums[2: ]):\\n            if b+c > a:\\n                return a+b+c\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203376,
                "title": "largest-perimeter-triangle",
                "content": "class Solution {\\n\\n    public int largestPerimeter(int[] nums) {\\n        int end = nums.length - 1;\\n        Arrays.sort(nums);\\n        while(1 < end){\\n            if (nums[end] + nums[end - 1] > nums[end - 2] && nums[end] + nums[end - 2] > nums[end - 1] && nums[end - 1] + nums[end - 2] > nums[end]){\\n                return nums[end] + nums[end - 1] + nums[end - 2];\\n            }\\n            end--;\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int largestPerimeter(int[] nums) {\\n        int end = nums.length - 1;\\n        Arrays.sort(nums);\\n        while(1 < end){\\n            if (nums[end] + nums[end - 1] > nums[end - 2] && nums[end] + nums[end - 2] > nums[end - 1] && nums[end - 1] + nums[end - 2] > nums[end]){\\n                return nums[end] + nums[end - 1] + nums[end - 2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2173861,
                "title": "javascript-solution-typescript-easy-to-understand",
                "content": "```\\nfunction largestPerimeter(nums: number[]): number {\\n    nums.sort((a, b) => b - a);\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] < nums[i+1] + nums[i+2]) {\\n            return nums[i] + nums[i+1] + nums[i+2];\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sorting"
                ],
                "code": "```\\nfunction largestPerimeter(nums: number[]): number {\\n    nums.sort((a, b) => b - a);\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] < nums[i+1] + nums[i+2]) {\\n            return nums[i] + nums[i+1] + nums[i+2];\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2172763,
                "title": "python-simple-python-solution-using-sorting",
                "content": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\n# Runtime: 212 ms, faster than 81.66% of Python3 online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 15.4 MB, less than 45.46% of Python3 online submissions for Largest Perimeter Triangle.\\n\\tclass Solution:\\n\\t\\tdef largestPerimeter(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tnums = sorted(nums)\\n\\n\\t\\t\\ti = len(nums)-3\\n\\n\\t\\t\\twhile i>-1:\\n\\n\\t\\t\\t\\tif nums[i]+nums[i+1] > nums[i+2]:\\n\\n\\t\\t\\t\\t\\treturn nums[i]+nums[i+1]+nums[i+2]\\n\\n\\t\\t\\t\\ti = i - 1\\n\\n\\t\\t\\treturn 0\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\n# Runtime: 212 ms, faster than 81.66% of Python3 online submissions for Largest Perimeter Triangle.\\n# Memory Usage: 15.4 MB, less than 45.46% of Python3 online submissions for Largest Perimeter Triangle.\\n\\tclass Solution:\\n\\t\\tdef largestPerimeter(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tnums = sorted(nums)\\n\\n\\t\\t\\ti = len(nums)-3\\n\\n\\t\\t\\twhile i>-1:\\n\\n\\t\\t\\t\\tif nums[i]+nums[i+1] > nums[i+2]:\\n\\n\\t\\t\\t\\t\\treturn nums[i]+nums[i+1]+nums[i+2]\\n\\n\\t\\t\\t\\ti = i - 1\\n\\n\\t\\t\\treturn 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 2149681,
                "title": "0ms100-faster-solution-ez-2-line-logic-c",
                "content": "Sort the array in Desc order and check if sum of next 2 elements is greater than the greatest of the 3 !\\n class Solution {\\n \\n public:\\n   \\n    int largestPerimeter(vector<int>& nums) {\\n        \\n\\t\\tsort(nums.begin(),nums.end(),greater<int>());\\n        \\n        for(int i=0;i<nums.size()-2;i++){\\n            \\n            if(nums[i]<nums[i+1]+nums[i+2])\\n                return nums[i] + nums[i+1] + nums[i+2];\\n        }  \\n       \\n     return 0;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n \\n public:\\n   \\n    int largestPerimeter(vector<int>& nums) {\\n        \\n\\t\\tsort(nums.begin(),nums.end(),greater<int>());\\n        \\n        for(int i=0;i<nums.size()-2;i++){\\n            \\n            if(nums[i]<nums[i+1]+nums[i+2])\\n                return nums[i] + nums[i+1] + nums[i+2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1954971,
                "title": "python-solution-with-explanation-about-triangle-properties",
                "content": "```python\\ndef largest_perimeter(nums: list[int]) -> int:\\n  \\'\\'\\'\\n  Per the triangle inequality theorem, for any triangle, including degenerate triangles with zero area:\\n    0 <= a <= b <= c\\n    a + b >= c\\n  Where a, b, and c are the side lengths of the triangle.\\n  Reference: https://en.wikipedia.org/wiki/Degeneracy_(mathematics)#Triangle\\n\\n  But for this problem, we don\\'t need to worry about degenerate triangles.\\n\\n  Therefore, for a triangle with non-zero area, the following expression must hold true:\\n    0 < a <= b <= c\\n    a + b > c\\n  To be clear, the sum of the two shortest sides of the triangle must be greater than the longest side.\\n\\n  Thus, we simply need to sort the list, so that we choose the largest possible a, b, and c that will form a civilized triangle.\\n\\n  Complexity Analysis\\n  Time Complexity: O(n log n), where n is the length of nums.\\n  Space Complexity: O(1).\\n\\n  Runtime: 194 ms, faster than 91.18% of Python3 online submissions for Largest Perimeter Triangle.\\n  Memory Usage: 15.6 MB, less than 9.30% of Python3 online submissions for Largest Perimeter Triangle.\\n  \\'\\'\\'\\n  nums = sorted(nums, reverse=True)\\n  for i in range(len(nums) - 2):\\n    a = nums[i+2]\\n    b = nums[i+1]\\n    c = nums[i]\\n    if a + b > c:\\n      return a + b + c\\n  return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef largest_perimeter(nums: list[int]) -> int:\\n  \\'\\'\\'\\n  Per the triangle inequality theorem, for any triangle, including degenerate triangles with zero area:\\n    0 <= a <= b <= c\\n    a + b >= c\\n  Where a, b, and c are the side lengths of the triangle.\\n  Reference: https://en.wikipedia.org/wiki/Degeneracy_(mathematics)#Triangle\\n\\n  But for this problem, we don\\'t need to worry about degenerate triangles.\\n\\n  Therefore, for a triangle with non-zero area, the following expression must hold true:\\n    0 < a <= b <= c\\n    a + b > c\\n  To be clear, the sum of the two shortest sides of the triangle must be greater than the longest side.\\n\\n  Thus, we simply need to sort the list, so that we choose the largest possible a, b, and c that will form a civilized triangle.\\n\\n  Complexity Analysis\\n  Time Complexity: O(n log n), where n is the length of nums.\\n  Space Complexity: O(1).\\n\\n  Runtime: 194 ms, faster than 91.18% of Python3 online submissions for Largest Perimeter Triangle.\\n  Memory Usage: 15.6 MB, less than 9.30% of Python3 online submissions for Largest Perimeter Triangle.\\n  \\'\\'\\'\\n  nums = sorted(nums, reverse=True)\\n  for i in range(len(nums) - 2):\\n    a = nums[i+2]\\n    b = nums[i+1]\\n    c = nums[i]\\n    if a + b > c:\\n      return a + b + c\\n  return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1891715,
                "title": "sort-function-javascript",
                "content": "*Hope you find help \\uD83E\\uDD17*\\n\\n> *Code:*\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    \\n    let perimeter = 0;\\n    nums.sort((x, y)=>y-x);\\n    \\n    for(let i = 0; i<nums.length-2; i++)\\n        {\\n            if(nums[i]<(nums[i+1] + nums[i+2]))\\n                {\\n                    perimeter = nums[i] + nums[i+1] + nums[i+2];\\n                    break;\\n                }\\n        }\\n    \\n    return perimeter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    \\n    let perimeter = 0;\\n    nums.sort((x, y)=>y-x);\\n    \\n    for(let i = 0; i<nums.length-2; i++)\\n        {\\n            if(nums[i]<(nums[i+1] + nums[i+2]))\\n                {\\n                    perimeter = nums[i] + nums[i+1] + nums[i+2];\\n                    break;\\n                }\\n        }\\n    \\n    return perimeter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1874130,
                "title": "python3-circumvent-triangle-side-rule",
                "content": "There are 2 restraints for triangle sides are as follows:\\n> The length of one side of a triangle must be greater than the differnce and less than the sum of the lengths of the other two sides. are 15 and 5. The length of the third side must be greater than 15-5 or 10 and less than 15+5 or 20.\\n\\nNote that as the list is sorted, we only need to check one rule. Depending on the sort, the 3rd side will always be greater than or less than the difference/summation.\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        \\n        for i in range(len(nums) - 2):\\n            s1, s2, s3 = nums[i], nums[i+1], nums[i + 2]\\n            if (s3 > s1 - s2):\\n                return sum((s1, s2, s3))\\n        return 0\\n",
                "solutionTags": [],
                "code": "There are 2 restraints for triangle sides are as follows:\\n> The length of one side of a triangle must be greater than the differnce and less than the sum of the lengths of the other two sides. are 15 and 5. The length of the third side must be greater than 15-5 or 10 and less than 15+5 or 20.\\n\\nNote that as the list is sorted, we only need to check one rule. Depending on the sort, the 3rd side will always be greater than or less than the difference/summation.\\n\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        \\n        for i in range(len(nums) - 2):\\n            s1, s2, s3 = nums[i], nums[i+1], nums[i + 2]\\n            if (s3 > s1 - s2):\\n                return sum((s1, s2, s3))\\n        return 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 1853345,
                "title": "javascript-solution",
                "content": "```\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let i = nums.length - 1;\\n    while(i >= 0){\\n        if (nums[i] < nums[i-1] + nums[i-2]){\\n            return nums[i] + nums[i-1] + nums[i-2];\\n        } else {\\n              i--;\\n        }\\n    }\\n    return 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    let i = nums.length - 1;\\n    while(i >= 0){\\n        if (nums[i] < nums[i-1] + nums[i-2]){\\n            return nums[i] + nums[i-1] + nums[i-2];\\n        } else {\\n              i--;\\n        }\\n    }\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1819174,
                "title": "easy-solution-c-4-lines-of-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        }       \\n        return 0;       \\n    }\\n};\\n```\\n\\n**Upvote if it helped :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2])\\n                return nums[i]+nums[i-1]+nums[i-2];\\n        }       \\n        return 0;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816267,
                "title": "c-efficient-using-sorting-easy-simple-clean-solution",
                "content": "##### Please upvote if u find it\\'s Helpful :)\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1; i>1; i--){\\n            if(nums[i]>=nums[i-1]+nums[i-2]) continue;\\n            else return nums[i]+nums[i-1]+nums[i-2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1; i>1; i--){\\n            if(nums[i]>=nums[i-1]+nums[i-2]) continue;\\n            else return nums[i]+nums[i-1]+nums[i-2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816020,
                "title": "python-98-21-faster",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums, reverse=True)\\n        for i in range(0, len(nums) - 2):\\n            a, b, c = nums[i:i+3]\\n            if (a < b + c) and (b < a + c) and (c < a + b):\\n                return a + b + c\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums, reverse=True)\\n        for i in range(0, len(nums) - 2):\\n            a, b, c = nums[i:i+3]\\n            if (a < b + c) and (b < a + c) and (c < a + b):\\n                return a + b + c\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814774,
                "title": "java-easy-solution-largest-perimeter",
                "content": "**Code**\\n```java\\npublic int largestPerimeter(int[] nums) {\\n\\tArrays.sort(nums);\\n\\n\\tint maxperi = 0;\\n\\tfor(int i = nums.length-1; (i >= 0 && (i-2)>=0); i--) {\\n\\t\\tint a = nums[i-2], \\n\\t\\t\\tb = nums[i-1],\\n\\t\\t\\tc = nums[i];\\n\\n\\t\\tif(a + b > c) {\\n\\t\\t\\tmaxperi = Math.max(maxperi, a + b + c);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxperi;\\n}\\n```\\n\\nHope it helps\\nThanks\\nDo upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int largestPerimeter(int[] nums) {\\n\\tArrays.sort(nums);\\n\\n\\tint maxperi = 0;\\n\\tfor(int i = nums.length-1; (i >= 0 && (i-2)>=0); i--) {\\n\\t\\tint a = nums[i-2], \\n\\t\\t\\tb = nums[i-1],\\n\\t\\t\\tc = nums[i];\\n\\n\\t\\tif(a + b > c) {\\n\\t\\t\\tmaxperi = Math.max(maxperi, a + b + c);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxperi;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1691729,
                "title": "java-intuitive-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. In order for 3 edges to form a triangle, the sum of any 2 edges need to > 3rd edge.\\n        2. To get the max perimeter, look for the largest possible edges. \\n        3. Sort the array and iterate from n to 2. If edge[n-2] + edge[n-1] > edge[n], return the sum of edges.\\n    */\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int j = nums.length -1; j >= 2; j--) {\\n            if (nums[j-1] + nums[j-2] > nums[j]) {\\n                return nums[j-1] + nums[j-2] + nums[j];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. In order for 3 edges to form a triangle, the sum of any 2 edges need to > 3rd edge.\\n        2. To get the max perimeter, look for the largest possible edges. \\n        3. Sort the array and iterate from n to 2. If edge[n-2] + edge[n-1] > edge[n], return the sum of edges.\\n    */\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int j = nums.length -1; j >= 2; j--) {\\n            if (nums[j-1] + nums[j-2] > nums[j]) {\\n                return nums[j-1] + nums[j-2] + nums[j];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438060,
                "title": "o-n-log-n-time-o-n-space-without-input-modifiaction",
                "content": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] nums) {        \\n        var numsSorted = nums\\n            .OrderByDescending(n => n)\\n            .ToList();\\n        \\n        for(int i = 0; i < numsSorted.Count - 2; ++i) {\\n            if(numsSorted[i] < numsSorted[i+1] + numsSorted[i+2]) {\\n                return numsSorted[i] + numsSorted[i+1] + numsSorted[i+2];\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] nums) {        \\n        var numsSorted = nums\\n            .OrderByDescending(n => n)\\n            .ToList();\\n        \\n        for(int i = 0; i < numsSorted.Count - 2; ++i) {\\n            if(numsSorted[i] < numsSorted[i+1] + numsSorted[i+2]) {\\n                return numsSorted[i] + numsSorted[i+1] + numsSorted[i+2];\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381910,
                "title": "simple-greedy-solution-java",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        if(nums.length <3) return 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int a = n-3, b = n-2, c = n-1;\\n        while(a>=0){\\n            if(nums[a]+nums[b]>nums[c]) return nums[a]+nums[b]+nums[c];\\n            else{\\n                a--;\\n                b--;\\n                c--;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int largestPerimeter(int[] nums) {\\n        if(nums.length <3) return 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int a = n-3, b = n-2, c = n-1;\\n        while(a>=0){\\n            if(nums[a]+nums[b]>nums[c]) return nums[a]+nums[b]+nums[c];\\n            else{\\n                a--;\\n                b--;\\n                c--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1320183,
                "title": "java-sorting-greedy-6ms-beats-100-t-c-o-nlogn-s-c-o-1",
                "content": "\\n    // Sorting\\n\\t// O(NlogN) O(1)\\n\\tpublic int largestPerimeter(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tArrays.sort(nums);\\n\\n\\t\\tfor (int i = len - 1; i >= 2; i--) {\\n\\t\\t\\tif (isValid(nums[i], nums[i - 1], nums[i - 2]))\\n\\t\\t\\t\\treturn nums[i] + nums[i - 1] + nums[i - 2];\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t// O(1) O(1)\\n\\tpublic boolean isValid(int a, int b, int c) {\\n        if(a + b <= c || b + c <= a || a + c <= b)\\n            return false;\\n        return true;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // Sorting\\n\\t// O(NlogN) O(1)\\n\\tpublic int largestPerimeter(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tArrays.sort(nums);\\n\\n\\t\\tfor (int i = len - 1; i >= 2; i--) {\\n\\t\\t\\tif (isValid(nums[i], nums[i - 1], nums[i - 2]))\\n\\t\\t\\t\\treturn nums[i] + nums[i - 1] + nums[i - 2];\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t// O(1) O(1)\\n\\tpublic boolean isValid(int a, int b, int c) {\\n        if(a + b <= c || b + c <= a || a + c <= b)\\n            return false;\\n        return true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1296831,
                "title": "easy-python-solution-93-46",
                "content": "Runtime: 180 ms, faster than 93.46% of Python3 online submissions for Largest Perimeter Triangle.\\nMemory Usage: 15.5 MB, less than 59.90% of Python3 online submissions for Largest Perimeter Triangle.\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)-1,1,-1):\\n            if(nums[i-2]+nums[i-1]>nums[i]):\\n                return nums[i]+nums[i-1]+nums[i-2]\\n        return 0",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 180 ms, faster than 93.46% of Python3 online submissions for Largest Perimeter Triangle.\\nMemory Usage: 15.5 MB, less than 59.90% of Python3 online submissions for Largest Perimeter Triangle.\\n```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)-1,1,-1):\\n            if(nums[i-2]+nums[i-1]>nums[i]):\\n                return nums[i]+nums[i-1]+nums[i-2]\\n        return 0",
                "codeTag": "Java"
            },
            {
                "id": 1259782,
                "title": "rust-4ms-faster-than-100-2-3mb-less-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/7a7614f0-d1dd-475d-9665-4947c43bfc81_1623180583.1149526.png)\\n\\n```\\n\\timpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        nums.reverse();\\n        for i in 1..nums.len() - 1{\\n            if nums[i-1] + nums[i] > nums[i+1] && nums[i-1] + nums[i+1] > nums[i] && nums[i] + nums[i+1] > nums[i-1] {\\n                return nums[i-1] + nums[i] + nums[i+1];\\n            }\\n        }\\n        0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\timpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        nums.reverse();\\n        for i in 1..nums.len() - 1{\\n            if nums[i-1] + nums[i] > nums[i+1] && nums[i-1] + nums[i+1] > nums[i] && nums[i] + nums[i+1] > nums[i-1] {\\n                return nums[i-1] + nums[i] + nums[i+1];\\n            }\\n        }\\n        0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168419,
                "title": "c-28ms-94-sorting-and-math",
                "content": "Runtime: 28 ms, faster than 93.96% of C++ online submissions for Largest Perimeter Triangle.\\nMemory Usage: 21.9 MB, less than 10.33% of C++ online submissions for Largest Perimeter Triangle.\\n**General idea**\\n1. sort all numbers\\n2. check : last three numbers is satisfied for inequality of triangle ? if not will check next three numbers and so etc.\\n```\\nclass Solution {\\npublic:\\n  int largestPerimeter(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\t\\n    for(int a= nums.size()- 1, b= nums.size()- 2, c= nums.size()- 3; b ;a--,b--,c--)\\n      if(nums[a] < nums[b] + nums[c]) return nums[a] + nums[b] + nums[c];\\n    \\n    return 0;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int largestPerimeter(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n\\t\\n    for(int a= nums.size()- 1, b= nums.size()- 2, c= nums.size()- 3; b ;a--,b--,c--)\\n      if(nums[a] < nums[b] + nums[c]) return nums[a] + nums[b] + nums[c];\\n    \\n    return 0;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123705,
                "title": "python3-priority-queue",
                "content": "It might be over-engineering but be another way of solving it.\\n\\n\"\"\"\\n\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n\\n        neg = [-x for x in nums]\\n        heapq.heapify(neg)\\n        a = -heapq.heappop(neg)\\n        b = -heapq.heappop(neg)\\n\\n        while len(neg) > 0:\\n            c = -heapq.heappop(neg)\\n            if a < b + c:\\n                return a + b + c\\n            else:\\n                a, b  = b, c\\n\\t\\t\\t\\t\\n        return 0\\n\\n\"\"\"",
                "solutionTags": [],
                "code": "It might be over-engineering but be another way of solving it.\\n\\n\"\"\"\\n\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n\\n        neg = [-x for x in nums]\\n        heapq.heapify(neg)\\n        a = -heapq.heappop(neg)\\n        b = -heapq.heappop(neg)\\n\\n        while len(neg) > 0:\\n            c = -heapq.heappop(neg)\\n            if a < b + c:\\n                return a + b + c\\n            else:\\n                a, b  = b, c\\n\\t\\t\\t\\t\\n        return 0\\n\\n\"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 1081040,
                "title": "golang-solution-faster-than-95-65",
                "content": "**Code On The Bottom, If this helped you please up vote**\\nThe idea of this solution is to sort the array and then keep on checking the largest three side lengths. \\n\\nIn the problem it asks us to \"return the largest perimeter of a triangle with non-zero area.\" Non-zero area means a triangle with the two smaller side lengths that add up to be greater than the greatest side length. This can be show in a couple images\\n\\n![image](https://assets.leetcode.com/users/images/66ccb9b3-8b78-4dc9-98ae-ab0552ee5a76_1614187356.9360328.png)\\n\\n*The triangle above is a proper triangle with an area greater than zero and we know that because the two smaller lengths, `5` and `5` added together is `10 > 7`.*\\n![image](https://assets.leetcode.com/users/images/0552ecab-f2d5-494e-a395-873af3e082e9_1614187373.3305833.png)\\n\\n*In the image above we can see that this is not a proper triangle because the area is zero. We know that this is not a proper triangle because the two smaller sides lengths are `4` and `3`. Four plus three is `7` and `7` is the length of the greatest triangle. So we don\\'t have a triangle.*\\n\\n![image](https://assets.leetcode.com/users/images/b922600c-e53c-46cd-9311-4eed61679add_1614187386.0672615.png)\\n![image](https://assets.leetcode.com/users/images/fb5dab69-6d7e-4c5c-8b31-ce81980346a1_1614187400.8811622.png)\\n\\n*The two images above are not proper triangles because the length of the two smaller sides are smaller than `7` and won\\'t be able to form a triangle.*\\n\\n```\\nfunc largestPerimeter(A []int) int {\\n    sort.Ints(A)\\n    for i := len(A) - 1; i >= 2; i-- {\\n        if A[i] < A[i - 1] + A[i - 2] {\\n            return A[i] + A[i - 1] + A[i - 2]\\n        }\\n    }\\n    return 0\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestPerimeter(A []int) int {\\n    sort.Ints(A)\\n    for i := len(A) - 1; i >= 2; i-- {\\n        if A[i] < A[i - 1] + A[i - 2] {\\n            return A[i] + A[i - 1] + A[i - 2]\\n        }\\n    }\\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1048016,
                "title": "using-triangle-properties-sum-of-two-sides-is-greater-than-third-side-simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int largestPerimeter(int[] A) {\\n        int end = A.length-1;\\n        Arrays.sort(A);\\n        int sum=0;\\n        for(int i=end;i>=2;i--)\\n        {\\n            if(A[i-2]+A[i-1]>A[i]){\\n                sum = A[i-2]+A[i-1]+A[i];\\n                break;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] A) {\\n        int end = A.length-1;\\n        Arrays.sort(A);\\n        int sum=0;\\n        for(int i=end;i>=2;i--)\\n        {\\n            if(A[i-2]+A[i-1]>A[i]){\\n                sum = A[i-2]+A[i-1]+A[i];\\n                break;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998277,
                "title": "easy-clear-solution-99-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& A) {\\n        ios::sync_with_stdio(0); cout.tie(0); cin.tie(0);\\n        sort(A.begin(),A.end());\\n        int n=A.size();\\n        for(int i=n-1;i>1;i--){\\n            if(A[i]>=A[i-1]+A[i-2])continue;\\n            else return A[i]+A[i-1]+A[i-2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& A) {\\n        ios::sync_with_stdio(0); cout.tie(0); cin.tie(0);\\n        sort(A.begin(),A.end());\\n        int n=A.size();\\n        for(int i=n-1;i>1;i--){\\n            if(A[i]>=A[i-1]+A[i-2])continue;\\n            else return A[i]+A[i-1]+A[i-2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 218686,
                "title": "c-4-lines-beat-100",
                "content": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] A) {\\n        Array.Sort(A);\\n        for(int i = A.Length-1;i>=2;i--)\\n            if(A[i]<A[i-1]+A[i-2]) return A[i]+A[i-1]+A[i-2];\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LargestPerimeter(int[] A) {\\n        Array.Sort(A);\\n        for(int i = A.Length-1;i>=2;i--)\\n            if(A[i]<A[i-1]+A[i-2]) return A[i]+A[i-1]+A[i-2];\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218455,
                "title": "simple-python-solution-without-sorting-beats-100",
                "content": "\\n\\tdef largestPerimeter(self, A):\\n\\t\\ta = max(A)\\n        A.remove(a)\\n        b = max(A)\\n        A.remove(b)\\n        c = max(A)\\n        A.remove(c)        \\n        while b+c <= a and A != []:\\n\\t\\t\\ta,b,c = b,c,max(A)\\n\\t\\t   A.remove(c)        \\n        if b+c>a: \\n            return a+b+c\\n        else:\\n            return 0",
                "solutionTags": [],
                "code": "\\n\\tdef largestPerimeter(self, A):\\n\\t\\ta = max(A)\\n        A.remove(a)\\n        b = max(A)\\n        A.remove(b)\\n        c = max(A)\\n        A.remove(c)        \\n        while b+c <= a and A != []:\\n\\t\\t\\ta,b,c = b,c,max(A)\\n\\t\\t   A.remove(c)        \\n        if b+c>a: \\n            return a+b+c\\n        else:\\n            return 0",
                "codeTag": "Python3"
            },
            {
                "id": 3938483,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(NlogN) + O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        for(int i = 0; i < nums.size()-2; i++){\\n            if(nums[i+2] + nums[i+1] > nums[i])\\n                return nums[i+2] + nums[i+1] + nums[i];\\n        }\\n        return 0;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/b4a78ab0-1c02-486b-88dd-f93befc74ad9_1692570558.5688822.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        for(int i = 0; i < nums.size()-2; i++){\\n            if(nums[i+2] + nums[i+1] > nums[i])\\n                return nums[i+2] + nums[i+1] + nums[i];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653933,
                "title": "easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums));\\n\\n        for (int i=n-1; i>1; i--)\\n            if (nums[i] < nums[i-1]+nums[i-2]) return nums[i]+nums[i-1]+nums[i-2];\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(begin(nums), end(nums));\\n\\n        for (int i=n-1; i>1; i--)\\n            if (nums[i] < nums[i-1]+nums[i-2]) return nums[i]+nums[i-1]+nums[i-2];\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622121,
                "title": "c-simple-sorting-triangle-property",
                "content": "# Code\\n```\\n// Triangle property: a + b > c\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n       sort(nums.rbegin(), nums.rend());\\n       for (int i = 0; i < nums.size()-2; i++) {\\n           if (nums[i] < nums[i+1] + nums[i+2])\\n            return nums[i] + nums[i+1] + nums[i+2];\\n       }\\n       return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// Triangle property: a + b > c\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n       sort(nums.rbegin(), nums.rend());\\n       for (int i = 0; i < nums.size()-2; i++) {\\n           if (nums[i] < nums[i+1] + nums[i+2])\\n            return nums[i] + nums[i+1] + nums[i+2];\\n       }\\n       return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532977,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& n) {\\n        sort(n.begin(), n.end());\\n        for(int i = n.size()-3; i >= 0; i--)\\n        {\\n            if(n[i] + n[i+1] > n[i+2])\\n            {\\n                return n[i] + n[i+1] + n[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums) - 2):\\n            a = nums[i]\\n            b = nums[i+1]\\n            c = nums[i+2]\\n            if a < b + c:\\n                return a + b + c\\n        return 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        setMaxAtIndexI(nums.length - 1, nums);\\n        setMaxAtIndexI(nums.length - 2, nums);\\n        for (int i = nums.length - 1; i > 1; i--) {\\n             setMaxAtIndexI(i - 2, nums);\\n            if (nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n    private void setMaxAtIndexI(int index, int [] nums) {\\n        int maxValue = 0;\\n        int maxValueIndex = index;\\n\\n        for (int i = 0; i <= index; i++) {\\n            if (maxValue < nums[i]) {\\n                maxValue = nums[i];\\n                maxValueIndex = i;\\n            }\\n        }\\n        nums[maxValueIndex] = nums[index];\\n        nums[index] = maxValue;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& n) {\\n        sort(n.begin(), n.end());\\n        for(int i = n.size()-3; i >= 0; i--)\\n        {\\n            if(n[i] + n[i+1] > n[i+2])\\n            {\\n                return n[i] + n[i+1] + n[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        for i in range(len(nums) - 2):\\n            a = nums[i]\\n            b = nums[i+1]\\n            c = nums[i+2]\\n            if a < b + c:\\n                return a + b + c\\n        return 0\\n```\n```Java []\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        setMaxAtIndexI(nums.length - 1, nums);\\n        setMaxAtIndexI(nums.length - 2, nums);\\n        for (int i = nums.length - 1; i > 1; i--) {\\n             setMaxAtIndexI(i - 2, nums);\\n            if (nums[i] < nums[i-1] + nums[i-2]) {\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n    private void setMaxAtIndexI(int index, int [] nums) {\\n        int maxValue = 0;\\n        int maxValueIndex = index;\\n\\n        for (int i = 0; i <= index; i++) {\\n            if (maxValue < nums[i]) {\\n                maxValue = nums[i];\\n                maxValueIndex = i;\\n            }\\n        }\\n        nums[maxValueIndex] = nums[index];\\n        nums[index] = maxValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506631,
                "title": "simple-java-solution-for-beginners-8ms-beats-99-39",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 2; i--) {\\n            if(nums[i - 1] + nums[i - 2] > nums[i]) {\\n                return nums[i - 1] + nums[i - 2] + nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 2; i--) {\\n            if(nums[i - 1] + nums[i - 2] > nums[i]) {\\n                return nums[i - 1] + nums[i - 2] + nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462706,
                "title": "find-the-largest-perimeter-of-a-non-zero-area-triangle",
                "content": "\\n1. Sort the input array in non-descending order using Arrays.sort(nums).\\n2. Iterate over the sorted array from the last element towards the front.\\n3. For each element, check if it can be used as the longest side of a triangle by checking the triangle inequality: \"the sum of any two sides is strictly greater than the third side\". If this condition is satisfied for the current element and its two preceding elements, we have found a non-zero area triangle.\\n4. If a non-zero area triangle is found, return its perimeter which is the sum of the three sides. If no non-zero area triangle is found, return 0.\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i = n-1; i >= 2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i = n-1; i >= 2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n                return nums[i] + nums[i-1] + nums[i-2];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438306,
                "title": "java-largest-perimeter-triangle",
                "content": "\\n```\\nclass Solution {\\n   public int minToMax(int[] nums)\\n    {\\n        int min = nums.length - 3;\\n        int sqere = 0;\\n        while (min > -1)\\n        {\\n            if (nums[min + 2] < nums[min] + nums[min + 1])\\n                sqere = Math.max(nums[min + 2] + nums[min] + nums[min + 1], sqere);\\n            \\n                min--;\\n        }\\n        return sqere;\\n    }\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        return minToMax(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int minToMax(int[] nums)\\n    {\\n        int min = nums.length - 3;\\n        int sqere = 0;\\n        while (min > -1)\\n        {\\n            if (nums[min + 2] < nums[min] + nums[min + 1])\\n                sqere = Math.max(nums[min + 2] + nums[min] + nums[min + 1], sqere);\\n            \\n                min--;\\n        }\\n        return sqere;\\n    }\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        return minToMax(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258929,
                "title": "sort-for-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n\\n    for (let i = 0; i < nums.length - 2; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\\n            return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n    }\\n\\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar largestPerimeter = function(nums) {\\n    nums.sort((a, b) => b - a);\\n\\n    for (let i = 0; i < nums.length - 2; i++) {\\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\\n            return nums[i] + nums[i + 1] + nums[i + 2];\\n        }\\n    }\\n\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3192203,
                "title": "java-simple-fastest-solution-beats-99-64-with-explanation-using-test-cases",
                "content": "\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        //[2,1,2]\\n        //sort => [1,2,2]<-\\n        //a+b > c\\n        //(1+2)=3 > 2 true\\n        //res = 5\\n\\n        //[1,2,1]\\n        //sort=> [1,1,2]<-\\n        //(1+1)=2 > 2 false \\n        //return 0\\n\\n        //[1,1,10]\\n        //sort => [1,1,10] <-\\n        //(1+1)=2> 10 false\\n        // return 0\\n        \\n        //[1,2,10]\\n        //sort => [1,2,10]\\n        //(1+2)=3> 10 false\\n        // return 0\\n        \\n        //[1,2,1,2,1,2]\\n        //sort => [1,1,1,2,2,2] <-\\n        //(2+2)=4> 2 true\\n        // return 6\\n        \\n      \\n        Arrays.sort(nums);\\n\\n          // we need to loop through an array backward , this wasy we can get max values.\\n\\n        for(int i =nums.length-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        //[2,1,2]\\n        //sort => [1,2,2]<-\\n        //a+b > c\\n        //(1+2)=3 > 2 true\\n        //res = 5\\n\\n        //[1,2,1]\\n        //sort=> [1,1,2]<-\\n        //(1+1)=2 > 2 false \\n        //return 0\\n\\n        //[1,1,10]\\n        //sort => [1,1,10] <-\\n        //(1+1)=2> 10 false\\n        // return 0\\n        \\n        //[1,2,10]\\n        //sort => [1,2,10]\\n        //(1+2)=3> 10 false\\n        // return 0\\n        \\n        //[1,2,1,2,1,2]\\n        //sort => [1,1,1,2,2,2] <-\\n        //(2+2)=4> 2 true\\n        // return 6\\n        \\n      \\n        Arrays.sort(nums);\\n\\n          // we need to loop through an array backward , this wasy we can get max values.\\n\\n        for(int i =nums.length-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138912,
                "title": "c-greedy-approach-sort-easiest-soln",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort in asc order and then you know the max perimeter will be found only from the last. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int max_peri= 0;\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                max_peri=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return max_peri;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int max_peri= 0;\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(nums[i-1]+nums[i-2]>nums[i]){\\n                max_peri=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return max_peri;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073407,
                "title": "larggest-perimeter-triangle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-3;i>=0;i--){\\n            if(nums[i]+nums[i+1]>nums[i+2]){\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068822,
                "title": "easiest-solution-ever-c",
                "content": "# Intuition\\njust think about in any \\u26DB triangle sum of two sides always greater than than third sides\\n\\n# Approach\\nat first sort the nums vector and i used here from last iterator you can also sort vector in descending order.\\njust use in any \\u26DB triangle sum of two sides always greater than than third sides and write code.  \\uD83D\\uDE0A\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(nums[i]<(nums[i-1]+nums[i-2])){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(nums[i]<(nums[i-1]+nums[i-2])){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022082,
                "title": "4-line-code-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        std::sort( nums.rbegin(), nums.rend() );\\n        for( int i = 0 ; i < nums.size()-2 ; i++ ){ \\n            if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }  \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        std::sort( nums.rbegin(), nums.rend() );\\n        for( int i = 0 ; i < nums.size()-2 ; i++ ){ \\n            if( nums[i] < ( nums[i+1] + nums[i+2]) ){\\n                return nums[i] + nums[i+1] + nums[i+2];\\n            }  \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957115,
                "title": "kotlin-4-line-solution-windowed",
                "content": "# Code\\n```\\nclass Solution {\\n    fun largestPerimeter(nums: IntArray): Int {\\n        nums.sortedDescending().windowed(3, 1).forEach { (a, b, c) ->\\n            if (a < b + c && b < a + c && c < a + b) return a + b + c\\n        }\\n\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun largestPerimeter(nums: IntArray): Int {\\n        nums.sortedDescending().windowed(3, 1).forEach { (a, b, c) ->\\n            if (a < b + c && b < a + c && c < a + b) return a + b + c\\n        }\\n\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808758,
                "title": "leetcode-the-hard-way-rust-solutions",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\nSort and find the first three lengths where satifies `a + b > c` from the largest.\\n\\n```rs\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        for i in (2 .. nums.len()).rev() {\\n            if (nums[i - 2] + nums[i - 1] > nums[i]) {\\n                return nums[i - 2] + nums[i - 1] + nums[i];\\n            }\\n        }\\n        0\\n    }\\n}\\n```\\n\\nWe can use `windows` as well.\\n\\n```rs\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        for w in nums.windows(3).rev() {\\n            if (w[0] + w[1] > w[2]) {\\n                return w[0] + w[1] + w[2];\\n            }\\n        }\\n        0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```rs\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        for i in (2 .. nums.len()).rev() {\\n            if (nums[i - 2] + nums[i - 1] > nums[i]) {\\n                return nums[i - 2] + nums[i - 1] + nums[i];\\n            }\\n        }\\n        0\\n    }\\n}\\n```\n```rs\\nimpl Solution {\\n    pub fn largest_perimeter(mut nums: Vec<i32>) -> i32 {\\n        nums.sort_unstable();\\n        for w in nums.windows(3).rev() {\\n            if (w[0] + w[1] > w[2]) {\\n                return w[0] + w[1] + w[2];\\n            }\\n        }\\n        0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2725205,
                "title": "95ms-beats-98-40-javascript-submissions-memory-usage-44-mb-beats-96-33-users",
                "content": "var largestPerimeter = function(nums) {\\n    nums.sort(function(a,b) {return a-b})\\n    for (let i=nums.length-1;i>=0;i--){\\n        if(nums[i]>=nums[i-1]+nums[i-2]){\\n        continue;\\n        }else if(nums[i]<nums[i-1]+nums[i-2]){\\n                 return nums[i]+nums[i-1]+nums[i-2]\\n        break;         \\n        }\\n        return 0\\n    }\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "var largestPerimeter = function(nums) {\\n    nums.sort(function(a,b) {return a-b})\\n    for (let i=nums.length-1;i>=0;i--){\\n        if(nums[i]>=nums[i-1]+nums[i-2]){\\n        continue;\\n        }else if(nums[i]<nums[i-1]+nums[i-2]){\\n                 return nums[i]+nums[i-1]+nums[i-2]\\n        break;         \\n        }\\n        return 0\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2702667,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=2){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=n-1;i>=2;i--){\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n\\n            if(a+b>c){\\n                return a+b+c;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n// class Solution {\\n// public:\\n//     int largestPerimeter(vector<int>& nums) {\\n//         sort(nums.begin(),nums.end());\\n//         for(int i=nums.size()-1;i>=2;i--){\\n//             int a=nums[i-2];\\n//             int b=nums[i-1];\\n//             int c=nums[i];\\n            \\n//             if(a+b>c){\\n//                 return a+b+c;\\n//             }\\n//         }\\n//         return 0;\\n        \\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=2){\\n            return 0;\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=n-1;i>=2;i--){\\n            int a=nums[i-2];\\n            int b=nums[i-1];\\n            int c=nums[i];\\n\\n            if(a+b>c){\\n                return a+b+c;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n// class Solution {\\n// public:\\n//     int largestPerimeter(vector<int>& nums) {\\n//         sort(nums.begin(),nums.end());\\n//         for(int i=nums.size()-1;i>=2;i--){\\n//             int a=nums[i-2];\\n//             int b=nums[i-1];\\n//             int c=nums[i];\\n            \\n//             if(a+b>c){\\n//                 return a+b+c;\\n//             }\\n//         }\\n//         return 0;\\n        \\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699195,
                "title": "easy-solution-in-four-line-in-python",
                "content": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)        \\n        for i in range(len(nums)-1,1,-1):\\n            if nums[i]+nums[i-1] > nums[i-2] and nums[i-1]+nums[i-2] > nums[i] and nums[i]+nums[i-2] > nums[i-1]:\\n                return (nums[i]+nums[i-1]+nums[i-2])\\n        return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPerimeter(self, nums: List[int]) -> int:\\n        nums = sorted(nums)        \\n        for i in range(len(nums)-1,1,-1):\\n            if nums[i]+nums[i-1] > nums[i-2] and nums[i-1]+nums[i-2] > nums[i] and nums[i]+nums[i-2] > nums[i-1]:\\n                return (nums[i]+nums[i-1]+nums[i-2])\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695906,
                "title": "java-same-as-all-the-others-but-consider-upvoting",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 3; i >= 0; i--) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) {\\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n) + O(n * logn) => O(n * logn)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = nums.length - 3; i >= 0; i--) {\\n            if (nums[i] + nums[i + 1] > nums[i + 2]) {\\n                return nums[i] + nums[i + 1] + nums[i + 2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n) + O(n * logn) => O(n * logn)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695691,
                "title": "c-short-solution",
                "content": "Solution should be fairly self explanatory, just sort the array and then check each triplet for the triangle inequality (`a+b > c`).\\n\\n```\\nint* comp(const void* a, const void* b){\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nint largestPerimeter(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int cur=0;\\n    for (int i=2; i<numsSize; i++)\\n        if (nums[i] < nums[i-1] + nums[i-2])\\n            cur = nums[i] + nums[i-1] + nums[i-2];\\n    \\n    return cur;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint* comp(const void* a, const void* b){\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nint largestPerimeter(int* nums, int numsSize){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int cur=0;\\n    for (int i=2; i<numsSize; i++)\\n        if (nums[i] < nums[i-1] + nums[i-2])\\n            cur = nums[i] + nums[i-1] + nums[i-2];\\n    \\n    return cur;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2695516,
                "title": "largest-perimeter-triangle-c-o-logn-concise-and-description",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The solution is based on one of the basic properties of a triangle.\\nThe sum of the length of any two sides of a triangle is greater than the length of the third side.\\n2.Sort the array and when a+b>c, return the perimeter (a+b+c). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- sort the array\\ntraverse from n-3 to 0\\nif at any instant a + b > c, return perimenter (a+b+c)\\n a=nums[i], b=nums[i+1], c=nums[i+2];\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(logn)\\n\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#ifdef tabr\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n#define pb        push_back\\n#define ll        long long\\n#define ff        first\\n#define ss        second\\n#define ppi       pair<int, pair<int, int>>\\n#define fo(i,n)   for(int i=0;i<n;i++)\\n#define N 10000\\n\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = n - 3; i >= 0; i--)\\n        {\\n            if (nums[i] + nums[i + 1] > nums[i + 2])\\n            {\\n                return  nums[i] + nums[i + 1] + nums[i + 2];\\n            }\\n        }\\n        return 0;\\n\\n    }\\n};\\n\\n#ifdef tabr\\nint main()\\n{\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    //\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#ifdef tabr\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n#define pb        push_back\\n#define ll        long long\\n#define ff        first\\n#define ss        second\\n#define ppi       pair<int, pair<int, int>>\\n#define fo(i,n)   for(int i=0;i<n;i++)\\n#define N 10000\\n\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for (int i = n - 3; i >= 0; i--)\\n        {\\n            if (nums[i] + nums[i + 1] > nums[i + 2])\\n            {\\n                return  nums[i] + nums[i + 1] + nums[i + 2];\\n            }\\n        }\\n        return 0;\\n\\n    }\\n};\\n\\n#ifdef tabr\\nint main()\\n{\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    //\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2695475,
                "title": "east-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-3;i>=0;i--)\\n        {\\n            if(nums[i]+nums[i+1]>nums[i+2])\\n            {\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-3;i>=0;i--)\\n        {\\n            if(nums[i]+nums[i+1]>nums[i+2])\\n            {\\n                return nums[i]+nums[i+1]+nums[i+2];\\n            }\\n        }\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695298,
                "title": "c-simple-code-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool valid(int a,int b,int c){return (a+b>c && a+c>b && b+c>a);}\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(valid(nums[i],nums[i+1],nums[i+2])) return nums[i]+nums[i+1]+nums[i+2];\\n        }\\n        return 0;\\n    }\\n};\\n```\\n*Implementation of valid fns to check whether the triangle is valid or not\\nbasic triangle perimeter sum of two sides should be greater than the third side.*\\n\\n*Sort array in decreasing order to calculate maximum possible perimeter\\nwe iterate to nums.size()-2 cause we need 3 no\\'s*\\n\\n*Checking the three nos from ith posn i.e nums at* i, i+1, i+2 *if they fulfill triangles perimeter property they are good to go\\nso we return the sum of the 3no\\'s.*\\n\\nTime Complexity ~ O(NlogN)\\nSpace Complexity ~ O(1)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int a,int b,int c){return (a+b>c && a+c>b && b+c>a);}\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<nums.size()-2;i++){\\n            if(valid(nums[i],nums[i+1],nums[i+2])) return nums[i]+nums[i+1]+nums[i+2];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695154,
                "title": "python-easy-solution-bruteforce",
                "content": "\\nBruteforce -->\\n1. First sort the list and reverse it so that you can have the largest number at the start of the lisit.\\n2. Then traverse the list till len(nums)-2 because you are going to take 3 numberse into consideration.\\n3. Then we have to check the simple condition and rule of tranges ie. --> The sum of the two sides of the triangle is always smaller than the third side.\\n4. If all the condition meet then we have to return the sum of the three sides of the triange.\\n5. The three sides of the triangle are the 1st, 2nd and the 3rd element and they will always be the largest because we have sorted it in thre reverse order.\\n\\n![image](https://assets.leetcode.com/users/images/c584c62d-e263-4e30-849f-cc670169e10f_1665592727.4565024.png)\\n\\n\\n        nums.sort(reverse = True)\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] + nums[i+2]:\\n                return nums[i] + nums[i+1] + nums[i+2]\\n        return 0\\n\\nAnother way of writing the same code -->\\n![image](https://assets.leetcode.com/users/images/8e14b15c-a266-4581-b091-1c63863074e0_1665592747.352271.png)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\nBruteforce -->\\n1. First sort the list and reverse it so that you can have the largest number at the start of the lisit.\\n2. Then traverse the list till len(nums)-2 because you are going to take 3 numberse into consideration.\\n3. Then we have to check the simple condition and rule of tranges ie. --> The sum of the two sides of the triangle is always smaller than the third side.\\n4. If all the condition meet then we have to return the sum of the three sides of the triange.\\n5. The three sides of the triangle are the 1st, 2nd and the 3rd element and they will always be the largest because we have sorted it in thre reverse order.\\n\\n![image](https://assets.leetcode.com/users/images/c584c62d-e263-4e30-849f-cc670169e10f_1665592727.4565024.png)\\n\\n\\n        nums.sort(reverse = True)\\n        for i in range(len(nums)-2):\\n            if nums[i] < nums[i+1] + nums[i+2]:\\n                return nums[i] + nums[i+1] + nums[i+2]\\n        return 0\\n\\nAnother way of writing the same code -->\\n![image](https://assets.leetcode.com/users/images/8e14b15c-a266-4581-b091-1c63863074e0_1665592747.352271.png)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2694948,
                "title": "c",
                "content": "\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int LargestPerimeter(int[] nums) \\n    {        \\n        if (nums.Length < 3)\\n        {\\n            return 0;\\n        }\\n\\n        Array.Sort(nums);\\n\\n        for(int i=nums.Length-1; i>=2; i--)\\n        {   \\n            if (nums[i-1] + nums[i-2] > nums[i])\\n            {\\n                return nums[i-1] + nums[i-2] + nums[i] ;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int LargestPerimeter(int[] nums) \\n    {        \\n        if (nums.Length < 3)\\n        {\\n            return 0;\\n        }\\n\\n        Array.Sort(nums);\\n\\n        for(int i=nums.Length-1; i>=2; i--)\\n        {   \\n            if (nums[i-1] + nums[i-2] > nums[i])\\n            {\\n                return nums[i-1] + nums[i-2] + nums[i] ;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694746,
                "title": "easy-c-solution",
                "content": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2694739,
                "title": "easy-c-solution",
                "content": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2694716,
                "title": "easy-c-solution",
                "content": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestPerimeter(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin() , nums.end());\\n        int i = n-1;\\n       \\n        while((nums[i-1]+nums[i-2] <= nums[i]) && i-2 > 0){\\n           i--;\\n        }\\n        \\n        if(nums[i-1]+nums[i-2] > nums[i]) return nums[i]+nums[i-1]+nums[i-2];\\n        else return 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2694150,
                "title": "accepted-java-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMax perimeter is the sum of the max 3 values\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        //max perimeter is the sum of the max 3 values\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--){\\n            \\n            //if the sum of the first two sides are greater than the third side then it forms a triangle\\n            if(nums[i] < nums[i-1]+nums[i-2])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        //max perimeter is the sum of the max 3 values\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=2;i--){\\n            \\n            //if the sum of the first two sides are greater than the third side then it forms a triangle\\n            if(nums[i] < nums[i-1]+nums[i-2])\\n                return nums[i] + nums[i-1] + nums[i-2];\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694124,
                "title": "easy-solution-beginner-c-java-o-nlogn-simple-traversal",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\\n2)Sort the array to get the maximum element of the array at a side ;\\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\\n4)Store the value of it in ans (default value is 0) and return it .\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\nC++ solution\\n```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i = nums.size()-1; i>=2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n               ans=nums[i] + nums[i-1]+ nums[i-2];  \\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nJAVA solution\\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i = nums.length-1; i>=2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n               ans=nums[i] + nums[i-1]+ nums[i-2];  \\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i = nums.size()-1; i>=2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n               ans=nums[i] + nums[i-1]+ nums[i-2];  \\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i = nums.length-1; i>=2; i--){\\n            if(nums[i] < nums[i-1] + nums[i-2]){\\n               ans=nums[i] + nums[i-1]+ nums[i-2];  \\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694095,
                "title": "java-100-faster-solution",
                "content": "class Solution {\\n    public int largestPerimeter(int[] n) {\\n        \\n        \\n     Arrays.sort(n);\\n        \\n        \\n        for(int i=n.length-1;i>1;--i){\\n            \\n            if(n[i]<n[i-1]+n[i-2])\\n                return n[i]+n[i-1]+n[i-2];\\n             }\\n        return 0;\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestPerimeter(int[] n) {\\n        \\n        \\n     Arrays.sort(n);\\n        \\n        \\n        for(int i=n.length-1;i>1;--i){\\n            \\n            if(n[i]<n[i-1]+n[i-2])\\n                return n[i]+n[i-1]+n[i-2];\\n             }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1642182,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1798479,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641689,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1572410,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1642254,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641635,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1643491,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1923724,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1643541,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641603,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1642182,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1798479,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641689,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1572410,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1642254,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641635,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1643491,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1923724,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1643541,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 1641603,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1)If the side of a triangle are a,b,c then a+b>c for the triangle to be formed .\n2)Sort the array to get the maximum element of the array at a side ;\n3)Traverse the array bacckward to find nums[i]<nums[i-1]+nums[i-2] till the index 2 as i-2 will get out of bound ,\n4)Store the value of it in ans (default value is 0) and return it .  "
                    },
                    {
                        "username": "PandeyKartik",
                        "content": "Why sort the whole array?"
                    },
                    {
                        "username": "barwal77",
                        "content": "Why does this work even when some side combinations are definitely missed. Like in example 2 :\\ncase 1,1,10 will never be checked according to the indexing of our loop, so is there a chance that we miss the answer or am I missing something?"
                    },
                    {
                        "username": "rathore_9326",
                        "content": "after storing the value (after passing the condition). we should use break. so, we can only store largest perimeter.\\n\\nclass Solution {\\n    public int largestPerimeter(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int temp=0;\\n        for(int i=nums.length-1;i>=2;i--)\\n        {\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                temp=nums[i]+nums[i-1]+nums[i-2];\\n                break;\\n            }\\n        }\\n        return temp;\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "auspiciouss",
                        "content": "[@IamJayPrakash](/IamJayPrakash) int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=nums.size()-1;i>1;i--){\\n            if(nums[i]<nums[i-1]+nums[i-2]){\\n                ans=max(ans,nums[i]+nums[i-1]+nums[i-2]);\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "IamJayPrakash",
                        "content": "int largestPerimeter(int* nums, int numsSize){\\n\\nint temp=0,s=0;\\n//sorting ascending\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=i+1;j<numsSize;j++)\\n    {\\n         if(nums[i]>nums[j])\\n         {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n         }\\n    }\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    for(int j=2;j>=i;j--){\\n    if(nums[j]<(nums[j-1]+nums[j-2]))\\n    {\\n        s=s+nums[i];\\n    }\\n    }\\n}\\nreturn s;\\n}\\n\\n\\n\\ni did the same as your suggestion or i had made any mistake ??\\nwhy it shows runtime error?\\nhelp!!!!!"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Thanks for help!"
                    },
                    {
                        "username": "marcthestrong",
                        "content": "This should be a med difficulty problem"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "[@mochiball](/mochiball) largest implies sorting or at least some ways to find the top 3 max."
                    },
                    {
                        "username": "mochiball",
                        "content": "Can be easy to med. I felt the hard part was trying to optimize the solution without sorting but i don\\'t know if that is possible"
                    },
                    {
                        "username": "kundan202124",
                        "content": "there are two necessary conditions on sides of a triangle :\na). sum of any two sides greater than third side\nb). difference of any two sides less than third side\n\nThen why everybody is solving by taking just 1st condition??\nplease correct if i am wrong."
                    },
                    {
                        "username": "dushun328",
                        "content": "If the list is sorted, consider either one. If not, both conditions have to be satisfied. "
                    },
                    {
                        "username": "riderop",
                        "content": "Both condition is same \\n1st condition can be written as a + b > c where as we can also rearrange as \\na > b - c. Which mean both the condition is same. "
                    },
                    {
                        "username": "manohar369",
                        "content": "either 1 or 2\\nnot  1 and 2 i think"
                    },
                    {
                        "username": "kundan202124",
                        "content": "tnx now i got it"
                    },
                    {
                        "username": "ankitakumari9430",
                        "content": "If a + b > c(1st condition, then automatically a > c - b(shifting b to RHS) or c - b < a(2nd condition). If the 1st condition is met, then automatically the 2nd condition also gets satisfied."
                    },
                    {
                        "username": "SevenLeung",
                        "content": "Can it be solved in O(n) time, i.e. without sorting the array?"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I thought, maybe Hashmap, but without sorting all you are doing is basically comparing each cases and then testing whether it satisfies the criteria or not and then again testing if it is the largest. \\nBut with sorting it gets a lot easier as you don\\'t have to check whether it is the largest cause it will be and just need to pass the case of the triangle criteria."
                    },
                    {
                        "username": "Sushanta_Das",
                        "content": "Why are we checking only three consecutive element from sorted array for getting maximum perimeter ? Will there not be any possibility of getting  maximum perimeter  \nwith non consecutive elements (let say we have nums.size=5 and max perimeter by elements at indices 1 ,3 ,4   (may be because elm at 4,3,2 is not forming a valid triangle)?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think it\\'s trivial that if we have a sorted array, like that:\\n[60,40,20,18,12,9,8,7], the first triangle we found, has the largest perimeter.\\nBut how to be sure that a previous  item (60 in this example) can be used to have a triangle? \\nIn that example: 60 = 40 + 20 we don\\'t have triangle. Can 60 be used for an other triangle?\\nNO: because the sum of two elements will decrease:\\n40 + 20 = 60\\n18 + 20 = 38\\n12 + 18 = 30...\\n\\nI hope that make sense."
                    },
                    {
                        "username": "SIN99",
                        "content": "***Note: They are wanting \"MAX perimeter\" not with \"any perimeter\" which can satisfy the condition for a Triangle!\\n\\nEG:\\nLets\\'s say we have sorted the array (say nums[]) in descending order then, \\nnums=[50, 40, 30, 20, 10]\\n\\nNow,  MAX perimeter will be\\nnums[0] < nums[1]+nums[2]\\n\\nGeneralizing above eqn (say i=1), we get\\nnums[i-1] < nums[i] + nums[i+1],\\n\\nAs soon as this condition gets satisfy it will be the MAX perimeter possible (ans)! \\nNow moving further may form a Triangle theoretically but it will not be the Triangle with \"MAX perimeter\" which is asked!!!\\n\\nHINT: We need to move this (nums[i-1] < nums[i] + nums[i+1])  set of three elements on every iteration over a descending sorted array!  \\n (If you sort in ascending then just traverse from backwards cz max elements will be present on the end side)\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I had this question myself.\\n\\nWhy would you want a subsequence instead? If you have the three largest lengths, why would you ever want to remove the second largest length for an even smaller one? This won\\'t get you the max perimeter. Instead, let\\'s remove the largest, so the triplet is still larger than some subsequence.\\n\\nIf we remove the smallest or second smallest, we are only getting an even smaller perimeter. So lets remove the largest length. \\n\\nI hope this helps"
                    },
                    {
                        "username": "neildeng0705",
                        "content": "after sort, there is only one possibility to find the max perimeter"
                    },
                    {
                        "username": "Phunsukh_Wangdu",
                        "content": "I guess you are asking for why only consecutive subset of 3 is we are taking in consider everytime , and why not sub sequence can form the answer...\n\nreason lies in question itself , we have to return the maximum perimeter.\nCondition : a+b > c.\n\ntake a=(nums[n-3], b = nums[n-2], c= nums[n-1], largest perimeter we can get , without any condition,\nif this fails our condition a+b> c,\n\nthen any pair a, b for this given c could not hold this condition, \nhence this c got discarded.\n\nhope this will help you ;)\n"
                    },
                    {
                        "username": "CODEX47",
                        "content": "A nearly O(N) solution would be to find largest number in first loop, then second largest in second loop , and third largest in last loop. But this solution fails for some testcase for example - [3,6,2,3]. Here 6 < 3 + 3 is not true, Ans should be 8 => 3 + 3 + 2.\n\nI would love if somebody could actually improve this solution further to pass all testcase.\nThen there would be a O(N) solution for this problem."
                    },
                    {
                        "username": "matttmaloney",
                        "content": "Why does [1,2,1] return 0? I understand it\\'s area is 0, but the would be an isosceles triangle so it seems its area shouldn\\'t be 0.\\n\\nguess im looking for intuition lol"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "It\\'s called a line."
                    },
                    {
                        "username": "mochiball",
                        "content": "It is because this is not a valid triangle based on the properties of a triangle"
                    },
                    {
                        "username": "ardas",
                        "content": "a triangle with side lengths 1 2 1 is impossible:\n\nhttps://en.wikipedia.org/wiki/Triangle_inequality"
                    },
                    {
                        "username": "Light_7",
                        "content": "it can\\'t form a triangle given the condition that sum of any two sides must be strictly greater than the third side so 1 + 1 = 2 would not form the triangle and if u can picture in your head, then you will be able to see that the two sides with length 1 will fall over the base with length 2 so there will be no angle formed or angle will be 0 so area will be 0 as it will be technically a straight line."
                    },
                    {
                        "username": "HallRules",
                        "content": "this is just a geometry problem disguised as a coding problem tbh"
                    },
                    {
                        "username": "tingyawang",
                        "content": "example data is not large data and array is similar sorted . when this situation can use insertionsort that time complex.. is O(n)..."
                    },
                    {
                        "username": "speedyy",
                        "content": "the built-in sort function has also insertion sort integrated, so I guess that moment the TC of sort() is O(n)? (plz don\\'t negative vote me if I am wrong)"
                    },
                    {
                        "username": "shreyans",
                        "content": "I sorted the list in descending order and in the window of 3 elements kept on checking if the triangle property holds (i.e. sum of two sides greater than remaining one) while tracking the max area so far and returned the final area."
                    },
                    {
                        "username": "fast_nd_steady",
                        "content": "You do not have to keep the track of max perimeter so far, the very first you encounter a valid triangle just retutn it, you have already sorted it.so need of keeping max so far."
                    }
                ]
            },
            {
                "id": 2045134,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 2035602,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 2028623,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1993295,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1902267,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1899215,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1869938,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1852503,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1847491,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            },
            {
                "id": 1838667,
                "content": [
                    {
                        "username": "adityaiiitnagpur",
                        "content": "solved\\n"
                    },
                    {
                        "username": "kylebloom05",
                        "content": "This problem feels especially arbitrary and goofy. \\n\\nThere is a lack of clarity. Why can\\'t you form a triangle with the lengths 1, 2, 10 in the second example if you can form a triangle with 1, 2, 2 in the first example? Are we talking only about right angle triangles? If so, the question should specify that. Otherwise, triangles should be able to be formed with any 3 lengths and this problem has unnecessary limitations."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: \n1. Sort and start from the back and find the FIRST valid group of 3 that satisfies the properties of a triangle "
                    },
                    {
                        "username": "Undefeated22",
                        "content": ",\\n"
                    },
                    {
                        "username": "_Jenia_",
                        "content": "this is my code, and its giving output 8 for this test case [3,2,3,4], expected output is 10. can someone explain me the error?\\nclass Solution {\\npublic:\\n    int largestPerimeter(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int peri=0;\\n        for(int i=nums.size()-1; i>=2;--i)\\n        {\\nif(nums[i]<nums[i-1]+nums[i-2])\\n{\\n    peri=nums[i]+nums[i-1]+nums[i-2];\\n}\\n        }\\n        return peri;\\n    }\\n};"
                    },
                    {
                        "username": "dvrd",
                        "content": "because you are not comparing the previous calculated perimeters"
                    },
                    {
                        "username": "speedyy",
                        "content": "If anybody still confused why people sorted it first or why sorting is needed here crucially or trying to find more details, I tried to explained from scratch, you can check the [link](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used-from-scratch/) "
                    },
                    {
                        "username": "vavan66",
                        "content": "\\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0443 \\u043C\\u0435\\u043D\\u044F \\u043D\\u0435\\u0432\\u0430\\u043B\\u0438\\u0434\\u043D\\u044B\\u0435 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0435?"
                    },
                    {
                        "username": "solavsujit",
                        "content": "I did not get the problem can any one explain it"
                    },
                    {
                        "username": "patrickallard",
                        "content": "The key with this one is identifying what are the condition to creating a valid, non-zero area triangle. If you need a hint, remember that the problem definition says nothing about sorting the array..."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Problem is marked with Greedy but if I try every single possibility I hit Time Limit!"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "why didn\\'t we took 1,2,1. Because with that we can have a non-zero area"
                    },
                    {
                        "username": "speedyy",
                        "content": "if a = 1, b = 2, c = 1\nthen a+b>c and b+c>a are true BUT a+c>b (2>2) is not true. So if there is a single variation (from : a+b>c, a+c>b, b+c>a) which is false then you can't make triangle with that given a,b,c. If you also want to look for more explanation of why sort() used you can read my [explanation](https://leetcode.com/problems/largest-perimeter-triangle/solutions/3542385/precise-explanation-of-why-sort-used/)  "
                    }
                ]
            }
        ]
    }
]