[
    {
        "title": "Cells in a Range on an Excel Sheet",
        "question_content": "A cell (r, c) of an excel sheet is represented as a string \"<col><row>\" where:\n\n\t<col> denotes the column number c of the cell. It is represented by alphabetical letters.\n\t\n\t\tFor example, the 1st column is denoted by 'A', the 2nd by 'B', the 3rd by 'C', and so on.\n\t\n\t\n\t<row> is the row number r of the cell. The rth row is represented by the integer r.\n\nYou are given a string s&nbsp;in&nbsp;the format \"<col1><row1>:<col2><row2>\", where <col1> represents the column c1, <row1> represents the row r1, <col2> represents the column c2, and <row2> represents the row r2, such that r1 <= r2 and c1 <= c2.\nReturn the list of cells (x, y) such that r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as&nbsp;strings in the format mentioned above and be sorted in non-decreasing order first by columns and then by rows.\n&nbsp;\nExample 1:\n\nInput: s = \"K1:L2\"\nOutput: [\"K1\",\"K2\",\"L1\",\"L2\"]\nExplanation:\nThe above diagram shows the cells which should be present in the list.\nThe red arrows denote the order in which the cells should be presented.\n\nExample 2:\n\nInput: s = \"A1:F1\"\nOutput: [\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]\nExplanation:\nThe above diagram shows the cells which should be present in the list.\nThe red arrow denotes the order in which the cells should be presented.\n\n&nbsp;\nConstraints:\n\n\ts.length == 5\n\t'A' <= s[0] <= s[3] <= 'Z'\n\t'1' <= s[1] <= s[4] <= '9'\n\ts consists of uppercase English letters, digits and ':'.",
        "solutions": [
            {
                "id": 1823744,
                "title": "two-loops",
                "content": "**Python**\\n```python\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c) + chr(r) for c in range(ord(s[0]), ord(s[3]) + 1) for r in range(ord(s[1]), ord(s[4]) + 1)]\\n```\\n**C++**\\n```cpp\\nvector<string> cellsInRange(string s) {\\n    vector<string> res;\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.push_back({c, r});\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c) + chr(r) for c in range(ord(s[0]), ord(s[3]) + 1) for r in range(ord(s[1]), ord(s[4]) + 1)]\\n```\n```cpp\\nvector<string> cellsInRange(string s) {\\n    vector<string> res;\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.push_back({c, r});\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823819,
                "title": "java-python-3-simple-code-w-analysis",
                "content": "\\n\\n```java\\n    public List<String> cellsInRange(String s) {\\n        char c1 = s.charAt(0), c2 = s.charAt(3);\\n        char r1 = s.charAt(1), r2 = s.charAt(4);\\n        List<String> cells = new ArrayList<>();\\n        for (char c = c1; c <= c2; ++c) {\\n            for (char r = r1; r <= r2; ++r) {\\n                cells.add(\"\" + c + r);\\n            }\\n        }\\n        return cells;\\n    }\\n```\\n```python\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1, c2 = ord(s[0]), ord(s[3])\\n        r1, r2 = int(s[1]), int(s[4])\\n        return [chr(c) + str(r) for c in range(c1, c2 + 1) for r in range(r1, r2 + 1)]\\n```\\nPython 3 Two liner: credit to **@stefan4trivia**:\\n```python\\ndef cellsInRange(self, s: str) -> List[str]:\\n    c1, r1, _, c2, r2 = map(ord, s)\\n    return [chr(c) + chr(r) for c in range(c1, c2 + 1) for r in range(r1, r2 + 1)]\\n```\\n**Analysis:**\\n\\nTime: `O((c2 - c1 + 1) * (r2 - r1 + 1))`, space: `O(1)` - excluding return space.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<String> cellsInRange(String s) {\\n        char c1 = s.charAt(0), c2 = s.charAt(3);\\n        char r1 = s.charAt(1), r2 = s.charAt(4);\\n        List<String> cells = new ArrayList<>();\\n        for (char c = c1; c <= c2; ++c) {\\n            for (char r = r1; r <= r2; ++r) {\\n                cells.add(\"\" + c + r);\\n            }\\n        }\\n        return cells;\\n    }\\n```\n```python\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1, c2 = ord(s[0]), ord(s[3])\\n        r1, r2 = int(s[1]), int(s[4])\\n        return [chr(c) + str(r) for c in range(c1, c2 + 1) for r in range(r1, r2 + 1)]\\n```\n```python\\ndef cellsInRange(self, s: str) -> List[str]:\\n    c1, r1, _, c2, r2 = map(ord, s)\\n    return [chr(c) + chr(r) for c in range(c1, c2 + 1) for r in range(r1, r2 + 1)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1824082,
                "title": "c-brute-force-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        \\n        vector<string>ans;\\n        \\n        for(char ch=s[0];ch<=s[3];ch++)\\n        {\\n            for(int i=s[1]-\\'0\\';i<=s[4]-\\'0\\';i++)\\n            {\\n                string res=\"\";\\n                res+=ch;\\n                res+=to_string(i);\\n                ans.push_back(res);\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        \\n        vector<string>ans;\\n        \\n        for(char ch=s[0];ch<=s[3];ch++)\\n        {\\n            for(int i=s[1]-\\'0\\';i<=s[4]-\\'0\\';i++)\\n            {\\n                string res=\"\";\\n                res+=ch;\\n                res+=to_string(i);\\n                ans.push_back(res);\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833319,
                "title": "javascript-easy-to-understand-double-loop",
                "content": "The strategy for this problem is straightforward:\\n- we traverse from start letter to end letter\\n- for each letter, we traverse from start number to end number\\n\\nI can\\'t find tricks for this problem, if you find some please comment, thanks.\\n\\nHere\\'s the code I submitted during the contest:\\n\\n```js\\nconst cellsInRange = (s) => {\\n  const [fromLetter, fromNum, , toLetter, toNum] = s;\\n  const ret = [];\\n  for (let l1 = fromLetter.charCodeAt(0), l2 = toLetter.charCodeAt(0); l1 <= l2; ++l1) {\\n    for (let n1 = +fromNum, n2 = +toNum; n1 <= n2; ++n1) {\\n      ret.push(String.fromCharCode(l1) + n1);\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst cellsInRange = (s) => {\\n  const [fromLetter, fromNum, , toLetter, toNum] = s;\\n  const ret = [];\\n  for (let l1 = fromLetter.charCodeAt(0), l2 = toLetter.charCodeAt(0); l1 <= l2; ++l1) {\\n    for (let n1 = +fromNum, n2 = +toNum; n1 <= n2; ++n1) {\\n      ret.push(String.fromCharCode(l1) + n1);\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165250,
                "title": "java-simple-solution-runtime-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**cs= column Start**\\n**ce= column End**\\n**rs= row Start**\\n**re= row End**\\n\\n**c= Column**\\n**r= Row**\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n\\n    // runtime 1 ms\\n\\n    //cs= Column Start //ce= Column End\\n    //rs= Row Start   //re= Row End\\n    char cs=s.charAt(0),ce=s.charAt(3);\\n    char rs=s.charAt(1),re=s.charAt(4);\\n\\n    List<String> ls=new ArrayList<>();\\n    //c - cell\\n    for(char c=cs;c<=ce;c++){\\n        // r - row\\n        for(char r=rs;r<=re;r++){\\n            ls.add(new String(new char[]{c,r} ));\\n        }\\n    }\\n\\n    return ls;\\n\\n\\n  \\n    }\\n}\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/49543455-2edd-4e6e-9e2b-5a6749aae7fd_1676026442.6162713.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n\\n    // runtime 1 ms\\n\\n    //cs= Column Start //ce= Column End\\n    //rs= Row Start   //re= Row End\\n    char cs=s.charAt(0),ce=s.charAt(3);\\n    char rs=s.charAt(1),re=s.charAt(4);\\n\\n    List<String> ls=new ArrayList<>();\\n    //c - cell\\n    for(char c=cs;c<=ce;c++){\\n        // r - row\\n        for(char r=rs;r<=re;r++){\\n            ls.add(new String(new char[]{c,r} ));\\n        }\\n    }\\n\\n    return ls;\\n\\n\\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823695,
                "title": "easy-solution-in-java-6-lines-of-code",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String str) {\\n        char[] s = str.toCharArray();\\n        List<String> result = new ArrayList<>();\\n        for (char c1 = s[0]; c1 <= s[3]; c1++) {\\n            for (char c2 = s[1]; c2 <= s[4]; c2++) {\\n                result.add(\"\" + c1 + c2);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String str) {\\n        char[] s = str.toCharArray();\\n        List<String> result = new ArrayList<>();\\n        for (char c1 = s[0]; c1 <= s[3]; c1++) {\\n            for (char c2 = s[1]; c2 <= s[4]; c2++) {\\n                result.add(\"\" + c1 + c2);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824001,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        result=[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            rs=\"\"\\n            for j in range(int(s[1]),int(s[4])+1):\\n                rs=chr(i)+str(j)\\n                result.append(rs)\\n        return result\\n\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        result=[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            rs=\"\"\\n            for j in range(int(s[1]),int(s[4])+1):\\n                rs=chr(i)+str(j)\\n                result.append(rs)\\n        return result\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1823607,
                "title": "python3-1-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/bb5647e856ff11b072f9c51a140e0f243c100171) for solutions of weekly 283.\\n\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]), ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]), ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823901,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {\\n        char ch1 = s[0], ch2 = s[3];              // stroing 0th and 3rd char [A1:B2] , 0th=A , 3rd=B\\n        int in1= s[1]-\\'0\\', in2=s[4]-\\'0\\';          // stroing 1st and 4th int [A1:B2] ,  1st=1 , 4th=2\\n        vector<string> ans;\\n        \\n        for(int i=ch1-\\'A\\'; i<=ch2-\\'A\\'; i++)\\n        {\\n            for(int j=in1; j<=in2; j++)\\n            {\\n                string s= ch1+to_string(j);\\n                ans.push_back(s);\\n            }\\n            ch1 = ch1+1;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {\\n        char ch1 = s[0], ch2 = s[3];              // stroing 0th and 3rd char [A1:B2] , 0th=A , 3rd=B\\n        int in1= s[1]-\\'0\\', in2=s[4]-\\'0\\';          // stroing 1st and 4th int [A1:B2] ,  1st=1 , 4th=2\\n        vector<string> ans;\\n        \\n        for(int i=ch1-\\'A\\'; i<=ch2-\\'A\\'; i++)\\n        {\\n            for(int j=in1; j<=in2; j++)\\n            {\\n                string s= ch1+to_string(j);\\n                ans.push_back(s);\\n            }\\n            ch1 = ch1+1;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515289,
                "title": "my-cellsinrange",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nfunction parser(s) {\\n\\tlet result = [];\\n\\tlet index = s.indexOf(\\':\\');\\n\\tresult.push(s[0]);\\n\\tresult.push(+s.slice(1, index));\\n\\tresult.push(s[index + 1]);\\n\\tresult.push(+s.slice(index + 2));\\n\\treturn result;\\n}\\n\\nvar cellsInRange = function (s) {\\n\\tlet parserResult = parser(s);\\n\\tlet firstLetter = parserResult[0];\\n\\tlet firstNum = parserResult[1];\\n\\tlet secondLetter = parserResult[2];\\n\\tlet secondNum = parserResult[3];\\n\\tlet alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'.toUpperCase();\\n\\tlet letters = alphabet.slice(alphabet.indexOf(firstLetter), alphabet.indexOf(secondLetter) + 1).split(\\'\\');\\n\\tlet result = [];\\n\\tletters.forEach(letter => {\\n\\t\\tfor (let num = firstNum; num < secondNum + 1; num++) {\\n\\t\\t\\tresult.push(letter + num);\\n\\t\\t}\\n\\t});\\n\\treturn result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nfunction parser(s) {\\n\\tlet result = [];\\n\\tlet index = s.indexOf(\\':\\');\\n\\tresult.push(s[0]);\\n\\tresult.push(+s.slice(1, index));\\n\\tresult.push(s[index + 1]);\\n\\tresult.push(+s.slice(index + 2));\\n\\treturn result;\\n}\\n\\nvar cellsInRange = function (s) {\\n\\tlet parserResult = parser(s);\\n\\tlet firstLetter = parserResult[0];\\n\\tlet firstNum = parserResult[1];\\n\\tlet secondLetter = parserResult[2];\\n\\tlet secondNum = parserResult[3];\\n\\tlet alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'.toUpperCase();\\n\\tlet letters = alphabet.slice(alphabet.indexOf(firstLetter), alphabet.indexOf(secondLetter) + 1).split(\\'\\');\\n\\tlet result = [];\\n\\tletters.forEach(letter => {\\n\\t\\tfor (let num = firstNum; num < secondNum + 1; num++) {\\n\\t\\t\\tresult.push(letter + num);\\n\\t\\t}\\n\\t});\\n\\treturn result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953186,
                "title": "python-solution-with-explanation-of-ascii-ord-chr",
                "content": "**`ord(character)`** gives ascii value of that character\\n**`chr(ascii)`** converts ascii value back to character\\n\\nexample: \\nord(\"a\")=97\\nchr(97)= a\\n\\nord(\"A\")=65\\nchr(65)=A\\n\\n**`fun fact:`** ```Difference between ascii values of lowercase character and its uppercase is 32```\\n\\n```\\n    def cellsInRange(self, s: str) -> List[str]:\\n        \\n        fr=int(s[1])\\n        sr=int(s[4])+1\\n        l=[]\\n        \\n       \\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(fr, sr):\\n                l.append(chr(ch)+str(i))\\n        return l\\n```\\n\\nThis question is quite simple so i am not explaining much. Let me know if you have any doubt.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Difference between ascii values of lowercase character and its uppercase is 32```\n```\\n    def cellsInRange(self, s: str) -> List[str]:\\n        \\n        fr=int(s[1])\\n        sr=int(s[4])+1\\n        l=[]\\n        \\n       \\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(fr, sr):\\n                l.append(chr(ch)+str(i))\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1888602,
                "title": "1ms-java-solution-no-concatenation",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char sc = s.charAt(0), ec = s.charAt(3);\\n        char sr = s.charAt(1), er = s.charAt(4);\\n        List<String> res = new ArrayList<>();\\n        \\n        for (char i = sc; i <= ec; ++i){\\n            for (char j = sr; j <= er; ++j){\\n                res.add(new String(new char[]{i, j}));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char sc = s.charAt(0), ec = s.charAt(3);\\n        char sr = s.charAt(1), er = s.charAt(4);\\n        List<String> res = new ArrayList<>();\\n        \\n        for (char i = sc; i <= ec; ++i){\\n            for (char j = sr; j <= er; ++j){\\n                res.add(new String(new char[]{i, j}));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824129,
                "title": "javascript-pretty",
                "content": "```\\nconst toCharCode = (char) => char.charCodeAt()\\n\\nvar cellsInRange = function(s) {\\n    const result = []\\n    for(let i = toCharCode(s[0]) ; i <= toCharCode(s[3]) ; i++){\\n        for(let j = s[1] ; j <= s[4] ; j++){\\n            result.push(String.fromCharCode(i) +j)\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst toCharCode = (char) => char.charCodeAt()\\n\\nvar cellsInRange = function(s) {\\n    const result = []\\n    for(let i = toCharCode(s[0]) ; i <= toCharCode(s[3]) ; i++){\\n        for(let j = s[1] ; j <= s[4] ; j++){\\n            result.push(String.fromCharCode(i) +j)\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704256,
                "title": "python-simple-solution-faster-than-97-44",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1,r1,c2,r2 = s[:1], s[1:2], s[3:4], s[4:]\\n        a=[]\\n        for i in range(ord(c1),ord(c2)+1):\\n            x=chr(i)\\n            for j in range(int(r1),int(r2)+1):\\n                y=x+str(j)\\n                a.append(y)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1,r1,c2,r2 = s[:1], s[1:2], s[3:4], s[4:]\\n        a=[]\\n        for i in range(ord(c1),ord(c2)+1):\\n            x=chr(i)\\n            for j in range(int(r1),int(r2)+1):\\n                y=x+str(j)\\n                a.append(y)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591833,
                "title": "c-100-easy-understanding-0m",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string>ans;\\n        char leftChar = s[0];\\n        char rightChar = s[3];\\n        \\n        while (leftChar <= rightChar){\\n            int low = s[1] - \\'0\\', high = s[4] - \\'0\\';\\n            while (low <= high){\\n                ans.push_back(leftChar + to_string(low));\\n                low++;\\n            }\\n            leftChar++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string>ans;\\n        char leftChar = s[0];\\n        char rightChar = s[3];\\n        \\n        while (leftChar <= rightChar){\\n            int low = s[1] - \\'0\\', high = s[4] - \\'0\\';\\n            while (low <= high){\\n                ans.push_back(leftChar + to_string(low));\\n                low++;\\n            }\\n            leftChar++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826374,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let sb = s.as_bytes();\\n        (sb[0]..=sb[3])\\n            .flat_map(|col| (sb[1]..=sb[4]).map(move |row| format!(\"{}{}\", col as char, row as char)))\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let sb = s.as_bytes();\\n        (sb[0]..=sb[3])\\n            .flat_map(|col| (sb[1]..=sb[4]).map(move |row| format!(\"{}{}\", col as char, row as char)))\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823693,
                "title": "easy-simulation-with-comments",
                "content": "**Alogorithm**:\\nWe have to iterate from `col1 to col2` **letters** and for every letter we just have to traverse from `row1 to row2` **number.**\\nIn this way we will get our answer in **sorted order** automatically.\\n\\n**C++**\\n    \\n\\tvector<string> cellsInRange(string s){\\n        //result answer\\n        vector<string> res;\\n        \\n        //extract columns and rows\\n        int col1= s[0]-\\'A\\' , col2= s[3]-\\'A\\';\\n        int row1= s[1]-\\'0\\' , row2= s[4]-\\'0\\';\\n        \\n        //keep incrementing the character from c1->c2\\n        for(;col1<=col2;col1++){\\n           char letter= col1+\\'A\\'; \\n           //for every charcter traverse from r1->r2 \\n           for(int i=row1;i<=row2;i++){\\n               string p=\"\";\\n               char r= i+\\'0\\';     //get corresponding column in terms of character\\n               p+=letter;         //append current column-> letter\\n               p+=r;              //append current row\\n               res.push_back(p);  //put string in res vector\\n           } \\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Alogorithm**:\\nWe have to iterate from `col1 to col2` **letters** and for every letter we just have to traverse from `row1 to row2` **number.**\\nIn this way we will get our answer in **sorted order** automatically.\\n\\n**C++**\\n    \\n\\tvector<string> cellsInRange(string s){\\n        //result answer\\n        vector<string> res;\\n        \\n        //extract columns and rows\\n        int col1= s[0]-\\'A\\' , col2= s[3]-\\'A\\';\\n        int row1= s[1]-\\'0\\' , row2= s[4]-\\'0\\';\\n        \\n        //keep incrementing the character from c1->c2\\n        for(;col1<=col2;col1++){\\n           char letter= col1+\\'A\\'; \\n           //for every charcter traverse from r1->r2 \\n           for(int i=row1;i<=row2;i++){\\n               string p=\"\";\\n               char r= i+\\'0\\';     //get corresponding column in terms of character\\n               p+=letter;         //append current column-> letter\\n               p+=r;              //append current row\\n               res.push_back(p);  //put string in res vector\\n           } \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1823666,
                "title": "java-straightforward",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        for(char i = \\'A\\' ; i <= \\'Z\\'; ++i) {\\n            for(char j = \\'1\\'; j <= \\'9\\'; ++j) {\\n                if(i >= s.charAt(0) && i <= s.charAt(3) && j >= s.charAt(1) && j <= s.charAt(4)){\\n                    ans.add(Character.toString(i) + Character.toString(j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<String>();\\n        for(char i = \\'A\\' ; i <= \\'Z\\'; ++i) {\\n            for(char j = \\'1\\'; j <= \\'9\\'; ++j) {\\n                if(i >= s.charAt(0) && i <= s.charAt(3) && j >= s.charAt(1) && j <= s.charAt(4)){\\n                    ans.add(Character.toString(i) + Character.toString(j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779607,
                "title": "python-3-two-loops-1-line-bonus-beats-97",
                "content": "```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(int(s[1]), int(s[4])+1):\\n                res.append(f\\'{chr(ch)}{i}\\')\\n        return res\\n```\\n```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\\'{chr(ch)}{i}\\' for ch in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1)]\\n```\\n![Screenshot 2023-07-17 at 22.02.52.png](https://assets.leetcode.com/users/images/417eaef4-6451-4ffa-9cbe-d39867ab6f5c_1689620605.0786376.png)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        for ch in range(ord(s[0]), ord(s[3])+1):\\n            for i in range(int(s[1]), int(s[4])+1):\\n                res.append(f\\'{chr(ch)}{i}\\')\\n        return res\\n```\n```python3 []\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\\'{chr(ch)}{i}\\' for ch in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394861,
                "title": "c-and-c-very-easy-solution",
                "content": "\\n```C# []\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        List<string> res=new List<string>();\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.Add($\"{c}{r}\");\\n    return res;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n    vector<string> res;\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.push_back({c, r});\\n    return res;\\n    }     \\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "String"
                ],
                "code": "```C# []\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        List<string> res=new List<string>();\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.Add($\"{c}{r}\");\\n    return res;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n    vector<string> res;\\n    for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n            res.push_back({c, r});\\n    return res;\\n    }     \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946295,
                "title": "easy-python-for-loop",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        a,b=map(str,s.split(\":\"))\\n        m=[]\\n        r=range(ord(a[0]),ord(b[0])+1)\\n        for i in r:\\n            for j in range(int(a[-1]),int(b[-1])+1):\\n                m.append(chr(i)+str(j))\\n        return m\\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        a,b=map(str,s.split(\":\"))\\n        m=[]\\n        r=range(ord(a[0]),ord(b[0])+1)\\n        for i in r:\\n            for j in range(int(a[-1]),int(b[-1])+1):\\n                m.append(chr(i)+str(j))\\n        return m\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 3764784,
                "title": "easiest-c-solution-o-n-2-time-complexity-beats-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string>ans; \\n        for(char ch = s[0]; ch <= s[3]; ch++){\\n            for(int i = s[1]-\\'0\\'; i <= s[4]-\\'0\\'; i++){\\n                ans.push_back(ch + to_string(i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string>ans; \\n        for(char ch = s[0]; ch <= s[3]; ch++){\\n            for(int i = s[1]-\\'0\\'; i <= s[4]-\\'0\\'; i++){\\n                ans.push_back(ch + to_string(i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758952,
                "title": "beats-100-simple-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        ArrayList<String> ans = new ArrayList<>();\\n        \\n        char c1 = s.charAt(0);\\n        char r1 = s.charAt(1);\\n        char c2 = s.charAt(3);\\n        char r2 = s.charAt(4);\\n\\n        for(char i = c1; i<=c2; i++){\\n            for(char j = r1; j<= r2; j++){\\n                StringBuilder str = new StringBuilder();\\n                str.append(i).append(j);\\n                ans.add(str.toString());\\n            }\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        ArrayList<String> ans = new ArrayList<>();\\n        \\n        char c1 = s.charAt(0);\\n        char r1 = s.charAt(1);\\n        char c2 = s.charAt(3);\\n        char r2 = s.charAt(4);\\n\\n        for(char i = c1; i<=c2; i++){\\n            for(char j = r1; j<= r2; j++){\\n                StringBuilder str = new StringBuilder();\\n                str.append(i).append(j);\\n                ans.add(str.toString());\\n            }\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442027,
                "title": "cells-in-a-range-on-an-excel-sheet-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int i, j;\\n        vector<string> ans;\\n        string temp = \"\";\\n        string temp2 = \"\";\\n        \\n        for(i=s[0] ; i<=s[3] ; i++)\\n        {\\n            temp += (char)(i);\\n            for(j=s[1] ; j<=s[4] ; j++)\\n            {\\n                temp2 += temp;\\n                temp2 += (char)(j);\\n                ans.push_back(temp2);\\n                temp2.clear();\\n            }\\n            temp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/5d773661-3c5c-46c6-9c6a-9b1c9f42b2d0_1682613052.7181225.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int i, j;\\n        vector<string> ans;\\n        string temp = \"\";\\n        string temp2 = \"\";\\n        \\n        for(i=s[0] ; i<=s[3] ; i++)\\n        {\\n            temp += (char)(i);\\n            for(j=s[1] ; j<=s[4] ; j++)\\n            {\\n                temp2 += temp;\\n                temp2 += (char)(j);\\n                ans.push_back(temp2);\\n                temp2.clear();\\n            }\\n            temp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863323,
                "title": "java-char-array-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> answerList = new ArrayList<>();\\n        int startLetter, startNumber, endLetter, endNumber;\\n        char[] charArray = s.toCharArray();\\n        startLetter = charArray[0];\\n        startNumber = Character.getNumericValue(charArray[1]);\\n        endLetter = charArray[3];\\n        endNumber = Character.getNumericValue(charArray[4]);\\n        for(int i = startLetter; i <= endLetter; i++) {\\n            String letter = String.valueOf((char) i);\\n            for (int j = startNumber; j <= endNumber; j++) {\\n                answerList.add(letter + j);\\n            }\\n        }\\n        return answerList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> answerList = new ArrayList<>();\\n        int startLetter, startNumber, endLetter, endNumber;\\n        char[] charArray = s.toCharArray();\\n        startLetter = charArray[0];\\n        startNumber = Character.getNumericValue(charArray[1]);\\n        endLetter = charArray[3];\\n        endNumber = Character.getNumericValue(charArray[4]);\\n        for(int i = startLetter; i <= endLetter; i++) {\\n            String letter = String.valueOf((char) i);\\n            for (int j = startNumber; j <= endNumber; j++) {\\n                answerList.add(letter + j);\\n            }\\n        }\\n        return answerList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823458,
                "title": "simplest-detailed-approach-in-python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        alpha = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n\\n        # Rows\\n        r1 = int(s[1])\\n        r2 = int(s[-1])\\n\\n        # Columns\\n        c1 = s[0]\\n        c2 = s[-2]\\n\\n        op = []\\n        for col in range(alpha.index(c1), alpha.index(c2)+1):\\n            for row in range(r1, r2+1):\\n                op.append(alpha[col] + str(row))\\n        return op\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        alpha = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n\\n        # Rows\\n        r1 = int(s[1])\\n        r2 = int(s[-1])\\n\\n        # Columns\\n        c1 = s[0]\\n        c2 = s[-2]\\n\\n        op = []\\n        for col in range(alpha.index(c1), alpha.index(c2)+1):\\n            for row in range(r1, r2+1):\\n                op.append(alpha[col] + str(row))\\n        return op\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368874,
                "title": "95-ms-faster-than-65-68-of-javascript",
                "content": "```\\nvar cellsInRange = function (s) {\\n    let arr = s.split(\":\");\\n    let textStart = arr[0];\\n    let charstart = textStart.charCodeAt(0);\\n    let textEnd = arr[arr.length - 1];\\n    let charend = textEnd.charCodeAt(0);\\n    let RowLen = arr[arr.length - 1][1];\\n    let res = [];\\n    for (let i = charstart; i <= charend; i++) {\\n        let letter = String.fromCharCode(i);\\n        for (let j = arr[0][1]; j <= RowLen; j++) {\\n            res.push(letter + j);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cellsInRange = function (s) {\\n    let arr = s.split(\":\");\\n    let textStart = arr[0];\\n    let charstart = textStart.charCodeAt(0);\\n    let textEnd = arr[arr.length - 1];\\n    let charend = textEnd.charCodeAt(0);\\n    let RowLen = arr[arr.length - 1][1];\\n    let res = [];\\n    for (let i = charstart; i <= charend; i++) {\\n        let letter = String.fromCharCode(i);\\n        for (let j = arr[0][1]; j <= RowLen; j++) {\\n            res.push(letter + j);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823707,
                "title": "easy-c-o-n-2-solution",
                "content": "\\n        char a=s[0];\\n        char b=s[3];\\n        char c=s[1];\\n        char d=s[4];\\n        vector<string>res;\\n        for(char i=a; i<=b; i++){\\n            for(char x=c; x<=d; x++){\\n                string temp;\\n                temp+=i;\\n                temp+=x;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n        char a=s[0];\\n        char b=s[3];\\n        char c=s[1];\\n        char d=s[4];\\n        vector<string>res;\\n        for(char i=a; i<=b; i++){\\n            for(char x=c; x<=d; x++){\\n                string temp;\\n                temp+=i;\\n                temp+=x;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 3653355,
                "title": "100-beats-simple-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n          int initialCol = s.charAt(0);\\n        int finalCol = s.charAt(3);\\n        \\n        int initialRow = s.charAt(1);\\n        int finalRow = s.charAt(4);\\n\\n        List<String> cells = new ArrayList<>();\\n        char[] ch = new char[2];\\n\\n        for(int c = initialCol; c <= finalCol; c++){            \\n            for(int r = initialRow; r <= finalRow; r++){\\n                 ch[0] = (char)c;\\n                 ch[1] = (char)r;\\n                 cells.add(String.valueOf(ch));\\n            }\\n        }\\n\\n        return cells;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n          int initialCol = s.charAt(0);\\n        int finalCol = s.charAt(3);\\n        \\n        int initialRow = s.charAt(1);\\n        int finalRow = s.charAt(4);\\n\\n        List<String> cells = new ArrayList<>();\\n        char[] ch = new char[2];\\n\\n        for(int c = initialCol; c <= finalCol; c++){            \\n            for(int r = initialRow; r <= finalRow; r++){\\n                 ch[0] = (char)c;\\n                 ch[1] = (char)r;\\n                 cells.add(String.valueOf(ch));\\n            }\\n        }\\n\\n        return cells;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422487,
                "title": "c-code",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to move from the number in first part of the colon to the number in the second part of the colon, meanwhile covering all the alphabets between that in first colon to the one in second colon. For an example :\\nK1 : M4\\nIndicates, in each column from K to M ie K,L,M,\\nWe need to go down the column by 4 spaces hence the answer will be,\\nK1,K2,K3,K4,L1,L2,L3,L4,M1,M2,M3,M4\\nBelow code is the Implementation of the same.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {   \\n        int startch = s[0];\\n        int endch = s[3];\\n        int startIn = int(s[1])-48;\\n        int endIn = int(s[4])-48;\\n        vector<string>result;\\n       for(char c = startch; c<= endch; c++)\\n       {\\n           for(int i = startIn; i<= endIn; i++)\\n           { \\n               string str = \"\";\\n               str+=c;\\n               str+=to_string(i);\\n               result.push_back(str);\\n           }\\n       } \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {   \\n        int startch = s[0];\\n        int endch = s[3];\\n        int startIn = int(s[1])-48;\\n        int endIn = int(s[4])-48;\\n        vector<string>result;\\n       for(char c = startch; c<= endch; c++)\\n       {\\n           for(int i = startIn; i<= endIn; i++)\\n           { \\n               string str = \"\";\\n               str+=c;\\n               str+=to_string(i);\\n               result.push_back(str);\\n           }\\n       } \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334434,
                "title": "most-easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char startCol=s.charAt(0);\\n        int startRow=s.charAt(1)-\\'0\\';\\n        char endCol=s.charAt(3);\\n        int endRow=s.charAt(4)-\\'0\\';\\n        List<String> ans=new ArrayList<>();\\n        for(char c=startCol;c<=endCol;){\\n            for(int i=startRow;i<=endRow;i++){\\n                ans.add(c+\"\"+i);\\n        }\\n        c=(char)(c+1);\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char startCol=s.charAt(0);\\n        int startRow=s.charAt(1)-\\'0\\';\\n        char endCol=s.charAt(3);\\n        int endRow=s.charAt(4)-\\'0\\';\\n        List<String> ans=new ArrayList<>();\\n        for(char c=startCol;c<=endCol;){\\n            for(int i=startRow;i<=endRow;i++){\\n                ans.add(c+\"\"+i);\\n        }\\n        c=(char)(c+1);\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221188,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char[] sc = s.toCharArray();\\n        List<String> ar = new ArrayList<>();\\n        for(char c1=sc[0];c1<=sc[3];c1++){\\n            for(char n1=sc[1];n1<=sc[4];n1++){\\n                ar.add(\"\"+c1+n1);\\n            }\\n        }\\n        return ar;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char[] sc = s.toCharArray();\\n        List<String> ar = new ArrayList<>();\\n        for(char c1=sc[0];c1<=sc[3];c1++){\\n            for(char n1=sc[1];n1<=sc[4];n1++){\\n                ar.add(\"\"+c1+n1);\\n            }\\n        }\\n        return ar;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210384,
                "title": "c-solution-simple-approach-using-2-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        \\n    char start_col = s[0];\\n    char start_row = s[1];\\n    char end_col = s[3];\\n    char end_row = s[4];\\n\\n    vector<string> ans;\\n    for (char i = start_col; i <= end_col; i++)\\n    {\\n        for (char j = start_row; j <= end_row; j++)\\n        {\\n            string cell = \"\";\\n            cell = cell + i + j;\\n            ans.push_back(cell);\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        \\n    char start_col = s[0];\\n    char start_row = s[1];\\n    char end_col = s[3];\\n    char end_row = s[4];\\n\\n    vector<string> ans;\\n    for (char i = start_col; i <= end_col; i++)\\n    {\\n        for (char j = start_row; j <= end_row; j++)\\n        {\\n            string cell = \"\";\\n            cell = cell + i + j;\\n            ans.push_back(cell);\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206879,
                "title": "java-1ms-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> l = new ArrayList<>();\\n        for(char i = s.charAt(0); i <= s.charAt(3); i++){\\n            for(char j = s.charAt(1); j <= s.charAt(4); j++){\\n                l.add(new String(new char[]{i,j}));\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> l = new ArrayList<>();\\n        for(char i = s.charAt(0); i <= s.charAt(3); i++){\\n            for(char j = s.charAt(1); j <= s.charAt(4); j++){\\n                l.add(new String(new char[]{i,j}));\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798345,
                "title": "simple-c-solution-100beats-at-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        char startCol = s[0];\\n        char endCol = s[3];\\n        int startIndex = s[1];\\n        int endIndex = s[4];\\n\\n        for(char i = startCol; i<= endCol; i++)\\n            for(char j = startIndex ; j <= endIndex; j++)\\n                result.push_back(string(1,i)+j);\\n            \\n\\n       return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        char startCol = s[0];\\n        char endCol = s[3];\\n        int startIndex = s[1];\\n        int endIndex = s[4];\\n\\n        for(char i = startCol; i<= endCol; i++)\\n            for(char j = startIndex ; j <= endIndex; j++)\\n                result.push_back(string(1,i)+j);\\n            \\n\\n       return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752059,
                "title": "java-94-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> selectedCells=new ArrayList<>();\\n        StringBuilder builder = new StringBuilder();\\n        char s1 = s.charAt(0);\\n        char s2 = s.charAt(3);\\n        int s3 = s.charAt(1)-48;\\n        int s4 = s.charAt(4)-48;\\n        for(char i=s1; i<=s2;i++){\\n            builder.append(i);\\n            for(int j=s3; j<=s4;j++){\\n                builder.append(j);\\n                selectedCells.add(builder.toString());\\n                builder.deleteCharAt(1);\\n            }\\n            builder.deleteCharAt(0);\\n        }\\n        return selectedCells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> selectedCells=new ArrayList<>();\\n        StringBuilder builder = new StringBuilder();\\n        char s1 = s.charAt(0);\\n        char s2 = s.charAt(3);\\n        int s3 = s.charAt(1)-48;\\n        int s4 = s.charAt(4)-48;\\n        for(char i=s1; i<=s2;i++){\\n            builder.append(i);\\n            for(int j=s3; j<=s4;j++){\\n                builder.append(j);\\n                selectedCells.add(builder.toString());\\n                builder.deleteCharAt(1);\\n            }\\n            builder.deleteCharAt(0);\\n        }\\n        return selectedCells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663177,
                "title": "python-chr-ord-simple",
                "content": "```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        rList = []\\n      \\n        for i in range(ord(s[0]), ord(s[3])+1):\\n            for j in range(int(s[1]), int(s[4])+1):\\n                rList.append(chr(i) + str(j))\\n        return rList\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        rList = []\\n      \\n        for i in range(ord(s[0]), ord(s[3])+1):\\n            for j in range(int(s[1]), int(s[4])+1):\\n                rList.append(chr(i) + str(j))\\n        return rList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646149,
                "title": "simple-java-solution-using-for-loop",
                "content": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n        String a=s.substring(1,2);\\n        String b=s.substring(s.length()-1,s.length());\\n        \\n        List<String> list=new ArrayList<>();\\n        char c=s.charAt(0);\\n        char d=s.charAt(3);\\n        \\n        if(a.equals(b)){\\n           for(char m=c;m<=d;m++){\\n            // System.out.println(m);\\n            list.add(m+a);\\n        }\\n        }\\n        else{\\n        int x=Integer.parseInt(a);\\n        int y=Integer.parseInt(b);\\n        for(int z=x;z<=y;z++){\\n        for(char m=c;m<=d;m++){\\n            String last=Integer.toString(z);\\n            list.add(m+last);\\n        }\\n        }\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n        String a=s.substring(1,2);\\n        String b=s.substring(s.length()-1,s.length());\\n        \\n        List<String> list=new ArrayList<>();\\n        char c=s.charAt(0);\\n        char d=s.charAt(3);\\n        \\n        if(a.equals(b)){\\n           for(char m=c;m<=d;m++){\\n            // System.out.println(m);\\n            list.add(m+a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2491489,
                "title": "0-n-2-java-simple-code",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list=new ArrayList<>();\\n        int startc=s.charAt(0)-\\'A\\';\\n        int endc=s.charAt(3)-\\'A\\';\\n        int starti=s.charAt(1)-\\'0\\';\\n        int endi=s.charAt(4)-\\'0\\';\\n        String temp=\"\";\\n        while(startc<=endc){\\n            char c=(char)(65+startc);\\n            for(int i=starti;i<=endi;i++){\\n                temp=c+\"\";\\n                char n=(char)(48+i);\\n                temp+=n+\"\";\\n                list.add(temp);\\n            }\\n            startc++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list=new ArrayList<>();\\n        int startc=s.charAt(0)-\\'A\\';\\n        int endc=s.charAt(3)-\\'A\\';\\n        int starti=s.charAt(1)-\\'0\\';\\n        int endi=s.charAt(4)-\\'0\\';\\n        String temp=\"\";\\n        while(startc<=endc){\\n            char c=(char)(65+startc);\\n            for(int i=starti;i<=endi;i++){\\n                temp=c+\"\";\\n                char n=(char)(48+i);\\n                temp+=n+\"\";\\n                list.add(temp);\\n            }\\n            startc++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445324,
                "title": "100-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char col1 = s[0];   char row1 = s[1];\\n        char col2 = s[3];   char row2 = s[4];\\n        \\n        vector<string> cells;\\n        \\n        for(int i=col1; i<=col2; i++){\\n            for(int j=row1; j<=row2; j++){\\n                string currentCell = \"  \";\\n                currentCell[0] = i;\\n                currentCell[1] = j;\\n                cells.push_back(currentCell);\\n            }\\n        }\\n        return cells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char col1 = s[0];   char row1 = s[1];\\n        char col2 = s[3];   char row2 = s[4];\\n        \\n        vector<string> cells;\\n        \\n        for(int i=col1; i<=col2; i++){\\n            for(int j=row1; j<=row2; j++){\\n                string currentCell = \"  \";\\n                currentCell[0] = i;\\n                currentCell[1] = j;\\n                cells.push_back(currentCell);\\n            }\\n        }\\n        return cells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396515,
                "title": "go-simple-solutions-0ms-3mb",
                "content": "```go\\nfunc cellsInRange(s string) []string {\\n    // pre allocate result\\n    res := make([]string, (s[3]-s[0]+1)*(s[4]-s[1]+1))\\n    var i int\\n    for c := s[0]; c <= s[3]; c++ {\\n        for r := s[1]; r <= s[4]; r++ {\\n            res[i] = string([]byte{c, r})\\n            i++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc cellsInRange(s string) []string {\\n    // pre allocate result\\n    res := make([]string, (s[3]-s[0]+1)*(s[4]-s[1]+1))\\n    var i int\\n    for c := s[0]; c <= s[3]; c++ {\\n        for r := s[1]; r <= s[4]; r++ {\\n            res[i] = string([]byte{c, r})\\n            i++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369701,
                "title": "simple-python3-no-ord-no-chr",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        start, end = s.split(\\':\\')\\n        start_letter, start_num = start[0], int(start[-1])\\n        end_letter, end_num = end[0], int(end[1])\\n        alphabet = list(\\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\')\\n        alphabet_slice = \\\\\\n            alphabet[alphabet.index(start_letter):alphabet.index(end_letter) + 1]\\n        res = list()\\n        for el in alphabet_slice:\\n            res += [el + str(num) for num in range(start_num, end_num + 1)]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        start, end = s.split(\\':\\')\\n        start_letter, start_num = start[0], int(start[-1])\\n        end_letter, end_num = end[0], int(end[1])\\n        alphabet = list(\\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\')\\n        alphabet_slice = \\\\\\n            alphabet[alphabet.index(start_letter):alphabet.index(end_letter) + 1]\\n        res = list()\\n        for el in alphabet_slice:\\n            res += [el + str(num) for num in range(start_num, end_num + 1)]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245978,
                "title": "java-solution",
                "content": "```class Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> s1= new ArrayList<>();\\n        for(char i=s.charAt(0);i<=s.charAt(3);i++)\\n        {\\n            for(int j=s.charAt(1);j<=s.charAt(4);j++)\\n            {\\n                String ans=i+\"\"+(j-\\'0\\');\\n                s1.add(ans);\\n            }\\n        }\\n        return s1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> s1= new ArrayList<>();\\n        for(char i=s.charAt(0);i<=s.charAt(3);i++)\\n        {\\n            for(int j=s.charAt(1);j<=s.charAt(4);j++)\\n            {\\n                String ans=i+\"\"+(j-\\'0\\');\\n                s1.add(ans);\\n            }\\n        }\\n        return s1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227093,
                "title": "c-100-faster",
                "content": "```\\n\\t    vector<string> v;\\n        string str = \"\";\\n        int a = (s[3]-s[0])+1;\\n        int b = (s[4]-s[1])+1;\\n        for (int i = 0; i < a; i++)\\n        {\\n            for (int j = 0; j < b; j++)\\n            {\\n                str=\"\";\\n                str.push_back(char(s[0] + i));\\n                str.push_back(char(s[1] + j));\\n                v.push_back(str);\\n            }    \\n        }\\n        return v;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t    vector<string> v;\\n        string str = \"\";\\n        int a = (s[3]-s[0])+1;\\n        int b = (s[4]-s[1])+1;\\n        for (int i = 0; i < a; i++)\\n        {\\n            for (int j = 0; j < b; j++)\\n            {\\n                str=\"\";\\n                str.push_back(char(s[0] + i));\\n                str.push_back(char(s[1] + j));\\n                v.push_back(str);\\n            }    \\n        }\\n        return v;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966259,
                "title": "javascript-begineer-solution-for-loop-faster-than-79-29",
                "content": "```\\nlet s = \"K1:L2\";\\nlet result = []\\n\\nconst [word1, word1Len, , word2, word2Len] = s;\\n\\nfor(let i= word1.charCodeAt(0) ; i<=  word2.charCodeAt(0) ;i++){\\n    let aa = (String.fromCharCode(i))\\n    for(j = word1Len ; j <=word2Len ; j++){\\n        result.push(aa+j)\\n    }\\n}\\nconsole.log(result)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet s = \"K1:L2\";\\nlet result = []\\n\\nconst [word1, word1Len, , word2, word2Len] = s;\\n\\nfor(let i= word1.charCodeAt(0) ; i<=  word2.charCodeAt(0) ;i++){\\n    let aa = (String.fromCharCode(i))\\n    for(j = word1Len ; j <=word2Len ; j++){\\n        result.push(aa+j)\\n    }\\n}\\nconsole.log(result)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947562,
                "title": "javascript-solution-using-nested-loops",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst cellsInRange = s => {\\n    let startLetter = s.charCodeAt(0) - 64;\\n    let endLetter = s.charCodeAt(3) - 64;\\n    let startNumber = parseInt(s[1])\\n    let endNumber = parseInt(s[4])\\n    let result = [];\\n\\n    for (let i = startLetter; i <= endLetter; i++) {\\n        let char = String.fromCharCode(i + 64);\\n        for (let j = startNumber; j <= endNumber; j++) {\\n            result.push(char + `${j}`);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cellsInRange = s => {\\n    let startLetter = s.charCodeAt(0) - 64;\\n    let endLetter = s.charCodeAt(3) - 64;\\n    let startNumber = parseInt(s[1])\\n    let endNumber = parseInt(s[4])\\n    let result = [];\\n\\n    for (let i = startLetter; i <= endLetter; i++) {\\n        let char = String.fromCharCode(i + 64);\\n        for (let j = startNumber; j <= endNumber; j++) {\\n            result.push(char + `${j}`);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826356,
                "title": "c-solution",
                "content": "**Note**\\nIn C#, ```char``` is value type and has a numerical value, but it doesn\\'t have a custom ```+``` operator. When we do ```+``` operation on chars, they will be implicitly converted to integers, so the result will be integer. \\n\\n**Complexity**\\n- Time: O((s[3] - s[0]) + 1 * (s[4] - s[2] + 1))\\n- Space: O((s[3] - s[0]) + 1 * (s[4] - s[2] + 1)) due to the output\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        \\n        if(string.IsNullOrEmpty(s))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        char col1 = s[0], col2 = s[3];\\n        char row1 = s[1], row2 = s[4];\\n    \\n        List<string> res = new List<string>();\\n        for(char c = col1; c <= col2; c++)\\n        {\\n            for(char r = row1; r <= row2; r++)\\n            {\\n                res.Add(c.ToString() + r.ToString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```char```\n```+```\n```+```\n```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        \\n        if(string.IsNullOrEmpty(s))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        char col1 = s[0], col2 = s[3];\\n        char row1 = s[1], row2 = s[4];\\n    \\n        List<string> res = new List<string>();\\n        for(char c = col1; c <= col2; c++)\\n        {\\n            for(char r = row1; r <= row2; r++)\\n            {\\n                res.Add(c.ToString() + r.ToString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825249,
                "title": "c-4-variables-and-2-loops-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char startCol = s[0];\\n        char endCol = s[3];\\n        char startRow = s[1];\\n        char endRow = s[4];\\n        vector<string>ans;\\n        \\n        for(char a = startCol; a<=endCol; a++){\\n            for(char b = startRow; b<=endRow; b++){\\n                string sans = \"\";\\n                sans.push_back(a);\\n                sans.push_back(b);\\n                ans.push_back(sans);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char startCol = s[0];\\n        char endCol = s[3];\\n        char startRow = s[1];\\n        char endRow = s[4];\\n        vector<string>ans;\\n        \\n        for(char a = startCol; a<=endCol; a++){\\n            for(char b = startRow; b<=endRow; b++){\\n                string sans = \"\";\\n                sans.push_back(a);\\n                sans.push_back(b);\\n                ans.push_back(sans);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824868,
                "title": "c-code-single-loop",
                "content": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** cellsInRange(char * s, int* returnSize){\\n    //Get the values needed from the input\\n    int row_start = (s[1]-\\'0\\');\\n    int row_end = (s[4]-\\'0\\');\\n    int rows = (row_end - row_start) + 1;\\n    int cols = ((s[3] % 65) - (s[0] % 65)) + 1;\\n    int size = (rows * cols);\\n    //printf(\"row_start = %d | row_end = %d | rows = %d | cols = %d | size = %d\\\\n\", row_start, row_end, rows, cols, size);\\n    \\n    //Declare the resultant array and allocate memory\\n    char **result = (char**)malloc(sizeof(char*) * size);\\n    for(int i = 0; i < size; i++){\\n        result[i] = (char*)malloc(sizeof(char) * 3);\\n    }\\n    \\n    \\n    //Add elements to the resultant array\\n    char ch = s[0];\\n    int i = 0;\\n    while(i < size){\\n        for(int j = row_start; j <= row_end; j++){\\n            result[i][0] = ch;\\n            result[i][1] = \\'0\\' + j;\\n            result[i][2] = \\'\\\\0\\';\\n            //printf(\"result[%d][0] = %c | result[%d][1] = %c\\\\n\", i, result[i][0], i, result[i][1]);\\n            \\n            i++;\\n        }\\n        ch = ((ch % 65) + 1) + 65;\\n    }\\n    \\n    *returnSize = size;\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** cellsInRange(char * s, int* returnSize){\\n    //Get the values needed from the input\\n    int row_start = (s[1]-\\'0\\');\\n    int row_end = (s[4]-\\'0\\');\\n    int rows = (row_end - row_start) + 1;\\n    int cols = ((s[3] % 65) - (s[0] % 65)) + 1;\\n    int size = (rows * cols);\\n    //printf(\"row_start = %d | row_end = %d | rows = %d | cols = %d | size = %d\\\\n\", row_start, row_end, rows, cols, size);\\n    \\n    //Declare the resultant array and allocate memory\\n    char **result = (char**)malloc(sizeof(char*) * size);\\n    for(int i = 0; i < size; i++){\\n        result[i] = (char*)malloc(sizeof(char) * 3);\\n    }\\n    \\n    \\n    //Add elements to the resultant array\\n    char ch = s[0];\\n    int i = 0;\\n    while(i < size){\\n        for(int j = row_start; j <= row_end; j++){\\n            result[i][0] = ch;\\n            result[i][1] = \\'0\\' + j;\\n            result[i][2] = \\'\\\\0\\';\\n            //printf(\"result[%d][0] = %c | result[%d][1] = %c\\\\n\", i, result[i][0], i, result[i][1]);\\n            \\n            i++;\\n        }\\n        ch = ((ch % 65) + 1) + 65;\\n    }\\n    \\n    *returnSize = size;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823952,
                "title": "simple-easy-solution-c",
                "content": "\\tonly problem i am able to solve :(\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> cellsInRange(string s) {\\n\\t\\t\\tint r1 = s[1] -\\'0\\';\\n\\t\\t\\tint r2 = s[4] - \\'0\\';\\n\\n\\t\\t\\tint c1 = (s[0] - \\'A\\');\\n\\t\\t\\tint c2 = (s[3] - \\'A\\');\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tfor(int j = c1;j<=c2;j++){\\n\\t\\t\\tfor(int i = r1;i<=r2;i++){\\n\\n\\t\\t\\t\\t\\tchar ch =  j + \\'A\\';\\n\\n\\t\\t\\t\\t\\tans.push_back(ch + to_string(i));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> cellsInRange(string s) {\\n\\t\\t\\tint r1 = s[1] -\\'0\\';\\n\\t\\t\\tint r2 = s[4] - \\'0\\';\\n\\n\\t\\t\\tint c1 = (s[0] - \\'A\\');\\n\\t\\t\\tint c2 = (s[3] - \\'A\\');\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tfor(int j = c1;j<=c2;j++){\\n\\t\\t\\tfor(int i = r1;i<=r2;i++){\\n\\n\\t\\t\\t\\t\\tchar ch =  j + \\'A\\';\\n\\n\\t\\t\\t\\t\\tans.push_back(ch + to_string(i));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1823940,
                "title": "java-stringbuilder-100-optimal-faster-solution",
                "content": "```\\nclass Solution {\\n    public List < String > cellsInRange(String s) {\\n\\n        String[] str = s.split(\":\");\\n\\n        List < String > res = new ArrayList < > ();\\n        int a = Character.getNumericValue(str[0].charAt(1));\\n        int b = Character.getNumericValue(str[1].charAt(1));\\n        int c1 = str[0].charAt(0) - \\'A\\';\\n        int c2 = str[1].charAt(0) - \\'A\\';\\n\\n        for (int i = c1; i <= c2; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(Character.toString(i + 65));\\n            for (int j = a; j <= b; j++) {\\n                sb.append(j);\\n\\n                res.add(sb.toString());\\n\\n                sb = sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List < String > cellsInRange(String s) {\\n\\n        String[] str = s.split(\":\");\\n\\n        List < String > res = new ArrayList < > ();\\n        int a = Character.getNumericValue(str[0].charAt(1));\\n        int b = Character.getNumericValue(str[1].charAt(1));\\n        int c1 = str[0].charAt(0) - \\'A\\';\\n        int c2 = str[1].charAt(0) - \\'A\\';\\n\\n        for (int i = c1; i <= c2; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(Character.toString(i + 65));\\n            for (int j = a; j <= b; j++) {\\n                sb.append(j);\\n\\n                res.add(sb.toString());\\n\\n                sb = sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823641,
                "title": "c-clean-excel-cell-name-and-cell-number-easy",
                "content": "\\nSimilar question: [Excel sheet column title](https://leetcode.com/problems/excel-sheet-column-title/), [Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/)\\n\\nThis question was basically the combination of above two questions with some string processing\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    // calculate excel sheet column num from name\\n    int calNum(string s, int &p){\\n        int n = 1;\\n        while(p<s.size() && (s[p] >= \\'A\\') && (s[p] <=\\'Z\\')){\\n            n = (n-1)*26 + s[p] - \\'A\\' + 1;\\n            p++;\\n        }\\n        return n;\\n    }\\n    \\n    // calculate excel sheet row num from name\\n    int calNum2(string s, int &p){\\n        int n = 0;\\n        while(p<s.size() && (s[p] >= \\'0\\') && (s[p] <=\\'9\\')){\\n            n = n*10 + int(s[p] - \\'0\\');\\n            p++;\\n        }\\n        return n;\\n    }\\n    \\n    // calculate excel sheet cellName from column num and row num\\n    string calName(int i, int j){\\n        string s;\\n        while(i){\\n            s.push_back( (i-1)%26 + \\'A\\' );\\n            i = (i-1) / 26;\\n        }\\n        reverse(s.begin(), s.end());\\n        s += (to_string(j));\\n        return s;\\n    }\\n    \\n    vector<string> cellsInRange(string s) {\\n        \\n        int p = 0;                  // current position till where string is iterated\\n        int sx = calNum(s, p);      // starting cell column num\\n        int sy = calNum2(s, p);     // starting cell row num\\n         \\n        p++;                        // skipping \":\"\\n            \\n        int ex = calNum(s, p);      // ending cell column num\\n        int ey = calNum2(s, p);     // ending cell row num\\n        \\n        vector<string> ans;\\n        \\n        // iterate all cell and calculate it\\'s name\\n        for(int i=sx; i<=ex; i++)\\n            for(int j=sy; j<=ey; j++)\\n                ans.push_back(calName(i, j));\\n\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // calculate excel sheet column num from name\\n    int calNum(string s, int &p){\\n        int n = 1;\\n        while(p<s.size() && (s[p] >= \\'A\\') && (s[p] <=\\'Z\\')){\\n            n = (n-1)*26 + s[p] - \\'A\\' + 1;\\n            p++;\\n        }\\n        return n;\\n    }\\n    \\n    // calculate excel sheet row num from name\\n    int calNum2(string s, int &p){\\n        int n = 0;\\n        while(p<s.size() && (s[p] >= \\'0\\') && (s[p] <=\\'9\\')){\\n            n = n*10 + int(s[p] - \\'0\\');\\n            p++;\\n        }\\n        return n;\\n    }\\n    \\n    // calculate excel sheet cellName from column num and row num\\n    string calName(int i, int j){\\n        string s;\\n        while(i){\\n            s.push_back( (i-1)%26 + \\'A\\' );\\n            i = (i-1) / 26;\\n        }\\n        reverse(s.begin(), s.end());\\n        s += (to_string(j));\\n        return s;\\n    }\\n    \\n    vector<string> cellsInRange(string s) {\\n        \\n        int p = 0;                  // current position till where string is iterated\\n        int sx = calNum(s, p);      // starting cell column num\\n        int sy = calNum2(s, p);     // starting cell row num\\n         \\n        p++;                        // skipping \":\"\\n            \\n        int ex = calNum(s, p);      // ending cell column num\\n        int ey = calNum2(s, p);     // ending cell row num\\n        \\n        vector<string> ans;\\n        \\n        // iterate all cell and calculate it\\'s name\\n        for(int i=sx; i<=ex; i++)\\n            for(int j=sy; j<=ey; j++)\\n                ans.push_back(calName(i, j));\\n\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823610,
                "title": "beginner-friendly-python-solution",
                "content": "**Code:**\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        row1 = int(s[1])\\n        row2 = int(s[4])\\n        col1 = ord(s[0]) # To get their Unicode values\\n        col2 = ord(s[3]) # To get their Unicode values\\n        res = []\\n        # Since we are asked to sort the answer list first column and then row wise.\\n        for i in range(col1, col2+1):  \\n            for j in range(row1, row2+1):\\n                res.append(f\"{chr(i)}{j}\") # First column then row\\n        return res\\n```\\n**Code cramped into one line:**\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\"{chr(i)}{j}\" for i in range(ord(s[0]), ord(s[3])+1) for j in range(int(s[1]), int(s[4])+1)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        row1 = int(s[1])\\n        row2 = int(s[4])\\n        col1 = ord(s[0]) # To get their Unicode values\\n        col2 = ord(s[3]) # To get their Unicode values\\n        res = []\\n        # Since we are asked to sort the answer list first column and then row wise.\\n        for i in range(col1, col2+1):  \\n            for j in range(row1, row2+1):\\n                res.append(f\"{chr(i)}{j}\") # First column then row\\n        return res\\n```\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [f\"{chr(i)}{j}\" for i in range(ord(s[0]), ord(s[3])+1) for j in range(int(s[1]), int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870861,
                "title": "the-finest-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        k,k1,l=int(s[1]),int(s[4]),[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            for j in range(int(s[1]),int(s[4])+1):\\n                l1=\\'\\'\\n                l1+=chr(i)\\n                l1+=str(j)\\n                l.append(l1)\\n        return l\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        k,k1,l=int(s[1]),int(s[4]),[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            for j in range(int(s[1]),int(s[4])+1):\\n                l1=\\'\\'\\n                l1+=chr(i)\\n                l1+=str(j)\\n                l.append(l1)\\n        return l\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866788,
                "title": "java-solution-o-row-x-col-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple loop traversal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the initial and final row and column values in char variables.\\nLoop through each row using the ASCII value.\\nFor each row, loop through the columns and add as string to the list.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(row x col)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(row x col)\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n        \\n        char startRow = s.charAt(0);\\n        char startCol = s.charAt(1);\\n        char endRow = s.charAt(3);\\n        char endCol = s.charAt(4); \\n\\n        while(startRow <= endRow) {\\n            while(startCol <= endCol) {\\n                ans.add(startRow + \"\" + startCol);\\n                startCol++;\\n            }\\n            startCol = s.charAt(1);\\n            startRow++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n        \\n        char startRow = s.charAt(0);\\n        char startCol = s.charAt(1);\\n        char endRow = s.charAt(3);\\n        char endCol = s.charAt(4); \\n\\n        while(startRow <= endRow) {\\n            while(startCol <= endCol) {\\n                ans.add(startRow + \"\" + startCol);\\n                startCol++;\\n            }\\n            startCol = s.charAt(1);\\n            startRow++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518660,
                "title": "simple-java-solution-for-beginners-1ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> AL = new ArrayList();\\n        StringBuilder SB = new StringBuilder();\\n        char arr[] = s.toCharArray();\\n        for(char ch = arr[0]; ch <= arr[3]; ch = (char)(ch + 1)) {\\n            SB.append(ch);\\n            for(char num = arr[1]; num <= arr[4]; num++) {\\n                SB.append(num);\\n                AL.add(SB.toString());\\n                SB.deleteCharAt(1);\\n            }\\n            SB.deleteCharAt(0);\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> AL = new ArrayList();\\n        StringBuilder SB = new StringBuilder();\\n        char arr[] = s.toCharArray();\\n        for(char ch = arr[0]; ch <= arr[3]; ch = (char)(ch + 1)) {\\n            SB.append(ch);\\n            for(char num = arr[1]; num <= arr[4]; num++) {\\n                SB.append(num);\\n                AL.add(SB.toString());\\n                SB.deleteCharAt(1);\\n            }\\n            SB.deleteCharAt(0);\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518625,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char first = s.charAt(0);\\n        int begin = s.charAt(1) - \\'0\\';\\n        char last = s.charAt(3);\\n        int end = s.charAt(4) - \\'0\\';\\n        List<String> AL = new ArrayList();\\n        for(char c = first; c <= last;) {\\n            for(int i = begin; i <= end; i++) {\\n                AL.add(c+\"\"+i);\\n            }\\n            c = (char)(c + 1);\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char first = s.charAt(0);\\n        int begin = s.charAt(1) - \\'0\\';\\n        char last = s.charAt(3);\\n        int end = s.charAt(4) - \\'0\\';\\n        List<String> AL = new ArrayList();\\n        for(char c = first; c <= last;) {\\n            for(int i = begin; i <= end; i++) {\\n                AL.add(c+\"\"+i);\\n            }\\n            c = (char)(c + 1);\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404209,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun cellsInRange(s: String): List<String> {\\n        val arr = ArrayList<String>()\\n        for (row in s[0]..s[3]) {\\n            for (col in s[1]..s[4]) arr.add(\"$row$col\")\\n        }\\n        return arr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun cellsInRange(s: String): List<String> {\\n        val arr = ArrayList<String>()\\n        for (row in s[0]..s[3]) {\\n            for (col in s[1]..s[4]) arr.add(\"$row$col\")\\n        }\\n        return arr\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130153,
                "title": "simple-and-easy-to-understand-solution-in-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Created a result vector to store and return the result.\\n2) Since numbers are present at the 1st and 4th index of the string, stored the numbers into another variables known as no1 and no2.\\n3) Stored the both characters into variables called a and b.\\n4) Created two variables max_n and min_n to store maximum and minimum of both the numbers in respective variables.\\n5) Iterated from a to b in external loop and iterated from min_n to max_n in the internal loop.\\n6) Kept concatenating and adding the string into result vector.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        int no1 = s[1]-\\'0\\', no2 = s[4]-\\'0\\', max_n, min_n;\\n        char a = s[0], b = s[3];\\n\\n        max_n = max(no1,no2);\\n        min_n = min(no1,no2);\\n\\n        char j = a;\\n        while(j <= b){\\n            int i = min_n;\\n            while(i <= max_n){\\n                result.push_back(j+to_string(i));\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        int no1 = s[1]-\\'0\\', no2 = s[4]-\\'0\\', max_n, min_n;\\n        char a = s[0], b = s[3];\\n\\n        max_n = max(no1,no2);\\n        min_n = min(no1,no2);\\n\\n        char j = a;\\n        while(j <= b){\\n            int i = min_n;\\n            while(i <= max_n){\\n                result.push_back(j+to_string(i));\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953730,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** cellsInRange(char * s, int* returnSize){\\n    *returnSize = ((s[3]-s[0])+1) * ((s[4]-s[1])+1);\\n    char** ret = (char*)calloc(*returnSize , sizeof(char*)); // create array of strings\\n    int i , index = 0 , j ;\\n    for(i = s[0] ; i <= s[3] ; i++)\\n    {\\n        for(j = s[1] ; j <= s[4] ; j++)\\n        {\\n            ret[index] =(char*)calloc(3 , sizeof(char));\\n            ret[index][0] = i;\\n            ret[index][1] = j;\\n            ret[index][2] = \\'\\\\0\\';\\n            index++;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** cellsInRange(char * s, int* returnSize){\\n    *returnSize = ((s[3]-s[0])+1) * ((s[4]-s[1])+1);\\n    char** ret = (char*)calloc(*returnSize , sizeof(char*)); // create array of strings\\n    int i , index = 0 , j ;\\n    for(i = s[0] ; i <= s[3] ; i++)\\n    {\\n        for(j = s[1] ; j <= s[4] ; j++)\\n        {\\n            ret[index] =(char*)calloc(3 , sizeof(char));\\n            ret[index][0] = i;\\n            ret[index][1] = j;\\n            ret[index][2] = \\'\\\\0\\';\\n            index++;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2922922,
                "title": "java-time-o-col1-col2-row1-row2-space-o-col1-col2-row1-row2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s an easy problem just need patience.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExtract the range of column and row, then start adding it to list storing the cells.\\n\\n# Complexity\\n- Time complexity: O( |col1-col2| * |row1-row2| )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( |col1-col2| * |row1-row2| )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> cells = new ArrayList<>();\\n        char col1 = s.charAt(0);\\n        char col2 = s.charAt(3);\\n        int row1 = Integer.valueOf(String.valueOf(s.charAt(1)));\\n        int row2 = Integer.valueOf(String.valueOf(s.charAt(4)));\\n        for(int i=(int)col1;i<=(int)col2;i++){\\n            for(int j=row1;j<=row2;j++){\\n                cells.add(String.valueOf((char)i) + String.valueOf(j));\\n            }\\n        }\\n        return cells;\\n    }\\n    // Time Complexity : O(|col1-col2| * |row1-row2|)\\n    // Space Complexity : O(|col1-col2| * |row1-row2|)\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> cells = new ArrayList<>();\\n        char col1 = s.charAt(0);\\n        char col2 = s.charAt(3);\\n        int row1 = Integer.valueOf(String.valueOf(s.charAt(1)));\\n        int row2 = Integer.valueOf(String.valueOf(s.charAt(4)));\\n        for(int i=(int)col1;i<=(int)col2;i++){\\n            for(int j=row1;j<=row2;j++){\\n                cells.add(String.valueOf((char)i) + String.valueOf(j));\\n            }\\n        }\\n        return cells;\\n    }\\n    // Time Complexity : O(|col1-col2| * |row1-row2|)\\n    // Space Complexity : O(|col1-col2| * |row1-row2|)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859321,
                "title": "2-line-code-simple-and-naive-approach",
                "content": "# Intuition\\n2 line Code\\n# Approach\\nSimple and Naive Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nwe used list as its already said to use\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n   List<String> list=new ArrayList<String>();  \\n   for(char i=s.charAt(0);i<=s.charAt(3);i++) \\n   {  \\n       for(char j=s.charAt(1);j<=s.charAt(4);j++)\\n      {   \\n          list.add(\"\"+i+j);\\n }}\\n   return list;  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n   List<String> list=new ArrayList<String>();  \\n   for(char i=s.charAt(0);i<=s.charAt(3);i++) \\n   {  \\n       for(char j=s.charAt(1);j<=s.charAt(4);j++)\\n      {   \\n          list.add(\"\"+i+j);\\n }}\\n   return list;  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851693,
                "title": "javascript-easy-to-understand-solution-beats-97",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nconst cellsInRange = function(s) {\\n   let parts = s.split(\":\");///get the rows and columns\\n   let cols = [];\\n   let rows = [];\\n   let answer = [];\\n\\n    for (let i = 0; i < parts.length; i++) {//turn strings to ascii numbers\\n        cols.push(parts[i][0].charCodeAt(0));\\n        rows.push(parts[i][1].charCodeAt(0));\\n    }\\n\\n    ///set two loops for the range of rows and columns according to ascii codes\\n    for (let i = Math.min(...cols); i <= Math.max(...cols) ; i++) {\\n        for (let j = Math.min(...rows); j <= Math.max(...rows); j++) {\\n            let element = \"\";\\n            element += (String.fromCharCode(i));///add column\\n            element += (String.fromCharCode(j));///add row\\n            answer.push(element);\\n        }\\n    }\\n\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nconst cellsInRange = function(s) {\\n   let parts = s.split(\":\");///get the rows and columns\\n   let cols = [];\\n   let rows = [];\\n   let answer = [];\\n\\n    for (let i = 0; i < parts.length; i++) {//turn strings to ascii numbers\\n        cols.push(parts[i][0].charCodeAt(0));\\n        rows.push(parts[i][1].charCodeAt(0));\\n    }\\n\\n    ///set two loops for the range of rows and columns according to ascii codes\\n    for (let i = Math.min(...cols); i <= Math.max(...cols) ; i++) {\\n        for (let j = Math.min(...rows); j <= Math.max(...rows); j++) {\\n            let element = \"\";\\n            element += (String.fromCharCode(i));///add column\\n            element += (String.fromCharCode(j));///add row\\n            answer.push(element);\\n        }\\n    }\\n\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2762746,
                "title": "typescript-clean-solution",
                "content": "```\\nfunction cellsInRange(s: string): string[] {\\n  const colStart = s[0].charCodeAt(0);\\n  const rowStart = +s[1];\\n  const colEnd = s[3].charCodeAt(0);\\n  const rowEnd = +s[4];\\n\\n  const cells: string[] = [];\\n  for (let col = colStart; col <= colEnd; col++) {\\n    for (let row = rowStart; row <= rowEnd; row++) {\\n      cells.push(String.fromCharCode(col) + row);\\n    }\\n  }\\n  return cells;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cellsInRange(s: string): string[] {\\n  const colStart = s[0].charCodeAt(0);\\n  const rowStart = +s[1];\\n  const colEnd = s[3].charCodeAt(0);\\n  const rowEnd = +s[4];\\n\\n  const cells: string[] = [];\\n  for (let col = colStart; col <= colEnd; col++) {\\n    for (let row = rowStart; row <= rowEnd; row++) {\\n      cells.push(String.fromCharCode(col) + row);\\n    }\\n  }\\n  return cells;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2737276,
                "title": "simple-c-solution-using-nested-for-loops",
                "content": "# Intuition\\nThe idea here is that C# allows you to manipulate char like a numeric value so you can use a `for` loop to allow you to iterate between a known start and end.\\n\\nThe problem space defines itself that the range will always be `lower:higher`. As a result we can make several assumptions\\n\\n# Approach\\nBasically we are always given a string that is `start:stop`. Splitting on the semi-colon will give us an array where we have start and finish.\\n\\n\\nThis code example starts with the columns and walks the columns first, then determines the appropriate rows afterwards. Remember, we are guaranteed that the row counts will not decrease.\\n\\nSo we can walk the columns like so:\\n\\n```\\nfor (var cStart = start[0]; cStart <= end[0]; cStart++)\\n```\\n\\nLet\\'s define an arbitrary example where the input string is `A1:B2`.\\nIn that case `cStart` will begin with `A` and the `for` loop will walk it to `B` inclusive.\\n\\nThen we can walk the rows fairly easily using a virtually identical setup:\\n```\\nfor (var rStart = start[1]; rStart <= end[1]; rStart++)\\n```\\n`rStart` will be `1` and the for loop will increment us to `2` before halting. Again, this is due to how chars are treated in C#. We can manipulate them as if they were numbers without any problems.\\n\\n\\n# Code\\n```\\npublic class Solution\\n{\\n\\tpublic IList<string> CellsInRange(string s)\\n\\t{\\n\\t\\tvar list = new List<string>();\\n\\t\\tvar range = s.Split(\\':\\');\\n\\t\\tvar start = range[0];\\n\\t\\tvar end = range[1];\\n\\t\\tfor (var cStart = start[0]; cStart <= end[0]; cStart++)\\n\\t\\t{\\n\\t\\t\\tfor (var rStart = start[1]; rStart <= end[1]; rStart++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlist.Add($\"{cStart}{rStart}\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```\\n\\nThere\\'s probably more efficient solutions for this one but this one felt the most straight-forward and simple to implement.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nfor (var cStart = start[0]; cStart <= end[0]; cStart++)\\n```\n```\\nfor (var rStart = start[1]; rStart <= end[1]; rStart++)\\n```\n```\\npublic class Solution\\n{\\n\\tpublic IList<string> CellsInRange(string s)\\n\\t{\\n\\t\\tvar list = new List<string>();\\n\\t\\tvar range = s.Split(\\':\\');\\n\\t\\tvar start = range[0];\\n\\t\\tvar end = range[1];\\n\\t\\tfor (var cStart = start[0]; cStart <= end[0]; cStart++)\\n\\t\\t{\\n\\t\\t\\tfor (var rStart = start[1]; rStart <= end[1]; rStart++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlist.Add($\"{cStart}{rStart}\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563404,
                "title": "javascript-solution",
                "content": "function cellsInRange(s: string): string[] {\\n\\n  //s //K1:L2\\n\\n  const result = [];\\n  const d = []\\n  const alphabets = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\\n  let idx = 0;\\n\\n\\n  //[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t]\\n\\n  // check if they are adjacent \\n  // check if the frequency is more then one\\n  // then run the loop of the largest char frequency\\n\\n  let charOneIndex = alphabets.indexOf(s.charAt(0))\\n  let charTwoIndex = alphabets.indexOf(s.charAt(3))\\n  let largest = Number(s.charAt(4))\\n\\n  if (Number(s.charAt(1)) > 1) {\\n    idx = Number(s.charAt(4)) - Number(s.charAt(1));\\n  }\\n\\n  while (charOneIndex <= charTwoIndex) {\\n    result.push(`${alphabets[charOneIndex]}`)\\n    charOneIndex++\\n  }\\n\\n\\n\\n  if (Number(s.charAt(4)) === 1 && Number(s.charAt(1)) === 1) {\\n    for (let i = idx; i < result.length; i++) {\\n      result[i] = result[i] + \"1\"\\n    }\\n  } else {\\n     for (let i = 0; i < result.length; i++) {\\n       for (let y = Number(s.charAt(1)); y <= largest; y++) {\\n         d.push(`${result[i]}${y}`)\\n       }\\n     \\n     } \\n\\n  }\\n\\n  if (Number(s.charAt(4)) === 1) {\\n    return result\\n  } else {\\n    return d\\n  }\\n\\n\\n\\n};",
                "solutionTags": [],
                "code": "function cellsInRange(s: string): string[] {\\n\\n  //s //K1:L2\\n\\n  const result = [];\\n  const d = []\\n  const alphabets = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\\n  let idx = 0;\\n\\n\\n  //[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t]\\n\\n  // check if they are adjacent \\n  // check if the frequency is more then one\\n  // then run the loop of the largest char frequency\\n\\n  let charOneIndex = alphabets.indexOf(s.charAt(0))\\n  let charTwoIndex = alphabets.indexOf(s.charAt(3))\\n  let largest = Number(s.charAt(4))\\n\\n  if (Number(s.charAt(1)) > 1) {\\n    idx = Number(s.charAt(4)) - Number(s.charAt(1));\\n  }\\n\\n  while (charOneIndex <= charTwoIndex) {\\n    result.push(`${alphabets[charOneIndex]}`)\\n    charOneIndex++\\n  }\\n\\n\\n\\n  if (Number(s.charAt(4)) === 1 && Number(s.charAt(1)) === 1) {\\n    for (let i = idx; i < result.length; i++) {\\n      result[i] = result[i] + \"1\"\\n    }\\n  } else {\\n     for (let i = 0; i < result.length; i++) {\\n       for (let y = Number(s.charAt(1)); y <= largest; y++) {\\n         d.push(`${result[i]}${y}`)\\n       }\\n     \\n     } \\n\\n  }\\n\\n  if (Number(s.charAt(4)) === 1) {\\n    return result\\n  } else {\\n    return d\\n  }\\n\\n\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2492026,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> res = new ArrayList<>();\\n        char[] cs = s.toCharArray();\\n        for (char i = cs[0]; i <= cs[3]; i++) {\\n            for (char j = cs[1]; j <= cs[4]; j++) {\\n                res.add(new String(new char[]{i, j}));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> res = new ArrayList<>();\\n        char[] cs = s.toCharArray();\\n        for (char i = cs[0]; i <= cs[3]; i++) {\\n            for (char j = cs[1]; j <= cs[4]; j++) {\\n                res.add(new String(new char[]{i, j}));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490314,
                "title": "samir-easy-two-loops-with-explanation",
                "content": "# Please Upvote\\n<hr>\\n\\n* The startIndex is for the row of the cell as K1 (1 -> startIndex)\\n* similarly endIndex is for the last row till which we will iterate L2 (2 -> endIndex)\\n* startChar is for the column of the cell like K1 (K -> startChar)\\n* endChar is for the column till which we\\'ll be iterating like L2 (L -> endChar)\\n\\n<hr> \\n\\n## Code :- \\n\\n```\\n\\t\\tint startIndex = Integer.parseInt(Character.toString(s.charAt(1)));\\n        int endIndex = Integer.parseInt(Character.toString(s.charAt(4)));\\n        int startChar = (int)s.charAt(0);\\n        int endChar = (int)s.charAt(3);\\n        List<String> ans = new ArrayList<>();\\n        for(int i = startChar; i <= endChar; i++){\\n            for(int j = startIndex; j <= endIndex; j++){\\n                String ss = Character.toString((char)i);\\n                ss += Integer.toString(j);\\n                ans.add(ss);\\n            }\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint startIndex = Integer.parseInt(Character.toString(s.charAt(1)));\\n        int endIndex = Integer.parseInt(Character.toString(s.charAt(4)));\\n        int startChar = (int)s.charAt(0);\\n        int endChar = (int)s.charAt(3);\\n        List<String> ans = new ArrayList<>();\\n        for(int i = startChar; i <= endChar; i++){\\n            for(int j = startIndex; j <= endIndex; j++){\\n                String ss = Character.toString((char)i);\\n                ss += Integer.toString(j);\\n                ans.add(ss);\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2469317,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:                \\n        ans = []\\n        for i in range(ord(s[0]), ord(s[3])+1):\\n                \\n                for j in range(int(s[1]),int(s[4])+1):\\n                    ans.append(\"{}{}\".format(chr(i),j))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:                \\n        ans = []\\n        for i in range(ord(s[0]), ord(s[3])+1):\\n                \\n                for j in range(int(s[1]),int(s[4])+1):\\n                    ans.append(\"{}{}\".format(chr(i),j))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461740,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list = new ArrayList<>();\\n\\n        int f = Character.getNumericValue(s.charAt(1)),\\n                l = Character.getNumericValue(s.charAt(s.length() - 1));\\n        char c_f = s.charAt(0), c_s = s.charAt(s.length() - 2);\\n        for (char c = c_f; c <= c_s; c++) {\\n            for (int i = f; i <= l; i++) {\\n                list.add(String.valueOf(c) + i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list = new ArrayList<>();\\n\\n        int f = Character.getNumericValue(s.charAt(1)),\\n                l = Character.getNumericValue(s.charAt(s.length() - 1));\\n        char c_f = s.charAt(0), c_s = s.charAt(s.length() - 2);\\n        for (char c = c_f; c <= c_s; c++) {\\n            for (int i = f; i <= l; i++) {\\n                list.add(String.valueOf(c) + i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451019,
                "title": "0ms-straightforward",
                "content": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let c = s.as_bytes();\\n        let mut ans: Vec<String> = Vec::with_capacity(10);\\n        for col in c[0]..=c[3] {\\n            for row in c[1]..=c[4] {\\n                ans.push(format!(\"{}{}\",col as char, row as char));\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let c = s.as_bytes();\\n        let mut ans: Vec<String> = Vec::with_capacity(10);\\n        for col in c[0]..=c[3] {\\n            for row in c[1]..=c[4] {\\n                ans.push(format!(\"{}{}\",col as char, row as char));\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2348383,
                "title": "python-easy-and-clean",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(i)+str(j) for i in range(ord(s[0]), ord(s[3])+1) for j in range(int(s[1]), int(s[4])+1)]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(i)+str(j) for i in range(ord(s[0]), ord(s[3])+1) for j in range(int(s[1]), int(s[4])+1)]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2334942,
                "title": "simple-python-solution-in-one-line-with-explanation",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res=\\'\\'\\n        li=[]\\n        str1=\"\"\\n\\t\\t#initialization of variables\\n        s1=\\'\\'\\n        s2=\\'\\'\\n        a=0\\n        b=0\\n        s1=ord(s[0]) #1st char ascii value\\n        a=int(s[1]) #2nd char int value\\n        s2=ord(s[3])\\n        b=int(s[4])\\n        #print(s1,a,s2,b)\\n        return [chr(i)+ str(j) for i in range(s1,s2+1) for j in range(a,b+1)]\\n\\t\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res=\\'\\'\\n        li=[]\\n        str1=\"\"\\n\\t\\t#initialization of variables\\n        s1=\\'\\'\\n        s2=\\'\\'\\n        a=0\\n        b=0\\n        s1=ord(s[0]) #1st char ascii value\\n        a=int(s[1]) #2nd char int value\\n        s2=ord(s[3])\\n        b=int(s[4])\\n        #print(s1,a,s2,b)\\n        return [chr(i)+ str(j) for i in range(s1,s2+1) for j in range(a,b+1)]\\n\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331632,
                "title": "java-easy-4-line-code",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> result = new ArrayList<>();\\n        for (char letter=s.charAt(0);letter<=s.charAt(3);letter++){\\n            for (char digit=s.charAt(1);digit<=s.charAt(4);digit++){\\n                result.add(letter+\"\"+digit);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nfor any queries comment down and if you like this solution then upvote",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> result = new ArrayList<>();\\n        for (char letter=s.charAt(0);letter<=s.charAt(3);letter++){\\n            for (char digit=s.charAt(1);digit<=s.charAt(4);digit++){\\n                result.add(letter+\"\"+digit);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329490,
                "title": "using-flatmap-in-kotlin",
                "content": "```kotlin\\nclass Solution {\\n    fun cellsInRange(s: String): List<String> =\\n        s.split(\":\").flatMap { it.toList() }\\n            .let { (startCol, startRow, endCol, endRow) ->\\n                (startCol..endCol).flatMap { col ->\\n                    (startRow..endRow).map { row -> \"$col$row\" }\\n                }\\n            }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun cellsInRange(s: String): List<String> =\\n        s.split(\":\").flatMap { it.toList() }\\n            .let { (startCol, startRow, endCol, endRow) ->\\n                (startCol..endCol).flatMap { col ->\\n                    (startRow..endRow).map { row -> \"$col$row\" }\\n                }\\n            }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295630,
                "title": "python3-one-liner-solution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(j)+str(i) for j in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1) ]\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(j)+str(i) for j in range(ord(s[0]), ord(s[3])+1) for i in range(int(s[1]), int(s[4])+1) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291419,
                "title": "java-solution-faster-than-100-00-and-runtime-1-ms",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {        \\n        List<String> list = new ArrayList<>();\\n        \\n        int col1 = s.charAt(0); // A\\n        int row1 = s.charAt(1); // 1\\n        \\n        int col2 = s.charAt(3); // F\\n        int row2 = s.charAt(4); // 1\\n        \\n        for(int j = col1; j <= col2; j++) {\\n            for(int i = row1; i <= row2; i++) {\\n                StringBuffer sb = new StringBuffer();\\n                \\n                sb.append((char)j); // A\\n                sb.append((char)i); // 1\\n                \\n                list.add(sb.toString()); // A1\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {        \\n        List<String> list = new ArrayList<>();\\n        \\n        int col1 = s.charAt(0); // A\\n        int row1 = s.charAt(1); // 1\\n        \\n        int col2 = s.charAt(3); // F\\n        int row2 = s.charAt(4); // 1\\n        \\n        for(int j = col1; j <= col2; j++) {\\n            for(int i = row1; i <= row2; i++) {\\n                StringBuffer sb = new StringBuffer();\\n                \\n                sb.append((char)j); // A\\n                sb.append((char)i); // 1\\n                \\n                list.add(sb.toString()); // A1\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286524,
                "title": "ruby-ascii-loop-solution",
                "content": "\\n```ruby\\ndef cells_in_range(s)\\n    chars = s.split(\"\")\\n\\n    result = []\\n    (chars[0].sum..chars[3].sum).each do |item|\\n        (chars[1].to_i..chars.last.to_i).each do |i|\\n            result << \"#{item.chr}#{i}\"\\n        end\\n    end\\n\\n    result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef cells_in_range(s)\\n    chars = s.split(\"\")\\n\\n    result = []\\n    (chars[0].sum..chars[3].sum).each do |item|\\n        (chars[1].to_i..chars.last.to_i).each do |i|\\n            result << \"#{item.chr}#{i}\"\\n        end\\n    end\\n\\n    result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2225711,
                "title": "easy-to-understand-solution",
                "content": "**Problem**: \\nWe have to return a vector containing cells from range x to y. For this, we would need to iterate from column col1 to col2 and for each iteration, iterate over rows from row1 to row2 (all inclusive).\\n\\n**Approach**:\\nWe know that the string given to us in the format: [col1][row1]:[col2][row2]\\nso, s[0] will contain the value col1, s[1] will contain row1, s[2] would be a colon(:), s[3] will contain col2, and s[4] will contain row2.\\nSo, we need to run an iteration from s[0] till s[3]. And for each iteration, iterate from s[1] to s[4], and hence, add values in the format: [column][row] to a string and insert the string to the vector.\\n\\n**Solution**:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans; //vector in which we would store our result\\n        for(char column=s[0];column<=s[3];column++) //iterating over columns from col1 to col2\\n        {\\n            for(int row=s[1]-\\'0\\';row<=s[4]-\\'0\\';row++) //iterating over rows from row1 to row2\\n            {\\n                string current=\"\"; // we take an empty string for the cell\\n                current+=column; // add the column to the string\\n                current+=to_string(row); // add the row number in form of string to the string\\n                ans.push_back(current); // push the string to the vector\\n            }\\n        }\\n        return ans; // return the vector\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans; //vector in which we would store our result\\n        for(char column=s[0];column<=s[3];column++) //iterating over columns from col1 to col2\\n        {\\n            for(int row=s[1]-\\'0\\';row<=s[4]-\\'0\\';row++) //iterating over rows from row1 to row2\\n            {\\n                string current=\"\"; // we take an empty string for the cell\\n                current+=column; // add the column to the string\\n                current+=to_string(row); // add the row number in form of string to the string\\n                ans.push_back(current); // push the string to the vector\\n            }\\n        }\\n        return ans; // return the vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160205,
                "title": "java-simple",
                "content": ">**T/S:** O(mn)/O(1), where m = number of rows, n = number of columns. Actually it\\'ll be O(1)\\n```\\npublic List<String> cellsInRange(String s) {\\n\\tvar cells = new ArrayList<String>();\\n\\t\\n\\tfor (var i = s.charAt(0); i <= s.charAt(3); i++)\\n\\t\\tfor (var j = s.charAt(1); j <= s.charAt(4); j++)\\n\\t\\t\\tcells.add(i + \"\" + j);\\n\\treturn cells;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> cellsInRange(String s) {\\n\\tvar cells = new ArrayList<String>();\\n\\t\\n\\tfor (var i = s.charAt(0); i <= s.charAt(3); i++)\\n\\t\\tfor (var j = s.charAt(1); j <= s.charAt(4); j++)\\n\\t\\t\\tcells.add(i + \"\" + j);\\n\\treturn cells;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2090950,
                "title": "swift-ascii-play",
                "content": "```\\nimport Foundation\\nclass Solution {\\n    func cellsInRange(_ s: String) -> [String] {\\n\\n        let arr = Array(s)\\n        let s0 = arr[0].unicodeScalars.first!.value\\n        let s3 = arr[3].unicodeScalars.first!.value\\n        \\n        let s1 = Int(\"\\\\(arr[1])\")!\\n        let s4 = Int(\"\\\\(arr[4])\")!\\n        \\n        var op: [String] = []\\n        for i in s0...s3 {\\n            for j in s1...s4 {\\n                op.append(\"\\\\(Character(UnicodeScalar(i)!))\\\\(j)\")\\n            }\\n        }\\n        \\n        return op\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nimport Foundation\\nclass Solution {\\n    func cellsInRange(_ s: String) -> [String] {\\n\\n        let arr = Array(s)\\n        let s0 = arr[0].unicodeScalars.first!.value\\n        let s3 = arr[3].unicodeScalars.first!.value\\n        \\n        let s1 = Int(\"\\\\(arr[1])\")!\\n        let s4 = Int(\"\\\\(arr[4])\")!\\n        \\n        var op: [String] = []\\n        for i in s0...s3 {\\n            for j in s1...s4 {\\n                op.append(\"\\\\(Character(UnicodeScalar(i)!))\\\\(j)\")\\n            }\\n        }\\n        \\n        return op\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073029,
                "title": "88-or-100-solution-in-java-easy-understand",
                "content": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n     //     88 % m/s solution\\n        char [] c=s.toCharArray();\\n       List<String> str= new ArrayList<>();\\n        \\n        \\n        for(char i=c[0];i<=c[3];i++){\\n             for(char j=c[1];j<=c[4];j++){\\n             str.add(new String(new char[]{i, j}));\\n            \\n        }\\n            \\n        }\\n         return str;  \\n        \\n        // second solution 100%\\n        \\n//            char sc = s.charAt(0), ec = s.charAt(3);\\n//         char sr = s.charAt(1), er = s.charAt(4);\\n//         List<String> res = new ArrayList<>();\\n        \\n//         for (char i = sc; i <= ec; ++i){\\n//             for (char j = sr; j <= er; ++j){\\n//                 res.add(new String(new char[]{i, j}));\\n//             }\\n//         }\\n        \\n//         return res;\\n    }\\n}\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n     //     88 % m/s solution\\n        char [] c=s.toCharArray();\\n       List<String> str= new ArrayList<>();\\n        \\n        \\n        for(char i=c[0];i<=c[3];i++){\\n             for(char j=c[1];j<=c[4];j++){\\n             str.add(new String(new char[]{i, j}",
                "codeTag": "Java"
            },
            {
                "id": 2010653,
                "title": "cells-in-a-range-on-an-excel-sheet-python3-easy",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        excel_row_start , excel_row_end = int(s[1]) , int(s[4])\\n        excel_column_start , excel_column_end = s[0], s[3]\\n        result = list()\\n        for col in range(ord(excel_column_start), ord(excel_column_end)+1):\\n            for row in range(excel_row_start , excel_row_end+1):\\n                result.append(chr(col)+str(row))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        excel_row_start , excel_row_end = int(s[1]) , int(s[4])\\n        excel_column_start , excel_column_end = s[0], s[3]\\n        result = list()\\n        for col in range(ord(excel_column_start), ord(excel_column_end)+1):\\n            for row in range(excel_row_start , excel_row_end+1):\\n                result.append(chr(col)+str(row))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972939,
                "title": "c-solution-0ms-faster-than-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Cells in a Range on an Excel Sheet.\\nMemory Usage: 7.9 MB, less than 19.65% of C++ online submissions for Cells in a Range on an Excel Sheet.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    vector<string> cellsInRange(const string& s) \\n    {\\n        std::vector<std::string> res;\\n        for (char col = s[0]; col <= s[3]; col++)\\n        {\\n            for (char row = s[1]; row <= s[4]; row++)\\n            {\\n                std::string temp;\\n                temp += col;\\n                temp += row;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<string> cellsInRange(const string& s) \\n    {\\n        std::vector<std::string> res;\\n        for (char col = s[0]; col <= s[3]; col++)\\n        {\\n            for (char row = s[1]; row <= s[4]; row++)\\n            {\\n                std::string temp;\\n                temp += col;\\n                temp += row;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967286,
                "title": "kotlin",
                "content": "```\\nfun cellsInRange(s: String) = mutableListOf<String>().apply {\\n    (s.first()..s[3]).forEach {\\n        for (i in Character.getNumericValue(s[1])..Character.getNumericValue(s.last())) {\\n            add(\"$it$i\")\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun cellsInRange(s: String) = mutableListOf<String>().apply {\\n    (s.first()..s[3]).forEach {\\n        for (i in Character.getNumericValue(s[1])..Character.getNumericValue(s.last())) {\\n            add(\"$it$i\")\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1965664,
                "title": "c-straightforward-solution",
                "content": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        List<string> res = new();\\n        char c1 = s.Split(\\':\\')[0][0];\\n        char c2 = s.Split(\\':\\')[1][0];\\n        int n1 = Convert.ToInt32(s.Split(\\':\\')[0][1])-\\'0\\';\\n        int n2 = Convert.ToInt32(s.Split(\\':\\')[1][1])-\\'0\\';\\n        for(int i=c1-\\'A\\'; i<=c2-\\'A\\'; i++)\\n        {\\n            for(int j=n1; j<=n2; j++)\\n            {\\n                res.Add(Convert.ToChar(\\'A\\'+i)+j.ToString());\\n            }\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n        List<string> res = new();\\n        char c1 = s.Split(\\':\\')[0][0];\\n        char c2 = s.Split(\\':\\')[1][0];\\n        int n1 = Convert.ToInt32(s.Split(\\':\\')[0][1])-\\'0\\';\\n        int n2 = Convert.ToInt32(s.Split(\\':\\')[1][1])-\\'0\\';\\n        for(int i=c1-\\'A\\'; i<=c2-\\'A\\'; i++)\\n        {\\n            for(int j=n1; j<=n2; j++)\\n            {\\n                res.Add(Convert.ToChar(\\'A\\'+i)+j.ToString());\\n            }\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944120,
                "title": "python-olution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        v = []\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            for j in range(int(s[1]),int(s[4])+1):\\n                v.append(chr(i)+str(j))\\n        return v\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        v = []\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            for j in range(int(s[1]),int(s[4])+1):\\n                v.append(chr(i)+str(j))\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938601,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {String} s\\n# @return {String[]}\\ndef cells_in_range(s)\\n  (s[0]..s[3]).to_a.product((s[1]..s[4]).to_a).map(&:join)  \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @return {String[]}\\ndef cells_in_range(s)\\n  (s[0]..s[3]).to_a.product((s[1]..s[4]).to_a).map(&:join)  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1937740,
                "title": "python-using-for-loops-faster-than-94",
                "content": "![image](https://assets.leetcode.com/users/images/fbf77fdd-8049-4de9-84dc-9ec5962516d9_1649721022.8458278.png)\\n\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        \\n        res = []\\n        for letter in range(ord(s[0]), ord(s[3]) + 1, 1):\\n            for i in range(int(s[1]), int(s[-1]) + 1):\\n                res.append(chr(letter) + str(i))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        \\n        res = []\\n        for letter in range(ord(s[0]), ord(s[3]) + 1, 1):\\n            for i in range(int(s[1]), int(s[-1]) + 1):\\n                res.append(chr(letter) + str(i))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935658,
                "title": "easy-and-simple-solution-using-for-statement",
                "content": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n            IList<string> cells = new List<string>();\\n            int cs = Convert.ToInt32(s[1].ToString());\\n            int ce = Convert.ToInt32(s[4].ToString());\\n            char rs = s[0];\\n            char re = s[3];\\n               \\n            for(char j = rs; j <= re; j++) for(int i = cs; i <= ce; i++) cells.Add(j.ToString()+i.ToString());\\n            return cells;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s) {\\n            IList<string> cells = new List<string>();\\n            int cs = Convert.ToInt32(s[1].ToString());\\n            int ce = Convert.ToInt32(s[4].ToString());\\n            char rs = s[0];\\n            char re = s[3];\\n               \\n            for(char j = rs; j <= re; j++) for(int i = cs; i <= ce; i++) cells.Add(j.ToString()+i.ToString());\\n            return cells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918719,
                "title": "simple-python3-solution",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1, r1, c2, r2 = s[0], s[1], s[3], s[4]\\n        result = []\\n        for col in range(ord(c1), ord(c2) + 1):\\n            for row in range(ord(r1), ord(r2) + 1):\\n                result.append(f\"{chr(col)}{chr(row)}\")\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        c1, r1, c2, r2 = s[0], s[1], s[3], s[4]\\n        result = []\\n        for col in range(ord(c1), ord(c2) + 1):\\n            for row in range(ord(r1), ord(r2) + 1):\\n                result.append(f\"{chr(col)}{chr(row)}\")\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905642,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> res;\\n        for (char i = s[0]; i <= s[3]; i++)\\n        {\\n            for (char j = s[1]; j <= s[4]; j++)\\n            {\\n                res.push_back({i,j});\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> res;\\n        for (char i = s[0]; i <= s[3]; i++)\\n        {\\n            for (char j = s[1]; j <= s[4]; j++)\\n            {\\n                res.push_back({i,j});\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885193,
                "title": "rust-simple-two-loops",
                "content": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let mut ans = Vec::new();\\n        let s: Vec<char> = s.chars().collect();\\n        for i in s[0]..=s[3] {\\n            for j in s[1]..=s[4] {\\n                ans.push(format!(\"{}{}\", i, j));\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn cells_in_range(s: String) -> Vec<String> {\\n        let mut ans = Vec::new();\\n        let s: Vec<char> = s.chars().collect();\\n        for i in s[0]..=s[3] {\\n            for j in s[1]..=s[4] {\\n                ans.push(format!(\"{}{}\", i, j));\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868457,
                "title": "javascript-solution",
                "content": "```\\nconst cellsInRange = (s) => {\\n  let letters = [s.charCodeAt(0), s.charCodeAt(3)]; // To get letter ASCII codes as columns\\n  let numbers = [Number(s[1]), Number(s[4])]; // For rows\\n  let res = [];\\n\\n  for (let i = letters[0]; i <= letters[1]; i++) {\\n    for (let j = numbers[0]; j <= numbers[1]; j++) {\\n      let cell = String.fromCharCode(i) + j;\\n      res.push(cell);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cellsInRange = (s) => {\\n  let letters = [s.charCodeAt(0), s.charCodeAt(3)]; // To get letter ASCII codes as columns\\n  let numbers = [Number(s[1]), Number(s[4])]; // For rows\\n  let res = [];\\n\\n  for (let i = letters[0]; i <= letters[1]; i++) {\\n    for (let j = numbers[0]; j <= numbers[1]; j++) {\\n      let cell = String.fromCharCode(i) + j;\\n      res.push(cell);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868179,
                "title": "python3-simple-two-loops-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \\n                    \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \\n                    \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\\n        \\n        res = []\\n        start = alphabet.index(s[0])\\n        \\n        for i in range(start, len(alphabet)):\\n            j1 = int(s[1])\\n            j2 = int(s[4])\\n            for j in range(j1, j2+1):\\n                res.append(\"\" + alphabet[i] + str(j))\\n            if alphabet[i] == s[3]:\\n                break\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \\n                    \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \\n                    \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\\n        \\n        res = []\\n        start = alphabet.index(s[0])\\n        \\n        for i in range(start, len(alphabet)):\\n            j1 = int(s[1])\\n            j2 = int(s[4])\\n            for j in range(j1, j2+1):\\n                res.append(\"\" + alphabet[i] + str(j))\\n            if alphabet[i] == s[3]:\\n                break\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856136,
                "title": "1-line-python-solution-80-faster-memory-less-than-25",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(i)+str(j) for i in range(ord(s[0]),ord(s[3])+1) for j in range(int(s[1]),int(s[4])+1)]\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(i)+str(j) for i in range(ord(s[0]),ord(s[3])+1) for j in range(int(s[1]),int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854887,
                "title": "java-straight-forward-11ms-for",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        String alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        String number = \"0123456789\";\\n        ArrayList<String> list = new ArrayList<>();\\n        String str = new String();\\n        int colIndexStart = alpha.indexOf(Character.toString(s.charAt(0)));\\n        int colIndexEnd = alpha.indexOf(Character.toString(s.charAt(3)));\\n        int rowIndexStart = Integer.valueOf(s.charAt(1)-48);\\n        int rowIndexEnd = Integer.valueOf(s.charAt(4)-48);\\n        for(int i=colIndexStart; i<=colIndexEnd; i++){\\n            for(int j=rowIndexStart; j<=rowIndexEnd; j++){\\n                str += alpha.charAt(i);\\n                str += number.charAt(j);\\n                list.add(str);\\n                str = \"\";\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        String alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        String number = \"0123456789\";\\n        ArrayList<String> list = new ArrayList<>();\\n        String str = new String();\\n        int colIndexStart = alpha.indexOf(Character.toString(s.charAt(0)));\\n        int colIndexEnd = alpha.indexOf(Character.toString(s.charAt(3)));\\n        int rowIndexStart = Integer.valueOf(s.charAt(1)-48);\\n        int rowIndexEnd = Integer.valueOf(s.charAt(4)-48);\\n        for(int i=colIndexStart; i<=colIndexEnd; i++){\\n            for(int j=rowIndexStart; j<=rowIndexEnd; j++){\\n                str += alpha.charAt(i);\\n                str += number.charAt(j);\\n                list.add(str);\\n                str = \"\";\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848280,
                "title": "c-cpp-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int sc = s[0] - \\'A\\',ec = s[3] - \\'A\\', sr = s[1] - \\'1\\',er = s[4] - \\'1\\';\\n        vector<string> ans;\\n        for(int i = sc; i <= ec;i++){\\n            for(int j = sr ; j <= er;j++){\\n                ans.emplace_back(char(i + \\'A\\') + to_string(j + 1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a0b2b76f-d776-425e-8fa5-7bf4e6a5497d_1647246926.234795.png)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int sc = s[0] - \\'A\\',ec = s[3] - \\'A\\', sr = s[1] - \\'1\\',er = s[4] - \\'1\\';\\n        vector<string> ans;\\n        for(int i = sc; i <= ec;i++){\\n            for(int j = sr ; j <= er;j++){\\n                ans.emplace_back(char(i + \\'A\\') + to_string(j + 1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841324,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        for(char c = s[0]; c <= s[3]; c++) {\\n            for(int i = s[1]-\\'0\\'; i <= s[4]-\\'0\\'; i++) {\\n                ans.push_back(string{c}+to_string(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        for(char c = s[0]; c <= s[3]; c++) {\\n            for(int i = s[1]-\\'0\\'; i <= s[4]-\\'0\\'; i++) {\\n                ans.push_back(string{c}+to_string(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839756,
                "title": "very-easy-c-solution-with-detailed-explanation",
                "content": "Explanation\\n-\\n\\n- The cells in given range X1N1 : X2N2 will range from X1 to X1 and N1 to N2\\n- For example if we have A3:C5, the first value will range from A to C and second one from 3 to 5.\\n- So we use a nested loop to enter the cells inside the vector.\\n\\n**Please UPVOTE if you understood!!**\\n```\\n    vector<string> cellsInRange(string s) {\\n        vector<string> res;\\n        for(char a=s[0]; a<=s[3]; a++)\\n            for(char b=s[1]; b<=s[4]; b++)\\n                res.push_back({a, b});\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<string> cellsInRange(string s) {\\n        vector<string> res;\\n        for(char a=s[0]; a<=s[3]; a++)\\n            for(char b=s[1]; b<=s[4]; b++)\\n                res.push_back({a, b});\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833559,
                "title": "java-solution-time-space-o-n",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> result = new ArrayList<>();\\n        String[] split = s.split(\":\");\\n        char fs = split[0].charAt(0);\\n        char ss = split[1].charAt(0);\\n        int li = split[0].charAt(0);\\n        int fi = (int) Character.getNumericValue(split[0].charAt(1));\\n        int si = (int)Character.getNumericValue(split[1].charAt(1));\\n        int temp = fi;\\n\\n        while(li <= split[1].charAt(0)) {\\n            result.add((char)li+String.valueOf(temp));\\n            if(temp == si) {\\n                li++;\\n                temp = fi;\\n            } else \\n                temp++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> result = new ArrayList<>();\\n        String[] split = s.split(\":\");\\n        char fs = split[0].charAt(0);\\n        char ss = split[1].charAt(0);\\n        int li = split[0].charAt(0);\\n        int fi = (int) Character.getNumericValue(split[0].charAt(1));\\n        int si = (int)Character.getNumericValue(split[1].charAt(1));\\n        int temp = fi;\\n\\n        while(li <= split[1].charAt(0)) {\\n            result.add((char)li+String.valueOf(temp));\\n            if(temp == si) {\\n                li++;\\n                temp = fi;\\n            } else \\n                temp++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829597,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Time Complexity : O(n*m)**\\nwhere n = number of rows; m = number of columns\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    var list = [];\\n    let c1 = s.charCodeAt(0), c2 = s.charCodeAt(3), r1 = s[1], r2 = s[4];\\n    for(let c=c1; c<=c2; c++){\\n      for(let r=r1; r<=r2; r++){\\n          list.push(String.fromCharCode(c) + r);\\n      }\\n    }\\n    return list;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    var list = [];\\n    let c1 = s.charCodeAt(0), c2 = s.charCodeAt(3), r1 = s[1], r2 = s[4];\\n    for(let c=c1; c<=c2; c++){\\n      for(let r=r1; r<=r2; r++){\\n          list.push(String.fromCharCode(c) + r);\\n      }\\n    }\\n    return list;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829577,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n*m)**\\nwhere n = number of rows; m = number of columns\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list = new ArrayList<>();\\n        char c1 = s.charAt(0), c2 = s.charAt(3);\\n        char r1 = s.charAt(1), r2 = s.charAt(4);\\n        for(char c=c1; c<=c2; c++){\\n            for(char r=r1; r<=r2; r++){\\n                list.add(\"\" + c + r);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> list = new ArrayList<>();\\n        char c1 = s.charAt(0), c2 = s.charAt(3);\\n        char r1 = s.charAt(1), r2 = s.charAt(4);\\n        for(char c=c1; c<=c2; c++){\\n            for(char r=r1; r<=r2; r++){\\n                list.add(\"\" + c + r);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829425,
                "title": "java-2ms-98-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Loop from the starting letter to ending letter\\n        2. Inside this loop, loop again from starting number to ending number\\n        3. Use a char[2] to store the chars and add it to the list of cells.\\n        4. Return the answer/cells.\\n    */\\n    public List<String> cellsInRange(String s) {\\n        List<String> cells = new ArrayList<>();\\n        char[] cell = new char[2];\\n        for (char l = s.charAt(0); l <= s.charAt(3); l++) {\\n            cell[0] = l;\\n            for (char n = s.charAt(1); n <= s.charAt(4); n++) {\\n                cell[1] = n;\\n                cells.add(new String(cell));\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Loop from the starting letter to ending letter\\n        2. Inside this loop, loop again from starting number to ending number\\n        3. Use a char[2] to store the chars and add it to the list of cells.\\n        4. Return the answer/cells.\\n    */\\n    public List<String> cellsInRange(String s) {\\n        List<String> cells = new ArrayList<>();\\n        char[] cell = new char[2];\\n        for (char l = s.charAt(0); l <= s.charAt(3); l++) {\\n            cell[0] = l;\\n            for (char n = s.charAt(1); n <= s.charAt(4); n++) {\\n                cell[1] = n;\\n                cells.add(new String(cell));\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828768,
                "title": "c-reserve-capacity-reuse-string-and-emplace-rather-than-push",
                "content": "The problem is trivial but we do a few things right beyond the bare minimum to solve it:\\n\\n1. We reserve the exact required capacity in our output vector.\\n2. We keep one string around and reuse it in our inner loop.\\n3. We transfer the string contents into our output vector with `emplace_back()` rather than `push_back()`\\n\\nWe also take a `string_view` rather than letting a string be passed in by value. \\n\\n## C++ Code\\n\\n```c++\\n    static vector<string> cellsInRange(const string_view s)\\n    {\\n        // The ends of the column and row ranges:\\n        const auto cend = s[3];\\n        const auto rend = s[4];\\n        \\n        // Let\\'s preallocate the exact heap space we need for our result vector:\\n        // If we didn\\'t do this we\\'d grow it exponentially and end up with unused\\n        // slop at the end of the final allocation most of the time.\\n        vector<string> res;\\n        res.reserve((cend - s[0]) * (rend-s[1]));\\n        \\n        // Let\\'s have a single string that we reuse in the inner loop:\\n        string str;\\n        str.resize(2);\\n        \\n        for(auto col = s[0]; col <= cend; ++col)\\n        {\\n            for(auto row = s[1]; row <= rend; ++row)\\n            {\\n                str[0] = col;\\n                str[1] = row;\\n                // Let\\'s emplace_back rather than push back:\\n                // I.e., we run the string copy constructor on\\n                // the raw memory at the back of the vector. \\n                res.emplace_back(str);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n# Emplace Empty String Variant\\n\\nInstead of copy constructing at the end of the result vector, we can default construct there and then resize and write the two desired characters into the correct locations within the result vector\\'s single heap allocation, relying on the small string optimisation to make the resize a trivial, non-allocating operation.\\n\\n## C++ Code\\n\\n```c++\\n    static vector<string> cellsInRange(const string_view s)\\n    {\\n        // The ends of the column and row ranges:\\n        const auto cend = s[3];\\n        const auto rend = s[4];\\n        \\n        // Let\\'s preallocate the exact heap space we need for our result vector:\\n        // If we didn\\'t do this we\\'d grow it exponentially and end up with unused\\n        // slop at the end of the final allocation most of the time.\\n        vector<string> res;\\n        res.reserve((cend - s[0]) * (rend-s[1]));\\n                \\n        for(auto col = s[0]; col <= cend; ++col)\\n        {\\n            for(auto row = s[1]; row <= rend; ++row)\\n            {\\n                // Let\\'s emplace_back rather than push back:\\n                // I.e., we run the string default constructor on\\n                // the raw memory at the back of the vector.\\n                // We then write row and colum directly into the string\\n                // at the back of the result vector:\\n                res.emplace_back();\\n                string& str = res.back();\\n                str.resize(2);\\n                str[0] = col;\\n                str[1] = row;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n# Notes\\n\\n* Although we make an effort to avoid allocating too much memory in these implementations, having power of two allocations might have upsides in some uses. For instance, if the results are only kept around temporarily as a step in some larger algorithm and then freed, the standard allocation sizes of the usual growth pattern might be quicker to allocate and free to memory pools. Customised allocations of minimal length, however, might fall back to a slower, general purpose allocation strategy, with the freeing step walking a list of free blocks looking for neighbours to coalesce with rather than simply adding the block to a fixed-size pool.",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\n    static vector<string> cellsInRange(const string_view s)\\n    {\\n        // The ends of the column and row ranges:\\n        const auto cend = s[3];\\n        const auto rend = s[4];\\n        \\n        // Let\\'s preallocate the exact heap space we need for our result vector:\\n        // If we didn\\'t do this we\\'d grow it exponentially and end up with unused\\n        // slop at the end of the final allocation most of the time.\\n        vector<string> res;\\n        res.reserve((cend - s[0]) * (rend-s[1]));\\n        \\n        // Let\\'s have a single string that we reuse in the inner loop:\\n        string str;\\n        str.resize(2);\\n        \\n        for(auto col = s[0]; col <= cend; ++col)\\n        {\\n            for(auto row = s[1]; row <= rend; ++row)\\n            {\\n                str[0] = col;\\n                str[1] = row;\\n                // Let\\'s emplace_back rather than push back:\\n                // I.e., we run the string copy constructor on\\n                // the raw memory at the back of the vector. \\n                res.emplace_back(str);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```c++\\n    static vector<string> cellsInRange(const string_view s)\\n    {\\n        // The ends of the column and row ranges:\\n        const auto cend = s[3];\\n        const auto rend = s[4];\\n        \\n        // Let\\'s preallocate the exact heap space we need for our result vector:\\n        // If we didn\\'t do this we\\'d grow it exponentially and end up with unused\\n        // slop at the end of the final allocation most of the time.\\n        vector<string> res;\\n        res.reserve((cend - s[0]) * (rend-s[1]));\\n                \\n        for(auto col = s[0]; col <= cend; ++col)\\n        {\\n            for(auto row = s[1]; row <= rend; ++row)\\n            {\\n                // Let\\'s emplace_back rather than push back:\\n                // I.e., we run the string default constructor on\\n                // the raw memory at the back of the vector.\\n                // We then write row and colum directly into the string\\n                // at the back of the result vector:\\n                res.emplace_back();\\n                string& str = res.back();\\n                str.resize(2);\\n                str[0] = col;\\n                str[1] = row;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827593,
                "title": "c-simple-and-straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        \\n        for(int i = s[0] - \\'A\\'; i <= s[3] - \\'A\\'; i++){\\n            for(int j = s[1] - \\'0\\'; j <= s[4] - \\'0\\'; j++){\\n                result.push_back(string(1, char(i + 65)) + string(1, char(j + 48)));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**Please upvote if you love the solution**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> result;\\n        \\n        for(int i = s[0] - \\'A\\'; i <= s[3] - \\'A\\'; i++){\\n            for(int j = s[1] - \\'0\\'; j <= s[4] - \\'0\\'; j++){\\n                result.push_back(string(1, char(i + 65)) + string(1, char(j + 48)));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825571,
                "title": "c-simple-implementation",
                "content": "```\\nclass Solution\\n{\\n  public:\\n    vector<string> cellsInRange(string s)\\n    {\\n        vector<string> result;\\n        string temp = \"\";\\n        for (char i = s[0]; i <= s[3]; i++)\\n        {\\n            temp = \"\";\\n            temp += i;\\n            for (char j = s[1]; j <= s[4]; j++)\\n            {\\n                temp += j;\\n                result.push_back(temp);\\n                temp.pop_back();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n  public:\\n    vector<string> cellsInRange(string s)\\n    {\\n        vector<string> result;\\n        string temp = \"\";\\n        for (char i = s[0]; i <= s[3]; i++)\\n        {\\n            temp = \"\";\\n            temp += i;\\n            for (char j = s[1]; j <= s[4]; j++)\\n            {\\n                temp += j;\\n                result.push_back(temp);\\n                temp.pop_back();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825539,
                "title": "easy-understanding",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans=new ArrayList<>();\\n        \\n        String[]arr=s.split(\":\");\\n        char sc=arr[0].charAt(0);\\n        int sr=Integer.parseInt(arr[0].substring(1));\\n        \\n        char ec=arr[1].charAt(0);\\n        int er=Integer.parseInt(arr[1].substring(1));\\n        \\n        for(int i=sc;i<=ec;i++){\\n            getAll(sr,i,er,ec,ans);\\n        }\\n        return ans;\\n    }\\n    \\n    public void getAll(int sr, int sc, int er, int ec,List<String> ans){\\n        while(sr<=er){\\n            ans.add((char)sc+\"\"+sr);\\n            sr++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans=new ArrayList<>();\\n        \\n        String[]arr=s.split(\":\");\\n        char sc=arr[0].charAt(0);\\n        int sr=Integer.parseInt(arr[0].substring(1));\\n        \\n        char ec=arr[1].charAt(0);\\n        int er=Integer.parseInt(arr[1].substring(1));\\n        \\n        for(int i=sc;i<=ec;i++){\\n            getAll(sr,i,er,ec,ans);\\n        }\\n        return ans;\\n    }\\n    \\n    public void getAll(int sr, int sc, int er, int ec,List<String> ans){\\n        while(sr<=er){\\n            ans.add((char)sc+\"\"+sr);\\n            sr++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825495,
                "title": "python-one-line-use-ord-and-chr",
                "content": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]),ord(s[3])+1) for r in range(int(s[1]),int(s[4])+1)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]),ord(s[3])+1) for r in range(int(s[1]),int(s[4])+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825244,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char c1 = s[0];\\n        char r1 = s[1];\\n        char c2 = s[3];\\n        char r2 = s[4];\\n        vector<string> ans;\\n        for(int i=0;i+c1<=c2;i++)\\n        {\\n            for(int j=0;j+r1<=r2;j++)\\n            {\\n                string res;\\n                // s = \"K1:L2\"\\n                // here c1 = k,c2 = L,r1 = 1,r2 = 2 ,i=j=0.;\\n                // after 1st execution of for loop for j res = k+0+1+0 = k1\\n                // after 2nd execution of for loop for j res = k+0+1+1 = k2\\n                // after execution of for loop for i res = k+1+1+0 = L1\\n                res+=(c1+i);\\n                res+=(r1+j);\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char c1 = s[0];\\n        char r1 = s[1];\\n        char c2 = s[3];\\n        char r2 = s[4];\\n        vector<string> ans;\\n        for(int i=0;i+c1<=c2;i++)\\n        {\\n            for(int j=0;j+r1<=r2;j++)\\n            {\\n                string res;\\n                // s = \"K1:L2\"\\n                // here c1 = k,c2 = L,r1 = 1,r2 = 2 ,i=j=0.;\\n                // after 1st execution of for loop for j res = k+0+1+0 = k1\\n                // after 2nd execution of for loop for j res = k+0+1+1 = k2\\n                // after execution of for loop for i res = k+1+1+0 = L1\\n                res+=(c1+i);\\n                res+=(r1+j);\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825193,
                "title": "simple-c-100-0ms-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> cellsInRange(string s) {\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tvector<string> v1;\\n\\t\\t\\tint a=int(s[0]),b=s[1]-\\'0\\',c=int(s[3]),d=s[4]-\\'0\\';\\n\\t\\t\\tint n=abs(a-c);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<=n;i++)\\n\\t\\t\\t  {\\n\\t\\t\\t\\t  for(int j=b;j<=d;j++)\\n              {\\n\\t\\t\\t\\tans+=char(a+i);    \\n\\t\\t\\t\\tans+=to_string(j);\\n\\t\\t\\t\\tv1.push_back(ans);\\n\\t\\t\\t\\tans=\"\";\\n          }\\n        }\\n\\t\\t\\treturn v1;\\n\\t\\t\\t}\\n\\t  };",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> cellsInRange(string s) {\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tvector<string> v1;\\n\\t\\t\\tint a=int(s[0]),b=s[1]-\\'0\\',c=int(s[3]),d=s[4]-\\'0\\';\\n\\t\\t\\tint n=abs(a-c);\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<=n;i++)\\n\\t\\t\\t  {\\n\\t\\t\\t\\t  for(int j=b;j<=d;j++)\\n              {\\n\\t\\t\\t\\tans+=char(a+i);    \\n\\t\\t\\t\\tans+=to_string(j);\\n\\t\\t\\t\\tv1.push_back(ans);\\n\\t\\t\\t\\tans=\"\";\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1824768,
                "title": "faster-c-solution",
                "content": "vector<string> ans;\\n        for(char col = \\'A\\'; col <= \\'Z\\'; col++) {\\n            for(char row = \\'1\\'; row <= \\'9\\'; row++) {\\n                if(row >= s[1] && row <= s[4] && col >= s[0] && col <= s[3])\\n                    ans.push_back(string(1, col) + string(1, row));\\n            }\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\t\\n\\tif(helps){\\n\\tupvotes++;\\n\\t}\\n\\telse ignore;",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<string> ans;\\n        for(char col = \\'A\\'; col <= \\'Z\\'; col++) {\\n            for(char row = \\'1\\'; row <= \\'9\\'; row++) {\\n                if(row >= s[1] && row <= s[4] && col >= s[0] && col <= s[3])\\n                    ans.push_back(string(1, col) + string(1, row));\\n            }\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\t\\n\\tif(helps){\\n\\tupvotes++;\\n\\t}\\n\\telse ignore;",
                "codeTag": "Unknown"
            },
            {
                "id": 1824368,
                "title": "c-nested-loop-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char col1 = s[0];\\n        char col2 = s[3];\\n        char row1 = s[1];\\n        char row2 = s[4];\\n        \\n        vector<string> res;\\n        \\n        for(char ch=col1;ch<=col2;ch++){\\n            for(char rw=row1;rw<=row2;rw++){\\n                string temp = \"\";\\n                temp += ch;\\n                temp += rw;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char col1 = s[0];\\n        char col2 = s[3];\\n        char row1 = s[1];\\n        char row2 = s[4];\\n        \\n        vector<string> res;\\n        \\n        for(char ch=col1;ch<=col2;ch++){\\n            for(char rw=row1;rw<=row2;rw++){\\n                string temp = \"\";\\n                temp += ch;\\n                temp += rw;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824255,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        string start=s.substr(0,2);\\n        string end=s.substr(3,2);\\n        vector<string> res;\\n        for(char i=start[0];i<=end[0];i++)\\n            for(char j=start[1];j<=end[1];j++){\\n                    stringstream ss;\\n                    ss<<i<<j;\\n                    res.push_back(ss.str());\\n                }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        string start=s.substr(0,2);\\n        string end=s.substr(3,2);\\n        vector<string> res;\\n        for(char i=start[0];i<=end[0];i++)\\n            for(char j=start[1];j<=end[1];j++){\\n                    stringstream ss;\\n                    ss<<i<<j;\\n                    res.push_back(ss.str());\\n                }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823890,
                "title": "easy-java-solution",
                "content": "List<String> res = new ArrayList<>();\\n        \\n        for (char c = s.charAt(0); c <= s.charAt(3); c++) {\\n            for (int i = s.charAt(1)-\\'0\\'; i <= s.charAt(4)-\\'0\\'; i++) {\\n                res.add(c + \"\" + i);                \\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "List<String> res = new ArrayList<>();\\n        \\n        for (char c = s.charAt(0); c <= s.charAt(3); c++) {\\n            for (int i = s.charAt(1)-\\'0\\'; i <= s.charAt(4)-\\'0\\'; i++) {\\n                res.add(c + \"\" + i);                \\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 1823807,
                "title": "java-easy-solution-approach-explained",
                "content": "As result has to be first column sorted, then row sorted.\\nSo, loop through `c1 to c2` & add cells from `r1 to r2 for each column.`\\n\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char c1 = s.charAt(0);\\n        char r1 = s.charAt(1);\\n        \\n        char c2 = s.charAt(3);\\n        char r2 = s.charAt(4);\\n        \\n        List<String> res = new ArrayList<>();\\n        while (c1 <= c2) {\\n            char temp = r1;\\n            while (temp <= r2) {\\n                res.add(c1 + \"\" + temp);\\n                ++temp;\\n            }\\n            ++c1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        char c1 = s.charAt(0);\\n        char r1 = s.charAt(1);\\n        \\n        char c2 = s.charAt(3);\\n        char r2 = s.charAt(4);\\n        \\n        List<String> res = new ArrayList<>();\\n        while (c1 <= c2) {\\n            char temp = r1;\\n            while (temp <= r2) {\\n                res.add(c1 + \"\" + temp);\\n                ++temp;\\n            }\\n            ++c1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823718,
                "title": "easy-c-bruteforce",
                "content": "\\t char a=s[0];\\n        char b=s[3];\\n        char c=s[1];\\n        char d=s[4];\\n        vector<string>res;\\n        for(char i=a;i<=b;i++){\\n           \\n            for(char x=c;x<=d;x++ ){\\n                string temp;\\n                temp+=i;\\n                temp+=x;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "\\t char a=s[0];\\n        char b=s[3];\\n        char c=s[1];\\n        char d=s[4];\\n        vector<string>res;\\n        for(char i=a;i<=b;i++){\\n           \\n            for(char x=c;x<=d;x++ ){\\n                string temp;\\n                temp+=i;\\n                temp+=x;\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 1823685,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        char c1 = s[0];\\n        char r1 = s[1];\\n        char c2 = s[3];\\n        char r2 = s[4];\\n        \\n        char rmin = min(r1,r2);\\n        char rmax = max(r1,r2);\\n        char cmin = min(c1,c2);\\n        char cmax = max(c1,c2);\\n        \\n        while(cmin <= cmax){\\n            char l = rmin; \\n            char r = rmax;\\n            while(l <= r){\\n                string str;\\n                str.push_back(cmin);\\n                str.push_back(l);\\n                ans.push_back(str);\\n                l++;\\n            }\\n            cmin++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        char c1 = s[0];\\n        char r1 = s[1];\\n        char c2 = s[3];\\n        char r2 = s[4];\\n        \\n        char rmin = min(r1,r2);\\n        char rmax = max(r1,r2);\\n        char cmin = min(c1,c2);\\n        char cmax = max(c1,c2);\\n        \\n        while(cmin <= cmax){\\n            char l = rmin; \\n            char r = rmax;\\n            while(l <= r){\\n                string str;\\n                str.push_back(cmin);\\n                str.push_back(l);\\n                ans.push_back(str);\\n                l++;\\n            }\\n            cmin++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823667,
                "title": "java-simple-loop-explanation",
                "content": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        String [] sp = s.split(\":\");\\n        int l = sp[0].charAt(1) -\\'0\\'; //col left\\n        int r = sp[1].charAt(1) -\\'0\\'; //col right\\n        int lc = sp[0].charAt(0); // row left\\n        int rc = sp[1].charAt(0); // row right\\n        List<String> out = new ArrayList<>();\\n        for(int i=lc;i<=rc;i++){\\n            for(int j=l;j<=r;j++){\\n                out.add(((char) i) + String.valueOf(j));\\n            }\\n        }\\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> cellsInRange(String s) {\\n        String [] sp = s.split(\":\");\\n        int l = sp[0].charAt(1) -\\'0\\'; //col left\\n        int r = sp[1].charAt(1) -\\'0\\'; //col right\\n        int lc = sp[0].charAt(0); // row left\\n        int rc = sp[1].charAt(0); // row right\\n        List<String> out = new ArrayList<>();\\n        for(int i=lc;i<=rc;i++){\\n            for(int j=l;j<=r;j++){\\n                out.add(((char) i) + String.valueOf(j));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1823631,
                "title": "c-straightforward",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/cells-in-a-range-on-an-excel-sheet/\\n// Author: github.com/lzl124631x\\n// Time: O(1) since there are at most 26 * 9 cells.\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        char a = s[0], b = s[3], x = s[1], y = s[4];\\n        for (; a <= b; ++a) {\\n            for (char i = x; i <= y; ++i) {\\n                ans.push_back(string(1, a) + string(1, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/cells-in-a-range-on-an-excel-sheet/\\n// Author: github.com/lzl124631x\\n// Time: O(1) since there are at most 26 * 9 cells.\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> ans;\\n        char a = s[0], b = s[3], x = s[1], y = s[4];\\n        for (; a <= b; ++a) {\\n            for (char i = x; i <= y; ++i) {\\n                ans.push_back(string(1, a) + string(1, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092928,
                "title": "python3-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n      s=s.split(\\':\\')\\n      l1,l2=s[0][0],s[1][0]\\n      n1,n2=int(s[0][1]),int(s[1][1])\\n      L=[]\\n      ans=\\'\\'\\n      for i in range(ord(l1),ord(l2)+1):\\n          for j in range(n1,n2+1):\\n                ans=chr(i)+str(j)\\n                L.append(ans)\\n      return L\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n      s=s.split(\\':\\')\\n      l1,l2=s[0][0],s[1][0]\\n      n1,n2=int(s[0][1]),int(s[1][1])\\n      L=[]\\n      ans=\\'\\'\\n      for i in range(ord(l1),ord(l2)+1):\\n          for j in range(n1,n2+1):\\n                ans=chr(i)+str(j)\\n                L.append(ans)\\n      return L\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091141,
                "title": "simples-c-solution-no-overengineering-keep-it-simple",
                "content": "Simple and intutive solution!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n      vector<string> ans;\\n      int fromCIndex = s[0]-0, toCIndex = s[3]-0, fromIndex = s[1]-48, toIndex = s[4]-48;\\n      for(int i=fromCIndex;i<=toCIndex;i++) {\\n        for(int j=fromIndex; j<=toIndex;j++) {\\n          string x=(char)i + to_string(j);\\n          ans.push_back(x);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n      vector<string> ans;\\n      int fromCIndex = s[0]-0, toCIndex = s[3]-0, fromIndex = s[1]-48, toIndex = s[4]-48;\\n      for(int i=fromCIndex;i<=toCIndex;i++) {\\n        for(int j=fromIndex; j<=toIndex;j++) {\\n          string x=(char)i + to_string(j);\\n          ans.push_back(x);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087499,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int startCol = s[0] - \\'A\\';\\n        int endCol = s[3] - \\'A\\';\\n        int startRow = s[1] - \\'0\\';\\n        int endRow = s[4] - \\'0\\';\\n        vector<string> res;\\n        for (int col = startCol; col <= endCol; col++)\\n        {\\n            for (int row = startRow; row <= endRow; row++)\\n            {\\n                char tmp[3];\\n                tmp[0] = \\'A\\' + col;\\n                tmp[1] = \\'0\\' + row;\\n                tmp[2] = 0;\\n                res.push_back(string(tmp));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int startCol = s[0] - \\'A\\';\\n        int endCol = s[3] - \\'A\\';\\n        int startRow = s[1] - \\'0\\';\\n        int endRow = s[4] - \\'0\\';\\n        vector<string> res;\\n        for (int col = startCol; col <= endCol; col++)\\n        {\\n            for (int row = startRow; row <= endRow; row++)\\n            {\\n                char tmp[3];\\n                tmp[0] = \\'A\\' + col;\\n                tmp[1] = \\'0\\' + row;\\n                tmp[2] = 0;\\n                res.push_back(string(tmp));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081414,
                "title": "cells-in-a-range-on-an-excel-sheet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n\\n        char startRow = s.charAt(0);\\n        char startCol = s.charAt(1);\\n        char endRow = s.charAt(3);\\n        char endCol = s.charAt(4);\\n\\n        while(startRow<=endRow)\\n        {\\n            while(startCol <= endCol)\\n            {\\n                ans.add(startRow+\"\"+startCol);\\n                startCol++;\\n            }\\n            startCol = s.charAt(1);\\n            startRow++;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n\\n        char startRow = s.charAt(0);\\n        char startCol = s.charAt(1);\\n        char endRow = s.charAt(3);\\n        char endCol = s.charAt(4);\\n\\n        while(startRow<=endRow)\\n        {\\n            while(startCol <= endCol)\\n            {\\n                ans.add(startRow+\"\"+startCol);\\n                startCol++;\\n            }\\n            startCol = s.charAt(1);\\n            startRow++;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079983,
                "title": "simple-and-easy-java-solution-100-beats-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Please Upvote.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        // List to store the ans.\\n        List<String> list = new ArrayList<>();\\n        // StringBuilder to make the each String.\\n        StringBuilder sb = new StringBuilder();\\n        // Variables to store values \\n        char c = s.charAt(0);\\n        int n = s.charAt(3) - c;\\n        int c1 = s.charAt(1)-\\'0\\';\\n        int m = (s.charAt(4)-\\'0\\')-c1;\\n        // It will iterate through all the columns.\\n        for(int i =0;i<=n;i++){\\n            // It will iterate through all the rows.\\n            for(int j=0;j<=m;j++){\\n                //First add column to the string then add row.\\n                sb.append((char)(c+i));\\n                sb.append(c1+j);\\n                // add the answer to the list.\\n                list.add(sb.toString());\\n                // It will make the StringBuilder empty.\\n                sb.setLength(0);\\n            }\\n        }\\n        // Finaly Return the answer.\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        // List to store the ans.\\n        List<String> list = new ArrayList<>();\\n        // StringBuilder to make the each String.\\n        StringBuilder sb = new StringBuilder();\\n        // Variables to store values \\n        char c = s.charAt(0);\\n        int n = s.charAt(3) - c;\\n        int c1 = s.charAt(1)-\\'0\\';\\n        int m = (s.charAt(4)-\\'0\\')-c1;\\n        // It will iterate through all the columns.\\n        for(int i =0;i<=n;i++){\\n            // It will iterate through all the rows.\\n            for(int j=0;j<=m;j++){\\n                //First add column to the string then add row.\\n                sb.append((char)(c+i));\\n                sb.append(c1+j);\\n                // add the answer to the list.\\n                list.add(sb.toString());\\n                // It will make the StringBuilder empty.\\n                sb.setLength(0);\\n            }\\n        }\\n        // Finaly Return the answer.\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076733,
                "title": "this-method-uses-chr-and-ord",
                "content": "# Intuition\\nUse indexing to get what we need, throw them into variables then somehow turn that integers using ord() and make a loop.\\n\\n# Approach\\njust a normal pattern loop idk how to verbalize it.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nno idea lol but consumes 15.89 mb\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        rfinal = int(s[4])\\n        rstart = int(s[1])\\n        cfinal = ord(s[3])\\n        cstart = ord(s[0])\\n\\n        while cstart <= cfinal:\\n            x = chr(cstart)\\n            rstart = int(s[1])\\n\\n            while rstart <= rfinal:\\n                y = rstart\\n                res.append(x + str(y))\\n                rstart += 1\\n            cstart += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        res = []\\n        rfinal = int(s[4])\\n        rstart = int(s[1])\\n        cfinal = ord(s[3])\\n        cstart = ord(s[0])\\n\\n        while cstart <= cfinal:\\n            x = chr(cstart)\\n            rstart = int(s[1])\\n\\n            while rstart <= rfinal:\\n                y = rstart\\n                res.append(x + str(y))\\n                rstart += 1\\n            cstart += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074601,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(row * col)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n      vector<string> cells;\\n      for(int i=int(s[0]);i<=int(s[3]);i++ ){\\n        for(int j=int(s[1]);j<=int(s[4]);j++){\\n          cells.push_back(string(1, char(i))+string(1,char(j)));\\n        }\\n      }\\n      return cells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n      vector<string> cells;\\n      for(int i=int(s[0]);i<=int(s[3]);i++ ){\\n        for(int j=int(s[1]);j<=int(s[4]);j++){\\n          cells.push_back(string(1, char(i))+string(1,char(j)));\\n        }\\n      }\\n      return cells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074026,
                "title": "java-solution-5ms-easy-implementation",
                "content": "# Approach\\n\\n1. **Initialization:**\\n\\n    - Create an ArrayList<String> named `ans` to store the generated cells.\\nHandle edge cases: If the input string `s` is null or empty, return an empty list.\\n\\n2. **Extract Column and Row Ranges:**\\n\\n    - Extract the column ranges `c1` and `c2` from the first and fourth characters of the input string s, respectively. These represent the starting and ending columns.\\n\\n    - Extract the row ranges `r1` and `r2` from the second and fifth characters of the input string s, respectively. These represent the starting and ending rows.\\n\\n3. **Generate Cells:**\\n\\n    - Use nested loops to iterate through the range of columns and rows.\\nIn the outer loop, iterate through columns from `c1` to `c2`.\\nIn the inner loop, iterate through rows from `r1` to `r2`.\\n\\n    - For each combination of column and row, generate a cell representation using `(char)(cell + \\'A\\' - 1)` to convert the column number back to the corresponding letter, and concatenate it with the row number.\\n\\n4. **Adding to List:**\\n\\n    - Add each generated cell to the list `ans`.\\n\\n5. **Return the List:**\\n\\n    - After generating all cells, return the list `ans`.\\n\\n\\n# Complexity\\n- Time complexity: O(col * row)\\n\\n- Space complexity: O(col + row)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n        // Edge cases\\n        if (s == null || s.length() == 0) {\\n            return ans;\\n        }\\n        // Getting values \\n        final int c1 = s.charAt(0) - \\'A\\' + 1;\\n        final int c2 = s.charAt(3) - \\'A\\' + 1;\\n        final int r1 = Character.getNumericValue(s.charAt(1));\\n        final int r2 = Character.getNumericValue(s.charAt(4));\\n        // Fill the list\\n        for (int cell = c1; cell <= c2; cell++) {\\n            for (int row = r1; row <= r2; row++) {\\n                ans.add((char)(cell + \\'A\\' - 1) + \"\" + row);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        List<String> ans = new ArrayList<>();\\n        // Edge cases\\n        if (s == null || s.length() == 0) {\\n            return ans;\\n        }\\n        // Getting values \\n        final int c1 = s.charAt(0) - \\'A\\' + 1;\\n        final int c2 = s.charAt(3) - \\'A\\' + 1;\\n        final int r1 = Character.getNumericValue(s.charAt(1));\\n        final int r2 = Character.getNumericValue(s.charAt(4));\\n        // Fill the list\\n        for (int cell = c1; cell <= c2; cell++) {\\n            for (int row = r1; row <= r2; row++) {\\n                ans.add((char)(cell + \\'A\\' - 1) + \"\" + row);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073143,
                "title": "kotlin-solution-beats-50-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //Using LinkedList\\nfun cellsInRange(s: String): List<String> {\\n    val linkedList = LinkedList<String>()\\n    for (row in s[0]..s[3]){\\n        for (col in s[1]..s[4]) linkedList.add(\"$row$col\")\\n    }\\n    return linkedList\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    //Using LinkedList\\nfun cellsInRange(s: String): List<String> {\\n    val linkedList = LinkedList<String>()\\n    for (row in s[0]..s[3]){\\n        for (col in s[1]..s[4]) linkedList.add(\"$row$col\")\\n    }\\n    return linkedList\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073105,
                "title": "recursion-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nfun cellsInRange(s: String): List<String> {\\n    val (firstChar, lastChar) = s.split(\\':\\')\\n\\n\\n    return recursiveCells(\\n        firstChar.first(),\\n        lastChar.first(), s[1].digitToInt(), s.last().digitToInt(), mutableListOf<String>()\\n    )\\n}\\n\\nfun recursiveCells(\\n    firstChar: Char,\\n    lastChar: Char,\\n    smallNumber: Int,\\n    largeNumber: Int,\\n    result: MutableList<String>\\n): MutableList<String> {\\n    if (firstChar > lastChar) return result\\n    for (number in smallNumber..largeNumber)\\n        result.add(\"${firstChar}${number}\")\\n\\n\\n    return recursiveCells(firstChar + 1, lastChar, smallNumber, largeNumber, result)\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\nfun cellsInRange(s: String): List<String> {\\n    val (firstChar, lastChar) = s.split(\\':\\')\\n\\n\\n    return recursiveCells(\\n        firstChar.first(),\\n        lastChar.first(), s[1].digitToInt(), s.last().digitToInt(), mutableListOf<String>()\\n    )\\n}\\n\\nfun recursiveCells(\\n    firstChar: Char,\\n    lastChar: Char,\\n    smallNumber: Int,\\n    largeNumber: Int,\\n    result: MutableList<String>\\n): MutableList<String> {\\n    if (firstChar > lastChar) return result\\n    for (number in smallNumber..largeNumber)\\n        result.add(\"${firstChar}${number}\")\\n\\n\\n    return recursiveCells(firstChar + 1, lastChar, smallNumber, largeNumber, result)\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072070,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        ans = []\\n        z = []\\n        z.append(s[0])\\n        z.append(s[3])\\n        input_str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        a1 = z[0]\\n        a2 = z[1]\\n\\n        start_index = input_str.index(a1)\\n        end_index = input_str.index(a2)\\n        result = input_str[start_index:end_index + 1]\\n\\n        x = s[len(s)-1 : len(s)]\\n        for i in result:\\n            for j in range(int(s[1]),int(x)+1):\\n                ans.append(i+str(j))\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        ans = []\\n        z = []\\n        z.append(s[0])\\n        z.append(s[3])\\n        input_str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        a1 = z[0]\\n        a2 = z[1]\\n\\n        start_index = input_str.index(a1)\\n        end_index = input_str.index(a2)\\n        result = input_str[start_index:end_index + 1]\\n\\n        x = s[len(s)-1 : len(s)]\\n        for i in result:\\n            for j in range(int(s[1]),int(x)+1):\\n                ans.append(i+str(j))\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071766,
                "title": "python-approach-beats-70-21ms-13-3-mb-ascii-approach",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        outcome = []\\n        for col in range(ord(s[0]),ord(s[3]) + 1): # Ascii value (x, y + 1)\\n            for row in range (int(s[1]), int(s[4]) + 1):\\n                outcome.append(str(chr(col)) + str(row))\\n        return outcome\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        outcome = []\\n        for col in range(ord(s[0]),ord(s[3]) + 1): # Ascii value (x, y + 1)\\n            for row in range (int(s[1]), int(s[4]) + 1):\\n                outcome.append(str(chr(col)) + str(row))\\n        return outcome\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069811,
                "title": "simplest-python-solution-ever",
                "content": "# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        startChar = s[0]\\n        endChar = s[3]\\n        startNum = int(s[1])\\n        endNum = int(s[4])\\n        ans = []\\n        temp = \\'\\'\\n        for i in range(ord(startChar), ord(endChar)+1):\\n            for j in range(startNum,endNum+1):\\n                temp = chr(i)+str(j)\\n                ans.append(temp)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        startChar = s[0]\\n        endChar = s[3]\\n        startNum = int(s[1])\\n        endNum = int(s[4])\\n        ans = []\\n        temp = \\'\\'\\n        for i in range(ord(startChar), ord(endChar)+1):\\n            for j in range(startNum,endNum+1):\\n                temp = chr(i)+str(j)\\n                ans.append(temp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065703,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 61ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    \\n    const parts = s.split(\":\");\\n\\n    let startLetter = parts[0].charAt(0);\\n    let endLetter = parts[1].charAt(0);\\n    let startCell = parseInt(parts[0].charAt(1));\\n    let endCell = parseInt(parts[1].charAt(1));\\n    let result = [];\\n\\n    for (let i = startLetter.charCodeAt(0); i<= endLetter.charCodeAt(0); i++) {\\n        for (let j = startCell; j <= endCell; j++) {\\n            result.push(String.fromCharCode(i) + j);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    \\n    const parts = s.split(\":\");\\n\\n    let startLetter = parts[0].charAt(0);\\n    let endLetter = parts[1].charAt(0);\\n    let startCell = parseInt(parts[0].charAt(1));\\n    let endCell = parseInt(parts[1].charAt(1));\\n    let result = [];\\n\\n    for (let i = startLetter.charCodeAt(0); i<= endLetter.charCodeAt(0); i++) {\\n        for (let j = startCell; j <= endCell; j++) {\\n            result.push(String.fromCharCode(i) + j);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053096,
                "title": "runtime-18-ms-90-memory-13-40-mb-90",
                "content": "\\n \\n# Code\\n```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        output, l = [], string.ascii_uppercase  # l = letters \\n        for letter in l[l.index(s[0]):l.index(s[3]) + 1]: \\n            for number in range(int(s[1]), int(s[4]) + 1):\\n                output.append(letter + str(number))\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def cellsInRange(self, s):\\n        output, l = [], string.ascii_uppercase  # l = letters \\n        for letter in l[l.index(s[0]):l.index(s[3]) + 1]: \\n            for number in range(int(s[1]), int(s[4]) + 1):\\n                output.append(letter + str(number))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044621,
                "title": "elixir-solution",
                "content": "\\n```\\n\\ndefmodule Solution do\\n  @moduledoc \"\"\"\\n  Suggested strategy:\\n  Engineer a loop within a loop.\\n  The outer loop needs to iterate from the start letter to the\\n  end letter .\\n  Within the inner loop iterate from the start number to the end\\n  number.\\n  Once the loop is underway. Manipulate the data into the\\n  requred form. ie: [ \"K1\", \"K2\", \"L1\", \"L2\"]\\n  Some flattening may be required too.\\n\\n  \"\"\"\\n  @spec cells_in_range(s :: String.t()) :: [String.t()]\\n  def cells_in_range(s) do\\n    start_ascii_value =   String.at(s, 0) |> :binary.first\\n    end_ascii_value = String.at(s,3) |> :binary.first\\n\\n    start_number = String.at(s, 1) |> String.to_integer\\n    end_number = String.at(s, 4) |> String.to_integer\\n\\n    # loop from start_ascii_value to end_ascii_value\\n    result =\\n      for o_val <- start_ascii_value..end_ascii_value do\\n        o_letter = <<o_val::utf8>>\\n        for in_num <- start_number..end_number do\\n          exp = o_letter <> Integer.to_string(in_num)\\n        end\\n      end\\n\\n    result |> List.flatten\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n\\ndefmodule Solution do\\n  @moduledoc \"\"\"\\n  Suggested strategy:\\n  Engineer a loop within a loop.\\n  The outer loop needs to iterate from the start letter to the\\n  end letter .\\n  Within the inner loop iterate from the start number to the end\\n  number.\\n  Once the loop is underway. Manipulate the data into the\\n  requred form. ie: [ \"K1\", \"K2\", \"L1\", \"L2\"]\\n  Some flattening may be required too.\\n\\n  \"\"\"\\n  @spec cells_in_range(s :: String.t()) :: [String.t()]\\n  def cells_in_range(s) do\\n    start_ascii_value =   String.at(s, 0) |> :binary.first\\n    end_ascii_value = String.at(s,3) |> :binary.first\\n\\n    start_number = String.at(s, 1) |> String.to_integer\\n    end_number = String.at(s, 4) |> String.to_integer\\n\\n    # loop from start_ascii_value to end_ascii_value\\n    result =\\n      for o_val <- start_ascii_value..end_ascii_value do\\n        o_letter = <<o_val::utf8>>\\n        for in_num <- start_number..end_number do\\n          exp = o_letter <> Integer.to_string(in_num)\\n        end\\n      end\\n\\n    result |> List.flatten\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4042906,
                "title": "solution-using-product-and-ord",
                "content": "\\n\\n# Code\\n```\\nfrom itertools import product\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        cols=[]\\n        nums=[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            cols.append(chr(i))\\n        for j in range(int(s[1]),int(s[4])+1):\\n            nums.append(j)\\n        return [a+str(b) for a,b in list(product(cols,nums))]\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import product\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        cols=[]\\n        nums=[]\\n        for i in range(ord(s[0]),ord(s[3])+1):\\n            cols.append(chr(i))\\n        for j in range(int(s[1]),int(s[4])+1):\\n            nums.append(j)\\n        return [a+str(b) for a,b in list(product(cols,nums))]\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039418,
                "title": "check-this-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> s1; \\n            \\n            int row1 =  s[1] - \\'0\\';\\n            int row2 = s[4]- \\'0\\';\\n            char strtCol = s[0]  ;\\n            char endCol = s[3] ;\\n            char k = \\'k\\';\\n            char l = \\'1\\';\\n            cout << k <<  l ;\\n            \\n            for(char j = strtCol ; j <= endCol ; j++){\\n                for( int i = row1 ; i <= row2 ; i++ ){\\n                    \\n                    string temp = \"\";\\n                    string ch = to_string(i);\\n                    temp += j;\\n                    temp += ch;\\n                    s1.push_back(temp);\\n                }\\n\\n            }\\n        return s1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        vector<string> s1; \\n            \\n            int row1 =  s[1] - \\'0\\';\\n            int row2 = s[4]- \\'0\\';\\n            char strtCol = s[0]  ;\\n            char endCol = s[3] ;\\n            char k = \\'k\\';\\n            char l = \\'1\\';\\n            cout << k <<  l ;\\n            \\n            for(char j = strtCol ; j <= endCol ; j++){\\n                for( int i = row1 ; i <= row2 ; i++ ){\\n                    \\n                    string temp = \"\";\\n                    string ch = to_string(i);\\n                    temp += j;\\n                    temp += ch;\\n                    s1.push_back(temp);\\n                }\\n\\n            }\\n        return s1 ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4037232,
                "title": "very-easy-to-understand-please-upvote-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char c1= s[0];\\n        char c2= s[3];\\n        int r1= s[1]-\\'0\\';\\n        int r2= s[4]-\\'0\\';\\n\\n        vector<string>ans;\\n        for(char i=c1;i<=c2;i++)\\n        {\\n            for(int j=r1;j<=r2;j++)\\n            {\\n                string res=\"\";\\n                res=res+i;\\n                res=res+ to_string(j);\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        char c1= s[0];\\n        char c2= s[3];\\n        int r1= s[1]-\\'0\\';\\n        int r2= s[4]-\\'0\\';\\n\\n        vector<string>ans;\\n        for(char i=c1;i<=c2;i++)\\n        {\\n            for(int j=r1;j<=r2;j++)\\n            {\\n                string res=\"\";\\n                res=res+i;\\n                res=res+ to_string(j);\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036357,
                "title": "easy-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {\\n        int start=stoi(s.substr(1,2));\\n        int end=stoi(s.substr(4,5));\\n        char st=s[0];\\n        char en=s[3];\\n        vector<string> ans;\\n        for(char f=st;f<=en;f++)\\n        {\\n            for(int i=start;i<=end;i++)\\n            {\\n                string y=f+to_string(i);\\n                ans.push_back(y);\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) \\n    {\\n        int start=stoi(s.substr(1,2));\\n        int end=stoi(s.substr(4,5));\\n        char st=s[0];\\n        char en=s[3];\\n        vector<string> ans;\\n        for(char f=st;f<=en;f++)\\n        {\\n            for(int i=start;i<=end;i++)\\n            {\\n                string y=f+to_string(i);\\n                ans.push_back(y);\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031451,
                "title": "simple-python-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially I\\'d thought to convert the cell column titles from letters to their `int` counterparts, but after remembering that would merely be\\n```py\\n# Assuming `c` as the column title being converted.\\nord(\\'A\\') - ord(c) + 1\\n```\\nI then opted to instead used a ranged for loop over the ASCII values of each letter. This solution works since we are guaranteed that the column titles $$C$$ will follow the bounds $$\\\\forall c; c\\\\in C.\\\\ \\\\text{\\'A\\'}\\\\leq c\\\\leq\\\\text{\\'Z\\'}$$. Had this restriction not been applied, then conversion would have been neccessary.\\n\\nThis then meant that solving this problem would be as simple as using two ranged loops nested within each other.\\n\\n# Complexity\\n- Time complexity: Technically $$O(n^2)$$ or $$O(c\\\\cdot r)$$ where $$c$$ is the range of columns and $$r$$ is the range of rows. Could also be seen as $$O(n)$$ where $$n$$ is the number of rows since the columns are limited to 26--a constant value which may then be omitted.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        cells = []\\n        c1, r1, _, c2, r2 = list(s)\\n        for c in range(ord(c1), ord(c2) + 1):\\n            for r in range(int(r1), int(r2) + 1):\\n                cells.append(f\"{chr(c)}{str(r)}\")\\n        return cells\\n\\n```\\n\\n**Note: Looking back, I could have omitted** `str(r)` **for just** `r`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\n# Assuming `c` as the column title being converted.\\nord(\\'A\\') - ord(c) + 1\\n```\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        cells = []\\n        c1, r1, _, c2, r2 = list(s)\\n        for c in range(ord(c1), ord(c2) + 1):\\n            for r in range(int(r1), int(r2) + 1):\\n                cells.append(f\"{chr(c)}{str(r)}\")\\n        return cells\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030625,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s)\\n    {\\n      IList<string> myList = new List<string> { };\\n      for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n          myList.Add($\"{c}{r}\");\\n\\n      foreach (var i in myList) Console.WriteLine(i);\\n      return myList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> CellsInRange(string s)\\n    {\\n      IList<string> myList = new List<string> { };\\n      for (char c = s[0]; c <= s[3]; ++c)\\n        for (char r = s[1]; r <= s[4]; ++r)\\n          myList.Add($\"{c}{r}\");\\n\\n      foreach (var i in myList) Console.WriteLine(i);\\n      return myList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028714,
                "title": "o-n-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    // TC: O(n)\\n    // SC: O(n)\\n    public List<String> cellsInRange(String s) {\\n        List<String> li = new ArrayList<>();\\n        char leftCol = s.charAt(0);\\n        char rightCol = s.charAt(3);\\n        char leftRow = s.charAt(1);\\n        char rightRow = s.charAt(4);\\n        \\n        for(char c=leftCol;c<=rightCol;c++){\\n            for(char r=leftRow;r<=rightRow;r++){\\n                li.add(c+\"\"+r);\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // TC: O(n)\\n    // SC: O(n)\\n    public List<String> cellsInRange(String s) {\\n        List<String> li = new ArrayList<>();\\n        char leftCol = s.charAt(0);\\n        char rightCol = s.charAt(3);\\n        char leftRow = s.charAt(1);\\n        char rightRow = s.charAt(4);\\n        \\n        for(char c=leftCol;c<=rightCol;c++){\\n            for(char r=leftRow;r<=rightRow;r++){\\n                li.add(c+\"\"+r);\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023330,
                "title": "just-1-line-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]),ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        return [chr(c)+str(r) for c in range(ord(s[0]),ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019477,
                "title": "max-min-row-easy-approach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n\\n        int rmax=Math.max(s.charAt(1)-\\'0\\',s.charAt(4)-\\'0\\');\\n        int rmin=Math.min(s.charAt(1)-\\'0\\',s.charAt(4)-\\'0\\');\\n\\n        List<String> list=new ArrayList<>();\\n\\n        for(char col=s.charAt(0);col<=s.charAt(3);col++){\\n            for(int row=rmin;row<=rmax;row++){\\n                list.add(col+\"\"+row);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n\\n        int rmax=Math.max(s.charAt(1)-\\'0\\',s.charAt(4)-\\'0\\');\\n        int rmin=Math.min(s.charAt(1)-\\'0\\',s.charAt(4)-\\'0\\');\\n\\n        List<String> list=new ArrayList<>();\\n\\n        for(char col=s.charAt(0);col<=s.charAt(3);col++){\\n            for(int row=rmin;row<=rmax;row++){\\n                list.add(col+\"\"+row);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017355,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        ArrayList<String> arr=new ArrayList<String>();\\n        char c1=s.charAt(0);\\n        char c2=s.charAt(3);\\n        int n1=s.charAt(1)-\\'0\\';\\n        int n2=s.charAt(4)-\\'0\\';\\n        for(char i=c1;i<=c2;i++){\\n            for(int j=n1;j<=n2;j++){\\n            arr.add(i+\"\"+(char)(j+\\'0\\'));\\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> cellsInRange(String s) {\\n        ArrayList<String> arr=new ArrayList<String>();\\n        char c1=s.charAt(0);\\n        char c2=s.charAt(3);\\n        int n1=s.charAt(1)-\\'0\\';\\n        int n2=s.charAt(4)-\\'0\\';\\n        for(char i=c1;i<=c2;i++){\\n            for(int j=n1;j<=n2;j++){\\n            arr.add(i+\"\"+(char)(j+\\'0\\'));\\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017140,
                "title": "faster-99-02-by-using-javascript-accessible",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    var res = new Array();\\n    for(let i = s[0].charCodeAt(0); i <= s[3].charCodeAt(0); i++){\\n        for(let j = s[1].charCodeAt(0); j <= s[4].charCodeAt(0); j++){\\n            res.push(String.fromCharCode(i) + String.fromCharCode(j));\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar cellsInRange = function(s) {\\n    var res = new Array();\\n    for(let i = s[0].charCodeAt(0); i <= s[3].charCodeAt(0); i++){\\n        for(let j = s[1].charCodeAt(0); j <= s[4].charCodeAt(0); j++){\\n            res.push(String.fromCharCode(i) + String.fromCharCode(j));\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015474,
                "title": "harshi-s-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int l=s[1],h=s[4];\\n        int a=s[0],b=s[3];\\n        vector<string> v;\\n        for(int i=a;i<=b;i++){\\n            for(int j=l;j<=h;j++){\\n                string k=\"\";\\n                k=k+char(i);\\n                k+=j;\\n                v.push_back(k);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> cellsInRange(string s) {\\n        int l=s[1],h=s[4];\\n        int a=s[0],b=s[3];\\n        vector<string> v;\\n        for(int i=a;i<=b;i++){\\n            for(int j=l;j<=h;j++){\\n                string k=\"\";\\n                k=k+char(i);\\n                k+=j;\\n                v.push_back(k);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014766,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        chars = [s[0],s[-2]]\\n        nums = [s[1], s[-1]]\\n\\n        res = []\\n\\n        currchar = chars[0]\\n        endchar = chars[1] \\n        \\n        while ord(currchar) != ord(endchar) + 1:\\n            for i in range(int(nums[0]), int(nums[1])+ 1):\\n                res.append(currchar + str(i))\\n            i = ord(currchar)\\n            i = i + 1\\n            currchar = chr(i)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        chars = [s[0],s[-2]]\\n        nums = [s[1], s[-1]]\\n\\n        res = []\\n\\n        currchar = chars[0]\\n        endchar = chars[1] \\n        \\n        while ord(currchar) != ord(endchar) + 1:\\n            for i in range(int(nums[0]), int(nums[1])+ 1):\\n                res.append(currchar + str(i))\\n            i = ord(currchar)\\n            i = i + 1\\n            currchar = chr(i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007521,
                "title": "straight-forward-o-n-m-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        rows = ord(s[3]) - ord(s[0]) + 1 \\n        cols = int(s[4]) - int(s[1]) + 1\\n        \\n        res = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                char = chr(ord(s[0]) + i)\\n                num = str(int(s[1]) + j)\\n                res.append(char + num)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cellsInRange(self, s: str) -> List[str]:\\n        rows = ord(s[3]) - ord(s[0]) + 1 \\n        cols = int(s[4]) - int(s[1]) + 1\\n        \\n        res = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                char = chr(ord(s[0]) + i)\\n                num = str(int(s[1]) + j)\\n                res.append(char + num)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1679654,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "honestly, it felt like you know how to solve but you don\\'t know how to write the code.. sometimes it is what it is. let\\'s keep learning"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "The steps i took to solve this problem:\\n\\n-Create a list of letters starting at s[0] and ending at s[-2]\\n\\n-Loop through list\\n-Inner loop for numerical value, starting at s[1] and ending at s[-1]+1\\n-Append both letter and number to answer list \\n-return list \\n\\n:)"
                    },
                    {
                        "username": "jordwang",
                        "content": "Don\\'t you know how to read? it says no ANSWER in this discussion and yet you wrote it, does it make you feel better?... pathetic"
                    }
                ]
            },
            {
                "id": 1713985,
                "content": [
                    {
                        "username": "Bobzero",
                        "content": "honestly, it felt like you know how to solve but you don\\'t know how to write the code.. sometimes it is what it is. let\\'s keep learning"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "The steps i took to solve this problem:\\n\\n-Create a list of letters starting at s[0] and ending at s[-2]\\n\\n-Loop through list\\n-Inner loop for numerical value, starting at s[1] and ending at s[-1]+1\\n-Append both letter and number to answer list \\n-return list \\n\\n:)"
                    },
                    {
                        "username": "jordwang",
                        "content": "Don\\'t you know how to read? it says no ANSWER in this discussion and yet you wrote it, does it make you feel better?... pathetic"
                    }
                ]
            }
        ]
    },
    {
        "title": "Distance to a Cycle in Undirected Graph",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1687653,
                "content": [
                    {
                        "username": "opringle",
                        "content": "I believe variable edges in example 1 is incorrect. Shouldn\\'t it be [[0, 1],[1, 2],[2,4],[1,3],[3,4],[2,5],[6,5]] ? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Health to Beat Game",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1644233,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748885,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1750155,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748119,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1749178,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748348,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748110,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1706120,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 2034790,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1757968,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1644233,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748885,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1750155,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748119,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1749178,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748348,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1748110,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1706120,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 2034790,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            },
            {
                "id": 1757968,
                "content": [
                    {
                        "username": "some_dude_2020",
                        "content": "why is this even a medium?\\n\\nThe logic seems quite easy"
                    },
                    {
                        "username": "ajesk",
                        "content": "I think it is definitely a mis-categorized problem. The only reason I would guess why it remains medium is because of the wordy description that could make it seem harder than it actually is. Still should be an easy at most."
                    },
                    {
                        "username": "cswartzell",
                        "content": "This has GOT to be the easiest medium on leetcode"
                    },
                    {
                        "username": "BristolJ",
                        "content": "don\\'t be like me. pay attention to return types"
                    },
                    {
                        "username": "tahakothawala",
                        "content": "saved my day!!"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As per [**constraints**](https://leetcode.com/problems/minimum-health-to-beat-game/description/)\\n- $1 \\\\leq \\\\text{damage.length} \\\\leq 10^5$\\n- $0 \\\\leq \\\\text{damage[i]} \\\\leq 10^5$\\n\\nThus, if anyone is planning to add all damages, please note that maximum sum can be $10^{10}$. So, make sure you take necessary steps to prevent overflow."
                    },
                    {
                        "username": "kaichamp101",
                        "content": "Definitely not a medium!"
                    },
                    {
                        "username": "mx64",
                        "content": "Is this test case correct? \\ndamage: [3]\\narmor: 1\\n\\nExpected output: 3\\n\\nBut, for the following input, the expected output is 4:\\ndamage [3]\\narmor: 0\\n"
                    },
                    {
                        "username": "mx64",
                        "content": "Thanks for the clarification -- I didn\\'t read carefully this paragraph\\n```\\nYou are also given an integer armor. You may use your armor ability at most once during the game on any level which will protect you from at most armor damage.\\n````\\n\\nExamples were not the most intuitive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Yes. Expected Output is correct\n\n- Starting with 3 health, at level 0 in `[3]`, we can use armor 1, and thus to complete level we have to lose 2 health. Therefore, after completing level, our health will be 1 which is positive.\n- Starting with 4 health, we don't have any armor, and to complete level we have to lose 3 health for `[3]`. Therefore, after completing level, our health will be 1 which is positive."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "Why **Prefix Sum** under $\\\\text{Related Topics}$ in [Problem Description](https://leetcode.com/problems/minimum-health-to-beat-game/description/)?"
                    },
                    {
                        "username": "zoeysun0617",
                        "content": "I understand using DP will get you the min health at all levels, but this is leet code ok we are simply solving the given problem. All that is needed is to find the max damage level and apply armor to that level. "
                    },
                    {
                        "username": "san70sh",
                        "content": "Is it just me who thought armor increases your health?"
                    },
                    {
                        "username": "SchmendrickTheMagician",
                        "content": "This one should be an easy I think. The logic is straightforward, and I don\\'t think the overflow cases are enough to qualify it as a medium."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Operations to Convert Time",
        "question_content": "<p>You are given two strings <code>current</code> and <code>correct</code> representing two <strong>24-hour times</strong>.</p>\n\n<p>24-hour times are formatted as <code>&quot;HH:MM&quot;</code>, where <code>HH</code> is between <code>00</code> and <code>23</code>, and <code>MM</code> is between <code>00</code> and <code>59</code>. The earliest 24-hour time is <code>00:00</code>, and the latest is <code>23:59</code>.</p>\n\n<p>In one operation you can increase the time <code>current</code> by <code>1</code>, <code>5</code>, <code>15</code>, or <code>60</code> minutes. You can perform this operation <strong>any</strong> number of times.</p>\n\n<p>Return <em>the <strong>minimum number of operations</strong> needed to convert </em><code>current</code><em> to </em><code>correct</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> current = &quot;02:30&quot;, correct = &quot;04:35&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:\n</strong>We can convert current to correct in 3 operations as follows:\n- Add 60 minutes to current. current becomes &quot;03:30&quot;.\n- Add 60 minutes to current. current becomes &quot;04:30&quot;.\n- Add 5 minutes to current. current becomes &quot;04:35&quot;.\nIt can be proven that it is not possible to convert current to correct in fewer than 3 operations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> current = &quot;11:00&quot;, correct = &quot;11:01&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We only have to add one minute to current, so the minimum number of operations needed is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>current</code> and <code>correct</code> are in the format <code>&quot;HH:MM&quot;</code></li>\n\t<li><code>current &lt;= correct</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1908782,
                "title": "c-greedy",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Greedy\\n\\n* Compute the time difference in seconds\\n* Greedily using `60, 15, 5, 1` operations. For each operation `op`, we use `diff / op` number of operations to turn `diff` to `diff % op`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/minimum-number-of-operations-to-convert-time/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\n    int getTime(string &s) {\\n        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n    }\\npublic:\\n    int convertTime(string current, string correct) {\\n        int diff = getTime(correct) - getTime(current), ops[4] = {60,15,5,1}, ans = 0;\\n        for (int op : ops) {\\n            ans += diff / op;\\n            diff %= op;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/minimum-number-of-operations-to-convert-time/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\n    int getTime(string &s) {\\n        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n    }\\npublic:\\n    int convertTime(string current, string correct) {\\n        int diff = getTime(correct) - getTime(current), ops[4] = {60,15,5,1}, ans = 0;\\n        for (int op : ops) {\\n            ans += diff / op;\\n            diff %= op;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908779,
                "title": "convert-to-minutes",
                "content": "Since we can only add minutes, the greedy approach would work.\\n\\n**C++**\\n```cpp    \\nint convertTime(string current, string correct) {\\n    auto toMin = [](string &s) { \\n \\xA0 \\xA0 \\xA0 \\xA0return s[0] * 600 + s[1] * 60 + s[3] * 10 + s[4] ;\\n    };\\n    int d = toMin(correct) - toMin(current);\\n    return d / 60 + d % 60 / 15 + d % 15 / 5 + d % 5;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp    \\nint convertTime(string current, string correct) {\\n    auto toMin = [](string &s) { \\n \\xA0 \\xA0 \\xA0 \\xA0return s[0] * 600 + s[1] * 60 + s[3] * 10 + s[4] ;\\n    };\\n    int d = toMin(correct) - toMin(current);\\n    return d / 60 + d % 60 / 15 + d % 15 / 5 + d % 5;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908786,
                "title": "easy-python-solution-convert-time-to-minutes",
                "content": "1. Convert times into minutes and then the problem becomes simpler. \\n2. To minimize the number of total operations we try to use the largest possible change from `[60,15,5,1]` till possible.\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current_time = 60 * int(current[0:2]) + int(current[3:5]) # Current time in minutes\\n        target_time = 60 * int(correct[0:2]) + int(correct[3:5]) # Target time in minutes\\n        diff = target_time - current_time # Difference b/w current and target times in minutes\\n        count = 0 # Required number of operations\\n\\t\\t# Use GREEDY APPROACH to calculate number of operations\\n        for i in [60, 15, 5, 1]:\\n            count += diff // i # add number of operations needed with i to count\\n            diff %= i # Diff becomes modulo of diff with i\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current_time = 60 * int(current[0:2]) + int(current[3:5]) # Current time in minutes\\n        target_time = 60 * int(correct[0:2]) + int(correct[3:5]) # Target time in minutes\\n        diff = target_time - current_time # Difference b/w current and target times in minutes\\n        count = 0 # Required number of operations\\n\\t\\t# Use GREEDY APPROACH to calculate number of operations\\n        for i in [60, 15, 5, 1]:\\n            count += diff // i # add number of operations needed with i to count\\n            diff %= i # Diff becomes modulo of diff with i\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908985,
                "title": "java-loop-easy-to-understand",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. Convert both **current time** and **correct time** into **minutes**.\\n2. **Increase** **current time** by 60min until it becomes **just less or equal to correct time**.\\n3. Similarly do the **same thing** with 15min, 5min, and 1min window.\\n4. Count the **number of iterations** performed.\\n5. Return the number of iterations.\\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        String[] curr = current.split(\":\");\\n        String[] corr = correct.split(\":\");\\n        int cur = Integer.parseInt(curr[0]) * 60 + Integer.parseInt(curr[1]);\\n        int cor = Integer.parseInt(corr[0]) * 60 + Integer.parseInt(corr[1]);\\n        int count = 0;\\n        \\n        while(cur + 60 <= cor) {\\n            ++count;\\n            cur += 60;\\n        }\\n        \\n         while(cur + 15 <= cor) {\\n            ++count;\\n            cur += 15;\\n        }\\n        \\n         while(cur + 5 <= cor) {\\n            ++count;\\n            cur += 5;\\n        }\\n        \\n         while(cur + 1 <= cor) {\\n            ++count;\\n            cur += 1;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(c) // c some constant value <= 100\\nSpace Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        String[] curr = current.split(\":\");\\n        String[] corr = correct.split(\":\");\\n        int cur = Integer.parseInt(curr[0]) * 60 + Integer.parseInt(curr[1]);\\n        int cor = Integer.parseInt(corr[0]) * 60 + Integer.parseInt(corr[1]);\\n        int count = 0;\\n        \\n        while(cur + 60 <= cor) {\\n            ++count;\\n            cur += 60;\\n        }\\n        \\n         while(cur + 15 <= cor) {\\n            ++count;\\n            cur += 15;\\n        }\\n        \\n         while(cur + 5 <= cor) {\\n            ++count;\\n            cur += 5;\\n        }\\n        \\n         while(cur + 1 <= cor) {\\n            ++count;\\n            cur += 1;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```\n```\\nTime Complexity: O(c) // c some constant value <= 100\\nSpace Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909089,
                "title": "short-java-5-lines",
                "content": "```java\\n public int convertTime(String current, String correct){\\n        Function<String, Integer> parse = t -> Integer.parseInt(t.substring(0, 2)) * 60 + Integer.parseInt(t.substring(3));\\n        int diff = parse.apply(correct) - parse.apply(current), ops[] = {60, 15, 5, 1}, r = 0;\\n        for(int i = 0; i < ops.length && diff > 0; diff = diff % ops[i++])\\n            r += diff / ops[i];\\n        return r;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n public int convertTime(String current, String correct){\\n        Function<String, Integer> parse = t -> Integer.parseInt(t.substring(0, 2)) * 60 + Integer.parseInt(t.substring(3));\\n        int diff = parse.apply(correct) - parse.apply(current), ops[] = {60, 15, 5, 1}, r = 0;\\n        for(int i = 0; i < ops.length && diff > 0; diff = diff % ops[i++])\\n            r += diff / ops[i];\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1909350,
                "title": "c-solution-0ms-100-faster",
                "content": "\"\"\"\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hour1=(current[0]-\\'0\\')*10+(current[1]-\\'0\\');\\n        int hour2=(correct[0]-\\'0\\')*10+(correct[1]-\\'0\\');\\n        int minute1=(current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n        int minute2=(correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n        \\n        int total=(hour2-hour1)*60+ (minute2-minute1);\\n        int res=0;\\n        if(total>=60){\\n            int temp=(total/60);\\n            total-=(temp*60);\\n            res+=temp;\\n        }\\n        if(total>=15){\\n            int temp=(total/15);\\n            total-=(temp*15);\\n            res+=temp;\\n        }\\n        if(total>=5){\\n            int temp=(total/5);\\n            total-=(temp*5);\\n            res+=temp;\\n        }\\n        res+=total;\\n        return res;\\n    }\\n};\\n\"\"\"\\n\\tPlease Upvote if you Find it Helpful \\uD83D\\uDE42.",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hour1=(current[0]-\\'0\\')*10+(current[1]-\\'0\\');\\n        int hour2=(correct[0]-\\'0\\')*10+(correct[1]-\\'0\\');\\n        int minute1=(current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n        int minute2=(correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n        \\n        int total=(hour2-hour1)*60+ (minute2-minute1);\\n        int res=0;\\n        if(total>=60){\\n            int temp=(total/60);\\n            total-=(temp*60);\\n            res+=temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1909169,
                "title": "c-greedy-convert-to-minutes",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string co) {\\n        \\n        string h1=\"\";\\n        string m1=\"\";\\n        string h2=\"\";\\n        string m2=\"\";\\n        \\n        h1+=current[0];\\n        h1+=current[1];\\n        \\n        m1+=current[3];\\n        m1+=current[4];\\n        \\n        h2+=co[0];\\n        h2+=co[1];\\n        \\n        m2+=co[3];\\n        m2+=co[4];\\n        \\n        \\n        int min1=stoi(h1)*60+stoi(m1);\\n        int min2=stoi(h2)*60+stoi(m2);\\n        \\n       // int x=min2-min1;\\n        int count=0;\\n        \\n        while(min2>min1){\\n            \\n            if((min2-min1)>=60){\\n                min1=min1+60;\\n                count++;\\n            }\\n            else if((min2-min1)>=15){\\n                min1=min1+15;\\n                count++;\\n            }\\n            else if((min2-min1)>=5){\\n                min1=min1+5;\\n                count++;\\n            }\\n            else {\\n                count+=(min2-min1);\\n                min1=min1+(min2-min1);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string co) {\\n        \\n        string h1=\"\";\\n        string m1=\"\";\\n        string h2=\"\";\\n        string m2=\"\";\\n        \\n        h1+=current[0];\\n        h1+=current[1];\\n        \\n        m1+=current[3];\\n        m1+=current[4];\\n        \\n        h2+=co[0];\\n        h2+=co[1];\\n        \\n        m2+=co[3];\\n        m2+=co[4];\\n        \\n        \\n        int min1=stoi(h1)*60+stoi(m1);\\n        int min2=stoi(h2)*60+stoi(m2);\\n        \\n       // int x=min2-min1;\\n        int count=0;\\n        \\n        while(min2>min1){\\n            \\n            if((min2-min1)>=60){\\n                min1=min1+60;\\n                count++;\\n            }\\n            else if((min2-min1)>=15){\\n                min1=min1+15;\\n                count++;\\n            }\\n            else if((min2-min1)>=5){\\n                min1=min1+5;\\n                count++;\\n            }\\n            else {\\n                count+=(min2-min1);\\n                min1=min1+(min2-min1);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908920,
                "title": "cpp-easy-greedy-explained-faster-than-100",
                "content": "```\\n1. extract the hours and minutes from both the strings\\n2. convert the strings to numbers\\n3. convert both time time to minutes.\\n4. calculate the minutes difference.\\n5. simply check minimum operations to make minutes equal to difference.\\nclass Solution {\\npublic:\\n    int convertTime(string a, string b) {\\n        int x=a[0]-\\'0\\',y=a[1]-\\'0\\',z=a[3]-\\'0\\',w=a[4]-\\'0\\';\\n        int p=b[0]-\\'0\\',q=b[1]-\\'0\\',r=b[3]-\\'0\\',s=b[4]-\\'0\\';\\n        int hr1 = (x)*10+(y);\\n        int m1 = (z)*10+(w);\\n        int hr2 = (p)*10+(q);\\n        int m2 = (r)*10+s;\\n        int num1 = hr1*60+m1;\\n        int num2 = hr2*60+m2;\\n        int diff = num2-num1;\\n        int res=0;\\n        int arr[4]={60,15,5,1};\\n        for(int i=0;i<4;i++){\\n            res+=diff/arr[i];\\n            diff = diff%arr[i];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int convertTime(string a, string b) {\\n        int x=a[0]-\\'0\\',y=a[1]-\\'0\\',z=a[3]-\\'0\\',w=a[4]-\\'0\\';\\n        int p=b[0]-\\'0\\',q=b[1]-\\'0\\',r=b[3]-\\'0\\',s=b[4]-\\'0\\';\\n        int hr1 = (x)*10+(y);\\n        int m1 = (z)*10+(w);\\n        int hr2 = (p)*10+(q);\\n        int m2 = (r)*10+s;\\n        int num1 = hr1*60+m1;\\n        int num2 = hr2*60+m2;\\n        int diff = num2-num1;\\n        int res=0;\\n        int arr[4]={60,15,5,1}",
                "codeTag": "Java"
            },
            {
                "id": 3657266,
                "title": "python-3-convert-to-minutes-and-find-parts-using-divmod-beats-85",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h, m = s.split(\\':\\')\\n            return 60 * int(h) + int(m)\\n        \\n        minutes = toMinutes(correct) - toMinutes(current)\\n        hours, minutes = divmod(minutes, 60)\\n        quaters, minutes = divmod(minutes, 15)\\n        fives, minutes = divmod(minutes, 5)\\n\\n        return hours + quaters + fives + minutes\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h, m = s.split(\\':\\')\\n            return 60 * int(h) + int(m)\\n        \\n        minutes = toMinutes(correct) - toMinutes(current)\\n        hours, minutes = divmod(minutes, 60)\\n        quaters, minutes = divmod(minutes, 15)\\n        fives, minutes = divmod(minutes, 5)\\n\\n        return hours + quaters + fives + minutes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924690,
                "title": "javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst convertTime = (current, correct) => {\\n    if (current === correct) return 0\\n\\t\\n    let count = 0\\n    let currentInMins = parseInt(current.slice(3)) + parseInt(current.slice(0, 2)) * 60\\n    let correcttInMins = parseInt(correct.slice(3)) + parseInt(correct.slice(0, 2)) * 60\\n    let minuteDifference = correcttInMins - currentInMins\\n\\n    while (minuteDifference !== 0) {\\n        if (minuteDifference % 60 === 0) {\\n            minuteDifference -= 60\\n            count++\\n        }\\n        else if (minuteDifference % 15 === 0) {\\n            minuteDifference -= 15\\n            count++\\n        }\\n        else if (minuteDifference % 5 === 0) {\\n            minuteDifference -= 5\\n            count++\\n        }\\n        else{\\n            minuteDifference -= 1\\n            count++\\n        }\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst convertTime = (current, correct) => {\\n    if (current === correct) return 0\\n\\t\\n    let count = 0\\n    let currentInMins = parseInt(current.slice(3)) + parseInt(current.slice(0, 2)) * 60\\n    let correcttInMins = parseInt(correct.slice(3)) + parseInt(correct.slice(0, 2)) * 60\\n    let minuteDifference = correcttInMins - currentInMins\\n\\n    while (minuteDifference !== 0) {\\n        if (minuteDifference % 60 === 0) {\\n            minuteDifference -= 60\\n            count++\\n        }\\n        else if (minuteDifference % 15 === 0) {\\n            minuteDifference -= 15\\n            count++\\n        }\\n        else if (minuteDifference % 5 === 0) {\\n            minuteDifference -= 5\\n            count++\\n        }\\n        else{\\n            minuteDifference -= 1\\n            count++\\n        }\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908764,
                "title": "intutive-easytounderstand-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int curr_hour = stoi(current.substr(0,2));\\n        int curr_min  = stoi(current.substr(3,2));\\n        int co_hour = stoi(correct.substr(0,2));\\n        int co_min  = stoi(correct.substr(3,2));\\n        \\n       \\n        int h_diff = co_hour - curr_hour;\\n        int min_diff = co_min - curr_min;\\n        \\n        int total = h_diff*60 + min_diff;   //Calculate The Total Minutes\\n        vector<int>time{1,5,15,60};\\n        \\n        int op = 0;                                    // Perform the Greedy Operation\\n        for(int i = time.size() -1;i>=0;i--){\\n            if(total >= time[i] && total >0){\\n                op+=total/time[i]; \\n                total = total%time[i];\\n            }\\n        }\\n       \\n        \\n        \\n        return op;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int curr_hour = stoi(current.substr(0,2));\\n        int curr_min  = stoi(current.substr(3,2));\\n        int co_hour = stoi(correct.substr(0,2));\\n        int co_min  = stoi(correct.substr(3,2));\\n        \\n       \\n        int h_diff = co_hour - curr_hour;\\n        int min_diff = co_min - curr_min;\\n        \\n        int total = h_diff*60 + min_diff;   //Calculate The Total Minutes\\n        vector<int>time{1,5,15,60}",
                "codeTag": "Java"
            },
            {
                "id": 1918848,
                "title": "python-easy",
                "content": "first compute the hour and minute difference\\n\\nif minute difference is negative then we must change the diffs\\n\\nthen greedily subtract the remainder to 15, 5, 1 from minutes.\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        h = int(h2) - int(h1)\\n        m = int(m2) - int(m1)\\n        if m < 0:\\n            h -= 1\\n            m += 60\\n        \\n        a = m // 15\\n        m %= 15\\n        b = m // 5\\n        m %= 5\\n        return h + a + b + m\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        h = int(h2) - int(h1)\\n        m = int(m2) - int(m1)\\n        if m < 0:\\n            h -= 1\\n            m += 60\\n        \\n        a = m // 15\\n        m %= 15\\n        b = m // 5\\n        m %= 5\\n        return h + a + b + m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910157,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        if current == correct {\\n            return 0;\\n        }\\n\\n        let to_num = |s: &str| -> i32 { s.parse().unwrap() };\\n        let (h2, m2) = (to_num(&correct[..2]), to_num(&correct[3..]));\\n        let (h1, m1) = (to_num(&current[..2]), to_num(&current[3..]));\\n\\n        let mut delta = (m2 - m1) + 60 * if h2 >= h1 { h2 - h1 } else { h2 - h1 + 24 };\\n        let mut res = 0;\\n\\n        for op in [60, 15, 5] {\\n            res += delta / op;\\n            delta %= op;\\n        }\\n\\n        res + delta\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        if current == correct {\\n            return 0;\\n        }\\n\\n        let to_num = |s: &str| -> i32 { s.parse().unwrap() };\\n        let (h2, m2) = (to_num(&correct[..2]), to_num(&correct[3..]));\\n        let (h1, m1) = (to_num(&current[..2]), to_num(&current[3..]));\\n\\n        let mut delta = (m2 - m1) + 60 * if h2 >= h1 { h2 - h1 } else { h2 - h1 + 24 };\\n        let mut res = 0;\\n\\n        for op in [60, 15, 5] {\\n            res += delta / op;\\n            delta %= op;\\n        }\\n\\n        res + delta\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909148,
                "title": "javascript-clean-o-n-solution",
                "content": "```\\nvar convertTime = function(current, correct) {\\n    // 1. Seperate current and correct into Hours and Minutes\\n    const currentHoursMins = current.split(\":\");\\n    const correctHoursMins = correct.split(\":\");\\n \\n    // 2. Calculate difference in minutes\\n    let minDifference = ((correctHoursMins[1] - currentHoursMins[1])) + ((correctHoursMins[0] - currentHoursMins[0]) * 60);\\n\\n    // 3. Greedily take the highest minutes to lowest minutes\\n    let operations = 0;\\n    const operationValues = [60, 15, 5, 1] // this format is maintainable and extensible since other values can easily be added\\n    for(const difference of operationValues){\\n        while(minDifference >= difference){\\n            minDifference -= difference;\\n            operations++;\\n        }\\n    }\\n    \\n    return operations;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar convertTime = function(current, correct) {\\n    // 1. Seperate current and correct into Hours and Minutes\\n    const currentHoursMins = current.split(\":\");\\n    const correctHoursMins = correct.split(\":\");\\n \\n    // 2. Calculate difference in minutes\\n    let minDifference = ((correctHoursMins[1] - currentHoursMins[1])) + ((correctHoursMins[0] - currentHoursMins[0]) * 60);\\n\\n    // 3. Greedily take the highest minutes to lowest minutes\\n    let operations = 0;\\n    const operationValues = [60, 15, 5, 1] // this format is maintainable and extensible since other values can easily be added\\n    for(const difference of operationValues){\\n        while(minDifference >= difference){\\n            minDifference -= difference;\\n            operations++;\\n        }\\n    }\\n    \\n    return operations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908979,
                "title": "python-convert-to-minutes",
                "content": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n\\tans = 0\\n\\th, m = list(map(int, current.split(\\':\\')))\\n\\tnewH, newM = list(map(int, correct.split(\\':\\')))\\n\\td = 60*(newH - h) + newM - m\\n\\tfor x in [60, 15, 5, 1]:\\n\\t\\tans += d//x\\n\\t\\td %= x\\n\\treturn ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n\\tans = 0\\n\\th, m = list(map(int, current.split(\\':\\')))\\n\\tnewH, newM = list(map(int, correct.split(\\':\\')))\\n\\td = 60*(newH - h) + newM - m\\n\\tfor x in [60, 15, 5, 1]:\\n\\t\\tans += d//x\\n\\t\\td %= x\\n\\treturn ans \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1908895,
                "title": "javascript-greedy-84ms",
                "content": "Main idea: calculate minute difference, and divide 60, 15, 5, 1 respectively\\n```\\nconst convertTime = (s, t) => {\\n    let [hs, ms] = op(s), [ht, mt] = op(t);\\n    let diff = Math.abs(hs * 60 + ms - (ht * 60 + mt));\\n    let res = 0;\\n    res += parseInt(diff / 60);\\n    diff %= 60;\\n    res += parseInt(diff / 15);\\n    diff %= 15;\\n    res += parseInt(diff / 5);\\n    diff %= 5;\\n    return res + diff; // finally diff will be in range [0, 4], use all 1\\n};\\n\\nconst op = (s) => {\\n    let a = s.split(\":\").map(Number);\\n    return a;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst convertTime = (s, t) => {\\n    let [hs, ms] = op(s), [ht, mt] = op(t);\\n    let diff = Math.abs(hs * 60 + ms - (ht * 60 + mt));\\n    let res = 0;\\n    res += parseInt(diff / 60);\\n    diff %= 60;\\n    res += parseInt(diff / 15);\\n    diff %= 15;\\n    res += parseInt(diff / 5);\\n    diff %= 5;\\n    return res + diff; // finally diff will be in range [0, 4], use all 1\\n};\\n\\nconst op = (s) => {\\n    let a = s.split(\":\").map(Number);\\n    return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832399,
                "title": "pyrhon3-simple-beats-99-30-explained",
                "content": "The following code beats 99.30 % of python3 submissions\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        diff=(int(correct[:2])*60)+int(correct[3:])-((int(current[:2])*60)+int(current[3:]))\\n        count=0\\n        while diff!=0:\\n            if diff>=60:\\n                diff-=60\\n                count+=1\\n            elif diff>=15:\\n                diff-=15\\n                count+=1\\n            elif diff>=5:\\n                diff-=5\\n                count+=1\\n            else:\\n                diff-=1\\n                count+=1\\n        return count\\n```\\nExplanation\\nFirst we convert both the \\'times\\' into minutes by slicing the first 2 characters of the string and multiplying it by 60 to get the minutes and then adding the last two characters to get the total minutes python\\nAfter doing this we subtract the two \\'times\\' two get the difference\\nNow until the difference becomes 0 we keep subtracting 60 or 15 or 5 or 1 and incrementing the count for each subtraction",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        diff=(int(correct[:2])*60)+int(correct[3:])-((int(current[:2])*60)+int(current[3:]))\\n        count=0\\n        while diff!=0:\\n            if diff>=60:\\n                diff-=60\\n                count+=1\\n            elif diff>=15:\\n                diff-=15\\n                count+=1\\n            elif diff>=5:\\n                diff-=5\\n                count+=1\\n            else:\\n                diff-=1\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651747,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int getTime(string &s) {\\n        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n    }\\npublic:\\n    int convertTime(string current, string correct) {\\n        int diff = getTime(correct) - getTime(current), ops[4] = {60,15,5,1}, ans = 0;\\n        for (int op : ops) {\\n            ans += diff / op;\\n            diff %= op;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int getTime(string &s) {\\n        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n    }\\npublic:\\n    int convertTime(string current, string correct) {\\n        int diff = getTime(correct) - getTime(current), ops[4] = {60,15,5,1}, ans = 0;\\n        for (int op : ops) {\\n            ans += diff / op;\\n            diff %= op;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929316,
                "title": "solution-in-6-languages-o-1-time-and-o-1-space-complexity-0ms-implementation",
                "content": "**Pls upvote(\\uD83E\\uDD7A\\uD83D\\uDE48\\uD83D\\uDE0C). If you found it useful**\\n\\nJust convert time of the day to minutes and iterate over 60,15,5,1 minutes to get the number of ops.\\n\\nPlease suggest any improvements language wise or algorithmwise, im only well verse in c++,golang. I use the rest of languages on need by basis at work.\\n\\nPlease comment if u have any doubts, will be happy to reply\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int HHMMToMinutes(string s){\\n        return stoi(s.substr(0,2))*60 + stoi(s.substr(3,2));\\n    }\\n    int convertTime(string current, string correct) {\\n        int diff = - HHMMToMinutes(current) +  HHMMToMinutes(correct);\\n        vector<int> order = {60,15,5,1};\\n        int i = 0;\\n        int ans = 0;\\n        while(i < 4){\\n            ans+=(diff/order[i]);\\n            diff%=order[i];\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nJava\\n\\n```\\nclass Solution {\\n    public int  HHMMToMinutes(String s){\\n        return Integer.parseInt(s.substring(0,2))*60 + Integer.parseInt(s.substring(3,5)) ;\\n    }\\n    public int convertTime(String current, String correct) {\\n        int diff =  HHMMToMinutes(correct) -  HHMMToMinutes(current);\\n        int[] order = {60,15,5,1};\\n        int i = 0;\\n        int ops = 0;\\n        while(i < 4){\\n            ops+=(diff/order[i]);\\n            diff%=order[i];\\n            i++;\\n        }\\n        return ops;\\n    }\\n}\\n```\\nPython\\n```\\nclass Solution:\\n    def HHMMToMinutes(self, s: str) -> int:\\n        return int(s[0:2])*60 + int(s[3:5])\\n    def convertTime(self, current: str, correct: str) -> int:\\n        diff = self.HHMMToMinutes(correct) - self.HHMMToMinutes(current)\\n        order = [60,15,5,1]\\n        ops = 0\\n        for i in range(0,4):\\n            ops+=int(diff/order[i])\\n            diff%=order[i]\\n        return ops\\n```\\nJavascript\\n\\n```\\nvar getTime = function(time){\\n    var [hrs,mins] = time.split(\":\");\\n    return parseInt(hrs)*60 + parseInt(mins);\\n}\\n\\n\\nvar convertTime = function(current, correct) {\\n    var diff = getTime(correct) - getTime(current);\\n    var order = [60,15,5,1];\\n    var ops = 0;\\n    order.forEach(val =>{\\n        ops+=Math.floor((diff/val));\\n        diff%=val;\\n    })\\n    return ops;\\n};\\n```\\n\\nGolang\\n```\\nimport \"strconv\"\\nfunc HHMMToMinutes(s string) int{\\n    sr := strings.Split(s,\":\")\\n    hrs,_ := strconv.Atoi(sr[0])\\n    minutes,_ := strconv.Atoi(sr[1]) \\n    return  hrs*60 + minutes \\n}\\nfunc convertTime(current string, correct string) int {\\n    diff := HHMMToMinutes(correct) - HHMMToMinutes(current)\\n    order := [4]int{60,15,5,1}\\n    ops := 0\\n    for i := 0 ; i < 4 ; i++ {\\n        ops+=(diff/order[i])\\n        diff%=order[i]\\n    }\\n    return ops\\n}\\n```\\n\\nKotlin\\n```\\nclass Solution {\\n    fun HHMMToMinutes(s: String): Int{\\n        return Integer.parseInt(s.subSequence(0,2).toString())*60+Integer.parseInt(s.subSequence(3,5).toString())\\n    }\\n    fun convertTime(current: String, correct: String): Int {\\n        var diff = HHMMToMinutes(correct) - HHMMToMinutes(current)\\n        var ops = 0\\n        val order = intArrayOf(60,15,5,1)\\n        println(diff)\\n        for(i in 0..3){\\n            ops+=(diff/order[i])\\n            diff%=order[i]\\n        }\\n        return ops\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int HHMMToMinutes(string s){\\n        return stoi(s.substr(0,2))*60 + stoi(s.substr(3,2));\\n    }\\n    int convertTime(string current, string correct) {\\n        int diff = - HHMMToMinutes(current) +  HHMMToMinutes(correct);\\n        vector<int> order = {60,15,5,1};\\n        int i = 0;\\n        int ans = 0;\\n        while(i < 4){\\n            ans+=(diff/order[i]);\\n            diff%=order[i];\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int  HHMMToMinutes(String s){\\n        return Integer.parseInt(s.substring(0,2))*60 + Integer.parseInt(s.substring(3,5)) ;\\n    }\\n    public int convertTime(String current, String correct) {\\n        int diff =  HHMMToMinutes(correct) -  HHMMToMinutes(current);\\n        int[] order = {60,15,5,1};\\n        int i = 0;\\n        int ops = 0;\\n        while(i < 4){\\n            ops+=(diff/order[i]);\\n            diff%=order[i];\\n            i++;\\n        }\\n        return ops;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def HHMMToMinutes(self, s: str) -> int:\\n        return int(s[0:2])*60 + int(s[3:5])\\n    def convertTime(self, current: str, correct: str) -> int:\\n        diff = self.HHMMToMinutes(correct) - self.HHMMToMinutes(current)\\n        order = [60,15,5,1]\\n        ops = 0\\n        for i in range(0,4):\\n            ops+=int(diff/order[i])\\n            diff%=order[i]\\n        return ops\\n```\n```\\nvar getTime = function(time){\\n    var [hrs,mins] = time.split(\":\");\\n    return parseInt(hrs)*60 + parseInt(mins);\\n}\\n\\n\\nvar convertTime = function(current, correct) {\\n    var diff = getTime(correct) - getTime(current);\\n    var order = [60,15,5,1];\\n    var ops = 0;\\n    order.forEach(val =>{\\n        ops+=Math.floor((diff/val));\\n        diff%=val;\\n    })\\n    return ops;\\n};\\n```\n```\\nimport \"strconv\"\\nfunc HHMMToMinutes(s string) int{\\n    sr := strings.Split(s,\":\")\\n    hrs,_ := strconv.Atoi(sr[0])\\n    minutes,_ := strconv.Atoi(sr[1]) \\n    return  hrs*60 + minutes \\n}\\nfunc convertTime(current string, correct string) int {\\n    diff := HHMMToMinutes(correct) - HHMMToMinutes(current)\\n    order := [4]int{60,15,5,1}\\n    ops := 0\\n    for i := 0 ; i < 4 ; i++ {\\n        ops+=(diff/order[i])\\n        diff%=order[i]\\n    }\\n    return ops\\n}\\n```\n```\\nclass Solution {\\n    fun HHMMToMinutes(s: String): Int{\\n        return Integer.parseInt(s.subSequence(0,2).toString())*60+Integer.parseInt(s.subSequence(3,5).toString())\\n    }\\n    fun convertTime(current: String, correct: String): Int {\\n        var diff = HHMMToMinutes(correct) - HHMMToMinutes(current)\\n        var ops = 0\\n        val order = intArrayOf(60,15,5,1)\\n        println(diff)\\n        for(i in 0..3){\\n            ops+=(diff/order[i])\\n            diff%=order[i]\\n        }\\n        return ops\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909822,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nint convertTime(string current, string correct) {\\n        \\n        int hour1 = 0;\\n        \\n        hour1 = hour1 * 10 + current[0] - \\'0\\';\\n        \\n        hour1 = hour1 * 10 + current[1] - \\'0\\';\\n        \\n        int minute1 = 0;\\n        \\n        minute1 = minute1 * 10 + current[3] - \\'0\\';\\n        \\n        minute1 = minute1 * 10 + current[4] - \\'0\\';\\n        \\n        int hour2 = 0;\\n        \\n        hour2 = hour2 * 10 + correct[0] - \\'0\\';\\n        \\n        hour2 = hour2 * 10 + correct[1] - \\'0\\';\\n        \\n        int minute2 = 0;\\n        \\n        minute2 = minute2 * 10 + correct[3] - \\'0\\';\\n        \\n        minute2 = minute2 * 10 + correct[4] - \\'0\\';\\n        \\n        int time1 = hour1 * 60 + minute1;\\n        \\n        int time2 = hour2 * 60 + minute2;\\n        \\n        int count = 0;\\n        \\n        while(time1 + 60 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 60;\\n        }\\n        \\n        while(time1 + 15 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 15;\\n        }\\n        \\n        while(time1 + 5 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 5;\\n        }\\n        \\n        while(time1 + 1 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nint convertTime(string current, string correct) {\\n        \\n        int hour1 = 0;\\n        \\n        hour1 = hour1 * 10 + current[0] - \\'0\\';\\n        \\n        hour1 = hour1 * 10 + current[1] - \\'0\\';\\n        \\n        int minute1 = 0;\\n        \\n        minute1 = minute1 * 10 + current[3] - \\'0\\';\\n        \\n        minute1 = minute1 * 10 + current[4] - \\'0\\';\\n        \\n        int hour2 = 0;\\n        \\n        hour2 = hour2 * 10 + correct[0] - \\'0\\';\\n        \\n        hour2 = hour2 * 10 + correct[1] - \\'0\\';\\n        \\n        int minute2 = 0;\\n        \\n        minute2 = minute2 * 10 + correct[3] - \\'0\\';\\n        \\n        minute2 = minute2 * 10 + correct[4] - \\'0\\';\\n        \\n        int time1 = hour1 * 60 + minute1;\\n        \\n        int time2 = hour2 * 60 + minute2;\\n        \\n        int count = 0;\\n        \\n        while(time1 + 60 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 60;\\n        }\\n        \\n        while(time1 + 15 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 15;\\n        }\\n        \\n        while(time1 + 5 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 5;\\n        }\\n        \\n        while(time1 + 1 <= time2)\\n        {\\n            count++;\\n            \\n            time1 += 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909573,
                "title": "java-time-conversion-new",
                "content": "```\\nclass Solution {\\n    public static int convertTime(String current, String correct) {\\n\\t\\tint start = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3));\\n\\t\\tint goal = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3));\\n\\n//\\t\\tSystem.out.println(start);\\n//\\t\\tSystem.out.println(goal);\\n\\t\\tint count = 0;\\n\\t\\twhile (goal != start) {\\n\\t\\t\\tint diff = goal - start;\\n\\t\\t\\tif (diff >= 60) {\\n\\t\\t\\t\\tgoal = goal - 60;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >= 15) {\\n\\t\\t\\t\\tgoal = goal - 15;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >=5) {\\n\\t\\t\\t\\tgoal = goal - 5;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >= 1) {\\n\\t\\t\\t\\tgoal = goal - 1;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public static int convertTime(String current, String correct) {\\n\\t\\tint start = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3));\\n\\t\\tint goal = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3));\\n\\n//\\t\\tSystem.out.println(start);\\n//\\t\\tSystem.out.println(goal);\\n\\t\\tint count = 0;\\n\\t\\twhile (goal != start) {\\n\\t\\t\\tint diff = goal - start;\\n\\t\\t\\tif (diff >= 60) {\\n\\t\\t\\t\\tgoal = goal - 60;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >= 15) {\\n\\t\\t\\t\\tgoal = goal - 15;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >=5) {\\n\\t\\t\\t\\tgoal = goal - 5;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else if (diff >= 1) {\\n\\t\\t\\t\\tgoal = goal - 1;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908924,
                "title": "python-o-1-time",
                "content": "```\\nclass Solution:\\n    def convertTime(self, s: str, c: str) -> int:\\n        dif=(int(c[:2])*60+int(c[3:]))-(int(s[:2])*60+int(s[3:]))\\n        count=0\\n        print(dif)\\n        arr=[60,15,5,1]\\n        for x in arr:\\n            count+=dif//x\\n            dif=dif%x\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, s: str, c: str) -> int:\\n        dif=(int(c[:2])*60+int(c[3:]))-(int(s[:2])*60+int(s[3:]))\\n        count=0\\n        print(dif)\\n        arr=[60,15,5,1]\\n        for x in arr:\\n            count+=dif//x\\n            dif=dif%x\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1908893,
                "title": "simple-elegant-solution-with-explaination",
                "content": "## Idea:\\nFor simplification, we can firstly convert `current` and `correct` to minutes. In this problem, we essentially need to bridge the gap between `current` and `correct` by adding  `[1, 5, 15, 60]` minutes to `current`. To be precise, we need to add `correct - current` number of minutes to \\'current\\'. Let `diff = correct - current`.\\n\\n### Superincreasing sequence:\\nNote that the sequence `[1, 5, 15, 60]` is a **superincreasing sequence**. A sequence is called superincreasing if every element of the sequence is greater than the sum of all previous elements in the sequence. In this case:\\n```\\n5 > 1\\n15 > 1 + 5\\n60 > 1 + 5 + 15\\n```\\n\\nSince its superincreasing, we can **greedily** solve the problem by first subtracting 60 from `diff` as much as we can, then subtracting 15 as much as we can and so on until diff becomes zero. We simply count the number of times we have to subtract. We can implement this elegantly using python\\'s `divmod`.\\n\\n### Solution:\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def get_time(t):\\n            hh, mm = t.split(\\':\\')\\n            return int(hh) * 60 + int(mm)\\n        \\n        current, correct = get_time(current), get_time(correct)\\n        operations = 0\\n        diff = correct - current\\n        \\n        for mins in [60, 15, 5, 1]:\\n            quotient, remainder = divmod(diff, mins)\\n            operations += quotient\\n            diff = remainder\\n                \\n        return operations\\n```\\n\\n\\nTime Complexity: O(1)\\nSpace Complexity: O(1)\\n\\n**Do upvote if you like the solution. Have a nice day!**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n5 > 1\\n15 > 1 + 5\\n60 > 1 + 5 + 15\\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def get_time(t):\\n            hh, mm = t.split(\\':\\')\\n            return int(hh) * 60 + int(mm)\\n        \\n        current, correct = get_time(current), get_time(correct)\\n        operations = 0\\n        diff = correct - current\\n        \\n        for mins in [60, 15, 5, 1]:\\n            quotient, remainder = divmod(diff, mins)\\n            operations += quotient\\n            diff = remainder\\n                \\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908744,
                "title": "python-java-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef convertTime(self, current: str, correct: str) -> int:\\n\\t\\t\\tcurrentTime = int(current[0:2]) * 60 + int(current[3:])\\n\\t\\t\\tcorrectTime = int(correct[0:2]) * 60 + int(correct[3:])\\n\\t\\t\\tdiff = correctTime - currentTime\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor time in (60, 15, 5, 1):\\n\\t\\t\\t\\tres += diff // time\\n\\t\\t\\t\\tdiff %= time\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int convertTime(String current, String correct) {\\n\\t\\t\\tint currentTime = Integer.valueOf(current.substring(0, 2)) * 60 + Integer.valueOf(current.substring(3, 5));\\n\\t\\t\\tint correctTime = Integer.valueOf(correct.substring(0, 2)) * 60 + Integer.valueOf(correct.substring(3, 5));\\n\\t\\t\\tint diff = correctTime - currentTime;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int time: new int[] {60, 15, 5, 1}) {\\n\\t\\t\\t\\tres += diff / time;\\n\\t\\t\\t\\tdiff %= time;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef convertTime(self, current: str, correct: str) -> int:\\n\\t\\t\\tcurrentTime = int(current[0:2]) * 60 + int(current[3:])\\n\\t\\t\\tcorrectTime = int(correct[0:2]) * 60 + int(correct[3:])\\n\\t\\t\\tdiff = correctTime - currentTime\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor time in (60, 15, 5, 1):\\n\\t\\t\\t\\tres += diff // time\\n\\t\\t\\t\\tdiff %= time\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int convertTime(String current, String correct) {\\n\\t\\t\\tint currentTime = Integer.valueOf(current.substring(0, 2)) * 60 + Integer.valueOf(current.substring(3, 5));\\n\\t\\t\\tint correctTime = Integer.valueOf(correct.substring(0, 2)) * 60 + Integer.valueOf(correct.substring(3, 5));\\n\\t\\t\\tint diff = correctTime - currentTime;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int time: new int[] {60, 15, 5, 1}",
                "codeTag": "Java"
            },
            {
                "id": 3387766,
                "title": "minimum-number-of-operations-to-convert-time-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int current_time=0, correct_time=0, diff, count=0;\\n        \\n        current_time = (int(current[0])*10+int(current[1]))*60+int(current[3])*10+int(current[4]);\\n        correct_time = (int(correct[0])*10+int(correct[1]))*60+int(correct[3])*10+int(correct[4]);\\n\\n        diff = correct_time-current_time;\\n        while(diff!=0)\\n        {\\n            if(diff>=60)\\n                diff -= 60;\\n            else if(diff>=15)\\n                diff -= 15;\\n            else if(diff>=5)\\n                diff -= 5;\\n            else\\n                diff -= 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int current_time=0, correct_time=0, diff, count=0;\\n        \\n        current_time = (int(current[0])*10+int(current[1]))*60+int(current[3])*10+int(current[4]);\\n        correct_time = (int(correct[0])*10+int(correct[1]))*60+int(correct[3])*10+int(correct[4]);\\n\\n        diff = correct_time-current_time;\\n        while(diff!=0)\\n        {\\n            if(diff>=60)\\n                diff -= 60;\\n            else if(diff>=15)\\n                diff -= 15;\\n            else if(diff>=5)\\n                diff -= 5;\\n            else\\n                diff -= 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289410,
                "title": "beat-99-29-22ms-python3-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current, correct = current.replace(\\':\\',\\'\\'), correct.replace(\\':\\',\\'\\')\\n        a, count = (int(correct[:2]) * 60 + int(correct[2:])) - (int(current[:2]) * 60 + int(current[2:])), 0\\n        for i in [60, 15, 5, 1]:\\n            count += a // i\\n            a %= i\\n        return count \\n\\n        #before for loop\\n        # while a != 0:\\n        #     if a >= 60:\\n        #         count += (a // 60)\\n        #         a %= 60\\n        #     elif 15 <= a < 60:\\n        #         count += (a // 15)\\n        #         a %= 15\\n        #     elif 5 <= a < 15:\\n        #         count += (a // 5)\\n        #         a %= 5\\n        #     elif 1 <= a < 5:\\n        #         count += (a // 1)\\n        #         a %= 1\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current, correct = current.replace(\\':\\',\\'\\'), correct.replace(\\':\\',\\'\\')\\n        a, count = (int(correct[:2]) * 60 + int(correct[2:])) - (int(current[:2]) * 60 + int(current[2:])), 0\\n        for i in [60, 15, 5, 1]:\\n            count += a // i\\n            a %= i\\n        return count \\n\\n        #before for loop\\n        # while a != 0:\\n        #     if a >= 60:\\n        #         count += (a // 60)\\n        #         a %= 60\\n        #     elif 15 <= a < 60:\\n        #         count += (a // 15)\\n        #         a %= 15\\n        #     elif 5 <= a < 15:\\n        #         count += (a // 5)\\n        #         a %= 5\\n        #     elif 1 <= a < 5:\\n        #         count += (a // 1)\\n        #         a %= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791871,
                "title": "java-optimized-from-8-ms-to-1ms",
                "content": "# Solution 3 | 8ms | 11% time | 69% memory\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curHour = Integer.parseInt(current.charAt(0) + \"\" + current.charAt(1));\\n        int curMin = Integer.parseInt(current.charAt(3) + \"\" + current.charAt(4));\\n        int corHour = Integer.parseInt(correct.charAt(0) + \"\" + correct.charAt(1));\\n        int corMin = Integer.parseInt(correct.charAt(3) + \"\" + correct.charAt(4));\\n        int timeCur = curHour * 60 + curMin, timeCor = corHour * 60 + corMin;\\n        int count = 0;\\n        if (timeCur < timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur + 60 <= timeCor) {\\n                    timeCur += 60;\\n                } else if (timeCur + 15 <= timeCor) {\\n                    timeCur += 15;\\n                } else if (timeCur + 5 <= timeCor) {\\n                    timeCur += 5;\\n                } else timeCur++;\\n                count++;\\n            }\\n        } else if (timeCur > timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur - 60 >= timeCor) {\\n                    timeCur -= 60;\\n                } else if (timeCur - 15 >= timeCor) {\\n                    timeCur -= 15;\\n                } else if (timeCur - 5 >= timeCor) {\\n                    timeCur -= 5;\\n                } else timeCur--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nDecided to use StringBuilder.\\n\\n# Solution 2 | 2ms | 83% time | 87% memory\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        StringBuilder sb = new StringBuilder();\\n        int curHour = Integer.parseInt(sb.append(current.charAt(0)).append(current.charAt(1)).toString());\\n        sb.setLength(0);\\n        int curMin = Integer.parseInt(sb.append(current.charAt(3)).append(current.charAt(4)).toString());\\n        sb.setLength(0);\\n        int corHour = Integer.parseInt(sb.append(correct.charAt(0)).append(correct.charAt(1)).toString());\\n        sb.setLength(0);\\n        int corMin = Integer.parseInt(sb.append(correct.charAt(3)).append(correct.charAt(4)).toString());\\n        int timeCur = curHour * 60 + curMin, timeCor = corHour * 60 + corMin;\\n        int count = 0;\\n        if (timeCur < timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur + 60 <= timeCor) {\\n                    timeCur += 60;\\n                } else if (timeCur + 15 <= timeCor) {\\n                    timeCur += 15;\\n                } else if (timeCur + 5 <= timeCor) {\\n                    timeCur += 5;\\n                } else timeCur++;\\n                count++;\\n            }\\n        } else if (timeCur > timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur - 60 >= timeCor) {\\n                    timeCur -= 60;\\n                } else if (timeCur - 15 >= timeCor) {\\n                    timeCur -= 15;\\n                } else if (timeCur - 5 >= timeCor) {\\n                    timeCur -= 5;\\n                } else timeCur--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Solution 1 | 1ms | 99% time |55% memory\\nComplexity: O(1)\\n```\\nint curHour = (current.charAt(0) - \\'0\\') * 10 + (current.charAt(1) - \\'0\\');\\n        int curMin = (current.charAt(3) - \\'0\\') * 10 + (current.charAt(4) - \\'0\\');\\n        int corHour = (correct.charAt(0) - \\'0\\') * 10 + (correct.charAt(1) - \\'0\\');\\n        int corMin = (correct.charAt(3) - \\'0\\') * 10 + (correct.charAt(4) - \\'0\\');\\n        int diff = (corHour * 60 + corMin) - (curHour * 60 + curMin);\\n        int sixty = diff / 60;\\n        diff -= sixty * 60;\\n        int fifteen = diff / 15;\\n        diff -= fifteen * 15;\\n        int five = diff / 5;\\n        diff -= five * 5;\\n        return sixty + fifteen + five + diff;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curHour = Integer.parseInt(current.charAt(0) + \"\" + current.charAt(1));\\n        int curMin = Integer.parseInt(current.charAt(3) + \"\" + current.charAt(4));\\n        int corHour = Integer.parseInt(correct.charAt(0) + \"\" + correct.charAt(1));\\n        int corMin = Integer.parseInt(correct.charAt(3) + \"\" + correct.charAt(4));\\n        int timeCur = curHour * 60 + curMin, timeCor = corHour * 60 + corMin;\\n        int count = 0;\\n        if (timeCur < timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur + 60 <= timeCor) {\\n                    timeCur += 60;\\n                } else if (timeCur + 15 <= timeCor) {\\n                    timeCur += 15;\\n                } else if (timeCur + 5 <= timeCor) {\\n                    timeCur += 5;\\n                } else timeCur++;\\n                count++;\\n            }\\n        } else if (timeCur > timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur - 60 >= timeCor) {\\n                    timeCur -= 60;\\n                } else if (timeCur - 15 >= timeCor) {\\n                    timeCur -= 15;\\n                } else if (timeCur - 5 >= timeCor) {\\n                    timeCur -= 5;\\n                } else timeCur--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        StringBuilder sb = new StringBuilder();\\n        int curHour = Integer.parseInt(sb.append(current.charAt(0)).append(current.charAt(1)).toString());\\n        sb.setLength(0);\\n        int curMin = Integer.parseInt(sb.append(current.charAt(3)).append(current.charAt(4)).toString());\\n        sb.setLength(0);\\n        int corHour = Integer.parseInt(sb.append(correct.charAt(0)).append(correct.charAt(1)).toString());\\n        sb.setLength(0);\\n        int corMin = Integer.parseInt(sb.append(correct.charAt(3)).append(correct.charAt(4)).toString());\\n        int timeCur = curHour * 60 + curMin, timeCor = corHour * 60 + corMin;\\n        int count = 0;\\n        if (timeCur < timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur + 60 <= timeCor) {\\n                    timeCur += 60;\\n                } else if (timeCur + 15 <= timeCor) {\\n                    timeCur += 15;\\n                } else if (timeCur + 5 <= timeCor) {\\n                    timeCur += 5;\\n                } else timeCur++;\\n                count++;\\n            }\\n        } else if (timeCur > timeCor) {\\n            while (timeCur != timeCor) {\\n                if (timeCur - 60 >= timeCor) {\\n                    timeCur -= 60;\\n                } else if (timeCur - 15 >= timeCor) {\\n                    timeCur -= 15;\\n                } else if (timeCur - 5 >= timeCor) {\\n                    timeCur -= 5;\\n                } else timeCur--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nint curHour = (current.charAt(0) - \\'0\\') * 10 + (current.charAt(1) - \\'0\\');\\n        int curMin = (current.charAt(3) - \\'0\\') * 10 + (current.charAt(4) - \\'0\\');\\n        int corHour = (correct.charAt(0) - \\'0\\') * 10 + (correct.charAt(1) - \\'0\\');\\n        int corMin = (correct.charAt(3) - \\'0\\') * 10 + (correct.charAt(4) - \\'0\\');\\n        int diff = (corHour * 60 + corMin) - (curHour * 60 + curMin);\\n        int sixty = diff / 60;\\n        diff -= sixty * 60;\\n        int fifteen = diff / 15;\\n        diff -= fifteen * 15;\\n        int five = diff / 5;\\n        diff -= five * 5;\\n        return sixty + fifteen + five + diff;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614687,
                "title": "simple-java-solution-greedy",
                "content": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int currentTimeInMin = getMinutes(current);\\n        int correctTimeInMin = getMinutes(correct);\\n        \\n        int diff=correctTimeInMin-currentTimeInMin;\\n        int[] denominations={60,15,5,1};\\n        int count=0;\\n        if(diff>0){\\n            for(int denomination:denominations){\\n                if(diff%denomination==0){\\n                    count+=diff/denomination;\\n                    break;\\n                }else{\\n                   count+=diff/denomination;\\n                    diff=diff%denomination;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int getMinutes(String time){\\n        int hours=Integer.parseInt(time.split(\":\")[0]);\\n        int minutes=Integer.parseInt(time.split(\":\")[1]);\\n        \\n        return hours*60+minutes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int currentTimeInMin = getMinutes(current);\\n        int correctTimeInMin = getMinutes(correct);\\n        \\n        int diff=correctTimeInMin-currentTimeInMin;\\n        int[] denominations={60,15,5,1};\\n        int count=0;\\n        if(diff>0){\\n            for(int denomination:denominations){\\n                if(diff%denomination==0){\\n                    count+=diff/denomination;\\n                    break;\\n                }else{\\n                   count+=diff/denomination;\\n                    diff=diff%denomination;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int getMinutes(String time){\\n        int hours=Integer.parseInt(time.split(\":\")[0]);\\n        int minutes=Integer.parseInt(time.split(\":\")[1]);\\n        \\n        return hours*60+minutes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911834,
                "title": "rust-parse-o-n",
                "content": "parse, unwrap_or.\\n\\n```\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        let h = &current[..2].parse::<i32>().map_or(0, |x|x);\\n        let m = &current[3..].parse::<i32>().unwrap_or(0);\\n        let start = h*60 + m;\\n\\n        let h = &correct[..2].parse::<i32>().map_or(0, |x|x);\\n        let m = &correct[3..].parse::<i32>().unwrap_or(0);\\n        let end = h*60 + m;\\n        let mut diff = end - start;\\n        \\n        let mut ans = diff/60;\\n        diff %= 60;\\n        ans += diff/15;\\n        diff %= 15;\\n        ans += diff/5;\\n        diff %= 5;\\n        ans += diff;\\n        \\n        // println!(\"h {}, m {}\", h, m);\\n        \\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        let h = &current[..2].parse::<i32>().map_or(0, |x|x);\\n        let m = &current[3..].parse::<i32>().unwrap_or(0);\\n        let start = h*60 + m;\\n\\n        let h = &correct[..2].parse::<i32>().map_or(0, |x|x);\\n        let m = &correct[3..].parse::<i32>().unwrap_or(0);\\n        let end = h*60 + m;\\n        let mut diff = end - start;\\n        \\n        let mut ans = diff/60;\\n        diff %= 60;\\n        ans += diff/15;\\n        diff %= 15;\\n        ans += diff/5;\\n        diff %= 5;\\n        ans += diff;\\n        \\n        // println!(\"h {}, m {}\", h, m);\\n        \\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1911669,
                "title": "c-convert-given-times-to-minutes-and-think-in-greedy-way",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertToMinutes(string current){\\n        int minutes = 0;\\n        //add hrs after converting to minutes 02:35 ->02*60 = 120\\n        int i;\\n        string hrs = \"\";\\n        for(i=0; i<=1; i++){\\n             hrs += current[i];\\n        }\\n        int hrI = stoi(hrs);   //\"02\"  -> 02\\n        minutes += (hrI*60);   //02*60 -> 120\\n        \\n        string minute;\\n        for(i=3; i<=4; i++){\\n            minute += current[i];\\n        }\\n        int minuteI = stoi(minute);\\n        minutes += minuteI;\\n        \\n        return minutes;\\n    }\\n    \\n    int convertTime(string current, string correct) {\\n        int dest = convertToMinutes(current);\\n        int target = convertToMinutes(correct);\\n        \\n        int count = 0;\\n        while(dest != target){\\n            if(dest+60 <= target)\\n                dest += 60;\\n            else if(dest+15 <= target)\\n                dest += 15;\\n            else if(dest+5 <= target)\\n                dest += 5;\\n            else\\n                dest += 1;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertToMinutes(string current){\\n        int minutes = 0;\\n        //add hrs after converting to minutes 02:35 ->02*60 = 120\\n        int i;\\n        string hrs = \"\";\\n        for(i=0; i<=1; i++){\\n             hrs += current[i];\\n        }\\n        int hrI = stoi(hrs);   //\"02\"  -> 02\\n        minutes += (hrI*60);   //02*60 -> 120\\n        \\n        string minute;\\n        for(i=3; i<=4; i++){\\n            minute += current[i];\\n        }\\n        int minuteI = stoi(minute);\\n        minutes += minuteI;\\n        \\n        return minutes;\\n    }\\n    \\n    int convertTime(string current, string correct) {\\n        int dest = convertToMinutes(current);\\n        int target = convertToMinutes(correct);\\n        \\n        int count = 0;\\n        while(dest != target){\\n            if(dest+60 <= target)\\n                dest += 60;\\n            else if(dest+15 <= target)\\n                dest += 15;\\n            else if(dest+5 <= target)\\n                dest += 5;\\n            else\\n                dest += 1;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910136,
                "title": "java-greedy-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        // convert current time to minutes\\n        String[] current_time = current.split(\":\");\\n        int current_hour = Integer.parseInt(current_time[0]);\\n        current_hour *= 60;\\n        int current_min = Integer.parseInt(current_time[1]);\\n        current_hour += current_min;\\n        \\n        // convert correct time to minutes\\n        String[] correct_time = correct.split(\":\");\\n        int correct_hour = Integer.parseInt(correct_time[0]);\\n        correct_hour *= 60;\\n        int correct_min = Integer.parseInt(correct_time[1]);\\n        correct_hour += correct_min;\\n        \\n        // operations\\n        int count = 0;\\n        \\n        // do greedily\\n        while(correct_hour - current_hour >= 60){\\n            count++;\\n            current_hour += 60;\\n        }\\n        while(correct_hour - current_hour >= 15){\\n            count++;\\n            current_hour += 15;\\n        }\\n        while(correct_hour - current_hour >= 5){\\n            count++;\\n            current_hour += 5;\\n        }\\n        while(correct_hour - current_hour >= 1){\\n            count++;\\n            current_hour += 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        // convert current time to minutes\\n        String[] current_time = current.split(\":\");\\n        int current_hour = Integer.parseInt(current_time[0]);\\n        current_hour *= 60;\\n        int current_min = Integer.parseInt(current_time[1]);\\n        current_hour += current_min;\\n        \\n        // convert correct time to minutes\\n        String[] correct_time = correct.split(\":\");\\n        int correct_hour = Integer.parseInt(correct_time[0]);\\n        correct_hour *= 60;\\n        int correct_min = Integer.parseInt(correct_time[1]);\\n        correct_hour += correct_min;\\n        \\n        // operations\\n        int count = 0;\\n        \\n        // do greedily\\n        while(correct_hour - current_hour >= 60){\\n            count++;\\n            current_hour += 60;\\n        }\\n        while(correct_hour - current_hour >= 15){\\n            count++;\\n            current_hour += 15;\\n        }\\n        while(correct_hour - current_hour >= 5){\\n            count++;\\n            current_hour += 5;\\n        }\\n        while(correct_hour - current_hour >= 1){\\n            count++;\\n            current_hour += 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909288,
                "title": "c-easy-o-n-solution-maths",
                "content": "**Please upvote if it helps :)**\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) \\n    {\\n        int cur_hrs = stoi(current.substr(0,2)), cur_min = stoi(current.substr(3,4));\\n        int cor_hrs = stoi(correct.substr(0,2)), cor_min = stoi(correct.substr(3,4));\\n\\n        int diff_min;\\n        int oper=0;\\n        \\n        //if minute diffrence is negative then we decrease correct hrs by 1 \\n        //Eg: current- 10:45, correct- 11:34 \\n        if((cor_min-cur_min) < 0) \\n            cor_hrs -= 1;\\n        \\n        diff_min = (60 + (cor_min - cur_min)) % 60; \\n        diff_min += 60*((24 + (cor_hrs - cur_hrs)) % 24); // mutliply by 60 to convert hrs into min.\\n    \\n        \\n        while(diff_min != 0)\\n        {\\n            if(diff_min >= 60)\\n            {\\n                diff_min -= 60; oper++;\\n            }\\n            else if(diff_min >= 15)\\n            {\\n                diff_min -= 15; oper++;\\n            }\\n            else if(diff_min >= 5)\\n            {\\n                diff_min -= 5; oper++;\\n            }\\n            else\\n            {\\n                diff_min -= 1; oper++;\\n            }\\n        }\\n        \\n        \\n       return oper; \\n    }\\n};\\n```\\n**Please upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) \\n    {\\n        int cur_hrs = stoi(current.substr(0,2)), cur_min = stoi(current.substr(3,4));\\n        int cor_hrs = stoi(correct.substr(0,2)), cor_min = stoi(correct.substr(3,4));\\n\\n        int diff_min;\\n        int oper=0;\\n        \\n        //if minute diffrence is negative then we decrease correct hrs by 1 \\n        //Eg: current- 10:45, correct- 11:34 \\n        if((cor_min-cur_min) < 0) \\n            cor_hrs -= 1;\\n        \\n        diff_min = (60 + (cor_min - cur_min)) % 60; \\n        diff_min += 60*((24 + (cor_hrs - cur_hrs)) % 24); // mutliply by 60 to convert hrs into min.\\n    \\n        \\n        while(diff_min != 0)\\n        {\\n            if(diff_min >= 60)\\n            {\\n                diff_min -= 60; oper++;\\n            }\\n            else if(diff_min >= 15)\\n            {\\n                diff_min -= 15; oper++;\\n            }\\n            else if(diff_min >= 5)\\n            {\\n                diff_min -= 5; oper++;\\n            }\\n            else\\n            {\\n                diff_min -= 1; oper++;\\n            }\\n        }\\n        \\n        \\n       return oper; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909233,
                "title": "go-golang-time-o-1-0-ms-100-space-o-1-1-9-mb-100",
                "content": "```\\nfunc convertTime(current string, correct string) int {\\n    currentHour, _ := strconv.Atoi(current[:2])\\n    correctHour, _ := strconv.Atoi(correct[:2])\\n    currentMinutes, _ := strconv.Atoi(current[3:])\\n    correctMinutes, _ := strconv.Atoi(correct[3:])\\n    result, minutes := 0, (correctHour - currentHour) * 60 - (currentMinutes - correctMinutes)\\n    \\n    for _, increase := range []int{60, 15, 5} {\\n        result += minutes / increase\\n        minutes %= increase\\n    }\\n\\n    return result + minutes\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc convertTime(current string, correct string) int {\\n    currentHour, _ := strconv.Atoi(current[:2])\\n    correctHour, _ := strconv.Atoi(correct[:2])\\n    currentMinutes, _ := strconv.Atoi(current[3:])\\n    correctMinutes, _ := strconv.Atoi(correct[3:])\\n    result, minutes := 0, (correctHour - currentHour) * 60 - (currentMinutes - correctMinutes)\\n    \\n    for _, increase := range []int{60, 15, 5} {\\n        result += minutes / increase\\n        minutes %= increase\\n    }\\n\\n    return result + minutes\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908829,
                "title": "c-string-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hd = stoi(correct.substr(0,2)) - stoi(current.substr(0,2));\\n        int ans = 0;\\n        ans += hd;\\n        \\n        int ct = stoi(correct.substr(3,2)) - stoi(current.substr(3,2));\\n        \\n        if(ct > 0){\\n            while(ct > 0){\\n                if(ct >= 15){\\n                    ct -= 15;\\n                }else if(ct>=5){\\n                    ct-=5;\\n                }\\n                else{\\n                    ct-=1;\\n                }\\n                ans++;\\n            }\\n        }\\n        else if(ct < 0){\\n            int kk = ((hd-1)+24)%24;\\n            int td = 60+ct;\\n            while(td > 0){\\n                cout<<td<<\" \";\\n                if(td >= 15){\\n                    td -= 15;\\n                }else if(td>=5){\\n                    td-=5;\\n                }\\n                else{\\n                    td-=1;\\n                }\\n                kk++;\\n            }\\n            return kk;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hd = stoi(correct.substr(0,2)) - stoi(current.substr(0,2));\\n        int ans = 0;\\n        ans += hd;\\n        \\n        int ct = stoi(correct.substr(3,2)) - stoi(current.substr(3,2));\\n        \\n        if(ct > 0){\\n            while(ct > 0){\\n                if(ct >= 15){\\n                    ct -= 15;\\n                }else if(ct>=5){\\n                    ct-=5;\\n                }\\n                else{\\n                    ct-=1;\\n                }\\n                ans++;\\n            }\\n        }\\n        else if(ct < 0){\\n            int kk = ((hd-1)+24)%24;\\n            int td = 60+ct;\\n            while(td > 0){\\n                cout<<td<<\" \";\\n                if(td >= 15){\\n                    td -= 15;\\n                }else if(td>=5){\\n                    td-=5;\\n                }\\n                else{\\n                    td-=1;\\n                }\\n                kk++;\\n            }\\n            return kk;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1908737,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) \\n    {\\n        // extractig the minute & hours value from given strings\\n        int cur_hrs = stoi(current.substr(0,2));\\n        int cur_min = stoi(current.substr(3,4));\\n        int cor_hrs = stoi(correct.substr(0,2));\\n        int cor_min = stoi(correct.substr(3,4));\\n        \\n        // it will count the total number of minute difference\\n        int diff_min;\\n        int oper=0;\\n        \\n        // if our target is leeser than do -1\\n        if((cor_min-cur_min) < 0) \\n            cor_hrs -= 1;\\n        \\n        // counting the diff min \\n        // first for minutes and then for hours (1 hour = 60 minute)\\n        diff_min = (60 + (cor_min - cur_min)) % 60;\\n        diff_min += 60*((24 + (cor_hrs - cur_hrs)) % 24);\\n    \\n        // while our diff min is not equal to 0\\n        while(diff_min != 0)\\n        {\\n            // if our diff is bigger than or equal to 60 than substract 60 from it \\n            if(diff_min >= 60)\\n            {\\n                diff_min -= 60; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 15 than substract 15 from it \\n            else if(diff_min >= 15)\\n            {\\n                diff_min -= 15; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 5 than substract 5 from it \\n            else if(diff_min >= 5)\\n            {\\n                diff_min -= 5; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 1 than substract 1 from it \\n            else\\n            {\\n                diff_min -= 1; \\n                oper++;\\n            }\\n        }\\n        \\n        \\n       return oper; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) \\n    {\\n        // extractig the minute & hours value from given strings\\n        int cur_hrs = stoi(current.substr(0,2));\\n        int cur_min = stoi(current.substr(3,4));\\n        int cor_hrs = stoi(correct.substr(0,2));\\n        int cor_min = stoi(correct.substr(3,4));\\n        \\n        // it will count the total number of minute difference\\n        int diff_min;\\n        int oper=0;\\n        \\n        // if our target is leeser than do -1\\n        if((cor_min-cur_min) < 0) \\n            cor_hrs -= 1;\\n        \\n        // counting the diff min \\n        // first for minutes and then for hours (1 hour = 60 minute)\\n        diff_min = (60 + (cor_min - cur_min)) % 60;\\n        diff_min += 60*((24 + (cor_hrs - cur_hrs)) % 24);\\n    \\n        // while our diff min is not equal to 0\\n        while(diff_min != 0)\\n        {\\n            // if our diff is bigger than or equal to 60 than substract 60 from it \\n            if(diff_min >= 60)\\n            {\\n                diff_min -= 60; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 15 than substract 15 from it \\n            else if(diff_min >= 15)\\n            {\\n                diff_min -= 15; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 5 than substract 5 from it \\n            else if(diff_min >= 5)\\n            {\\n                diff_min -= 5; \\n                oper++;\\n            }\\n            // if our diff is bigger than or equal to 1 than substract 1 from it \\n            else\\n            {\\n                diff_min -= 1; \\n                oper++;\\n            }\\n        }\\n        \\n        \\n       return oper; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830171,
                "title": "fastest-solution-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int convertTime(String current, String correct){\\n        int a = Integer.parseInt(current.substring(0, 2));\\n        int b = Integer.parseInt(current.substring(3));\\n        int x = a*60+b;\\n        int c = Integer.parseInt(correct.substring(0, 2));\\n        int d = Integer.parseInt(correct.substring(3));\\n        int y = c*60+d;\\n        int k = y-x;\\n        int ans = 0;\\n        while(k>0){\\n            if(k%60==0){\\n                k -= 60;\\n                ans++;\\n            }\\n            else if(k%15==0){\\n                k -= 15;\\n                ans++;\\n            }\\n            else if(k%5==0){\\n                k -= 5;\\n                ans++;\\n            }\\n            else if(k%1==0){\\n                k -= 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int convertTime(String current, String correct){\\n        int a = Integer.parseInt(current.substring(0, 2));\\n        int b = Integer.parseInt(current.substring(3));\\n        int x = a*60+b;\\n        int c = Integer.parseInt(correct.substring(0, 2));\\n        int d = Integer.parseInt(correct.substring(3));\\n        int y = c*60+d;\\n        int k = y-x;\\n        int ans = 0;\\n        while(k>0){\\n            if(k%60==0){\\n                k -= 60;\\n                ans++;\\n            }\\n            else if(k%15==0){\\n                k -= 15;\\n                ans++;\\n            }\\n            else if(k%5==0){\\n                k -= 5;\\n                ans++;\\n            }\\n            else if(k%1==0){\\n                k -= 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668590,
                "title": "100-beat-easy-to-understand-c-solution-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string s1, string s2) {\\n        int h1 = stoi(s1.substr(0,2));\\n        int m1 = stoi(s1.substr(3,2));\\n        int h2 = stoi(s2.substr(0,2));\\n        int m2 = stoi(s2.substr(3,2));\\n        int hrDiff = h2 - h1;\\n        if(hrDiff < 0) hrDiff += 24;\\n        int minDiff = m2 - m1;\\n        int total = hrDiff*60 + minDiff;\\n        int ans = 0;\\n\\n        if(total >= 60){\\n            ans += (total/60);\\n            total = total%60;\\n        }\\n        if(total >= 15){\\n            ans += (total/15);\\n            total = total%15;\\n        }\\n        if(total >= 5){\\n            ans += (total / 5);\\n            total = total%5;\\n        }\\n        ans += total;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string s1, string s2) {\\n        int h1 = stoi(s1.substr(0,2));\\n        int m1 = stoi(s1.substr(3,2));\\n        int h2 = stoi(s2.substr(0,2));\\n        int m2 = stoi(s2.substr(3,2));\\n        int hrDiff = h2 - h1;\\n        if(hrDiff < 0) hrDiff += 24;\\n        int minDiff = m2 - m1;\\n        int total = hrDiff*60 + minDiff;\\n        int ans = 0;\\n\\n        if(total >= 60){\\n            ans += (total/60);\\n            total = total%60;\\n        }\\n        if(total >= 15){\\n            ans += (total/15);\\n            total = total%15;\\n        }\\n        if(total >= 5){\\n            ans += (total / 5);\\n            total = total%5;\\n        }\\n        ans += total;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749036,
                "title": "minimum-memory-81-faster-math-integer",
                "content": "Clean code and faster!\\n\\n\\n\\n\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int x = Integer.parseInt(current.substring(0,2));\\n        int y = Integer.parseInt(correct.substring(0,2));\\n\\n        int x1 = Integer.parseInt(current.substring(3));\\n        int x2 = Integer.parseInt(correct.substring(3));\\n\\n        int z = x2-x1;\\n        if(x2<x1){\\n            y=y-1;\\n            z = 60 - x1+x2;\\n        }\\n        int a = (z/15);\\n        int b = ((z-a*15)/5);\\n        int c = z-a*15-b*5;\\n\\n        return y-x+a+b+c;\\n    \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public int convertTime(String current, String correct) {\\n        int x = Integer.parseInt(current.substring(0,2));\\n        int y = Integer.parseInt(correct.substring(0,2));\\n\\n        int x1 = Integer.parseInt(current.substring(3));\\n        int x2 = Integer.parseInt(correct.substring(3));\\n\\n        int z = x2-x1;\\n        if(x2<x1){\\n            y=y-1;\\n            z = 60 - x1+x2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2703973,
                "title": "c-manual-code-100-faster",
                "content": "class Solution {\\npublic\\n\\n//we can also use substr() and stoi() functions here ,I have done that manually coz given string wasn\\'t so complex\\n\\n     int toMinute(string curr){\\n          int mi=0;  \\n        mi=mi+curr[0]-\\'0\\'; mi*=10;\\n        mi=mi+curr[1]-\\'0\\';\\n        mi*=60;\\n        int a=0;\\n        a=a+curr[3]-\\'0\\'; a*=10;\\n        a=a+curr[4]-\\'0\\';\\n        mi+=a;\\n        return mi;\\n    }\\n    int convertTime(string curr, string correct) {\\n      int a=toMinute(curr);\\n     int b=toMinute(correct);\\n        int count=0;\\n        while(a<b){\\n            if(b-a>=60){\\n                a+=60;\\n            }\\n            else  if(b-a>=15){\\n                a+=15;\\n            }\\n            else  if(b-a>=5){\\n                a+=5;\\n            }\\n            else {\\n                a+=1;\\n            }\\n           count++; \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic\\n\\n//we can also use substr() and stoi() functions here ,I have done that manually coz given string wasn\\'t so complex\\n\\n     int toMinute(string curr){\\n          int mi=0;  \\n        mi=mi+curr[0]-\\'0\\'; mi*=10;\\n        mi=mi+curr[1]-\\'0\\';\\n        mi*=60;\\n        int a=0;\\n        a=a+curr[3]-\\'0\\'; a*=10;\\n        a=a+curr[4]-\\'0\\';\\n        mi+=a;\\n        return mi;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2636665,
                "title": "100-fast-convert-into-min",
                "content": "upvote\\n```\\n    int convertTime(string cur, string cor) {\\n        int curr = ((cur[0]-\\'0\\')*10+cur[1]-\\'0\\')*60+(cur[3]-\\'0\\')*10+cur[4]-\\'0\\';\\n        int corr = ((cor[0]-\\'0\\')*10+cor[1]-\\'0\\')*60+(cor[3]-\\'0\\')*10+cor[4]-\\'0\\';\\n        int ops =0, rem=corr-curr;\\n        while(rem>=60){\\n            rem -= 60;\\n            ops++;\\n        }\\n        while(rem>=15){\\n            rem -= 15;\\n            ops++;\\n        }\\n        while(rem>=5){\\n            rem -= 5;\\n            ops++;\\n        }\\n        while(rem>=1){\\n            rem -= 1;\\n            ops++;\\n        }\\n        \\n        return ops;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int convertTime(string cur, string cor) {\\n        int curr = ((cur[0]-\\'0\\')*10+cur[1]-\\'0\\')*60+(cur[3]-\\'0\\')*10+cur[4]-\\'0\\';\\n        int corr = ((cor[0]-\\'0\\')*10+cor[1]-\\'0\\')*60+(cor[3]-\\'0\\')*10+cor[4]-\\'0\\';\\n        int ops =0, rem=corr-curr;\\n        while(rem>=60){\\n            rem -= 60;\\n            ops++;\\n        }\\n        while(rem>=15){\\n            rem -= 15;\\n            ops++;\\n        }\\n        while(rem>=5){\\n            rem -= 5;\\n            ops++;\\n        }\\n        while(rem>=1){\\n            rem -= 1;\\n            ops++;\\n        }\\n        \\n        return ops;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2576476,
                "title": "easiest-shortest-simplest-c-solution",
                "content": "Convert the strings to int time in minutes and then find the difference. Apply simple maths!\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint convertTime(string current, string correct) {\\n\\t\\t\\tint ftime = (stoi(current.substr(0,2))) * 60 + (stoi(current.substr(3,current.size())));\\n\\t\\t\\tint ltime = (stoi(correct.substr(0,2))) * 60 + (stoi(correct.substr(3,correct.size())));\\n\\t\\t\\tint diff = ltime - ftime;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tans += diff/60;\\n\\t\\t\\tdiff = diff%60;\\n\\t\\t\\tans += diff/15;\\n\\t\\t\\tdiff = diff%15;\\n\\t\\t\\tans +=diff/5;\\n\\t\\t\\tdiff = diff%5;\\n\\t\\t\\tans += diff;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint convertTime(string current, string correct) {\\n\\t\\t\\tint ftime = (stoi(current.substr(0,2))) * 60 + (stoi(current.substr(3,current.size())));\\n\\t\\t\\tint ltime = (stoi(correct.substr(0,2))) * 60 + (stoi(correct.substr(3,correct.size())));\\n\\t\\t\\tint diff = ltime - ftime;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tans += diff/60;\\n\\t\\t\\tdiff = diff%60;\\n\\t\\t\\tans += diff/15;\\n\\t\\t\\tdiff = diff%15;\\n\\t\\t\\tans +=diff/5;\\n\\t\\t\\tdiff = diff%5;\\n\\t\\t\\tans += diff;\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2445402,
                "title": "c-easily-understandable-brute-force-greedy",
                "content": "```\\nTime: O(Log minute)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int m1=10*(current[3]-\\'0\\')+(current[4]-\\'0\\'),\\n            m2=10*(correct[3]-\\'0\\')+(correct[4]-\\'0\\');\\n        int k=m2-m1;\\n        int h1=10*(current[0]-\\'0\\')+(current[1]-\\'0\\'),\\n            h2=10*(correct[0]-\\'0\\')+(correct[1]-\\'0\\');\\n        int k2=h2-h1;\\n        int tmin=k2*60+k;\\n        k=0;\\n        while(tmin){\\n            if(tmin>=60){\\n                k+=tmin/60;tmin%=60;\\n            }else if(tmin>=15)\\n                k+=tmin/15,tmin%=15;\\n            else if(tmin>=5)\\n                k+=tmin/5,tmin%=5;\\n            else\\n                k+=tmin/1,tmin%=1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nTime: O(Log minute)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int m1=10*(current[3]-\\'0\\')+(current[4]-\\'0\\'),\\n            m2=10*(correct[3]-\\'0\\')+(correct[4]-\\'0\\');\\n        int k=m2-m1;\\n        int h1=10*(current[0]-\\'0\\')+(current[1]-\\'0\\'),\\n            h2=10*(correct[0]-\\'0\\')+(correct[1]-\\'0\\');\\n        int k2=h2-h1;\\n        int tmin=k2*60+k;\\n        k=0;\\n        while(tmin){\\n            if(tmin>=60){\\n                k+=tmin/60;tmin%=60;\\n            }else if(tmin>=15)\\n                k+=tmin/15,tmin%=15;\\n            else if(tmin>=5)\\n                k+=tmin/5,tmin%=5;\\n            else\\n                k+=tmin/1,tmin%=1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412947,
                "title": "100-faster-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hours1=stoi(current.substr(0,2));\\n        int hours2=stoi(correct.substr(0,2));\\n        int min1=stoi(current.substr(3,2));\\n        int min2=stoi(correct.substr(3,2));\\n        int mins=((60-min1)+(min2))<60?abs((hours2-hours1-1)*60)+((60-min1)+(min2)):abs((hours2-hours1)*60) + abs(min2-min1);\\n        int count=0;\\n        while(mins!=0){\\n            if(mins>=60){\\n                count++;mins-=60;\\n            }\\n            else if(mins>=15){\\n                count++;mins-=15;\\n            }\\n            else if(mins>=5){\\n                count++;mins-=5;\\n            }\\n            else if(mins>=1){\\n                count++;mins-=1;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/b615f4cb-50ff-4548-910e-aef09b4f7f28_1660251060.0716007.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hours1=stoi(current.substr(0,2));\\n        int hours2=stoi(correct.substr(0,2));\\n        int min1=stoi(current.substr(3,2));\\n        int min2=stoi(correct.substr(3,2));\\n        int mins=((60-min1)+(min2))<60?abs((hours2-hours1-1)*60)+((60-min1)+(min2)):abs((hours2-hours1)*60) + abs(min2-min1);\\n        int count=0;\\n        while(mins!=0){\\n            if(mins>=60){\\n                count++;mins-=60;\\n            }\\n            else if(mins>=15){\\n                count++;mins-=15;\\n            }\\n            else if(mins>=5){\\n                count++;mins-=5;\\n            }\\n            else if(mins>=1){\\n                count++;mins-=1;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406772,
                "title": "c-0ms-and-java-1ms-easy-understanding",
                "content": "**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ret=0, digit=1, cur=0, cor=0, hour=1, i;\\n        int t[] = {59,14,4,0};\\n        for(i = current.size()-1; i>-1; i--){\\n            if(58!=current[i]){\\n                cur += (current[i]-48)*digit*hour;\\n                cor += (correct[i]-48)*digit*hour;\\n                digit=10;\\n            }\\n            else {\\n                digit=1;\\n                hour=60;\\n            }\\n        }\\n        cor -= cur;\\n        i=0;\\n        while(cor>0){\\n            if(cor>t[i]){\\n                cor -= t[i]+1;\\n                ret++;\\n            }\\n            else i++;\\n        } \\n        return ret;\\n    }\\n};\\n```\\n**Java Solution**\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int ret=0, digit=1, cur=0, cor=0, hour=1, i;\\n        int[] t = {59,14,4,0};\\n        for(i = current.length()-1; i>-1; i--){\\n            if(58!=current.charAt(i)){\\n                cur += (current.charAt(i)-48)*digit*hour;\\n                cor += (correct.charAt(i)-48)*digit*hour;\\n                digit=10;\\n            }\\n            else {\\n                digit=1;\\n                hour=60;\\n            }\\n        }\\n        cor -= cur;\\n        i=0;\\n        while(cor>0){\\n            if(cor>t[i]){\\n                cor -= t[i]+1;\\n                ret++;\\n            }\\n            else i++;\\n        } \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ret=0, digit=1, cur=0, cor=0, hour=1, i;\\n        int t[] = {59,14,4,0};\\n        for(i = current.size()-1; i>-1; i--){\\n            if(58!=current[i]){\\n                cur += (current[i]-48)*digit*hour;\\n                cor += (correct[i]-48)*digit*hour;\\n                digit=10;\\n            }\\n            else {\\n                digit=1;\\n                hour=60;\\n            }\\n        }\\n        cor -= cur;\\n        i=0;\\n        while(cor>0){\\n            if(cor>t[i]){\\n                cor -= t[i]+1;\\n                ret++;\\n            }\\n            else i++;\\n        } \\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int ret=0, digit=1, cur=0, cor=0, hour=1, i;\\n        int[] t = {59,14,4,0};\\n        for(i = current.length()-1; i>-1; i--){\\n            if(58!=current.charAt(i)){\\n                cur += (current.charAt(i)-48)*digit*hour;\\n                cor += (correct.charAt(i)-48)*digit*hour;\\n                digit=10;\\n            }\\n            else {\\n                digit=1;\\n                hour=60;\\n            }\\n        }\\n        cor -= cur;\\n        i=0;\\n        while(cor>0){\\n            if(cor>t[i]){\\n                cor -= t[i]+1;\\n                ret++;\\n            }\\n            else i++;\\n        } \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373684,
                "title": "easiest-java-solution-t-o-1-s-o-1",
                "content": "\\n\\n\\n```\\npublic int convertTime(String current, String correct) {\\n        String[] start = current.split(\":\");\\n        int startMins = Integer.valueOf(start[0])*60+Integer.valueOf(start[1]);\\n        \\n        String[] target = correct.split(\":\");\\n        int targetMins = Integer.valueOf(target[0])*60+Integer.valueOf(target[1]);\\n\\n        int diff = targetMins-startMins;\\n        int ops=0;\\n        \\n        ops += diff/60;    \\n        diff = diff%60;\\n\\n        ops += diff/15;\\n        diff = diff%15;\\n        \\n        ops += diff/5;\\n        diff = diff%5;\\n        \\n        return ops + diff;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int convertTime(String current, String correct) {\\n        String[] start = current.split(\":\");\\n        int startMins = Integer.valueOf(start[0])*60+Integer.valueOf(start[1]);\\n        \\n        String[] target = correct.split(\":\");\\n        int targetMins = Integer.valueOf(target[0])*60+Integer.valueOf(target[1]);\\n\\n        int diff = targetMins-startMins;\\n        int ops=0;\\n        \\n        ops += diff/60;    \\n        diff = diff%60;\\n\\n        ops += diff/15;\\n        diff = diff%15;\\n        \\n        ops += diff/5;\\n        diff = diff%5;\\n        \\n        return ops + diff;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2348431,
                "title": "greedy-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int res=0;\\n        string ans=current.substr(0,2);\\n        string ans1=current.substr(3,5);\\n        int a1=stoi(ans)*60;\\n        int a2=stoi(ans1);\\n         string st=correct.substr(0,2);\\n        string st1=correct.substr(3,5);\\n        int b1=stoi(st)*60;\\n        int b2=stoi(st1);\\n        \\n        int ff=abs((a1+a2)-(b1+b2));\\n        int hours = ff/60;\\n        res+=hours;\\n        int minutes=ff%60;\\n        if(minutes % 15 ==0 ){\\n            res+=minutes/15;\\n            return res;\\n        }\\n        if(minutes > 15 ){\\n            res+=minutes/15;\\n            minutes = minutes%15;\\n        }\\n        \\n        if(minutes%5==0){\\n            res+=minutes/5;\\n            return res;\\n        }\\n        if(minutes > 5){\\n            res+=minutes/5;\\n            minutes=minutes%5;\\n        }\\n        res+=minutes;\\n        return res;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int res=0;\\n        string ans=current.substr(0,2);\\n        string ans1=current.substr(3,5);\\n        int a1=stoi(ans)*60;\\n        int a2=stoi(ans1);\\n         string st=correct.substr(0,2);\\n        string st1=correct.substr(3,5);\\n        int b1=stoi(st)*60;\\n        int b2=stoi(st1);\\n        \\n        int ff=abs((a1+a2)-(b1+b2));\\n        int hours = ff/60;\\n        res+=hours;\\n        int minutes=ff%60;\\n        if(minutes % 15 ==0 ){\\n            res+=minutes/15;\\n            return res;\\n        }\\n        if(minutes > 15 ){\\n            res+=minutes/15;\\n            minutes = minutes%15;\\n        }\\n        \\n        if(minutes%5==0){\\n            res+=minutes/5;\\n            return res;\\n        }\\n        if(minutes > 5){\\n            res+=minutes/5;\\n            minutes=minutes%5;\\n        }\\n        res+=minutes;\\n        return res;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304608,
                "title": "leetcode-the-hard-way-greedy-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\nChoosing `60` 1 time is better than choosing `15` 4 times. We choose from the largest number as many times as we could, then choose the second largest and etc. Since the operation is on minute, we need to convert the input to minute format first. Then we calculate the difference and try each operation to see how many times we could apply and update the difference after each operation.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int getMinutes(string t) {\\n        int res = 0;\\n        // handle HH\\n        res += (t[0] - \\'0\\') * 10;\\n        res += (t[1] - \\'0\\');\\n        res *= 60;\\n        // handle MM\\n        res += (t[3] - \\'0\\') * 10;\\n        res += (t[4] - \\'0\\');\\n        return res;\\n    }\\n    \\n    int convertTime(string current, string correct) {\\n        // convert inputs to minute format\\n        int from = getMinutes(current), to = getMinutes(correct);\\n        // init ans & calculate the difference\\n        int ans = 0, d = to - from;\\n        // available operators - use largest one first\\n        vector<int> ops{ 60, 15, 5, 1 };\\n        // try each operation - take as many as possible\\n        // and update the difference\\n        for (auto x : ops) ans += d / x, d %= x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int getMinutes(string t) {\\n        int res = 0;\\n        // handle HH\\n        res += (t[0] - \\'0\\') * 10;\\n        res += (t[1] - \\'0\\');\\n        res *= 60;\\n        // handle MM\\n        res += (t[3] - \\'0\\') * 10;\\n        res += (t[4] - \\'0\\');\\n        return res;\\n    }\\n    \\n    int convertTime(string current, string correct) {\\n        // convert inputs to minute format\\n        int from = getMinutes(current), to = getMinutes(correct);\\n        // init ans & calculate the difference\\n        int ans = 0, d = to - from;\\n        // available operators - use largest one first\\n        vector<int> ops{ 60, 15, 5, 1 };\\n        // try each operation - take as many as possible\\n        // and update the difference\\n        for (auto x : ops) ans += d / x, d %= x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299755,
                "title": "java-difference-in-minutes",
                "content": "```\\npublic int convertTime(String current, String correct) {\\n        String[] currentTime = current.split(\":\");\\n        String[] correctTime = correct.split(\":\");\\n        \\n        int correctMin = Integer.parseInt(correctTime[0]) * 60 + Integer.parseInt(correctTime[1]);\\n        int currentMin = Integer.parseInt(currentTime[0]) * 60 + Integer.parseInt(currentTime[1]);\\n  \\n        int diff = correctMin - currentMin;\\n        int steps = 0;\\n        while(diff>0)\\n        {\\n            if(diff>=60)\\n            {\\n                diff -=60;\\n            }\\n            else if(diff>=15)\\n            {\\n                diff -=15;\\n            }\\n            else if (diff>=5)\\n            {\\n                diff -=5;\\n            }\\n            else if(diff>=1)\\n            {\\n                diff -=1;\\n            }\\n            steps++;\\n        }\\n\\n        return steps;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int convertTime(String current, String correct) {\\n        String[] currentTime = current.split(\":\");\\n        String[] correctTime = correct.split(\":\");\\n        \\n        int correctMin = Integer.parseInt(correctTime[0]) * 60 + Integer.parseInt(correctTime[1]);\\n        int currentMin = Integer.parseInt(currentTime[0]) * 60 + Integer.parseInt(currentTime[1]);\\n  \\n        int diff = correctMin - currentMin;\\n        int steps = 0;\\n        while(diff>0)\\n        {\\n            if(diff>=60)\\n            {\\n                diff -=60;\\n            }\\n            else if(diff>=15)\\n            {\\n                diff -=15;\\n            }\\n            else if (diff>=5)\\n            {\\n                diff -=5;\\n            }\\n            else if(diff>=1)\\n            {\\n                diff -=1;\\n            }\\n            steps++;\\n        }\\n\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2250910,
                "title": "rust",
                "content": "```rust\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        let current: Vec<_> = current.split(\":\").collect();\\n        let correct: Vec<_> = correct.split(\":\").collect();\\n        let start0: i32 = current[0].parse().unwrap();\\n        let start1: i32 = current[1].parse().unwrap();\\n        let end0: i32 = correct[0].parse().unwrap();\\n        let end1: i32 = correct[1].parse().unwrap();\\n\\n        let mut diff = (end0 - start0) * 60 + (end1 - start1);\\n        let mut cnt = 0;\\n        for n in vec![60, 15, 5, 1] {\\n            if diff >= n {\\n                cnt += diff / n;\\n                diff %= n\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn convert_time(current: String, correct: String) -> i32 {\\n        let current: Vec<_> = current.split(\":\").collect();\\n        let correct: Vec<_> = correct.split(\":\").collect();\\n        let start0: i32 = current[0].parse().unwrap();\\n        let start1: i32 = current[1].parse().unwrap();\\n        let end0: i32 = correct[0].parse().unwrap();\\n        let end1: i32 = correct[1].parse().unwrap();\\n\\n        let mut diff = (end0 - start0) * 60 + (end1 - start1);\\n        let mut cnt = 0;\\n        for n in vec![60, 15, 5, 1] {\\n            if diff >= n {\\n                cnt += diff / n;\\n                diff %= n\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2203335,
                "title": "my-2ms-easy-to-understand-java-code",
                "content": "```\\nclass Solution \\n{\\n    public int convertTime(String current, String correct) \\n    {\\n        int cur_hou = Integer.parseInt(current.substring(0,2));\\n        int cur_min = Integer.parseInt(current.substring(3,5));\\n        int cur     = (cur_hou*60)+cur_min;     //150\\n        \\n        int cor_hou = Integer.parseInt(correct.substring(0,2));\\n        int cor_min = Integer.parseInt(correct.substring(3,5));\\n        int cor     = (cor_hou*60)+cor_min;     //275\\n        \\n        int differ  = cor-cur;  //125\\n        int no_of_ops=0;\\n        \\n        while(differ!=0)\\n        {\\n            if(differ>=60)\\n            {\\n                differ=differ-60;\\n                no_of_ops++;\\n            }\\n            else if(differ>=15)\\n            {\\n                differ-=15;\\n                no_of_ops++;\\n            }\\n            else if(differ>=5)\\n            {\\n                differ-=5;\\n                no_of_ops++;\\n            }\\n            else\\n            {\\n                differ-=1;\\n                no_of_ops++;\\n            }\\n        }\\n        \\n        return no_of_ops;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int convertTime(String current, String correct) \\n    {\\n        int cur_hou = Integer.parseInt(current.substring(0,2));\\n        int cur_min = Integer.parseInt(current.substring(3,5));\\n        int cur     = (cur_hou*60)+cur_min;     //150\\n        \\n        int cor_hou = Integer.parseInt(correct.substring(0,2));\\n        int cor_min = Integer.parseInt(correct.substring(3,5));\\n        int cor     = (cor_hou*60)+cor_min;     //275\\n        \\n        int differ  = cor-cur;  //125\\n        int no_of_ops=0;\\n        \\n        while(differ!=0)\\n        {\\n            if(differ>=60)\\n            {\\n                differ=differ-60;\\n                no_of_ops++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2109918,
                "title": "easy-python-solution",
                "content": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        d=(int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:]))\\n        return d//60+(d%60)//15+((d%60)%15)//5+((d%60)%15)%5\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        d=(int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:]))\\n        return d//60+(d%60)//15+((d%60)%15)//5+((d%60)%15)%5\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2002717,
                "title": "why-greedy-works-here",
                "content": "I know there is papaer regarding cannonical sequence of numbers which can identify if a problem like this can be solved using Greedy way. https://arxiv.org/pdf/0809.0400.pdf\\nIs there any simple way to decide if we can use greedy way to solve this kind problem.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1977364,
                "title": "simple-python-solution-with-detailed-explanation-faster-than-99-easy-to-understand",
                "content": "```\\n\\n```class Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        \\n        newcu = current.split(\\':\\')      # extract hours and minutes from current and correct\\n        newco = correct.split(\\':\\')\\n        \\n        newcu = [int(x) for x in newcu]     # change string to integer\\n        newco = [int(x) for x in newco]\\n        \\n        newcu1 = newcu[0]*60 + newcu[1]     # change hours to minutes\\n        newco1 = newco[0]*60 + newco[1]\\n        \\n        diff = newco1 - newcu1      # get the difference between correct and current in minutes\\n        \\n        nums = diff//60 + diff%60//15 + diff%60%15//5 + diff%60%15%5        # divide by 60, then + remainder divide by 15, then + remainder divide by 5 then + remainder of 5\\n\\n        return nums",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1974552,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curr=Integer.parseInt(current.substring(0,2))*60;\\n         curr+=Integer.parseInt(current.substring(3,5));\\n        \\n        int corr=Integer.parseInt(correct.substring(0,2))*60;\\n         corr+=Integer.parseInt(correct.substring(3,5));\\n\\n        corr=corr-curr;\\n        \\n        int res=0;\\n        res+=corr/60;\\n        corr=corr%60;\\n        \\n        res+=corr/15;\\n        corr=corr%15;\\n        \\n        res+=corr/5;\\n        corr=corr%5;\\n        \\n        res+=corr/1;\\n        \\n\\n        return res;\\n\\n        \\n        \\n        \\n        \\n \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curr=Integer.parseInt(current.substring(0,2))*60;\\n         curr+=Integer.parseInt(current.substring(3,5));\\n        \\n        int corr=Integer.parseInt(correct.substring(0,2))*60;\\n         corr+=Integer.parseInt(correct.substring(3,5));\\n\\n        corr=corr-curr;\\n        \\n        int res=0;\\n        res+=corr/60;\\n        corr=corr%60;\\n        \\n        res+=corr/15;\\n        corr=corr%15;\\n        \\n        res+=corr/5;\\n        corr=corr%5;\\n        \\n        res+=corr/1;\\n        \\n\\n        return res;\\n\\n        \\n        \\n        \\n        \\n \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961744,
                "title": "python3-division-modulo",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/f2b4a5c0268eb27201b136764bb0b6ad3880c6f6) for solutions of weekly 287.\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        fn = lambda x, y: 60*x + y\\n        m0 = fn(*map(int, current.split(\\':\\')))\\n        m1 = fn(*map(int, correct.split(\\':\\')))\\n        ans = 0 \\n        diff = m1 - m0 \\n        for x in 60, 15, 5, 1: \\n            ans += diff // x\\n            diff %= x\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        fn = lambda x, y: 60*x + y\\n        m0 = fn(*map(int, current.split(\\':\\')))\\n        m1 = fn(*map(int, correct.split(\\':\\')))\\n        ans = 0 \\n        diff = m1 - m0 \\n        for x in 60, 15, 5, 1: \\n            ans += diff // x\\n            diff %= x\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957609,
                "title": "python-coin-change-problem",
                "content": "\\n    def convertTime(self, current, correct):\\n        current = int(current.split(\":\")[0])*60 + int(current.split(\":\")[1])\\n        correct = int(correct.split(\":\")[0])*60 + int(correct.split(\":\")[1])\\n        \\n        amount, coins = correct - current, [1,5,15,60]\\n        \\n        dp = [float(\"inf\")]*(amount+1)\\n        \\n        dp[0] = 0\\n        \\n        for coin in coins:\\n            for i in range(coin, amount+1):\\n                dp[i] = min(dp[i], 1 + dp[i-coin])\\n                \\n        return dp[-1]",
                "solutionTags": [],
                "code": "\\n    def convertTime(self, current, correct):\\n        current = int(current.split(\":\")[0])*60 + int(current.split(\":\")[1])\\n        correct = int(correct.split(\":\")[0])*60 + int(correct.split(\":\")[1])\\n        \\n        amount, coins = correct - current, [1,5,15,60]\\n        \\n        dp = [float(\"inf\")]*(amount+1)\\n        \\n        dp[0] = 0\\n        \\n        for coin in coins:\\n            for i in range(coin, amount+1):\\n                dp[i] = min(dp[i], 1 + dp[i-coin])\\n                \\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1948319,
                "title": "java-greedy-solution",
                "content": "```\\n// Greedy Solution\\n// Time complexity: O(1), O(T) where T is a constant\\n// Space complexity: O(1)\\nclass Solution {\\n    private static final int[] TIMES = {60, 15, 5, 1};\\n    \\n    public int convertTime(String current, String correct) {\\n        int t1 = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3));\\n        int t2 = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3));\\n        int ops = 0;\\n        for (int time : TIMES) {\\n            while (t1 + time <= t2) {\\n                t1 += time;\\n                ops++;\\n            }\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Greedy Solution\\n// Time complexity: O(1), O(T) where T is a constant\\n// Space complexity: O(1)\\nclass Solution {\\n    private static final int[] TIMES = {60, 15, 5, 1};\\n    \\n    public int convertTime(String current, String correct) {\\n        int t1 = Integer.parseInt(current.substring(0, 2)) * 60 + Integer.parseInt(current.substring(3));\\n        int t2 = Integer.parseInt(correct.substring(0, 2)) * 60 + Integer.parseInt(correct.substring(3));\\n        int ops = 0;\\n        for (int time : TIMES) {\\n            while (t1 + time <= t2) {\\n                t1 += time;\\n                ops++;\\n            }\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931298,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int sum=0;\\n        sum+=Integer.parseInt(correct.substring(0,2))-Integer.parseInt(current.substring(0,2));\\n        int min = Integer.parseInt(correct.substring(3,5))-Integer.parseInt(current.substring(3,5));\\n        if(min<0)\\n        {\\n           sum--;\\n           min+=60;\\n        }\\n        if(min>=15)\\n        {\\n            sum+=min/15;\\n            min-=15*(min/15);\\n        }\\n        if(min>=5)\\n        {\\n            sum+=min/5;\\n            min-=5*(min/5);\\n        }\\n        sum+=min;\\n         return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int convertTime(String current, String correct) {\\n        int sum=0;\\n        sum+=Integer.parseInt(correct.substring(0,2))-Integer.parseInt(current.substring(0,2));\\n        int min = Integer.parseInt(correct.substring(3,5))-Integer.parseInt(current.substring(3,5));\\n        if(min<0)\\n        {\\n           sum--;\\n           min+=60;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1930643,
                "title": "simple-javascript",
                "content": "```\\nconst convertTime = function(current, correct) {\\n    const [currentHH, currentMM] = current.split(\\':\\').map((val) => Number(val));\\n    const [correctHH, correctMM] = correct.split(\\':\\').map((val) => Number(val));\\n    \\n    let total = 0;\\n    \\n    total += correctHH - currentHH;\\n    \\n    let diff = correctMM - currentMM;\\n    \\n    // for negative where needed minutes are lower than the current minutes\\n    if (correctMM < currentMM) {\\n        total -= 1;\\n        diff += 60;\\n    }\\n\\n\\n    if (diff >= 15) {\\n        total += Math.floor(diff / 15);\\n        diff = diff % 15;\\n    }\\n\\n    if (diff >= 5) {\\n        total += Math.floor(diff / 5);\\n        diff = diff % 5;\\n    }\\n\\n    if (diff > 0) {\\n        total += diff;\\n    }\\n\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst convertTime = function(current, correct) {\\n    const [currentHH, currentMM] = current.split(\\':\\').map((val) => Number(val));\\n    const [correctHH, correctMM] = correct.split(\\':\\').map((val) => Number(val));\\n    \\n    let total = 0;\\n    \\n    total += correctHH - currentHH;\\n    \\n    let diff = correctMM - currentMM;\\n    \\n    // for negative where needed minutes are lower than the current minutes\\n    if (correctMM < currentMM) {\\n        total -= 1;\\n        diff += 60;\\n    }\\n\\n\\n    if (diff >= 15) {\\n        total += Math.floor(diff / 15);\\n        diff = diff % 15;\\n    }\\n\\n    if (diff >= 5) {\\n        total += Math.floor(diff / 5);\\n        diff = diff % 5;\\n    }\\n\\n    if (diff > 0) {\\n        total += diff;\\n    }\\n\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929413,
                "title": "simple-greedy-solution-o-1-time",
                "content": "**In this problem greedy strategy worked because given values {60,15,5,1} are divisible with each other.**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int convertTime(string current, string correct)\\n    {\\n        // if current is same as correct we return 0\\n        if (current == correct)\\n            return 0;\\n\\n        // converting the string into int using stoi() function\\n        int h1, h2, m1, m2;\\n        h1 = stoi(current.substr(0, 2));\\n        h2 = stoi(correct.substr(0, 2));\\n        m1 = stoi(current.substr(3, 2));\\n        m2 = stoi(correct.substr(3, 2));\\n\\n        // storing the difference between current and correct\\n        int time = 0;\\n        time += (m2 - m1);\\n        time += (h2 - h1) * 60;\\n\\n        // using greedy method to find the minimum moves\\n        int ans = 0;\\n        ans += time / 60, time = time % 60;\\n        ans += time / 15, time = time % 15;\\n        ans += time / 5, time = time % 5;\\n        ans += time;\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(1)**\\n**Space Comlexity: O(1)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int convertTime(string current, string correct)\\n    {\\n        // if current is same as correct we return 0\\n        if (current == correct)\\n            return 0;\\n\\n        // converting the string into int using stoi() function\\n        int h1, h2, m1, m2;\\n        h1 = stoi(current.substr(0, 2));\\n        h2 = stoi(correct.substr(0, 2));\\n        m1 = stoi(current.substr(3, 2));\\n        m2 = stoi(correct.substr(3, 2));\\n\\n        // storing the difference between current and correct\\n        int time = 0;\\n        time += (m2 - m1);\\n        time += (h2 - h1) * 60;\\n\\n        // using greedy method to find the minimum moves\\n        int ans = 0;\\n        ans += time / 60, time = time % 60;\\n        ans += time / 15, time = time % 15;\\n        ans += time / 5, time = time % 5;\\n        ans += time;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929289,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int rem=time(correct)-time(current);\\n        int[] ops={60,15,5,1};\\n        \\n        int res=0;\\n        for(int op:ops){\\n            res+=rem/op;\\n            rem=rem%op;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int time(String time){\\n        int h=Integer.parseInt(time.split(\":\")[0]);\\n        int m=Integer.parseInt(time.split(\":\")[1]);\\n        \\n        return h*60+m;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int rem=time(correct)-time(current);\\n        int[] ops={60,15,5,1};\\n        \\n        int res=0;\\n        for(int op:ops){\\n            res+=rem/op;\\n            rem=rem%op;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int time(String time){\\n        int h=Integer.parseInt(time.split(\":\")[0]);\\n        int m=Integer.parseInt(time.split(\":\")[1]);\\n        \\n        return h*60+m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919358,
                "title": "java-o-1-simple-approach",
                "content": "```\\nclass Solution {\\n    public int convertTime(String c, String co) {\\n        String[] s1=c.split(\":\") ;\\n        String[] s2=co.split(\":\") ;\\n        int ct= Integer.parseInt(s1[0])*60 + Integer.parseInt(s1[1]);\\n        int rt= Integer.parseInt(s2[0])*60 + Integer.parseInt(s2[1]);\\n        // System.out.println(ct+\" \"+rt);\\n        int rem=rt-ct;ct=0;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/60;\\n        rem=rem%60;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/15;\\n        rem%=15;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/5;\\n        rem%=5;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/1;\\n        rem%=1;\\n        \\n        \\n        return ct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String c, String co) {\\n        String[] s1=c.split(\":\") ;\\n        String[] s2=co.split(\":\") ;\\n        int ct= Integer.parseInt(s1[0])*60 + Integer.parseInt(s1[1]);\\n        int rt= Integer.parseInt(s2[0])*60 + Integer.parseInt(s2[1]);\\n        // System.out.println(ct+\" \"+rt);\\n        int rem=rt-ct;ct=0;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/60;\\n        rem=rem%60;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/15;\\n        rem%=15;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/5;\\n        rem%=5;\\n        if(rem==0)\\n            return ct;\\n        ct+=rem/1;\\n        rem%=1;\\n        \\n        \\n        return ct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913661,
                "title": "python-simple-solution-easy-to-understand-begginners",
                "content": "```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n        l = current.split(\":\")\\n        m = correct.split(\":\")\\n        c = 0 \\n        c+=int(m[0])-int(l[0])\\n        x = int(m[1])-int(l[1])\\n        if int(m[1])<int(l[1]):\\n            c-=1\\n            x = int(m[1])\\n            x+=60-int(l[1])\\n        while x>0:\\n            if x>=15:\\n                c+=x//15 \\n                x=x%15 \\n\\n            elif x>=5:\\n                c+=x//5\\n                x = x%5\\n            else:\\n                c+=x \\n                x=0 \\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n        l = current.split(\":\")\\n        m = correct.split(\":\")\\n        c = 0 \\n        c+=int(m[0])-int(l[0])\\n        x = int(m[1])-int(l[1])\\n        if int(m[1])<int(l[1]):\\n            c-=1\\n            x = int(m[1])\\n            x+=60-int(l[1])\\n        while x>0:\\n            if x>=15:\\n                c+=x//15 \\n                x=x%15 \\n\\n            elif x>=5:\\n                c+=x//5\\n                x = x%5\\n            else:\\n                c+=x \\n                x=0 \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913524,
                "title": "greedy-and-dp-solutions-in-python",
                "content": "\\n# \\t\\tdp \\n\\t\\t\\n\\t\\t@cache\\n        def solve(i,rem):\\n            if rem<0:\\n                return INF\\n            if i==N:\\n                if rem==0:\\n                    return 0\\n                return INF\\n            remcurrent=1+solve(i,rem-nums[i])\\n            othermove=solve(i+1,rem)\\n            return min(remcurrent,othermove)\\n        \\n        def f(value):\\n            hh,mm=[int(x) for x in value.split(\\':\\')]\\n            return hh*60+mm\\n        diff=f(correct)-f(current)\\n        nums=[60,15,5,1]\\n        INF=10**10\\n        N=4\\n        return solve(0,diff)\\n# \\t\\tgreedy\\n        \\n\\t\\t\\n        def f(value):\\n            hh,mm=[int(x) for x in value.split(\\':\\')]\\n            return hh*60+mm\\n\\t\\tdiff=f(correct)-f(current)\\n        cnt=0\\n        for i in [60,15,5,1]:\\n            cnt+=diff//i\\n            diff=diff%i\\n        return cnt\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "\\n# \\t\\tdp \\n\\t\\t\\n\\t\\t@cache\\n        def solve(i,rem):\\n            if rem<0:\\n                return INF\\n            if i==N:\\n                if rem==0:\\n                    return 0\\n                return INF\\n            remcurrent=1+solve(i,rem-nums[i])\\n            othermove=solve(i+1,rem)\\n            return min(remcurrent,othermove)\\n        \\n        def f(value):\\n            hh,mm=[int(x) for x in value.split(\\':\\')]\\n            return hh*60+mm\\n        diff=f(correct)-f(current)\\n        nums=[60,15,5,1]\\n        INF=10**10\\n        N=4\\n        return solve(0,diff)\\n# \\t\\tgreedy\\n        \\n\\t\\t\\n        def f(value):\\n            hh,mm=[int(x) for x in value.split(\\':\\')]\\n            return hh*60+mm\\n\\t\\tdiff=f(correct)-f(current)\\n        cnt=0\\n        for i in [60,15,5,1]:\\n            cnt+=diff//i\\n            diff=diff%i\\n        return cnt\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1911904,
                "title": "python-greed-towards-mins",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        cur_hr,cur_min = map(int,current.split(\":\"))\\n        cor_hr,cor_min = map(int,correct.split(\":\"))\\n        \\n        cur_min = cur_min + cur_hr*60\\n        cor_min = cor_min + cor_hr*60\\n        \\n        req = abs(cur_min-cor_min)\\n        ans = 0\\n        \\n        for i in [60,15,5,1]:\\n            ans+= req//i\\n            req %= i\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        cur_hr,cur_min = map(int,current.split(\":\"))\\n        cor_hr,cor_min = map(int,correct.split(\":\"))\\n        \\n        cur_min = cur_min + cur_hr*60\\n        cor_min = cor_min + cor_hr*60\\n        \\n        req = abs(cur_min-cor_min)\\n        ans = 0\\n        \\n        for i in [60,15,5,1]:\\n            ans+= req//i\\n            req %= i\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911812,
                "title": "go-0-ms",
                "content": "```\\nfunc convertTime(current, correct string) (op int) {\\n    diff :=  minutesConversion(correct) - minutesConversion(current)\\n    for _, v := range []int{60, 15, 5, 1} {\\n            op += diff/v\\n            diff %= v\\n        }\\n    return\\n}\\n\\nfunc minutesConversion(s string) int {\\n    hours, _ := strconv.Atoi(s[:2])\\n    minutes, _ := strconv.Atoi(s[3:5])\\n    hours *= 60\\n    return hours+minutes\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc convertTime(current, correct string) (op int) {\\n    diff :=  minutesConversion(correct) - minutesConversion(current)\\n    for _, v := range []int{60, 15, 5, 1} {\\n            op += diff/v\\n            diff %= v\\n        }\\n    return\\n}\\n\\nfunc minutesConversion(s string) int {\\n    hours, _ := strconv.Atoi(s[:2])\\n    minutes, _ := strconv.Atoi(s[3:5])\\n    hours *= 60\\n    return hours+minutes\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1911381,
                "title": "java-beginner-friendly-greedy",
                "content": "This method involves converting the given time into mins. Then we find target = correct - correct. We run a loop to greedily make target as 0 using 60,15,5,1 subtractions. Here the order of subtractions is important as we want to get min operation count. I write a custom function toMins() which converts given time to mins of type int. I dont use split method or fancy java methods in conversion. \\nHere is the complete code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        //current<=correct -> correct-current\\n        int x = toMins(current);\\n        int y = toMins(correct);\\n        int target = y - x;\\n        int ops = 0;\\n        while(target>0) {\\n            if(target>=60)\\n                target = target - 60;\\n            else if(target>=15 && target<60)\\n                target = target - 15;\\n            else if(target>=5 && target<15)\\n                target = target - 5;\\n            else \\n                target = target - 1;\\n            ops++;\\n        }\\n        return ops;\\n        \\n    }\\n    private int toMins(String s) {\\n        int i = 0;\\n        while(s.charAt(i)!=\\':\\') {\\n            i++;\\n        }\\n        String hours = s.substring(0, i);\\n        String mins = s.substring(i+1, s.length());\\n        return Integer.valueOf(hours) * 60 + Integer.valueOf(mins);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        //current<=correct -> correct-current\\n        int x = toMins(current);\\n        int y = toMins(correct);\\n        int target = y - x;\\n        int ops = 0;\\n        while(target>0) {\\n            if(target>=60)\\n                target = target - 60;\\n            else if(target>=15 && target<60)\\n                target = target - 15;\\n            else if(target>=5 && target<15)\\n                target = target - 5;\\n            else \\n                target = target - 1;\\n            ops++;\\n        }\\n        return ops;\\n        \\n    }\\n    private int toMins(String s) {\\n        int i = 0;\\n        while(s.charAt(i)!=\\':\\') {\\n            i++;\\n        }\\n        String hours = s.substring(0, i);\\n        String mins = s.substring(i+1, s.length());\\n        return Integer.valueOf(hours) * 60 + Integer.valueOf(mins);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910984,
                "title": "pythontimeconverter-tc-o-1-sc-o-4",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        currentTime = 60 * int(current[:2]) + int(current[3:]) # Current time in minute\\n        targetTime = 60 * int(correct[:2]) + int(correct[3:]) # Current time in minutes\\n        diff = targetTime - currentTime\\n        count = 0\\n        for i in [60, 15, 5, 1]:\\n            count += diff // i # add number of operations needed with i to count\\n            diff %= i #subtracting the i from diff after counting the steps\\n        return count\\n```\\nreference from\\n[https://leetcode.com/anCoderr/](http://)",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        currentTime = 60 * int(current[:2]) + int(current[3:]) # Current time in minute\\n        targetTime = 60 * int(correct[:2]) + int(correct[3:]) # Current time in minutes\\n        diff = targetTime - currentTime\\n        count = 0\\n        for i in [60, 15, 5, 1]:\\n            count += diff // i # add number of operations needed with i to count\\n            diff %= i #subtracting the i from diff after counting the steps\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909955,
                "title": "convert-everything-to-minutes",
                "content": "* Convert hours to minutes.\\n* Add minutes together and find difference.\\n* Calculate greedy answer.\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current = list(map(int, current.split(\\':\\')))\\n        correct = list(map(int, correct.split(\\':\\')))\\n        \\n        current = current[0] * 60 + current[1]\\n        correct = correct[0] * 60 + correct[1]\\n        \\n        diff = correct - current\\n        ans = 0\\n        for val in (60, 15, 5, 1):\\n            while diff >= val:\\n                ans += 1\\n                diff -= val\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current = list(map(int, current.split(\\':\\')))\\n        correct = list(map(int, correct.split(\\':\\')))\\n        \\n        current = current[0] * 60 + current[1]\\n        correct = correct[0] * 60 + correct[1]\\n        \\n        diff = correct - current\\n        ans = 0\\n        for val in (60, 15, 5, 1):\\n            while diff >= val:\\n                ans += 1\\n                diff -= val\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909837,
                "title": "c-greedy",
                "content": "```\\n  \\n       int h1=(curr[1]-\\'0\\');\\n        h1=h1+ (curr[0]-\\'0\\')*10;\\n        \\n          int min1=(curr[4]-\\'0\\');\\n        min1=min1+ (curr[3]-\\'0\\')*10;\\n        \\n         int min2=(right[4]-\\'0\\');\\n        min2=min2+ (right[3]-\\'0\\')*10;\\n        \\n        int h2=(right[1]-\\'0\\');\\n        h2= h2 + (right[0]-\\'0\\')*10;\\n        \\n        int ans=0;\\n       int min;\\n        if(min2>=min1)\\n        {\\n            ans+=(h2-h1);\\n            min=min2-min1;\\n        }\\n        else\\n        {\\n            ans+=(h2-h1)-1;\\n            min=(min2-min1 + 60);\\n            \\n        }\\n        \\n        while(min!=0)\\n        {\\n           if(min>=15)\\n           {\\n               min-=15;\\n               ans++;\\n           }\\n            else\\n           {\\n              if(min<15 && min>=5)\\n              {\\n                  min-=5;\\n                  ans++;\\n              }\\n                else\\n                {\\n                    min-=1;\\n                    ans++;\\n                }\\n           }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  \\n       int h1=(curr[1]-\\'0\\');\\n        h1=h1+ (curr[0]-\\'0\\')*10;\\n        \\n          int min1=(curr[4]-\\'0\\');\\n        min1=min1+ (curr[3]-\\'0\\')*10;\\n        \\n         int min2=(right[4]-\\'0\\');\\n        min2=min2+ (right[3]-\\'0\\')*10;\\n        \\n        int h2=(right[1]-\\'0\\');\\n        h2= h2 + (right[0]-\\'0\\')*10;\\n        \\n        int ans=0;\\n       int min;\\n        if(min2>=min1)\\n        {\\n            ans+=(h2-h1);\\n            min=min2-min1;\\n        }\\n        else\\n        {\\n            ans+=(h2-h1)-1;\\n            min=(min2-min1 + 60);\\n            \\n        }\\n        \\n        while(min!=0)\\n        {\\n           if(min>=15)\\n           {\\n               min-=15;\\n               ans++;\\n           }\\n            else\\n           {\\n              if(min<15 && min>=5)\\n              {\\n                  min-=5;\\n                  ans++;\\n              }\\n                else\\n                {\\n                    min-=1;\\n                    ans++;\\n                }\\n           }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909751,
                "title": "convert-to-minutes-short-and-clear",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int start_min = ((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60+(current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n        int end_min = ((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60+(correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n        int diff = end_min-start_min, tot=0;\\n        for(auto x:{60,15,5,1})\\n        {\\n            tot+=diff/x;\\n            diff=max(0,diff-(diff/x)*x);\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int start_min = ((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60+(current[3]-\\'0\\')*10+(current[4]-\\'0\\');\\n        int end_min = ((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60+(correct[3]-\\'0\\')*10+(correct[4]-\\'0\\');\\n        int diff = end_min-start_min, tot=0;\\n        for(auto x:{60,15,5,1})\\n        {\\n            tot+=diff/x;\\n            diff=max(0,diff-(diff/x)*x);\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909748,
                "title": "c-easy-with-explanation",
                "content": "\\n    int convertTime(string current, string correct) {\\n        int ans = 0,currH=0,currM=0,finH=0,finM=0,diff_min,diff_hr;\\n        currH = stoi(current.substr(0,2)); // extracting the current hour\\n        currM = stoi(current.substr(3,2)); // extracting the current minute\\n        finH = stoi(correct.substr(0,2)); // extracting final/correct hour\\n        finM = stoi(correct.substr(3,2)); // extracting final/correct minute\\n        if(currM > finM){\\n            diff_min = 60 - abs(currM - finM);    // if curr minutes are more than calculating diff in minutes by moving 1 hour back\\n        }\\n        else{\\n            diff_min = abs(currM - finM);  // else normal diff\\n        }\\n        if(currM > finM) currH++; \\n        diff_hr = abs(currH - finH); \\n        while(diff_min){                               // calculating how much steps to make minutes correct\\n            if(diff_min >= 15) diff_min -= 15;\\n            else if(diff_min >= 5) diff_min -= 5;\\n            else diff_min -= 1;\\n            ans++;\\n        }\\n        \\n        while(diff_hr){ // calculating how much steps to make hour correct\\n            diff_hr -= 1;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "\\n    int convertTime(string current, string correct) {\\n        int ans = 0,currH=0,currM=0,finH=0,finM=0,diff_min,diff_hr;\\n        currH = stoi(current.substr(0,2)); // extracting the current hour\\n        currM = stoi(current.substr(3,2)); // extracting the current minute\\n        finH = stoi(correct.substr(0,2)); // extracting final/correct hour\\n        finM = stoi(correct.substr(3,2)); // extracting final/correct minute\\n        if(currM > finM){\\n            diff_min = 60 - abs(currM - finM);    // if curr minutes are more than calculating diff in minutes by moving 1 hour back\\n        }\\n        else{\\n            diff_min = abs(currM - finM);  // else normal diff\\n        }\\n        if(currM > finM) currH++; \\n        diff_hr = abs(currH - finH); \\n        while(diff_min){                               // calculating how much steps to make minutes correct\\n            if(diff_min >= 15) diff_min -= 15;\\n            else if(diff_min >= 5) diff_min -= 5;\\n            else diff_min -= 1;\\n            ans++;\\n        }\\n        \\n        while(diff_hr){ // calculating how much steps to make hour correct\\n            diff_hr -= 1;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909355,
                "title": "c-convert-to-minutes",
                "content": "```\\n* Convert to minutes and find the difference\\n* check for every minute and store in result\\n```\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint get(string &s){\\n\\t\\t\\treturn stoi(s.substr(0,2))*60 + stoi(s.substr(3));\\n\\t\\t}\\n\\n\\t\\tint convertTime(string current, string correct) {\\n\\t\\t\\tint res = 0,diff = get(correct)-get(current);\\n\\t\\t\\tfor(auto num:{60,15,5,1}){\\n\\t\\t\\t\\tres+= diff/num;\\n\\t\\t\\t\\tdiff%=num;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "```\\n* Convert to minutes and find the difference\\n* check for every minute and store in result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909213,
                "title": "easy-c-solution-converting-time-to-minutes",
                "content": "1. First Convert the time format to minutes\\n2. then try to minimize the no. of operations\\n\\n```\\nclass Solution {\\npublic:\\n    int removecol(string s)\\n    {\\n        if(s.size() == 4)\\n            s.replace(1,1,\"\");\\n        if(s.size() == 5)\\n            s.replace(2,1,\"\");\\n        \\n        return stoi(s);\\n    }\\n    int convertTime(string current, string correct) {\\n           \\n        int time1 = removecol(current);\\n        int time2 = removecol(correct);\\n        \\n        int min1 = (time1/100)*60 + time1%100;\\n        int min2 = (time2/100)*60 + time2%100;      \\n        \\n        int op = 0;\\n        \\n        vector<int> timarr = {60,15,5,1};\\n        int diff = min2 - min1;\\n        for(int i=0; i<timarr.size(); i++)\\n        {\\n            op += (diff) / timarr[i];\\n            diff = diff % timarr[i];\\n        }\\n        \\n        return op;\\n    }\\n};\\n```\\n\\nPLS UPVOTE ME!!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removecol(string s)\\n    {\\n        if(s.size() == 4)\\n            s.replace(1,1,\"\");\\n        if(s.size() == 5)\\n            s.replace(2,1,\"\");\\n        \\n        return stoi(s);\\n    }\\n    int convertTime(string current, string correct) {\\n           \\n        int time1 = removecol(current);\\n        int time2 = removecol(correct);\\n        \\n        int min1 = (time1/100)*60 + time1%100;\\n        int min2 = (time2/100)*60 + time2%100;      \\n        \\n        int op = 0;\\n        \\n        vector<int> timarr = {60,15,5,1};\\n        int diff = min2 - min1;\\n        for(int i=0; i<timarr.size(); i++)\\n        {\\n            op += (diff) / timarr[i];\\n            diff = diff % timarr[i];\\n        }\\n        \\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909194,
                "title": "2-lines-simple-solution-c-explanation",
                "content": "* No need to convert string characters to integer. Just subtract the corresponding pairs of digits\\n* Convert time into minutes\\n* Apply the operations using 60, 15, 5, 1 as described\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int n = ((correct[0]-current[0])*600) + ((correct[1]-current[1])*60) + ((correct[3]-current[3])*10) + correct[4]-current[4];\\n        return (n / 60) + (n % 60 / 15) + (n % 60 % 15 / 5) + (n % 60 % 15 % 5);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int n = ((correct[0]-current[0])*600) + ((correct[1]-current[1])*60) + ((correct[3]-current[3])*10) + correct[4]-current[4];\\n        return (n / 60) + (n % 60 / 15) + (n % 60 % 15 / 5) + (n % 60 % 15 % 5);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909126,
                "title": "python-easy-and-clear-solution",
                "content": "1. First we find difference between the hours and minutes as ```h``` and `m`\\n2. Convert the difference in hours to minutes by `h*60`, then add it with the `m`.\\n1. Use a counter variable, here taking it as `count=0` \\n1. Given we can add `60,15,5,1 `minutes in a a single step, so to find minimum no steps we check from 60 minutes then 15 then 5 and atlast 1 minute.\\n1. If the total difference in minutes is larger than 60, we add the quotient `dit//60` of to count to see how many 60 minutes we have added, and store the remainder in `dit` .\\n1. Ex: If we have 75, `75//60 =1 `, so count is increased by 1, then the remainder `15` is stored in dit.\\n1. if we have dit as 120, count would be increased by 2, since `120//60=2`.\\n1. Same happens for 15, 5 and 1 only the remaining minutes is passed through dit, thus minimizing no:of operations to convert.\\nLiked the Solution, Give a Upvote :)\\n```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        if current==correct:\\n            return 0\\n        h=int(correct[:2])-int(current[:2])\\n        m=int(correct[3:])-int(current[3:])\\n        dit=h*60+m\\n        count=0\\n        if dit>=60:\\n            count+=dit//60\\n            dit=dit%60\\n        if dit>=15:\\n            count+=dit//15\\n            dit=dit%15   \\n        if dit>=5:\\n            count+=dit//5\\n            dit=dit%5    \\n        if dit>=1:\\n            count+=dit//1\\n            dit=dit%1    \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```h```\n```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        if current==correct:\\n            return 0\\n        h=int(correct[:2])-int(current[:2])\\n        m=int(correct[3:])-int(current[3:])\\n        dit=h*60+m\\n        count=0\\n        if dit>=60:\\n            count+=dit//60\\n            dit=dit%60\\n        if dit>=15:\\n            count+=dit//15\\n            dit=dit%15   \\n        if dit>=5:\\n            count+=dit//5\\n            dit=dit%5    \\n        if dit>=1:\\n            count+=dit//1\\n            dit=dit%1    \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1909105,
                "title": "easy-python-two-lines",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        final = (int(correct[0:2]) - int(current[0:2]))*60 + int(correct[3:]) - int(current[3:])\\n        return final//60 + (final%60)//15 + ((final%60)%15)//5 + (((final%60)%15)%5)//1\\n```\\n\\nBasically convert into minutes and count.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        final = (int(correct[0:2]) - int(current[0:2]))*60 + int(correct[3:]) - int(current[3:])\\n        return final//60 + (final%60)//15 + ((final%60)%15)//5 + (((final%60)%15)%5)//1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909032,
                "title": "easy-java-solution-by-converting-to-minutes-2ms-beats-100",
                "content": "Convert the time to minutes and then take the difference.\\nDivide difference starting with the highest increment and then take the mod of of difference by increment to find the next possible increase. \\n\\n```\\n    public static int convertTime(String current, String correct) {\\n        int currentMinute = Integer.parseInt(current.split(\":\")[0]) * 60 + Integer.parseInt(current.split(\":\")[1]);\\n        int correctMinute = Integer.parseInt(correct.split(\":\")[0]) * 60 + Integer.parseInt(correct.split(\":\")[1]);\\n        int diff = correctMinute - currentMinute;\\n        int count = 0;\\n        int[] increments = new int[]{60, 15, 5, 1};\\n\\n        for (int increment : increments){\\n            count += diff / increment;\\n            diff %= increment;\\n        }\\n        return count;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static int convertTime(String current, String correct) {\\n        int currentMinute = Integer.parseInt(current.split(\":\")[0]) * 60 + Integer.parseInt(current.split(\":\")[1]);\\n        int correctMinute = Integer.parseInt(correct.split(\":\")[0]) * 60 + Integer.parseInt(correct.split(\":\")[1]);\\n        int diff = correctMinute - currentMinute;\\n        int count = 0;\\n        int[] increments = new int[]{60, 15, 5, 1};\\n\\n        for (int increment : increments){\\n            count += diff / increment;\\n            diff %= increment;\\n        }\\n        return count;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908898,
                "title": "c-easy-minutes",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int h1=(int)(current[0]*10+current[1]);\\n        int h2=(int)(correct[0]*10+correct[1]);\\n        int m1=(int)(current[3]*10+current[4]);\\n        int m2=(int)(correct[3]*10+correct[4]);\\n        \\n        int hour_diff=h2-h1-1;\\n        int min_diff=m2+(60-m1);\\n        \\n        if(min_diff>=60){\\n            hour_diff++;\\n            min_diff=min_diff-60;\\n        }\\n        \\n        if(hour_diff==0 && min_diff==0)return 0;\\n        \\n        int ans=0;\\n        if(hour_diff>0)\\n        {\\n            ans+=hour_diff; //add 60 minutes\\n        }\\n        while(min_diff!=0){\\n            if(min_diff-15>=0){\\n                ans++;\\n                min_diff-=15;\\n            }\\n            else if(min_diff-5>=0){\\n                ans++;\\n                min_diff-=5;\\n            }\\n            else if(min_diff-1>=0){\\n                ans++;\\n                min_diff-=1;\\n            }\\n        }        \\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease let me know how to improve my solution.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int h1=(int)(current[0]*10+current[1]);\\n        int h2=(int)(correct[0]*10+correct[1]);\\n        int m1=(int)(current[3]*10+current[4]);\\n        int m2=(int)(correct[3]*10+correct[4]);\\n        \\n        int hour_diff=h2-h1-1;\\n        int min_diff=m2+(60-m1);\\n        \\n        if(min_diff>=60){\\n            hour_diff++;\\n            min_diff=min_diff-60;\\n        }\\n        \\n        if(hour_diff==0 && min_diff==0)return 0;\\n        \\n        int ans=0;\\n        if(hour_diff>0)\\n        {\\n            ans+=hour_diff; //add 60 minutes\\n        }\\n        while(min_diff!=0){\\n            if(min_diff-15>=0){\\n                ans++;\\n                min_diff-=15;\\n            }\\n            else if(min_diff-5>=0){\\n                ans++;\\n                min_diff-=5;\\n            }\\n            else if(min_diff-1>=0){\\n                ans++;\\n                min_diff-=1;\\n            }\\n        }        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908869,
                "title": "convert-to-minutes-time-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ch=0;\\n        int cm=0;\\n        int crh=0;\\n        int crm=0;\\n        int count=0;\\n        ch=stoi(current.substr(0,2));\\n        cm=stoi(current.substr(3,2));\\n        \\n        int csec=ch*60+cm;\\n        crh=stoi(correct.substr(0,2));\\n        crm=stoi(correct.substr(3,2));\\n        int crsec=crh*60+crm;\\n        \\n        int req=crsec-csec;\\n        if(req<0)\\n        {\\n            req+=60*24;\\n        }\\n       \\n        while(req>0)\\n        {\\n            if(req>=60)\\n            {\\n                int left=req%60;\\n                count+=req/60;\\n                req=left;\\n            }\\n            else if(req>=15)\\n            {\\n                int left=req%15;\\n                count+=req/15;\\n                req=left;\\n            }\\n            else if(req>=5)\\n            {\\n                int left=req%5;\\n                count+=req/5;\\n                req=left;\\n            }\\n            else if(req>=1)\\n            {   count+=req/1;\\n                req=0;\\n            }\\n        }\\n      return count;\\n        \\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ch=0;\\n        int cm=0;\\n        int crh=0;\\n        int crm=0;\\n        int count=0;\\n        ch=stoi(current.substr(0,2));\\n        cm=stoi(current.substr(3,2));\\n        \\n        int csec=ch*60+cm;\\n        crh=stoi(correct.substr(0,2));\\n        crm=stoi(correct.substr(3,2));\\n        int crsec=crh*60+crm;\\n        \\n        int req=crsec-csec;\\n        if(req<0)\\n        {\\n            req+=60*24;\\n        }\\n       \\n        while(req>0)\\n        {\\n            if(req>=60)\\n            {\\n                int left=req%60;\\n                count+=req/60;\\n                req=left;\\n            }\\n            else if(req>=15)\\n            {\\n                int left=req%15;\\n                count+=req/15;\\n                req=left;\\n            }\\n            else if(req>=5)\\n            {\\n                int left=req%5;\\n                count+=req/5;\\n                req=left;\\n            }\\n            else if(req>=1)\\n            {   count+=req/1;\\n                req=0;\\n            }\\n        }\\n      return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908815,
                "title": "python-intuitive-easy-solution",
                "content": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current = current.split(\\':\\')\\n        correct = correct.split(\\':\\')\\n        minute_diff = int(correct[1]) - int(current[1])\\n        ops = 0\\n        if minute_diff >= 0:\\n            ops += int(correct[0]) - int(current[0])\\n        else:\\n            ops += int(correct[0]) - int(current[0]) - 1\\n            minute_diff += 60\\n        ops += minute_diff // 15\\n        minute_diff = minute_diff % 15\\n        ops += minute_diff // 5\\n        minute_diff = minute_diff % 5\\n        ops += minute_diff\\n        return ops\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        current = current.split(\\':\\')\\n        correct = correct.split(\\':\\')\\n        minute_diff = int(correct[1]) - int(current[1])\\n        ops = 0\\n        if minute_diff >= 0:\\n            ops += int(correct[0]) - int(current[0])\\n        else:\\n            ops += int(correct[0]) - int(current[0]) - 1\\n            minute_diff += 60\\n        ops += minute_diff // 15\\n        minute_diff = minute_diff % 15\\n        ops += minute_diff // 5\\n        minute_diff = minute_diff % 5\\n        ops += minute_diff\\n        return ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908712,
                "title": "python-convert-to-minutes-and-reduce",
                "content": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        x = int(current[:2]) * 60 + int(current[3:])\\n        y = int(correct[:2]) * 60 + int(correct[3:])\\n        res = 0\\n        diff = abs(x - y)\\n        while diff > 0:\\n            if diff >= 60:\\n                diff -= 60\\n            elif diff >= 15:\\n                diff -= 15\\n            elif diff >= 5:\\n                diff -= 5\\n            elif diff >= 1:\\n                diff -= 1\\n            res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef convertTime(self, current: str, correct: str) -> int:\\n        x = int(current[:2]) * 60 + int(current[3:])\\n        y = int(correct[:2]) * 60 + int(correct[3:])\\n        res = 0\\n        diff = abs(x - y)\\n        while diff > 0:\\n            if diff >= 60:\\n                diff -= 60\\n            elif diff >= 15:\\n                diff -= 15\\n            elif diff >= 5:\\n                diff -= 5\\n            elif diff >= 1:\\n                diff -= 1\\n            res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1908711,
                "title": "python-1-liner",
                "content": "Algorithm:\\n1. Split the strings at `:` and convert each element to `int()`.\\n2. If `correct` time minutes is `less` than `current` time minutes, `subtract 1` from `correct` time hours and `add 60` to `correct` time minutes.\\n3. return `difference` between the time hours `plus` the number of operation to make `correct` time minutes which can be calculated by `dividing` the difference in minutes by `15`, `5` and `1` respectively.\\n\\n```\\nclass Solution(object):\\n    def convertTime(self, cu, co):\\n        return ((lambda x : (x[2] - x[0])+ (x[3]-x[1])//15 + ((x[3]-x[1])%15)//5 + ((x[3]-x[1])%15)%5)((lambda a, b, c, d  : [a, b, c-1, d+60] if d < b else [a, b, c, d])(int(cu.split(\\':\\')[0]), int(cu.split(\\':\\')[1]),int(co.split(\\':\\')[0]), int(co.split(\\':\\')[1]))))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertTime(self, cu, co):\\n        return ((lambda x : (x[2] - x[0])+ (x[3]-x[1])//15 + ((x[3]-x[1])%15)//5 + ((x[3]-x[1])%15)%5)((lambda a, b, c, d  : [a, b, c-1, d+60] if d < b else [a, b, c, d])(int(cu.split(\\':\\')[0]), int(cu.split(\\':\\')[1]),int(co.split(\\':\\')[0]), int(co.split(\\':\\')[1]))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088043,
                "title": "greedy-approach-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int time=0, ans=0;\\n        int currentmins = current[3]*10 + current[4];\\n        int correctmins = correct[3]*10 + correct[4];\\n        int currenthours = current[0]*10 + current[1];\\n        int correcthours = correct[0]*10 + correct[1];\\n        int mindiff = 0, hourdiff = 0;\\n        if(correctmins < currentmins) \\n        {\\n            mindiff = (60-currentmins) + correctmins;\\n            hourdiff = abs(correcthours - currenthours-1);\\n        }\\n        else \\n        {\\n            mindiff = abs(correctmins - currentmins);\\n            hourdiff = abs(correcthours - currenthours);\\n        }\\n        time = mindiff + hourdiff*60;\\n        while(time != 0)\\n        {\\n            if(time>=60) time-=60;\\n            else if(time>=15) time-=15;\\n            else if(time>=5)  time-=5;\\n            else if(time>=1)  time-=1;\\n            ans++;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int time=0, ans=0;\\n        int currentmins = current[3]*10 + current[4];\\n        int correctmins = correct[3]*10 + correct[4];\\n        int currenthours = current[0]*10 + current[1];\\n        int correcthours = correct[0]*10 + correct[1];\\n        int mindiff = 0, hourdiff = 0;\\n        if(correctmins < currentmins) \\n        {\\n            mindiff = (60-currentmins) + correctmins;\\n            hourdiff = abs(correcthours - currenthours-1);\\n        }\\n        else \\n        {\\n            mindiff = abs(correctmins - currentmins);\\n            hourdiff = abs(correcthours - currenthours);\\n        }\\n        time = mindiff + hourdiff*60;\\n        while(time != 0)\\n        {\\n            if(time>=60) time-=60;\\n            else if(time>=15) time-=15;\\n            else if(time>=5)  time-=5;\\n            else if(time>=1)  time-=1;\\n            ans++;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087907,
                "title": "short-and-simple-convert-to-minutes",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nvar convertTime = function(current, correct) {\\n    const steps = [60, 15, 5, 1];\\n    const currentTimeInMinutes = convertToMinutes(current);\\n    const correctTimeInMinutes = convertToMinutes(correct);\\n    let diff = correctTimeInMinutes - currentTimeInMinutes;\\n    let operationsCount = 0;\\n\\n    for (const step of steps) {\\n        const currentStepsCount = Math.floor(diff / step);\\n        operationsCount += currentStepsCount;\\n        diff -= currentStepsCount * step;\\n        if (diff === 0) break;\\n    }\\n    return operationsCount;\\n};\\n\\nfunction convertToMinutes(time) {\\n    const [hours, minutes] = Array.from(time.split(\\':\\'), Number);\\n    return hours * 60 + minutes;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convertTime = function(current, correct) {\\n    const steps = [60, 15, 5, 1];\\n    const currentTimeInMinutes = convertToMinutes(current);\\n    const correctTimeInMinutes = convertToMinutes(correct);\\n    let diff = correctTimeInMinutes - currentTimeInMinutes;\\n    let operationsCount = 0;\\n\\n    for (const step of steps) {\\n        const currentStepsCount = Math.floor(diff / step);\\n        operationsCount += currentStepsCount;\\n        diff -= currentStepsCount * step;\\n        if (diff === 0) break;\\n    }\\n    return operationsCount;\\n};\\n\\nfunction convertToMinutes(time) {\\n    const [hours, minutes] = Array.from(time.split(\\':\\'), Number);\\n    return hours * 60 + minutes;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080932,
                "title": "simple-and-easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curH = (current.charAt(0)-\\'0\\')*10 +current.charAt(1)-\\'0\\';\\n        int corH = (correct.charAt(0)-\\'0\\')*10 +correct.charAt(1)-\\'0\\';\\n        int curM = (current.charAt(3)-\\'0\\')*10 +current.charAt(4)-\\'0\\';\\n        int corM = (correct.charAt(3)-\\'0\\')*10 +correct.charAt(4)-\\'0\\';\\n\\n        int curr = curH*60 + curM;\\n        int corr = corH*60 + corM;\\n        int diff = Math.abs(curr-corr);\\n        int ans=0;\\n\\n        while( diff != 0){\\n            if(diff -60 >= 0) diff -=60;\\n            else if(diff -15 >= 0) diff -=15;\\n            else if(diff -5 >= 0) diff -=5;\\n            else diff--; \\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int curH = (current.charAt(0)-\\'0\\')*10 +current.charAt(1)-\\'0\\';\\n        int corH = (correct.charAt(0)-\\'0\\')*10 +correct.charAt(1)-\\'0\\';\\n        int curM = (current.charAt(3)-\\'0\\')*10 +current.charAt(4)-\\'0\\';\\n        int corM = (correct.charAt(3)-\\'0\\')*10 +correct.charAt(4)-\\'0\\';\\n\\n        int curr = curH*60 + curM;\\n        int corr = corH*60 + corM;\\n        int diff = Math.abs(curr-corr);\\n        int ans=0;\\n\\n        while( diff != 0){\\n            if(diff -60 >= 0) diff -=60;\\n            else if(diff -15 >= 0) diff -=15;\\n            else if(diff -5 >= 0) diff -=5;\\n            else diff--; \\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075160,
                "title": "2224",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        String[] c1 = current.split(\":\");\\n        String[] c2 = correct.split(\":\");\\n        int h1 = Integer.valueOf(c1[0])*60+Integer.valueOf(c1[1]);\\n        int h2 = Integer.valueOf(c2[0])*60+Integer.valueOf(c2[1]);\\n        int m = Math.abs(h1-h2);\\n        int count =0;\\n        int time;\\n        if(m>=60){\\n            time = m/60;\\n            count += time;                \\n            m %= 60;\\n        }\\n        if(m>=15){\\n            time = m/15;\\n            count += time;\\n            m %= 15;\\n        }\\n        if(m>=5){\\n            time = m/5;\\n            count += time;\\n            m %= 5;\\n        }\\n        if(m>=1){\\n            count += m;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        String[] c1 = current.split(\":\");\\n        String[] c2 = correct.split(\":\");\\n        int h1 = Integer.valueOf(c1[0])*60+Integer.valueOf(c1[1]);\\n        int h2 = Integer.valueOf(c2[0])*60+Integer.valueOf(c2[1]);\\n        int m = Math.abs(h1-h2);\\n        int count =0;\\n        int time;\\n        if(m>=60){\\n            time = m/60;\\n            count += time;                \\n            m %= 60;\\n        }\\n        if(m>=15){\\n            time = m/15;\\n            count += time;\\n            m %= 15;\\n        }\\n        if(m>=5){\\n            time = m/5;\\n            count += time;\\n            m %= 5;\\n        }\\n        if(m>=1){\\n            count += m;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074611,
                "title": "simple-greedy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nconst increases = [60,15,5,1]\\nvar convertTime = function(current, correct) {\\n  const [h1,m1] = current.split(\":\").map(Number)\\n  const [h2,m2] = correct.split(\":\").map(Number)\\n  let dif = (h2-h1) * 60 + m2 - m1\\n  let count = 0\\n  while(dif){\\n    for(let i = 0; i < increases.length; i++){\\n      if(dif - increases[i] >= 0){\\n        dif -=  increases[i];\\n        break;\\n      }\\n    }\\n    count++\\n  }\\n  return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nconst increases = [60,15,5,1]\\nvar convertTime = function(current, correct) {\\n  const [h1,m1] = current.split(\":\").map(Number)\\n  const [h2,m2] = correct.split(\":\").map(Number)\\n  let dif = (h2-h1) * 60 + m2 - m1\\n  let count = 0\\n  while(dif){\\n    for(let i = 0; i < increases.length; i++){\\n      if(dif - increases[i] >= 0){\\n        dif -=  increases[i];\\n        break;\\n      }\\n    }\\n    count++\\n  }\\n  return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043783,
                "title": "java-fastest-1ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int h1 = Integer.parseInt(current.substring(0, 2));\\n        int h2 = Integer.parseInt(correct.substring(0, 2));\\n        \\n        int m1 = Integer.parseInt(current.substring(3, 5));\\n        int m2 = Integer.parseInt(correct.substring(3, 5));\\n        \\n       \\n        int hm = (h2 - h1)*60;\\n        int m = m2 - m1;\\n      \\n        int c = 0;\\n        int cnt = 0;\\n\\n        if(m2 < m1){\\n            hm = hm - 60;\\n            m = m + 60;\\n        }\\n\\n        if(m >= 60 || hm >= 60){\\n            c = m/60;\\n            m = m - c*60;\\n            cnt += c;\\n\\n            c = hm/60;\\n            hm = hm - c*60;\\n            cnt+=c;\\n        }\\n        \\n        if(m >= 15){\\n            c = m/15;\\n            m = m - c*15;\\n            cnt += c;\\n        }\\n\\n        if(m >= 5){\\n            c = m/5;\\n            m = m-c*5;\\n            cnt += c;\\n        }\\n\\n        cnt += m;\\n       \\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int h1 = Integer.parseInt(current.substring(0, 2));\\n        int h2 = Integer.parseInt(correct.substring(0, 2));\\n        \\n        int m1 = Integer.parseInt(current.substring(3, 5));\\n        int m2 = Integer.parseInt(correct.substring(3, 5));\\n        \\n       \\n        int hm = (h2 - h1)*60;\\n        int m = m2 - m1;\\n      \\n        int c = 0;\\n        int cnt = 0;\\n\\n        if(m2 < m1){\\n            hm = hm - 60;\\n            m = m + 60;\\n        }\\n\\n        if(m >= 60 || hm >= 60){\\n            c = m/60;\\n            m = m - c*60;\\n            cnt += c;\\n\\n            c = hm/60;\\n            hm = hm - c*60;\\n            cnt+=c;\\n        }\\n        \\n        if(m >= 15){\\n            c = m/15;\\n            m = m - c*15;\\n            cnt += c;\\n        }\\n\\n        if(m >= 5){\\n            c = m/5;\\n            m = m-c*5;\\n            cnt += c;\\n        }\\n\\n        cnt += m;\\n       \\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040106,
                "title": "simple-solution-in-c-greedy-appraoch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst we calculate the time into only minutes so the on subtracted the time we dont get any error.Then we got difference of time(min)that we have to coverd into minimum usage of {60,15,5,1}. As we clearly see by using these we can make any number so we have to tell what minimum usage of number to attain the difference. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int h(string s){\\n        return stoi(s.substr(0,2))*60+stoi(s.substr(3,5));\\n    }\\n    int convertTime(string current, string correct) {\\n        int ans=0;\\n        int d=h(correct)-h(current);\\n        vector<int> nums={60,15,5,1};\\n        for(int i=0;i<4;i++){\\n            ans+=(d/nums[i]);\\n            d=d%nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int h(string s){\\n        return stoi(s.substr(0,2))*60+stoi(s.substr(3,5));\\n    }\\n    int convertTime(string current, string correct) {\\n        int ans=0;\\n        int d=h(correct)-h(current);\\n        vector<int> nums={60,15,5,1};\\n        for(int i=0;i<4;i++){\\n            ans+=(d/nums[i]);\\n            d=d%nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031176,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h,m = s.split(\":\")\\n            return 60*(int(h)) + int(m)\\n        \\n        n = toMinutes(correct) - toMinutes(current)\\n\\n        ops = 0\\n        while n > 0:\\n            if n >= 60:\\n                n -= 60\\n                ops += 1\\n            elif n >= 15:\\n                n -= 15\\n                ops += 1\\n            elif n >= 5:\\n                n -= 5\\n                ops += 1\\n            elif n >= 1:\\n                n -= 1\\n                ops += 1\\n\\n        return ops\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def toMinutes(s):\\n            h,m = s.split(\":\")\\n            return 60*(int(h)) + int(m)\\n        \\n        n = toMinutes(correct) - toMinutes(current)\\n\\n        ops = 0\\n        while n > 0:\\n            if n >= 60:\\n                n -= 60\\n                ops += 1\\n            elif n >= 15:\\n                n -= 15\\n                ops += 1\\n            elif n >= 5:\\n                n -= 5\\n                ops += 1\\n            elif n >= 1:\\n                n -= 1\\n                ops += 1\\n\\n        return ops\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025761,
                "title": "python-two-approaches-time-logic-convert-into-minutes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force and Convert to Minutes\\n\\n# Approach - 1\\n<!-- Describe your approach to solving the problem. -->\\nFind the difference b/w hours and minutes if minutes difference is less than 0 then reduce the hours diff by 1.\\nno.of sixty minutes used is the hrs diff and calculate 15 mins, 5 mins, 1 mins using divide and modulo\\n\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        h = int(h2) - int(h1)\\n        m = int(m2) - int(m1)\\n        if m < 0:\\n            h -= 1\\n            m += 60\\n        for i in [15,5,1]:\\n            h += m//i\\n            m %= i\\n        return h \\n```\\n\\n\\n# Approach - 2\\n<!-- Describe your approach to solving the problem. -->\\nConvert the given time into minutes and find the difference and count the 60 mins 15 mins 5 mins 1 mins used using divide and modulo method.\\n\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        time_diff=((60*int(h2))+int(m2))-((60*int(h1))+int(m1))\\n        ans=0;time=[60,15,5,1]\\n        for i in time:\\n            ans += time_diff // i \\n            time_diff %= i\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        h = int(h2) - int(h1)\\n        m = int(m2) - int(m1)\\n        if m < 0:\\n            h -= 1\\n            m += 60\\n        for i in [15,5,1]:\\n            h += m//i\\n            m %= i\\n        return h \\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        h1, m1 = current.split(\\':\\')\\n        h2, m2 = correct.split(\\':\\')\\n        time_diff=((60*int(h2))+int(m2))-((60*int(h1))+int(m1))\\n        ans=0;time=[60,15,5,1]\\n        for i in time:\\n            ans += time_diff // i \\n            time_diff %= i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023722,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function (current, correct) {\\n\\n    // if string current is equal to string correct then return zero\\n    if (current === correct) return 0;\\n\\n    // initialize count to zero\\n    let count = 0;\\n\\n    // find total minutes from string current time using parsInt() and slice()\\n    let currentInMins = parseInt(current.slice(3)) + parseInt(current.slice(0, 2)) * 60;\\n\\n    // find total minutes from string correct time using parsInt() and slice()\\n    let correcttInMins = parseInt(correct.slice(3)) + parseInt(correct.slice(0, 2)) * 60;\\n\\n    // find minute Difference of correcttInMins and currentInMins\\n    let minuteDifference = correcttInMins - currentInMins;\\n\\n\\n    // while minuteDifference is not equal to zero then continue the loop\\n    while (minuteDifference !== 0) {\\n\\n        // if minuteDifference divide by 60\\n        if (minuteDifference % 60 === 0) {\\n\\n            // find minuteDiffCount by dividing minuteDifference to 60\\n            let minuteDiffCount = parseInt(minuteDifference / 60);\\n\\n            // subtract minuteDifference by multiplying minuteDiffCount\\n            minuteDifference -= (minuteDiffCount * 60);\\n\\n            // add minuteDifference to count\\n            count += minuteDiffCount;\\n\\n        } // else if minuteDifference divide by 15\\n        else if (minuteDifference % 15 === 0) {\\n\\n            // subtract minuteDifference by 15\\n            minuteDifference -= 15;\\n\\n            // increment the count\\n            count++;\\n\\n        } // else if minuteDifference divide by 5\\n        else if (minuteDifference % 5 === 0) {\\n\\n            // subtract minuteDifference by 5\\n            minuteDifference -= 5;\\n\\n            // increment the count\\n            count++;\\n\\n        } // else\\n        else {\\n\\n            // subtract minuteDifference by 1\\n            minuteDifference -= 1;\\n\\n            // increment the count\\n            count++;\\n        }\\n    }\\n\\n    // return the count\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function (current, correct) {\\n\\n    // if string current is equal to string correct then return zero\\n    if (current === correct) return 0;\\n\\n    // initialize count to zero\\n    let count = 0;\\n\\n    // find total minutes from string current time using parsInt() and slice()\\n    let currentInMins = parseInt(current.slice(3)) + parseInt(current.slice(0, 2)) * 60;\\n\\n    // find total minutes from string correct time using parsInt() and slice()\\n    let correcttInMins = parseInt(correct.slice(3)) + parseInt(correct.slice(0, 2)) * 60;\\n\\n    // find minute Difference of correcttInMins and currentInMins\\n    let minuteDifference = correcttInMins - currentInMins;\\n\\n\\n    // while minuteDifference is not equal to zero then continue the loop\\n    while (minuteDifference !== 0) {\\n\\n        // if minuteDifference divide by 60\\n        if (minuteDifference % 60 === 0) {\\n\\n            // find minuteDiffCount by dividing minuteDifference to 60\\n            let minuteDiffCount = parseInt(minuteDifference / 60);\\n\\n            // subtract minuteDifference by multiplying minuteDiffCount\\n            minuteDifference -= (minuteDiffCount * 60);\\n\\n            // add minuteDifference to count\\n            count += minuteDiffCount;\\n\\n        } // else if minuteDifference divide by 15\\n        else if (minuteDifference % 15 === 0) {\\n\\n            // subtract minuteDifference by 15\\n            minuteDifference -= 15;\\n\\n            // increment the count\\n            count++;\\n\\n        } // else if minuteDifference divide by 5\\n        else if (minuteDifference % 5 === 0) {\\n\\n            // subtract minuteDifference by 5\\n            minuteDifference -= 5;\\n\\n            // increment the count\\n            count++;\\n\\n        } // else\\n        else {\\n\\n            // subtract minuteDifference by 1\\n            minuteDifference -= 1;\\n\\n            // increment the count\\n            count++;\\n        }\\n    }\\n\\n    // return the count\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006367,
                "title": "super-simple-solution-sss",
                "content": "Thanks for reading :)\\n# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        sum_cur, sum_cor, ans = 0, 0, 0\\n        time_ = [60, 15, 5, 1]\\n        cur_split = current.split(\\':\\')\\n        cor_split = correct.split(\\':\\')\\n        for i, v in enumerate(zip(cur_split, cor_split)):\\n            if i == 0:\\n                sum_cur = time_[0] * int(v[0])\\n                sum_cor = time_[0] * int(v[1])\\n            if i == 1:\\n                sum_cur += int(v[0])\\n                sum_cor += int(v[1])\\n        diff_t = sum_cor - sum_cur\\n        for i in time_:\\n            ans += diff_t // i\\n            diff_t -= i * (diff_t // i)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        sum_cur, sum_cor, ans = 0, 0, 0\\n        time_ = [60, 15, 5, 1]\\n        cur_split = current.split(\\':\\')\\n        cor_split = correct.split(\\':\\')\\n        for i, v in enumerate(zip(cur_split, cor_split)):\\n            if i == 0:\\n                sum_cur = time_[0] * int(v[0])\\n                sum_cor = time_[0] * int(v[1])\\n            if i == 1:\\n                sum_cur += int(v[0])\\n                sum_cor += int(v[1])\\n        diff_t = sum_cor - sum_cur\\n        for i in time_:\\n            ans += diff_t // i\\n            diff_t -= i * (diff_t // i)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996539,
                "title": "three-different-python-solutions",
                "content": "# Intuition\\n\\nNotice that this is identical to the [Coin Change](https://leetcode.com/problems/coin-change/) problem (LeetCode #322) where we need to make up `target_mins` (the time difference) from the given selection of \"coins\" (the list `[1, 5, 15, 60]`). However, note that in this case, a greedy solution will work because every item in the list is larger than the sum of all smaller items.\\n\\n# Method 1 - Greedy Solution\\n\\nFast and efficient for this problem, but not easily generalisable\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        # greedy solution: correct >= current\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        return target_mins // 60 + (target_mins % 60) // 15 + (target_mins % 60 % 15) // 5 + \\\\\\n            (target_mins % 60 % 15 % 5)\\n```\\n\\nThis can be written in a more general way like this:\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n\\n        import functools\\n\\n        # greedy solution: correct >= current\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n\\n        choices = [60, 15, 5, 1]\\n\\n        rems = [functools.reduce(lambda a, b: a % b, [target_mins] + choices[:i]) \\\\\\n            for i in range(len(choices))]\\n\\n        return sum(rems[i] // choices[i] for i in range(len(choices)))\\n```\\n\\n# Method 2 - Recursion\\n\\nFast but less intuitive\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str, memo: dict = {}) -> int:\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        choices = [1, 5, 15, 60]\\n        return self.solveRecursively(target_mins, choices)\\n    \\n    def solveRecursively(self, amount: int, choices: list, memo: dict = {}) -> int:\\n        if amount < 0: # amount cannot be made - set to negative to fail check\\n            return -1\\n        if amount == 0: # base case\\n            return 0\\n        if amount in memo:\\n            return memo[amount] \\n        \\n        min_count = float(\\'inf\\')\\n        for c in choices:\\n            if 0 <= (f := self.solveRecursively(amount - c, choices, memo)) < min_count:\\n                min_count = 1 + f\\n        memo[amount] = min_count if min_count != float(\\'inf\\') else -1\\n        return memo[amount]\\n```\\n\\n# Method 3 - Dynamic Programming\\n\\nSlowest, but most easily generalisable to harder problems.\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str, memo: dict = {}) -> int:\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        choices = [1, 5, 15, 60]\\n        dp = {0: 0}  # base case\\n        for a in range(1, target_mins + 1):\\n            dp[a] = min(1 + dp.get(a - c, float(\\'inf\\')) for c in choices)\\n        \\n        return dp[target_mins] if dp[target_mins] is not float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        # greedy solution: correct >= current\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        return target_mins // 60 + (target_mins % 60) // 15 + (target_mins % 60 % 15) // 5 + \\\\\\n            (target_mins % 60 % 15 % 5)\\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n\\n        import functools\\n\\n        # greedy solution: correct >= current\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n\\n        choices = [60, 15, 5, 1]\\n\\n        rems = [functools.reduce(lambda a, b: a % b, [target_mins] + choices[:i]) \\\\\\n            for i in range(len(choices))]\\n\\n        return sum(rems[i] // choices[i] for i in range(len(choices)))\\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str, memo: dict = {}) -> int:\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        choices = [1, 5, 15, 60]\\n        return self.solveRecursively(target_mins, choices)\\n    \\n    def solveRecursively(self, amount: int, choices: list, memo: dict = {}) -> int:\\n        if amount < 0: # amount cannot be made - set to negative to fail check\\n            return -1\\n        if amount == 0: # base case\\n            return 0\\n        if amount in memo:\\n            return memo[amount] \\n        \\n        min_count = float(\\'inf\\')\\n        for c in choices:\\n            if 0 <= (f := self.solveRecursively(amount - c, choices, memo)) < min_count:\\n                min_count = 1 + f\\n        memo[amount] = min_count if min_count != float(\\'inf\\') else -1\\n        return memo[amount]\\n```\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str, memo: dict = {}) -> int:\\n        current_hrs, current_mins = map(int, current.split(\\':\\'))\\n        correct_hrs, correct_mins = map(int, correct.split(\\':\\'))\\n        target_mins = (correct_hrs - current_hrs) * 60 + (correct_mins - current_mins)\\n        choices = [1, 5, 15, 60]\\n        dp = {0: 0}  # base case\\n        for a in range(1, target_mins + 1):\\n            dp[a] = min(1 + dp.get(a - c, float(\\'inf\\')) for c in choices)\\n        \\n        return dp[target_mins] if dp[target_mins] is not float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996177,
                "title": "typescript-easy-math-solution-o-1",
                "content": "# Approach\\nCount the difference in mututes between current and correct times, than use the arithmetics to count the operations.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction convertTime(current: string, correct: string): number {\\n    let counter = 0;\\n\\n    const cur = getMinutes(current);\\n    const cor = getMinutes(correct);\\n    let rest = Math.abs(cur - cor);\\n\\n    if (Math.floor(rest / 60) > 0) {\\n        counter += Math.floor(rest / 60);\\n        rest = rest % 60;\\n    }\\n    if (Math.floor(rest / 15) > 0) {\\n        counter += Math.floor(rest / 15);\\n        rest = rest % 15;\\n    }\\n    if (Math.floor(rest / 5) > 0) {\\n        counter += Math.floor(rest / 5);\\n        rest = rest % 5;\\n    }\\n\\n    return counter + rest;\\n};\\n\\nfunction getMinutes (value: string):number {\\n    const arr = value.split(\":\");\\n    return Number(arr[0])*60 + Number(arr[1]);\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction convertTime(current: string, correct: string): number {\\n    let counter = 0;\\n\\n    const cur = getMinutes(current);\\n    const cor = getMinutes(correct);\\n    let rest = Math.abs(cur - cor);\\n\\n    if (Math.floor(rest / 60) > 0) {\\n        counter += Math.floor(rest / 60);\\n        rest = rest % 60;\\n    }\\n    if (Math.floor(rest / 15) > 0) {\\n        counter += Math.floor(rest / 15);\\n        rest = rest % 15;\\n    }\\n    if (Math.floor(rest / 5) > 0) {\\n        counter += Math.floor(rest / 5);\\n        rest = rest % 5;\\n    }\\n\\n    return counter + rest;\\n};\\n\\nfunction getMinutes (value: string):number {\\n    const arr = value.split(\":\");\\n    return Number(arr[0])*60 + Number(arr[1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994183,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int convertTime(string current, string correct) {\\n    const vector<int> ops{60, 15, 5, 1};\\n    int diff = getMinutes(correct) - getMinutes(current);\\n    int ans = 0;\\n\\n    for (const int op : ops) {\\n      ans += diff / op;\\n      diff %= op;\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  int getMinutes(const string& s) {\\n    return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int convertTime(string current, string correct) {\\n    const vector<int> ops{60, 15, 5, 1};\\n    int diff = getMinutes(correct) - getMinutes(current);\\n    int ans = 0;\\n\\n    for (const int op : ops) {\\n      ans += diff / op;\\n      diff %= op;\\n    }\\n\\n    return ans;\\n  }\\n\\n private:\\n  int getMinutes(const string& s) {\\n    return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942663,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int convertTime(String current, String correct) {\\n        int currentMinute = hourToMinuteConverter(current);\\n        int correctMinute = hourToMinuteConverter(correct);\\n        int difference = correctMinute - currentMinute;\\n        int count = numberOfOperations(difference);\\n        return count;\\n    }\\n\\n    private static int hourToMinuteConverter(String hour) {\\n        int first = ((int)hour.charAt(0) - 48) * 10;\\n        int second = ((int)hour.charAt(1) - 48);\\n        int hours = (first + second) * 60;\\n        int m1 = ((int)hour.charAt(3) - 48) * 10;\\n        int m2 = ((int)hour.charAt(4) - 48);\\n        int minutes = m1 + m2;\\n        return hours + minutes;\\n    }\\n\\n    private static int numberOfOperations(int difference) {\\n        int result = difference;\\n        int count = 0;\\n        while (result>0) {\\n            if(result/60 >= 1) {\\n                int i = result / 60;\\n                count += i;\\n                result -= 60*i;\\n            } else if(result/15 >= 1) {\\n                int i = result / 15;\\n                count += i;\\n                result -= 15*i;\\n            } else if(result/5 >= 1) {\\n                int i = result / 5;\\n                count += i;\\n                result -= 5*i;\\n            } else {\\n                int i = result;\\n                count += i;\\n                result -= i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int convertTime(String current, String correct) {\\n        int currentMinute = hourToMinuteConverter(current);\\n        int correctMinute = hourToMinuteConverter(correct);\\n        int difference = correctMinute - currentMinute;\\n        int count = numberOfOperations(difference);\\n        return count;\\n    }\\n\\n    private static int hourToMinuteConverter(String hour) {\\n        int first = ((int)hour.charAt(0) - 48) * 10;\\n        int second = ((int)hour.charAt(1) - 48);\\n        int hours = (first + second) * 60;\\n        int m1 = ((int)hour.charAt(3) - 48) * 10;\\n        int m2 = ((int)hour.charAt(4) - 48);\\n        int minutes = m1 + m2;\\n        return hours + minutes;\\n    }\\n\\n    private static int numberOfOperations(int difference) {\\n        int result = difference;\\n        int count = 0;\\n        while (result>0) {\\n            if(result/60 >= 1) {\\n                int i = result / 60;\\n                count += i;\\n                result -= 60*i;\\n            } else if(result/15 >= 1) {\\n                int i = result / 15;\\n                count += i;\\n                result -= 15*i;\\n            } else if(result/5 >= 1) {\\n                int i = result / 5;\\n                count += i;\\n                result -= 5*i;\\n            } else {\\n                int i = result;\\n                count += i;\\n                result -= i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899308,
                "title": "short-and-easy-to-understand",
                "content": "\\n\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        # get hours and minutes\\n        h1,m1 = list(map(int,(correct).split(\\':\\')))\\n        h2,m2 = list(map(int,(current).split(\\':\\')))\\n        \\n        # count hours diff deducting 1 hour in case\\n        # \\'correct\\' minutes are higher vs \\'current\\'\\n\\n        count = h1-h2 - (m2>m1)\\n        # count min diff adding 1 hour for the case then\\n        # \\'correct\\' minutes are higher vs \\'current\\'\\n\\n        diff = (m1-m2) + 60*(m2>m1)        \\n        for n in (15,5):\\n            count += diff//n\\n            diff %=n\\n        return  count + diff\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        # get hours and minutes\\n        h1,m1 = list(map(int,(correct).split(\\':\\')))\\n        h2,m2 = list(map(int,(current).split(\\':\\')))\\n        \\n        # count hours diff deducting 1 hour in case\\n        # \\'correct\\' minutes are higher vs \\'current\\'\\n\\n        count = h1-h2 - (m2>m1)\\n        # count min diff adding 1 hour for the case then\\n        # \\'correct\\' minutes are higher vs \\'current\\'\\n\\n        diff = (m1-m2) + 60*(m2>m1)        \\n        for n in (15,5):\\n            count += diff//n\\n            diff %=n\\n        return  count + diff\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884755,
                "title": "java-beats-100-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int min1 = (current.charAt(0) - \\'0\\')*10 + (current.charAt(1) - \\'0\\');\\n        int min2 = (correct.charAt(0) - \\'0\\')*10 + (correct.charAt(1) - \\'0\\');\\n\\n        int sec1 = (current.charAt(3) - \\'0\\')*10 + (current.charAt(4) - \\'0\\');\\n        int sec2 = (correct.charAt(3) - \\'0\\')*10 + (correct.charAt(4) - \\'0\\');\\n\\n        int ans = 0;\\n        int a;\\n        int b;\\n        ans += min2 - min1;\\n        if(ans < 0)\\n            ans += 24;\\n        a = sec2 - sec1;\\n        if(a < 0){\\n            ans--;\\n            a += 60;\\n        }\\n        ans += a/15;\\n        int c = a%15;\\n        ans += c/5;\\n        ans += c%5;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int min1 = (current.charAt(0) - \\'0\\')*10 + (current.charAt(1) - \\'0\\');\\n        int min2 = (correct.charAt(0) - \\'0\\')*10 + (correct.charAt(1) - \\'0\\');\\n\\n        int sec1 = (current.charAt(3) - \\'0\\')*10 + (current.charAt(4) - \\'0\\');\\n        int sec2 = (correct.charAt(3) - \\'0\\')*10 + (correct.charAt(4) - \\'0\\');\\n\\n        int ans = 0;\\n        int a;\\n        int b;\\n        ans += min2 - min1;\\n        if(ans < 0)\\n            ans += 24;\\n        a = sec2 - sec1;\\n        if(a < 0){\\n            ans--;\\n            a += 60;\\n        }\\n        ans += a/15;\\n        int c = a%15;\\n        ans += c/5;\\n        ans += c%5;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884189,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int ConvertTime(string current, string correct) {\\n        var res = 0;\\n        int hour = (correct[0] - current[0]) * 10 + (correct[1] - current[1]);\\n        int min = (correct[3] - current[3]) * 10 + (correct[4] - current[4]);\\n        if( min < 0) {\\n            hour--;\\n            min += 60;\\n        }\\n        res += hour;\\n        while(min >= 15){\\n            min -= 15;\\n            res++;\\n        }\\n        while(min >= 5){\\n            min -= 5;\\n            res++;\\n        }\\n        while(min >= 1){\\n            min -= 1;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ConvertTime(string current, string correct) {\\n        var res = 0;\\n        int hour = (correct[0] - current[0]) * 10 + (correct[1] - current[1]);\\n        int min = (correct[3] - current[3]) * 10 + (correct[4] - current[4]);\\n        if( min < 0) {\\n            hour--;\\n            min += 60;\\n        }\\n        res += hour;\\n        while(min >= 15){\\n            min -= 15;\\n            res++;\\n        }\\n        while(min >= 5){\\n            min -= 5;\\n            res++;\\n        }\\n        while(min >= 1){\\n            min -= 1;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878497,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        if(current.equals(correct))\\n            return 0;\\n        int t1=((current.charAt(0)-\\'0\\')*10+(current.charAt(1)-\\'0\\'))*60;\\n        t1+=(current.charAt(3)-\\'0\\')*10+current.charAt(4)-\\'0\\';\\n        int t2=((correct.charAt(0)-\\'0\\')*10+(correct.charAt(1)-\\'0\\'))*60;\\n        t2+=(correct.charAt(3)-\\'0\\')*10+correct.charAt(4)-\\'0\\';\\n        int t=t2-t1;\\n        if(t<0)\\n            t+=1440;\\n        int c=0;\\n        while(t!=0){\\n            if(t>=60)\\n                t-=60;\\n            else if(t>=15)\\n                t-=15;\\n            else if(t>=5)\\n                t-=5;\\n            else\\n                t--;\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        if(current.equals(correct))\\n            return 0;\\n        int t1=((current.charAt(0)-\\'0\\')*10+(current.charAt(1)-\\'0\\'))*60;\\n        t1+=(current.charAt(3)-\\'0\\')*10+current.charAt(4)-\\'0\\';\\n        int t2=((correct.charAt(0)-\\'0\\')*10+(correct.charAt(1)-\\'0\\'))*60;\\n        t2+=(correct.charAt(3)-\\'0\\')*10+correct.charAt(4)-\\'0\\';\\n        int t=t2-t1;\\n        if(t<0)\\n            t+=1440;\\n        int c=0;\\n        while(t!=0){\\n            if(t>=60)\\n                t-=60;\\n            else if(t>=15)\\n                t-=15;\\n            else if(t>=5)\\n                t-=5;\\n            else\\n                t--;\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870093,
                "title": "c-easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int cnt=0;\\n        int target=(stoi(correct.substr(0, 2))-stoi(current.substr(0, 2)))*60+(stoi(correct.substr(3, 2))-stoi(current.substr(3, 2)));\\n        while(target>=60){\\n            target-=60;\\n            cnt++;\\n        }\\n        while(target>=15){\\n            target-=15;\\n            cnt++;\\n        }\\n        while(target>=5){\\n            target-=5;\\n            cnt++;\\n        }\\n        while(target>=1){\\n            target-=1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int cnt=0;\\n        int target=(stoi(correct.substr(0, 2))-stoi(current.substr(0, 2)))*60+(stoi(correct.substr(3, 2))-stoi(current.substr(3, 2)));\\n        while(target>=60){\\n            target-=60;\\n            cnt++;\\n        }\\n        while(target>=15){\\n            target-=15;\\n            cnt++;\\n        }\\n        while(target>=5){\\n            target-=5;\\n            cnt++;\\n        }\\n        while(target>=1){\\n            target-=1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870083,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int start_hour = stoi(current.substr(0, 2));\\n        int end_hour = stoi(correct.substr(0, 2));\\n        int start_min = stoi(current.substr(3, 2));\\n        int end_min = stoi(correct.substr(3, 2));\\n        if(start_min>end_min){\\n            end_hour--;\\n            end_min+=60;\\n        }\\n        int target=(end_hour-start_hour)*60+(end_min-start_min);\\n        int cnt=0;\\n        while(target>=60){\\n            target-=60;\\n            cnt++;\\n        }\\n        while(target>=15){\\n            target-=15;\\n            cnt++;\\n        }\\n        while(target>=5){\\n            target-=5;\\n            cnt++;\\n        }\\n        while(target>=1){\\n            target-=1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int start_hour = stoi(current.substr(0, 2));\\n        int end_hour = stoi(correct.substr(0, 2));\\n        int start_min = stoi(current.substr(3, 2));\\n        int end_min = stoi(correct.substr(3, 2));\\n        if(start_min>end_min){\\n            end_hour--;\\n            end_min+=60;\\n        }\\n        int target=(end_hour-start_hour)*60+(end_min-start_min);\\n        int cnt=0;\\n        while(target>=60){\\n            target-=60;\\n            cnt++;\\n        }\\n        while(target>=15){\\n            target-=15;\\n            cnt++;\\n        }\\n        while(target>=5){\\n            target-=5;\\n            cnt++;\\n        }\\n        while(target>=1){\\n            target-=1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865209,
                "title": "easy-cpp-solution-beginner-friendly-by-calculating-difference",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        // cuh = current hours into minutes\\n        int cuh = stoi(current.substr(0,2)) * 60;\\n        // ch = correct hours into minutes\\n        int ch = stoi(correct.substr(0,2)) * 60;\\n        cuh += stoi(current.substr(3,2));\\n        ch += stoi(correct.substr(3,2));\\n        // Getting difference of both in minutes\\n        int diff = ch - cuh;\\n        int steps = 0;\\n        while(diff){\\n            if(diff >= 60)\\n                diff -= 60;\\n            else if(diff >= 15)\\n                diff -= 15;\\n            else if(diff >= 5)\\n                diff -= 5;\\n            else\\n                diff -= 1;\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        // cuh = current hours into minutes\\n        int cuh = stoi(current.substr(0,2)) * 60;\\n        // ch = correct hours into minutes\\n        int ch = stoi(correct.substr(0,2)) * 60;\\n        cuh += stoi(current.substr(3,2));\\n        ch += stoi(correct.substr(3,2));\\n        // Getting difference of both in minutes\\n        int diff = ch - cuh;\\n        int steps = 0;\\n        while(diff){\\n            if(diff >= 60)\\n                diff -= 60;\\n            else if(diff >= 15)\\n                diff -= 15;\\n            else if(diff >= 5)\\n                diff -= 5;\\n            else\\n                diff -= 1;\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862500,
                "title": "straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int hoursCurrent = Integer.valueOf(current.substring(0, 2));\\n        int minsCurrent = Integer.valueOf(current.substring(3, 5));\\n\\n        int hoursCorrect = Integer.valueOf(correct.substring(0, 2));\\n        int minsCorrect = Integer.valueOf(correct.substring(3, 5));\\n\\n        int hoursDiff = hoursCorrect - hoursCurrent;\\n        int minsDiff = minsCorrect - minsCurrent;\\n\\n        if (minsDiff < 0) {\\n            if (hoursDiff > 0) {\\n                hoursDiff -= 1;\\n            }\\n            minsDiff = 60 + minsDiff;\\n        }\\n\\n        int ops = 0;\\n        while (minsDiff > 0) {\\n            if (minsDiff - 15 >= 0) {\\n                minsDiff -= 15;\\n            } else if (minsDiff - 5 >= 0) {\\n                minsDiff -= 5;\\n            } else if (minsDiff - 1 >= 0) {\\n                minsDiff -= 1;\\n            }\\n            ops++;\\n        }\\n\\n        ops += hoursDiff;\\n\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int hoursCurrent = Integer.valueOf(current.substring(0, 2));\\n        int minsCurrent = Integer.valueOf(current.substring(3, 5));\\n\\n        int hoursCorrect = Integer.valueOf(correct.substring(0, 2));\\n        int minsCorrect = Integer.valueOf(correct.substring(3, 5));\\n\\n        int hoursDiff = hoursCorrect - hoursCurrent;\\n        int minsDiff = minsCorrect - minsCurrent;\\n\\n        if (minsDiff < 0) {\\n            if (hoursDiff > 0) {\\n                hoursDiff -= 1;\\n            }\\n            minsDiff = 60 + minsDiff;\\n        }\\n\\n        int ops = 0;\\n        while (minsDiff > 0) {\\n            if (minsDiff - 15 >= 0) {\\n                minsDiff -= 15;\\n            } else if (minsDiff - 5 >= 0) {\\n                minsDiff -= 5;\\n            } else if (minsDiff - 1 >= 0) {\\n                minsDiff -= 1;\\n            }\\n            ops++;\\n        }\\n\\n        ops += hoursDiff;\\n\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854561,
                "title": "converttime-by-mat-j-soukup",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert strings and do difference between correct and current\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n20 minutes\\n\\n# Code\\n```\\npublic class Solution {\\n      public int ConvertTime(string current, string correct)\\n        {\\n\\n            int int_current = int.Parse(current.Split(\\':\\')[0]) * 60;\\n            int_current += int.Parse(current.Split(\\':\\')[1]);\\n\\n            int int_correct = int.Parse(correct.Split(\\':\\')[0]) * 60;\\n            int_correct += int.Parse(correct.Split(\\':\\')[1]);\\n\\n\\n            int diff = int_correct - int_current;\\n\\n            int i = 0;\\n\\n            while (diff > 0)\\n            {\\n                if (diff >= 60)\\n                {\\n                    diff -= 60;\\n                    i++;\\n\\n                }else if(diff >= 15)\\n                {\\n                    diff -= 15;\\n                    i++;\\n\\n                }else if (diff >= 5)\\n                {\\n                    diff -= 5;\\n                    i++;\\n\\n                }\\n                else\\n                {\\n                    diff--;\\n                    i++;\\n\\n                }\\n            }\\n\\n            return i;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n      public int ConvertTime(string current, string correct)\\n        {\\n\\n            int int_current = int.Parse(current.Split(\\':\\')[0]) * 60;\\n            int_current += int.Parse(current.Split(\\':\\')[1]);\\n\\n            int int_correct = int.Parse(correct.Split(\\':\\')[0]) * 60;\\n            int_correct += int.Parse(correct.Split(\\':\\')[1]);\\n\\n\\n            int diff = int_correct - int_current;\\n\\n            int i = 0;\\n\\n            while (diff > 0)\\n            {\\n                if (diff >= 60)\\n                {\\n                    diff -= 60;\\n                    i++;\\n\\n                }else if(diff >= 15)\\n                {\\n                    diff -= 15;\\n                    i++;\\n\\n                }else if (diff >= 5)\\n                {\\n                    diff -= 5;\\n                    i++;\\n\\n                }\\n                else\\n                {\\n                    diff--;\\n                    i++;\\n\\n                }\\n            }\\n\\n            return i;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850312,
                "title": "clean-ts-solution-with-o-n-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction convertTime(current: string, correct: string): number {\\n    const [h1, m1] = current.split(\":\").map(r => parseInt(r));\\n    const [h2, m2] = correct.split(\":\").map(r => parseInt(r));\\n    let differnceInMinutes = Math.abs((h2 - h1) * 60 + (m2 - m1));\\n    let operations = 0;\\n    const increaseValues = [60, 15, 5, 1]; // it is important the increase values to be ordered descenting\\n\\n    for (const increase of increaseValues) {\\n        while (differnceInMinutes >= increase) { \\n            differnceInMinutes -= increase; // keep removing from the highest increas first will we reache the end.\\n            operations++;\\n        }\\n    }\\n    return operations;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Greedy"
                ],
                "code": "```\\nfunction convertTime(current: string, correct: string): number {\\n    const [h1, m1] = current.split(\":\").map(r => parseInt(r));\\n    const [h2, m2] = correct.split(\":\").map(r => parseInt(r));\\n    let differnceInMinutes = Math.abs((h2 - h1) * 60 + (m2 - m1));\\n    let operations = 0;\\n    const increaseValues = [60, 15, 5, 1]; // it is important the increase values to be ordered descenting\\n\\n    for (const increase of increaseValues) {\\n        while (differnceInMinutes >= increase) { \\n            differnceInMinutes -= increase; // keep removing from the highest increas first will we reache the end.\\n            operations++;\\n        }\\n    }\\n    return operations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817144,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:KARUNYA UNIVERSITY::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) \\n    {\\n        String[] first=current.split(\":\");\\nString[] second=correct.split(\":\");\\n\\n\\nint firstlove=Integer.valueOf(first[0])*60+Integer.valueOf(first[1]);\\nint secondlove=Integer.valueOf(second[0])*60+Integer.valueOf(second[1]);\\n\\nSystem.out.println(firstlove+\" \"+secondlove +\"---->\"+\"\"+(firstlove-secondlove));\\n\\nint total=secondlove-firstlove;\\nint operiton=0;\\nSystem.out.println(total);\\n\\nwhile (total>0)\\n{  \\n  System.out.println(\"what the fuck\");   \\n  if (total>=60) \\n  {  \\n    \\n   System.out.println(\"jebas\");    \\n    operiton+=total/60;\\n    System.out.println(\"greater than 60\"+(total/60));\\n    total=total%60;\\n  }\\n  else if (total>=15) \\n  {\\n    System.out.println(\"raja\");\\n    operiton+=total/15;\\n    total=total%15;\\n  }\\n  else if (total>=5) \\n  {\\n    System.out.println(\"peter\");\\n    operiton+=total/5;\\n    System.out.println(\"greater than 5\"+(total/5));\\n    total=total%5; \\n  }\\n  else\\n  {  \\n    System.out.println(\"crime_luv\");\\n     operiton+=total;\\n     total=0;\\n    }\\n}\\n\\n\\nSystem.out.println(operiton);\\n\\nreturn operiton;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) \\n    {\\n        String[] first=current.split(\":\");\\nString[] second=correct.split(\":\");\\n\\n\\nint firstlove=Integer.valueOf(first[0])*60+Integer.valueOf(first[1]);\\nint secondlove=Integer.valueOf(second[0])*60+Integer.valueOf(second[1]);\\n\\nSystem.out.println(firstlove+\" \"+secondlove +\"---->\"+\"\"+(firstlove-secondlove));\\n\\nint total=secondlove-firstlove;\\nint operiton=0;\\nSystem.out.println(total);\\n\\nwhile (total>0)\\n{  \\n  System.out.println(\"what the fuck\");   \\n  if (total>=60) \\n  {  \\n    \\n   System.out.println(\"jebas\");    \\n    operiton+=total/60;\\n    System.out.println(\"greater than 60\"+(total/60));\\n    total=total%60;\\n  }\\n  else if (total>=15) \\n  {\\n    System.out.println(\"raja\");\\n    operiton+=total/15;\\n    total=total%15;\\n  }\\n  else if (total>=5) \\n  {\\n    System.out.println(\"peter\");\\n    operiton+=total/5;\\n    System.out.println(\"greater than 5\"+(total/5));\\n    total=total%5; \\n  }\\n  else\\n  {  \\n    System.out.println(\"crime_luv\");\\n     operiton+=total;\\n     total=0;\\n    }\\n}\\n\\n\\nSystem.out.println(operiton);\\n\\nreturn operiton;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808131,
                "title": "simple-easy-to-understand-go-golang-solution",
                "content": "```\\nfunc convertTime(current, correct string) int {\\n        timeRange := toMinutes(correct) - toMinutes(current)\\n        var counter int\\n\\n        for timeRange > 0 {\\n                var reduce int\\n\\n                if timeRange >= 60 {\\n                        reduce = 60\\n                } else if timeRange >= 15 && timeRange < 60 {\\n                        reduce = 15\\n                } else if timeRange >= 5 && timeRange < 15 {\\n                        reduce = 5\\n                } else {\\n                        reduce = 1\\n                }\\n\\n                timeRange -= reduce\\n                counter++\\n        }\\n\\n        return counter\\n}\\n\\nfunc toMinutes(time string) int {\\n        hours := time[:2]\\n        minutes := time[3:]\\n\\n        var res int\\n\\n        res += int(minutes[1] - \\'0\\')\\n        res += (int(minutes[0]-\\'0\\') * 10)\\n\\n        res += (int(hours[1]-\\'0\\') * 60)\\n        res += (int(hours[0]-\\'0\\') * 60 * 10)\\n\\n        return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc convertTime(current, correct string) int {\\n        timeRange := toMinutes(correct) - toMinutes(current)\\n        var counter int\\n\\n        for timeRange > 0 {\\n                var reduce int\\n\\n                if timeRange >= 60 {\\n                        reduce = 60\\n                } else if timeRange >= 15 && timeRange < 60 {\\n                        reduce = 15\\n                } else if timeRange >= 5 && timeRange < 15 {\\n                        reduce = 5\\n                } else {\\n                        reduce = 1\\n                }\\n\\n                timeRange -= reduce\\n                counter++\\n        }\\n\\n        return counter\\n}\\n\\nfunc toMinutes(time string) int {\\n        hours := time[:2]\\n        minutes := time[3:]\\n\\n        var res int\\n\\n        res += int(minutes[1] - \\'0\\')\\n        res += (int(minutes[0]-\\'0\\') * 10)\\n\\n        res += (int(hours[1]-\\'0\\') * 60)\\n        res += (int(hours[0]-\\'0\\') * 60 * 10)\\n\\n        return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796815,
                "title": "easy-and-naiive-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n        public int convertTime(String current, String correct) {\\n        int H1 = Integer.valueOf(current.substring(0,2));\\n        int H2 = Integer.valueOf(correct.substring(0,2));\\n        int M1 = Integer.valueOf(current.substring(3));\\n        int M2 = Integer.valueOf(correct.substring(3));\\n\\n        int totSecs1 = H1 * 60 + M1;\\n        int totSecs2 = H2 * 60 + M2;\\n\\n        int rem = totSecs2 - totSecs1;\\n\\n        int minOps = 0;\\n\\n        int divideBy60 = rem / 60;\\n\\n        minOps += divideBy60;\\n        rem -= (60 * divideBy60);\\n\\n        int divideBy15 = rem / 15;\\n\\n        minOps += divideBy15;\\n        rem -= (15 * divideBy15);\\n\\n        int divideBy5 = rem / 5;\\n\\n        minOps += divideBy5;\\n        rem -= (5 * divideBy5);\\n\\n        minOps += rem;\\n\\n        return minOps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int convertTime(String current, String correct) {\\n        int H1 = Integer.valueOf(current.substring(0,2));\\n        int H2 = Integer.valueOf(correct.substring(0,2));\\n        int M1 = Integer.valueOf(current.substring(3));\\n        int M2 = Integer.valueOf(correct.substring(3));\\n\\n        int totSecs1 = H1 * 60 + M1;\\n        int totSecs2 = H2 * 60 + M2;\\n\\n        int rem = totSecs2 - totSecs1;\\n\\n        int minOps = 0;\\n\\n        int divideBy60 = rem / 60;\\n\\n        minOps += divideBy60;\\n        rem -= (60 * divideBy60);\\n\\n        int divideBy15 = rem / 15;\\n\\n        minOps += divideBy15;\\n        rem -= (15 * divideBy15);\\n\\n        int divideBy5 = rem / 5;\\n\\n        minOps += divideBy5;\\n        rem -= (5 * divideBy5);\\n\\n        minOps += rem;\\n\\n        return minOps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778453,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int operations = 0;\\n        int h1= (current[0]-\\'0\\')*10 + current[1]-\\'0\\', h2= (correct[0]-\\'0\\')*10 + correct[1]-\\'0\\';\\n        int m1= (current[3]-\\'0\\')*10 + current[4]-\\'0\\', m2= (correct[3]-\\'0\\')*10 + correct[4]-\\'0\\';\\n        operations = h2-h1; \\n        if(m2-m1 < 0){\\n            m2+=60-m1;\\n            operations--;\\n        }\\n        else m2-=m1;\\n        operations+= m2/15;\\n        m2 = m2%15;\\n        operations+= m2/5;\\n        m2 = m2%5;\\n        operations+=m2;\\n        return operations;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int operations = 0;\\n        int h1= (current[0]-\\'0\\')*10 + current[1]-\\'0\\', h2= (correct[0]-\\'0\\')*10 + correct[1]-\\'0\\';\\n        int m1= (current[3]-\\'0\\')*10 + current[4]-\\'0\\', m2= (correct[3]-\\'0\\')*10 + correct[4]-\\'0\\';\\n        operations = h2-h1; \\n        if(m2-m1 < 0){\\n            m2+=60-m1;\\n            operations--;\\n        }\\n        else m2-=m1;\\n        while(m2 > 0){\\n            if(m2%5==0) break;\\n            m2-=1;\\n            operations++;\\n        }\\n        while(m2 >= 15){\\n            m2-=15;\\n            operations++;\\n        }\\n        while(m2 > 0){\\n            m2-=5;\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        if(current==correct) return 0;\\n        string t1 = \"\", t2=\"\", t3=\"\", t4=\"\";\\n        t1=current[0]; t1+=current[1];\\n        t2=correct[0]; t2+=correct[1];\\n        t3=current[3]; t3+=current[4];\\n        t4=correct[3]; t4+=correct[4];\\n        int operations = 0, h1= stoi(t1), h2= stoi(t2), m1= stoi(t3), m2= stoi(t4);\\n        operations = h2-h1;\\n        m2-=m1;\\n        if(m2==0) return operations;\\n        if(m2 < 0){\\n            m2+=m1;\\n            m1 = 60-m1;\\n            m1+=m2;\\n            m2=m1;\\n            operations--;\\n        }\\n        while(m2 > 0){\\n            if(m2%5==0) break;\\n            m2-=1;\\n            operations++;\\n        }\\n        while(m2 >= 15){\\n            m2-=15;\\n            operations++;\\n        }\\n        while(m2 > 0){\\n            m2-=5;\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int operations = 0;\\n        int h1= (current[0]-\\'0\\')*10 + current[1]-\\'0\\', h2= (correct[0]-\\'0\\')*10 + correct[1]-\\'0\\';\\n        int m1= (current[3]-\\'0\\')*10 + current[4]-\\'0\\', m2= (correct[3]-\\'0\\')*10 + correct[4]-\\'0\\';\\n        operations = h2-h1; \\n        if(m2-m1 < 0){\\n            m2+=60-m1;\\n            operations--;\\n        }\\n        else m2-=m1;\\n        operations+= m2/15;\\n        m2 = m2%15;\\n        operations+= m2/5;\\n        m2 = m2%5;\\n        operations+=m2;\\n        return operations;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int operations = 0;\\n        int h1= (current[0]-\\'0\\')*10 + current[1]-\\'0\\', h2= (correct[0]-\\'0\\')*10 + correct[1]-\\'0\\';\\n        int m1= (current[3]-\\'0\\')*10 + current[4]-\\'0\\', m2= (correct[3]-\\'0\\')*10 + correct[4]-\\'0\\';\\n        operations = h2-h1; \\n        if(m2-m1 < 0){\\n            m2+=60-m1;\\n            operations--;\\n        }\\n        else m2-=m1;\\n        while(m2 > 0){\\n            if(m2%5==0) break;\\n            m2-=1;\\n            operations++;\\n        }\\n        while(m2 >= 15){\\n            m2-=15;\\n            operations++;\\n        }\\n        while(m2 > 0){\\n            m2-=5;\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        if(current==correct) return 0;\\n        string t1 = \"\", t2=\"\", t3=\"\", t4=\"\";\\n        t1=current[0]; t1+=current[1];\\n        t2=correct[0]; t2+=correct[1];\\n        t3=current[3]; t3+=current[4];\\n        t4=correct[3]; t4+=correct[4];\\n        int operations = 0, h1= stoi(t1), h2= stoi(t2), m1= stoi(t3), m2= stoi(t4);\\n        operations = h2-h1;\\n        m2-=m1;\\n        if(m2==0) return operations;\\n        if(m2 < 0){\\n            m2+=m1;\\n            m1 = 60-m1;\\n            m1+=m2;\\n            m2=m1;\\n            operations--;\\n        }\\n        while(m2 > 0){\\n            if(m2%5==0) break;\\n            m2-=1;\\n            operations++;\\n        }\\n        while(m2 >= 15){\\n            m2-=15;\\n            operations++;\\n        }\\n        while(m2 > 0){\\n            m2-=5;\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772272,
                "title": "convert-to-minutes-and-use-divmod",
                "content": "# Code\\n```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def minutes(h: str, m: str) -> int:\\n            return int(h) * 60 + int(m)\\n        \\n        diff = abs(minutes(*current.split(\":\")) - minutes(*correct.split(\":\")))\\n        result = 0\\n        for divider in [60, 15, 5, 1]:\\n            ops, diff = divmod(diff, divider)\\n            result += ops\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        def minutes(h: str, m: str) -> int:\\n            return int(h) * 60 + int(m)\\n        \\n        diff = abs(minutes(*current.split(\":\")) - minutes(*correct.split(\":\")))\\n        result = 0\\n        for divider in [60, 15, 5, 1]:\\n            ops, diff = divmod(diff, divider)\\n            result += ops\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754500,
                "title": "java-number-of-operations-using-stringtominutes-method-explained",
                "content": "# Approach\\nTo calculate the difference between the two times, we need to first convert them to \"integer-minutes\", so that the 24h-time is being represented by minutes of the day between 0 and 1440 (24*60).\\nTherefore I use StringToMinutes, which adds up the chars int the string representing the hours and minutes into seperate integers and returns their sum.\\n\\nThe actual problemsolving algorithm works as follows:\\nAs long as we can add 60 (minutes) to the current Time and its still smaller or equals to the correct time we do so. If its not possible anymore we continue to do so with 15, 5 and 1. That way we ensure that the minimal number of operations is used, since we add the highest numbers as long as its possible and then switch to the smaller ones.\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n\\n        int curTime=StringToMinute(current);\\n        int corTime=StringToMinute(correct);\\n        int counter=0;\\n\\n        while(curTime+60<=corTime){\\n            curTime+=60;\\n            counter++;\\n        }\\n        while(curTime+15<=corTime){\\n            curTime+=15;\\n            counter++;\\n        }\\n        while(curTime+5<=corTime){\\n            curTime+=5;\\n            counter++;\\n        }\\n        while(curTime+1<=corTime){\\n            curTime+=1;\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n\\n    public int StringToMinute(String st){\\n        int min=0;\\n        int hours=0;\\n\\n        //the \"  -\\'0\\'  \" is needed since .charAt(i) would only return the Unicode points for the numbers \"1, 2, 3\" and so on\\n       hours+=(st.charAt(0)-\\'0\\')*10+st.charAt(1)-\\'0\\';\\n\\n       min+=(st.charAt(3)-\\'0\\')*10+(st.charAt(4)-\\'0\\');\\n\\n        return min+hours*60;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n\\n        int curTime=StringToMinute(current);\\n        int corTime=StringToMinute(correct);\\n        int counter=0;\\n\\n        while(curTime+60<=corTime){\\n            curTime+=60;\\n            counter++;\\n        }\\n        while(curTime+15<=corTime){\\n            curTime+=15;\\n            counter++;\\n        }\\n        while(curTime+5<=corTime){\\n            curTime+=5;\\n            counter++;\\n        }\\n        while(curTime+1<=corTime){\\n            curTime+=1;\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n\\n    public int StringToMinute(String st){\\n        int min=0;\\n        int hours=0;\\n\\n        //the \"  -\\'0\\'  \" is needed since .charAt(i) would only return the Unicode points for the numbers \"1, 2, 3\" and so on\\n       hours+=(st.charAt(0)-\\'0\\')*10+st.charAt(1)-\\'0\\';\\n\\n       min+=(st.charAt(3)-\\'0\\')*10+(st.charAt(4)-\\'0\\');\\n\\n        return min+hours*60;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752857,
                "title": "100-beats-easy-solution-with-explanation-c",
                "content": "# Intuition\\nThe problem involves converting the time from the current time to the correct time. We need to calculate the number of steps needed to reach the correct time, where each step can be a jump of 60 minutes, 15 minutes, 5 minutes, or a remaining duration less than 5 minutes.\\n\\n# Approach\\nTo solve this problem, we can follow these steps:\\n1. Parse the hours and minutes from the `current` and `correct` strings and convert them into minutes. We can use the `stoi` function and substrings to extract the hours and minutes.\\n2. Calculate the difference `dis` between the correct time and the current time in minutes.\\n3. Initialize a counter `cnt` to keep track of the number of steps taken.\\n4. Use a `while` loop to iterate as long as `dis` is greater than or equal to zero.\\n5. Inside the loop, check if `dis` is greater than or equal to 60. If so, divide `dis` by 60 and add the quotient to `cnt`. Update `dis` by taking the remainder (`dis %= 60`).\\n6. Repeat the same process for 15 minutes and 5 minutes intervals, updating `cnt` and `dis` accordingly.\\n7. If `dis` is less than 5 minutes, add `dis` to `cnt` and break out of the loop.\\n8. Return the final value of `cnt`.\\n\\n# Complexity\\n- Time complexity: O(1) as the solution has a fixed number of calculations.\\n- Space complexity: O(1) as the space usage does not grow with the input size.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int m1 = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3, 2));\\n        int m2 = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3, 2));\\n        int dis = m2 - m1;\\n        int cnt = 0;\\n        \\n        while (dis >= 0) {\\n            if (dis >= 60) {\\n                cnt += (dis / 60);\\n                dis %= 60;\\n            }\\n            else if (dis >= 15) {\\n                cnt += (dis / 15);\\n                dis %= 15;\\n            }\\n            else if (dis >= 5) {\\n                cnt += (dis / 5);\\n                dis %= 5;\\n            }\\n            else {\\n                cnt += dis;\\n                break;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int m1 = stoi(current.substr(0, 2)) * 60 + stoi(current.substr(3, 2));\\n        int m2 = stoi(correct.substr(0, 2)) * 60 + stoi(correct.substr(3, 2));\\n        int dis = m2 - m1;\\n        int cnt = 0;\\n        \\n        while (dis >= 0) {\\n            if (dis >= 60) {\\n                cnt += (dis / 60);\\n                dis %= 60;\\n            }\\n            else if (dis >= 15) {\\n                cnt += (dis / 15);\\n                dis %= 15;\\n            }\\n            else if (dis >= 5) {\\n                cnt += (dis / 5);\\n                dis %= 5;\\n            }\\n            else {\\n                cnt += dis;\\n                break;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739208,
                "title": "a-simple-greedy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int h1 = Integer.parseInt(current.substring(0, 2));\\n        int h2 = Integer.parseInt(correct.substring(0, 2));\\n        int m1 = Integer.parseInt(current.substring(3, 5));\\n        int m2 = Integer.parseInt(correct.substring(3, 5));\\n        int mdiff = (m2 - m1) + (h2 - h1) * 60;\\n        int times = 0;\\n        if(mdiff > 0) {\\n            times += mdiff / 60;\\n            mdiff %= 60;\\n            times += mdiff / 15;\\n            mdiff %= 15;\\n            times += mdiff / 5;\\n            mdiff %= 5;\\n            times += mdiff / 1;\\n            mdiff %= 1;\\n        }\\n        return times;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int h1 = Integer.parseInt(current.substring(0, 2));\\n        int h2 = Integer.parseInt(correct.substring(0, 2));\\n        int m1 = Integer.parseInt(current.substring(3, 5));\\n        int m2 = Integer.parseInt(correct.substring(3, 5));\\n        int mdiff = (m2 - m1) + (h2 - h1) * 60;\\n        int times = 0;\\n        if(mdiff > 0) {\\n            times += mdiff / 60;\\n            mdiff %= 60;\\n            times += mdiff / 15;\\n            mdiff %= 15;\\n            times += mdiff / 5;\\n            mdiff %= 5;\\n            times += mdiff / 1;\\n            mdiff %= 1;\\n        }\\n        return times;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724236,
                "title": "similar-like-coin-change",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-coin change \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-bottom up dp\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int diff,int time[]){\\n        if(diff == 0){\\n            return 0;\\n        }\\n        vector<int> dp(diff+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i = 1;i<=diff;i++){\\n            for(int j =0;j<4;j++){\\n                if((i-time[j]>=0) && dp[i-time[j] != INT_MAX])\\n                 dp[i] = min(dp[i] ,dp[i-time[j]]+1);\\n            }\\n        }\\n        return dp[diff];\\n    }\\n    int convertTime(string current, string correct) {\\n        int curr = 0;\\n        int corr = 0;\\n        for(int i =0 ;i<2;i++){\\n                curr = curr*10 + (current[i] -\\'0\\');\\n                corr = corr*10 + (correct[i]-\\'0\\');\\n        }\\n        curr = curr*60;\\n        corr = corr*60;\\n        int minc = 0;\\n        int mincr = 0;\\n        for(int i =3 ;i<5;i++){\\n            minc = minc*10 + (current[i] -\\'0\\');\\n            mincr = mincr*10 + (correct[i]-\\'0\\');\\n        }\\n        curr = curr + minc;\\n        corr = corr + mincr;\\n        int diff = corr - curr;\\n        int time[4] = {1,5,15,60};\\n        return solve(diff,time) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int diff,int time[]){\\n        if(diff == 0){\\n            return 0;\\n        }\\n        vector<int> dp(diff+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i = 1;i<=diff;i++){\\n            for(int j =0;j<4;j++){\\n                if((i-time[j]>=0) && dp[i-time[j] != INT_MAX])\\n                 dp[i] = min(dp[i] ,dp[i-time[j]]+1);\\n            }\\n        }\\n        return dp[diff];\\n    }\\n    int convertTime(string current, string correct) {\\n        int curr = 0;\\n        int corr = 0;\\n        for(int i =0 ;i<2;i++){\\n                curr = curr*10 + (current[i] -\\'0\\');\\n                corr = corr*10 + (correct[i]-\\'0\\');\\n        }\\n        curr = curr*60;\\n        corr = corr*60;\\n        int minc = 0;\\n        int mincr = 0;\\n        for(int i =3 ;i<5;i++){\\n            minc = minc*10 + (current[i] -\\'0\\');\\n            mincr = mincr*10 + (correct[i]-\\'0\\');\\n        }\\n        curr = curr + minc;\\n        corr = corr + mincr;\\n        int diff = corr - curr;\\n        int time[4] = {1,5,15,60};\\n        return solve(diff,time) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723904,
                "title": "java-greedy-explained",
                "content": "**Idea:** Convert the times to minutes and find the difference between them (D), then find the operations required by finding the quotient by minutes in decreasing order and reducing D to the remainder\\n>**T/S:** O(1)/O(1)\\n```\\npublic int convertTime(String current, String correct) {\\n\\tvar ops = 0;\\n\\tvar diff = toMinutes(correct) - toMinutes(current);\\n\\n\\tfor (var m : List.of(60, 15, 5, 1)) {\\n\\t\\tops += diff / m;\\n\\t\\tdiff %= m;\\n\\t}\\n\\n\\treturn ops;\\n}\\n\\nprivate int toMinutes(String time) {\\n\\tvar parts = time.split(\":\");\\n\\treturn Integer.parseInt(parts[0]) * 60 + Integer.parseInt(parts[1]);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int convertTime(String current, String correct) {\\n\\tvar ops = 0;\\n\\tvar diff = toMinutes(correct) - toMinutes(current);\\n\\n\\tfor (var m : List.of(60, 15, 5, 1)) {\\n\\t\\tops += diff / m;\\n\\t\\tdiff %= m;\\n\\t}\\n\\n\\treturn ops;\\n}\\n\\nprivate int toMinutes(String time) {\\n\\tvar parts = time.split(\":\");\\n\\treturn Integer.parseInt(parts[0]) * 60 + Integer.parseInt(parts[1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3719106,
                "title": "c-easy-to-understand-solution-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/a8e6b42d-f876-4568-a5b4-fbbba3562ee5_1688500682.3755567.png)\\n# Approach\\nEssentially, we convert the correct hours into minutes and continue to add to the current minutes until we reach the same value.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ConvertTime(string current, string correct) {\\n        if (current == correct)\\n        {\\n            return 0;\\n        }\\n\\n        int counter = 0;\\n        int correctHours = int.Parse(correct[..2]);\\n        int currentHours = int.Parse(current[..2]);\\n        int currentMinutes = int.Parse(current.Substring(3, 2));\\n        int correctMinutes = int.Parse(correct.Substring(3, 2)) + 60 * Math.Abs(correctHours - currentHours);\\n\\n        while (currentMinutes != correctMinutes)\\n        {\\n            if ((currentMinutes + 60) <= correctMinutes)\\n            {\\n                currentMinutes += 60;\\n            }\\n            else if ((currentMinutes + 15) <= correctMinutes)\\n            {\\n                currentMinutes += 15;\\n            }\\n            else if ((currentMinutes + 5) <= correctMinutes)\\n            {\\n                currentMinutes += 5;\\n            }\\n            else if ((currentMinutes + 1) <= correctMinutes)\\n            {\\n                currentMinutes += 1;\\n            }\\n\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ConvertTime(string current, string correct) {\\n        if (current == correct)\\n        {\\n            return 0;\\n        }\\n\\n        int counter = 0;\\n        int correctHours = int.Parse(correct[..2]);\\n        int currentHours = int.Parse(current[..2]);\\n        int currentMinutes = int.Parse(current.Substring(3, 2));\\n        int correctMinutes = int.Parse(correct.Substring(3, 2)) + 60 * Math.Abs(correctHours - currentHours);\\n\\n        while (currentMinutes != correctMinutes)\\n        {\\n            if ((currentMinutes + 60) <= correctMinutes)\\n            {\\n                currentMinutes += 60;\\n            }\\n            else if ((currentMinutes + 15) <= correctMinutes)\\n            {\\n                currentMinutes += 15;\\n            }\\n            else if ((currentMinutes + 5) <= correctMinutes)\\n            {\\n                currentMinutes += 5;\\n            }\\n            else if ((currentMinutes + 1) <= correctMinutes)\\n            {\\n                currentMinutes += 1;\\n            }\\n\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700712,
                "title": "best-dynamic-programming-memorization-java",
                "content": "class Solution {\\n    public int convertTime(String current, String correct) {\\n        int diff=0;\\n        int count=0;\\n        for(int i=0;i<current.length()-1;i++){\\n            if(current.charAt(i)==\\':\\' || current.charAt(i+1)==\\':\\') continue;\\n            if(count==0){\\n                int s1=current.charAt(i)-\\'0\\';\\n                int s2=correct.charAt(i)-\\'0\\';\\n                int s3=current.charAt(i+1)-\\'0\\';\\n                int s4=correct.charAt(i+1)-\\'0\\';\\n                s1=s1*10+s3;\\n                s2=s2*10+s4;  \\n                diff+=Math.abs(s1-s2)*60;\\n\\n            }\\n            else{\\n                int s1=current.charAt(i)-\\'0\\';\\n                int s2=correct.charAt(i)-\\'0\\';\\n                int s3=current.charAt(i+1)-\\'0\\';\\n                int s4=correct.charAt(i+1)-\\'0\\';\\n                s1=s1*10+s3;\\n                s2=s2*10+s4;\\n                if(s1<s2){\\n                     diff+=Math.abs(s1-s2);\\n                }\\n                else{\\n                     diff-=Math.abs(s1-s2);\\n                }\\n            }\\n            count++;\\n\\n        }\\n        int[] dp=new int[diff+1];\\n        Arrays.fill(dp,-1);\\n        return helper(diff,dp);\\n    }\\n    public int helper(int diff,int[] dp){\\n        if(diff<0){\\n            return (int)1e9;\\n        }\\n        if(dp[diff]!=-1){\\n            return dp[diff];\\n        }\\n        if(diff==0){\\n            return dp[diff]=0;\\n        }\\n        return dp[diff]=Math.min(1+helper(diff-1,dp),Math.min(1+helper(diff-5,dp),Math.min(1+helper(diff-15,dp),1+helper(diff-60,dp))));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int convertTime(String current, String correct) {\\n        int diff=0;\\n        int count=0;\\n        for(int i=0;i<current.length()-1;i++){\\n            if(current.charAt(i)==\\':\\' || current.charAt(i+1)==\\':\\') continue;\\n            if(count==0){\\n                int s1=current.charAt(i)-\\'0\\';\\n                int s2=correct.charAt(i)-\\'0\\';\\n                int s3=current.charAt(i+1)-\\'0\\';\\n                int s4=correct.charAt(i+1)-\\'0\\';\\n                s1=s1*10+s3;\\n                s2=s2*10+s4;  \\n                diff+=Math.abs(s1-s2)*60;\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3699024,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\n\\nvar convertTime = function(current, correct) {\\n    const getMinutes = (time) => +time.slice(0, 2) * 60 + +time.slice(3);\\n    let diff = getMinutes(correct) - getMinutes(current);\\n    let sum = 0;\\n    const arr = [60, 15, 5,1]\\n    for(let i =0; i<arr.length; i++){\\n        sum += Math.floor(diff/arr[i]);\\n        diff %= arr[i];\\n    }\\n    return sum;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\n\\nvar convertTime = function(current, correct) {\\n    const getMinutes = (time) => +time.slice(0, 2) * 60 + +time.slice(3);\\n    let diff = getMinutes(correct) - getMinutes(current);\\n    let sum = 0;\\n    const arr = [60, 15, 5,1]\\n    for(let i =0; i<arr.length; i++){\\n        sum += Math.floor(diff/arr[i]);\\n        diff %= arr[i];\\n    }\\n    return sum;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679004,
                "title": "beats-93-75-runtime-94-3-space-python3",
                "content": "# Approach\\nDirectly splice hours and minutes from string and convert to integer. Use modular arithmetic to account to circular cycle of hours and minutes. Use greedy approach on remaining minutes.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        ops = 0\\n        cur_hours, cur_minutes = int(current[0:2]), int(current[3:5])\\n        cor_hours, cor_minutes = int(correct[0:2]), int(correct[3:5])\\n\\n        ops += (cor_hours - cur_hours) % 24 - (cor_minutes < cur_minutes)\\n        remaining = (cor_minutes - cur_minutes) % 60\\n        for q in (15, 5):\\n            ops += remaining // q\\n            remaining %= q\\n        \\n        return ops + remaining\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def convertTime(self, current: str, correct: str) -> int:\\n        ops = 0\\n        cur_hours, cur_minutes = int(current[0:2]), int(current[3:5])\\n        cor_hours, cor_minutes = int(correct[0:2]), int(correct[3:5])\\n\\n        ops += (cor_hours - cur_hours) % 24 - (cor_minutes < cur_minutes)\\n        remaining = (cor_minutes - cur_minutes) % 60\\n        for q in (15, 5):\\n            ops += remaining // q\\n            remaining %= q\\n        \\n        return ops + remaining\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676691,
                "title": "java-simple-solution-convert-to-minutes-and-traverse",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int convertTime(String current, String correct) {\\n        String[] splitCurrent = current.split(\":\");\\n        int currentInMinutes = Integer.parseInt(splitCurrent[0]) * 60 + Integer.parseInt(splitCurrent[1]);\\n\\n        String[] splitCorrect = correct.split(\":\");\\n        int correctInMinutes = Integer.parseInt(splitCorrect[0]) * 60 + Integer.parseInt(splitCorrect[1]);\\n\\n        int counter = 0;\\n        while (currentInMinutes != correctInMinutes) {\\n            if (currentInMinutes + 60 <= correctInMinutes) {\\n                currentInMinutes += 60;\\n            } else if (currentInMinutes + 15 <= correctInMinutes) {\\n                currentInMinutes += 15;\\n            } else if (currentInMinutes + 5 <= correctInMinutes) {\\n                currentInMinutes += 5;\\n            } else {\\n                currentInMinutes += 1;\\n            }\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int convertTime(String current, String correct) {\\n        String[] splitCurrent = current.split(\":\");\\n        int currentInMinutes = Integer.parseInt(splitCurrent[0]) * 60 + Integer.parseInt(splitCurrent[1]);\\n\\n        String[] splitCorrect = correct.split(\":\");\\n        int correctInMinutes = Integer.parseInt(splitCorrect[0]) * 60 + Integer.parseInt(splitCorrect[1]);\\n\\n        int counter = 0;\\n        while (currentInMinutes != correctInMinutes) {\\n            if (currentInMinutes + 60 <= correctInMinutes) {\\n                currentInMinutes += 60;\\n            } else if (currentInMinutes + 15 <= correctInMinutes) {\\n                currentInMinutes += 15;\\n            } else if (currentInMinutes + 5 <= correctInMinutes) {\\n                currentInMinutes += 5;\\n            } else {\\n                currentInMinutes += 1;\\n            }\\n            counter++;\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676611,
                "title": "beats-100-time-and-97-9-space-easy-approach",
                "content": "# Approach\\n\\nGet time difference between both times and use Greedy Approach (i.e first 60min, then 15min, 5min and 1min). \\n\\nThe time difference is (minCorr ~ minNow) if correct min is more than current min. (i.e the acute angle in the clock)\\n\\nBut in the other case, it should be the obtuse angle so, the difference is 60 - (minCorr ~ minNow). Further, in this case the hour isn\\'t complete yet so we decrease hour count by 1.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hN = (current[0] - \\'0\\')*10 + (current[1] - \\'0\\')*1;\\n        int hC = (correct[0] - \\'0\\')*10 + (correct[1] - \\'0\\')*1;\\n        int mN = (current[3] - \\'0\\')*10 + (current[4] - \\'0\\')*1;\\n        int mC = (correct[3] - \\'0\\')*10 + (correct[4] - \\'0\\')*1;\\n        \\n        int res = abs(hN - hC);\\n        int diff{};\\n        if(mN > mC){\\n            diff = abs(60- (mN-mC));\\n            res--;\\n        }\\n        else{\\n            diff = abs(mN - mC);\\n        }\\n        \\n        while(diff){\\n            if(diff >=15){\\n                res++;\\n                diff -= 15;\\n            }\\n            else if(diff >=5){\\n                res++;\\n                diff -= 5;\\n            }\\n            else{\\n                res += diff;\\n                diff = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int hN = (current[0] - \\'0\\')*10 + (current[1] - \\'0\\')*1;\\n        int hC = (correct[0] - \\'0\\')*10 + (correct[1] - \\'0\\')*1;\\n        int mN = (current[3] - \\'0\\')*10 + (current[4] - \\'0\\')*1;\\n        int mC = (correct[3] - \\'0\\')*10 + (correct[4] - \\'0\\')*1;\\n        \\n        int res = abs(hN - hC);\\n        int diff{};\\n        if(mN > mC){\\n            diff = abs(60- (mN-mC));\\n            res--;\\n        }\\n        else{\\n            diff = abs(mN - mC);\\n        }\\n        \\n        while(diff){\\n            if(diff >=15){\\n                res++;\\n                diff -= 15;\\n            }\\n            else if(diff >=5){\\n                res++;\\n                diff -= 5;\\n            }\\n            else{\\n                res += diff;\\n                diff = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669379,
                "title": "java-brief-and-fast-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRegarding the fact that we have String input values we will need to parse them to int and transform them in minutes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, we transform string values to int values in minutes. Then we create array with the values that we are allowed to use in operations. And starting from the biggest allowed value, we increase current time until it equals to correct time. Amount of operations will be the answer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int result=0;\\n\\n        int cur = Integer.parseInt(current.substring(0,2))*60+Integer.parseInt(current.substring(3,5));\\n\\n        int cor = Integer.parseInt(correct.substring(0,2))*60+Integer.parseInt(correct.substring(3,5));\\n\\n        int [] time = {60,15,5,1};\\n\\n        for(int i=0;i<time.length;i++){\\n            while (cor-cur>=time[i])\\n            {\\n                result++;\\n                cur+=time[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int result=0;\\n\\n        int cur = Integer.parseInt(current.substring(0,2))*60+Integer.parseInt(current.substring(3,5));\\n\\n        int cor = Integer.parseInt(correct.substring(0,2))*60+Integer.parseInt(correct.substring(3,5));\\n\\n        int [] time = {60,15,5,1};\\n\\n        for(int i=0;i<time.length;i++){\\n            while (cor-cur>=time[i])\\n            {\\n                result++;\\n                cur+=time[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659381,
                "title": "2224-minimum-number-of-operations-to-convert-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n       \\n       int hour1 = Integer.parseInt(current.substring(0,2));\\n       int min1  = Integer.parseInt(current.substring(3));\\n       int hour2 = Integer.parseInt(correct.substring(0,2));\\n       int min2  = Integer.parseInt(correct.substring(3));\\n\\n       int time1 =  hour1*60 + min1;\\n       int time2 =  hour2*60 + min2;\\n\\n       int required = Math.abs(time2-time1);\\n       int count=0;\\n\\n       while(required != 0){\\n           if(required >= 60){\\n               required -= 60;\\n           }\\n           else if(required >=15){\\n               required -= 15;\\n           }\\n           else if(required >= 5){\\n               required -= 5;\\n           }\\n           else{\\n               required -= 1;\\n           }\\n           count++;\\n       }\\n       return count;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n       \\n       int hour1 = Integer.parseInt(current.substring(0,2));\\n       int min1  = Integer.parseInt(current.substring(3));\\n       int hour2 = Integer.parseInt(correct.substring(0,2));\\n       int min2  = Integer.parseInt(correct.substring(3));\\n\\n       int time1 =  hour1*60 + min1;\\n       int time2 =  hour2*60 + min2;\\n\\n       int required = Math.abs(time2-time1);\\n       int count=0;\\n\\n       while(required != 0){\\n           if(required >= 60){\\n               required -= 60;\\n           }\\n           else if(required >=15){\\n               required -= 15;\\n           }\\n           else if(required >= 5){\\n               required -= 5;\\n           }\\n           else{\\n               required -= 1;\\n           }\\n           count++;\\n       }\\n       return count;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643935,
                "title": "bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool vis[1500];\\n    int convertStringTimeToInt(string timeString){\\n        int pos = timeString.find(\":\");\\n        int hours = stoi(timeString.substr(0,pos));\\n        int mins = stoi(timeString.substr(pos+1,timeString.size()));\\n        \\n        mins = hours*60 + mins;\\n        \\n        return mins;\\n    }\\n    \\n    \\n    int convertTime(string current, string correct) {\\n          vector<int> operations = {1,5,15,60};\\n         int ct = convertStringTimeToInt(current);\\n         int cti = convertStringTimeToInt(correct);\\n         \\n         queue<int> q;\\n        q.push(cti);\\n        \\n        int level=0;\\n        \\n        while(q.size()){\\n          \\n            int s=q.size();\\n            while(s--){\\n                int c=q.front();\\n                q.pop();\\n                \\n                if(c==ct) return level;\\n                \\n                if(vis[c]==true || c<0) continue;\\n                \\n                vis[c]=true;\\n                \\n                for(int i=0;i<operations.size();i++)\\n                      if(c-operations[i]>=0)\\n                      q.push(c-operations[i]);\\n                \\n               }\\n            level++;\\n       \\n        }\\n        return level;\\n    }\\n};\\n// we can surely do with beadth first search\\n\\n// time into minues ok \\n```\\n\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool vis[1500];\\n    int convertStringTimeToInt(string timeString){\\n        int pos = timeString.find(\":\");\\n        int hours = stoi(timeString.substr(0,pos));\\n        int mins = stoi(timeString.substr(pos+1,timeString.size()));\\n        \\n        mins = hours*60 + mins;\\n        \\n        return mins;\\n    }\\n    \\n    \\n    int convertTime(string current, string correct) {\\n          vector<int> operations = {1,5,15,60};\\n         int ct = convertStringTimeToInt(current);\\n         int cti = convertStringTimeToInt(correct);\\n         \\n         queue<int> q;\\n        q.push(cti);\\n        \\n        int level=0;\\n        \\n        while(q.size()){\\n          \\n            int s=q.size();\\n            while(s--){\\n                int c=q.front();\\n                q.pop();\\n                \\n                if(c==ct) return level;\\n                \\n                if(vis[c]==true || c<0) continue;\\n                \\n                vis[c]=true;\\n                \\n                for(int i=0;i<operations.size();i++)\\n                      if(c-operations[i]>=0)\\n                      q.push(c-operations[i]);\\n                \\n               }\\n            level++;\\n       \\n        }\\n        return level;\\n    }\\n};\\n// we can surely do with beadth first search\\n\\n// time into minues ok \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592245,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        \\n        int currentHours = 0;\\n        int currentMinute = 0;\\n        int correctHours = 0;\\n        int correctMinute = 0;   \\n        \\n        int i = 0;\\n        \\n        while(current[i] != \\':\\') {\\n            currentHours = currentHours * 10 + (current[i] - \\'0\\');\\n            ++i;\\n        }     \\n        ++i;\\n        while(i < current.size()) {\\n            currentMinute = currentMinute * 10 + (current[i] - \\'0\\');\\n            ++i;\\n        }\\n        \\n        int j = 0;\\n        while(correct[j] != \\':\\') {\\n            correctHours = correctHours * 10 + (correct[j] - \\'0\\');\\n            ++j;\\n        }\\n        ++j;\\n        while(j < correct.size()) {\\n            correctMinute = correctMinute * 10 + (correct[j] - \\'0\\');\\n            ++j;\\n        }\\n        \\n        currentMinute += currentHours * 60;\\n        correctMinute += correctHours * 60;\\n        vector<int> minutes = {60, 15, 5, 1};\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < 4; ++i) {\\n            \\n              int minute = minutes[i];\\n            while(currentMinute < correctMinute) {\\n                currentMinute += minute;\\n                count++;\\n            }\\n\\n            if(currentMinute == correctMinute) {\\n                return count;\\n            }\\n\\n            currentMinute -= minute;\\n            count--;\\n        }\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        \\n        int currentHours = 0;\\n        int currentMinute = 0;\\n        int correctHours = 0;\\n        int correctMinute = 0;   \\n        \\n        int i = 0;\\n        \\n        while(current[i] != \\':\\') {\\n            currentHours = currentHours * 10 + (current[i] - \\'0\\');\\n            ++i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3587174,
                "title": "javascript-modulus-division-remainder-57-ms-beats-80",
                "content": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    a = Number(current.split(\\':\\').at(0)) * 60 + Number(current.split(\\':\\').at(1))\\n    b = Number(correct.split(\\':\\').at(0)) * 60 + Number(correct.split(\\':\\').at(1))    \\n    time = b - a\\n    count = 0    \\n          \\n    count += Math.floor(time / 60), time = time % 60\\n    count += Math.floor(time / 15), time = time % 15\\n    count += Math.floor(time / 5), time = time % 5\\n    count += time\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    a = Number(current.split(\\':\\').at(0)) * 60 + Number(current.split(\\':\\').at(1))\\n    b = Number(correct.split(\\':\\').at(0)) * 60 + Number(correct.split(\\':\\').at(1))    \\n    time = b - a\\n    count = 0    \\n          \\n    count += Math.floor(time / 60), time = time % 60\\n    count += Math.floor(time / 15), time = time % 15\\n    count += Math.floor(time / 5), time = time % 5\\n    count += time\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3581668,
                "title": "c-intuitive-and-concise-with-explanation-why-greedy-work",
                "content": "greedy choose current viable max value\\n\\nThink about :\\nwe can use [1,5,15,60],for some number 60+X,\\n60+X = 60(1) + X = 15(4) + X = 5(12) + X = 1(60) + X\\n\\nif we can only use:\\n[1,4,5] , we can\\'t use greedy method.\\n\\n5+X = 5(1)+X = 4(1)+(X+1) = 1(5) + X\\nthink about X = 3\\n5+3 = 8 = 5(1) + 3 = 4(1) + (3+1) = 1(5) +3\\n\\n# Code\\n```\\n//============================================\\n// Greedy\\nclass Solution {\\n\\npublic:\\n    int convertTime(string current, string correct) {\\n\\n        vector<int> s_int(5);\\n\\n        //count differ , just do it.\\n        for(int i{};i<5;i++){\\n            s_int[i] = correct[i]-current[i];\\n        }\\n\\n        int hour,min;\\n        hour = s_int[0]*10+s_int[1];\\n        min  = s_int[3]*10+s_int[4];\\n        if(min<0) hour-=1,min+=60;\\n        \\n        return hour + min/15 + (min%15)/5 + (min%15%5);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//============================================\\n// Greedy\\nclass Solution {\\n\\npublic:\\n    int convertTime(string current, string correct) {\\n\\n        vector<int> s_int(5);\\n\\n        //count differ , just do it.\\n        for(int i{};i<5;i++){\\n            s_int[i] = correct[i]-current[i];\\n        }\\n\\n        int hour,min;\\n        hour = s_int[0]*10+s_int[1];\\n        min  = s_int[3]*10+s_int[4];\\n        if(min<0) hour-=1,min+=60;\\n        \\n        return hour + min/15 + (min%15)/5 + (min%15%5);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558466,
                "title": "easy-python-solution-time-complexity-o-1",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Split the current and correct strings at the colon (\":\") delimiter using the split method. The resulting substrings are assigned to curr and corr variables, respectively.\\n\\n2. The time values in curr and corr are converted to minutes by multiplying the hour part by 60 and adding the minute part. These converted values are assigned to cur_time and cor_time variables, respectively.\\n\\n3. The code enters a while loop that continues until cur_time becomes equal to or greater than cor_time.\\n\\n4. Within each iteration of the while loop, the code checks multiple conditions in a specific order to decide which operation to perform:\\n\\n5. Once the while loop completes, the function returns the value of ans, representing the minimum number of operations needed to convert the current time to the correct time.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n        curr = current.split(\":\")\\n        corr = correct.split(\":\")\\n        ans = 0\\n        cur_time = int(curr[0])*60 + int(curr[1])\\n        cor_time = int(corr[0])*60 + int(corr[1])\\n        while cur_time < cor_time:\\n            if cur_time + 60 <= cor_time:\\n                cur_time += 60\\n            elif cur_time + 15 <= cor_time:\\n                cur_time += 15\\n            elif cur_time + 5 <= cor_time:\\n                cur_time += 5\\n            elif cur_time + 1 <= cor_time:\\n                cur_time += 1\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n        curr = current.split(\":\")\\n        corr = correct.split(\":\")\\n        ans = 0\\n        cur_time = int(curr[0])*60 + int(curr[1])\\n        cor_time = int(corr[0])*60 + int(corr[1])\\n        while cur_time < cor_time:\\n            if cur_time + 60 <= cor_time:\\n                cur_time += 60\\n            elif cur_time + 15 <= cor_time:\\n                cur_time += 15\\n            elif cur_time + 5 <= cor_time:\\n                cur_time += 5\\n            elif cur_time + 1 <= cor_time:\\n                cur_time += 1\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553605,
                "title": "simple-ruby-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n# @param {String} current\\n# @param {String} correct\\n# @return {Integer}\\ndef convert_time(current, correct)\\n    curr = current.split(\\':\\')\\n    corr = correct.split(\\':\\')\\n    diff = corr[0].to_i*60 - curr[0].to_i*60 + corr[1].to_i - curr[1].to_i\\n    incs = [60, 15, 5, 1]\\n    ops = 0\\n    for i in incs do\\n        if diff == 0 then\\n            break\\n        end\\n        units = (diff/i).to_i\\n        diff = diff - units*i\\n        ops += units\\n    end\\n    return ops\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} current\\n# @param {String} correct\\n# @return {Integer}\\ndef convert_time(current, correct)\\n    curr = current.split(\\':\\')\\n    corr = correct.split(\\':\\')\\n    diff = corr[0].to_i*60 - curr[0].to_i*60 + corr[1].to_i - curr[1].to_i\\n    incs = [60, 15, 5, 1]\\n    ops = 0\\n    for i in incs do\\n        if diff == 0 then\\n            break\\n        end\\n        units = (diff/i).to_i\\n        diff = diff - units*i\\n        ops += units\\n    end\\n    return ops\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3547207,
                "title": "best-solution-in-o-1-time-and-space-complexity-100-correct-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert each time into minutes and then check the time difference between correct and current time.Then check how can we divide the difference into multiples of 1,5,15,60.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        string a=current.substr(0,2);\\n        //cout<<a<<endl;\\n        string b=correct.substr(0,2);\\n        //cout<<b<<endl;\\n        string c=current.substr(3);\\n        //cout<<c<<endl;\\n        string d=correct.substr(3);\\n        //cout<<d<<endl;\\n        int ans=((stoi(b)-stoi(a))*60)+(stoi(d)-stoi(c));\\n        \\n            \\n            //cout<<ans<<endl;\\n            //cout<<ans/60<<endl;\\n            //cout<<(ans%60)/15<<endl;\\n            //cout<<(ans%15)/5<<endl;\\n            //cout<<(ans%5)<<endl;\\n            return (ans/60)+(ans%60)/15+(ans%15)/5+(ans%5);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        string a=current.substr(0,2);\\n        //cout<<a<<endl;\\n        string b=correct.substr(0,2);\\n        //cout<<b<<endl;\\n        string c=current.substr(3);\\n        //cout<<c<<endl;\\n        string d=correct.substr(3);\\n        //cout<<d<<endl;\\n        int ans=((stoi(b)-stoi(a))*60)+(stoi(d)-stoi(c));\\n        \\n            \\n            //cout<<ans<<endl;\\n            //cout<<ans/60<<endl;\\n            //cout<<(ans%60)/15<<endl;\\n            //cout<<(ans%15)/5<<endl;\\n            //cout<<(ans%5)<<endl;\\n            return (ans/60)+(ans%60)/15+(ans%15)/5+(ans%5);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3540528,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        auto cur = ((current[0] - \\'0\\') * 10 + (current[1] - \\'0\\')) * 60 + (current[3] - \\'0\\') * 10 + (current[4] - \\'0\\');\\n        auto cor = ((correct[0] - \\'0\\') * 10 + (correct[1] - \\'0\\')) * 60 + (correct[3] - \\'0\\') * 10 + (correct[4] - \\'0\\');\\n        auto diff = cor - cur;\\n        return diff / 60 + diff % 60 / 15 + diff % 60 % 15 / 5 + diff % 60 % 15 % 5;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        auto cur = ((current[0] - \\'0\\') * 10 + (current[1] - \\'0\\')) * 60 + (current[3] - \\'0\\') * 10 + (current[4] - \\'0\\');\\n        auto cor = ((correct[0] - \\'0\\') * 10 + (correct[1] - \\'0\\')) * 60 + (correct[3] - \\'0\\') * 10 + (correct[4] - \\'0\\');\\n        auto diff = cor - cur;\\n        return diff / 60 + diff % 60 / 15 + diff % 60 % 15 / 5 + diff % 60 % 15 % 5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538346,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun convertTime(current: String, correct: String): Int {\\n        val hr1 = current.substring(0, 2).toInt()\\n        val min1 = current.substring(3, 5).toInt()\\n        val hr2 = correct.substring(0, 2).toInt()\\n        val min2 = correct.substring(3, 5).toInt()\\n        val mins = (hr2 - hr1) * 60 + (min2 - min1)\\n        return mins / 60 + (mins % 60) / 15 + (mins % 15) / 5 + (mins % 5)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun convertTime(current: String, correct: String): Int {\\n        val hr1 = current.substring(0, 2).toInt()\\n        val min1 = current.substring(3, 5).toInt()\\n        val hr2 = correct.substring(0, 2).toInt()\\n        val min2 = correct.substring(3, 5).toInt()\\n        val mins = (hr2 - hr1) * 60 + (min2 - min1)\\n        return mins / 60 + (mins % 60) / 15 + (mins % 15) / 5 + (mins % 5)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524387,
                "title": "beats-97-simple-javascript-solution",
                "content": "# Simple Javascript Solution\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function (current, correct) {\\n    let currentArr = current.split(\":\")\\n    let currentMins = Number(currentArr[0]) * 60 + Number(currentArr[1]) \\n\\n    let correctArr = correct.split(\":\")\\n    let correctMins = Number(correctArr[0]) * 60 + Number(correctArr[1])\\n\\n    let noOfOperations = 0\\n    let deltaTime = correctMins - currentMins\\n\\n    while (deltaTime > 0) {\\n        if (deltaTime >= 60) currentMins += 60\\n        else if (deltaTime >= 15) currentMins += 15\\n        else if (deltaTime >= 5) currentMins += 5\\n        else if (deltaTime >= 1) currentMins += 1\\n\\n        deltaTime = correctMins - currentMins\\n        noOfOperations++\\n    };\\n    return noOfOperations\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function (current, correct) {\\n    let currentArr = current.split(\":\")\\n    let currentMins = Number(currentArr[0]) * 60 + Number(currentArr[1]) \\n\\n    let correctArr = correct.split(\":\")\\n    let correctMins = Number(correctArr[0]) * 60 + Number(correctArr[1])\\n\\n    let noOfOperations = 0\\n    let deltaTime = correctMins - currentMins\\n\\n    while (deltaTime > 0) {\\n        if (deltaTime >= 60) currentMins += 60\\n        else if (deltaTime >= 15) currentMins += 15\\n        else if (deltaTime >= 5) currentMins += 5\\n        else if (deltaTime >= 1) currentMins += 1\\n\\n        deltaTime = correctMins - currentMins\\n        noOfOperations++\\n    };\\n    return noOfOperations\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493838,
                "title": "very-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    var currentSplit = current.split(\":\");\\n    var correctSplit = correct.split(\":\");\\n    var currentMins = parseInt(currentSplit[0]) * 60 + parseInt(currentSplit[1]);\\n    var correctMins = parseInt(correctSplit[0]) * 60 + parseInt(correctSplit[1]);\\n    var differenceMins = (correctMins - currentMins);\\n\\n    // 60 Minutes\\n    var count60 = Math.floor(differenceMins / 60);\\n    differenceMins -= count60 * 60;\\n\\n    // 15 Minutes\\n    var count15 = Math.floor(differenceMins / 15);\\n    differenceMins -= count15 * 15;\\n    \\n    // 5 Minutes\\n    var count5 = Math.floor(differenceMins / 5);\\n    differenceMins -= count5 * 5;\\n    \\n    // 1 Minutes\\n    var count1 = Math.floor(differenceMins);\\n    \\n    return count60 + count15 + count5 + count1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    var currentSplit = current.split(\":\");\\n    var correctSplit = correct.split(\":\");\\n    var currentMins = parseInt(currentSplit[0]) * 60 + parseInt(currentSplit[1]);\\n    var correctMins = parseInt(correctSplit[0]) * 60 + parseInt(correctSplit[1]);\\n    var differenceMins = (correctMins - currentMins);\\n\\n    // 60 Minutes\\n    var count60 = Math.floor(differenceMins / 60);\\n    differenceMins -= count60 * 60;\\n\\n    // 15 Minutes\\n    var count15 = Math.floor(differenceMins / 15);\\n    differenceMins -= count15 * 15;\\n    \\n    // 5 Minutes\\n    var count5 = Math.floor(differenceMins / 5);\\n    differenceMins -= count5 * 5;\\n    \\n    // 1 Minutes\\n    var count1 = Math.floor(differenceMins);\\n    \\n    return count60 + count15 + count5 + count1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492396,
                "title": "best-solution-with-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc convertTime(current string, correct string) int {\\n\\tif current == correct {\\n\\t\\treturn 0\\n\\t}\\n\\thour, _ := strconv.Atoi(current[:2])\\n\\tthour, _ := strconv.Atoi(correct[:2])\\n\\tminute, _ := strconv.Atoi(current[3:])\\n\\ttminute, _ := strconv.Atoi(correct[3:])\\n\\ttarget := thour*60 + tminute\\n\\tfrom := hour*60 + minute\\n\\treturn timeTakes(target-from, 0)\\n\\n}\\n\\nfunc timeTakes(minute int, operation int) int {\\n\\n\\tif minute == 0 {\\n\\t\\treturn operation\\n\\t}\\n\\n\\tif minute >= 60 {\\n\\t\\treturn timeTakes(minute%60, operation+(minute/60))\\n\\t} else if minute >= 15 {\\n\\t\\treturn timeTakes(minute%15, operation+(minute/15))\\n\\t} else if minute >= 5 {\\n\\t\\treturn timeTakes(minute%5, operation+(minute/5))\\n\\t} else {\\n\\t\\treturn timeTakes(minute%1, operation+(minute/1))\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc convertTime(current string, correct string) int {\\n\\tif current == correct {\\n\\t\\treturn 0\\n\\t}\\n\\thour, _ := strconv.Atoi(current[:2])\\n\\tthour, _ := strconv.Atoi(correct[:2])\\n\\tminute, _ := strconv.Atoi(current[3:])\\n\\ttminute, _ := strconv.Atoi(correct[3:])\\n\\ttarget := thour*60 + tminute\\n\\tfrom := hour*60 + minute\\n\\treturn timeTakes(target-from, 0)\\n\\n}\\n\\nfunc timeTakes(minute int, operation int) int {\\n\\n\\tif minute == 0 {\\n\\t\\treturn operation\\n\\t}\\n\\n\\tif minute >= 60 {\\n\\t\\treturn timeTakes(minute%60, operation+(minute/60))\\n\\t} else if minute >= 15 {\\n\\t\\treturn timeTakes(minute%15, operation+(minute/15))\\n\\t} else if minute >= 5 {\\n\\t\\treturn timeTakes(minute%5, operation+(minute/5))\\n\\t} else {\\n\\t\\treturn timeTakes(minute%1, operation+(minute/1))\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486506,
                "title": "js-converttime-noodkhan-navin",
                "content": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\n```\\n```\\nfunction getmin(min1, min2, ops) {\\n  var A = min1;\\n  var B = min2;\\n  while (A < B && A + 15 <= B) {\\n    ops++;\\n    A += 15;\\n  }\\n  while (A < B && A + 5 <= B) {\\n    ops++;\\n    A += 5;\\n  }\\n  while (A < B) {\\n    ops++;\\n    A++;\\n  }\\n  return ops;\\n}\\n\\nfunction getpair(input, arr) {\\n  var hours = [];\\n  var mins = [];\\n  hours.push(input[0], input[1]);\\n  mins.push(input[input.length - 2], input[input.length - 1]);\\n  var h = +hours.join(\"\");\\n  var m = +mins.join(\"\");\\n  arr.push([h, m]);\\n  return arr;\\n}\\n\\nvar convertTime = function (current, correct) {\\n  if (current === correct) {\\n    return 0;\\n  }\\n  var ops = 0;\\n  var arr = [];\\n  getpair(current, arr);\\n  getpair(correct, arr);\\n  var cur = arr[0];\\n  var cor = arr[1];\\n  var X = cur[1];\\n  var Y = cor[1];\\n  while (cor[0] > cur[0]) {\\n    ops++;\\n    cur[0]++;\\n  }\\n  if (cor[1] > cur[1]) {\\n    return getmin(X, Y, ops);\\n  }\\n  if (Y < X && cur[0] < cor[0]) {\\n    return getmin(X, Y + 60, ops);\\n  } else {\\n    if (cor[1] !== cur[1]) {\\n      return getmin(X, Y + 60, ops) - 1;\\n    }\\n  }\\n  return ops;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\n```\n```\\nfunction getmin(min1, min2, ops) {\\n  var A = min1;\\n  var B = min2;\\n  while (A < B && A + 15 <= B) {\\n    ops++;\\n    A += 15;\\n  }\\n  while (A < B && A + 5 <= B) {\\n    ops++;\\n    A += 5;\\n  }\\n  while (A < B) {\\n    ops++;\\n    A++;\\n  }\\n  return ops;\\n}\\n\\nfunction getpair(input, arr) {\\n  var hours = [];\\n  var mins = [];\\n  hours.push(input[0], input[1]);\\n  mins.push(input[input.length - 2], input[input.length - 1]);\\n  var h = +hours.join(\"\");\\n  var m = +mins.join(\"\");\\n  arr.push([h, m]);\\n  return arr;\\n}\\n\\nvar convertTime = function (current, correct) {\\n  if (current === correct) {\\n    return 0;\\n  }\\n  var ops = 0;\\n  var arr = [];\\n  getpair(current, arr);\\n  getpair(correct, arr);\\n  var cur = arr[0];\\n  var cor = arr[1];\\n  var X = cur[1];\\n  var Y = cor[1];\\n  while (cor[0] > cur[0]) {\\n    ops++;\\n    cur[0]++;\\n  }\\n  if (cor[1] > cur[1]) {\\n    return getmin(X, Y, ops);\\n  }\\n  if (Y < X && cur[0] < cor[0]) {\\n    return getmin(X, Y + 60, ops);\\n  } else {\\n    if (cor[1] !== cur[1]) {\\n      return getmin(X, Y + 60, ops) - 1;\\n    }\\n  }\\n  return ops;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462077,
                "title": "java-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n\\n        int h = Integer.parseInt(current.substring(0,2));\\n        int m = Integer.parseInt(current.substring(3,5));\\n        int cur = (h*60) + m;\\n\\n        int h1 = Integer.parseInt(correct.substring(0,2));\\n        int m1 = Integer.parseInt(correct.substring(3,5));\\n        int cor = (h1*60) + m1;\\n\\n        return helper(cur, cor, 0);\\n    }\\n    int helper(int cur, int cor, int ans)\\n    {\\n        if(cur == cor)\\n            return ans;\\n\\n        if(cur+60 <= cor)\\n            return helper(cur+60, cor, ans+1);\\n\\n        if(cur+15 <= cor)\\n            return helper(cur+15, cor, ans+1);\\n\\n        if(cur+5 <= cor)\\n            return helper(cur+5, cor, ans+1);\\n\\n        if(cur+1 <= cor)\\n            return helper(cur+1, cor, ans+1);\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n\\n        int h = Integer.parseInt(current.substring(0,2));\\n        int m = Integer.parseInt(current.substring(3,5));\\n        int cur = (h*60) + m;\\n\\n        int h1 = Integer.parseInt(correct.substring(0,2));\\n        int m1 = Integer.parseInt(correct.substring(3,5));\\n        int cor = (h1*60) + m1;\\n\\n        return helper(cur, cor, 0);\\n    }\\n    int helper(int cur, int cor, int ans)\\n    {\\n        if(cur == cor)\\n            return ans;\\n\\n        if(cur+60 <= cor)\\n            return helper(cur+60, cor, ans+1);\\n\\n        if(cur+15 <= cor)\\n            return helper(cur+15, cor, ans+1);\\n\\n        if(cur+5 <= cor)\\n            return helper(cur+5, cor, ans+1);\\n\\n        if(cur+1 <= cor)\\n            return helper(cur+1, cor, ans+1);\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460658,
                "title": "java-straightforward-and-short-version",
                "content": "```\\n    public int convertTime(String fromStr, String toStr) {\\n        var fromH = Integer.parseInt(fromStr.split(\":\")[0]);\\n        var fromM = Integer.parseInt(fromStr.split(\":\")[1]);\\n        var toH   = Integer.parseInt(toStr.split(\":\")[0]);\\n        var toM   = Integer.parseInt(toStr.split(\":\")[1]);\\n        var diffH = toH-fromH;\\n        var diffM = toM-fromM+diffH*60;\\n        var res = 0;\\n        while (diffM>0){\\n            if (diffM>=60){\\n                res++;diffM-=60;\\n            } else if (diffM>=15){\\n                res++;diffM-=15;\\n            } else if (diffM>=5){\\n                res++;diffM-=5;\\n            } else {\\n                res+=diffM;diffM=0;\\n            }\\n        }\\n        return res;\\n    }\\n```\\nand short version\\n```\\n    public int convertTime(String f, String t) {\\n        String[] from=f.split(\":\"), to=t.split(\":\");\\n        int fromH = Integer.parseInt(from[0]), fromM = Integer.parseInt(from[1]),\\n            toH   = Integer.parseInt(to[0]),   toM   = Integer.parseInt(to[1]),\\n            diffH = toH-fromH,                 diffM = toM-fromM+diffH*60;\\n        return diffM/60+(diffM%60)/15+((diffM%60)%15)/5+((diffM%60)%15)%5;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public int convertTime(String fromStr, String toStr) {\\n        var fromH = Integer.parseInt(fromStr.split(\":\")[0]);\\n        var fromM = Integer.parseInt(fromStr.split(\":\")[1]);\\n        var toH   = Integer.parseInt(toStr.split(\":\")[0]);\\n        var toM   = Integer.parseInt(toStr.split(\":\")[1]);\\n        var diffH = toH-fromH;\\n        var diffM = toM-fromM+diffH*60;\\n        var res = 0;\\n        while (diffM>0){\\n            if (diffM>=60){\\n                res++;diffM-=60;\\n            } else if (diffM>=15){\\n                res++;diffM-=15;\\n            } else if (diffM>=5){\\n                res++;diffM-=5;\\n            } else {\\n                res+=diffM;diffM=0;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int convertTime(String f, String t) {\\n        String[] from=f.split(\":\"), to=t.split(\":\");\\n        int fromH = Integer.parseInt(from[0]), fromM = Integer.parseInt(from[1]),\\n            toH   = Integer.parseInt(to[0]),   toM   = Integer.parseInt(to[1]),\\n            diffH = toH-fromH,                 diffM = toM-fromM+diffH*60;\\n        return diffM/60+(diffM%60)/15+((diffM%60)%15)/5+((diffM%60)%15)%5;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440700,
                "title": "c-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct)\\n    {\\n        int diff =\\n            + ((correct[0] - \\'0\\') * 10 + (correct[1] - \\'0\\')) * 60\\n            + ((correct[3] - \\'0\\') * 10 + (correct[4] - \\'0\\'))\\n            - ((current[0] - \\'0\\') * 10 + (current[1] - \\'0\\')) * 60\\n            - ((current[3] - \\'0\\') * 10 + (current[4] - \\'0\\'));\\n\\n        int ans = 0;\\n        for (auto i : { 60, 15, 5, 1 })\\n        {\\n            int c = diff / i;\\n            diff -= c*i, ans+=c;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct)\\n    {\\n        int diff =\\n            + ((correct[0] - \\'0\\') * 10 + (correct[1] - \\'0\\')) * 60\\n            + ((correct[3] - \\'0\\') * 10 + (correct[4] - \\'0\\'))\\n            - ((current[0] - \\'0\\') * 10 + (current[1] - \\'0\\')) * 60\\n            - ((current[3] - \\'0\\') * 10 + (current[4] - \\'0\\'));\\n\\n        int ans = 0;\\n        for (auto i : { 60, 15, 5, 1 })\\n        {\\n            int c = diff / i;\\n            diff -= c*i, ans+=c;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436858,
                "title": "beginner-level-solution-beats-94-12-runtime",
                "content": "# Intuition\\n1. Calculate the difference in terms of minutes.\\n2. Run through the list of correction and apply correction steps 1 by 1, from largest -> smallest.\\n3. Keep track of the counter.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n\\n        if current == correct: return 0\\n\\n        hh1 = int(current[:2])\\n        mm1 = int(current[-2:])\\n        hh2 = int(correct[:2])\\n        mm2 = int(correct[-2:])\\n\\n        correction = [1,5,15,60]\\n\\n        diff = (hh2-hh1) * 60 + (mm2 - mm1)\\n\\n        cntr = 0\\n        i = 3\\n        while diff > 0:\\n            while diff >= correction[i]:\\n                diff -= correction[i]\\n                cntr += 1\\n            i -= 1\\n\\n        return cntr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertTime(self, current, correct):\\n        \"\"\"\\n        :type current: str\\n        :type correct: str\\n        :rtype: int\\n        \"\"\"\\n\\n        if current == correct: return 0\\n\\n        hh1 = int(current[:2])\\n        mm1 = int(current[-2:])\\n        hh2 = int(correct[:2])\\n        mm2 = int(correct[-2:])\\n\\n        correction = [1,5,15,60]\\n\\n        diff = (hh2-hh1) * 60 + (mm2 - mm1)\\n\\n        cntr = 0\\n        i = 3\\n        while diff > 0:\\n            while diff >= correction[i]:\\n                diff -= correction[i]\\n                cntr += 1\\n            i -= 1\\n\\n        return cntr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435143,
                "title": "beginner-friendly-java-solution-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n      int minInCurr=Integer.parseInt(current.substring(0,current.length()-3))*60 +Integer.parseInt(current.substring(current.length()-2,current.length()));\\n      int minInCorr=Integer.parseInt(correct.substring(0,correct.length()-3))*60 +Integer.parseInt(correct.substring(correct.length()-2,correct.length()));\\n      int diff=minInCorr-minInCurr;\\n      int count=0;\\n      while(diff>0){\\n          if(diff>=60){\\n              count++;\\n              diff=diff-60;\\n          }else if(diff>=15){\\n              count++;\\n              diff=diff-15;\\n          }else if(diff>=5){\\n              count++;\\n              diff=diff-5;\\n          }else {\\n              count++;\\n              diff=diff-1;\\n          }\\n      }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n      int minInCurr=Integer.parseInt(current.substring(0,current.length()-3))*60 +Integer.parseInt(current.substring(current.length()-2,current.length()));\\n      int minInCorr=Integer.parseInt(correct.substring(0,correct.length()-3))*60 +Integer.parseInt(correct.substring(correct.length()-2,correct.length()));\\n      int diff=minInCorr-minInCurr;\\n      int count=0;\\n      while(diff>0){\\n          if(diff>=60){\\n              count++;\\n              diff=diff-60;\\n          }else if(diff>=15){\\n              count++;\\n              diff=diff-15;\\n          }else if(diff>=5){\\n              count++;\\n              diff=diff-5;\\n          }else {\\n              count++;\\n              diff=diff-1;\\n          }\\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429988,
                "title": "beats-100-simple-solution-string-to-num",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n       int curr=((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60+((current[3]-\\'0\\')*10+(current[4]-\\'0\\'));\\n       int corr=((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60+((correct[3]-\\'0\\')*10+(correct[4]-\\'0\\')); \\n       int diff=corr-curr;\\n       int count=0;\\n       while(diff)\\n       {\\n       if(diff>=60)\\n       {\\n         diff=diff-60;\\n         count++;\\n       }\\n       else if(diff>=15&&diff<60)\\n            {\\n                diff=diff-15;\\n                count++;\\n            }\\n       else if(diff>=5&&diff<15)\\n             {\\n                 diff=diff-5;\\n                 count++;\\n             }\\n        else\\n        {\\n            diff=diff-1;\\n            count++;\\n        }     \\n       }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n       int curr=((current[0]-\\'0\\')*10+(current[1]-\\'0\\'))*60+((current[3]-\\'0\\')*10+(current[4]-\\'0\\'));\\n       int corr=((correct[0]-\\'0\\')*10+(correct[1]-\\'0\\'))*60+((correct[3]-\\'0\\')*10+(correct[4]-\\'0\\')); \\n       int diff=corr-curr;\\n       int count=0;\\n       while(diff)\\n       {\\n       if(diff>=60)\\n       {\\n         diff=diff-60;\\n         count++;\\n       }\\n       else if(diff>=15&&diff<60)\\n            {\\n                diff=diff-15;\\n                count++;\\n            }\\n       else if(diff>=5&&diff<15)\\n             {\\n                 diff=diff-5;\\n                 count++;\\n             }\\n        else\\n        {\\n            diff=diff-1;\\n            count++;\\n        }     \\n       }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419271,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int count = 0;\\n\\n        int m = (correct.charAt(3)*10 + correct.charAt(4)) - (current.charAt(3)*10 + current.charAt(4));\\n        int h = (correct.charAt(0)*10 + correct.charAt(1)) - (current.charAt(0)*10 + current.charAt(1));\\n        int min = h*60 + m;\\n\\n        while(min > 0){\\n            if(min >= 60){\\n                min -= 60;\\n                count++;\\n            }\\n            else if(min >= 15){\\n                min -= 15;\\n                count++;\\n            }\\n            else if(min >= 5){\\n                min -= 5;\\n                count++;\\n            }\\n            else{\\n                min -= 1;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        int count = 0;\\n\\n        int m = (correct.charAt(3)*10 + correct.charAt(4)) - (current.charAt(3)*10 + current.charAt(4));\\n        int h = (correct.charAt(0)*10 + correct.charAt(1)) - (current.charAt(0)*10 + current.charAt(1));\\n        int min = h*60 + m;\\n\\n        while(min > 0){\\n            if(min >= 60){\\n                min -= 60;\\n                count++;\\n            }\\n            else if(min >= 15){\\n                min -= 15;\\n                count++;\\n            }\\n            else if(min >= 5){\\n                min -= 5;\\n                count++;\\n            }\\n            else{\\n                min -= 1;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403576,
                "title": "javascript-solution-96",
                "content": "\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    let [h1,m1]=current.split(\":\")\\n    let [h2,m2]=correct.split(\":\")\\n    let diff = (h2-h1)*60+(m2-m1)\\n    \\n    let operations = 0\\n    while (diff>=60){\\n    diff -=60\\n    operations++\\n    }\\n    while (diff>=15){\\n    diff-=15\\n    operations++\\n    }\\n    while (diff>=5){\\n    diff -=5\\n    operations++\\n    }\\n    while (diff>=1){\\n    diff-=1\\n    operations++\\n    }\\n    return operations\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    let [h1,m1]=current.split(\":\")\\n    let [h2,m2]=correct.split(\":\")\\n    let diff = (h2-h1)*60+(m2-m1)\\n    \\n    let operations = 0\\n    while (diff>=60){\\n    diff -=60\\n    operations++\\n    }\\n    while (diff>=15){\\n    diff-=15\\n    operations++\\n    }\\n    while (diff>=5){\\n    diff -=5\\n    operations++\\n    }\\n    while (diff>=1){\\n    diff-=1\\n    operations++\\n    }\\n    return operations\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3399884,
                "title": "naive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is pretty simple, just keep checking if the time is up or not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHave the times in an array to easily subtract the times in decreasing order to always remove the most of amount of time possible. Have a while loop until done\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> Not sure exactly, but above O(n) and below O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        // current is formatted as HH:MM hour and minute\\n\\n        // Increase current by 1, 5, 15, 60 minutes\\n        // Split the string, turn it all into minutes\\n        // Loop for 60 -> 15 -> 5 -> 1 until 0\\n        // Return number of operations needed to get to correct\\n\\n        // CURRNENT\\n        int hr = Integer.valueOf(current.substring(0, 2))*60;\\n        int min = Integer.valueOf(current.substring(3));\\n        int total = hr+min;\\n        int[] times = {60, 15, 5, 1};\\n        int count = 0;\\n\\n        // CORRECT\\n        int hrC = Integer.valueOf(correct.substring(0, 2))*60;\\n        int minC = Integer.valueOf(correct.substring(3));\\n        int totalC = hrC+minC;\\n\\n        int finalTotal = totalC - total;\\n\\n        //System.out.println(hr);\\n        //System.out.println(min);\\n        System.out.println(hr+min); //150\\n\\n        int i = 0;\\n        while(finalTotal != 0){\\n            if(finalTotal >= times[i]){\\n                finalTotal-=times[i];\\n                count++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return(count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int convertTime(String current, String correct) {\\n        // current is formatted as HH:MM hour and minute\\n\\n        // Increase current by 1, 5, 15, 60 minutes\\n        // Split the string, turn it all into minutes\\n        // Loop for 60 -> 15 -> 5 -> 1 until 0\\n        // Return number of operations needed to get to correct\\n\\n        // CURRNENT\\n        int hr = Integer.valueOf(current.substring(0, 2))*60;\\n        int min = Integer.valueOf(current.substring(3));\\n        int total = hr+min;\\n        int[] times = {60, 15, 5, 1};\\n        int count = 0;\\n\\n        // CORRECT\\n        int hrC = Integer.valueOf(correct.substring(0, 2))*60;\\n        int minC = Integer.valueOf(correct.substring(3));\\n        int totalC = hrC+minC;\\n\\n        int finalTotal = totalC - total;\\n\\n        //System.out.println(hr);\\n        //System.out.println(min);\\n        System.out.println(hr+min); //150\\n\\n        int i = 0;\\n        while(finalTotal != 0){\\n            if(finalTotal >= times[i]){\\n                finalTotal-=times[i];\\n                count++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return(count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394257,
                "title": "simple-maths-o-n-soln-upvote-for-karma",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ans=0;\\n        if(current==correct)\\n        return 0;\\n\\n        ans=(correct[0]*10+correct[1])-(current[0]*10+current[1]);\\n\\n        int a=(correct[3]*10+correct[4]);\\n        int b=(current[3]*10+current[4]);\\n      \\n        int c=abs(a-b);\\n\\n           if(a<b){\\n          ans--;\\n          c=a+60-b;\\n           }\\n          \\n          int rem=0;\\n          rem=c/15;\\n          c=c%15;\\n          rem+=c/5;\\n          c=c%5;\\n          rem+=c;\\n\\n         \\n          ans+=rem;\\n\\n          return ans;\\n\\n    }\\n};\\n//Upvote\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertTime(string current, string correct) {\\n        int ans=0;\\n        if(current==correct)\\n        return 0;\\n\\n        ans=(correct[0]*10+correct[1])-(current[0]*10+current[1]);\\n\\n        int a=(correct[3]*10+correct[4]);\\n        int b=(current[3]*10+current[4]);\\n      \\n        int c=abs(a-b);\\n\\n           if(a<b){\\n          ans--;\\n          c=a+60-b;\\n           }\\n          \\n          int rem=0;\\n          rem=c/15;\\n          c=c%15;\\n          rem+=c/5;\\n          c=c%5;\\n          rem+=c;\\n\\n         \\n          ans+=rem;\\n\\n          return ans;\\n\\n    }\\n};\\n//Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387273,
                "title": "js-runtime-58-ms-beats-76-27-memory-41-9-mb-beats-86-44",
                "content": "# Intuition\\nBreak current and correct in chunks of 60,15,5,1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    var count = 0;\\n\\n    var crtArr = current.split(\\':\\')\\n    var crcArr = correct.split(\\':\\')\\n\\n    var crtHH = Number(crtArr[0])\\n    var crcHH = Number(crcArr[0])\\n    var diffHH = crcHH - crtHH;\\n    count = count + diffHH;\\n\\n    var crtMM = Number(crtArr[1])\\n    var crcMM = Number(crcArr[1])\\n\\n    // Detect if Minutes Current > Minutes Correct\\n    if(crtMM <= crcMM){\\n        var diffMM = crcMM - crtMM\\n    }else{\\n        diffMM = crcMM + (60 - crtMM)\\n        count = count - 1\\n    }\\n\\n    var d15 = diffMM/15\\n    var remain = diffMM%15\\n    if(d15>0){\\n        count = count + Math.floor(d15)\\n    }\\n\\n    if(remain){\\n        var d5 = remain/5\\n        remain = remain%5\\n        if(d5>0){\\n             count = count + Math.floor(d5)\\n        }\\n    }\\n    if(remain){\\n        count = count + remain\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} current\\n * @param {string} correct\\n * @return {number}\\n */\\nvar convertTime = function(current, correct) {\\n    var count = 0;\\n\\n    var crtArr = current.split(\\':\\')\\n    var crcArr = correct.split(\\':\\')\\n\\n    var crtHH = Number(crtArr[0])\\n    var crcHH = Number(crcArr[0])\\n    var diffHH = crcHH - crtHH;\\n    count = count + diffHH;\\n\\n    var crtMM = Number(crtArr[1])\\n    var crcMM = Number(crcArr[1])\\n\\n    // Detect if Minutes Current > Minutes Correct\\n    if(crtMM <= crcMM){\\n        var diffMM = crcMM - crtMM\\n    }else{\\n        diffMM = crcMM + (60 - crtMM)\\n        count = count - 1\\n    }\\n\\n    var d15 = diffMM/15\\n    var remain = diffMM%15\\n    if(d15>0){\\n        count = count + Math.floor(d15)\\n    }\\n\\n    if(remain){\\n        var d5 = remain/5\\n        remain = remain%5\\n        if(d5>0){\\n             count = count + Math.floor(d5)\\n        }\\n    }\\n    if(remain){\\n        count = count + remain\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2025730,
                "content": [
                    {
                        "username": "IliyanP",
                        "content": "Just convert the time in minutes for bot current and correct, substract current from correct as absolute value and then use while loop to substract the values\\n60,15,5,1 from the difference of current and correct"
                    },
                    {
                        "username": "bortengineer",
                        "content": "There is nothing in the description indicating that \"current should be less than or equal to correct\"."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "In one operation you can INCREASE the time"
                    },
                    {
                        "username": "shuydo12",
                        "content": "Logic absent. I decreasing 1 counter-clockwise, but no increase 23+3*15+2*5+4 in case 142 0:00 => 23:59 //32"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "According to the description, you cannot go counter-clockwise:)"
                    }
                ]
            },
            {
                "id": 1814501,
                "content": [
                    {
                        "username": "IliyanP",
                        "content": "Just convert the time in minutes for bot current and correct, substract current from correct as absolute value and then use while loop to substract the values\\n60,15,5,1 from the difference of current and correct"
                    },
                    {
                        "username": "bortengineer",
                        "content": "There is nothing in the description indicating that \"current should be less than or equal to correct\"."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "In one operation you can INCREASE the time"
                    },
                    {
                        "username": "shuydo12",
                        "content": "Logic absent. I decreasing 1 counter-clockwise, but no increase 23+3*15+2*5+4 in case 142 0:00 => 23:59 //32"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "According to the description, you cannot go counter-clockwise:)"
                    }
                ]
            },
            {
                "id": 1728432,
                "content": [
                    {
                        "username": "IliyanP",
                        "content": "Just convert the time in minutes for bot current and correct, substract current from correct as absolute value and then use while loop to substract the values\\n60,15,5,1 from the difference of current and correct"
                    },
                    {
                        "username": "bortengineer",
                        "content": "There is nothing in the description indicating that \"current should be less than or equal to correct\"."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "In one operation you can INCREASE the time"
                    },
                    {
                        "username": "shuydo12",
                        "content": "Logic absent. I decreasing 1 counter-clockwise, but no increase 23+3*15+2*5+4 in case 142 0:00 => 23:59 //32"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "According to the description, you cannot go counter-clockwise:)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Total Beauty of the Gardens",
        "question_content": "<p>Alice is a caretaker of <code>n</code> gardens and she wants to plant flowers to maximize the total beauty of all her gardens.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>flowers</code> of size <code>n</code>, where <code>flowers[i]</code> is the number of flowers already planted in the <code>i<sup>th</sup></code> garden. Flowers that are already planted <strong>cannot</strong> be removed. You are then given another integer <code>newFlowers</code>, which is the <strong>maximum</strong> number of flowers that Alice can additionally plant. You are also given the integers <code>target</code>, <code>full</code>, and <code>partial</code>.</p>\n\n<p>A garden is considered <strong>complete</strong> if it has <strong>at least</strong> <code>target</code> flowers. The <strong>total beauty</strong> of the gardens is then determined as the <strong>sum</strong> of the following:</p>\n\n<ul>\n\t<li>The number of <strong>complete</strong> gardens multiplied by <code>full</code>.</li>\n\t<li>The <strong>minimum</strong> number of flowers in any of the <strong>incomplete</strong> gardens multiplied by <code>partial</code>. If there are no incomplete gardens, then this value will be <code>0</code>.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum</strong> total beauty that Alice can obtain after planting at most </em><code>newFlowers</code><em> flowers.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> Alice can plant\n- 2 flowers in the 0<sup>th</sup> garden\n- 3 flowers in the 1<sup>st</sup> garden\n- 1 flower in the 2<sup>nd</sup> garden\n- 1 flower in the 3<sup>rd</sup> garden\nThe gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.\nThere is 1 garden that is complete.\nThe minimum number of flowers in the incomplete gardens is 2.\nThus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14.\nNo other way of planting flowers can obtain a total beauty higher than 14.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6\n<strong>Output:</strong> 30\n<strong>Explanation:</strong> Alice can plant\n- 3 flowers in the 0<sup>th</sup> garden\n- 0 flowers in the 1<sup>st</sup> garden\n- 0 flowers in the 2<sup>nd</sup> garden\n- 2 flowers in the 3<sup>rd</sup> garden\nThe gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.\nThere are 3 gardens that are complete.\nThe minimum number of flowers in the incomplete gardens is 4.\nThus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30.\nNo other way of planting flowers can obtain a total beauty higher than 30.\nNote that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>\n\t<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1931085,
                "title": "python-explanation-with-pictures",
                "content": "Its clear that if we have more complete gardens, we are likely to have fewer flowers in the smallest garden. We are not sure how many complete gardens we need to maximize the score, hence we will try every possible number of complete garden. \\n\\nWe want to use fewer flowers to fill a complete garden, hence, sort gardens by the number of flowers and complete each garden from the incomplete garden that having the most flowers. \\n\\nTherefore we will \\n- **count complete gardens from tail**\\n- **maximize the incomoplete garden from head**.\\n\\nNotice that we have at most `new` flowers to plant, if we make all the gardens after `j` complete, the remaining flowers equals `new` minus the cost to make these gardens complete.\\n\\nThen we maximize the number of flowers using the updated `new`, as shown in the picture below. Hence, we have the score in this case.\\n\\n![image](https://assets.leetcode.com/users/images/96ca4435-4e56-4005-8e9f-8b0e858df43f_1649563440.3317957.png)\\n\\n\\nThen we move on to make one more complete garden, that is, to make `j-1 -th` garden as complete. If there is still flowers left after making this garden complete, we will repeat the same process to calculate the maximum minimum number of flowers.\\n\\n![image](https://assets.leetcode.com/users/images/9823acd8-32f0-4123-a9d7-d9ef24d9acfc_1649563449.1329505.png)\\n\\nHow to calculate the maximum incomplete flower?\\n\\nRecall that we split the problem into two halves, getting the cost to complete gardens after `j` is straigtforward, we just need to iterate from `n-1` to `j` and calculate the cost.\\n\\n![image](https://assets.leetcode.com/users/images/3b6a4498-a4b1-4dec-97fd-e8d123a3d8e1_1649565225.0188658.png)\\n\\nFor the second half: **maximize the incomplete flowers**, we can build an auxiliary list `cost`, as shown in the picture below. Basically, `cost[i]` stands for the total cost to make all the gardens before `i` having the same number of flowers as `garden i\\'s`. \\nFor instance, I colored the `cost[1]` in purple and you can tell the reason why `cost[1] = 2`.\\n\\n![image](https://assets.leetcode.com/users/images/2e169773-1188-4498-aaca-54eb35f787ef_1649565262.8332002.png)\\n\\nSuppose we have 6 flowers and would like to maximize the incomplete flowers. \\n- Find how many gardens will be planted using binary search. If `new` is no less than `cost[i]`, meaning we can make all the first `i` gardens having `A[i]` flowers.\\n- Check if we can increase the number of flowers in all the `i` gardens any more.\\n\\nMore details:\\n\\n![image](https://assets.leetcode.com/users/images/87fc33ad-baa2-496a-8f0b-bf88930ceece_1649565266.8852856.png)\\n\\n> In case I didn\\'t explain it well, take a look at the right hand side of the picture above. What does the `idx=3` of the binary search tell? It means that the `new=6` we have is enough to make `3` gardens having the same number of flowers\\n\\n**Steps**\\n> In short, we will stop by every incomplete garden (by decreasing order), for each garden:\\n> -  Maximize the smallest incomplete garden.\\n> -  Get the current score and update the maximum score.\\n> -  Make this garden complete, if possible and move on to the next incomplete garden.\\n\\n**Complexity**\\n`O(n logn)`.\\n`O(n)` steps in the iteration, since we have to complete at most `n` buildings before finding out the maximum score. Binary search in each step takes `O(logn)` (I think it can be reduced to `O(1)` since the minimum flower is monotonically decreasing, as we increase the number of complete gardens).\\n\\n\\n**Code**\\n```\\nclass Solution:\\n    def maximumBeauty(self, A: List[int], new: int, t: int, full: int, part: int) -> int:\\n        A = [min(t, a) for a in A]\\n        A.sort()\\n\\t\\t\\n\\t\\t# Two edge cases\\n        if min(A) == t: return full * len(A)\\n        if new >= t * len(A) - sum(A):\\n            return max(full*len(A), full*(len(A)-1) + part*(t-1))\\n        \\n\\t\\t# Build the array `cost`.\\n        cost = [0]\\n        for i in range(1, len(A)):\\n            pre = cost[-1]\\n            cost.append(pre + i * (A[i] - A[i - 1]))\\n\\n\\t\\t# Since there might be some gardens having `target` flowers already, we will skip them.\\n        j = len(A) - 1\\n        while A[j] == t:\\n            j -= 1\\n        \\n\\t\\t# Start the iteration\\n        ans = 0\\n        while new >= 0:\\n\\t\\t\\n\\t\\t\\t# idx stands for the first `j` gardens, notice a edge case might happen.\\n            idx = min(j, bisect_right(cost, new) - 1)\\n\\t\\t\\t\\n\\t\\t\\t# bar is the current minimum flower in the incomplete garden\\n            bar = A[idx] + (new - cost[idx]) // (idx + 1)\\n\\t\\t\\t\\n            ans = max(ans, bar * part + full *(len(A) - j - 1))\\n            \\n\\t\\t\\t# Now we would like to complete garden j, thus deduct the cost for garden j \\n\\t\\t\\t# from new and move on to the previous(next) incomplete garden!\\n\\t\\t\\tnew -= (t - A[j])\\n            j -= 1\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, A: List[int], new: int, t: int, full: int, part: int) -> int:\\n        A = [min(t, a) for a in A]\\n        A.sort()\\n\\t\\t\\n\\t\\t# Two edge cases\\n        if min(A) == t: return full * len(A)\\n        if new >= t * len(A) - sum(A):\\n            return max(full*len(A), full*(len(A)-1) + part*(t-1))\\n        \\n\\t\\t# Build the array `cost`.\\n        cost = [0]\\n        for i in range(1, len(A)):\\n            pre = cost[-1]\\n            cost.append(pre + i * (A[i] - A[i - 1]))\\n\\n\\t\\t# Since there might be some gardens having `target` flowers already, we will skip them.\\n        j = len(A) - 1\\n        while A[j] == t:\\n            j -= 1\\n        \\n\\t\\t# Start the iteration\\n        ans = 0\\n        while new >= 0:\\n\\t\\t\\n\\t\\t\\t# idx stands for the first `j` gardens, notice a edge case might happen.\\n            idx = min(j, bisect_right(cost, new) - 1)\\n\\t\\t\\t\\n\\t\\t\\t# bar is the current minimum flower in the incomplete garden\\n            bar = A[idx] + (new - cost[idx]) // (idx + 1)\\n\\t\\t\\t\\n            ans = max(ans, bar * part + full *(len(A) - j - 1))\\n            \\n\\t\\t\\t# Now we would like to complete garden j, thus deduct the cost for garden j \\n\\t\\t\\t# from new and move on to the previous(next) incomplete garden!\\n\\t\\t\\tnew -= (t - A[j])\\n            j -= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934318,
                "title": "two-pointers",
                "content": "I do not think that we need a binary search here.\\n\\nWe sort gardens (descending), and then go left to right and make gardens full (until we run out of flowers). Thus, our first pointer `p1` indicates full gardens, and the last garden defines the minimum number of flowers (`minF`) among all gardens.\\n \\n> There is a special case when we can make all gardens full - it may be better to only plant `target - 1` flowers in the last garden, if `(target - 1) * partial > full`.\\n\\nWe then go right-to-left, and try increasing the minimum number of flowers. The second pointer - `p2` - indicates how many gardens have less flowers than `minF`.\\n \\nWe plan necessary flowers to gardens right of `p2`. If we do not have enough flowers, we take it from the rightmost full garden, decreasing `p1`. For each `minF` we can achieve, we track and return the maximum beauty.\\n\\nHere is an example for `[9, 7, 7, 6, 5, 4, 3, 2, 1, 1]` gardens, with target `8` and `9` new flowers to plant. As you see, for `minF == 2`, we have 5 full gardens. For `minF == 3`, we move `p1` to get enough flowers to plant, and now we have 4 full gardens. \\n\\n![image](https://assets.leetcode.com/users/images/e4932391-61ca-434f-b02e-3e7adddb92ec_1649643539.741906.png)\\n\\n**C++**\\n```cpp\\nlong long maximumBeauty(vector<int>& fl, long long newFlowers, int target, int full, int partial) {\\n    sort(begin(fl), end(fl), greater<int>());\\n    long long p1 = 0, sum = 0, res = 0, sz = fl.size();\\n    for (; p1 < sz; ++p1) {\\n        if (target - fl[p1] > newFlowers)\\n            break;\\n        newFlowers -= max(0, target - fl[p1]);\\n    }\\n    if (p1 == sz)\\n        return max(sz * full, (sz - 1) * full + (fl.back() < target ? (long long)(target - 1) * partial : full));\\n    for (long long minF = fl.back(), p2 = fl.size() - 1; minF < target; ) {\\n        while (p2 >= p1 && fl[p2] <= minF)\\n            sum += fl[p2--];\\n        int needed = (sz - p2 - 1) * minF - sum;\\n        if (needed > newFlowers) {\\n            if (--p1 < 0)\\n                break;\\n            newFlowers += max(0, target - fl[p1]);\\n        }\\n        else {\\n            res = max(p1 * full + minF * partial, res);    \\n            ++minF;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long maximumBeauty(vector<int>& fl, long long newFlowers, int target, int full, int partial) {\\n    sort(begin(fl), end(fl), greater<int>());\\n    long long p1 = 0, sum = 0, res = 0, sz = fl.size();\\n    for (; p1 < sz; ++p1) {\\n        if (target - fl[p1] > newFlowers)\\n            break;\\n        newFlowers -= max(0, target - fl[p1]);\\n    }\\n    if (p1 == sz)\\n        return max(sz * full, (sz - 1) * full + (fl.back() < target ? (long long)(target - 1) * partial : full));\\n    for (long long minF = fl.back(), p2 = fl.size() - 1; minF < target; ) {\\n        while (p2 >= p1 && fl[p2] <= minF)\\n            sum += fl[p2--];\\n        int needed = (sz - p2 - 1) * minF - sum;\\n        if (needed > newFlowers) {\\n            if (--p1 < 0)\\n                break;\\n            newFlowers += max(0, target - fl[p1]);\\n        }\\n        else {\\n            res = max(p1 * full + minF * partial, res);    \\n            ++minF;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932250,
                "title": "c-commented-explanation-clean-code",
                "content": "/*\\n      \\n      Pre-Requisites :--> Prefix Sum + Binary Search\\n      \\n      Logic in a Nutshell :--> Actually in these type of questions , where the optimal answer is dependent on two distinct entities ,\\n      \\n                               We used to fix one entity and try to change ( increment / decrement ) its value ; and then figure out what \\n                               \\n                               is the impact of the first operation on the second entity.\\n                               \\n                               \\n                Maybe , it sounds not so good , but analyzing the question you can easily get that Our answer depends on \\n                 \\n                 (1) Number of full flowers --> (num_full*fullValue)  --> val1\\n                 (2) Minimum value of Incomplete flower --> (min_incomp*partialValue)  --> val2\\n                 \\n                 \\n               And the optimal answer will be the maxValue from any of the combinations of these two entity \\n               \\n               [ e.g :- 2 full flower + 3 partial flower\\n                        4 full flower + 1 partial flower\\n                        1 full flower + 3 partial flower ]\\n                        \\n                        \\n      Approach :-->  But how can we determine which valid combination fetchs us our desired output.\\n      \\n                     For these we have to make some basic but important observations ........\\n                     \\n                    \\n                    Observation(1) -->  We are given with fixed value of newFlowers (Let us consider it K) . Now we can use atmost K flowers.\\n \\n                         So how can we use minimum number of newFlowers and get maximum number of full flowers( whose value >= taregt) ???\\n                         \\n                         So obviously , we have to pick the Maximum valued flowers and try to put extra flowers till flowers[i]!=target.\\n                         \\n            [ E.g :- flowers [2,4,6,7,9] , newFlowers = 5 , fullValue = 10 ---> Now we pick the flowers[4]=9 and use 1 flower .......]\\n                                        \\n                                        \\n                   Observation(2) --> Now after we are done with the first part ( Current number of full flowers that we can achieve using atmost newFlowers amount of flowers )       \\n                   \\n                   After using certain amount of flowers in making certain amount of flowers \"full\" , let us say we have \"rest\" amount of newFlowers , we have to decide what we can do further with these amount of flowers.\\n                   \\n                   So , for these we have to look at the definition of\\n                   \\n                \"sumofbeauty\" --> \"# of full flowers * fullVal \" + \" Minimum valued incomplete flower * partialVal \"\\n                \\n                \\n                So it is not that we can make one flower[i] so big with \"rest\" flowers , as the minimum incomplete flowers[i] remains the same and it will not increment our result that much.\\n                \\n                Well ,we have to evenly distribute the \"rest\" flowers to all of the incomplete flowers and pick the Minimum one.\\n                \\n                wait wait , so as a whole we have to maximize the minimum flowers[i] --> bang on !!! Here comes the approach of Binary Search.\\n                   \\n                Finally , we have to fix the value of the incomplete flowers [ which have flowers[i] < target ] to \"mid\" and check whether all the incomplete flowers can reach to the \"mid\" value and if yes then increment the value properly.   \\n                   \\n    */\\n\\t\\n\\t`class Solution {\\npublic:\\n    \\n\\n    typedef long long ll;\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        \\n        ll n=flowers.size();\\n        \\n        sort(flowers.begin(),flowers.end());\\n        \\n        vector<ll>prefix(n,0LL);\\n        \\n        prefix[0]=flowers[0];\\n        \\n        for(ll i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+(ll)flowers[i];\\n        }\\n        \\n        \\n        ll max_beauty=0LL;\\n        \\n        // Travrese from the end of the array as discussed previously.......\\n        \\n        // Check Whether we can make full flowers from index n-1 to index i [ if not then break ]\\n        \\n        // There is one additional corner case --> Sometimes it will be optimal that we\\'ll select 0 number of full flowers and try to maximize the partial_beauty using newFlowers.\\n        \\n        \\n        for(ll i=n;i>=0;i--){\\n            \\n            if(i==n){\\n                \\n                \\n            }\\n        \\n            else{\\n                \\n                ll req_for_full=max(0LL,(ll)(target-flowers[i]));\\n                \\n                if(req_for_full > newFlowers){\\n                    break;\\n                }\\n                \\n                newFlowers-=req_for_full; \\n                \\n                flowers.pop_back();  // This the line where your code fails even after it is correct logically , as there is some situation when number of full flowers and number of partial flowers can collide and it increase our answer than the actual one . Try the Example TestCase 2 by your own.\\n                \\n            }\\n            \\n            \\n            ll curr_beauty_full=((n-i)*full);\\n            \\n            ll curr_beauty_partial=0LL;\\n            \\n            ll low=0,high=target-1;\\n            \\n            while(low<=high){\\n                \\n                ll mid=(low+high)/2;\\n                \\n                ll idx=upper_bound(flowers.begin(),flowers.end(),mid)-flowers.begin();\\n                \\n                if(idx==0){\\n                    \\n                    low=mid+1;\\n                    \\n                }\\n                \\n                else{\\n                    \\n                    ll have_flowers=prefix[idx-1];\\n                    \\n                    ll req_flowers=(idx*mid);\\n                    \\n                    ll extra_flowers=(req_flowers-have_flowers);\\n                    \\n                    if(extra_flowers<=newFlowers){\\n                        \\n                        curr_beauty_partial=(mid*partial);\\n                        \\n                        low=mid+1;\\n                        \\n                    }\\n                    \\n                    else{\\n                        \\n                        high=mid-1;\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            max_beauty=max(max_beauty,curr_beauty_partial+curr_beauty_full);\\n            \\n        }\\n        \\n        return max_beauty;\\n        \\n    }\\n};`",
                "solutionTags": [
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\n    typedef long long ll;\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        \\n        ll n=flowers.size();\\n        \\n        sort(flowers.begin(),flowers.end());\\n        \\n        vector<ll>prefix(n,0LL);\\n        \\n        prefix[0]=flowers[0];\\n        \\n        for(ll i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+(ll)flowers[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1931867,
                "title": "python3-prefix-sum-binary-search-o-log-target-log-n-n-accepted",
                "content": "First, sort the `flowers` list in ascending order. If we want to make some gardens full, we should choose those with more planted flowers to \"fulfill\".\\n\\nAssume that we want to get scores by making the largest `k` gardens full, while the rest `n-k` gardens have a max-min value of `flowers`. We need to sum up all missing values of the largest `k` flowers `sum[(max(0,target-flower) for flower in flowers[:-k]]`, which can be optimized by a \"reversed\" prefix sum array (for *prefix sum*, see [LC 303](https://leetcode.com/problems/range-sum-query-immutable/)) in a O(n) time. Here, I use `lack[k]` to accumulate the total flowers required to make the largest `k` `flower` full. (**Note**: In some corner cases, all gardens are already full before planting new flowers, as we can\\'t remove any planted flowers. Thus, we should start `k` with the min one that lets `lack[i]`>0 to avoid handling some full gardens as *incomplete* ones.)\\n\\nAfter fulfilling `k` gardens, the rest `n-k` gardens can be planted with **at most** `newFlowers-lack[k]` flowers. We\\'re just curious about what is the max min value when adding `newFlowers-lack[k]` to `flowers[:n-k]`. This question satisfies the property of *binary-search* with a lower bound as `flowers[0]` (the origin min value) and an upper bound as `target` (**Note**: *In fact, after adding all  `newFlowers-lack[k]`, the min value of  `flowers[:n-k]` may >= `target`. However, we don\\'t want to account for this case here because it will be considered later when we increase `k` to `n`, so the upper bound is limited to `target-1` inclusively*), so the score from the remaining `n-k` incomplete gardens can be obtained in `O(log(target)*cost(condition))`, in which `cost(condition)` denotes the time cost to check if the current min-value `flower` can be achieved by adding  `newFlowers-lack[k]` flowers.\\n \\nTraditionally, finding the max-min value of an array after adding some numbers is a typical **load balancer problem**, which is similar to Q3 this week and the first challenge problem hosted by Amazon Last Mile Delivery last week. But the traditional linear way to calculate the max-min value is of time complexity in `O(n)` even with the auxiliary of the pre-sum array, which leads to a TLE in the contest. To reduce the runtime, we just need to check if a min `flower` can be achieved after adding `f` new flowers to the first `k` gardens *optimally*, here I use `fill(flower, f, k)` as a conditional checker to determine if it is feasible to all first `k` gardens are of >= `flower` flowers. Given the `fill` function, we can quickly apply the [binary search template](https://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template-solved-many-problems) to finish the skeleton of getting the actual max-min of `flower[:k]`.\\n\\nNow, let\\'s look into `fill(flower, f, k)`: we check how many elements < `flower` there by binary-search as well,  we call it `m`. Then, we try to make up the total diff values between those elements and our required `flower`, so we just need to check if the sum of the first `m` elements >= `m*flower` after adding `m` to the left-hand of the inequity, which can be easily solved when we have already known the sum of first `m` elements by pre-sum array, so  `fill(flower, f, k)` is called in `O(log(n))`, which is the complexity of `cost(condition)` .\\n\\nFinally, we traverse the `flowers` linearly to consider `k` garden full and `n-k` gardens incomplete, the total score is `k*full + flower*partial`, in which `flower` is the max-min value of the `n-k` incomplete gardens, which is calculated by the binary search method above in `O(log(target)*log(n))`, along with a space complexity `O(n)`. (`n` = `len(flowers)`)\\n\\n\\n```py\\nimport bisect\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        # corner case in which no incomplete garden can be created. \\n        if flowers[0] >= target:\\n            return n*full\\n        \\n        # pre-sum in an ascending order\\n        for i in flowers:\\n            pre.append(pre[-1]+i)\\n        \\n        # pre-sum in a descending order, meanwhile, count how many gardens are already full\\n        cnt = 0\\n        for i in flowers[::-1]:\\n            if i >= target:\\n                cnt+=1\\n            lack.append(lack[-1]+max(target-i,0))\\n        \\n        # conditional checker: whether all first k elements can >= flower after adding f to them\\n        def fill(flower,f,k):\\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\\n            return pre[i] + f >= i*flower\\n            \\n        res = 0\\n        # start from the min number of full gardens\\n        for k in range(cnt,n):\\n            if lack[k] < newFlowers:\\n                left, right = flowers[0], target+1\\n                while left < right:\\n                    mid = (left+right)//2\\n                    if not fill(mid,newFlowers-lack[k],n-k):\\n                        right = mid\\n                    else:\\n                        left = mid + 1\\n                left -= 1\\n                \\n                if left >= target:\\n                    # the n-k gardens must be incomplete, which can have a max value as target-1\\n                    \\n                    res = max(res,(target-1)*partial+k*full)\\n                else:\\n                    res = max(res,k*full+left*partial)\\n        \\n        # A corner case: All n gardens can be full, no incomplete gardens\\n        if lack[-1] <= newFlowers:\\n            res = max(res,n*full)\\n        return res\\n        \\n            \\n```\\nI know it looks ugly, but anyway, it is accepted.\\n\\n**Update**: credit to [@ithachien](https://leetcode.com/ithachien/) (see the comment below), I realize that in the last corner case (all gardens can be fulfilled) we don\\'t have to do binary search to find out the max-min value of the first `n-k` gardens. It must be able to reach the largest min value as `target-1` because the remaining flowers are always sufficient, so I added the \"short-circuitting\" case before the loop as:\\n\\n```py\\nres = 0\\nif lack[-1] <= newFlowers:\\n    res = max(res,n*full)\\n    for k in range(cnt,n):\\n        res = max(res,(target-1)*partial+k*full)\\n    return res\\n```\\n\\nBesides, the lower bound of the max-min value for the first `n-k` garden after planting the remaining flowers can be further increased to `(newFlowers-lack[k])//(n-k) + flowers[0]` as all flowers are evenly assigned to all `n-k` garden, which narrows down the search range.\\n\\nBased on the minor optimization above, my code turned out to be of a runtime in 2432 ms, and beats 100% Python3 submissions so far.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```py\\nimport bisect\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        # corner case in which no incomplete garden can be created. \\n        if flowers[0] >= target:\\n            return n*full\\n        \\n        # pre-sum in an ascending order\\n        for i in flowers:\\n            pre.append(pre[-1]+i)\\n        \\n        # pre-sum in a descending order, meanwhile, count how many gardens are already full\\n        cnt = 0\\n        for i in flowers[::-1]:\\n            if i >= target:\\n                cnt+=1\\n            lack.append(lack[-1]+max(target-i,0))\\n        \\n        # conditional checker: whether all first k elements can >= flower after adding f to them\\n        def fill(flower,f,k):\\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\\n            return pre[i] + f >= i*flower\\n            \\n        res = 0\\n        # start from the min number of full gardens\\n        for k in range(cnt,n):\\n            if lack[k] < newFlowers:\\n                left, right = flowers[0], target+1\\n                while left < right:\\n                    mid = (left+right)//2\\n                    if not fill(mid,newFlowers-lack[k],n-k):\\n                        right = mid\\n                    else:\\n                        left = mid + 1\\n                left -= 1\\n                \\n                if left >= target:\\n                    # the n-k gardens must be incomplete, which can have a max value as target-1\\n                    \\n                    res = max(res,(target-1)*partial+k*full)\\n                else:\\n                    res = max(res,k*full+left*partial)\\n        \\n        # A corner case: All n gardens can be full, no incomplete gardens\\n        if lack[-1] <= newFlowers:\\n            res = max(res,n*full)\\n        return res\\n        \\n            \\n```\n```py\\nres = 0\\nif lack[-1] <= newFlowers:\\n    res = max(res,n*full)\\n    for k in range(cnt,n):\\n        res = max(res,(target-1)*partial+k*full)\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931056,
                "title": "c-iterate-over-number-of-gardens-we-make-full-then-binary-search",
                "content": "Note that if we make `i` gardens full, then for the optimal solution, those gardens are the `i` biggest ones.\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int full_cnt = 0;\\n        for(int i = flowers.size() - 1; i >= 0; i--) {\\n            if(flowers[i] < target) break;\\n            full_cnt++;\\n        }\\n        int n = flowers.size() - full_cnt;\\n        if(n == 0) return (long long)full_cnt * (long long)full;\\n        \\n        vector<long long> fill_up(n, 0), fill_target(n, 0);\\n        \\n        // fill_up: flowers needed to get min of flowers to flowers[i]\\n        fill_up[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            fill_up[i] = (flowers[i] - flowers[i-1]) * (long long)i + fill_up[i-1];\\n        }\\n        // fill_target[i] fill flowers[i] to flowers[n-1] to target level\\n        fill_target[n-1] = (long long) target - flowers[n-1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            fill_target[i] = fill_target[i+1] + (long long)(target - flowers[i]); \\n        }\\n        long long ret = 0;\\n        for(int num_fill = 0; num_fill <= n; num_fill++) {\\n            long long m = 0;\\n            long long rm = newFlowers;\\n            if(num_fill != 0) {\\n                rm -= fill_target[n-num_fill];\\n            }\\n            if(rm < 0) break;\\n            if(num_fill != n) {\\n                auto ptr = upper_bound(fill_up.begin(), fill_up.end(), rm);\\n                // can get min to flowers[idx-1] level, but not flowers[idx] level\\n                int idx = ptr - fill_up.begin();\\n                if(idx >= n - num_fill) idx = n - num_fill;\\n                m = flowers[idx - 1];\\n                m += (rm - fill_up[idx - 1]) / idx; \\n                m = min(m, (long long)target - 1);\\n            }\\n            long long tmp = m * (long long) partial + (full_cnt + num_fill) * (long long) full;\\n            ret = max(tmp, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int full_cnt = 0;\\n        for(int i = flowers.size() - 1; i >= 0; i--) {\\n            if(flowers[i] < target) break;\\n            full_cnt++;\\n        }\\n        int n = flowers.size() - full_cnt;\\n        if(n == 0) return (long long)full_cnt * (long long)full;\\n        \\n        vector<long long> fill_up(n, 0), fill_target(n, 0);\\n        \\n        // fill_up: flowers needed to get min of flowers to flowers[i]\\n        fill_up[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            fill_up[i] = (flowers[i] - flowers[i-1]) * (long long)i + fill_up[i-1];\\n        }\\n        // fill_target[i] fill flowers[i] to flowers[n-1] to target level\\n        fill_target[n-1] = (long long) target - flowers[n-1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            fill_target[i] = fill_target[i+1] + (long long)(target - flowers[i]); \\n        }\\n        long long ret = 0;\\n        for(int num_fill = 0; num_fill <= n; num_fill++) {\\n            long long m = 0;\\n            long long rm = newFlowers;\\n            if(num_fill != 0) {\\n                rm -= fill_target[n-num_fill];\\n            }\\n            if(rm < 0) break;\\n            if(num_fill != n) {\\n                auto ptr = upper_bound(fill_up.begin(), fill_up.end(), rm);\\n                // can get min to flowers[idx-1] level, but not flowers[idx] level\\n                int idx = ptr - fill_up.begin();\\n                if(idx >= n - num_fill) idx = n - num_fill;\\n                m = flowers[idx - 1];\\n                m += (rm - fill_up[idx - 1]) / idx; \\n                m = min(m, (long long)target - 1);\\n            }\\n            long long tmp = m * (long long) partial + (full_cnt + num_fill) * (long long) full;\\n            ret = max(tmp, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553928,
                "title": "c-prefix-sum-binary-search-easy-solution-clean-code",
                "content": "First of all, we would need to find the minimum and maximum number of complete gardens that can be formed using ```newFlowers``` . This can be easily done using sorting.\\n\\nThe most important to thing to figure out in this problem is the minimum number of flowers present in a garden, if ```x``` gardens are already complete after using some (if not all) ```newFlowers```. We will then iterate from ```minComplete``` garden to ```maxComplete``` garden, and keep track of the maximum answer.\\n\\nNow to find minimum number of flowers present for ```x``` complete gardens, we need to store the prefix difference array. What is the motivation? See, we have to maximise the minimum value of flowers for every garden. So we start increasing from the smallest to the next largest. For that, we will need the difference times the number of elements we have to increase.\\n\\nFor example, suppose for the ```flowers = [2, 5, 6, 11, 13]``` if we want to have minimum value to be 5 we need at least ```5 - 2 = 3``` flowers. Now, if we need 6 minimum value, then we need ```(6 - 5) * 2 + 3 = 4``` flowers. This was the pattern. Also, make sure that this value that you increment doesn\\'t make it equal to target.\\n\\nLastly, we will be having some ```newFlowers```, we find the least value for which it is possible, and then we may have some remaining flowers, we can then check for remaining group whether it is possible to increase that minimum value or not. \\n\\nLook at the code for better understanding.\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int tot = flowers.size();\\n        long long maxBeauty = 0ll;\\n        int maxComplete = 0, minComplete = 0;\\n        sort(flowers.begin(), flowers.end());\\n        long long tempNewFlowers = newFlowers;\\n        for (int i = tot - 1; i >= 0; i--) {\\n            if (flowers[i] >= target) {\\n                minComplete++;\\n                maxComplete++;\\n            }\\n            else if (target - flowers[i] <= tempNewFlowers) {\\n                maxComplete++;\\n                tempNewFlowers -= target - flowers[i];\\n            } else {\\n                break;\\n            }\\n        }\\n        flowers.push_back(target - 1);\\n        vector<long long> preDif(tot + 1, 0ll);\\n        for (int i = 1; i < tot; i++) {\\n            preDif[i] = (long long)(i * (flowers[i] - flowers[i - 1])) + preDif[i - 1];\\n        }\\n        int right = tot - 1;\\n        while(right >= 0 && flowers[right] >= target) {\\n            right--;\\n        }\\n        if (right >= 0) {\\n            flowers[right + 1] = target - 1;\\n            preDif[right + 1] = preDif[right] + (long long) (right + 1) * (long long)(flowers[right + 1] - flowers[right]);   \\n        }\\n        vector<long long> minFlower(maxComplete + 1);\\n        for (int complete = minComplete; complete <= maxComplete && right >= 0; complete++) {\\n            int pos = upper_bound(preDif.begin(), preDif.begin() + right + 1, newFlowers) - preDif.begin();\\n            pos--;\\n            minFlower[complete] = min((long long)target - 1, (long long)flowers[pos] + (long long)((newFlowers - preDif[pos]) / (pos + 1)));\\n            newFlowers -= (target - flowers[right]);\\n            right--;\\n            if (right >= 0) {\\n                flowers[right + 1] = target - 1;\\n                preDif[right + 1] = preDif[right] + (long long) (right + 1) * (long long)(flowers[right + 1] - flowers[right]);   \\n            }\\n        }\\n        for (int complete = minComplete; complete <= maxComplete; complete++) {\\n            maxBeauty = max(maxBeauty, (long long)complete * (long long)full + minFlower[complete] * (long long)partial);\\n        }\\n        return maxBeauty;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```newFlowers```\n```x```\n```newFlowers```\n```minComplete```\n```maxComplete```\n```x```\n```flowers = [2, 5, 6, 11, 13]```\n```5 - 2 = 3```\n```(6 - 5) * 2 + 3 = 4```\n```newFlowers```\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int tot = flowers.size();\\n        long long maxBeauty = 0ll;\\n        int maxComplete = 0, minComplete = 0;\\n        sort(flowers.begin(), flowers.end());\\n        long long tempNewFlowers = newFlowers;\\n        for (int i = tot - 1; i >= 0; i--) {\\n            if (flowers[i] >= target) {\\n                minComplete++;\\n                maxComplete++;\\n            }\\n            else if (target - flowers[i] <= tempNewFlowers) {\\n                maxComplete++;\\n                tempNewFlowers -= target - flowers[i];\\n            } else {\\n                break;\\n            }\\n        }\\n        flowers.push_back(target - 1);\\n        vector<long long> preDif(tot + 1, 0ll);\\n        for (int i = 1; i < tot; i++) {\\n            preDif[i] = (long long)(i * (flowers[i] - flowers[i - 1])) + preDif[i - 1];\\n        }\\n        int right = tot - 1;\\n        while(right >= 0 && flowers[right] >= target) {\\n            right--;\\n        }\\n        if (right >= 0) {\\n            flowers[right + 1] = target - 1;\\n            preDif[right + 1] = preDif[right] + (long long) (right + 1) * (long long)(flowers[right + 1] - flowers[right]);   \\n        }\\n        vector<long long> minFlower(maxComplete + 1);\\n        for (int complete = minComplete; complete <= maxComplete && right >= 0; complete++) {\\n            int pos = upper_bound(preDif.begin(), preDif.begin() + right + 1, newFlowers) - preDif.begin();\\n            pos--;\\n            minFlower[complete] = min((long long)target - 1, (long long)flowers[pos] + (long long)((newFlowers - preDif[pos]) / (pos + 1)));\\n            newFlowers -= (target - flowers[right]);\\n            right--;\\n            if (right >= 0) {\\n                flowers[right + 1] = target - 1;\\n                preDif[right + 1] = preDif[right] + (long long) (right + 1) * (long long)(flowers[right + 1] - flowers[right]);   \\n            }\\n        }\\n        for (int complete = minComplete; complete <= maxComplete; complete++) {\\n            maxBeauty = max(maxBeauty, (long long)complete * (long long)full + minFlower[complete] * (long long)partial);\\n        }\\n        return maxBeauty;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932287,
                "title": "o-n-sliding-window",
                "content": "```python\\nclass Solution:\\n    def maximumBeauty(self, A: List[int], to_add: int, target: int, full: int, partial: int) -> int:\\n        N = len(A)\\n        A.sort()\\n        P = list(accumulate(A, initial=0))\\n        \\n        ans = 0\\n        j = N - 1\\n        for k in range(N + 1):\\n            j = min(j, N - k - 1)\\n            while j >= 0:\\n                h = (P[j + 1] + to_add) // (j + 1)\\n                if h < A[j] and j >= 0:\\n                    j -= 1\\n                else:\\n                    break\\n\\n            cand = k * full\\n            if j >= 0 and A[j] < target:\\n                cand += min(h, target - 1) * partial\\n            ans = max(ans, cand)\\n            \\n            if k == N:\\n                break\\n            if (delta := target - A[~k]) > 0:\\n                to_add -= delta\\n            if to_add < 0:\\n                break\\n        \\n        return ans\\n```\\n\\nSort `A`.  You should take `k` plants and make them a height of `target`, and then try to improve the remaining `A[..j]` of them to be the best height possible.\\n\\nSince `j` is monotone decreasing as `k` increases, we can slide `j` down.  In the while loop `j >= 0`, we search for the largest `j` such that we can make `A[..j]` atleast the height `h` of `A[j]`.\\n\\nNow we have a candidate answer: `k` completed plants, plus a height of `h` for the partial.  There is a corner case where the height `h` as well as `A[j]` must be less than `target` for it to count.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumBeauty(self, A: List[int], to_add: int, target: int, full: int, partial: int) -> int:\\n        N = len(A)\\n        A.sort()\\n        P = list(accumulate(A, initial=0))\\n        \\n        ans = 0\\n        j = N - 1\\n        for k in range(N + 1):\\n            j = min(j, N - k - 1)\\n            while j >= 0:\\n                h = (P[j + 1] + to_add) // (j + 1)\\n                if h < A[j] and j >= 0:\\n                    j -= 1\\n                else:\\n                    break\\n\\n            cand = k * full\\n            if j >= 0 and A[j] < target:\\n                cand += min(h, target - 1) * partial\\n            ans = max(ans, cand)\\n            \\n            if k == N:\\n                break\\n            if (delta := target - A[~k]) > 0:\\n                to_add -= delta\\n            if to_add < 0:\\n                break\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931754,
                "title": "c-solution-dp-binary-search-prefix-sums-explained-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        long long ans = 0;\\n        int n = flowers.size();\\n        if(n == 0) return 0;\\n        sort(flowers.begin(), flowers.end());\\n        vector<long long> pref(n, 0); // Prefix sums array\\n        pref[0] = flowers[0];\\n        for(int i = 1; i < n; i++) {\\n            pref[i] = pref[i - 1] + flowers[i];\\n        }\\n        for(int i = n; i >= 0; i--) {\\n            // When i is n, none of the elements are incremented till target.\\n            if(i < n) { // The ith element(0-indexed) is incremented till target. This is handling the case of \"full\". We are doing this from the end because it will cost the least number of new Flowers.\\n                long long toAdd = max(0, target - flowers[i]);\\n                if(newFlowers < toAdd) {\\n                    break; // We are breaking because we would\\'ve already found the best answer in the previous iterations\\n                }\\n                newFlowers -= toAdd;\\n                flowers.pop_back();\\n            }\\n            long long beautyForFullCase = (long long)(n - i) * full; // All the elements from i to n -1 are incremented till target, so they have a beauty of (n - 1) * full\\n            \\n            // Here, we do binary search on x, which is the the maximum number we can increment all the numbers from 0 to i - 1 to. The maximum we can increment to is target-1 because after that, \"partial\" will not be applicable. Binary search is done to find out the maximum possible answer for the partial case.\\n            int l = 0, r = target - 1;\\n            long long beautyForPartialCase = 0;\\n            while(l <= r) {\\n                long long mid = l + (r - l) / 2; // mid is the maximum number we can increment to\\n                auto it = upper_bound(flowers.begin(), flowers.end(), mid); // will point to an element that is atleast 1 more than the incomplete garden with most number of flowers\\n                if(it == flowers.begin()) { // there are no incomplete gardens\\n                    l = mid + 1;\\n                } else {\\n                    long long len = distance(flowers.begin(), it); // number of incomplete gardens\\n                    long long sum = pref[len - 1];\\n                    long long needed = ((long long)mid * len) - sum; // number of flowers needed to make \"mid\" as the minimum element\\n                    if(needed <= newFlowers) { // if it is possible to plant flowers such that the minimum number of flowers for any garden is \"mid\", then we go to check for higher values through Binary search\\n                        l = mid + 1;\\n                        beautyForPartialCase = (long long)mid * partial; // (minimum number of flowers in any incomplete garden) * (partial) = total beauty of incomplete gardens\\n                    } else {\\n                        r = mid - 1;\\n                    }\\n                }\\n            }\\n            ans = max(ans, beautyForFullCase + beautyForPartialCase); // checking if this answer is better than the previous answers computed.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        long long ans = 0;\\n        int n = flowers.size();\\n        if(n == 0) return 0;\\n        sort(flowers.begin(), flowers.end());\\n        vector<long long> pref(n, 0); // Prefix sums array\\n        pref[0] = flowers[0];\\n        for(int i = 1; i < n; i++) {\\n            pref[i] = pref[i - 1] + flowers[i];\\n        }\\n        for(int i = n; i >= 0; i--) {\\n            // When i is n, none of the elements are incremented till target.\\n            if(i < n) { // The ith element(0-indexed) is incremented till target. This is handling the case of \"full\". We are doing this from the end because it will cost the least number of new Flowers.\\n                long long toAdd = max(0, target - flowers[i]);\\n                if(newFlowers < toAdd) {\\n                    break; // We are breaking because we would\\'ve already found the best answer in the previous iterations\\n                }\\n                newFlowers -= toAdd;\\n                flowers.pop_back();\\n            }\\n            long long beautyForFullCase = (long long)(n - i) * full; // All the elements from i to n -1 are incremented till target, so they have a beauty of (n - 1) * full\\n            \\n            // Here, we do binary search on x, which is the the maximum number we can increment all the numbers from 0 to i - 1 to. The maximum we can increment to is target-1 because after that, \"partial\" will not be applicable. Binary search is done to find out the maximum possible answer for the partial case.\\n            int l = 0, r = target - 1;\\n            long long beautyForPartialCase = 0;\\n            while(l <= r) {\\n                long long mid = l + (r - l) / 2; // mid is the maximum number we can increment to\\n                auto it = upper_bound(flowers.begin(), flowers.end(), mid); // will point to an element that is atleast 1 more than the incomplete garden with most number of flowers\\n                if(it == flowers.begin()) { // there are no incomplete gardens\\n                    l = mid + 1;\\n                } else {\\n                    long long len = distance(flowers.begin(), it); // number of incomplete gardens\\n                    long long sum = pref[len - 1];\\n                    long long needed = ((long long)mid * len) - sum; // number of flowers needed to make \"mid\" as the minimum element\\n                    if(needed <= newFlowers) { // if it is possible to plant flowers such that the minimum number of flowers for any garden is \"mid\", then we go to check for higher values through Binary search\\n                        l = mid + 1;\\n                        beautyForPartialCase = (long long)mid * partial; // (minimum number of flowers in any incomplete garden) * (partial) = total beauty of incomplete gardens\\n                    } else {\\n                        r = mid - 1;\\n                    }\\n                }\\n            }\\n            ans = max(ans, beautyForFullCase + beautyForPartialCase); // checking if this answer is better than the previous answers computed.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931410,
                "title": "python-o-nlogn-dp-and-binary-search",
                "content": "The idea is that after sorting the flowers array from low to high, in the optimal result, the full/compete gardens must be on the right side, while partial gardens are on the left. Otherwise, we are wasting some newFlowers thus the result can\\'t be optimal.\\n\\nSo we just need to check every index and do 2 things:\\n1) try to make the right part of current index all full, if not possible, simply continue to next index\\n2) after making the right part all full, we need to calculate what is the maximum value of min flowers in the left part we can make with remaing newFlowers.\\n\\nStep 1) above can be done with pre_sum array easily. Step 2) is more tricky.\\nThe algorithm I used is to keep an auxiliary dp array during iteration, which will store below information:\\n- at index j: dp[j] = (j+1) * flowers[j] - presum[j+1]\\n- essentially, the extra flowers needed to make every garden left of index j equal to flowers[j]\\n- this dp array is guaranteed to be increasing order\\n\\nSo in order to achieve Step 2), we will do a binary search on the dp array to get the rightmost j index possible with remaining newFlowers (rem_flowers), and every garden left of index j (including j) will be brought up to the same min_partial value which satisfies:\\n- min_partial * (j+1) - presum[j+1] <= rem_flowers\\n- min_partial <= target - 1\\n\\nThe rest is just update max_beauty with min_partial and total full/complete gardens\\n\\nOverall time complexity O(NlogN), space complexity O(N)\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        \\n\\t\\t# move out already completed garden\\n        already_complete = 0\\n        temp = []\\n        for f in flowers:\\n            if f >= target:\\n                already_complete += 1\\n            else:\\n                temp.append(f)\\n\\n        max_beauty = 0\\n        \\n        flowers = temp\\n        flowers.sort()\\n        \\n        presum = [0] + list(accumulate(flowers))\\n        N = len(flowers)\\n        \\n        dp_arr = []\\n        \\n        for i in range(N+1):\\n            # iterate all index: left part is all partial, right part (>= i) is all complete\\n            \\n            # update the dp arr for binary search below\\n            if i < N:\\n                dp_arr.append((i+1) * flowers[i] - presum[i+1])\\n            \\n            right_sum = presum[-1] - presum[i]\\n            right_count = N - i\\n            \\n            # if can\\'t make the right part all complete, go to next index\\n            if right_sum + newFlowers < right_count * target:\\n                continue\\n            \\n            # remaining flowers after making right part all complete\\n            rem_flowers = newFlowers - (right_count * target - right_sum)\\n            \\n            # binary search to find the maximum possible min flowers in the left part (named \\'min_partial\\')\\n            if i == 0:\\n                min_partial = 0\\n            else:\\n                j = min(bisect.bisect_right(dp_arr, rem_flowers) - 1, i-1)\\n                min_partial = min((rem_flowers + presum[j+1]) // (j+1), target-1)\\n                 \\n            complete = right_count + already_complete\\n            max_beauty = max(max_beauty, complete * full + min_partial * partial)\\n\\n            \\n        return max_beauty\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        \\n\\t\\t# move out already completed garden\\n        already_complete = 0\\n        temp = []\\n        for f in flowers:\\n            if f >= target:\\n                already_complete += 1\\n            else:\\n                temp.append(f)\\n\\n        max_beauty = 0\\n        \\n        flowers = temp\\n        flowers.sort()\\n        \\n        presum = [0] + list(accumulate(flowers))\\n        N = len(flowers)\\n        \\n        dp_arr = []\\n        \\n        for i in range(N+1):\\n            # iterate all index: left part is all partial, right part (>= i) is all complete\\n            \\n            # update the dp arr for binary search below\\n            if i < N:\\n                dp_arr.append((i+1) * flowers[i] - presum[i+1])\\n            \\n            right_sum = presum[-1] - presum[i]\\n            right_count = N - i\\n            \\n            # if can\\'t make the right part all complete, go to next index\\n            if right_sum + newFlowers < right_count * target:\\n                continue\\n            \\n            # remaining flowers after making right part all complete\\n            rem_flowers = newFlowers - (right_count * target - right_sum)\\n            \\n            # binary search to find the maximum possible min flowers in the left part (named \\'min_partial\\')\\n            if i == 0:\\n                min_partial = 0\\n            else:\\n                j = min(bisect.bisect_right(dp_arr, rem_flowers) - 1, i-1)\\n                min_partial = min((rem_flowers + presum[j+1]) // (j+1), target-1)\\n                 \\n            complete = right_count + already_complete\\n            max_beauty = max(max_beauty, complete * full + min_partial * partial)\\n\\n            \\n        return max_beauty\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030980,
                "title": "binary-search-with-upper-bound-function",
                "content": "\\n* The first thing that striked my mind was binary search infact but not in a very good way. \\n* I noticed that our N gardens will be made of x complete + N-x incomplete gardens , where 0 <= x <= N. \\n* Now lets think greedily , to make x gardens complete which gardens should I choose. The answer is x largest garden. \\n> eg : 5 4 1 2 , target = 5 , newFlowers = 7 \\nNow to make 3 gardens complete , we choose 5 , 4 , 2\\nIncreasing 4 -> 5 and 2 -> 5 resulting in usage of 4 newFlowers. \\nAnd we have 3 more flowers left. \\nThis is the optimal way of choosing because any other way will result in less number of flowers remaining. \\nSo we sort the array in reverse so that we always choose i largest gardens. \\n\\n* Now the question arises that how will we calculate the number of flowers needed for completing x gardens. \\n>eg : Consider the above example : 5 4 2 1 , \\nThe sum of first 3 numbers is 11 and we want to make 3 gardens complete so we require 3 * target = 15 flowers but we already have 11 so requires 4 more. \\nrequire[i] = i * target - prefixSum[i]. \\nAn edge case what if the flower array was  : 6 4 2 1 \\nApplying the same logic we get 15 - 12 = 3 , but on actual check we require 4. \\nThe problem is 6 because it is greater then target. \\nSo will be incrementing our sum as : \\n(pfSum[i] = pfSum[i-1] + min(flower[i] ,target)); \\n\\n* Now looking for the incomplete gardens we observe that for the remaing gardens we need to obtain the maximum minima. Also we observe that an incomplete garden will always contain flowers less then target giving us the upper bound of having atmost target - 1 flower in an incomplete garden.\\n> eg : 1 2 3 4 , target = 6 \\nRight now the min is 1 using 0 newFlowers\\nSuppose we choose our min as 2 so we need to increase the flower in 1st garden so : 2 2 3 4  , min = 2 , flowerUsed = 1\\nChoose min as 3 so : 3 3 3 4 , min : 3 , flowerUsed = 3 \\nChoose min as 4 so : 4 4 4 4 , min : 4 , flowerUsed = 6 \\nChoose min as 5 so : 5 5 5 5 , min : 5 , flowerUsed = 10 \\nThis is the most optimal case where all the incomplete gardens contains max flowers. we just need to make sure that flowersUsed <= newFlowers(left after planting the complete gardens). \\n\\n* But we cant simply iterate over the options to choose min instead we can apply binary search here. We need to find that number for which flowerUsed is largest and flowerUsed <= newFlower. \\n> eg : 1 2 3 4 \\nfor 1 we need 0 \\nfor 2 we need 0 + 1*(2-1) = 1\\nfor 3 we need 1 + 2*(3 - 2) = 3 \\nfor 4 we need 3 + 3*(4 - 3)  =6 \\nusedFlower[i] = usedFlower[i-1] + i * (flower[i] - flower[i-1])\\nSo suppose we have 4 newFlowers left \\nwe apply upper bound for 4 on [0 , 1 , 3 , 6] and we get index 3. \\nSubtract 1 from it and you get 3 which corresponds to choosing min as 3. \\nBut suppose we have newFlowers as 10 \\nupperBound will give 4 and we subtract 1 and get 3. \\nNow 10 - 6 = 4 and the array becomes 4 4 4 4 and we have 4 more left which will be distributed amongst the 4. \\n\\nHere comes the code :\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flower, long long newFlowers, int target, int full, int partial) {\\n        int n = flower.size();\\n        sort(flower.begin(),flower.end());\\n\\t\\t\\n\\t\\t// This r is for storing the flower that will be used \\n        vector<long long>r; \\n        r.push_back(0); \\n        for(int i = 1 ; i < n ; i++){\\n            long long cur = r.back() + i*(flower[i] - flower[i-1]); \\n            r.push_back(cur);\\n        }\\n        reverse(flower.begin(),flower.end());\\n        long long ans = 0 ;\\n        long long sum = 0 ; \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            //i : complete , n-i : incomplete \\n            long long k = newFlowers ; \\n            long long req = 1ll * i*target - sum ; \\n            if(k < req) break ;\\n            sum += min(flower[i], target); \\n            k -= max(0ll , req) ; \\n        \\n            long long int cur = 1ll * i * full ; \\n            if(flower[i] >= target){\\n                ans = max(ans , cur) ;\\n                r.pop_back(); \\n                continue ; \\n            }\\n\\t\\t\\t\\n            auto I = upper_bound(r.begin(),r.end(),k)-r.begin(); \\n            I = I - 1; \\n            \\n            k -= r[I]; \\n            long long Min = flower[n - I - 1] ; \\n            long long inc = k/(I+1); \\n            Min = min(Min+inc , 1ll * target-1) ; \\n\\t\\t\\t\\n            cur += Min * partial ; \\n\\t\\t\\t\\n            ans = max(ans , cur) ;\\n\\t\\t\\t\\n\\t\\t\\t//popping because next time we will have 1 complete garden more \\n            r.pop_back(); \\n            \\n        }\\n        \\n        if((1ll * n*target - sum) < newFlowers){\\n            ans = max(ans ,1ll * n *full); \\n        }\\n        return ans ;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flower, long long newFlowers, int target, int full, int partial) {\\n        int n = flower.size();\\n        sort(flower.begin(),flower.end());\\n\\t\\t\\n\\t\\t// This r is for storing the flower that will be used \\n        vector<long long>r; \\n        r.push_back(0); \\n        for(int i = 1 ; i < n ; i++){\\n            long long cur = r.back() + i*(flower[i] - flower[i-1]); \\n            r.push_back(cur);\\n        }\\n        reverse(flower.begin(),flower.end());\\n        long long ans = 0 ;\\n        long long sum = 0 ; \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            //i : complete , n-i : incomplete \\n            long long k = newFlowers ; \\n            long long req = 1ll * i*target - sum ; \\n            if(k < req) break ;\\n            sum += min(flower[i], target); \\n            k -= max(0ll , req) ; \\n        \\n            long long int cur = 1ll * i * full ; \\n            if(flower[i] >= target){\\n                ans = max(ans , cur) ;\\n                r.pop_back(); \\n                continue ; \\n            }\\n\\t\\t\\t\\n            auto I = upper_bound(r.begin(),r.end(),k)-r.begin(); \\n            I = I - 1; \\n            \\n            k -= r[I]; \\n            long long Min = flower[n - I - 1] ; \\n            long long inc = k/(I+1); \\n            Min = min(Min+inc , 1ll * target-1) ; \\n\\t\\t\\t\\n            cur += Min * partial ; \\n\\t\\t\\t\\n            ans = max(ans , cur) ;\\n\\t\\t\\t\\n\\t\\t\\t//popping because next time we will have 1 complete garden more \\n            r.pop_back(); \\n            \\n        }\\n        \\n        if((1ll * n*target - sum) < newFlowers){\\n            ans = max(ans ,1ll * n *full); \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932731,
                "title": "java-sort-prefix-sum-preprocessing-and-scan-o-nlogn-solution-45ms-beats-100",
                "content": "**Ituition**\\n* We want to add complete garden gradually and try to maximize the minimum number of the incomplete gardens.\\n* Apparently sort can help achieve the goal.\\n* For the complete garden, we can try to increase the number of complete gardens from the end of the array. In this way, we can use the minimum number of flowers to do it.\\n* To maximize the minimum number of incomplete garden, we can maintain another pointer to test if it can be the mimumum value after we plant the remaining flowers.\\n* If it can be the minimum value, it means all the other values appears before it must have the same value. If we have a prefix sum array, we can calculate if it\\'s doable quickly.\\n* As the remaining flowers will keep decreasing, the pointer we used must move to the left side accordingly. Hence, we can have O(N) search solution here.\\n* We also need to handle the case - when we make up the minimum value, we may still have some flowers left and we should try to use all of them.\\n* Overall time complexity is O(NLogN) as (1) Sorting O(NLogN) (2) prefix sum O(N) (3) Two pointer search O(N)\\n\\n```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }\\n            res = Math.max(res, c * (long) full + min * (long) partial);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }\\n            res = Math.max(res, c * (long) full + min * (long) partial);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981158,
                "title": "one-easy-step-forward-from-binary-search-to-two-pointers",
                "content": "During the contest, I solved this problem with binary search. And now, there\\'re a lot of binary-search solutions with detailed explanation and diagrams. \\n\\n**Before reading this post, you need to first read and understand: https://leetcode.com/poblems/maximum-total-beauty-of-the-gardens/discuss/1931085/Python-Explanation-with-pictures-Greedy (or any other posts about binary-search solutions) as I\\'m not going to explain the binary-search solution here.**\\n\\nIf you follow the aforementioned post, you may write your own version of binary search like mine:\\n\\n```c++\\n// Binary Search \\n// Time: O(nlogn)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        const long long n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        std::vector<long long> costs(n, 0);\\n        // special case 1: all gardens are already complete\\n        if(flowers[0] >= target){\\n            return full * n;\\n        }\\n        flowers[0] = std::min(flowers[0], target); // cap it\\n        long long last_partial = 0;\\n        for(long long i = 1; i < n; ++i){\\n            if(flowers[i] >= target){\\n                flowers[i] = target;\\n            } else{\\n                last_partial = i;\\n            }\\n            costs[i] = costs[i - 1] + (flowers[i] - flowers[i - 1]) * i;\\n        }\\n        // special case 2: all gardens can be complete\\n        if(costs.back() + n * (target - flowers.back()) <= newFlowers){\\n            return std::max(full * n, full * (n - 1) + partial * static_cast<long long>(target - 1));\\n        }\\n        long long res = 0;\\n        for(auto first_complete = last_partial + 1; first_complete >= 0; --first_complete){\\n            newFlowers -= first_complete == n ? 0 : (target - flowers[first_complete]);\\n            if(newFlowers < 0){\\n                break;\\n            }\\n            // try to fill the first [0, first_complete) gardens to their maximum partial \\n            const auto it = std::upper_bound(costs.begin(), costs.begin() + first_complete, newFlowers);\\n            const auto extra = (newFlowers - *(it - 1)) / (it - costs.begin());\\n            res = std::max(res, full * (n - first_complete) + partial * (extra + flowers[it - costs.begin() - 1]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\nWell, this is neat, and efficient enough with `O(nlogn)` complexity. And I would say this suffices for you to ace the Leetcode contest and any techinical interviews.\\n\\nBut wait a minute, just like me, you come across some other posts about two-pointer solutions and you want to optimize your code further! Unfortunately, as for now, these top posts about two-pointers solutions are not well written (in my opinion), and you don\\'t want to spend a whole lot of time reading and understanding their pieces of code.\\n\\nDon\\'t fret, from binary search to two pointers, there\\'s only a very small step forward. And that\\'s exactly what I\\'m going to write about.\\n\\nFirst, let\\'s take a look at the code (or the binary-search solution) above, and you may have already noticed:\\n\\n**When we iterate over `first_complete` and then do the binary search to find the maximal `it` for each `first_complete`, as `first_complete` decreases, `it` can never increase as `newFlowers` always decrease.** \\n\\n```c++\\nconst auto it = std::upper_bound(costs.begin(), costs.begin() + first_complete, newFlowers);\\n```\\n\\nThis is because as we make more gardens complete, we have fewer new flowers to optimize the first several incomplete gardens. Quite intutive.\\n\\nThen, to utilize this observation, instead of doing binary search each time, we may simply use another variable `best_effort` to **remember** the last position of `it` and decrement it all the time, which is the second pointer we need! (The first pointer is `first_complete` of course.) \\n\\nTherefore, with this key observation, to make the step forward from binary search to two pointers, you don\\'t need to make much modification to your code at all! And for your reference, you can see that most of my code is **the same**:\\n\\n```c++\\n// Sort + Two Pointers\\n// Time: O(nlogn)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        const long long n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        std::vector<long long> costs(n, 0);\\n        // special case 1: all gardens are already complete\\n        if(flowers[0] >= target){\\n            return full * n;\\n        }\\n        flowers[0] = std::min(flowers[0], target); // cap it\\n        long long last_partial = 0;\\n        for(long long i = 1; i < n; ++i){\\n            if(flowers[i] >= target){\\n                flowers[i] = target;\\n            } else{\\n                last_partial = i;\\n            }\\n            costs[i] = costs[i - 1] + (flowers[i] - flowers[i - 1]) * i;\\n        }\\n        // special case 2: all gardens can be complete\\n        if(costs.back() + n * (target - flowers.back()) <= newFlowers){\\n            return std::max(full * n, full * (n - 1) + partial * static_cast<long long>(target - 1));\\n        }\\n        long long res = 0;\\n\\t\\t// --- ALL code above is the same as the binary-search solution --- //\\n        for(auto first_complete = last_partial + 1, best_effort = last_partial; first_complete >= 0; --first_complete){\\n            newFlowers -= first_complete == n ? 0 : (target - flowers[first_complete]);\\n            if(newFlowers < 0){\\n                break;\\n            }\\n            best_effort = std::min(best_effort, first_complete - 1);\\n            // try to fill the first [0, first_complete) gardens to their maximum partial \\n\\t\\t\\t// -> instead of binary search, we use another pointer here\\n            while(best_effort >= 0 && costs[best_effort] > newFlowers){\\n                --best_effort;\\n            }\\n            // we can only maximize [0, best_effort] gardens\\n            const auto extra = (newFlowers - costs[best_effort]) / (best_effort + 1);\\n            res = std::max(res, full * (n - first_complete) + partial * (extra + flowers[best_effort]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```c++\\n// Binary Search \\n// Time: O(nlogn)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        const long long n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        std::vector<long long> costs(n, 0);\\n        // special case 1: all gardens are already complete\\n        if(flowers[0] >= target){\\n            return full * n;\\n        }\\n        flowers[0] = std::min(flowers[0], target); // cap it\\n        long long last_partial = 0;\\n        for(long long i = 1; i < n; ++i){\\n            if(flowers[i] >= target){\\n                flowers[i] = target;\\n            } else{\\n                last_partial = i;\\n            }\\n            costs[i] = costs[i - 1] + (flowers[i] - flowers[i - 1]) * i;\\n        }\\n        // special case 2: all gardens can be complete\\n        if(costs.back() + n * (target - flowers.back()) <= newFlowers){\\n            return std::max(full * n, full * (n - 1) + partial * static_cast<long long>(target - 1));\\n        }\\n        long long res = 0;\\n        for(auto first_complete = last_partial + 1; first_complete >= 0; --first_complete){\\n            newFlowers -= first_complete == n ? 0 : (target - flowers[first_complete]);\\n            if(newFlowers < 0){\\n                break;\\n            }\\n            // try to fill the first [0, first_complete) gardens to their maximum partial \\n            const auto it = std::upper_bound(costs.begin(), costs.begin() + first_complete, newFlowers);\\n            const auto extra = (newFlowers - *(it - 1)) / (it - costs.begin());\\n            res = std::max(res, full * (n - first_complete) + partial * (extra + flowers[it - costs.begin() - 1]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\n```c++\\nconst auto it = std::upper_bound(costs.begin(), costs.begin() + first_complete, newFlowers);\\n```\n```c++\\n// Sort + Two Pointers\\n// Time: O(nlogn)\\n// Space: O(n)\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        const long long n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        std::vector<long long> costs(n, 0);\\n        // special case 1: all gardens are already complete\\n        if(flowers[0] >= target){\\n            return full * n;\\n        }\\n        flowers[0] = std::min(flowers[0], target); // cap it\\n        long long last_partial = 0;\\n        for(long long i = 1; i < n; ++i){\\n            if(flowers[i] >= target){\\n                flowers[i] = target;\\n            } else{\\n                last_partial = i;\\n            }\\n            costs[i] = costs[i - 1] + (flowers[i] - flowers[i - 1]) * i;\\n        }\\n        // special case 2: all gardens can be complete\\n        if(costs.back() + n * (target - flowers.back()) <= newFlowers){\\n            return std::max(full * n, full * (n - 1) + partial * static_cast<long long>(target - 1));\\n        }\\n        long long res = 0;\\n\\t\\t// --- ALL code above is the same as the binary-search solution --- //\\n        for(auto first_complete = last_partial + 1, best_effort = last_partial; first_complete >= 0; --first_complete){\\n            newFlowers -= first_complete == n ? 0 : (target - flowers[first_complete]);\\n            if(newFlowers < 0){\\n                break;\\n            }\\n            best_effort = std::min(best_effort, first_complete - 1);\\n            // try to fill the first [0, first_complete) gardens to their maximum partial \\n\\t\\t\\t// -> instead of binary search, we use another pointer here\\n            while(best_effort >= 0 && costs[best_effort] > newFlowers){\\n                --best_effort;\\n            }\\n            // we can only maximize [0, best_effort] gardens\\n            const auto extra = (newFlowers - costs[best_effort]) / (best_effort + 1);\\n            res = std::max(res, full * (n - first_complete) + partial * (extra + flowers[best_effort]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942700,
                "title": "java-n-log-n-solution-greedy-sorting-prefix-sum",
                "content": "```\\nclass Solution {\\n    \\n    //BST\\n    private long getMax(int index,long rem,long target,long prefix_sum[],long arr[]){\\n        int left=0,right=index,in=-1;\\n        while(right>=left){\\n            int mid=left+(right-left)/2;\\n            \\n            //For calculating the value which we will add\\n            long val=(arr[mid]*(mid+1)-prefix_sum[mid]);\\n            if(rem>=val){\\n                \\n                //getting the index\\n                in=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        \\n        // edge case-1 in==-1 return 0;\\n        // edge case-2 in!=-1 return Math.min((rem+prefix_sum[in])/(in+1),target-1); \\n        // because we ultimately want a number which is less than target\\n        return in==-1?0:(Math.min((rem+prefix_sum[in])/(in+1),target-1));\\n    }\\n    public long maximumBeauty(int[] fl, long t, long target, long full, long partial) {\\n        \\n        //Edge case for fl having length 1\\n        if(fl.length==1){\\n            if(fl[0]>=target)\\n                return full;\\n            long result=Math.min(target-1,fl[0]+t)*partial;\\n            if(fl[0]+t>=target)\\n                result=Math.max(result,full);\\n            return result;\\n        }\\n        \\n        //converting the array to long array\\n        long arr[]=new long[fl.length];\\n        for(int i=0;i<fl.length;i++)\\n            arr[i]=(long)fl[i];\\n        \\n        //Sort the array for applying BST\\n        Arrays.sort(arr);\\n        \\n        //for removing the greatest or equal to elements than target\\n        int i=arr.length-1;\\n        while(i>-1&&arr[i]>=target)\\n            i--;\\n        long mid_val=(arr.length-i-1)*full;\\n        if(i==-1)\\n            return mid_val;\\n        \\n        //for prefix sum\\n        long prefix_sum[]=new long[arr.length];\\n        prefix_sum[0]=arr[0];\\n        for(int j=1;j<arr.length;j++)\\n            prefix_sum[j]=prefix_sum[j-1]+arr[j];\\n        \\n        // The present length after the reduction of the greatest or equal elements target\\n        int len=i+1;\\n        \\n        //Edge case 1\\n        long result=getMax(len-1,t,target,prefix_sum,arr)*partial;\\n        \\n        //Edge case 2\\n        if(t-target*(len)+prefix_sum[len-1]>=0)\\n            result=Math.max(result,len*full);\\n        \\n        // initialize sum=0 for calculating the sum in whie loop\\n        long sum=0;\\n        \\n        while(i>0){\\n            sum+=arr[i];\\n            long v=t-target*(len-i)+sum;\\n            if(v<0)\\n                break;\\n            result=Math.max(result,getMax(i-1,v,target,prefix_sum,arr)*partial+full*(len-i));\\n            i--;\\n        }\\n        \\n        //Return the result as mid_val+result\\n        return result+mid_val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //BST\\n    private long getMax(int index,long rem,long target,long prefix_sum[],long arr[]){\\n        int left=0,right=index,in=-1;\\n        while(right>=left){\\n            int mid=left+(right-left)/2;\\n            \\n            //For calculating the value which we will add\\n            long val=(arr[mid]*(mid+1)-prefix_sum[mid]);\\n            if(rem>=val){\\n                \\n                //getting the index\\n                in=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        \\n        // edge case-1 in==-1 return 0;\\n        // edge case-2 in!=-1 return Math.min((rem+prefix_sum[in])/(in+1),target-1); \\n        // because we ultimately want a number which is less than target\\n        return in==-1?0:(Math.min((rem+prefix_sum[in])/(in+1),target-1));\\n    }\\n    public long maximumBeauty(int[] fl, long t, long target, long full, long partial) {\\n        \\n        //Edge case for fl having length 1\\n        if(fl.length==1){\\n            if(fl[0]>=target)\\n                return full;\\n            long result=Math.min(target-1,fl[0]+t)*partial;\\n            if(fl[0]+t>=target)\\n                result=Math.max(result,full);\\n            return result;\\n        }\\n        \\n        //converting the array to long array\\n        long arr[]=new long[fl.length];\\n        for(int i=0;i<fl.length;i++)\\n            arr[i]=(long)fl[i];\\n        \\n        //Sort the array for applying BST\\n        Arrays.sort(arr);\\n        \\n        //for removing the greatest or equal to elements than target\\n        int i=arr.length-1;\\n        while(i>-1&&arr[i]>=target)\\n            i--;\\n        long mid_val=(arr.length-i-1)*full;\\n        if(i==-1)\\n            return mid_val;\\n        \\n        //for prefix sum\\n        long prefix_sum[]=new long[arr.length];\\n        prefix_sum[0]=arr[0];\\n        for(int j=1;j<arr.length;j++)\\n            prefix_sum[j]=prefix_sum[j-1]+arr[j];\\n        \\n        // The present length after the reduction of the greatest or equal elements target\\n        int len=i+1;\\n        \\n        //Edge case 1\\n        long result=getMax(len-1,t,target,prefix_sum,arr)*partial;\\n        \\n        //Edge case 2\\n        if(t-target*(len)+prefix_sum[len-1]>=0)\\n            result=Math.max(result,len*full);\\n        \\n        // initialize sum=0 for calculating the sum in whie loop\\n        long sum=0;\\n        \\n        while(i>0){\\n            sum+=arr[i];\\n            long v=t-target*(len-i)+sum;\\n            if(v<0)\\n                break;\\n            result=Math.max(result,getMax(i-1,v,target,prefix_sum,arr)*partial+full*(len-i));\\n            i--;\\n        }\\n        \\n        //Return the result as mid_val+result\\n        return result+mid_val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977624,
                "title": "c-java-python-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***C++***\\n```\\nclass Solution \\n{\\n    public:\\n        long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \\n        {\\n            int n = flowers.size();\\n            sort(flowers.begin(), flowers.end());\\n            if(n == 0)\\n                return 0;\\n            \\n   \\n            vector<long long>pre(n + 1, 0);\\n            \\n            for(int i = 1; i <= n; i++)\\n                pre[i] = pre[i - 1] + (long long)flowers[i - 1];\\n            \\n            long long res = LLONG_MIN;\\n            \\n            for(int t = n; t >= 0; t--)\\n            {\\n               \\n                long long fullCost = 0;\\n                long long partialCost = 0;\\n                \\n            \\n                if(t < n)\\n                {\\n                    if(flowers[t] < target)\\n                    {\\n                        long long need = (long long)target - (long long)flowers[t];\\n                        \\n                   \\n                        if(need > newFlowers)\\n                            break;\\n                        newFlowers -= need;\\n                    }\\n                }\\n                \\n                fullCost  = (long long)(n - t) * full;\\n                \\n                int l = 0;\\n                int r = target - 1;\\n                \\n                while(l <= r)\\n                {\\n                    int mid = l + (r - l) / 2; \\n                    int idx = upper_bound(flowers.begin(), flowers.begin() + t, mid) - flowers.begin(); \\n                    \\n                    if(idx == 0)\\n                    {\\n                        l = mid + 1;\\n                    }\\n                    else\\n                    {\\n                      \\n                        long long needToPlant = ((long long)mid * (long long)idx - pre[idx]);\\n                        \\n                        if(needToPlant > newFlowers)\\n                            r = mid - 1;\\n                        else\\n                        {\\n                            l = mid + 1;\\n                            partialCost = (long long)mid * partial;\\n                        }\\n                    }\\n                }\\n           \\n                res = max(res, fullCost + partialCost);\\n            }\\n            \\n            return res;\\n        }\\n};\\n```\\n\\n***Java***\\n```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }\\n            res = Math.max(res, c * (long) full + min * (long) partial);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n***Python***\\n```\\nimport bisect\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        # corner case in which no incomplete garden can be created. \\n        if flowers[0] >= target:\\n            return n*full\\n        \\n        # pre-sum in an ascending order\\n        for i in flowers:\\n            pre.append(pre[-1]+i)\\n        \\n        # pre-sum in a descending order, meanwhile, count how many gardens are already full\\n        cnt = 0\\n        for i in flowers[::-1]:\\n            if i >= target:\\n                cnt+=1\\n            lack.append(lack[-1]+max(target-i,0))\\n        \\n        # conditional checker: whether all first k elements can >= flower after adding f to them\\n        def fill(flower,f,k):\\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\\n            return pre[i] + f >= i*flower\\n            \\n        res = 0\\n        # start from the min number of full gardens\\n        for k in range(cnt,n):\\n            if lack[k] < newFlowers:\\n                left, right = flowers[0], target+1\\n                while left < right:\\n                    mid = (left+right)//2\\n                    if not fill(mid,newFlowers-lack[k],n-k):\\n                        right = mid\\n                    else:\\n                        left = mid + 1\\n                left -= 1\\n                \\n                if left >= target:\\n                    # the n-k gardens must be incomplete, which can have a max value as target-1\\n                    \\n                    res = max(res,(target-1)*partial+k*full)\\n                else:\\n                    res = max(res,k*full+left*partial)\\n        \\n        # A corner case: All n gardens can be full, no incomplete gardens\\n        if lack[-1] <= newFlowers:\\n            res = max(res,n*full)\\n        return res\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n        long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \\n        {\\n            int n = flowers.size();\\n            sort(flowers.begin(), flowers.end());\\n            if(n == 0)\\n                return 0;\\n            \\n   \\n            vector<long long>pre(n + 1, 0);\\n            \\n            for(int i = 1; i <= n; i++)\\n                pre[i] = pre[i - 1] + (long long)flowers[i - 1];\\n            \\n            long long res = LLONG_MIN;\\n            \\n            for(int t = n; t >= 0; t--)\\n            {\\n               \\n                long long fullCost = 0;\\n                long long partialCost = 0;\\n                \\n            \\n                if(t < n)\\n                {\\n                    if(flowers[t] < target)\\n                    {\\n                        long long need = (long long)target - (long long)flowers[t];\\n                        \\n                   \\n                        if(need > newFlowers)\\n                            break;\\n                        newFlowers -= need;\\n                    }\\n                }\\n                \\n                fullCost  = (long long)(n - t) * full;\\n                \\n                int l = 0;\\n                int r = target - 1;\\n                \\n                while(l <= r)\\n                {\\n                    int mid = l + (r - l) / 2; \\n                    int idx = upper_bound(flowers.begin(), flowers.begin() + t, mid) - flowers.begin(); \\n                    \\n                    if(idx == 0)\\n                    {\\n                        l = mid + 1;\\n                    }\\n                    else\\n                    {\\n                      \\n                        long long needToPlant = ((long long)mid * (long long)idx - pre[idx]);\\n                        \\n                        if(needToPlant > newFlowers)\\n                            r = mid - 1;\\n                        else\\n                        {\\n                            l = mid + 1;\\n                            partialCost = (long long)mid * partial;\\n                        }\\n                    }\\n                }\\n           \\n                res = max(res, fullCost + partialCost);\\n            }\\n            \\n            return res;\\n        }\\n};\\n```\n```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int n = flowers.length;\\n        long[] prefix = new long[n + 1];\\n        Arrays.sort(flowers);\\n        for (int i = 0; i < n; ++i) prefix[i + 1] = prefix[i] + Math.min(flowers[i], target);\\n        long res = 0;\\n        for (int c = 0, i = n - 1; c <= n; ++c) {\\n            long remain = prefix[n] - prefix[n - c] + newFlowers - c * (long) target, min = 0;\\n            if (0 > remain) break;\\n            i = Math.min(i, n - c - 1);\\n            while (0 <= i && (target <= flowers[i] || flowers[i] * (long) (i + 1) - prefix[i + 1] > remain)) i--;\\n            if (0 <= i) {\\n                long dif = flowers[i] * (long) (i + 1) - prefix[i + 1];\\n                min = Math.min(target - 1, flowers[i] + (remain - dif) / (i + 1));\\n                if (i + 1 < n - c) min = Math.min(min, flowers[i + 1]);\\n            }\\n            res = Math.max(res, c * (long) full + min * (long) partial);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nimport bisect\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort()\\n        pre,lack = [0],[0]\\n        \\n        # corner case in which no incomplete garden can be created. \\n        if flowers[0] >= target:\\n            return n*full\\n        \\n        # pre-sum in an ascending order\\n        for i in flowers:\\n            pre.append(pre[-1]+i)\\n        \\n        # pre-sum in a descending order, meanwhile, count how many gardens are already full\\n        cnt = 0\\n        for i in flowers[::-1]:\\n            if i >= target:\\n                cnt+=1\\n            lack.append(lack[-1]+max(target-i,0))\\n        \\n        # conditional checker: whether all first k elements can >= flower after adding f to them\\n        def fill(flower,f,k):\\n            i = bisect.bisect_left(flowers,flower,lo=0,hi=k)\\n            return pre[i] + f >= i*flower\\n            \\n        res = 0\\n        # start from the min number of full gardens\\n        for k in range(cnt,n):\\n            if lack[k] < newFlowers:\\n                left, right = flowers[0], target+1\\n                while left < right:\\n                    mid = (left+right)//2\\n                    if not fill(mid,newFlowers-lack[k],n-k):\\n                        right = mid\\n                    else:\\n                        left = mid + 1\\n                left -= 1\\n                \\n                if left >= target:\\n                    # the n-k gardens must be incomplete, which can have a max value as target-1\\n                    \\n                    res = max(res,(target-1)*partial+k*full)\\n                else:\\n                    res = max(res,k*full+left*partial)\\n        \\n        # A corner case: All n gardens can be full, no incomplete gardens\\n        if lack[-1] <= newFlowers:\\n            res = max(res,n*full)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935513,
                "title": "python-greedy-algorithm-o-nlogn-no-binary-search",
                "content": "Based on https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/discuss/1931085/Python-Explanation-with-pictures-Greedy.\\n```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = [min(target, e) for e in flowers]\\n        flowers.sort()\\n        n = len(flowers)\\n        if min(flowers) == target: return n*full\\n        if newFlowers >= target*n - sum(flowers):\\n            return max(full*n, (n-1)*full + (target-1)*partial)\\n        cost = [0]*n\\n        for i in range(1,n):\\n            cost[i] = cost[i-1] + i*(flowers[i]-flowers[i-1])\\n        j = n - 1\\n        while flowers[j] == target:\\n            j -= 1\\n        res = 0\\n        l = j\\n        while newFlowers >= 0:\\n            while cost[l] > newFlowers:\\n                l -= 1\\n            idx = min(j, l)\\n            cur_min = flowers[idx] + (newFlowers-cost[idx])//(idx+1)\\n            res = max(res, cur_min*partial+full*(n-j-1))\\n            newFlowers -= (target-flowers[j])\\n            j -= 1\\n        return res\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Based on https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/discuss/1931085/Python-Explanation-with-pictures-Greedy.\\n```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = [min(target, e) for e in flowers]\\n        flowers.sort()\\n        n = len(flowers)\\n        if min(flowers) == target: return n*full\\n        if newFlowers >= target*n - sum(flowers):\\n            return max(full*n, (n-1)*full + (target-1)*partial)\\n        cost = [0]*n\\n        for i in range(1,n):\\n            cost[i] = cost[i-1] + i*(flowers[i]-flowers[i-1])\\n        j = n - 1\\n        while flowers[j] == target:\\n            j -= 1\\n        res = 0\\n        l = j\\n        while newFlowers >= 0:\\n            while cost[l] > newFlowers:\\n                l -= 1\\n            idx = min(j, l)\\n            cur_min = flowers[idx] + (newFlowers-cost[idx])//(idx+1)\\n            res = max(res, cur_min*partial+full*(n-j-1))\\n            newFlowers -= (target-flowers[j])\\n            j -= 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1932539,
                "title": "c-time-100-space-100-o-nlogn-prefix-sum-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        if (target == flowers[0]) return flowers.size() * (long long)full;\\n        int n = flowers.size();\\n        long long max_beauty = 0;\\n        \\n        vector<long long> required_flower(n, 0);   //required_flower[i]: Number of flowers required to make first i gardens have at least flowers[i] flowers;\\n        for (int i = 1; i < n; ++i) {\\n            required_flower[i] = required_flower[i - 1] + i * (long long)(flowers[i] - flowers[i - 1]);\\n        }\\n        for (int j = n; j >= 0; --j) {\\n            if (j != n && flowers[j] < target) {                             //if j already full, we don\\'t decrease avaialble flowers\\n                newFlowers -= (target - flowers[j]);\\n            }\\n            if (newFlowers <= -1) break;                                    //if number of avaiable flowers smaller than 0\\n            long long score = (n - j) * (long long)full;                //score of making gardens j to n - 1 full\\n            if (j == 0) {                                                                //if j is at index 0, we don\\'t have any incomplete flowers\\n                max_beauty = max(score, max_beauty);\\n                break;\\n            }\\n            int candidate = max(0, binary_search(0, j - 1, newFlowers, required_flower));       \\n            long long max_flower = flowers[candidate] + (newFlowers - required_flower[candidate]) / (candidate + 1);    \\n            max_flower = min((long long)target - 1, max_flower);          //max flower of incomplete garden, can\\'t be higher or equal to target\\n            max_beauty = max(score + (long long)max_flower * partial, max_beauty);\\n        }\\n        return max_beauty;\\n    }\\n    int binary_search(int left, int right, int n, vector<long long>& vec) {\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (n >= vec[mid]) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        if (target == flowers[0]) return flowers.size() * (long long)full;\\n        int n = flowers.size();\\n        long long max_beauty = 0;\\n        \\n        vector<long long> required_flower(n, 0);   //required_flower[i]: Number of flowers required to make first i gardens have at least flowers[i] flowers;\\n        for (int i = 1; i < n; ++i) {\\n            required_flower[i] = required_flower[i - 1] + i * (long long)(flowers[i] - flowers[i - 1]);\\n        }\\n        for (int j = n; j >= 0; --j) {\\n            if (j != n && flowers[j] < target) {                             //if j already full, we don\\'t decrease avaialble flowers\\n                newFlowers -= (target - flowers[j]);\\n            }\\n            if (newFlowers <= -1) break;                                    //if number of avaiable flowers smaller than 0\\n            long long score = (n - j) * (long long)full;                //score of making gardens j to n - 1 full\\n            if (j == 0) {                                                                //if j is at index 0, we don\\'t have any incomplete flowers\\n                max_beauty = max(score, max_beauty);\\n                break;\\n            }\\n            int candidate = max(0, binary_search(0, j - 1, newFlowers, required_flower));       \\n            long long max_flower = flowers[candidate] + (newFlowers - required_flower[candidate]) / (candidate + 1);    \\n            max_flower = min((long long)target - 1, max_flower);          //max flower of incomplete garden, can\\'t be higher or equal to target\\n            max_beauty = max(score + (long long)max_flower * partial, max_beauty);\\n        }\\n        return max_beauty;\\n    }\\n    int binary_search(int left, int right, int n, vector<long long>& vec) {\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (n >= vec[mid]) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931773,
                "title": "java-binary-search-solution",
                "content": "```\\npublic long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n    int n = flowers.length;\\n\\n    List<Integer> gardens = new ArrayList<>();\\n\\n    for (int val : flowers) {\\n        if (val < target) {\\n            gardens.add(val);\\n        }\\n    }\\n\\n    if (gardens.size() == 0) {\\n        return (long) n * full;\\n    }\\n\\n    Collections.sort(gardens);\\n\\n    int m = gardens.size();\\n\\n    long[] costs = new long[m];\\n    for (int i = 1; i < m; ++i) {\\n        costs[i] = costs[i - 1] + (long) i * (gardens.get(i) - gardens.get(i - 1));\\n    }\\n\\n    long base = (long) (n - gardens.size()) * full;\\n    long max = 0;\\n\\n    for (int i = m - 1; i >= -1; --i) {\\n        long min = Math.min(getMin(gardens, costs, i, newFlowers), target - 1);\\n        max = Math.max(max, base + min * partial);\\n        if (i == -1 || target - gardens.get(i) > newFlowers) break;\\n        newFlowers -= target - gardens.get(i);\\n        base += full;\\n    }\\n\\n    return max;\\n}\\n\\nprivate long getMin(List<Integer> gardens, long[] costs, int i, long k, long limit) {\\n    if (i < 0) return 0;\\n    \\n    int l = 0, r = i;\\n    \\n    while (l < r) {\\n        int mid = (l + r) / 2 + 1;\\n        \\n        if (costs[mid] <= k) {\\n            l = mid;\\n        }\\n        else {\\n            r = mid - 1;\\n            limit = gardens.get(mid);\\n        }\\n    }\\n    \\n    return Math.min(gardens.get(l) + (k - costs[l]) / (l + 1), limit);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n    int n = flowers.length;\\n\\n    List<Integer> gardens = new ArrayList<>();\\n\\n    for (int val : flowers) {\\n        if (val < target) {\\n            gardens.add(val);\\n        }\\n    }\\n\\n    if (gardens.size() == 0) {\\n        return (long) n * full;\\n    }\\n\\n    Collections.sort(gardens);\\n\\n    int m = gardens.size();\\n\\n    long[] costs = new long[m];\\n    for (int i = 1; i < m; ++i) {\\n        costs[i] = costs[i - 1] + (long) i * (gardens.get(i) - gardens.get(i - 1));\\n    }\\n\\n    long base = (long) (n - gardens.size()) * full;\\n    long max = 0;\\n\\n    for (int i = m - 1; i >= -1; --i) {\\n        long min = Math.min(getMin(gardens, costs, i, newFlowers), target - 1);\\n        max = Math.max(max, base + min * partial);\\n        if (i == -1 || target - gardens.get(i) > newFlowers) break;\\n        newFlowers -= target - gardens.get(i);\\n        base += full;\\n    }\\n\\n    return max;\\n}\\n\\nprivate long getMin(List<Integer> gardens, long[] costs, int i, long k, long limit) {\\n    if (i < 0) return 0;\\n    \\n    int l = 0, r = i;\\n    \\n    while (l < r) {\\n        int mid = (l + r) / 2 + 1;\\n        \\n        if (costs[mid] <= k) {\\n            l = mid;\\n        }\\n        else {\\n            r = mid - 1;\\n            limit = gardens.get(mid);\\n        }\\n    }\\n    \\n    return Math.min(gardens.get(l) + (k - costs[l]) / (l + 1), limit);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931726,
                "title": "c-binary-search-comments",
                "content": "```\\n// Approach: Iterations  + Binary Search\\n// Time Complexity: NlogN (Approx.)\\n\\n// Idea: Idea is to complete k flowers and for remaining n - k flowers try to maximize the minimum by using remaining new flowers\\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        \\n        // Number of gardens\\n        int n = flowers.size();\\n    \\n        sort(flowers.begin(),flowers.end());\\n\\n        long long ans = 0;\\n\\n        // If All gardens are complete\\n        if(flowers[0] >= target)\\n        {\\n            return ((long long)n * full);\\n        }\\n\\n        // Prefix Sum Array\\n        long long prefix[n+1];\\n\\n        prefix[0] = 0;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            prefix[i] = prefix[i-1] + flowers[i-1];\\n        }\\n\\n\\n        // Completed Gardens\\n        long long complete = 0;\\n\\n\\n        // Calculating Already Completed Gardens\\n        for(int i=n-1; i>= 0;i--)\\n        {\\n            if(flowers[i] >= target)\\n            {\\n                complete++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        // This case if for keep the completed gardens as it is and try to maximize other flowers for partial multplication\\n        ans = (complete * full);\\n        long long lo = flowers[0];\\n        long long hi = target-1;\\n        long long minFlower = lo;\\n        while(lo <= hi)\\n        {\\n            long long mid = (lo + hi) / 2;\\n\\n            int count = flowers.end() - lower_bound(flowers.begin(),flowers.end(),mid);\\n\\n            int X = n - count;\\n\\n            long long req = mid * X - (prefix[X]);\\n\\n            if(req <= newFlowers)\\n            {\\n                minFlower = mid;\\n                lo = mid + 1;\\n\\n            }\\n            else\\n            {\\n                hi = mid - 1;\\n            }\\n\\n        }\\n\\n        ans += (minFlower * partial);\\n\\n        \\n\\n        for(int i=n - complete - 1;i >= 0;i--)\\n        {\\n            int diff = max(target - flowers[i], 0);\\n\\n            if(diff > newFlowers)\\n                break;\\n            newFlowers -= diff;\\n            complete++;\\n\\n            lo = flowers[0];\\n            hi = target - 1;\\n            minFlower = lo;\\n\\n            // Hey I have now make complete gardens \\n            // and now from remaining newFlowers try to maximize the flowers so that partial * min(flowers) will be maximums\\n            \\n            // Famous binary search implementation\\n            while(lo <= hi)\\n            {\\n                long long mid = (lo + hi) / 2;\\n\\n                int count = flowers.end() - lower_bound(flowers.begin(),flowers.begin() + n - complete,mid);\\n\\n                int X = n - count;\\n\\n                long long req = mid * X - (prefix[X]);\\n                \\n                if(req <= newFlowers)\\n                {\\n                    minFlower = mid;\\n                    lo = mid + 1;\\n\\n                }\\n                else\\n                {\\n                    hi = mid - 1;\\n                }\\n\\n            }\\n\\n            // Edge case if all completed then make the minFlower = 0\\n            if(complete == n)\\n                minFlower = 0;\\n\\n            // Try to maximize answer \\n            ans = max(complete * full + partial * minFlower,ans);\\n\\n        }\\n        \\n\\n        // You are done, return the answer\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        \\n        // Number of gardens\\n        int n = flowers.size();\\n    \\n        sort(flowers.begin(),flowers.end());\\n\\n        long long ans = 0;\\n\\n        // If All gardens are complete\\n        if(flowers[0] >= target)\\n        {\\n            return ((long long)n * full);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1931524,
                "title": "java-nlogn-small-proof-why-would-sort-work",
                "content": "Idea\\n1. Sort the array ,\\n2. choose every pivot from end to begin where element is less than target and make this = target\\n3. keep count of element >= target\\n4. Distribute remaining newFlowers from begining till index where it can be afforded\\n5. Check for max\\n\\nAttempt to Proof :\\n\\nTo maximize `MAX = (full * count (x_i >= target)) + (partial*(min(x_i < target))`  within contraints\\n\\nIterating count = 1 till length; \\n\\nSuppose this is sort order where `X0 = smallest , XN = largest in X0, X1, X2, X3, X4, X5...... XN`\\n\\n               We processed array till X5\\n\\n                X0, X1, X2, X3, X4, X5...... XN\\n\\t\\t\\t\\t\\t                |\\n\\t\\t\\t\\tNext to process is index = 4\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSuppose X4 - X3 = d; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tIf we increase the current count > target by 1, \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tto maximize MAX with count = N - 4\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t1. \\t\\tChoose sort order and process X4 after X5\\n\\n\\t\\t\\t\\t\\t\\t\\tX0, X1, X2, X3, X4, X5...... XN   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\n\\t\\t\\t\\t\\t\\t\\tnewRemainingFlowersX4 = remaining - (target -  x4)\\n\\t\\t\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t2. Without loss of generality Choose X3 after X5 and keep count = N-4 same so full * count is same in MAX \\n\\n\\t\\t\\t\\t\\t\\t\\tX0, X1, X2, X4, X3, X5...... XN \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tnewRemainingflowersX3 =remaining - (target - x3)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tLets say our min in both remaining flowers was targeting (min = X4+a ) in arr[0......3]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tThen what remains to see that this can be achived in both cases \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tX0...X2 is same cost \\n\\t\\t\\t\\t\\n\\t\\t\\t\\teq 1 -> newRemainingFlowersX4 - newRemainingFlowersX3 = X4 - X3 = d;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile extra cost to increase to min  = X4 + a in \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase 1 eq 2 -> X4-X3 + a = d+a\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase 2 = X4 - X4+ a = a;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tin eq1 extra d we get can be adjusted in eq2\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tSo sort order can be selected since min is not effected , count not effected  but remaining is more in can of sort order to process later elements.\\n\\t\\n\\t\\nLet me know your thoughts\\n\\n```\\nclass Solution {\\n\\tpublic long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n\\t\\tint len = flowers.length;\\n\\t\\tlong cumulativeCostArray[] = new long[len];\\n\\t\\tArrays.sort(flowers);\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcumulativeCostArray[i] = cumulativeCostArray[i - 1] + (long) i * (flowers[i] - flowers[i - 1]);\\n\\t\\t}\\n\\n\\t\\tlong max = 0;\\n\\t\\tint i;\\n\\t\\tint countComplete = 0;\\n\\t\\tfor (i = len - 1; i >= 0; i--) {\\n\\t\\t\\tif (flowers[i] < target)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcountComplete++;\\n\\t\\t}\\n\\n\\t\\tif (countComplete == len)\\n\\t\\t\\treturn ((countComplete * (long) full));\\n\\n\\t\\tint id = binarySearchCumulativeCost(cumulativeCostArray, newFlowers, 0, i);\\n\\t\\tmax = currentPartitionCost(flowers, newFlowers, target, full, partial, cumulativeCostArray, max, countComplete, id);\\n\\n\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\tnewFlowers = newFlowers - (target - flowers[j]);\\n\\t\\t\\tif (newFlowers < 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcountComplete++;\\n\\t\\t\\tif (j == 0) {\\n\\t\\t\\t\\tmax = Math.max(max, countComplete * (long) full);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tid = binarySearchCumulativeCost(cumulativeCostArray, newFlowers, 0, j - 1);\\n\\t\\t\\tmax = Math.max(max, currentPartitionCost(flowers, newFlowers, target, full, partial, cumulativeCostArray, max,\\n\\t\\t\\t\\t\\tcountComplete, id));\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}\\n\\n\\tprivate long currentPartitionCost(int[] flowers, long newFlowers, int target, int full, int partial,\\n\\t\\t\\tlong[] costArray, long max, int countComplete, int id) {\\n\\t\\tif (id >= 0) {\\n\\t\\t\\tlong rem = (newFlowers - costArray[id]);\\n\\t\\t\\tlong minToAddFromRem = rem / (id + 1);\\n\\t\\t\\tmax = ((countComplete * (long) full) + ((Math.min(target - 1, minToAddFromRem + flowers[id])) * (long) partial));\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\tpublic int binarySearchCumulativeCost(long cost[], long num, int s, int e) {\\n\\t\\tint i = s, j = e;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\t\\t\\tif (cost[mid] <= num) {\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cost[i] <= num ? i : (i - 1);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n\\t\\tint len = flowers.length;\\n\\t\\tlong cumulativeCostArray[] = new long[len];\\n\\t\\tArrays.sort(flowers);\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tcumulativeCostArray[i] = cumulativeCostArray[i - 1] + (long) i * (flowers[i] - flowers[i - 1]);\\n\\t\\t}\\n\\n\\t\\tlong max = 0;\\n\\t\\tint i;\\n\\t\\tint countComplete = 0;\\n\\t\\tfor (i = len - 1; i >= 0; i--) {\\n\\t\\t\\tif (flowers[i] < target)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcountComplete++;\\n\\t\\t}\\n\\n\\t\\tif (countComplete == len)\\n\\t\\t\\treturn ((countComplete * (long) full));\\n\\n\\t\\tint id = binarySearchCumulativeCost(cumulativeCostArray, newFlowers, 0, i);\\n\\t\\tmax = currentPartitionCost(flowers, newFlowers, target, full, partial, cumulativeCostArray, max, countComplete, id);\\n\\n\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\tnewFlowers = newFlowers - (target - flowers[j]);\\n\\t\\t\\tif (newFlowers < 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcountComplete++;\\n\\t\\t\\tif (j == 0) {\\n\\t\\t\\t\\tmax = Math.max(max, countComplete * (long) full);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tid = binarySearchCumulativeCost(cumulativeCostArray, newFlowers, 0, j - 1);\\n\\t\\t\\tmax = Math.max(max, currentPartitionCost(flowers, newFlowers, target, full, partial, cumulativeCostArray, max,\\n\\t\\t\\t\\t\\tcountComplete, id));\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}\\n\\n\\tprivate long currentPartitionCost(int[] flowers, long newFlowers, int target, int full, int partial,\\n\\t\\t\\tlong[] costArray, long max, int countComplete, int id) {\\n\\t\\tif (id >= 0) {\\n\\t\\t\\tlong rem = (newFlowers - costArray[id]);\\n\\t\\t\\tlong minToAddFromRem = rem / (id + 1);\\n\\t\\t\\tmax = ((countComplete * (long) full) + ((Math.min(target - 1, minToAddFromRem + flowers[id])) * (long) partial));\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\tpublic int binarySearchCumulativeCost(long cost[], long num, int s, int e) {\\n\\t\\tint i = s, j = e;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\t\\t\\tif (cost[mid] <= num) {\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cost[i] <= num ? i : (i - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886015,
                "title": "python-3-simple-interface-explained-o-nlogn-o-1",
                "content": "# Intuition\\nWe can forget about gardens that are originally complete, because we can\\'t change their state. Let\\'s assume that we don\\'t have such gardens, then:\\n* There are actually only $N+1$ candidates for an answer:\\n\\n  1 \\u2014 $0$ complete gardens and $N$ incomplete gardens (with maximized minimum amount of flowers)\\n  2 \\u2014 $1$ complete gardens and $N-1$ incomplete gardens (with maximized minimum amount of flowers)\\n    ...\\n  N+1 \\u2014 $N$ complete gardens and $0$ incomplete gardens (with maximized minimum amount of flowers)\\n\\nNow all we need is to find efficient approach to iterate over these candidates.\\n\\n* We can notice that we can do only 4 actions\\n    1. Make garden complete\\n    2. Maximize minimum number of flowers among incomplete gardens\\n    3. Revert operation (1)\\n    4. Revert operation (2)\\n\\nUsing this interface we can easily write an algorithm (pseudo-code):\\n```\\nm = 0  # number of complete gardens\\nwhile can_make_more_gardens_complete:\\n    make_garden_complete()  # Operation 1\\n    m += 1\\nmaximize_min_number_of_flowers()  # Operation 2\\nans = ...  # update answer\\nfor _ in range(m):\\n    make_garden_incomplete()  # Operation 3\\n    maximize_min_number_of_flowers()  # Operation 2\\n    ans = max(ans, ...)  # update answer\\nreturn ans\\n```\\n\\n* If we sort `flowers`: Operations (1), (3) can be implemented with $O(1)$ time, operation (2) can be implemented with $\\\\Omega(1)$ time and we don\\'t actually need operation (4)\\n\\n\\n# Complexity\\n- Time complexity: $$O(N\\\\log N)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort() \\n        originally_complete = sum(flowers[i] >= target for i in range(n))\\n        work_end = n - originally_complete\\n        # [0,        j-1] \\u2014 incomplete (with >=`level` flowers each, where `0 <= `level` <= target - 1) \\n        # [j, work_end-1] \\u2014 complete\\n        # [work_end, n-1] \\u2014 originally complete\\n\\n        i = -1\\n        level = 0\\n        def maximize_min_number_of_flowers() -> None:\\n            nonlocal i, level, newFlowers\\n            if j == 0:\\n                return\\n            if i == -1:\\n                i = 0\\n                level = flowers[0]\\n            while i < j:\\n                next_level = flowers[i+1] if i + 1 < j else target - 1\\n                max_boost = min(next_level - level, newFlowers // (i+1))\\n                level += max_boost\\n                newFlowers -= max_boost * (i+1)\\n                if level != next_level:\\n                    break\\n                i += 1\\n        \\n        j = work_end\\n        def add_complete_garden() -> bool:\\n            nonlocal j, newFlowers\\n            if j - 1 < 0 or newFlowers < target - flowers[j-1]:\\n                return False\\n            newFlowers -= target - flowers[j-1]\\n            j -= 1\\n            return True\\n        def remove_complete_garden() -> None:\\n            nonlocal j, newFlowers\\n            assert j < work_end\\n            newFlowers += target - flowers[j]\\n            flowers[j] = flowers[j]\\n            j += 1\\n\\n        while add_complete_garden():\\n            pass\\n        maximize_min_number_of_flowers()\\n        ans = full * (n - j) + partial * level\\n        while j < work_end:\\n            remove_complete_garden()\\n            maximize_min_number_of_flowers()\\n            ans = max(ans, full * (n - j) + partial * level)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nm = 0  # number of complete gardens\\nwhile can_make_more_gardens_complete:\\n    make_garden_complete()  # Operation 1\\n    m += 1\\nmaximize_min_number_of_flowers()  # Operation 2\\nans = ...  # update answer\\nfor _ in range(m):\\n    make_garden_incomplete()  # Operation 3\\n    maximize_min_number_of_flowers()  # Operation 2\\n    ans = max(ans, ...)  # update answer\\nreturn ans\\n```\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort() \\n        originally_complete = sum(flowers[i] >= target for i in range(n))\\n        work_end = n - originally_complete\\n        # [0,        j-1] \\u2014 incomplete (with >=`level` flowers each, where `0 <= `level` <= target - 1) \\n        # [j, work_end-1] \\u2014 complete\\n        # [work_end, n-1] \\u2014 originally complete\\n\\n        i = -1\\n        level = 0\\n        def maximize_min_number_of_flowers() -> None:\\n            nonlocal i, level, newFlowers\\n            if j == 0:\\n                return\\n            if i == -1:\\n                i = 0\\n                level = flowers[0]\\n            while i < j:\\n                next_level = flowers[i+1] if i + 1 < j else target - 1\\n                max_boost = min(next_level - level, newFlowers // (i+1))\\n                level += max_boost\\n                newFlowers -= max_boost * (i+1)\\n                if level != next_level:\\n                    break\\n                i += 1\\n        \\n        j = work_end\\n        def add_complete_garden() -> bool:\\n            nonlocal j, newFlowers\\n            if j - 1 < 0 or newFlowers < target - flowers[j-1]:\\n                return False\\n            newFlowers -= target - flowers[j-1]\\n            j -= 1\\n            return True\\n        def remove_complete_garden() -> None:\\n            nonlocal j, newFlowers\\n            assert j < work_end\\n            newFlowers += target - flowers[j]\\n            flowers[j] = flowers[j]\\n            j += 1\\n\\n        while add_complete_garden():\\n            pass\\n        maximize_min_number_of_flowers()\\n        ans = full * (n - j) + partial * level\\n        while j < work_end:\\n            remove_complete_garden()\\n            maximize_min_number_of_flowers()\\n            ans = max(ans, full * (n - j) + partial * level)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313576,
                "title": "python3-2-pointer",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/af907302ab84ad94ecb97eeeb9b0bfa529041e30) for solutions of weekly 288. \\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(min(target, x) for x in flowers)\\n        prefix = [0]\\n        ii = -1 \\n        for i in range(len(flowers)): \\n            if flowers[i] < target: ii = i \\n            if i: prefix.append(prefix[-1] + (flowers[i]-flowers[i-1])*i)\\n        ans = 0 \\n        for k in range(len(flowers)+1): \\n            if k: newFlowers -= target - flowers[-k]\\n            if newFlowers >= 0: \\n                while 0 <= ii and (ii+k >= len(flowers) or prefix[ii] > newFlowers): ii -= 1\\n                if 0 <= ii: kk = min(target-1, flowers[ii] + (newFlowers - prefix[ii])//(ii+1))\\n                else: kk = 0 \\n                ans = max(ans, k*full + kk*partial)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(min(target, x) for x in flowers)\\n        prefix = [0]\\n        ii = -1 \\n        for i in range(len(flowers)): \\n            if flowers[i] < target: ii = i \\n            if i: prefix.append(prefix[-1] + (flowers[i]-flowers[i-1])*i)\\n        ans = 0 \\n        for k in range(len(flowers)+1): \\n            if k: newFlowers -= target - flowers[-k]\\n            if newFlowers >= 0: \\n                while 0 <= ii and (ii+k >= len(flowers) or prefix[ii] > newFlowers): ii -= 1\\n                if 0 <= ii: kk = min(target-1, flowers[ii] + (newFlowers - prefix[ii])//(ii+1))\\n                else: kk = 0 \\n                ans = max(ans, k*full + kk*partial)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980804,
                "title": "c-solution-easy-to-understand",
                "content": "Firstly, I  recommend to see a hint and then visiting a code. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long funbin(vector<int> &v,vector<long long> &pre,long long f,int t)\\n    {\\n        \\n        if(v.size()==0 || v[0]>=t)\\n            return 0;\\n        int r = 0,l = t-1;\\n        while(r<=l)\\n        {\\n            long long mid = (r+l)/2;\\n            long long sum = 0;\\n            long long rr = 0,ll = v.size()-1;\\n            while(rr<=ll)\\n            {\\n                long long midd = (rr+ll)/2;\\n                if(v[midd]>=mid)\\n                    ll = midd-1;\\n                else\\n                    rr = midd+1;\\n            }\\n            \\n            if(ll>=0)\\n                sum = pre[ll];\\n            \\n            long long sum1 = 1ll*(ll+1)*(mid) - sum;\\n            \\n            if(sum1>f)\\n                l = mid-1;\\n            else\\n                r = mid+1;\\n        \\n        }\\n\\n        return l;\\n    }\\n    long long maximumBeauty(vector<int>& v, long long f, int t, int fu, int pa){\\n        \\n        sort(v.begin(),v.end());\\n        int n = v.size();\\n        vector<long long> pre(n);\\n        pre[0] = v[0];\\n        \\n        for(int i=1; i<v.size(); ++i)\\n            pre[i]+=pre[i-1] + v[i];\\n        \\n        long long fans = pa*funbin(v,pre,f,t);\\n        int coun = 0;\\n        while((int)v.size())\\n        {\\n            coun++;\\n            int x = v.back();\\n            v.pop_back();\\n            long long a = max(0,t-x);\\n            f-=a;\\n            if(f<0)\\n                break;\\n            \\n            long long lo = funbin(v,pre,f,t);\\n            \\n            fans = max(fans,1ll*coun*fu + 1ll*pa*lo);  \\n        }\\n        \\n        \\n        return fans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long funbin(vector<int> &v,vector<long long> &pre,long long f,int t)\\n    {\\n        \\n        if(v.size()==0 || v[0]>=t)\\n            return 0;\\n        int r = 0,l = t-1;\\n        while(r<=l)\\n        {\\n            long long mid = (r+l)/2;\\n            long long sum = 0;\\n            long long rr = 0,ll = v.size()-1;\\n            while(rr<=ll)\\n            {\\n                long long midd = (rr+ll)/2;\\n                if(v[midd]>=mid)\\n                    ll = midd-1;\\n                else\\n                    rr = midd+1;\\n            }\\n            \\n            if(ll>=0)\\n                sum = pre[ll];\\n            \\n            long long sum1 = 1ll*(ll+1)*(mid) - sum;\\n            \\n            if(sum1>f)\\n                l = mid-1;\\n            else\\n                r = mid+1;\\n        \\n        }\\n\\n        return l;\\n    }\\n    long long maximumBeauty(vector<int>& v, long long f, int t, int fu, int pa){\\n        \\n        sort(v.begin(),v.end());\\n        int n = v.size();\\n        vector<long long> pre(n);\\n        pre[0] = v[0];\\n        \\n        for(int i=1; i<v.size(); ++i)\\n            pre[i]+=pre[i-1] + v[i];\\n        \\n        long long fans = pa*funbin(v,pre,f,t);\\n        int coun = 0;\\n        while((int)v.size())\\n        {\\n            coun++;\\n            int x = v.back();\\n            v.pop_back();\\n            long long a = max(0,t-x);\\n            f-=a;\\n            if(f<0)\\n                break;\\n            \\n            long long lo = funbin(v,pre,f,t);\\n            \\n            fans = max(fans,1ll*coun*fu + 1ll*pa*lo);  \\n        }\\n        \\n        \\n        return fans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967273,
                "title": "c-detailed-solution-with-intuitive-explanation",
                "content": "\\t\\tthe idea is to sort the array first (why?...it\\'ll be clear as you go through the below explanation)\\n\\n\\t\\tthe beauty value (which we have to optimize) depends on two things\\n\\t\\t\\t- full*(# of complete gardens) [value 1]\\n\\t\\t\\t- partial *(minimum value of all the partial gardens) [value 2]\\n\\n\\t\\twhen we have to different things which our answer depends on, then it is better to fix on of them\\n\\t\\tand vary the other\\n\\n\\t\\there we will fix the first guy (full *(# of complete gardens))\\n\\n\\t\\tbasically what we are trying to do is:\\n\\t\\tfirst fix #of complete gardens to 1, and find the optimal value of the second value [partial *(minimum value of all the partial gardens)]\\n\\t\\tthen fix #of complete gardens to 2, and find the optimal value of the second value  [partial *(minimum value of all the partial gardens)]\\n\\n\\t\\tso in general fix #of complete gardens to x [by distributing some flowers to some gardens in some fashion (which we\\'ll see in a while)],\\n\\t\\tand for the remaining n - x gardens, distribute some/all of the remaining flowers in such a fashion such that  the minimum of all the remaining (incomplete)\\n\\t\\tgardens in maximum\\n\\n\\t\\tand keep doing this\\n\\t\\tnow the first question arises : which x gardens should i chose to make full?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tA very intuitive answer would be to chose those x gardens which contain maximum number of flowers\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(so that we have to use minimum number of flowers, and can be left with more options for the second step)\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tNow at each step we are chosing x largest values from the array (x :[1...N])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tso it means that we will sort the array and traverse from the back\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tat i, we would have made all the gardens from [n - 1 to i] complete by adding the required number of flowers to each of them\\n\\n\\t\\tnow the second step : how do we maximise the minimum value of all the partial / incomplete gardens?\\n\\t\\t\\t\\t\\t\\t\\t  we know that the range this value (minimum value of all the partial / incomplete gardens)\\n\\t\\t\\t\\t\\t\\t\\t  may lie in is [0, taret - 1]\\n\\t\\t\\t\\t\\t\\t\\t  that\\'s where binary search comes into the picture\\n\\n\\t\\t\\t\\t\\t\\t\\t  for a given value in this range (mid), we will see if it is possible to\\n\\t\\t\\t\\t\\t\\t\\t  somehow make the minimum value of this part of the array equal to mid?\\n\\t\\t\\t\\t\\t\\t\\t  if it is, then we have a candidate for this, and move ahead to find a larger value\\n\\n\\t\\t\\t\\t\\t\\t\\t  if it is not, then we\\'ll be forced to look for a smaller value\\n\\t\\t\\t\\t\\t\\t\\t  what we are doing here is, we find the first element greater than mid in the array (in the part before i) [let it\\'s index be idx]\\n\\t\\t\\t\\t\\t\\t\\t  and we will make all the elements coming before this equal to mid\\n\\n\\t\\t\\t\\t\\t\\t\\t  the number of flowers required to achive this will be mid*idx - sum[0..idx - 1] (quite easy to calculate)\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\n\\tll max(ll a, ll b) {return a > b ? a : b;}\\n\\n\\n\\n\\n\\tlong long maximumBeauty(vector<int>& a, long long newFlowers, int target, int full, int partial) {\\n\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tll n = a.size();\\n\\t\\tvector<ll> prefix(n, 0);\\n\\t\\tll sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += a[i];\\n\\t\\t\\tprefix[i] = sum;\\n\\t\\t}\\n\\n\\t\\t// end se leke i tak sabko complete kar denge\\n\\t\\tll ans = 0;\\n\\t\\tfor (int i = n; i >= 0; i--) {\\n\\t\\t\\t// from n - 1 till i, all the gardens are complete (means all of them have >= target number of flowers)\\n\\n\\t\\t\\tif (i < n) {\\n\\t\\t\\t\\tll toAdd = max(0, target - a[i]);\\n\\t\\t\\t\\tif (newFlowers < toAdd) break;\\n\\t\\t\\t\\tnewFlowers -= toAdd;\\n\\t\\t\\t\\ta.pop_back();\\n\\t\\t\\t}\\n\\n\\t\\t\\tll low = 0, high = target - 1;\\n\\t\\t\\t// the minimum incomplete garden value will lie between 0 and target - 1 obviously\\n\\n\\t\\t\\tll currentPartialBeauty = 0;\\n\\t\\t\\tll currentFullBeauty = (ll)((n - i) * full);\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tll mid = low + (high - low) / 2;\\n\\t\\t\\t\\t// mid is the candidate for the minimum guy in the array\\n\\n\\t\\t\\t\\tint idx = upper_bound(a.begin(), a.end(), mid) - a.begin(); // index of the first guy which is strictly greater than mid\\n\\t\\t\\t\\t// we intend to make every guy which comes before this equal to mid\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tif (idx == 0) {\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\t// in this case there are no elements behind mid, means no element can be made  == mid\\n\\t\\t\\t\\t\\t// means all the values are greater than 1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tll needed = (ll)mid * idx - (ll)prefix[idx - 1];\\n\\t\\t\\t\\t\\t// needed represents the number of flowers needed to make the minimum element in the array equal to mid\\n\\t\\t\\t\\t\\t// basically all the elements before idx will be set equal to mid. the array is increasing, so all the guys after idx -1\\n\\t\\t\\t\\t\\t// will be greater than mid (idx was the upper_bound index), so mid will be the minimum element in the array definitely\\n\\n\\t\\t\\t\\t\\t// if the number of flowers needed to make mid as the minimum is more than what we have, then we have to look for a lesser value of mid (as that would need lesser number of flowers to achieve)\\n\\t\\t\\t\\t\\t// in case we have sufficient number of flowers, we will search for a higher value of the minimum element\\n\\t\\t\\t\\t\\tif (needed <= newFlowers) {\\n\\t\\t\\t\\t\\t\\tcurrentPartialBeauty = mid * partial;\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\t} else high = mid - 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tans = max(ans, currentPartialBeauty + currentFullBeauty);\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\n\\tll max(ll a, ll b) {return a > b ? a : b;}\\n\\n\\n\\n\\n\\tlong long maximumBeauty(vector<int>& a, long long newFlowers, int target, int full, int partial) {\\n\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tll n = a.size();\\n\\t\\tvector<ll> prefix(n, 0);\\n\\t\\tll sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += a[i];\\n\\t\\t\\tprefix[i] = sum;\\n\\t\\t}\\n\\n\\t\\t// end se leke i tak sabko complete kar denge\\n\\t\\tll ans = 0;\\n\\t\\tfor (int i = n; i >= 0; i--) {\\n\\t\\t\\t// from n - 1 till i, all the gardens are complete (means all of them have >= target number of flowers)\\n\\n\\t\\t\\tif (i < n) {\\n\\t\\t\\t\\tll toAdd = max(0, target - a[i]);\\n\\t\\t\\t\\tif (newFlowers < toAdd) break;\\n\\t\\t\\t\\tnewFlowers -= toAdd;\\n\\t\\t\\t\\ta.pop_back();\\n\\t\\t\\t}\\n\\n\\t\\t\\tll low = 0, high = target - 1;\\n\\t\\t\\t// the minimum incomplete garden value will lie between 0 and target - 1 obviously\\n\\n\\t\\t\\tll currentPartialBeauty = 0;\\n\\t\\t\\tll currentFullBeauty = (ll)((n - i) * full);\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tll mid = low + (high - low) / 2;\\n\\t\\t\\t\\t// mid is the candidate for the minimum guy in the array\\n\\n\\t\\t\\t\\tint idx = upper_bound(a.begin(), a.end(), mid) - a.begin(); // index of the first guy which is strictly greater than mid\\n\\t\\t\\t\\t// we intend to make every guy which comes before this equal to mid\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tif (idx == 0) {\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\t// in this case there are no elements behind mid, means no element can be made  == mid\\n\\t\\t\\t\\t\\t// means all the values are greater than 1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tll needed = (ll)mid * idx - (ll)prefix[idx - 1];\\n\\t\\t\\t\\t\\t// needed represents the number of flowers needed to make the minimum element in the array equal to mid\\n\\t\\t\\t\\t\\t// basically all the elements before idx will be set equal to mid. the array is increasing, so all the guys after idx -1\\n\\t\\t\\t\\t\\t// will be greater than mid (idx was the upper_bound index), so mid will be the minimum element in the array definitely\\n\\n\\t\\t\\t\\t\\t// if the number of flowers needed to make mid as the minimum is more than what we have, then we have to look for a lesser value of mid (as that would need lesser number of flowers to achieve)\\n\\t\\t\\t\\t\\t// in case we have sufficient number of flowers, we will search for a higher value of the minimum element\\n\\t\\t\\t\\t\\tif (needed <= newFlowers) {\\n\\t\\t\\t\\t\\t\\tcurrentPartialBeauty = mid * partial;\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\t} else high = mid - 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tans = max(ans, currentPartialBeauty + currentFullBeauty);\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934037,
                "title": "c-compute-scores-of-candidate-cases-using-binary-search-prefix-sum",
                "content": "The goal is to find the maximum beauty score. However, neither maximizing complete gardens nor maximizing the minimum number of flowers of incomplete gardens yield the optimum. Thus one might need to go through most possible cases and get the largest one.\\n\\nOne idea is to gradually make near-complete gardens full (and we know the \"full\" score), and find the largest \"partial\" score from the remaining gardens. If we want to maximize the total score given that we first make `k` gardens full, we greedily choose `k` incomplete gardens that are nearest to `target` size, and hence we have most quota to maximize partial score. To greedily make gardens full, we sort the array and make the nearest-to-target one full in order.\\n\\nThe remaining part is to compute partial score given that `k` gardens are complete. To achieve this, we first construct a prefix sum table of the sorted array, and then we can compute \"the flower needed to fill the 0-th to `i`-th garden up to `t`\" by `t * (i+1) - presum[i]`. The goal is to find the largest `t`, where `t` is within the interval `[min(flowers), target - 1]`. We can use binary search to find the optimal `t`, and for fixed `t`, we can perform another binary search on `flowers[0:n-k]` to get the maximum index `i` where `flowers[i] <= t`, which is the largest garden we need to fill up to `t`. The following example illustrates the process:\\n\\n```\\nk=2\\nquota=8\\ntarget=10\\nt: binary search through [1, 9]\\n  0|x         |    1\\n  1|xx        |    3\\n  2|xxx       |    6\\n  3|xxx       |    9\\n  4|xxxxx     |    14\\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\nt=5\\n  0|xoooo|    |    1\\n  1|xxoo |    |    3\\n  2|xxxo |    |    6\\n  3|xxxo |    |    9\\n->4|xxxxx|    |    14    5*(4+1)-14=11 (>8)\\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\nt=4\\n  0|xooo|     |    1\\n  1|xxoo|     |    3\\n  2|xxxo|     |    6\\n->3|xxxo|     |    9     4*(3+1)-9=7 (<=8)\\n  4|xxxxx     |    14    \\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\n=>score(k=2) = full * k + partial * t\\n             = full * 2 + partial * 4\\n```\\nWe iterate through all possible `k`-s, and the maximum score ever computed is our answer.\\n\\n\\nThe following is the C++ code of this problem. Let `n` be the size of the `flowers` vector, and `t` be the numerical value of `target`, then the total time completity is `O(n (log t) (log n))`: each binary search over all possible partial points requires another nested binary search over the `flowers` array (in `upper_bound(flowers.begin(), flowers.begin() + i + 1, c)`), hence taking `O((log t) (log n))` per searching operation. The space complexity is `O(n)`, for building a prefix sum table.\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        \\n        // construct prefix sum table\\n        vector<long long> presum(1, flowers[0]);\\n        for (int i = 1; i < n; ++i) presum.push_back(presum.back() + flowers[i]);\\n        \\n        // for each iteration, use binary search to find the largest\\n        // partial point of [0, i] given that [i+1, n) can be completed\\n        long long ans = 0, avfl = newFlowers;\\n        for (int i = n - 1; i >= 0 && avfl > 0; --i) {\\n            if (flowers[i] >= target) continue; \\n            \\n            // largest possible partial weight \\n            // must fall between [flowers[0], target - 1]\\n            int l = flowers[0], r = target - 1;\\n            while (l < r) {\\n                int c = l + (r-l+1)/2;\\n                int j = distance(flowers.begin(), prev(upper_bound(flowers.begin(), flowers.begin() + i + 1, c)));\\n                if (avfl < (long long)c * (j+1) - presum[j]) r = c-1;\\n                else l = c;\\n            }\\n            // beauty score of [0, i] incomplete + [i+1, n) complete \\n            // = full * (n-i-1) + partial * maxPartialWeight\\n            ans = std::max(ans, (long long)full * (n-1-i) + (long long)partial * l);\\n            avfl -= target - flowers[i];\\n        }\\n        // all-complete case\\n        if (avfl >= 0) ans = std::max(ans, (long long)full * n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nk=2\\nquota=8\\ntarget=10\\nt: binary search through [1, 9]\\n  0|x         |    1\\n  1|xx        |    3\\n  2|xxx       |    6\\n  3|xxx       |    9\\n  4|xxxxx     |    14\\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\nt=5\\n  0|xoooo|    |    1\\n  1|xxoo |    |    3\\n  2|xxxo |    |    6\\n  3|xxxo |    |    9\\n->4|xxxxx|    |    14    5*(4+1)-14=11 (>8)\\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\nt=4\\n  0|xooo|     |    1\\n  1|xxoo|     |    3\\n  2|xxxo|     |    6\\n->3|xxxo|     |    9     4*(3+1)-9=7 (<=8)\\n  4|xxxxx     |    14    \\n  5|xxxxxxoooo|    20\\n  6|xxxxxxxxoo|    28\\n======================================\\n=>score(k=2) = full * k + partial * t\\n             = full * 2 + partial * 4\\n```\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        std::sort(flowers.begin(), flowers.end());\\n        \\n        // construct prefix sum table\\n        vector<long long> presum(1, flowers[0]);\\n        for (int i = 1; i < n; ++i) presum.push_back(presum.back() + flowers[i]);\\n        \\n        // for each iteration, use binary search to find the largest\\n        // partial point of [0, i] given that [i+1, n) can be completed\\n        long long ans = 0, avfl = newFlowers;\\n        for (int i = n - 1; i >= 0 && avfl > 0; --i) {\\n            if (flowers[i] >= target) continue; \\n            \\n            // largest possible partial weight \\n            // must fall between [flowers[0], target - 1]\\n            int l = flowers[0], r = target - 1;\\n            while (l < r) {\\n                int c = l + (r-l+1)/2;\\n                int j = distance(flowers.begin(), prev(upper_bound(flowers.begin(), flowers.begin() + i + 1, c)));\\n                if (avfl < (long long)c * (j+1) - presum[j]) r = c-1;\\n                else l = c;\\n            }\\n            // beauty score of [0, i] incomplete + [i+1, n) complete \\n            // = full * (n-i-1) + partial * maxPartialWeight\\n            ans = std::max(ans, (long long)full * (n-1-i) + (long long)partial * l);\\n            avfl -= target - flowers[i];\\n        }\\n        // all-complete case\\n        if (avfl >= 0) ans = std::max(ans, (long long)full * n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933397,
                "title": "n-logn-2-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int par) {\\n        int n=flowers.size();\\n        vector<long long>flower;\\n        for(auto it:flowers)\\n            flower.push_back(it);\\n        sort(flower.begin(),flower.end());\\n         int r;\\n          int k=0;\\n        long long used=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(flower[i]<1LL*target)\\n            {\\n                r=i;break;\\n            }\\n            else\\n                k++;\\n        }\\n        long long res=0;\\n        vector<long long>prem(n),pre(n);\\n        \\n        prem[0]=flower[0];\\n        pre[0]=flower[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1]+flower[i];\\n            prem[i]=min(prem[i],flower[i]);\\n        }\\n        \\n        for(int i=r;i>=0;i--)\\n        {\\n            \\n            long long l=prem[i],hi=target-1,ans=-1,mid;\\n            while(l<=hi)\\n            {\\n                mid=l+(hi-l)/2;\\n                long long va=0;\\n                   if(flower[0]<mid)\\n                   {\\n                    int j=upper_bound(flower.begin(),flower.begin()+(n-k),mid)-flower.begin();\\n                       \\n                    va=(1LL*j*mid)-pre[j-1];   \\n                   }\\n                if(va<=newFlowers-used)\\n                {\\n                    ans=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                    hi=mid-1;\\n            }\\n           if(ans!=-1)\\n           {               \\n               long long val=1LL*k*full+1LL*ans*par;\\n               res=max(res,val);\\n           }\\n            used+=abs(flower[i]-1LL*target);\\n            k++;  \\n        }\\n        if(used<=newFlowers)\\n        {\\n            res=max(res,1LL*n*full);\\n        }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int par) {\\n        int n=flowers.size();\\n        vector<long long>flower;\\n        for(auto it:flowers)\\n            flower.push_back(it);\\n        sort(flower.begin(),flower.end());\\n         int r;\\n          int k=0;\\n        long long used=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(flower[i]<1LL*target)\\n            {\\n                r=i;break;\\n            }\\n            else\\n                k++;\\n        }\\n        long long res=0;\\n        vector<long long>prem(n),pre(n);\\n        \\n        prem[0]=flower[0];\\n        pre[0]=flower[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1]+flower[i];\\n            prem[i]=min(prem[i],flower[i]);\\n        }\\n        \\n        for(int i=r;i>=0;i--)\\n        {\\n            \\n            long long l=prem[i],hi=target-1,ans=-1,mid;\\n            while(l<=hi)\\n            {\\n                mid=l+(hi-l)/2;\\n                long long va=0;\\n                   if(flower[0]<mid)\\n                   {\\n                    int j=upper_bound(flower.begin(),flower.begin()+(n-k),mid)-flower.begin();\\n                       \\n                    va=(1LL*j*mid)-pre[j-1];   \\n                   }\\n                if(va<=newFlowers-used)\\n                {\\n                    ans=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                    hi=mid-1;\\n            }\\n           if(ans!=-1)\\n           {               \\n               long long val=1LL*k*full+1LL*ans*par;\\n               res=max(res,val);\\n           }\\n            used+=abs(flower[i]-1LL*target);\\n            k++;  \\n        }\\n        if(used<=newFlowers)\\n        {\\n            res=max(res,1LL*n*full);\\n        }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933197,
                "title": "java-neat-code-binary-search",
                "content": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n        long[] cost = new long[flowers.length + 1];\\n        long[] preSum = new long[flowers.length + 1];\\n        for (int i = 0; i < flowers.length; i++) {\\n            cost[i + 1] = cost[i] + Math.max(target - flowers[i], 0);\\n            preSum[i + 1] = preSum[i] + flowers[i];\\n        }\\n        if (flowers[0] >= target) {\\n            return (long)full * flowers.length;\\n        }\\n        long ans = 0;\\n        if (cost[flowers.length] - cost[0] <= newFlowers) {\\n            ans = (long)full * flowers.length;\\n        }\\n        for (int i = 0; i < flowers.length && flowers[i] < target; i++) {\\n            if (cost[flowers.length] - cost[i + 1] > newFlowers) continue;\\n            long remain = newFlowers - cost[flowers.length] + cost[i + 1];\\n            int left = 0, right = i;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                if (remain >= (long)(mid + 1) * flowers[mid] - preSum[mid + 1]){\\n                    left = mid + 1;\\n                }else {\\n                    right = mid - 1;\\n                }\\n            }\\n            long part = Math.min(flowers[right] + (remain - (long)flowers[right] * (right + 1) + preSum[right + 1]) / (right + 1), target - 1);\\n            ans = Math.max(ans, part * partial + (long)full * (flowers.length - i - 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n        long[] cost = new long[flowers.length + 1];\\n        long[] preSum = new long[flowers.length + 1];\\n        for (int i = 0; i < flowers.length; i++) {\\n            cost[i + 1] = cost[i] + Math.max(target - flowers[i], 0);\\n            preSum[i + 1] = preSum[i] + flowers[i];\\n        }\\n        if (flowers[0] >= target) {\\n            return (long)full * flowers.length;\\n        }\\n        long ans = 0;\\n        if (cost[flowers.length] - cost[0] <= newFlowers) {\\n            ans = (long)full * flowers.length;\\n        }\\n        for (int i = 0; i < flowers.length && flowers[i] < target; i++) {\\n            if (cost[flowers.length] - cost[i + 1] > newFlowers) continue;\\n            long remain = newFlowers - cost[flowers.length] + cost[i + 1];\\n            int left = 0, right = i;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                if (remain >= (long)(mid + 1) * flowers[mid] - preSum[mid + 1]){\\n                    left = mid + 1;\\n                }else {\\n                    right = mid - 1;\\n                }\\n            }\\n            long part = Math.min(flowers[right] + (remain - (long)flowers[right] * (right + 1) + preSum[right + 1]) / (right + 1), target - 1);\\n            ans = Math.max(ans, part * partial + (long)full * (flowers.length - i - 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932699,
                "title": "c-binary-search-greedy-dp-explained-approach",
                "content": "Approach\\n\\n\\t- sort flowers in descending order\\n    - calculate postfix array for every element:\\n    - for any element i, postfix[i] = minimum number of flowers needed to plant the graden from i to n-1 with a minimum of flowers[i] flowers in each garden from i to n-1.\\n    - take every flower from i = 0:\\n\\t\\t\\t2cases: - considering 0 to i as full garden\\n\\t\\t\\t\\t\\t- only considering 0 to i-1 as full garden;\\n    \\n\\t\\t\\tupdate the ans.\\n    - return ans;\\n\\n\\n***Time complexity**: O(nlogn).*\\n\\n\\n**Solution Code:**\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<long long>& postfix, int l, int r, long long newFlowers) {\\n        while (l<=r) {\\n            int mid = (l+r)/2;\\n            if (postfix[mid] > newFlowers)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int n = flowers.size();\\n        \\n        vector<long long> postfix(n, 0);\\n        for (int i=n-2; i>=0; i--)\\n            postfix[i] = postfix[i+1] + (flowers[i] - flowers[i+1])*(n-1-i);\\n            \\n        long long ans = 0;\\n        for (int i=0; i<n; i++) {\\n            if (flowers[i] >= target)\\n                continue;\\n            \\n            int requi = target - flowers[i];\\n            \\n            //if we don\\'t want to full the requirement to make the flower full i.e. to exceed its count by target\\n            int k = binarySearch(postfix, i, n-1, newFlowers);\\n            int curr_flower_count = target-1 < flowers[k] + (newFlowers-postfix[k])/(n-k) ? target-1\\n                                        : flowers[k] + (newFlowers-postfix[k])/(n-k);\\n            \\n            ans = ans > long(i)*full + long(partial)*curr_flower_count ? ans\\n                                        : long(i)*full + long(partial)*curr_flower_count;\\n            \\n            //otherwise, proceed with making the flower full\\n            if (requi <= newFlowers)\\n                newFlowers -= requi;\\n            else\\n                break;\\n            \\n            if (i == n-1)\\n                ans = ans > long(n)*full? ans: long(n)*full;\\n        }\\n        \\n        if (ans == 0)\\n            return long(full)*n;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<long long>& postfix, int l, int r, long long newFlowers) {\\n        while (l<=r) {\\n            int mid = (l+r)/2;\\n            if (postfix[mid] > newFlowers)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int n = flowers.size();\\n        \\n        vector<long long> postfix(n, 0);\\n        for (int i=n-2; i>=0; i--)\\n            postfix[i] = postfix[i+1] + (flowers[i] - flowers[i+1])*(n-1-i);\\n            \\n        long long ans = 0;\\n        for (int i=0; i<n; i++) {\\n            if (flowers[i] >= target)\\n                continue;\\n            \\n            int requi = target - flowers[i];\\n            \\n            //if we don\\'t want to full the requirement to make the flower full i.e. to exceed its count by target\\n            int k = binarySearch(postfix, i, n-1, newFlowers);\\n            int curr_flower_count = target-1 < flowers[k] + (newFlowers-postfix[k])/(n-k) ? target-1\\n                                        : flowers[k] + (newFlowers-postfix[k])/(n-k);\\n            \\n            ans = ans > long(i)*full + long(partial)*curr_flower_count ? ans\\n                                        : long(i)*full + long(partial)*curr_flower_count;\\n            \\n            //otherwise, proceed with making the flower full\\n            if (requi <= newFlowers)\\n                newFlowers -= requi;\\n            else\\n                break;\\n            \\n            if (i == n-1)\\n                ans = ans > long(n)*full? ans: long(n)*full;\\n        }\\n        \\n        if (ans == 0)\\n            return long(full)*n;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932476,
                "title": "prefix-sum-bisection-search-in-rust",
                "content": "```\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::cmp::Ordering;\\n\\npub fn upper_bound<T: PartialOrd>(arr: &[T], target: T) -> usize {\\n    let mut l = 0;\\n    let mut r = arr.len();\\n    while l<r {\\n        let m = (l+r)/2;\\n        let v = unsafe {arr.get_unchecked(m)};\\n        if *v <= target {\\n            l = m + 1;\\n        }else{ //v > target\\n            r = m;\\n        }\\n    }\\n    //l==r\\n    l\\n}\\n\\npub fn lower_bound<T: PartialOrd>(arr: &[T], target: T) -> usize {\\n    let mut l = 0;\\n    let mut r = arr.len();\\n    while l<r {\\n        let m = (l+r)/2;\\n        let v = unsafe{arr.get_unchecked(m)};\\n        if *v >= target {\\n            r = m;\\n        }else{ //v < target\\n            l = m+1;\\n        }\\n    }\\n    //l==r\\n    l\\n}\\n\\nimpl Solution {\\n    pub fn maximum_beauty(mut flowers: Vec<i32>, new_flowers: i64, target: i32, full: i32, partial: i32) -> i64 {\\n        \\n        /*\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 10), 5);\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 45), 6);\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 9), 2);\\n        \\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 9), 2);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 10), 2);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 45), 5);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 0), 0);\\n        assert_eq!(lower_bound(&[10], 11), 1);\\n        assert_eq!(lower_bound(&[], 11), 0);\\n        */\\n        \\n        //low to high\\n        flowers.sort();\\n        \\n        let ll = flowers.len();\\n        \\n        let mut arr = vec![0i64; ll];\\n        \\n        let mut prev_v = 0i64;\\n        for (i,v) in flowers.iter().enumerate() {\\n            arr[i] = i as i64 * (*v as i64-prev_v) as i64;\\n            prev_v = *v as i64;\\n            \\n            //prefix sum to enable bisection for incomplete gardens\\n            if i > 0 {\\n                arr[i] += arr[i-1];\\n            }\\n        }\\n        \\n        //prefix sum to enable bisection for incomplete gardens\\n        //let arr = arr.iter().scan(0, |sum, i| {*sum += i; Some(*sum)}).collect::<Vec<_>>();\\n        \\n        let mut best = 0i64;\\n        let mut left = new_flowers as i64;\\n        \\n        for i in (0..=ll).rev(){\\n            \\n             if i < ll {\\n                let v = flowers[i];    \\n                //amount to reach complete garden\\n                let need_to_target = max(target - v, 0i32);\\n                if need_to_target as i64 <= left {\\n                    left -= need_to_target as i64;\\n                }else{\\n                    //not enough\\n                    break;\\n                }\\n            }\\n            \\n            //try fill incomplete gardens\\n            let mut num_incomplete = upper_bound(&arr[..i], left as i64);\\n            \\n            //bound to be < target in order to qualify as incomplete garden, search for last item in sorted order that is smaller than target\\n            let bound_idx = lower_bound(&flowers[..num_incomplete], target); \\n            let found = \\n            if bound_idx > 0 {\\n                debug_assert!(flowers[bound_idx-1] < target);\\n                num_incomplete = bound_idx;\\n                true\\n            }else{\\n                false\\n            };\\n           \\n            let min_flowers = \\n            if !found {\\n                0i64\\n            }else{\\n                let idx = num_incomplete - 1;\\n                let accum = arr[idx];\\n                let remain = left as i64 - accum;\\n                let distribute_remain = remain / num_incomplete as i64;\\n                let min_flowers = flowers[idx] as i64 + distribute_remain;\\n                min(min_flowers, target as i64 - 1i64)\\n            };\\n            \\n            //cal score\\n            let num_complete = if i==ll { 0 } else { ll - i };\\n            let score = num_complete as i64 * full as i64 + min_flowers * partial as i64;\\n            best = max(best, score);        \\n        }\\n        best\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::cmp::Ordering;\\n\\npub fn upper_bound<T: PartialOrd>(arr: &[T], target: T) -> usize {\\n    let mut l = 0;\\n    let mut r = arr.len();\\n    while l<r {\\n        let m = (l+r)/2;\\n        let v = unsafe {arr.get_unchecked(m)};\\n        if *v <= target {\\n            l = m + 1;\\n        }else{ //v > target\\n            r = m;\\n        }\\n    }\\n    //l==r\\n    l\\n}\\n\\npub fn lower_bound<T: PartialOrd>(arr: &[T], target: T) -> usize {\\n    let mut l = 0;\\n    let mut r = arr.len();\\n    while l<r {\\n        let m = (l+r)/2;\\n        let v = unsafe{arr.get_unchecked(m)};\\n        if *v >= target {\\n            r = m;\\n        }else{ //v < target\\n            l = m+1;\\n        }\\n    }\\n    //l==r\\n    l\\n}\\n\\nimpl Solution {\\n    pub fn maximum_beauty(mut flowers: Vec<i32>, new_flowers: i64, target: i32, full: i32, partial: i32) -> i64 {\\n        \\n        /*\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 10), 5);\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 45), 6);\\n        assert_eq!(upper_bound(&[5,7,10,10,10,45], 9), 2);\\n        \\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 9), 2);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 10), 2);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 45), 5);\\n        assert_eq!(lower_bound(&[5,7,10,10,10,45], 0), 0);\\n        assert_eq!(lower_bound(&[10], 11), 1);\\n        assert_eq!(lower_bound(&[], 11), 0);\\n        */\\n        \\n        //low to high\\n        flowers.sort();\\n        \\n        let ll = flowers.len();\\n        \\n        let mut arr = vec![0i64; ll];\\n        \\n        let mut prev_v = 0i64;\\n        for (i,v) in flowers.iter().enumerate() {\\n            arr[i] = i as i64 * (*v as i64-prev_v) as i64;\\n            prev_v = *v as i64;\\n            \\n            //prefix sum to enable bisection for incomplete gardens\\n            if i > 0 {\\n                arr[i] += arr[i-1];\\n            }\\n        }\\n        \\n        //prefix sum to enable bisection for incomplete gardens\\n        //let arr = arr.iter().scan(0, |sum, i| {*sum += i; Some(*sum)}).collect::<Vec<_>>();\\n        \\n        let mut best = 0i64;\\n        let mut left = new_flowers as i64;\\n        \\n        for i in (0..=ll).rev(){\\n            \\n             if i < ll {\\n                let v = flowers[i];    \\n                //amount to reach complete garden\\n                let need_to_target = max(target - v, 0i32);\\n                if need_to_target as i64 <= left {\\n                    left -= need_to_target as i64;\\n                }else{\\n                    //not enough\\n                    break;\\n                }\\n            }\\n            \\n            //try fill incomplete gardens\\n            let mut num_incomplete = upper_bound(&arr[..i], left as i64);\\n            \\n            //bound to be < target in order to qualify as incomplete garden, search for last item in sorted order that is smaller than target\\n            let bound_idx = lower_bound(&flowers[..num_incomplete], target); \\n            let found = \\n            if bound_idx > 0 {\\n                debug_assert!(flowers[bound_idx-1] < target);\\n                num_incomplete = bound_idx;\\n                true\\n            }else{\\n                false\\n            };\\n           \\n            let min_flowers = \\n            if !found {\\n                0i64\\n            }else{\\n                let idx = num_incomplete - 1;\\n                let accum = arr[idx];\\n                let remain = left as i64 - accum;\\n                let distribute_remain = remain / num_incomplete as i64;\\n                let min_flowers = flowers[idx] as i64 + distribute_remain;\\n                min(min_flowers, target as i64 - 1i64)\\n            };\\n            \\n            //cal score\\n            let num_complete = if i==ll { 0 } else { ll - i };\\n            let score = num_complete as i64 * full as i64 + min_flowers * partial as i64;\\n            best = max(best, score);        \\n        }\\n        best\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931864,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        sort(flowers.rbegin(), flowers.rend());\\n        int ps = 0;\\n        int complete = 0;\\n        while (ps < n && flowers[ps] >= target) {\\n            ++complete;\\n            ++ps;\\n        }\\n        if (ps == n) return (long long) n * full;\\n        vector<long long> req(n);\\n        long long sum = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            sum += flowers[i];\\n            long long rsum = (long long) flowers[i] * (n - i);\\n            req[i] = rsum - sum;\\n        }\\n        long long sol = 0;\\n        auto get = [&] (int low) -> pair<long long, long long> {\\n            int high = n - 1;\\n            int pos = n - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if (req[mid] <= newFlowers) {\\n                    pos = mid;\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n            return make_pair(pos, req[pos]);\\n        };\\n        for (int i = ps; i < n; i++) {\\n            pair<long long, long long> p = get(i);\\n            long long rest = newFlowers - p.second;\\n            long long tot = flowers[p.first] + rest / (n - p.first);\\n            tot = min(tot, (long long) target - 1);\\n            long long val = (long long) complete * full;\\n            val += (long long) partial * tot;\\n            sol = max(sol, val);\\n            if (target - flowers[i] <= newFlowers) {\\n                newFlowers -= target - flowers[i];\\n                ++complete;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        if (complete == n) {\\n            sol = max(sol, (long long) n * full);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        sort(flowers.rbegin(), flowers.rend());\\n        int ps = 0;\\n        int complete = 0;\\n        while (ps < n && flowers[ps] >= target) {\\n            ++complete;\\n            ++ps;\\n        }\\n        if (ps == n) return (long long) n * full;\\n        vector<long long> req(n);\\n        long long sum = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            sum += flowers[i];\\n            long long rsum = (long long) flowers[i] * (n - i);\\n            req[i] = rsum - sum;\\n        }\\n        long long sol = 0;\\n        auto get = [&] (int low) -> pair<long long, long long> {\\n            int high = n - 1;\\n            int pos = n - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if (req[mid] <= newFlowers) {\\n                    pos = mid;\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n            return make_pair(pos, req[pos]);\\n        };\\n        for (int i = ps; i < n; i++) {\\n            pair<long long, long long> p = get(i);\\n            long long rest = newFlowers - p.second;\\n            long long tot = flowers[p.first] + rest / (n - p.first);\\n            tot = min(tot, (long long) target - 1);\\n            long long val = (long long) complete * full;\\n            val += (long long) partial * tot;\\n            sol = max(sol, val);\\n            if (target - flowers[i] <= newFlowers) {\\n                newFlowers -= target - flowers[i];\\n                ++complete;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        if (complete == n) {\\n            sol = max(sol, (long long) n * full);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931790,
                "title": "sort-and-then-linear-greedy",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        ll baseline = 0;\\n        while (!flowers.empty() && flowers.back() >= target) {\\n            baseline += full;\\n            flowers.pop_back();\\n        }\\n\\n        ll best = 0;\\n        ll water_level = 0;  // value of the minimum partial garden.\\n        ll water_width = 0;  // number of such gardens.\\n        deque<ll> pending;  // non-minimum partial gardens.\\n        \\n        // In each iteration, try to use the budget below to increase water_level.\\n        // Budget could be negative, indicating the scenario is invalid as we couldn\\'t make that many gardens \\'full\\'.\\n        ll budget = newFlowers;\\n        for (int x : flowers) {\\n            budget -= (target - x);\\n        }\\n\\n        for (int num_partials = 0; num_partials <= flowers.size(); num_partials++) {\\n            if (budget >= 0) {\\n                ll full_sum = (ll)full * (flowers.size() - num_partials);\\n                ll partial_sum = water_level * partial;\\n                ll cur = full_sum + partial_sum;\\n                best = max(best, cur);\\n            }\\n            if (num_partials == flowers.size()) break;\\n            \\n            pending.push_back(flowers[num_partials]);\\n            budget += target - flowers[num_partials];\\n            \\n            while (budget > 0) {\\n                ll next_water_level = min<ll>(pending.empty() ? target - 1 : pending.front(), water_width == 0 ? INT32_MAX : water_level + (budget / water_width));\\n                budget -= (next_water_level - water_level) * water_width;\\n                water_level = next_water_level;\\n                bool consumed = false;\\n                while (!pending.empty() && pending.front() == water_level) {\\n                    water_width++;\\n                    pending.pop_front();\\n                    consumed = true;\\n                }\\n                if (water_level == target - 1 || !consumed) break;\\n            }\\n        }\\n        return best + baseline;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        ll baseline = 0;\\n        while (!flowers.empty() && flowers.back() >= target) {\\n            baseline += full;\\n            flowers.pop_back();\\n        }\\n\\n        ll best = 0;\\n        ll water_level = 0;  // value of the minimum partial garden.\\n        ll water_width = 0;  // number of such gardens.\\n        deque<ll> pending;  // non-minimum partial gardens.\\n        \\n        // In each iteration, try to use the budget below to increase water_level.\\n        // Budget could be negative, indicating the scenario is invalid as we couldn\\'t make that many gardens \\'full\\'.\\n        ll budget = newFlowers;\\n        for (int x : flowers) {\\n            budget -= (target - x);\\n        }\\n\\n        for (int num_partials = 0; num_partials <= flowers.size(); num_partials++) {\\n            if (budget >= 0) {\\n                ll full_sum = (ll)full * (flowers.size() - num_partials);\\n                ll partial_sum = water_level * partial;\\n                ll cur = full_sum + partial_sum;\\n                best = max(best, cur);\\n            }\\n            if (num_partials == flowers.size()) break;\\n            \\n            pending.push_back(flowers[num_partials]);\\n            budget += target - flowers[num_partials];\\n            \\n            while (budget > 0) {\\n                ll next_water_level = min<ll>(pending.empty() ? target - 1 : pending.front(), water_width == 0 ? INT32_MAX : water_level + (budget / water_width));\\n                budget -= (next_water_level - water_level) * water_width;\\n                water_level = next_water_level;\\n                bool consumed = false;\\n                while (!pending.empty() && pending.front() == water_level) {\\n                    water_width++;\\n                    pending.pop_front();\\n                    consumed = true;\\n                }\\n                if (water_level == target - 1 || !consumed) break;\\n            }\\n        }\\n        return best + baseline;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931535,
                "title": "java-binary-search-solution-with-code-comments",
                "content": "**Intution** : \\nThe overall value depends on 2 things : \\n        (i) The number of complete gardens : For this, we can increment the counter.\\n\\t\\t(ii) The minimum flowers present in all of the partial gardens : For this, we try to increase the minimum number of flowers present in a partial Garden.\\n\\t\\t\\n\\t\\tclass Solution {\\n    \\n     Returns the index of the first Element which is smaller than val.\\n      sIdx <= index <= eIdx \\n    \\n    public int getIndex(int[] arr,int sIdx,int eIdx,long val){\\n        int ans = eIdx;\\n        while(sIdx <= eIdx){\\n            int mid = sIdx + (eIdx - sIdx)/2;\\n            if(arr[mid] < val){\\n                ans = mid;\\n                sIdx = mid + 1;\\n            }else{\\n                eIdx = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n    public long maximumBeauty(int[] flowers, long newFlowers, int _target, int _full, int _partial) {\\n        long[] cumsum = new long[flowers.length];                   //Store the cummulative sum.\\n        Arrays.sort(flowers);\\n        cumsum[0] = flowers[0];\\n        long complete = 0;\\n        long partial_c = 0;\\n        long target = (long)_target;\\n        long full = (long)_full;\\n        long partial = (long)_partial;\\n        int index = 0;\\n        if(flowers[0] < target) partial_c++;\\n        if(flowers[0] >= target)complete++;\\n        for(int i = 1;i<flowers.length;i++){\\n            cumsum[i] = cumsum[i - 1] + (long)flowers[i];\\n            if(flowers[i] >= target){\\n                complete++;\\n            }\\n            else {\\n                index = Math.max(i,index);                            //Finding the Maximum index whoose value lies below target.  \\n                partial_c++;\\n            }\\n        \\n        }\\n        //Intution : \\n        // The overall value depends on 2 things : \\n        // (i) The number of complete gardens : For this, we can increment the counter.\\n        // (ii) The minimum flowers present in all of the partial gardens : For this, we try to increase the minimum number of flowers present in a partial Garden.\\n        //     \\n        long ans = full*complete;\\n        if(partial_c > 0){                                              // If there is at least one partially filled Garden.\\n            long lo = flowers[0];                                       // The least value for the minimum value in a partial Garden.\\n            long hi = target - 1;                                       // The maximum possible value of a garden without making it a complete Garden.\\n            while(lo <= hi){\\n                long mid = lo + (hi - lo)/2;\\n                //Calculate the First Flower that is less than mid : \\n                int myIdx = getIndex(flowers,0,index,mid);              //Fetch the index of first garden whoose number of flowers < mid.\\n                long t_required = mid*(myIdx + 1) - cumsum[myIdx];      //Calculate the required number of flowers to make the number of flowers in partial garden at least mid.\\n                if(t_required <= newFlowers){                           //If there are enough flowers.\\n                    ans = Math.max(ans, full*complete + mid*partial);   //Store for a probable answer.\\n                    lo = mid + 1;                                       //Try to increase the minimum value of all partial Gardens that is possible by the Garden.\\n                }else{\\n                    hi = mid - 1;\\n                }\\n            }\\n        }\\n        if(index==0)return ans;\\n        for(int i = index;i>=0;i--){\\n            long calc = 0;\\n            long diff = target - flowers[i];                            //Number of flowers required to convert the Garden[i] to complete Garden.\\n            if(diff > newFlowers)break;                                 //Not enough flowers. Break\\n            newFlowers -= diff;                                         //reduce the number of Flowers Left.\\n            complete++;                                                 //Increase the number of complete Gardens.\\n            calc += full*complete;\\n            if(i==0){\\n                ans = Math.max(ans,calc);\\n                break;\\n            }                                                           // If there is at least one partially filled Garden.\\n            long lo = flowers[0];                                       // The least value for the minimum value in a partial Garden.\\n            long hi = target - 1;                                       // The maximum possible value of a garden without making it a complete Garden.\\n            while(lo <= hi){                                \\n                long mid = lo + (hi - lo)/2;\\n                //Calculate the First Flower that is less than mid : \\n                int myIdx = getIndex(flowers,0,i - 1,mid);\\n                long t_required = mid*(myIdx + 1) - cumsum[myIdx];\\n                if(t_required <= newFlowers){\\n                    ans = Math.max(ans, calc + mid*partial);\\n                    lo = mid + 1;\\n                }else{\\n                    hi = mid - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    \\n     Returns the index of the first Element which is smaller than val.\\n      sIdx <= index <= eIdx \\n    \\n    public int getIndex(int[] arr,int sIdx,int eIdx,long val){\\n        int ans = eIdx;\\n        while(sIdx <= eIdx){\\n            int mid = sIdx + (eIdx - sIdx)/2;\\n            if(arr[mid] < val){\\n                ans = mid;\\n                sIdx = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1931259,
                "title": "python-an-o-n-logn-log-n-solution",
                "content": "the basic idea is to test for every possible complete garden number\\nfrom [(already complete) to (garden cnts)]\\nfor example with [1,2,3,4,5,5], target is 5,we need to make i=3 complete garder\\nwe should construct 1 extra complete garden\\nthe cheapest choice is make [4] to [5],(we can use accumulate to cal the cost)\\nif cost>newFlowers,we just break\\n\\nnow we still have (newFlowers-cost) flower\\nto make [1,2,3] in-compelte (no more than target-1 flower)\\nbut [maximize the smallest number] with (newFlowers-cost) flowers\\nwe can use binary search to find it in range [0,target-1]\\n\\nfor the test value {mid},we validate it as follows :\\nlet\\'s say we test how much we need to make the minium 2,(mid=2):\\n\\nany garden with flowers>=2 is not need plant,we can use bisect_left to find the index\\nso,[2,3]  not need no more flower\\nthe previous gardens [1] need  (mid*len-acc[len]) more flowers\\nin this example we need 1 more flowers\\njust compare it with (newFlowers-cost).\\n\\n\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n        flowers.sort()\\n        acc = [0] + list(accumulate(flowers))\\n        n = len(flowers)\\n\\n        def findwith(i, v):\\n            # make [0,i] as incomplete gardens\\n            # return the maxium-minium number with v extra flower\\n            if i < 0:\\n                return 0\\n            if v == 0:\\n                return flowers[0]\\n            l = 0\\n            r = target - 1 # the minium we need no more than target-1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                j = min(i + 1,bisect.bisect_left(flowers, mid))\\n                #for flower greater than mid, we don\\'t need to plant more flowers\\n                #to make [0,j] all equal to mid,we need (mid * (j) - acc[j]) flowers\\n                if mid * (j) - acc[j] <= v:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            return l - 1\\n\\n        ans = 0\\n        j = bisect.bisect_left(flowers, target)\\n        # how many gardens is already complete,(n - j)\\n        for i in range(n-j,n + 1):\\n            # make i complete gardens\\n            # (more) garden we need to construct i complete gardens\\n            more = i - (n - j)\\n            need = target * more - (acc[j] - acc[j - more])\\n            # {need} is flowers need for {more} complete gardens\\n            if need > newFlowers:\\n                break #no need to make more complete gardens\\n            mval = findwith(j - more - 1, newFlowers - need)\\n            #get the max-minium value with  {newFlowers - need} flowers\\n            ans = max(ans, full * i + mval * partial)\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n        flowers.sort()\\n        acc = [0] + list(accumulate(flowers))\\n        n = len(flowers)\\n\\n        def findwith(i, v):\\n            # make [0,i] as incomplete gardens\\n            # return the maxium-minium number with v extra flower\\n            if i < 0:\\n                return 0\\n            if v == 0:\\n                return flowers[0]\\n            l = 0\\n            r = target - 1 # the minium we need no more than target-1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                j = min(i + 1,bisect.bisect_left(flowers, mid))\\n                #for flower greater than mid, we don\\'t need to plant more flowers\\n                #to make [0,j] all equal to mid,we need (mid * (j) - acc[j]) flowers\\n                if mid * (j) - acc[j] <= v:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            return l - 1\\n\\n        ans = 0\\n        j = bisect.bisect_left(flowers, target)\\n        # how many gardens is already complete,(n - j)\\n        for i in range(n-j,n + 1):\\n            # make i complete gardens\\n            # (more) garden we need to construct i complete gardens\\n            more = i - (n - j)\\n            need = target * more - (acc[j] - acc[j - more])\\n            # {need} is flowers need for {more} complete gardens\\n            if need > newFlowers:\\n                break #no need to make more complete gardens\\n            mval = findwith(j - more - 1, newFlowers - need)\\n            #get the max-minium value with  {newFlowers - need} flowers\\n            ans = max(ans, full * i + mval * partial)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931087,
                "title": "c-soln-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int full_cnt = 0;\\n        for(int i = flowers.size() - 1; i >= 0; i--) {\\n            if(flowers[i] < target) break;\\n            full_cnt++;\\n        }\\n        int n = flowers.size() - full_cnt;\\n        if(n == 0) return (long long)full_cnt * (long long)full;\\n        \\n        vector<long long> fill_up(n, 0), fill_target(n, 0);\\n        \\n        // fill_up: flowers needed to get min of flowers to flowers[i]\\n        fill_up[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            fill_up[i] = (flowers[i] - flowers[i-1]) * (long long)i + fill_up[i-1];\\n        }\\n        // fill_target[i] fill flowers[i] to flowers[n-1] to target level\\n        fill_target[n-1] = (long long) target - flowers[n-1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            fill_target[i] = fill_target[i+1] + (long long)(target - flowers[i]); \\n        }\\n        long long ret = 0;\\n        for(int num_fill = 0; num_fill <= n; num_fill++) {\\n            long long m = 0;\\n            long long rm = newFlowers;\\n            if(num_fill != 0) {\\n                rm -= fill_target[n-num_fill];\\n            }\\n            if(rm < 0) break;\\n            if(num_fill != n) {\\n                auto ptr = upper_bound(fill_up.begin(), fill_up.end(), rm);\\n                // can get min to flowers[idx-1] level, but not flowers[idx] level\\n                int idx = ptr - fill_up.begin();\\n                if(idx >= n - num_fill) idx = n - num_fill;\\n                m = flowers[idx - 1];\\n                m += (rm - fill_up[idx - 1]) / idx; \\n                m = min(m, (long long)target - 1);\\n            }\\n            long long tmp = m * (long long) partial + (full_cnt + num_fill) * (long long) full;\\n            ret = max(tmp, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int full_cnt = 0;\\n        for(int i = flowers.size() - 1; i >= 0; i--) {\\n            if(flowers[i] < target) break;\\n            full_cnt++;\\n        }\\n        int n = flowers.size() - full_cnt;\\n        if(n == 0) return (long long)full_cnt * (long long)full;\\n        \\n        vector<long long> fill_up(n, 0), fill_target(n, 0);\\n        \\n        // fill_up: flowers needed to get min of flowers to flowers[i]\\n        fill_up[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            fill_up[i] = (flowers[i] - flowers[i-1]) * (long long)i + fill_up[i-1];\\n        }\\n        // fill_target[i] fill flowers[i] to flowers[n-1] to target level\\n        fill_target[n-1] = (long long) target - flowers[n-1];\\n        for(int i = n - 2; i >= 0; i--) {\\n            fill_target[i] = fill_target[i+1] + (long long)(target - flowers[i]); \\n        }\\n        long long ret = 0;\\n        for(int num_fill = 0; num_fill <= n; num_fill++) {\\n            long long m = 0;\\n            long long rm = newFlowers;\\n            if(num_fill != 0) {\\n                rm -= fill_target[n-num_fill];\\n            }\\n            if(rm < 0) break;\\n            if(num_fill != n) {\\n                auto ptr = upper_bound(fill_up.begin(), fill_up.end(), rm);\\n                // can get min to flowers[idx-1] level, but not flowers[idx] level\\n                int idx = ptr - fill_up.begin();\\n                if(idx >= n - num_fill) idx = n - num_fill;\\n                m = flowers[idx - 1];\\n                m += (rm - fill_up[idx - 1]) / idx; \\n                m = min(m, (long long)target - 1);\\n            }\\n            long long tmp = m * (long long) partial + (full_cnt + num_fill) * (long long) full;\\n            ret = max(tmp, ret);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895320,
                "title": "python3-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We will sort the gardens to have the small values in front and big values in the end.\\n- We will first remove as many full gardens as possible.\\n- We will then spend all the remaining newFlowers to increase the minimum\\n- We will then return the removed gardens one by one and repeat the previous step to find the max beauty at each step.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: nlogn\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n\\n        flowers.sort()\\n\\n        #Remove all already full gardens\\n        count = 0\\n        while flowers and flowers[-1] >= target:\\n            count += 1\\n            flowers.pop()\\n\\n        #Complete as many gardens as possible\\n        stack = []\\n        while flowers and newFlowers >= target - flowers[-1]:\\n            stack.append(max(0, target - flowers.pop()))\\n            newFlowers -= stack[-1]\\n        \\n        mini = 0\\n        i = 0\\n        #Spend all available newFlowers \\n        if flowers:\\n            while i < len(flowers) and (flowers[i] - mini) * i <= newFlowers:\\n                newFlowers -= (flowers[i] - mini) * i\\n                mini = flowers[i]\\n                i += 1\\n            mini += newFlowers // i\\n            newFlowers %= i\\n        \\n        #Max beauty\\n        maxi = (count + len(stack)) * full + mini * partial\\n\\n        while stack:\\n\\n            #Unplant flowers from one of the completed gardens\\n            newFlowers += stack[-1]\\n            flowers.append(target - stack.pop())\\n\\n            #Reduce mini to match the added garden if necessary\\n            if flowers[-1] < mini:\\n                newFlowers += i * (mini - flowers[-1])\\n                mini = flowers[-1]\\n\\n            #Spend available newFlowers\\n            while i < len(flowers) and (flowers[i] - mini) * i <= newFlowers:\\n                newFlowers -= (flowers[i] - mini) * i\\n                mini = flowers[i]\\n                i += 1\\n            mini += newFlowers // i\\n            newFlowers %= i\\n\\n            #Update max beauty\\n            maxi = max(maxi, (count + len(stack)) * full + min(mini, target - 1) * partial)\\n        \\n        return maxi\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n\\n        flowers.sort()\\n\\n        #Remove all already full gardens\\n        count = 0\\n        while flowers and flowers[-1] >= target:\\n            count += 1\\n            flowers.pop()\\n\\n        #Complete as many gardens as possible\\n        stack = []\\n        while flowers and newFlowers >= target - flowers[-1]:\\n            stack.append(max(0, target - flowers.pop()))\\n            newFlowers -= stack[-1]\\n        \\n        mini = 0\\n        i = 0\\n        #Spend all available newFlowers \\n        if flowers:\\n            while i < len(flowers) and (flowers[i] - mini) * i <= newFlowers:\\n                newFlowers -= (flowers[i] - mini) * i\\n                mini = flowers[i]\\n                i += 1\\n            mini += newFlowers // i\\n            newFlowers %= i\\n        \\n        #Max beauty\\n        maxi = (count + len(stack)) * full + mini * partial\\n\\n        while stack:\\n\\n            #Unplant flowers from one of the completed gardens\\n            newFlowers += stack[-1]\\n            flowers.append(target - stack.pop())\\n\\n            #Reduce mini to match the added garden if necessary\\n            if flowers[-1] < mini:\\n                newFlowers += i * (mini - flowers[-1])\\n                mini = flowers[-1]\\n\\n            #Spend available newFlowers\\n            while i < len(flowers) and (flowers[i] - mini) * i <= newFlowers:\\n                newFlowers -= (flowers[i] - mini) * i\\n                mini = flowers[i]\\n                i += 1\\n            mini += newFlowers // i\\n            newFlowers %= i\\n\\n            #Update max beauty\\n            maxi = max(maxi, (count + len(stack)) * full + min(mini, target - 1) * partial)\\n        \\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617558,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, long long full, long long partial)  \\n    {\\n        sort(flowers.rbegin(), flowers.rend());\\n        long long l = 0, n=flowers.size();;\\n        while(l < n && flowers[l] >= target) l++;\\n        long long ans = 0;\\n        vector<long long> required(n, 0);\\n        for(long long i = n-2 ; i >= l ; i--){\\n            required[i] = required[i+1] + (n-i-1)*(flowers[i]-flowers[i+1]);\\n        }\\n\\n        long long pre = l*full;\\n        ans = pre;\\n        for(int i = l ; i < n ; i++){\\n            long long part = solve(flowers, required, newFlowers, i, target);\\n            ans = max(ans, pre+part*partial);\\n            if(target-flowers[i] <= newFlowers){\\n                pre += full;\\n                newFlowers -= (target-flowers[i]);\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans = max(ans, pre);\\n    }\\n\\n    long long solve(vector<int>& flowers, vector<long long>& req, long long newFlowers, int ind, long long target){\\n        long long l = ind, r = flowers.size(), n = flowers.size();\\n        long long ans = 0;\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            long long cnt = req[mid];\\n            if(cnt > newFlowers){\\n                l = mid+1;\\n            }else{\\n                ans = flowers[mid] + (newFlowers-cnt)/(n-mid);\\n                r = mid-1;\\n            }\\n        }\\n        return min(ans, target-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, long long full, long long partial)  \\n    {\\n        sort(flowers.rbegin(), flowers.rend());\\n        long long l = 0, n=flowers.size();;\\n        while(l < n && flowers[l] >= target) l++;\\n        long long ans = 0;\\n        vector<long long> required(n, 0);\\n        for(long long i = n-2 ; i >= l ; i--){\\n            required[i] = required[i+1] + (n-i-1)*(flowers[i]-flowers[i+1]);\\n        }\\n\\n        long long pre = l*full;\\n        ans = pre;\\n        for(int i = l ; i < n ; i++){\\n            long long part = solve(flowers, required, newFlowers, i, target);\\n            ans = max(ans, pre+part*partial);\\n            if(target-flowers[i] <= newFlowers){\\n                pre += full;\\n                newFlowers -= (target-flowers[i]);\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans = max(ans, pre);\\n    }\\n\\n    long long solve(vector<int>& flowers, vector<long long>& req, long long newFlowers, int ind, long long target){\\n        long long l = ind, r = flowers.size(), n = flowers.size();\\n        long long ans = 0;\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            long long cnt = req[mid];\\n            if(cnt > newFlowers){\\n                l = mid+1;\\n            }else{\\n                ans = flowers[mid] + (newFlowers-cnt)/(n-mid);\\n                r = mid-1;\\n            }\\n        }\\n        return min(ans, target-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616200,
                "title": "python3-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n\\n        flowers.sort()\\n        n = len(flowers)\\n\\n        # 1: exclude complete gardens\\n        m = bisect.bisect_left(flowers, target)\\n        init = (n - m) * full\\n        \\n        if m == 0:\\n            return init\\n\\n        # 2. pre-processing\\n        need = [0] * m  # to flood till flowers[index], how many more flowers needed\\n        for index in range(1, m):\\n            need[index] = need[index - 1] + index * (flowers[index] - flowers[index - 1])\\n\\n        # gardens are all partials:\\n        ans = self.partial_garden(need, newFlowers, flowers, target, partial, m)\\n        \\n        # 3. loop all possible new complete garden index numbers\\n        for index in range(m - 1, -1, -1):\\n            if newFlowers + flowers[index] < target:\\n                break\\n            else:\\n                newFlowers -= (target - flowers[index]) # fill current \\'index\\' garden to be full\\n            \\n            cur_partial = self.partial_garden(need, newFlowers, flowers, target, partial, index)\\n            \\n            ans = max(ans, cur_partial + full * (m - index))\\n        \\n        return ans + init\\n\\n\\n    def partial_garden(self, nums, newFlowers, flowers, target, partial, ind):\\n        if ind == 0:\\n            return 0\\n        index = bisect.bisect_right(nums, newFlowers)\\n        index = min(index, ind)\\n        min_val = min(target - 1, flowers[index - 1] + (newFlowers - nums[index - 1]) // index)\\n        return min_val * partial\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n\\n        flowers.sort()\\n        n = len(flowers)\\n\\n        # 1: exclude complete gardens\\n        m = bisect.bisect_left(flowers, target)\\n        init = (n - m) * full\\n        \\n        if m == 0:\\n            return init\\n\\n        # 2. pre-processing\\n        need = [0] * m  # to flood till flowers[index], how many more flowers needed\\n        for index in range(1, m):\\n            need[index] = need[index - 1] + index * (flowers[index] - flowers[index - 1])\\n\\n        # gardens are all partials:\\n        ans = self.partial_garden(need, newFlowers, flowers, target, partial, m)\\n        \\n        # 3. loop all possible new complete garden index numbers\\n        for index in range(m - 1, -1, -1):\\n            if newFlowers + flowers[index] < target:\\n                break\\n            else:\\n                newFlowers -= (target - flowers[index]) # fill current \\'index\\' garden to be full\\n            \\n            cur_partial = self.partial_garden(need, newFlowers, flowers, target, partial, index)\\n            \\n            ans = max(ans, cur_partial + full * (m - index))\\n        \\n        return ans + init\\n\\n\\n    def partial_garden(self, nums, newFlowers, flowers, target, partial, ind):\\n        if ind == 0:\\n            return 0\\n        index = bisect.bisect_right(nums, newFlowers)\\n        index = min(index, ind)\\n        min_val = min(target - 1, flowers[index - 1] + (newFlowers - nums[index - 1]) // index)\\n        return min_val * partial\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582524,
                "title": "prefix-sum-binary-search-maths-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Idea is we will sort the flowers and we say ok we have some garden which are alredy full now I have `x` amount of extra flower \\n- so till what we can push the minima of non full garden using `x` amount of flower .\\n- and in each iteration we will increase the number of full garden and naturally now `x` will decrease to `x\\'` and how again we do same thing as above and will calculate the  maxima of all result \\n- we can get intial number of garden >=target using binay search \\n- now main gole is to get till what ciling i can push minima \\n- so for what we need cumilated difference \\n- eg 1 2 3 4 and i want to push minima celing till 3 so i need (1+2)extra flower or `dp[i-1]+flower[i]-flower[i-1]*i` flower.\\n- so now we have cumilated sum dp .\\n- now If I have `x` flower left then till which level I can push \\n- I can push atleast till that level where dp[i] is less than equal to x \\n- eg: dp= 1 2 5 7 and x=4 so I can push till flower[1] and dp[1]<x and after pushing till flower[1] I have some extra flower then I will distrubute rest of flower among `2` flower as i=1;  \\n- same thing in form of code\\n`ll temp = count - dp[j-1];`\\n`ll mini = (temp / j) + flowers[j-1];`\\n`ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + ((n - j) * 1ll * full));`\\n\\nNow just dry run with sample test case U will get the idea and look at code at Once .\\n\\n`FYI:I literlly spend 2 hours on this question nahi hoga nahi hoga to kr k rahunga`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long \\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        sort(flowers.begin(), flowers.end());\\n        vector<ll> dp(n, 0);   \\n\\n        // Calculate the cumulative difference of beauty values\\n        //how much flowers needed to make all j equal to i and j<i;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = dp[i-1] + (flowers[i] - flowers[i-1]) * i;\\n        }\\n\\n        //atleast this any full garden will be there no matter what\\n        int j = lower_bound(flowers.begin(), flowers.end(), target) - flowers.begin();\\n\\n        if (j == 0) {\\n            return n * 1ll * full;\\n        }\\n\\n        ll count = newFlowers;\\n        ll ans = 0;\\n\\n        while (count > 0 && j >= 0) {\\n            int i = upper_bound(dp.begin(), dp.end(), count) - dp.begin();\\n\\n            if (i == 0) {\\n                break;\\n            }\\n\\n            if (i > j) {\\n                if (j == 0) {\\n                    ans = max(ans, (n - j) * 1ll * full);\\n                } else {\\n                    ll temp = count - dp[j-1];\\n                    ll mini = (temp / j) + flowers[j-1];\\n                    ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + ((n - j) * 1ll * full));\\n                }\\n            } else {\\n                ll temp = count - dp[i-1];\\n                ll mini = (temp / i) + flowers[i-1];\\n                ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + (n - j) * 1ll * full);\\n            }\\n\\n            if (j - 1 >= 0) {\\n                count -= target - flowers[j-1];\\n            }\\n\\n            // cout << \"upper \" << j << \" \" << \"lower \" << i << \" \" << ans << \" \" << count << \"\\\\n\";\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long \\n\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n = flowers.size();\\n        sort(flowers.begin(), flowers.end());\\n        vector<ll> dp(n, 0);   \\n\\n        // Calculate the cumulative difference of beauty values\\n        //how much flowers needed to make all j equal to i and j<i;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = dp[i-1] + (flowers[i] - flowers[i-1]) * i;\\n        }\\n\\n        //atleast this any full garden will be there no matter what\\n        int j = lower_bound(flowers.begin(), flowers.end(), target) - flowers.begin();\\n\\n        if (j == 0) {\\n            return n * 1ll * full;\\n        }\\n\\n        ll count = newFlowers;\\n        ll ans = 0;\\n\\n        while (count > 0 && j >= 0) {\\n            int i = upper_bound(dp.begin(), dp.end(), count) - dp.begin();\\n\\n            if (i == 0) {\\n                break;\\n            }\\n\\n            if (i > j) {\\n                if (j == 0) {\\n                    ans = max(ans, (n - j) * 1ll * full);\\n                } else {\\n                    ll temp = count - dp[j-1];\\n                    ll mini = (temp / j) + flowers[j-1];\\n                    ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + ((n - j) * 1ll * full));\\n                }\\n            } else {\\n                ll temp = count - dp[i-1];\\n                ll mini = (temp / i) + flowers[i-1];\\n                ans = max(ans, min(mini, 1ll * target - 1) * 1ll * partial + (n - j) * 1ll * full);\\n            }\\n\\n            if (j - 1 >= 0) {\\n                count -= target - flowers[j-1];\\n            }\\n\\n            // cout << \"upper \" << j << \" \" << \"lower \" << i << \" \" << ans << \" \" << count << \"\\\\n\";\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3357385,
                "title": "python-prefix-sum-with-binary-search-o-nlogn-intuition-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition would be first sort the array, since the position of the garden doesn\\'t matter.\\n\\nThen we consider the following:\\n## Do we binary search the maximum score?\\n  - After some thinking, determine whether a value can be achieved is hard, since there\\'s no greedy approach to get an achievable solution.\\n\\n## Do we binary search the number of garden to fill & threshold to be partial?\\n  - Notice that when total full garden increase(total score +), the minimum value of partial garden decreses(total score -), which don\\'t look like a monotonic problem.\\n\\n## Then we have an observation of the cost, apparently it consist of 3 parts, fill_cost, align_cost and spread cost. \\n- Fill cost: the cost to fill $i$ largerst garden to target\\n- Align cost: the cost to align previous garden to $i_{th}$ garden (which increase the minimun value).\\n- Speard cost: left flowers can\\'t align to $i+1_{th}$ element, but can increase the minimum value per the number of all aligned elements. \\n## How to calculate the each cost?\\n- using prefix sum to avoid summing up the previous k cost everytime\\n- Fill cost:\\n![Snipaste_2023-03-29_19-18-17.png](https://assets.leetcode.com/users/images/c5331ad6-72aa-4db2-b60e-10d2ed3c4b7f_1680131940.5136378.png)\\n- Align cost:\\n![Snipaste_2023-03-29_19-17-06.png](https://assets.leetcode.com/users/images/80499ab0-937c-493e-900e-32ebd671c021_1680131837.119551.png)\\n- Spread cost:\\n![Snipaste_2023-03-29_19-23-11.png](https://assets.leetcode.com/users/images/07d00b81-c301-4e81-98eb-944410a60455_1680132204.6220386.png)\\n\\n## Why align cost then other?\\nThe pain point is to determine what\\'s min partial after the fill, by using bisect_right, we not only have the cost of align previous $i - 1$ element to $i_{th}$, but also get the unit cost to increase the minimum value by 1.\\n\\n# Edge cases\\n- new flower too small / =0?\\n- new flower too big?\\n  - If we have enough flowers to fill all garden to target, the optimal solution would be fill all garden or left 1 garden to be target - 1 since partial >= 0\\n  - We should cap the \\n- All garden already reach the target?\\n  - Do nothing, return # of garden * full\\n- \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsort: $O(NlogN)$\\niterate thru c1: $O(N)$\\nbinary search thru c2: $O(logN)$\\ntotal: $O(NlogN) + O(N) * O(logN) = O(NlogN)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(N)$\\n# Code\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], nf: int, target: int, full: int, partial: int) -> int:\\n        flowers, base = sorted([v for v in flowers if v < target], reverse=True), len([v for v in flowers if v >= target]) * full\\n        if flowers == []:\\n            return base\\n        n = len(flowers)\\n        c1, c2 = [], []\\n        # calculate C1, the fill cost\\n        ttl = 0\\n        for i, v in enumerate(flowers):\\n            c1.append(i * target - ttl)\\n            ttl += v\\n        c1.append(n * target - ttl)\\n\\n        # calculate C2, the align cost\\n        flowers.reverse()\\n        ttl = 0\\n        for i, v in enumerate(flowers):\\n            c2.append(i * v - ttl)\\n            ttl += v\\n        c2.append(n * target - ttl)\\n\\n        # \\n        if nf >= c2[-1]:\\n            return base + full * (n-1) + max(full, (target - 1) * partial)\\n\\n        maxV = 0\\n        for k1, fc in enumerate(c1):\\n            # only continue if we have enough flower to fill k1 number of garden\\n            if fc > nf:\\n                break\\n            # set the upper bound to n - k1 to avoid overlap\\n            j = bisect_right(c2, nf - fc, 0, n - k1)\\n\\n            # flowers_left = total_flower - fill_cost[k1] - align_cost[j - 1]\\n            npv = min(flowers[j - 1] + (nf - fc - c2[j - 1]) // j, target - 1)\\n            nv = full * k1 + npv * partial\\n            maxV = max(maxV, nv)\\n        return base + maxV\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], nf: int, target: int, full: int, partial: int) -> int:\\n        flowers, base = sorted([v for v in flowers if v < target], reverse=True), len([v for v in flowers if v >= target]) * full\\n        if flowers == []:\\n            return base\\n        n = len(flowers)\\n        c1, c2 = [], []\\n        # calculate C1, the fill cost\\n        ttl = 0\\n        for i, v in enumerate(flowers):\\n            c1.append(i * target - ttl)\\n            ttl += v\\n        c1.append(n * target - ttl)\\n\\n        # calculate C2, the align cost\\n        flowers.reverse()\\n        ttl = 0\\n        for i, v in enumerate(flowers):\\n            c2.append(i * v - ttl)\\n            ttl += v\\n        c2.append(n * target - ttl)\\n\\n        # \\n        if nf >= c2[-1]:\\n            return base + full * (n-1) + max(full, (target - 1) * partial)\\n\\n        maxV = 0\\n        for k1, fc in enumerate(c1):\\n            # only continue if we have enough flower to fill k1 number of garden\\n            if fc > nf:\\n                break\\n            # set the upper bound to n - k1 to avoid overlap\\n            j = bisect_right(c2, nf - fc, 0, n - k1)\\n\\n            # flowers_left = total_flower - fill_cost[k1] - align_cost[j - 1]\\n            npv = min(flowers[j - 1] + (nf - fc - c2[j - 1]) // j, target - 1)\\n            nv = full * k1 + npv * partial\\n            maxV = max(maxV, nv)\\n        return base + maxV\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175542,
                "title": "maximum-total-beauty-of-the-gardens",
                "content": "# Intuition\\nI do not think that we need a binary search here.\\n\\nWe sort gardens (descending), and then go left to right and make gardens full (until we run out of flowers). Thus, our first pointer p1 indicates full gardens, and the last garden defines the minimum number of flowers (minF) among all gardens.\\n\\nThere is a special case when we can make all gardens full - it may be better to only plant target - 1 flowers in the last garden, if (target - 1) * partial > full.\\n\\nWe then go right-to-left, and try increasing the minimum number of flowers. The second pointer - p2 - indicates how many gardens have less flowers than minF.\\n\\nWe plan necessary flowers to gardens right of p2. If we do not have enough flowers, we take it from the rightmost full garden, decreasing p1. For each minF we can achieve, we track and return the maximum beauty.\\n\\nHere is an example for [9, 7, 7, 6, 5, 4, 3, 2, 1, 1] gardens, with target 8 and 9 new flowers to plant. As you see, for minF == 2, we have 5 full gardens. For minF == 3, we move p1 to get enough flowers to plant, and now we have 4 full gardens.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& fl, long long newFlowers, int target, int full, int partial) {\\n         sort(begin(fl), end(fl), greater<int>());\\n    long long p1 = 0, sum = 0, res = 0, sz = fl.size();\\n    for (; p1 < sz; ++p1) {\\n        if (target - fl[p1] > newFlowers)\\n            break;\\n        newFlowers -= max(0, target - fl[p1]);\\n    }\\n    if (p1 == sz)\\n        return max(sz * full, (sz - 1) * full + (fl.back() < target ? (long long)(target - 1) * partial : full));\\n    for (long long minF = fl.back(), p2 = fl.size() - 1; minF < target; ) {\\n        while (p2 >= p1 && fl[p2] <= minF)\\n            sum += fl[p2--];\\n        int needed = (sz - p2 - 1) * minF - sum;\\n        if (needed > newFlowers) {\\n            if (--p1 < 0)\\n                break;\\n            newFlowers += max(0, target - fl[p1]);\\n        }\\n        else {\\n            res = max(p1 * full + minF * partial, res);    \\n            ++minF;\\n        }\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& fl, long long newFlowers, int target, int full, int partial) {\\n         sort(begin(fl), end(fl), greater<int>());\\n    long long p1 = 0, sum = 0, res = 0, sz = fl.size();\\n    for (; p1 < sz; ++p1) {\\n        if (target - fl[p1] > newFlowers)\\n            break;\\n        newFlowers -= max(0, target - fl[p1]);\\n    }\\n    if (p1 == sz)\\n        return max(sz * full, (sz - 1) * full + (fl.back() < target ? (long long)(target - 1) * partial : full));\\n    for (long long minF = fl.back(), p2 = fl.size() - 1; minF < target; ) {\\n        while (p2 >= p1 && fl[p2] <= minF)\\n            sum += fl[p2--];\\n        int needed = (sz - p2 - 1) * minF - sum;\\n        if (needed > newFlowers) {\\n            if (--p1 < 0)\\n                break;\\n            newFlowers += max(0, target - fl[p1]);\\n        }\\n        else {\\n            res = max(p1 * full + minF * partial, res);    \\n            ++minF;\\n        }\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066729,
                "title": "c-sort-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maximumBeauty(vector<int>& F, ll newFlowers, int target, int full, int partial) {\\n        ll res = 0;\\n        sort(begin(F), end(F));\\n        vector<ll> preSum(F.size()+1, 0);\\n        for(int i = 0; i < F.size(); i++) preSum[i+1] = preSum[i]+F[i];\\n        for(int i = F.size()-1; i >= -1; i--) {\\n            if(i >= 0 && F[i] >= target) continue;\\n            int l = -1, h = i;\\n            while(l < h) {\\n                ll m = l + (h-l+1)/2, v_sum = preSum[m+1], t_sum = F[m]*(m+1), diff = t_sum - v_sum;\\n                if(diff > newFlowers) h = m-1;\\n                else l = m;\\n            }\\n            ll min_v = i == -1 ? 0 : min(target-1ll, (preSum[l+1]+(ll)newFlowers)/(l+1));\\n            res = max(res, min_v*partial+((ll)F.size()-i-1)*full);\\n            if(i != -1 && target-F[i] > newFlowers) break;\\n            if(i != -1) newFlowers -= max(0, target-F[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maximumBeauty(vector<int>& F, ll newFlowers, int target, int full, int partial) {\\n        ll res = 0;\\n        sort(begin(F), end(F));\\n        vector<ll> preSum(F.size()+1, 0);\\n        for(int i = 0; i < F.size(); i++) preSum[i+1] = preSum[i]+F[i];\\n        for(int i = F.size()-1; i >= -1; i--) {\\n            if(i >= 0 && F[i] >= target) continue;\\n            int l = -1, h = i;\\n            while(l < h) {\\n                ll m = l + (h-l+1)/2, v_sum = preSum[m+1], t_sum = F[m]*(m+1), diff = t_sum - v_sum;\\n                if(diff > newFlowers) h = m-1;\\n                else l = m;\\n            }\\n            ll min_v = i == -1 ? 0 : min(target-1ll, (preSum[l+1]+(ll)newFlowers)/(l+1));\\n            res = max(res, min_v*partial+((ll)F.size()-i-1)*full);\\n            if(i != -1 && target-F[i] > newFlowers) break;\\n            if(i != -1) newFlowers -= max(0, target-F[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920340,
                "title": "nlog-n-greedy-two-pointers",
                "content": "```c++\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int n = flowers.size();\\n        if (flowers[0] >= target) return n * (long long)full;\\n        vector<long long> fillLeft(n, 0);\\n        for (int i = 1; i < n; ++i) {\\n            fillLeft[i] = fillLeft[i - 1] + i * (long long)(flowers[i] - flowers[i - 1]);\\n        }\\n\\n        long long ret = 0;\\n        int r = n, l = n - 1;\\n        while (r > -1 && newFlowers > 0 && l > -1) {\\n            if (r < n) {\\n                if (flowers[r] < target) newFlowers += (flowers[r] - target);\\n                if (newFlowers <= 0) return ret;\\n            }\\n            long long val = 0;\\n            if (r > 0) {\\n                l = min(r - 1 , l);\\n                while (l > -1 && fillLeft[l] > newFlowers) --l; \\n                ++l;\\n                if (l == 0) val = flowers[0] + newFlowers;\\n                else  val = flowers[l - 1] + (newFlowers - fillLeft[l - 1])/l;\\n                val = min(val, (long long)target -1);\\n            } \\n            ret = max(ret, full * (long long) (n - r) + val * partial);\\n            --r;\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        int n = flowers.size();\\n        if (flowers[0] >= target) return n * (long long)full;\\n        vector<long long> fillLeft(n, 0);\\n        for (int i = 1; i < n; ++i) {\\n            fillLeft[i] = fillLeft[i - 1] + i * (long long)(flowers[i] - flowers[i - 1]);\\n        }\\n\\n        long long ret = 0;\\n        int r = n, l = n - 1;\\n        while (r > -1 && newFlowers > 0 && l > -1) {\\n            if (r < n) {\\n                if (flowers[r] < target) newFlowers += (flowers[r] - target);\\n                if (newFlowers <= 0) return ret;\\n            }\\n            long long val = 0;\\n            if (r > 0) {\\n                l = min(r - 1 , l);\\n                while (l > -1 && fillLeft[l] > newFlowers) --l; \\n                ++l;\\n                if (l == 0) val = flowers[0] + newFlowers;\\n                else  val = flowers[l - 1] + (newFlowers - fillLeft[l - 1])/l;\\n                val = min(val, (long long)target -1);\\n            } \\n            ret = max(ret, full * (long long) (n - r) + val * partial);\\n            --r;\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905279,
                "title": "c-suffix-sum-binary-search-explained-with-comments",
                "content": "typedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    ll getMaxMin(vector<int>& arr, int i, int n, ll cl, ll &s, vector<ll>& suf){\\n        \\n        // Here we are finding the maximum min val that can be obtained using \\'s\\'. Since values cannot be more than target,\\n        // res will have an upper bound of cl.\\n        \\n        if(i == n) return 0;\\n        ll res = arr[n-1];\\n        ll l = res, r = cl;\\n\\n        while(l <= r){\\n            // Here we use suffix sum to find if mid can be achieved using \\'s\\' values. For e.g for arr{4,3,2,1} to have a min value \\n            // of 4, we calculate upper bound on 4, which is index 1(i.e. value 3). Now if 4 were to be the min value in the array,\\n            // then sum[1...3] should be 3*4 = 12. Actual sum is suf[1], i.e. 6. Now we compare this value against s.\\n            ll mid = (l+r) >> 1;\\n            int k = upper_bound(arr.begin()+i, arr.end(), mid, greater<int>())-arr.begin();\\n            if(k == n) k--;\\n\\n            ll req = (((ll)(n-k) * (mid))-suf[k]);\\n            \\n            if(req > s){\\n                r = mid-1;\\n            }else{\\n                res = mid;\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        //use a greedy approach, start with 0 full gardens, then 1 full garden upto n;\\n        sort(flowers.begin(), flowers.end(), [](const int& a, const int& b) -> bool{\\n            return a > b;\\n        });\\n        int n = flowers.size();\\n        int l = 0;\\n        //skip already full gardens\\n        while(l < n && flowers[l] >= target) l++;\\n        \\n        if(l == n) return (l*(ll)full);\\n        \\n        ll cl = target-1;\\n        \\n        //Find suffix sum\\n        vector<ll> suf(n);\\n        suf[n-1] = flowers[n-1];\\n        for(int i = n-2 ; i >=0 ; i--)\\n            suf[i] += (suf[i+1] + flowers[i]);\\n        \\n        ll fullCnt = l;\\n        \\n        ll res = (fullCnt * full + partial*getMaxMin(flowers, l, n, target-1, newFlowers, suf));\\n        \\n        for(int i = l ; i < n ; i++){\\n            ll reqFlowers = target-flowers[i];\\n            if(reqFlowers > newFlowers) break;\\n            newFlowers -= reqFlowers;\\n            fullCnt = i+1;\\n            \\n            res = max(res, fullCnt*full + partial*getMaxMin(flowers, i+1, n, target-1, newFlowers, suf));\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    ll getMaxMin(vector<int>& arr, int i, int n, ll cl, ll &s, vector<ll>& suf){\\n        \\n        // Here we are finding the maximum min val that can be obtained using \\'s\\'. Since values cannot be more than target,\\n        // res will have an upper bound of cl.\\n        \\n        if(i == n) return 0;\\n        ll res = arr[n-1];\\n        ll l = res, r = cl;\\n\\n        while(l <= r){\\n            // Here we use suffix sum to find if mid can be achieved using \\'s\\' values. For e.g for arr{4,3,2,1}",
                "codeTag": "Java"
            },
            {
                "id": 2667568,
                "title": "c-fast-simple",
                "content": "Link to the submission stats:\\nhttps://leetcode.com/submissions/detail/816324822/\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& ar, long long m, int t, int f, int p) {\\n        int n=ar.size();\\n        sort(ar.rbegin(),ar.rend());\\n        vector<long long> suf(n);\\n        vector<long long> mi(n);\\n        suf[n-1]=ar[n-1];\\n        mi[n-1]=0;\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+ar[i];\\n            mi[i]=mi[i+1]+(long long)(ar[i]-ar[i+1])*(n-i-1);\\n        }\\n        long long ans=0;\\n        int i=0;\\n        while(i<n && ar[i]>=t){i++;}\\n        while(i<n){\\n            if(m>=(long long)(t-1)*(n-i) - suf[i]){\\n                ans=max(ans,(long long)(i)*f + (long long)p*(t-1));\\n            }\\n            else{\\n                int lo=i,hi=n;\\n                int anss=-1;\\n                while(lo<hi){\\n                    int mid = (lo+hi)/2;\\n                    if(mi[mid]<=m){\\n                        anss=mid;\\n                        hi=mid;\\n                    }\\n                    else{\\n                        lo=mid+1;\\n                    }\\n                }\\n                long long mimi = m - mi[anss];\\n                mimi = ar[anss] + mimi/(n-anss);\\n                ans=max(ans,(long long)i*f + (long long)p*mimi);\\n            }\\n            long long dif = t-ar[i];\\n            if(m<dif){break;}\\n            m-=dif;\\n            i++;\\n        }\\n        if(i==n){ans=max(ans,(long long)f*n);}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& ar, long long m, int t, int f, int p) {\\n        int n=ar.size();\\n        sort(ar.rbegin(),ar.rend());\\n        vector<long long> suf(n);\\n        vector<long long> mi(n);\\n        suf[n-1]=ar[n-1];\\n        mi[n-1]=0;\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+ar[i];\\n            mi[i]=mi[i+1]+(long long)(ar[i]-ar[i+1])*(n-i-1);\\n        }\\n        long long ans=0;\\n        int i=0;\\n        while(i<n && ar[i]>=t){i++;}\\n        while(i<n){\\n            if(m>=(long long)(t-1)*(n-i) - suf[i]){\\n                ans=max(ans,(long long)(i)*f + (long long)p*(t-1));\\n            }\\n            else{\\n                int lo=i,hi=n;\\n                int anss=-1;\\n                while(lo<hi){\\n                    int mid = (lo+hi)/2;\\n                    if(mi[mid]<=m){\\n                        anss=mid;\\n                        hi=mid;\\n                    }\\n                    else{\\n                        lo=mid+1;\\n                    }\\n                }\\n                long long mimi = m - mi[anss];\\n                mimi = ar[anss] + mimi/(n-anss);\\n                ans=max(ans,(long long)i*f + (long long)p*mimi);\\n            }\\n            long long dif = t-ar[i];\\n            if(m<dif){break;}\\n            m-=dif;\\n            i++;\\n        }\\n        if(i==n){ans=max(ans,(long long)f*n);}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609457,
                "title": "easy-c-binary-search-prefix-sum-solution-beats-88",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>&nums, long long nf, long long target, long long f, long long partial) {\\n//      sorting the array\\n        sort(nums.begin(),nums.end());\\n        long long full=0;\\n//      count the already full gardens \\n        for(auto num:nums){\\n            full+=(num>=target);\\n        }\\n//       create a prefix array\\n        vector<long long>pre(nums.size()-full);\\n        for(long long i=1ll;i<nums.size()-full;i++){\\n            pre[i]=pre[i-1]+(nums[i]-nums[i-1])*1ll*i;\\n        }\\n        \\n        \\n//      declare answer  \\n        long long ans=0;\\n//      if all gardens are alreay full, we can\\'t proceed further\\n        if(full==nums.size())return full*1ll*f;\\n        ans=max(ans,full*f+nums[0]*partial);\\n        \\n//      increasing the size of nums by one to handle the case of (already full == 0);\\n        nums.push_back(target);\\n        \\n//      loop from back\\n        for(int i = pre.size() ; i>=0;i--){\\n//      handle the case i==0 separately because prefix array will be empty this time and we cannot apply upper_bound on empthy vector\\n            if(i==0){\\n                if(nf>=target*1ll-nums[i]*1ll){\\n                    full++;\\n                    ans=max(ans,f*1ll*full) ;\\n                }\\n            }\\n//          if we are able to make ith garden full\\n            else if(nf>=target-nums[i]){\\n//              decreasing the flowers available  \\n                nf-=max(target-nums[i],0ll);\\n//              increasing count of full gardens because our current garden is also full now \\n                if(nums[i]<target)full++;\\n                \\n//              getting the index off the garden whose pre[index] <= available flowers;\\n                long long ind = upper_bound(pre.begin(),pre.end(),nf)-pre.begin()-1;\\n//              how much extra flowers we can add to the gardens to increase minimum\\n                long long delta=(nf*1ll-pre[ind])/(ind+1);\\n                \\n//              updating the answer\\n                if(delta + nums[ind] >= target)delta=target-nums[ind]-1;\\n                ans=max(ans , full *(1ll)* f + partial*1ll*(nums[ind]+delta));\\n//             decreasing the size of pre\\n                pre.pop_back();\\n                 \\n            }else break;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>&nums, long long nf, long long target, long long f, long long partial) {\\n//      sorting the array\\n        sort(nums.begin(),nums.end());\\n        long long full=0;\\n//      count the already full gardens \\n        for(auto num:nums){\\n            full+=(num>=target);\\n        }\\n//       create a prefix array\\n        vector<long long>pre(nums.size()-full);\\n        for(long long i=1ll;i<nums.size()-full;i++){\\n            pre[i]=pre[i-1]+(nums[i]-nums[i-1])*1ll*i;\\n        }\\n        \\n        \\n//      declare answer  \\n        long long ans=0;\\n//      if all gardens are alreay full, we can\\'t proceed further\\n        if(full==nums.size())return full*1ll*f;\\n        ans=max(ans,full*f+nums[0]*partial);\\n        \\n//      increasing the size of nums by one to handle the case of (already full == 0);\\n        nums.push_back(target);\\n        \\n//      loop from back\\n        for(int i = pre.size() ; i>=0;i--){\\n//      handle the case i==0 separately because prefix array will be empty this time and we cannot apply upper_bound on empthy vector\\n            if(i==0){\\n                if(nf>=target*1ll-nums[i]*1ll){\\n                    full++;\\n                    ans=max(ans,f*1ll*full) ;\\n                }\\n            }\\n//          if we are able to make ith garden full\\n            else if(nf>=target-nums[i]){\\n//              decreasing the flowers available  \\n                nf-=max(target-nums[i],0ll);\\n//              increasing count of full gardens because our current garden is also full now \\n                if(nums[i]<target)full++;\\n                \\n//              getting the index off the garden whose pre[index] <= available flowers;\\n                long long ind = upper_bound(pre.begin(),pre.end(),nf)-pre.begin()-1;\\n//              how much extra flowers we can add to the gardens to increase minimum\\n                long long delta=(nf*1ll-pre[ind])/(ind+1);\\n                \\n//              updating the answer\\n                if(delta + nums[ind] >= target)delta=target-nums[ind]-1;\\n                ans=max(ans , full *(1ll)* f + partial*1ll*(nums[ind]+delta));\\n//             decreasing the size of pre\\n                pre.pop_back();\\n                 \\n            }else break;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414684,
                "title": "a-no-sort-java-solution-other-solutions",
                "content": "I am so frustrated by this question. I went through 3 different implementations and each time there was a stupid bug for me to debug. \\n\\nMy first solution didn\\'t sort the array at all. It is some kind of adjusting on the fly with heap and treeset. It is way too overcomplicated, so I will leave that for the last. \\n\\nHere this is the most optimal solution. It runs in 50ms scoring 90% Speed. O(1) Space with sort and **no** binary search. I\\'d actually recommend binary search instead, it may be slower but it is a lot easier to get right. or maybe it is just because I am so used to write binary search ...\\n\\n#### Java\\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n        if (flowers[0] >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        int lo = flowers[0], k = 0; // here lo = maximum partial\\n        long left = newFlowers;\\n        for(;lo < target-1 && left >= 0; lo++){\\n            while(k < flowers.length && flowers[k] <= lo){\\n                ++k;\\n            }\\n            left -= k;\\n        }\\n        if (left < 0){\\n            left += k;\\n            --lo;\\n        }\\n        long ans = 1L*lo*partial; // start from no full, max partial\\n        for (int i = flowers.length-1,j=i; i >= 0 && left >= 0; i--){ // make flowers[i] FULL.\\n            j = Math.min(i-1, j);\\n            if (flowers[i] < target){ // need something\\n                left -= (target - Math.max(lo, flowers[i]));\\n                while(left < 0 && j >= 0){\\n                    if (lo>flowers[j]){ // keep moving the j pointers leftward\\n                        left += j+1;\\n                        lo--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n            if (left >= 0){\\n                ans = Math.max(ans, 1L*(flowers.length-i)*full + 1L*(i==0?0:lo)*partial);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n#### Solution 2 (Binary Search)\\nSame idea as above, except this time we binary search for the max min partial\\n\\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int lo = Arrays.stream(flowers).min().getAsInt(), hi = target - 1;\\n        long left = newFlowers;\\n        while(lo < hi){ // binary search\\n            int mid = (lo+hi+1)>>1;\\n            long cost = 0;\\n            for (int n : flowers){\\n                cost += Math.max(0, mid-n);\\n            }\\n            if (cost <= newFlowers){\\n                left = newFlowers-cost;\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if (lo >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        long ans = 1L*lo*partial;\\n        Arrays.sort(flowers);\\n        for (int i = flowers.length-1,j=i; i >= 0 && left >= 0; i--){\\n            j = Math.min(i-1, j);\\n            if (flowers[i] < target){\\n                left -= (target - Math.max(lo, flowers[i]));\\n                while(left < 0 && j >= 0){\\n                    if (lo>flowers[j]){\\n                        left += j+1;\\n                        lo--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n            if (left >= 0){\\n                ans = Math.max(ans, 1L*(flowers.length-i)*full + 1L*(i==0?0:lo)*partial);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n#### Solution 3 (So complicated)\\nInstead of sort, I, uh.. for some reason, think that we can adjust on the fly with heap and treeset! It works but the implementation is tricky. I do not recommend it.\\n\\nOne good thing about this approach though, is that even if `target <= 1e10`, it will still work unlike the other 2 solutions.\\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int lo = Arrays.stream(flowers).min().getAsInt(), hi = target - 1;\\n        while(lo < hi){\\n            int mid = (lo+hi+1)>>1;\\n            long cost = 0;\\n            for (int n : flowers){\\n                cost += Math.max(0, mid-n);\\n            }\\n            if (cost <= newFlowers){\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if (lo >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        int cap = 0, fc = 0;\\n        long left = newFlowers;\\n        var maxheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> -flowers[o]));\\n        var able    = new TreeSet<Integer>((a,b)->flowers[a]==flowers[b]?a-b:flowers[b]-flowers[a]);\\n        for (int i = 0; i < flowers.length; i++){\\n            if (flowers[i] >= target){\\n                ++fc;\\n            }else{\\n                maxheap.offer(i);\\n            }\\n            if (flowers[i] < lo){\\n                able.add(i);\\n                left -= (lo - flowers[i]);\\n            }\\n        }\\n        long ans = 1L*lo * partial + 1L*fc * full;\\n        while(!maxheap.isEmpty() && left >= 0){\\n            int cur = maxheap.poll();\\n            int req = target - Math.max(lo, flowers[cur]);\\n            able.remove(cur);\\n            while (left < req && !able.isEmpty()){\\n                long a = ((req-left-1)/able.size())+1;\\n                if (lo-a >= flowers[able.first()]){\\n                    lo-=a;\\n                    left += a*able.size();\\n                }else{\\n                    left += 1L*able.size() * (lo - flowers[able.first()]);\\n                    lo = flowers[able.pollFirst()];\\n                }\\n            }\\n            left -= req;\\n            if (left >= 0){\\n                if (++fc == flowers.length){\\n                    lo=0;\\n                }\\n                ans = Math.max(ans, 1L*lo*partial + 1L*fc*full);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n        if (flowers[0] >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        int lo = flowers[0], k = 0; // here lo = maximum partial\\n        long left = newFlowers;\\n        for(;lo < target-1 && left >= 0; lo++){\\n            while(k < flowers.length && flowers[k] <= lo){\\n                ++k;\\n            }\\n            left -= k;\\n        }\\n        if (left < 0){\\n            left += k;\\n            --lo;\\n        }\\n        long ans = 1L*lo*partial; // start from no full, max partial\\n        for (int i = flowers.length-1,j=i; i >= 0 && left >= 0; i--){ // make flowers[i] FULL.\\n            j = Math.min(i-1, j);\\n            if (flowers[i] < target){ // need something\\n                left -= (target - Math.max(lo, flowers[i]));\\n                while(left < 0 && j >= 0){\\n                    if (lo>flowers[j]){ // keep moving the j pointers leftward\\n                        left += j+1;\\n                        lo--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n            if (left >= 0){\\n                ans = Math.max(ans, 1L*(flowers.length-i)*full + 1L*(i==0?0:lo)*partial);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int lo = Arrays.stream(flowers).min().getAsInt(), hi = target - 1;\\n        long left = newFlowers;\\n        while(lo < hi){ // binary search\\n            int mid = (lo+hi+1)>>1;\\n            long cost = 0;\\n            for (int n : flowers){\\n                cost += Math.max(0, mid-n);\\n            }\\n            if (cost <= newFlowers){\\n                left = newFlowers-cost;\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if (lo >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        long ans = 1L*lo*partial;\\n        Arrays.sort(flowers);\\n        for (int i = flowers.length-1,j=i; i >= 0 && left >= 0; i--){\\n            j = Math.min(i-1, j);\\n            if (flowers[i] < target){\\n                left -= (target - Math.max(lo, flowers[i]));\\n                while(left < 0 && j >= 0){\\n                    if (lo>flowers[j]){\\n                        left += j+1;\\n                        lo--;\\n                    }else{\\n                        j--;\\n                    }\\n                }\\n            }\\n            if (left >= 0){\\n                ans = Math.max(ans, 1L*(flowers.length-i)*full + 1L*(i==0?0:lo)*partial);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        int lo = Arrays.stream(flowers).min().getAsInt(), hi = target - 1;\\n        while(lo < hi){\\n            int mid = (lo+hi+1)>>1;\\n            long cost = 0;\\n            for (int n : flowers){\\n                cost += Math.max(0, mid-n);\\n            }\\n            if (cost <= newFlowers){\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if (lo >= target){\\n            return 1L*full*flowers.length;\\n        }\\n        int cap = 0, fc = 0;\\n        long left = newFlowers;\\n        var maxheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> -flowers[o]));\\n        var able    = new TreeSet<Integer>((a,b)->flowers[a]==flowers[b]?a-b:flowers[b]-flowers[a]);\\n        for (int i = 0; i < flowers.length; i++){\\n            if (flowers[i] >= target){\\n                ++fc;\\n            }else{\\n                maxheap.offer(i);\\n            }\\n            if (flowers[i] < lo){\\n                able.add(i);\\n                left -= (lo - flowers[i]);\\n            }\\n        }\\n        long ans = 1L*lo * partial + 1L*fc * full;\\n        while(!maxheap.isEmpty() && left >= 0){\\n            int cur = maxheap.poll();\\n            int req = target - Math.max(lo, flowers[cur]);\\n            able.remove(cur);\\n            while (left < req && !able.isEmpty()){\\n                long a = ((req-left-1)/able.size())+1;\\n                if (lo-a >= flowers[able.first()]){\\n                    lo-=a;\\n                    left += a*able.size();\\n                }else{\\n                    left += 1L*able.size() * (lo - flowers[able.first()]);\\n                    lo = flowers[able.pollFirst()];\\n                }\\n            }\\n            left -= req;\\n            if (left >= 0){\\n                if (++fc == flowers.length){\\n                    lo=0;\\n                }\\n                ans = Math.max(ans, 1L*lo*partial + 1L*fc*full);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311735,
                "title": "python-go-c-cumulative-sum-w-binary-search-vs-two-pointers-o-nlogn",
                "content": "*Python* solution w/ binary search\\n\\n```python\\ndef maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n    F = sorted(x for x in flowers if x < target)\\n    A = list(itertools.accumulate(F))\\n    L = [x * (i + 1) - A[i] for i, x in enumerate(F)]\\n    R = [x for x in itertools.accumulate(range(len(F)), lambda a, i: a + F[~i] - target, initial=newFlowers) if x >= 0]\\n    return max(\\n        ((i := bisect.bisect(L, x, hi=len(flowers) - j)) and min(target - 1, (A[i - 1] + x) // i)) * partial + j * full\\n        for j, x in enumerate(R, len(flowers) - len(F))\\n    )\\n```\\n\\n*Python* solution w/ two pointers O(1) space\\n\\n```python\\ndef maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n    res = tot = k = 0\\n    n = len(flowers)\\n    flowers.sort()\\n    while k < n and flowers[k] < target: k, tot = k + 1, tot + flowers[k]\\n    i = j = k - 1\\n    while j >= 0:\\n        if newFlowers < 0: return res\\n        while i > j or i >= 0 and (x := newFlowers + tot) < flowers[i] * (i + 1): i, tot = i - 1, tot - flowers[i]\\n        res = max(res, min(target - 1, x // (i + 1)) * partial + (n - 1 - j) * full)\\n        j, newFlowers = j - 1, newFlowers + flowers[j] - target\\n    return max(res, n * full)\\n```\\n\\n*Go* solution w/ two pointers O(1) space in 208ms\\n\\n```go\\nfunc min(x, y int64) int64 {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc maximumBeauty(flowers []int, newFlowers int64, target int, full int, partial int) int64 {\\n\\tvar (\\n\\t\\tres, tot, k int64\\n\\t\\tn           = int64(len(flowers))\\n\\t)\\n\\tsort.Ints(flowers)\\n\\tfor ; k < n && flowers[k] < target; k, tot = k+1, tot+int64(flowers[k]) {\\n\\t}\\n\\tfor i, j := k-1, k-1; j >= 0; j, newFlowers = j-1, newFlowers+int64(flowers[j]-target) {\\n\\t\\tif newFlowers < 0 {\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tfor ; i > j || i >= 0 && tot+newFlowers < int64(flowers[i])*(i+1); i, tot = i-1, tot-int64(flowers[i]) {\\n\\t\\t}\\n\\t\\tres = max(res, min(int64(target-1), (tot+newFlowers)/(i+1))*int64(partial)+(n-1-j)*int64(full))\\n\\t}\\n\\treturn max(res, n*int64(full))\\n}\\n```\\n\\n*C++* solution w/ two pointers O(1) space in 182ms beat 100% :)\\n\\n```c++\\nlong long maximumBeauty(vector<int> &A, long long y, int c, int b, int a) {\\n    long long res = 0, x = 0, k = 0, n = A.size();\\n    sort(A.begin(), A.end());\\n    for (; k < n && A[k] < c; x += A[k++]);\\n    for (long long i = k, j = k; j > 0 && y >= 0; y -= c - A[--j]) {\\n        for (; i > j || i > 0 && x + y < A[i - 1] * i; x -= A[--i]);\\n        res = max(res, min((x + y) / i, (long long)c - 1) * a + (n - j) * b);\\n    }\\n    return y < 0 ? res : max(res, n * b);\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n    F = sorted(x for x in flowers if x < target)\\n    A = list(itertools.accumulate(F))\\n    L = [x * (i + 1) - A[i] for i, x in enumerate(F)]\\n    R = [x for x in itertools.accumulate(range(len(F)), lambda a, i: a + F[~i] - target, initial=newFlowers) if x >= 0]\\n    return max(\\n        ((i := bisect.bisect(L, x, hi=len(flowers) - j)) and min(target - 1, (A[i - 1] + x) // i)) * partial + j * full\\n        for j, x in enumerate(R, len(flowers) - len(F))\\n    )\\n```\n```python\\ndef maximumBeauty(self, flowers, newFlowers, target, full, partial):\\n    res = tot = k = 0\\n    n = len(flowers)\\n    flowers.sort()\\n    while k < n and flowers[k] < target: k, tot = k + 1, tot + flowers[k]\\n    i = j = k - 1\\n    while j >= 0:\\n        if newFlowers < 0: return res\\n        while i > j or i >= 0 and (x := newFlowers + tot) < flowers[i] * (i + 1): i, tot = i - 1, tot - flowers[i]\\n        res = max(res, min(target - 1, x // (i + 1)) * partial + (n - 1 - j) * full)\\n        j, newFlowers = j - 1, newFlowers + flowers[j] - target\\n    return max(res, n * full)\\n```\n```go\\nfunc min(x, y int64) int64 {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc maximumBeauty(flowers []int, newFlowers int64, target int, full int, partial int) int64 {\\n\\tvar (\\n\\t\\tres, tot, k int64\\n\\t\\tn           = int64(len(flowers))\\n\\t)\\n\\tsort.Ints(flowers)\\n\\tfor ; k < n && flowers[k] < target; k, tot = k+1, tot+int64(flowers[k]) {\\n\\t}\\n\\tfor i, j := k-1, k-1; j >= 0; j, newFlowers = j-1, newFlowers+int64(flowers[j]-target) {\\n\\t\\tif newFlowers < 0 {\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tfor ; i > j || i >= 0 && tot+newFlowers < int64(flowers[i])*(i+1); i, tot = i-1, tot-int64(flowers[i]) {\\n\\t\\t}\\n\\t\\tres = max(res, min(int64(target-1), (tot+newFlowers)/(i+1))*int64(partial)+(n-1-j)*int64(full))\\n\\t}\\n\\treturn max(res, n*int64(full))\\n}\\n```\n```c++\\nlong long maximumBeauty(vector<int> &A, long long y, int c, int b, int a) {\\n    long long res = 0, x = 0, k = 0, n = A.size();\\n    sort(A.begin(), A.end());\\n    for (; k < n && A[k] < c; x += A[k++]);\\n    for (long long i = k, j = k; j > 0 && y >= 0; y -= c - A[--j]) {\\n        for (; i > j || i > 0 && x + y < A[i - 1] * i; x -= A[--i]);\\n        res = max(res, min((x + y) / i, (long long)c - 1) * a + (n - j) * b);\\n    }\\n    return y < 0 ? res : max(res, n * b);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2188914,
                "title": "sorting-nested-binary-search-and-suffix-sum",
                "content": "Sort the flower array in descending order.\\nThen iterate though sorted flower array. In each iteration calculate beauty by trying to make leftmost garden full and maximize the minimum available flowers among rest of the non-full gardens by using remaining flowers to maximize sum for partial gardens. Return max of all beauty values calculated. Maximizing the sum for partially full gardens is the most tricky part and can be optimized by using suffix sum array and 2 nested binary search loops.\\nThis has a complexity of O(n*log(full)*log(n)), where n is size of flowers array and full is the target flowers for full garden.\\n\\n```\\nclass Solution {\\npublic:\\n    int bin_search(vector<int>& flowers, vector<long long>& sum, int stIndx, int endIndx, int low, int up, long long remF) {\\n        int l = low, u = up;\\n        int res = low;\\n        //Binary search within range low to target-1 to find maximum value possible for partial gardens\\n        //This is a nested binary search. Complexity is O(log(up-low)*log(endIndx-stIndx))\\n        while (l <= u) {\\n            int mid = l + (u - l) / 2;\\n            int lf = stIndx, uf = endIndx, hIndx = uf;\\n            \\n            //Binary search using suffix array to find index of the partial garden which has maximum available flowers <= mid.\\n            //This index can be used to calculate number of flowers required to make all gardens with < mid flowers equal to mid flowers and\\n            // then check if it can be satisfied by remaining flowers.\\n            while (lf <= uf) {\\n                int m = lf + (uf - lf) / 2;\\n                if (mid <= flowers[m]) {\\n                    lf = m + 1;\\n                }\\n                else {\\n                    uf = m - 1;\\n                    hIndx = m;\\n                }\\n            }\\n            long long s = (long long)mid * (endIndx - hIndx + 1) - sum[hIndx];\\n            // If remaining flowers can satisfy this then use try increasing partial count and check else try reducing partial count.\\n            if (remF >= s) {\\n                res = mid;\\n                l = mid + 1;\\n            }\\n            else {\\n                u = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        //Sort flowers array in decending order of count\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int len = flowers.size();\\n        vector<long long> suffix_sum(len, 0);\\n        suffix_sum[len - 1] = flowers[len - 1];\\n        int i = 0;\\n        \\n        //Calculate suffix sum array where suffix_sum[i] denotes sum of flowers from index len-1 to i\\n        for (i = len - 2; i >= 0; i--) {\\n            suffix_sum[i] = flowers[i] + suffix_sum[i + 1];\\n        }\\n        int nComplete = 0, nPartial = 0;\\n        long long remF = newFlowers;\\n        \\n        //Calculate number of gardens with >= target count flowers. These will always be multiplied with full since flowers cannot be removed\\n        i = 0;\\n        while (i < flowers.size() && flowers[i] >= target) {\\n            i++;\\n        }\\n        nComplete = i;\\n        \\n        //If all gardens have >= target flowers then return nComplete*full as max beauty\\n        if (nComplete == len) {\\n            return ((long long)nComplete * full);\\n        }\\n\\n        // Iterate though all non-full gardens. In each iteration calculate beauty by trying to make leftmost garden full and maximize the\\n        // minimum available flowers among rest of the non-full gardens by using remaining flowers to maximize sum for partial gardens.\\n        // Return max of all beauty values calculated\\n        // This has a complexity of O(n*log(full)*log(n)), where n is size of flowers array\\n        long long max = nComplete * full + flowers[len - 1] * partial;\\n        for (i = nComplete; i < len; i++) {\\n            // maxPVal = maximize the minimum number of flowers for non-full gardens possible by distributing remaining flowers\\n            // This has complexity of O(log(full)*log(flowers.size()))\\n            int maxPVal = bin_search(flowers, suffix_sum, i, len - 1, flowers[len - 1], target - 1, remF);\\n            long long beauty = (long long)nComplete * full + (long long)maxPVal * partial;\\n            if (beauty > max) {\\n                max = beauty;\\n            }\\n            remF -= (target - flowers[i]);\\n            if (remF < 0) {\\n                break;\\n            }\\n            nComplete++;\\n            if (remF == 0 || i == len-1) {\\n                if (max < (long long)nComplete * full) {\\n                    max = (long long)nComplete * full;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bin_search(vector<int>& flowers, vector<long long>& sum, int stIndx, int endIndx, int low, int up, long long remF) {\\n        int l = low, u = up;\\n        int res = low;\\n        //Binary search within range low to target-1 to find maximum value possible for partial gardens\\n        //This is a nested binary search. Complexity is O(log(up-low)*log(endIndx-stIndx))\\n        while (l <= u) {\\n            int mid = l + (u - l) / 2;\\n            int lf = stIndx, uf = endIndx, hIndx = uf;\\n            \\n            //Binary search using suffix array to find index of the partial garden which has maximum available flowers <= mid.\\n            //This index can be used to calculate number of flowers required to make all gardens with < mid flowers equal to mid flowers and\\n            // then check if it can be satisfied by remaining flowers.\\n            while (lf <= uf) {\\n                int m = lf + (uf - lf) / 2;\\n                if (mid <= flowers[m]) {\\n                    lf = m + 1;\\n                }\\n                else {\\n                    uf = m - 1;\\n                    hIndx = m;\\n                }\\n            }\\n            long long s = (long long)mid * (endIndx - hIndx + 1) - sum[hIndx];\\n            // If remaining flowers can satisfy this then use try increasing partial count and check else try reducing partial count.\\n            if (remF >= s) {\\n                res = mid;\\n                l = mid + 1;\\n            }\\n            else {\\n                u = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        //Sort flowers array in decending order of count\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int len = flowers.size();\\n        vector<long long> suffix_sum(len, 0);\\n        suffix_sum[len - 1] = flowers[len - 1];\\n        int i = 0;\\n        \\n        //Calculate suffix sum array where suffix_sum[i] denotes sum of flowers from index len-1 to i\\n        for (i = len - 2; i >= 0; i--) {\\n            suffix_sum[i] = flowers[i] + suffix_sum[i + 1];\\n        }\\n        int nComplete = 0, nPartial = 0;\\n        long long remF = newFlowers;\\n        \\n        //Calculate number of gardens with >= target count flowers. These will always be multiplied with full since flowers cannot be removed\\n        i = 0;\\n        while (i < flowers.size() && flowers[i] >= target) {\\n            i++;\\n        }\\n        nComplete = i;\\n        \\n        //If all gardens have >= target flowers then return nComplete*full as max beauty\\n        if (nComplete == len) {\\n            return ((long long)nComplete * full);\\n        }\\n\\n        // Iterate though all non-full gardens. In each iteration calculate beauty by trying to make leftmost garden full and maximize the\\n        // minimum available flowers among rest of the non-full gardens by using remaining flowers to maximize sum for partial gardens.\\n        // Return max of all beauty values calculated\\n        // This has a complexity of O(n*log(full)*log(n)), where n is size of flowers array\\n        long long max = nComplete * full + flowers[len - 1] * partial;\\n        for (i = nComplete; i < len; i++) {\\n            // maxPVal = maximize the minimum number of flowers for non-full gardens possible by distributing remaining flowers\\n            // This has complexity of O(log(full)*log(flowers.size()))\\n            int maxPVal = bin_search(flowers, suffix_sum, i, len - 1, flowers[len - 1], target - 1, remF);\\n            long long beauty = (long long)nComplete * full + (long long)maxPVal * partial;\\n            if (beauty > max) {\\n                max = beauty;\\n            }\\n            remF -= (target - flowers[i]);\\n            if (remF < 0) {\\n                break;\\n            }\\n            nComplete++;\\n            if (remF == 0 || i == len-1) {\\n                if (max < (long long)nComplete * full) {\\n                    max = (long long)nComplete * full;\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165541,
                "title": "cpp-binary-search-prefix-sum",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool chk(vector<ll>&a,ll j,ll sum,ll trgt,vector<ll>&pfx)\\n    {\\n        ll idx=lower_bound(a.begin(),a.begin()+j+1,trgt)-a.begin();\\n        if(idx==0)return true;\\n        ll tmp=idx*trgt-pfx[idx-1];\\n        if(tmp<=sum)return true;\\n        return false;\\n    }\\n    ll find(vector<ll>&a,ll j,ll sum,ll trgt,vector<ll>&pfx)\\n    {\\n        if(j==-1)return 0;\\n        ll l=1,h=trgt-1,ans=0;\\n        while(l<=h)\\n        {\\n            ll mid=(l+h)/2;\\n            if(chk(a,j,sum,mid,pfx)==true)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        ll cnt=0;\\n        vector<ll>nms;\\n        for(int i=0;i<flowers.size();i++)\\n        {\\n            if(flowers[i]>=target)cnt++;\\n            else nms.push_back(flowers[i]);\\n        }\\n        ll ans=cnt*full;\\n        ll n=nms.size();\\n        if(n==0)return ans;\\n        sort(nms.begin(),nms.end());\\n        vector<ll>pfx(n,0);pfx[0]=nms[0];\\n        for(int i=1;i<n;i++)pfx[i]=nms[i]+pfx[i-1];\\n        ans+=nms[0]*partial;\\n        ll sum=0;\\n        for(int k=0;k<=n;k++)\\n        {\\n            if(k!=0)sum+=target-nms[n-k];\\n            if(newFlowers<sum)break;\\n            ll tmp=find(nms,n-1-k,newFlowers-sum,target,pfx);\\n            ans=max(ans,(cnt+k)*full+tmp*partial);\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool chk(vector<ll>&a,ll j,ll sum,ll trgt,vector<ll>&pfx)\\n    {\\n        ll idx=lower_bound(a.begin(),a.begin()+j+1,trgt)-a.begin();\\n        if(idx==0)return true;\\n        ll tmp=idx*trgt-pfx[idx-1];\\n        if(tmp<=sum)return true;\\n        return false;\\n    }\\n    ll find(vector<ll>&a,ll j,ll sum,ll trgt,vector<ll>&pfx)\\n    {\\n        if(j==-1)return 0;\\n        ll l=1,h=trgt-1,ans=0;\\n        while(l<=h)\\n        {\\n            ll mid=(l+h)/2;\\n            if(chk(a,j,sum,mid,pfx)==true)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        ll cnt=0;\\n        vector<ll>nms;\\n        for(int i=0;i<flowers.size();i++)\\n        {\\n            if(flowers[i]>=target)cnt++;\\n            else nms.push_back(flowers[i]);\\n        }\\n        ll ans=cnt*full;\\n        ll n=nms.size();\\n        if(n==0)return ans;\\n        sort(nms.begin(),nms.end());\\n        vector<ll>pfx(n,0);pfx[0]=nms[0];\\n        for(int i=1;i<n;i++)pfx[i]=nms[i]+pfx[i-1];\\n        ans+=nms[0]*partial;\\n        ll sum=0;\\n        for(int k=0;k<=n;k++)\\n        {\\n            if(k!=0)sum+=target-nms[n-k];\\n            if(newFlowers<sum)break;\\n            ll tmp=find(nms,n-1-k,newFlowers-sum,target,pfx);\\n            ans=max(ans,(cnt+k)*full+tmp*partial);\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2160324,
                "title": "c",
                "content": "```\\n\\t#define ll long long\\npublic:\\n    long long maximumBeauty(vector<int>& f, long long newF, int t, int fl, int pl) {\\n        sort(f.begin(),f.end());\\n        int n = f.size();\\n        if(f[0]>=t)\\n            return (ll)fl*n;\\n        \\n        int rightpos = lower_bound(f.begin(),f.end(),t)-f.begin()-1;\\n        \\n        ll sum=0;\\n        for(int i = 0;i<=rightpos;i++) sum+=f[i];\\n        if(newF>=(ll)t*(rightpos+1)-sum)\\n            return (ll)(n-1)*fl + max((ll)fl,(ll)pl*(t-1));\\n        \\n        vector<ll>cost(rightpos+1);\\n        for(int i =1 ;i<=rightpos;i++)\\n            cost[i] = cost[i-1] + (ll)i*(f[i]-f[i-1]);\\n        \\n        ll ans = 0;\\n        while(newF>=0){\\n            int pos = min(rightpos,int(upper_bound(cost.begin(),cost.end(),newF)-cost.begin()-1));\\n            int minInc = f[pos] + (newF - cost[pos])/(pos+1);\\n            ans=max(ans,(ll)minInc*pl + (ll)fl * (n-rightpos-1));\\n            newF -= (t-f[rightpos]);\\n            rightpos--;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\t#define ll long long\\npublic:\\n    long long maximumBeauty(vector<int>& f, long long newF, int t, int fl, int pl) {\\n        sort(f.begin(),f.end());\\n        int n = f.size();\\n        if(f[0]>=t)\\n            return (ll)fl*n;\\n        \\n        int rightpos = lower_bound(f.begin(),f.end(),t)-f.begin()-1;\\n        \\n        ll sum=0;\\n        for(int i = 0;i<=rightpos;i++) sum+=f[i];\\n        if(newF>=(ll)t*(rightpos+1)-sum)\\n            return (ll)(n-1)*fl + max((ll)fl,(ll)pl*(t-1));\\n        \\n        vector<ll>cost(rightpos+1);\\n        for(int i =1 ;i<=rightpos;i++)\\n            cost[i] = cost[i-1] + (ll)i*(f[i]-f[i-1]);\\n        \\n        ll ans = 0;\\n        while(newF>=0){\\n            int pos = min(rightpos,int(upper_bound(cost.begin(),cost.end(),newF)-cost.begin()-1));\\n            int minInc = f[pos] + (newF - cost[pos])/(pos+1);\\n            ans=max(ans,(ll)minInc*pl + (ll)fl * (n-rightpos-1));\\n            newF -= (t-f[rightpos]);\\n            rightpos--;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2137453,
                "title": "c-sort-enumerate-greedy",
                "content": "```\\ntypedef long long LL;\\n\\nclass Solution {\\npublic:\\n    LL maximumBeauty(vector<int>& fs, LL nfs, int tar, int fu, int par) {\\n        \\n        LL ans = 0;\\n        LL cplt = 0;\\n        sort(fs.begin(), fs.end());\\n        while (fs.size())\\n        {\\n            if (fs.back() < tar) break;\\n            LL t = fs.back(); fs.pop_back();\\n            cplt ++ ;\\n        }\\n        \\n        int n = fs.size();\\n        \\n        vector<LL> psum, psum2;\\n        for (int i = n - 1; i >= 0; -- i)\\n            psum.push_back(tar - fs[i]);\\n        for (int i = 1; i < n; ++ i) psum[i] += psum[i - 1];\\n        \\n        psum2.push_back(0);\\n        for (int i = 1; i < n; ++ i)\\n            psum2.push_back(psum2.back() + (fs[i] - fs[i - 1]) * i);\\n        \\n        LL nfs_cp = nfs, cplt_cp = cplt;\\n        LL cum = 0;\\n        for (int i = 0; i <= n; ++ i)\\n        {\\n            LL res = 0;\\n            \\n            if (i > 0)\\n            {\\n                if (psum[i - 1] > nfs) break;\\n                nfs -= psum[i - 1];\\n                cplt += i;\\n            }\\n            if (i < n)\\n            {\\n                auto it = upper_bound(psum2.begin(), psum2.begin() + n - i, nfs);\\n                LL cnt = it - psum2.begin();\\n                if (it != psum2.begin())\\n                {\\n                    nfs -= *prev(it);    \\n                    LL idx = prev(it) - psum2.begin();\\n                    if (fs[idx] + nfs / cnt >= tar)\\n                        res += ((LL)tar - 1) * par;\\n                    else\\n                        res += ((LL)fs[idx] + nfs / cnt) * par;\\n                }                \\n            }\\n\\n            res += cplt * fu;\\n            ans = max(ans, res);\\n            nfs = nfs_cp, cplt = cplt_cp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long LL;\\n\\nclass Solution {\\npublic:\\n    LL maximumBeauty(vector<int>& fs, LL nfs, int tar, int fu, int par) {\\n        \\n        LL ans = 0;\\n        LL cplt = 0;\\n        sort(fs.begin(), fs.end());\\n        while (fs.size())\\n        {\\n            if (fs.back() < tar) break;\\n            LL t = fs.back(); fs.pop_back();\\n            cplt ++ ;\\n        }\\n        \\n        int n = fs.size();\\n        \\n        vector<LL> psum, psum2;\\n        for (int i = n - 1; i >= 0; -- i)\\n            psum.push_back(tar - fs[i]);\\n        for (int i = 1; i < n; ++ i) psum[i] += psum[i - 1];\\n        \\n        psum2.push_back(0);\\n        for (int i = 1; i < n; ++ i)\\n            psum2.push_back(psum2.back() + (fs[i] - fs[i - 1]) * i);\\n        \\n        LL nfs_cp = nfs, cplt_cp = cplt;\\n        LL cum = 0;\\n        for (int i = 0; i <= n; ++ i)\\n        {\\n            LL res = 0;\\n            \\n            if (i > 0)\\n            {\\n                if (psum[i - 1] > nfs) break;\\n                nfs -= psum[i - 1];\\n                cplt += i;\\n            }\\n            if (i < n)\\n            {\\n                auto it = upper_bound(psum2.begin(), psum2.begin() + n - i, nfs);\\n                LL cnt = it - psum2.begin();\\n                if (it != psum2.begin())\\n                {\\n                    nfs -= *prev(it);    \\n                    LL idx = prev(it) - psum2.begin();\\n                    if (fs[idx] + nfs / cnt >= tar)\\n                        res += ((LL)tar - 1) * par;\\n                    else\\n                        res += ((LL)fs[idx] + nfs / cnt) * par;\\n                }                \\n            }\\n\\n            res += cplt * fu;\\n            ans = max(ans, res);\\n            nfs = nfs_cp, cplt = cplt_cp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088661,
                "title": "short-binary-search-nlogn-solution",
                "content": "```python\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        n = len(flowers)\\n        if flowers[0] >= target : return n * full\\n        res = c = 0\\n        a = []\\n        for i,j in enumerate(flowers):\\n            j = min(j,target)\\n            c += j\\n            a.append(j  * (i+1) - c)\\n        import bisect\\n        for i in range(n-1,-1,-1):\\n            idx = bisect.bisect(a,newFlowers+1,0,i+1)-1\\n            k = min(flowers[idx] + (newFlowers-a[idx]) // (idx+1), target - 1)\\n            res = max(res, k * partial + (n-i-1) * full)\\n            newFlowers -= max(0, target-flowers[i])\\n            if newFlowers < 0: break\\n            res = max(res, (n-i) * full)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        n = len(flowers)\\n        if flowers[0] >= target : return n * full\\n        res = c = 0\\n        a = []\\n        for i,j in enumerate(flowers):\\n            j = min(j,target)\\n            c += j\\n            a.append(j  * (i+1) - c)\\n        import bisect\\n        for i in range(n-1,-1,-1):\\n            idx = bisect.bisect(a,newFlowers+1,0,i+1)-1\\n            k = min(flowers[idx] + (newFlowers-a[idx]) // (idx+1), target - 1)\\n            res = max(res, k * partial + (n-i-1) * full)\\n            newFlowers -= max(0, target-flowers[i])\\n            if newFlowers < 0: break\\n            res = max(res, (n-i) * full)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051410,
                "title": "c-solution",
                "content": "```\\nint comp (const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n    \\nlong long maximumBeauty(int* flowers, int flowersSize, long long newFlowers, int target, int full, int partial){\\n    if (flowersSize == 1){\\n        if (flowers[0] + newFlowers >= target){\\n            return full > (long long)(target-1)*partial ? full : (long long)(target-1)*partial;\\n        } else {\\n            return (long long)(flowers[0] + newFlowers)*partial;\\n        }\\n    }\\n    qsort(flowers,flowersSize,sizeof(int),comp);\\n    int end = flowersSize-1;\\n    long long now = 0;\\n    while (end >= 0 && flowers[end] >= target){\\n        end--;\\n        now++;\\n    }\\n    if (end < 0){\\n        return (long long)flowersSize*full;\\n    }\\n    \\n    now *= full;\\n    long long* p_add = malloc(sizeof(long long)*flowersSize);\\n    p_add[0] = flowers[1]-flowers[0];\\n    for (int i = 1 ; i < flowersSize-1 ; i++){\\n        p_add[i] = (i+1)*(flowers[i+1]-flowers[i]);\\n        p_add[i] +=  p_add[i-1];\\n        if (p_add[i] > newFlowers){\\n            break;\\n        }  \\n    }\\n    \\n    int head = 0;\\n    long long copy = newFlowers;\\n    while (head < end && copy >= p_add[head]){\\n        head++;\\n    }\\n    if (head > 0){\\n        copy -= p_add[head-1];\\n    }\\n    \\n    long long min = flowers[head]+copy/(head+1);\\n    if (min >= target){\\n        long long a = (long long)full*flowersSize;\\n        long long b = (long long)full*(flowersSize-1)+(long long)(target-1)*partial;\\n        return a > b ? a : b;\\n    }\\n    long long ans = (min*partial)+now;\\n    \\n    \\n    newFlowers -= target-flowers[end];\\n    if (newFlowers >= 0){\\n        now += full;\\n        while (newFlowers < p_add[head] || head >= (end-1) ){\\n            head--;\\n            if (head < 0){\\n                if (ans < (flowers[0]+newFlowers)*partial + now){\\n                    ans = (flowers[0]+newFlowers)*partial + now;\\n                    }  \\n                return ans;\\n            }\\n        }\\n        copy = newFlowers-p_add[head];\\n        min = flowers[head+1] + copy/(head+2);\\n        copy %= (head+2);\\n        while (end-1 > head+1 && target-flowers[end-1] <= copy) {\\n            copy -= (target-flowers[end-1]);\\n            now += full;\\n            newFlowers -= (target-flowers[end-1]);\\n            end--;\\n        }\\n        while (target-min <= copy) {\\n            copy -= (target-min);\\n            now += full;\\n            newFlowers -= (target-flowers[end-1]);\\n            end--;\\n        }\\n        if (ans < (min*partial)+now){\\n            ans = (min*partial)+now;\\n        }\\n    }   \\n    end--;\\n    \\n    while (1){\\n        newFlowers -= target-flowers[end];\\n        if (newFlowers >= 0){\\n            now += full;\\n            while (head >= (end-1) || newFlowers < p_add[head]){\\n                head--;\\n            }\\n            min = flowers[head+1] + (newFlowers-p_add[head])/(head+2);\\n            if (ans < (min*partial)+now){\\n                ans = (min*partial)+now;\\n            }\\n            end--;\\n        } else {\\n            break;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint comp (const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n    \\nlong long maximumBeauty(int* flowers, int flowersSize, long long newFlowers, int target, int full, int partial){\\n    if (flowersSize == 1){\\n        if (flowers[0] + newFlowers >= target){\\n            return full > (long long)(target-1)*partial ? full : (long long)(target-1)*partial;\\n        } else {\\n            return (long long)(flowers[0] + newFlowers)*partial;\\n        }\\n    }\\n    qsort(flowers,flowersSize,sizeof(int),comp);\\n    int end = flowersSize-1;\\n    long long now = 0;\\n    while (end >= 0 && flowers[end] >= target){\\n        end--;\\n        now++;\\n    }\\n    if (end < 0){\\n        return (long long)flowersSize*full;\\n    }\\n    \\n    now *= full;\\n    long long* p_add = malloc(sizeof(long long)*flowersSize);\\n    p_add[0] = flowers[1]-flowers[0];\\n    for (int i = 1 ; i < flowersSize-1 ; i++){\\n        p_add[i] = (i+1)*(flowers[i+1]-flowers[i]);\\n        p_add[i] +=  p_add[i-1];\\n        if (p_add[i] > newFlowers){\\n            break;\\n        }  \\n    }\\n    \\n    int head = 0;\\n    long long copy = newFlowers;\\n    while (head < end && copy >= p_add[head]){\\n        head++;\\n    }\\n    if (head > 0){\\n        copy -= p_add[head-1];\\n    }\\n    \\n    long long min = flowers[head]+copy/(head+1);\\n    if (min >= target){\\n        long long a = (long long)full*flowersSize;\\n        long long b = (long long)full*(flowersSize-1)+(long long)(target-1)*partial;\\n        return a > b ? a : b;\\n    }\\n    long long ans = (min*partial)+now;\\n    \\n    \\n    newFlowers -= target-flowers[end];\\n    if (newFlowers >= 0){\\n        now += full;\\n        while (newFlowers < p_add[head] || head >= (end-1) ){\\n            head--;\\n            if (head < 0){\\n                if (ans < (flowers[0]+newFlowers)*partial + now){\\n                    ans = (flowers[0]+newFlowers)*partial + now;\\n                    }  \\n                return ans;\\n            }\\n        }\\n        copy = newFlowers-p_add[head];\\n        min = flowers[head+1] + copy/(head+2);\\n        copy %= (head+2);\\n        while (end-1 > head+1 && target-flowers[end-1] <= copy) {\\n            copy -= (target-flowers[end-1]);\\n            now += full;\\n            newFlowers -= (target-flowers[end-1]);\\n            end--;\\n        }\\n        while (target-min <= copy) {\\n            copy -= (target-min);\\n            now += full;\\n            newFlowers -= (target-flowers[end-1]);\\n            end--;\\n        }\\n        if (ans < (min*partial)+now){\\n            ans = (min*partial)+now;\\n        }\\n    }   \\n    end--;\\n    \\n    while (1){\\n        newFlowers -= target-flowers[end];\\n        if (newFlowers >= 0){\\n            now += full;\\n            while (head >= (end-1) || newFlowers < p_add[head]){\\n                head--;\\n            }\\n            min = flowers[head+1] + (newFlowers-p_add[head])/(head+2);\\n            if (ans < (min*partial)+now){\\n                ans = (min*partial)+now;\\n            }\\n            end--;\\n        } else {\\n            break;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045810,
                "title": "javascript-time-o-n-excluding-sorting-space-o-1",
                "content": "```\\nvar maximumBeauty = function(flowers, newFlowers, target, full, partial) {\\n    flowers.sort((b, a) => a - b);\\n\\n    let p1 = 0, ans = 0;\\n\\n    while (target - flowers[p1] <= newFlowers)\\n        newFlowers -= Math.max(0, target - flowers[p1++]);\\n\\n    if (p1 == flowers.length)\\n        return (p1 - 1) * full + Math.max(full, flowers.at(-1) < target ? (target - 1) * partial : 0);\\n\\n    for (let p2 = flowers.length - 1, suffixSum = flowers[p2]; p1 >= 0 && target > flowers[p1]; ) {\\n        while (p1 < p2 && (flowers[p2 - 1] == flowers[p2] || suffixSum + newFlowers > (flowers.length - p2) * flowers[p2 - 1])) {\\n            suffixSum += flowers[--p2];\\n        }\\n\\n        const incompleteFlowersSpan = flowers.length - p2;\\n        const leftWall = p2 == p1 ? target : flowers[p2 - 1];\\n        const minIncompleteFlowers = leftWall -\\n\\t\\t\\tMath.ceil((incompleteFlowersSpan * leftWall - (suffixSum + newFlowers)) / incompleteFlowersSpan);\\n\\n        ans = Math.max(ans, p1 * full + minIncompleteFlowers * partial);\\n        newFlowers += target - flowers[--p1];\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maximumBeauty = function(flowers, newFlowers, target, full, partial) {\\n    flowers.sort((b, a) => a - b);\\n\\n    let p1 = 0, ans = 0;\\n\\n    while (target - flowers[p1] <= newFlowers)\\n        newFlowers -= Math.max(0, target - flowers[p1++]);\\n\\n    if (p1 == flowers.length)\\n        return (p1 - 1) * full + Math.max(full, flowers.at(-1) < target ? (target - 1) * partial : 0);\\n\\n    for (let p2 = flowers.length - 1, suffixSum = flowers[p2]; p1 >= 0 && target > flowers[p1]; ) {\\n        while (p1 < p2 && (flowers[p2 - 1] == flowers[p2] || suffixSum + newFlowers > (flowers.length - p2) * flowers[p2 - 1])) {\\n            suffixSum += flowers[--p2];\\n        }\\n\\n        const incompleteFlowersSpan = flowers.length - p2;\\n        const leftWall = p2 == p1 ? target : flowers[p2 - 1];\\n        const minIncompleteFlowers = leftWall -\\n\\t\\t\\tMath.ceil((incompleteFlowersSpan * leftWall - (suffixSum + newFlowers)) / incompleteFlowersSpan);\\n\\n        ans = Math.max(ans, p1 * full + minIncompleteFlowers * partial);\\n        newFlowers += target - flowers[--p1];\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970184,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n  = flowers.size();\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        vector<long long> prefix(n, LONG_LONG_MAX);\\n        prefix[n-1] = 0;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            if(flowers[i] < target)\\n                    prefix[i] = (flowers[i] - flowers[i+1])*(n-i-1) + prefix[i+1];\\n            else\\n            {\\n                prefix[i] = (target-1 - flowers[i+1])*(n-i-1) + prefix[i+1];\\n                break;\\n            }\\n        }\\n        int start = 0;\\n        while(start < n && flowers[start] >= target)\\n            start++;\\n        long long comp = start;\\n        long long ans = (long long)start*full;\\n        for(int i = start; i < n; i++)\\n        {\\n            int index = lower_bound(prefix.begin()+i, prefix.end(), newFlowers, greater<long long>()) - prefix.begin();\\n            long long rem = newFlowers - prefix[index];\\n            long long min_value = min(flowers[index] + rem/(n-index), (long long)target-1);\\n            ans = max(ans, min_value*partial + comp*full);\\n            if(newFlowers - target+flowers[i] >= 0)\\n            {\\n                newFlowers= newFlowers-(target-flowers[i]);\\n                comp++;\\n            }\\n            else\\n                break;\\n            if(newFlowers <= 0)\\n                break;\\n        }\\n        if(newFlowers >= target - flowers[n-1])\\n            ans = max((long long)n*full, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        int n  = flowers.size();\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        vector<long long> prefix(n, LONG_LONG_MAX);\\n        prefix[n-1] = 0;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            if(flowers[i] < target)\\n                    prefix[i] = (flowers[i] - flowers[i+1])*(n-i-1) + prefix[i+1];\\n            else\\n            {\\n                prefix[i] = (target-1 - flowers[i+1])*(n-i-1) + prefix[i+1];\\n                break;\\n            }\\n        }\\n        int start = 0;\\n        while(start < n && flowers[start] >= target)\\n            start++;\\n        long long comp = start;\\n        long long ans = (long long)start*full;\\n        for(int i = start; i < n; i++)\\n        {\\n            int index = lower_bound(prefix.begin()+i, prefix.end(), newFlowers, greater<long long>()) - prefix.begin();\\n            long long rem = newFlowers - prefix[index];\\n            long long min_value = min(flowers[index] + rem/(n-index), (long long)target-1);\\n            ans = max(ans, min_value*partial + comp*full);\\n            if(newFlowers - target+flowers[i] >= 0)\\n            {\\n                newFlowers= newFlowers-(target-flowers[i]);\\n                comp++;\\n            }\\n            else\\n                break;\\n            if(newFlowers <= 0)\\n                break;\\n        }\\n        if(newFlowers >= target - flowers[n-1])\\n            ans = max((long long)n*full, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967596,
                "title": "problem-with-a-test-case-solved",
                "content": "Perhaps I don\\'t understand this question.  If `full > partial`, and you have at least enough `numFlowers` to complete out all your gardens, isn\\'t the solution just `# gardens * full`?\\n\\nflowers = [19,17,6,9,19]\\nnumFlowers = 24\\ntarget = 10\\nfull = 17\\npartial = 4\\n\\nIn this example, there are `5` gardens, with `full = 17`, so there\\'s no way I can have a more beautiful garden than `5 * 17 = 85`, right?  This test fails for me saying it\\'s possible to have beauty = 104, but I don\\'t see how that amount of beauty is possible.",
                "solutionTags": [],
                "code": "Perhaps I don\\'t understand this question.  If `full > partial`, and you have at least enough `numFlowers` to complete out all your gardens, isn\\'t the solution just `# gardens * full`?\\n\\nflowers = [19,17,6,9,19]\\nnumFlowers = 24\\ntarget = 10\\nfull = 17\\npartial = 4\\n\\nIn this example, there are `5` gardens, with `full = 17`, so there\\'s no way I can have a more beautiful garden than `5 * 17 = 85`, right?  This test fails for me saying it\\'s possible to have beauty = 104, but I don\\'t see how that amount of beauty is possible.",
                "codeTag": "Unknown"
            },
            {
                "id": 1964468,
                "title": "c-binary-search-explanation-beginner-friendly",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        long long ans;\\n        // Will use this vector to store all gardens with flowers less than target\\n        vector<long long int> p;\\n        long long int fullc = 0;\\n        for(int i=0;i<flowers.size();i++){\\n            if(flowers[i] >= target){\\n                fullc += 1;\\n            }else{\\n                p.push_back(flowers[i]);\\n            }\\n        }\\n        // Initalizing ans with base value\\n        ans = fullc * full;\\n        if(p.size() == 0)\\n            return ans;\\n        // Defining and creating prefix array which will be storing the number of flowers required for makeing all lower flowers\\n        // equal to the current number\\n        vector<long long int> pref(p.size(), 0);\\n        for(int i=1;i<p.size();i++){\\n            pref[i] = (p[i] - p[i-1]) * i + pref[i-1];\\n        }\\n        long long int val = 0;\\n        // Considering all partial and finding best possible ans\\n        long long int index = upper_bound(pref.begin(), pref.end(), newFlowers) - pref.begin();\\n        index -= 1;\\n\\n        long long int count = (newFlowers - pref[index]) / (index + 1);\\n        if(count + p[index] >= target){\\n            val = 1ll * partial * (target - 1);\\n        }else{\\n            val = (p[index] + count) * partial;\\n        }\\n        // Updating ans for base case\\n        ans = max(ans, val + ans);\\n        \\n        long long int i = p.size() - 1;\\n        \\n        // Iterating and adding garden to full group and calculating ans\\n        while(i >= 0){\\n            long long int currVal = 0;\\n            // Flowers required for current garden to reach target\\n            long long int toFull = target - p[i];\\n            \\n            // If enough flowers are not there then break the loop and exit (ans is already received)\\n            if(toFull >= newFlowers)\\n                break;\\n            fullc += 1;\\n            newFlowers -= toFull;\\n            // When all flowers are full\\n            if(i == 0){\\n                // updating ans if all garden are part of full group \\n                ans = max(ans, fullc * full);\\n                break;\\n            }\\n            // Binary search to find the best possible number closest to the remaining flowers\\n            // So that we can calculate the max beauty of the partial garden \\n            index = upper_bound(pref.begin(), pref.begin() + i, newFlowers) - pref.begin();\\n            index -= 1;\\n            \\n            // Calculating partila beauty for the current iteration\\n            long long int count = (newFlowers - pref[index]) / (index + 1);\\n            if(count + p[index] >= target){\\n                currVal = 1ll * partial * (target - 1);\\n            }else{\\n                currVal = 1ll * (p[index] + count) * partial;\\n            }\\n            \\n            // keep updating ans\\n            ans = max(ans, fullc * full + currVal);\\n            i-=1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        long long ans;\\n        // Will use this vector to store all gardens with flowers less than target\\n        vector<long long int> p;\\n        long long int fullc = 0;\\n        for(int i=0;i<flowers.size();i++){\\n            if(flowers[i] >= target){\\n                fullc += 1;\\n            }else{\\n                p.push_back(flowers[i]);\\n            }\\n        }\\n        // Initalizing ans with base value\\n        ans = fullc * full;\\n        if(p.size() == 0)\\n            return ans;\\n        // Defining and creating prefix array which will be storing the number of flowers required for makeing all lower flowers\\n        // equal to the current number\\n        vector<long long int> pref(p.size(), 0);\\n        for(int i=1;i<p.size();i++){\\n            pref[i] = (p[i] - p[i-1]) * i + pref[i-1];\\n        }\\n        long long int val = 0;\\n        // Considering all partial and finding best possible ans\\n        long long int index = upper_bound(pref.begin(), pref.end(), newFlowers) - pref.begin();\\n        index -= 1;\\n\\n        long long int count = (newFlowers - pref[index]) / (index + 1);\\n        if(count + p[index] >= target){\\n            val = 1ll * partial * (target - 1);\\n        }else{\\n            val = (p[index] + count) * partial;\\n        }\\n        // Updating ans for base case\\n        ans = max(ans, val + ans);\\n        \\n        long long int i = p.size() - 1;\\n        \\n        // Iterating and adding garden to full group and calculating ans\\n        while(i >= 0){\\n            long long int currVal = 0;\\n            // Flowers required for current garden to reach target\\n            long long int toFull = target - p[i];\\n            \\n            // If enough flowers are not there then break the loop and exit (ans is already received)\\n            if(toFull >= newFlowers)\\n                break;\\n            fullc += 1;\\n            newFlowers -= toFull;\\n            // When all flowers are full\\n            if(i == 0){\\n                // updating ans if all garden are part of full group \\n                ans = max(ans, fullc * full);\\n                break;\\n            }\\n            // Binary search to find the best possible number closest to the remaining flowers\\n            // So that we can calculate the max beauty of the partial garden \\n            index = upper_bound(pref.begin(), pref.begin() + i, newFlowers) - pref.begin();\\n            index -= 1;\\n            \\n            // Calculating partila beauty for the current iteration\\n            long long int count = (newFlowers - pref[index]) / (index + 1);\\n            if(count + p[index] >= target){\\n                currVal = 1ll * partial * (target - 1);\\n            }else{\\n                currVal = 1ll * (p[index] + count) * partial;\\n            }\\n            \\n            // keep updating ans\\n            ans = max(ans, fullc * full + currVal);\\n            i-=1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954929,
                "title": "moving-window-prefix-sum-binary-search-o-n-log-n",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        F = flowers[:]\\n        n = len(flowers)\\n        ans = 0\\n        \\n        nf = newFlowers\\n        r = n - 1\\n        while r >= 0:\\n            if F[r] >= target:\\n                r -= 1\\n                continue\\n            diff = target - F[r]\\n            # print(f\"r {r}, diff {diff}, nf {nf}\")\\n            if nf < diff:\\n                break\\n            nf -= diff\\n            r -= 1\\n        # print(f\"r {r}, nf {nf}\")\\n        if r == -1:\\n            ans = n * full\\n            if F[0] < target:\\n                curr = (target-1) * partial + (n-1) * full\\n                ans = max(ans, curr)\\n            return ans\\n\\n        P = [0]  # Prefix sum, count needed to fill to current amount.\\n        pre = F[0]\\n        for i in range(1, n):\\n            if F[i] >= target:\\n                P.append(float(\"inf\"))\\n                break\\n            diff = F[i] - pre\\n            if diff == 0:\\n                P.append(P[-1])\\n                continue\\n            P.append(P[-1] + diff * (i))\\n            pre = F[i]\\n            \\n        # print(\"p sum\", P)\\n        ans = (n-1-r) * full\\n        max_partial = self.fill(F, nf, P, r+1)\\n        ans += max_partial * partial\\n        \\n        for i in range(r+1, n):\\n            if F[i] >= target:\\n                break\\n            diff = target - F[i]\\n            nf += diff\\n            max_partial = self.fill(F, nf, P, i+1)\\n            curr = (n-1-i) * full + max_partial * partial\\n            ans = max(ans, curr)\\n        \\n        return ans\\n    \\n    def fill(self, F, nf, P, r):\\n        n = len(F)\\n        i = bisect.bisect_right(P, nf, 0, r)\\n        # print(f\"i {i}, nf {nf}, P {P}\")\\n        h = F[i-1]\\n        inc = (nf - P[i-1])//i\\n        max_partial = h + inc\\n        # print(f\"h {h}, inc {inc}\")\\n        return max_partial\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        F = flowers[:]\\n        n = len(flowers)\\n        ans = 0\\n        \\n        nf = newFlowers\\n        r = n - 1\\n        while r >= 0:\\n            if F[r] >= target:\\n                r -= 1\\n                continue\\n            diff = target - F[r]\\n            # print(f\"r {r}, diff {diff}, nf {nf}\")\\n            if nf < diff:\\n                break\\n            nf -= diff\\n            r -= 1\\n        # print(f\"r {r}, nf {nf}\")\\n        if r == -1:\\n            ans = n * full\\n            if F[0] < target:\\n                curr = (target-1) * partial + (n-1) * full\\n                ans = max(ans, curr)\\n            return ans\\n\\n        P = [0]  # Prefix sum, count needed to fill to current amount.\\n        pre = F[0]\\n        for i in range(1, n):\\n            if F[i] >= target:\\n                P.append(float(\"inf\"))\\n                break\\n            diff = F[i] - pre\\n            if diff == 0:\\n                P.append(P[-1])\\n                continue\\n            P.append(P[-1] + diff * (i))\\n            pre = F[i]\\n            \\n        # print(\"p sum\", P)\\n        ans = (n-1-r) * full\\n        max_partial = self.fill(F, nf, P, r+1)\\n        ans += max_partial * partial\\n        \\n        for i in range(r+1, n):\\n            if F[i] >= target:\\n                break\\n            diff = target - F[i]\\n            nf += diff\\n            max_partial = self.fill(F, nf, P, i+1)\\n            curr = (n-1-i) * full + max_partial * partial\\n            ans = max(ans, curr)\\n        \\n        return ans\\n    \\n    def fill(self, F, nf, P, r):\\n        n = len(F)\\n        i = bisect.bisect_right(P, nf, 0, r)\\n        # print(f\"i {i}, nf {nf}, P {P}\")\\n        h = F[i-1]\\n        inc = (nf - P[i-1])//i\\n        max_partial = h + inc\\n        # print(f\"h {h}, inc {inc}\")\\n        return max_partial\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948266,
                "title": "python-o-n-inspired-by-bakerston",
                "content": "Inspired by @Bakerston\\'s solution [https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/discuss/1931085/Python-Explanation-with-pictures-Greedy.](http://)\\n\\nUse bucket sort instead of general sort\\nUse one loop search instead of binary search because of monotonicity\\nThe overall time complexity would be reduced to O(N), where n = 10^5\\n```\\ndef sln(self,flowers,newFlowers,target,full,partial):\\n\\tn = len(flowers)\\n\\ttemp = [0]*100001\\n\\tfor x in flowers:\\n\\t\\tif x < target:\\n\\t\\t\\ttemp[x] += 1\\n\\tnums = []\\n\\tfor x in range(100001):\\n\\t\\tfor _ in range(temp[x],0,-1):\\n\\t\\t\\tnums.append(x)\\n\\tif not nums:\\n\\t\\treturn full*n\\n\\tif newFlowers >= target*len(nums) - sum(nums):\\n\\t\\treturn max(full*n,full*(n-1)+partial*(target-1))\\n\\n\\tcost = [0]\\n\\tfor i in range(1,len(nums)):\\n\\t\\tpre = cost[-1]\\n\\t\\tcost.append(pre + i*(nums[i]-nums[i-1]))\\n\\n\\tj = len(nums)-1\\n\\tidx = j\\n\\tres = 0\\n\\twhile newFlowers >= 0:\\n\\t\\twhile cost[idx]>newFlowers:\\n\\t\\t\\tidx -= 1\\n\\t\\tidx = min(j,idx)\\n\\t\\t# current minimum flower in the incomplete gardens\\n\\t\\tbar = nums[idx] + (newFlowers-cost[idx])//(idx+1)\\n\\t\\tres = max(res,bar*partial + (n-j-1)*full)\\n\\t\\tnewFlowers -= (target - nums[j])\\n\\t\\tj -= 1\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\ndef sln(self,flowers,newFlowers,target,full,partial):\\n\\tn = len(flowers)\\n\\ttemp = [0]*100001\\n\\tfor x in flowers:\\n\\t\\tif x < target:\\n\\t\\t\\ttemp[x] += 1\\n\\tnums = []\\n\\tfor x in range(100001):\\n\\t\\tfor _ in range(temp[x],0,-1):\\n\\t\\t\\tnums.append(x)\\n\\tif not nums:\\n\\t\\treturn full*n\\n\\tif newFlowers >= target*len(nums) - sum(nums):\\n\\t\\treturn max(full*n,full*(n-1)+partial*(target-1))\\n\\n\\tcost = [0]\\n\\tfor i in range(1,len(nums)):\\n\\t\\tpre = cost[-1]\\n\\t\\tcost.append(pre + i*(nums[i]-nums[i-1]))\\n\\n\\tj = len(nums)-1\\n\\tidx = j\\n\\tres = 0\\n\\twhile newFlowers >= 0:\\n\\t\\twhile cost[idx]>newFlowers:\\n\\t\\t\\tidx -= 1\\n\\t\\tidx = min(j,idx)\\n\\t\\t# current minimum flower in the incomplete gardens\\n\\t\\tbar = nums[idx] + (newFlowers-cost[idx])//(idx+1)\\n\\t\\tres = max(res,bar*partial + (n-j-1)*full)\\n\\t\\tnewFlowers -= (target - nums[j])\\n\\t\\tj -= 1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1946719,
                "title": "c-binary-search-gready",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \\n    {\\n        int n=flowers.size();\\n        sort(flowers.begin(),flowers.end());\\n        vector<ll>suffix(n,0),prefix(n,0);\\n        prefix[0]=flowers[0];\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+flowers[i];\\n        suffix[n-1]=max(0,target-flowers[n-1]);\\n        for(int i=n-2;i>=0;i--)suffix[i]=suffix[i+1]+max(0,target-flowers[i]);\\n        ll ans=0;\\n        if(suffix[0]<=newFlowers)ans=1ll*n*full;\\n        for(int i=0;i<target;i++)\\n        {\\n            auto it=upper_bound(flowers.begin(),flowers.end(),i);\\n            if(it==flowers.begin()&&*it>i)\\n            {\\n                continue;\\n            }else if(it==flowers.end())\\n            {\\n                if(prefix[n-1]>newFlowers)continue;\\n                ll left=newFlowers-(1ll*i*n-prefix[n-1]);\\n                if(left<0)continue;\\n                ll need=target-i;\\n                ll have=min(n-1ll,left/need);\\n                ans=max(ans,1ll*i*partial+1ll*have*full);\\n            }else\\n            {\\n                if(*it>i)it--;\\n                int idx=it-flowers.begin();\\n                ll left=newFlowers-(1ll*i*(idx+1)-prefix[idx]);\\n                if(left<0)continue;\\n                auto it2=upper_bound(suffix.rbegin(),suffix.rend(),left);\\n                if(it2==suffix.rbegin())\\n                {\\n                    ans=max(ans,1ll*i*partial);\\n                }else if(it2==suffix.rend())\\n                {\\n                    ans=max(ans,1ll*(n-1)*full+1ll*partial*i);\\n                }else\\n                {\\n                    if(*it2>left)it2--;\\n                    int idx2=it2-suffix.rbegin();\\n                    idx2=n-1-idx2;\\n                    if(idx2>idx)ans=max(ans,1ll*(n-idx2)*full+1ll*partial*i);\\n                    else\\n                    {\\n                        left-=suffix[idx+1];\\n                        ll need=target-i;\\n                        ll have=min(1ll*idx,1ll*left/need);\\n                        ans=max(ans,1ll*(have+n-idx-1)*full+1ll*partial*i);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Search Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \\n    {\\n        int n=flowers.size();\\n        sort(flowers.begin(),flowers.end());\\n        vector<ll>suffix(n,0),prefix(n,0);\\n        prefix[0]=flowers[0];\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+flowers[i];\\n        suffix[n-1]=max(0,target-flowers[n-1]);\\n        for(int i=n-2;i>=0;i--)suffix[i]=suffix[i+1]+max(0,target-flowers[i]);\\n        ll ans=0;\\n        if(suffix[0]<=newFlowers)ans=1ll*n*full;\\n        for(int i=0;i<target;i++)\\n        {\\n            auto it=upper_bound(flowers.begin(),flowers.end(),i);\\n            if(it==flowers.begin()&&*it>i)\\n            {\\n                continue;\\n            }else if(it==flowers.end())\\n            {\\n                if(prefix[n-1]>newFlowers)continue;\\n                ll left=newFlowers-(1ll*i*n-prefix[n-1]);\\n                if(left<0)continue;\\n                ll need=target-i;\\n                ll have=min(n-1ll,left/need);\\n                ans=max(ans,1ll*i*partial+1ll*have*full);\\n            }else\\n            {\\n                if(*it>i)it--;\\n                int idx=it-flowers.begin();\\n                ll left=newFlowers-(1ll*i*(idx+1)-prefix[idx]);\\n                if(left<0)continue;\\n                auto it2=upper_bound(suffix.rbegin(),suffix.rend(),left);\\n                if(it2==suffix.rbegin())\\n                {\\n                    ans=max(ans,1ll*i*partial);\\n                }else if(it2==suffix.rend())\\n                {\\n                    ans=max(ans,1ll*(n-1)*full+1ll*partial*i);\\n                }else\\n                {\\n                    if(*it2>left)it2--;\\n                    int idx2=it2-suffix.rbegin();\\n                    idx2=n-1-idx2;\\n                    if(idx2>idx)ans=max(ans,1ll*(n-idx2)*full+1ll*partial*i);\\n                    else\\n                    {\\n                        left-=suffix[idx+1];\\n                        ll need=target-i;\\n                        ll have=min(1ll*idx,1ll*left/need);\\n                        ans=max(ans,1ll*(have+n-idx-1)*full+1ll*partial*i);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941171,
                "title": "python-nlog-2-n-binary-search-solution",
                "content": "```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        i = len(flowers) - 1\\n        fulled = 0\\n        while i >= 0 and flowers[i] >= target:\\n            fulled += full\\n            i -= 1\\n        i += 1\\n        flowers = flowers[:i]\\n        if not flowers: return fulled\\n        head = flowers[:]\\n        head.insert(0, 0)\\n        n = len(flowers)\\n        for i in range(n): head[i + 1] += head[i]\\n        ans, used = 0, 0\\n        for i in range(n - 1, -1, -1):\\n            if newFlowers < used: break\\n            lo, hi = flowers[0], target\\n            cur = lo\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                pos = min(i + 1, bisect(flowers, mid))\\n                needed = pos * mid - head[pos]\\n                if needed <= newFlowers - used:\\n                    cur = max(cur, mid)\\n                    lo = mid + 1\\n                else: hi = mid - 1\\n            if cur == target: cmax = max(full * n, full * (n - 1) + (target - 1) * partial)\\n            else: cmax = full * (n - 1 - i) + cur * partial\\n            ans = max(ans, cmax)\\n            used += (target - flowers[i])\\n        if newFlowers >= n * target - head[-1]: ans = max(ans, full * n)\\n        return ans + fulled\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        i = len(flowers) - 1\\n        fulled = 0\\n        while i >= 0 and flowers[i] >= target:\\n            fulled += full\\n            i -= 1\\n        i += 1\\n        flowers = flowers[:i]\\n        if not flowers: return fulled\\n        head = flowers[:]\\n        head.insert(0, 0)\\n        n = len(flowers)\\n        for i in range(n): head[i + 1] += head[i]\\n        ans, used = 0, 0\\n        for i in range(n - 1, -1, -1):\\n            if newFlowers < used: break\\n            lo, hi = flowers[0], target\\n            cur = lo\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                pos = min(i + 1, bisect(flowers, mid))\\n                needed = pos * mid - head[pos]\\n                if needed <= newFlowers - used:\\n                    cur = max(cur, mid)\\n                    lo = mid + 1\\n                else: hi = mid - 1\\n            if cur == target: cmax = max(full * n, full * (n - 1) + (target - 1) * partial)\\n            else: cmax = full * (n - 1 - i) + cur * partial\\n            ans = max(ans, cmax)\\n            used += (target - flowers[i])\\n        if newFlowers >= n * target - head[-1]: ans = max(ans, full * n)\\n        return ans + fulled\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938865,
                "title": "python-greedy-binary-search-to-find-minimum-value-of-incomplete-gardens",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(flowers)[::-1]\\n        n = len(flowers)\\n        \\n        preSum = [0]\\n        for i in range(n-1, -1, -1):\\n            preSum.append(preSum[-1] + flowers[i])\\n        \\n        preSum = preSum[::-1]\\n        \\n        def findMin(left, numAdded):\\n            lo = flowers[-1]\\n            hi = target - 1\\n            \\n            def checkMin(value):\\n                a = left\\n                b = n - 1\\n                while(a <= b):\\n                    mid = (a + b)//2\\n                    if flowers[mid] >= value:\\n                        a = mid + 1\\n                    else:\\n                        b = mid - 1\\n                \\n                goodPoint = b + 1\\n                return preSum[goodPoint] + numAdded >= value *  (n - goodPoint)\\n            \\n            while(lo <= hi):\\n                mid = (lo + hi) // 2\\n                if checkMin(mid):\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n            \\n            return lo - 1\\n        \\n        start = n\\n        for i in range(n):\\n            if flowers[i] < target:\\n                start = i\\n                break\\n              \\n        rest = sum(flowers[start:])\\n        maxScore = start * full + ((findMin(start, newFlowers)) * partial if n-start > 0 else 0)\\n        while(start < n + 1):\\n            maxScore = max(maxScore, start * full + ((findMin(start, newFlowers)) * partial if n-start > 0 else 0))\\n            if start == n or newFlowers < target - flowers[start]:\\n                break\\n            else:\\n                rest -= flowers[start]\\n                newFlowers -= target - flowers[start]\\n                start += 1\\n        \\n        return maxScore\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(flowers)[::-1]\\n        n = len(flowers)\\n        \\n        preSum = [0]\\n        for i in range(n-1, -1, -1):\\n            preSum.append(preSum[-1] + flowers[i])\\n        \\n        preSum = preSum[::-1]\\n        \\n        def findMin(left, numAdded):\\n            lo = flowers[-1]\\n            hi = target - 1\\n            \\n            def checkMin(value):\\n                a = left\\n                b = n - 1\\n                while(a <= b):\\n                    mid = (a + b)//2\\n                    if flowers[mid] >= value:\\n                        a = mid + 1\\n                    else:\\n                        b = mid - 1\\n                \\n                goodPoint = b + 1\\n                return preSum[goodPoint] + numAdded >= value *  (n - goodPoint)\\n            \\n            while(lo <= hi):\\n                mid = (lo + hi) // 2\\n                if checkMin(mid):\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n            \\n            return lo - 1\\n        \\n        start = n\\n        for i in range(n):\\n            if flowers[i] < target:\\n                start = i\\n                break\\n              \\n        rest = sum(flowers[start:])\\n        maxScore = start * full + ((findMin(start, newFlowers)) * partial if n-start > 0 else 0)\\n        while(start < n + 1):\\n            maxScore = max(maxScore, start * full + ((findMin(start, newFlowers)) * partial if n-start > 0 else 0))\\n            if start == n or newFlowers < target - flowers[start]:\\n                break\\n            else:\\n                rest -= flowers[start]\\n                newFlowers -= target - flowers[start]\\n                start += 1\\n        \\n        return maxScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937397,
                "title": "python-soln-using-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers_sorted = sorted(flowers)\\n        \\n        full_cnt = 0\\n        min_partial = 1000000\\n        prefix_sm = []\\n        \\n        for i, f in enumerate(flowers_sorted):\\n            if f >= target:\\n                full_cnt += 1\\n            else:\\n                min_partial = min(f, min_partial)\\n            \\n            if not prefix_sm:\\n                prefix_sm.append(0)\\n            else:\\n                nv = prefix_sm[-1] + ((f-flowers_sorted[i-1]) * len(prefix_sm))\\n                prefix_sm.append(nv)\\n        curr_score = full_cnt * full + partial * (0 if min_partial == 1000000 else min_partial)\\n        for f in range(full_cnt, len(flowers_sorted)+1):\\n            rem_flowers = self.calc_rem_flowers(f, flowers_sorted, newFlowers, target) if f > full_cnt else newFlowers\\n            if (rem_flowers <= 0):\\n                break\\n            min_partial = self.calc_min_partial(f, prefix_sm, flowers_sorted, rem_flowers)\\n            if min_partial >= target:\\n                min_partial = target - 1\\n            curr_score = max(curr_score, f * full + partial * min_partial)\\n            newFlowers = rem_flowers\\n        return curr_score\\n    \\n    def calc_rem_flowers(self, f, flowers_sorted, newFlowers, target):\\n        for i in range(len(flowers_sorted)-f, -1, -1):\\n            if target > flowers_sorted[i]:\\n                newFlowers = newFlowers - (target-flowers_sorted[i])\\n            if len(flowers_sorted) - i == f:\\n                return newFlowers\\n        return -1\\n    \\n    def calc_min_partial(self, f, prefix_sm, flowers_sorted, rem_flowers):\\n        # find the minimum value by distributing remaining flowers\\n        N = len(flowers_sorted)\\n        lo = 0\\n        hi = N-f\\n        idx = bisect.bisect_left(prefix_sm, rem_flowers, lo, hi)\\n        if idx == 0:\\n            # distributing 0 flowers\\n            return 0\\n        return flowers_sorted[idx-1] + (rem_flowers - prefix_sm[idx-1])//(idx-lo)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers_sorted = sorted(flowers)\\n        \\n        full_cnt = 0\\n        min_partial = 1000000\\n        prefix_sm = []\\n        \\n        for i, f in enumerate(flowers_sorted):\\n            if f >= target:\\n                full_cnt += 1\\n            else:\\n                min_partial = min(f, min_partial)\\n            \\n            if not prefix_sm:\\n                prefix_sm.append(0)\\n            else:\\n                nv = prefix_sm[-1] + ((f-flowers_sorted[i-1]) * len(prefix_sm))\\n                prefix_sm.append(nv)\\n        curr_score = full_cnt * full + partial * (0 if min_partial == 1000000 else min_partial)\\n        for f in range(full_cnt, len(flowers_sorted)+1):\\n            rem_flowers = self.calc_rem_flowers(f, flowers_sorted, newFlowers, target) if f > full_cnt else newFlowers\\n            if (rem_flowers <= 0):\\n                break\\n            min_partial = self.calc_min_partial(f, prefix_sm, flowers_sorted, rem_flowers)\\n            if min_partial >= target:\\n                min_partial = target - 1\\n            curr_score = max(curr_score, f * full + partial * min_partial)\\n            newFlowers = rem_flowers\\n        return curr_score\\n    \\n    def calc_rem_flowers(self, f, flowers_sorted, newFlowers, target):\\n        for i in range(len(flowers_sorted)-f, -1, -1):\\n            if target > flowers_sorted[i]:\\n                newFlowers = newFlowers - (target-flowers_sorted[i])\\n            if len(flowers_sorted) - i == f:\\n                return newFlowers\\n        return -1\\n    \\n    def calc_min_partial(self, f, prefix_sm, flowers_sorted, rem_flowers):\\n        # find the minimum value by distributing remaining flowers\\n        N = len(flowers_sorted)\\n        lo = 0\\n        hi = N-f\\n        idx = bisect.bisect_left(prefix_sm, rem_flowers, lo, hi)\\n        if idx == 0:\\n            # distributing 0 flowers\\n            return 0\\n        return flowers_sorted[idx-1] + (rem_flowers - prefix_sm[idx-1])//(idx-lo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934480,
                "title": "python-3-binary-search-prefix-sum",
                "content": "Sort the flowers, then greedily fill up the gardens from the maximum flowers, and use binary search to find the max minimum of the first unfilled gardens.\\n```\\ndef maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:        \\n        n = len(flowers)\\n        flowers.sort()\\n        if flowers[0] >= target: return n * full\\n        prefix = [0]\\n        for x in flowers:\\n            prefix.append(prefix[-1]+x)\\n        # calculate the max minimum base on the k and cnt\\n        def cal(cnt, i, j):\\n            if i == j: return 0\\n            l, r = flowers[0], target - 1\\n            while l < r:\\n                mid = (l + r + 1) // 2\\n                idx = bisect.bisect(flowers, mid, 0, j)\\n                if mid * idx - prefix[idx] > cnt:\\n                    r = mid - 1\\n                else: \\n                    l = mid\\n            return l                                        \\n        \\n        j = n - 1\\n        cnt = newFlowers\\n        # greedy to find first j that need to add to target\\n        while j and flowers[j] >= target:\\n            j -= 1          \\n        # nothing add to j, initial res\\n        res = cal(newFlowers, 0, j + 1) * partial + (n - j - 1) * full   \\n        while j >= 0:\\n            cnt = cnt - (target - flowers[j])\\n            if cnt < 0: break\\n            res = max(res, cal(cnt, 0, j) * partial + (n - j) * full)\\n            j -= 1\\n        return res\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "Sort the flowers, then greedily fill up the gardens from the maximum flowers, and use binary search to find the max minimum of the first unfilled gardens.\\n```\\ndef maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:        \\n        n = len(flowers)\\n        flowers.sort()\\n        if flowers[0] >= target: return n * full\\n        prefix = [0]\\n        for x in flowers:\\n            prefix.append(prefix[-1]+x)\\n        # calculate the max minimum base on the k and cnt\\n        def cal(cnt, i, j):\\n            if i == j: return 0\\n            l, r = flowers[0], target - 1\\n            while l < r:\\n                mid = (l + r + 1) // 2\\n                idx = bisect.bisect(flowers, mid, 0, j)\\n                if mid * idx - prefix[idx] > cnt:\\n                    r = mid - 1\\n                else: \\n                    l = mid\\n            return l                                        \\n        \\n        j = n - 1\\n        cnt = newFlowers\\n        # greedy to find first j that need to add to target\\n        while j and flowers[j] >= target:\\n            j -= 1          \\n        # nothing add to j, initial res\\n        res = cal(newFlowers, 0, j + 1) * partial + (n - j - 1) * full   \\n        while j >= 0:\\n            cnt = cnt - (target - flowers[j])\\n            if cnt < 0: break\\n            res = max(res, cal(cnt, 0, j) * partial + (n - j) * full)\\n            j -= 1\\n        return res\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1934220,
                "title": "c-prefix-sum-binary-search-faster-than-100",
                "content": "```\\nlong long maximumBeauty(vector<int> &flowers, long long newFlowers, int _target, int full, int partial) {\\n        long long target = _target;\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int n = flowers.size();\\n        long long min_full = 0;\\n        for (auto flower: flowers) {\\n            if (flower >= target)\\n                min_full++;\\n        }\\n        long long temp = newFlowers;\\n        long long max_full = 0;\\n        for (int i = 0; i < n; i++) {\\n            temp -= max((long long) 0, target - flowers[i]);\\n            if (temp < 0)\\n                break;\\n            max_full++;\\n        }\\n        vector<long long> partial_min_arr(n, 0);\\n        for (int i = n - 2; i >= 0; i--) {\\n            partial_min_arr[i] = partial_min_arr[i + 1] + (flowers[i] - flowers[i + 1]) * (n - 1 - i);\\n        }\\n        vector<long long> remain_by_num_full(n + 1, 0);\\n        temp = newFlowers;\\n        for (int i = min_full; i <= max_full; i++) {\\n            if (i != 0) {\\n                temp -= max((long long) 0, target - flowers[i - 1]);\\n            }\\n            remain_by_num_full[i] = max(temp, (long long) 0);\\n        }\\n        long long res = -1;\\n        for (long long num_full = min_full; num_full <= max_full; num_full++) {\\n            long long cur = full * num_full;\\n            long long remain = remain_by_num_full[num_full];\\n            long long partial_min_index = n - (upper_bound(partial_min_arr.rbegin(), partial_min_arr.rend(), remain)\\n                                               - partial_min_arr.rbegin());\\n            partial_min_index = max(partial_min_index, num_full);\\n            long long num_partial_fill = n - partial_min_index;\\n            long long num_partial = 0;\\n            if (num_partial_fill != 0)\\n                num_partial = min(\\n                        target - 1,\\n                        flowers[partial_min_index] + (remain - partial_min_arr[partial_min_index]) / num_partial_fill\\n                );\\n            cur += num_partial * partial;\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long maximumBeauty(vector<int> &flowers, long long newFlowers, int _target, int full, int partial) {\\n        long long target = _target;\\n        sort(flowers.begin(), flowers.end(), greater<int>());\\n        int n = flowers.size();\\n        long long min_full = 0;\\n        for (auto flower: flowers) {\\n            if (flower >= target)\\n                min_full++;\\n        }\\n        long long temp = newFlowers;\\n        long long max_full = 0;\\n        for (int i = 0; i < n; i++) {\\n            temp -= max((long long) 0, target - flowers[i]);\\n            if (temp < 0)\\n                break;\\n            max_full++;\\n        }\\n        vector<long long> partial_min_arr(n, 0);\\n        for (int i = n - 2; i >= 0; i--) {\\n            partial_min_arr[i] = partial_min_arr[i + 1] + (flowers[i] - flowers[i + 1]) * (n - 1 - i);\\n        }\\n        vector<long long> remain_by_num_full(n + 1, 0);\\n        temp = newFlowers;\\n        for (int i = min_full; i <= max_full; i++) {\\n            if (i != 0) {\\n                temp -= max((long long) 0, target - flowers[i - 1]);\\n            }\\n            remain_by_num_full[i] = max(temp, (long long) 0);\\n        }\\n        long long res = -1;\\n        for (long long num_full = min_full; num_full <= max_full; num_full++) {\\n            long long cur = full * num_full;\\n            long long remain = remain_by_num_full[num_full];\\n            long long partial_min_index = n - (upper_bound(partial_min_arr.rbegin(), partial_min_arr.rend(), remain)\\n                                               - partial_min_arr.rbegin());\\n            partial_min_index = max(partial_min_index, num_full);\\n            long long num_partial_fill = n - partial_min_index;\\n            long long num_partial = 0;\\n            if (num_partial_fill != 0)\\n                num_partial = min(\\n                        target - 1,\\n                        flowers[partial_min_index] + (remain - partial_min_arr[partial_min_index]) / num_partial_fill\\n                );\\n            cur += num_partial * partial;\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934204,
                "title": "simple-python-search",
                "content": "I think the difficaulty is in the handeling of corner cases.\\n```\\nclass Solution:\\n    def fill_k(self, k):\\n        assert self.newFlowers >= self.need_to_full[k]\\n        rest = self.newFlowers - self.need_to_full[k]\\n        max_w = self.n-k\\n        score = k * self.full\\n        \\n        if max_w == 0:\\n            return score\\n        if rest == 0:\\n            return score + self.minh * self.partial\\n        \\n        while self.widths[-2] >= max_w:\\n            self.areas.pop()\\n            self.widths.pop()\\n            self.hights.pop()\\n        if self.widths[-1] > max_w:\\n            self.widths[-1] = max_w\\n            self.hights[-1] = self.hights[-2] + self.target\\n            self.areas[-1] = self.areas[-2] + self.target*max_w\\n        \\n        while self.areas[-2] > rest:\\n            self.areas.pop()\\n            self.widths.pop()\\n            self.hights.pop()\\n        rest -= self.areas[-2]\\n        add_h = self.hights[-2] + (rest//self.widths[-1])\\n        min_h = min(self.minh + add_h, self.target-1)\\n        score += min_h * self.partial\\n        return score\\n    \\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        already_full = 0\\n        while len(flowers) > 0 and flowers[-1] >= target:\\n            already_full += 1\\n            flowers.pop()\\n        \\n        if len(flowers) == 0:\\n            return already_full * full\\n        \\n        self.need_to_full = [0]\\n        for c in flowers[::-1]:\\n            need = target - c\\n            self.need_to_full.append(need + self.need_to_full[-1])\\n        #print(self.need_to_full)\\n        \\n        self.areas = [0]\\n        self.widths = [0]\\n        self.hights = [0]\\n        for i, c in enumerate(flowers[1:]):\\n            if c > flowers[i]:\\n                h = c - flowers[i]\\n                w = i+1\\n                area = h*w\\n                self.areas.append(self.areas[-1]+area)\\n                self.widths.append(w)\\n                self.hights.append(self.hights[-1]+h)\\n        h = target\\n        w = len(flowers)\\n        area = h*w\\n        self.areas.append(self.areas[-1]+area)\\n        self.widths.append(w)\\n        self.hights.append(self.hights[-1]+h)\\n        #print(self.widths)\\n        #print(self.areas)\\n        #print(self.hights)\\n        \\n        self.newFlowers = newFlowers\\n        self.full = full\\n        self.partial = partial\\n        self.minh = flowers[0]\\n        self.n = len(flowers)\\n        self.target = target\\n        #print(self.minh)\\n        \\n        r = 0\\n        for k in range(self.n+1):\\n            if self.newFlowers < self.need_to_full[k]:\\n                break\\n            r = max(r, self.fill_k(k))\\n        \\n        return r + already_full * self.full\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fill_k(self, k):\\n        assert self.newFlowers >= self.need_to_full[k]\\n        rest = self.newFlowers - self.need_to_full[k]\\n        max_w = self.n-k\\n        score = k * self.full\\n        \\n        if max_w == 0:\\n            return score\\n        if rest == 0:\\n            return score + self.minh * self.partial\\n        \\n        while self.widths[-2] >= max_w:\\n            self.areas.pop()\\n            self.widths.pop()\\n            self.hights.pop()\\n        if self.widths[-1] > max_w:\\n            self.widths[-1] = max_w\\n            self.hights[-1] = self.hights[-2] + self.target\\n            self.areas[-1] = self.areas[-2] + self.target*max_w\\n        \\n        while self.areas[-2] > rest:\\n            self.areas.pop()\\n            self.widths.pop()\\n            self.hights.pop()\\n        rest -= self.areas[-2]\\n        add_h = self.hights[-2] + (rest//self.widths[-1])\\n        min_h = min(self.minh + add_h, self.target-1)\\n        score += min_h * self.partial\\n        return score\\n    \\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        already_full = 0\\n        while len(flowers) > 0 and flowers[-1] >= target:\\n            already_full += 1\\n            flowers.pop()\\n        \\n        if len(flowers) == 0:\\n            return already_full * full\\n        \\n        self.need_to_full = [0]\\n        for c in flowers[::-1]:\\n            need = target - c\\n            self.need_to_full.append(need + self.need_to_full[-1])\\n        #print(self.need_to_full)\\n        \\n        self.areas = [0]\\n        self.widths = [0]\\n        self.hights = [0]\\n        for i, c in enumerate(flowers[1:]):\\n            if c > flowers[i]:\\n                h = c - flowers[i]\\n                w = i+1\\n                area = h*w\\n                self.areas.append(self.areas[-1]+area)\\n                self.widths.append(w)\\n                self.hights.append(self.hights[-1]+h)\\n        h = target\\n        w = len(flowers)\\n        area = h*w\\n        self.areas.append(self.areas[-1]+area)\\n        self.widths.append(w)\\n        self.hights.append(self.hights[-1]+h)\\n        #print(self.widths)\\n        #print(self.areas)\\n        #print(self.hights)\\n        \\n        self.newFlowers = newFlowers\\n        self.full = full\\n        self.partial = partial\\n        self.minh = flowers[0]\\n        self.n = len(flowers)\\n        self.target = target\\n        #print(self.minh)\\n        \\n        r = 0\\n        for k in range(self.n+1):\\n            if self.newFlowers < self.need_to_full[k]:\\n                break\\n            r = max(r, self.fill_k(k))\\n        \\n        return r + already_full * self.full\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934186,
                "title": "python-3-avoid-using-python-built-in-accumulate-function",
                "content": "Keep getting TLE\\nRealize the bottleneck is the python built-in `accumulate` function...\\nSame logic as the hint\\n* Greedily fill all gardens to target (descending prefix sum)\\n* Fill remaining garden and binary search the maximum lowest flowers\\n\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        q, q_acc = [], [0] #eligible gardens < target and its prefix sum\\n        full_need_acc = [0] #diff to target prefix sum\\n        ans = 0\\n        n = len(flowers)\\n        flowers.sort()\\n\\n        for f in flowers:\\n            if f >= target: \\n                ans += full\\n                continue\\n            q.append(f)\\n            q_acc.append(q_acc[-1] + f)\\n        \\n        for f in flowers[::-1]:\\n            if f >= target: continue\\n            full_need_acc.append(full_need_acc[-1] + max(0, target - f))\\n\\n        res = 0\\n        for i, x in enumerate(full_need_acc):\\n            if x > newFlowers: break\\n            if i == len(full_need_acc) - 1:\\n                res = max(res, i * full)\\n                continue\\n            l, h = flowers[0], target - 1\\n            while l < h:\\n                mid = l + (h - l + 1) // 2\\n                loc = bisect.bisect_left(q, mid, lo=0, hi=len(q)-i)\\n                if mid * loc - q_acc[loc] <= newFlowers - x:\\n                    l = mid\\n                else:\\n                    h = mid - 1\\n            res = max(res, i * full + l * partial)\\n        return ans + res\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        q, q_acc = [], [0] #eligible gardens < target and its prefix sum\\n        full_need_acc = [0] #diff to target prefix sum\\n        ans = 0\\n        n = len(flowers)\\n        flowers.sort()\\n\\n        for f in flowers:\\n            if f >= target: \\n                ans += full\\n                continue\\n            q.append(f)\\n            q_acc.append(q_acc[-1] + f)\\n        \\n        for f in flowers[::-1]:\\n            if f >= target: continue\\n            full_need_acc.append(full_need_acc[-1] + max(0, target - f))\\n\\n        res = 0\\n        for i, x in enumerate(full_need_acc):\\n            if x > newFlowers: break\\n            if i == len(full_need_acc) - 1:\\n                res = max(res, i * full)\\n                continue\\n            l, h = flowers[0], target - 1\\n            while l < h:\\n                mid = l + (h - l + 1) // 2\\n                loc = bisect.bisect_left(q, mid, lo=0, hi=len(q)-i)\\n                if mid * loc - q_acc[loc] <= newFlowers - x:\\n                    l = mid\\n                else:\\n                    h = mid - 1\\n            res = max(res, i * full + l * partial)\\n        return ans + res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1933936,
                "title": "c-binary-search-o-n-log-n-log-target",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> sum;\\n    int binarysearch(vector<int>& nums,int l,int h,long long m){\\n        int re = 0;\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n            if(nums[mid]<m){ re = mid; l=mid+1; }\\n            else h=mid-1;\\n        }\\n        return re;\\n    }\\n    long long find(vector<int>& nums,long long t,long long r,int x){\\n        long long l = nums[0],h=t-1,ans = 0;\\n        while(l<=h){\\n            long long m = (l+h)/2;\\n            long long temp = 0;\\n            int k = binarysearch(nums,0,nums.size()-x-1,m);\\n            temp = m*(k+1)-sum[k];\\n            if(temp<=r){\\n                ans = m; l=m+1;\\n            }\\n            else h=m-1;\\n        }\\n        return ans;\\n    }\\n    long long maximumBeauty(vector<int>& nums, long long n, int t, int full, int partial) {\\n        sort(nums.begin(),nums.end());\\n        long long l = 0,h=0,temp=n; // l = min no. of full garden, h = Max no. of garden that can be full\\n        vector<long long> arr; \\n        sum = vector<long long>(nums.size(),0); sum[0]=nums[0];\\n        for(int i = 1; i<nums.size();++i)sum[i]=nums[i]+sum[i-1];\\n        for(int i = nums.size()-1;i>=0;--i){\\n            if(nums[i]>=t) {l++;h++;}\\n            else{\\n                if(temp>=t-nums[i]){  // if ith garden is not full, Check if it can be completed \\n                    h++; temp-=t-nums[i];  \\n                    arr.push_back(temp);  // Store the no. of flowers left after ith garden is completed\\n                }\\n                else break;\\n            }\\n        }\\n        long long ans = (long long)full*l;  // calculate ans for `l`\\n        if(l<nums.size()) ans+=(long long)partial*find(nums,t,n,l);\\n        for(long long i = l+1;i<=h;++i){\\n            long long p = 0;\\n            if(nums.size()>i) p=find(nums,t,arr[i-l-1],i); // Get the maximized minimum no. of flowers if `i` gardens are completed and arr[i-l-1] flowers are left\\n            p = i*full +p*partial;\\n            ans = max(ans,p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> sum;\\n    int binarysearch(vector<int>& nums,int l,int h,long long m){\\n        int re = 0;\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n            if(nums[mid]<m){ re = mid; l=mid+1; }\\n            else h=mid-1;\\n        }\\n        return re;\\n    }\\n    long long find(vector<int>& nums,long long t,long long r,int x){\\n        long long l = nums[0],h=t-1,ans = 0;\\n        while(l<=h){\\n            long long m = (l+h)/2;\\n            long long temp = 0;\\n            int k = binarysearch(nums,0,nums.size()-x-1,m);\\n            temp = m*(k+1)-sum[k];\\n            if(temp<=r){\\n                ans = m; l=m+1;\\n            }\\n            else h=m-1;\\n        }\\n        return ans;\\n    }\\n    long long maximumBeauty(vector<int>& nums, long long n, int t, int full, int partial) {\\n        sort(nums.begin(),nums.end());\\n        long long l = 0,h=0,temp=n; // l = min no. of full garden, h = Max no. of garden that can be full\\n        vector<long long> arr; \\n        sum = vector<long long>(nums.size(),0); sum[0]=nums[0];\\n        for(int i = 1; i<nums.size();++i)sum[i]=nums[i]+sum[i-1];\\n        for(int i = nums.size()-1;i>=0;--i){\\n            if(nums[i]>=t) {l++;h++;}\\n            else{\\n                if(temp>=t-nums[i]){  // if ith garden is not full, Check if it can be completed \\n                    h++; temp-=t-nums[i];  \\n                    arr.push_back(temp);  // Store the no. of flowers left after ith garden is completed\\n                }\\n                else break;\\n            }\\n        }\\n        long long ans = (long long)full*l;  // calculate ans for `l`\\n        if(l<nums.size()) ans+=(long long)partial*find(nums,t,n,l);\\n        for(long long i = l+1;i<=h;++i){\\n            long long p = 0;\\n            if(nums.size()>i) p=find(nums,t,arr[i-l-1],i); // Get the maximized minimum no. of flowers if `i` gardens are completed and arr[i-l-1] flowers are left\\n            p = i*full +p*partial;\\n            ans = max(ans,p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933843,
                "title": "sort-iterate-over-minimum-values-greedy",
                "content": "We want to maximize `(mininum_value * partial + most_full(newFlowers - needed(minimum_value)) * full)`\\nconstrained by `0 <= minimum_value <= target`\\nwhere `most_full(X)` is the highest amount of full gardens we can have with `X` added flowers,\\nand `needed(Y)` is the fewest amount of flowers needed to make the minimum value `Y`.\\n\\n`most_full` and `needed` can each be efficiently updated while iterating through all `minimum_value`s since they are monotonic\\nwith respect to `minimum_value`. \\n\\nAn edge case is that `needed(minimum_value)` must be atleast `1` for `minimum_value > 0`. \\n\\nThe time complexity is `O(n log n + target)`. \\n\\n\\n\\n```\\n    using ll = long long;\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        ll n = flowers.size();\\n        vector<ll> needed(n+1, 0);\\n        ll full_ptr = n;\\n        for (ll i = n-1; i >= 0; --i) {\\n            needed[i] = needed[i+1] + max(0, target - flowers[i]);\\n            if (needed[i] <= newFlowers)\\n                full_ptr = i;\\n            \\n        }\\n\\n        ll needed_mv{0};\\n        ll pref_sum{0};\\n        ll ans = 0;\\n        ll partial_ptr{0};\\n        for (ll mv = 0; mv < (ll)target; ++mv) {\\n            while(partial_ptr < n && partial_ptr < full_ptr && flowers[partial_ptr] < mv) {\\n                pref_sum += flowers[partial_ptr++];\\n            }\\n            if (partial_ptr == 0 && mv > 0 && flowers[partial_ptr] <= mv) {\\n                pref_sum += flowers[partial_ptr++];\\n                full_ptr= max(partial_ptr, full_ptr);\\n            }\\n            needed_mv = mv * partial_ptr - pref_sum;\\n            if (needed_mv > newFlowers) break;\\n            while(needed_mv + needed[full_ptr] > newFlowers) {\\n                ++full_ptr;\\n            }\\n            ans = max(ans, (n - full_ptr) * full + ((ll)(partial_ptr != 0) * mv * partial));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    using ll = long long;\\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        sort(flowers.begin(), flowers.end());\\n        ll n = flowers.size();\\n        vector<ll> needed(n+1, 0);\\n        ll full_ptr = n;\\n        for (ll i = n-1; i >= 0; --i) {\\n            needed[i] = needed[i+1] + max(0, target - flowers[i]);\\n            if (needed[i] <= newFlowers)\\n                full_ptr = i;\\n            \\n        }\\n\\n        ll needed_mv{0};\\n        ll pref_sum{0};\\n        ll ans = 0;\\n        ll partial_ptr{0};\\n        for (ll mv = 0; mv < (ll)target; ++mv) {\\n            while(partial_ptr < n && partial_ptr < full_ptr && flowers[partial_ptr] < mv) {\\n                pref_sum += flowers[partial_ptr++];\\n            }\\n            if (partial_ptr == 0 && mv > 0 && flowers[partial_ptr] <= mv) {\\n                pref_sum += flowers[partial_ptr++];\\n                full_ptr= max(partial_ptr, full_ptr);\\n            }\\n            needed_mv = mv * partial_ptr - pref_sum;\\n            if (needed_mv > newFlowers) break;\\n            while(needed_mv + needed[full_ptr] > newFlowers) {\\n                ++full_ptr;\\n            }\\n            ans = max(ans, (n - full_ptr) * full + ((ll)(partial_ptr != 0) * mv * partial));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933623,
                "title": "python3-two-pointer-o-n-greedy",
                "content": "idea:\\n1. sort garden\\n2. try to complete from right to left using all the new flowers. Mark the position as `r`\\n3. release complete graden to get new flowers (index mark as `nr`), for current remaining new flowers:\\n\\t3.1 fill current gap to improve current minimum of incomplete garden within `[:l]` to `flowers[l]` until not enough remaining flowers.\\n\\t3.2 evenly adding the remaining flowers to incomplete garden.\\n4. calcualte current value\\n\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        N = len(flowers)\\n        rem = newFlowers\\n        res = 0\\n        for r in range(N-1,-1,-1):\\n            if rem >= max(0,target-flowers[r]):\\n                rem -= max(0,target-flowers[r])\\n            else:\\n                r += 1\\n                break\\n        if r == 0:\\n            res = full*N\\n        l=0\\n        for nr in range(r, N+1):\\n            if nr != r:\\n                off = max(0, target-flowers[nr-1])\\n                if off == 0:\\n                    break\\n                rem += off\\n            for l in range(l, nr):\\n                if l == 0:\\n                    if nr == 1:\\n                        cur = full*(N-nr)+partial*min(target-1, rem+flowers[l])  \\n                    else:\\n                        cur = full*(N-nr)+partial*min(target-1, rem+flowers[l], flowers[l+1])\\n                elif 0<l<nr-1:\\n                    if rem >= (flowers[l]-flowers[l-1])*l:\\n                        rem -= (flowers[l]-flowers[l-1])*l\\n                        cur = full*(N-nr)+partial*min(target-1, rem//(l+1)+flowers[l], flowers[l+1])\\n                    else:\\n                        cur = full*(N-nr)+partial*min(target-1, rem//l+flowers[l-1], flowers[l])\\n                        res = max(res,cur)\\n                        break\\n                elif l == nr-1:\\n                    if rem >= (flowers[l]-flowers[l-1])*l:\\n                        cur = full*(N-nr)+partial*min(target-1, (rem-(flowers[l]-flowers[l-1])*l)//(l+1)+flowers[l])\\n                res = max(res,cur)\\n            \\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers.sort()\\n        N = len(flowers)\\n        rem = newFlowers\\n        res = 0\\n        for r in range(N-1,-1,-1):\\n            if rem >= max(0,target-flowers[r]):\\n                rem -= max(0,target-flowers[r])\\n            else:\\n                r += 1\\n                break\\n        if r == 0:\\n            res = full*N\\n        l=0\\n        for nr in range(r, N+1):\\n            if nr != r:\\n                off = max(0, target-flowers[nr-1])\\n                if off == 0:\\n                    break\\n                rem += off\\n            for l in range(l, nr):\\n                if l == 0:\\n                    if nr == 1:\\n                        cur = full*(N-nr)+partial*min(target-1, rem+flowers[l])  \\n                    else:\\n                        cur = full*(N-nr)+partial*min(target-1, rem+flowers[l], flowers[l+1])\\n                elif 0<l<nr-1:\\n                    if rem >= (flowers[l]-flowers[l-1])*l:\\n                        rem -= (flowers[l]-flowers[l-1])*l\\n                        cur = full*(N-nr)+partial*min(target-1, rem//(l+1)+flowers[l], flowers[l+1])\\n                    else:\\n                        cur = full*(N-nr)+partial*min(target-1, rem//l+flowers[l-1], flowers[l])\\n                        res = max(res,cur)\\n                        break\\n                elif l == nr-1:\\n                    if rem >= (flowers[l]-flowers[l-1])*l:\\n                        cur = full*(N-nr)+partial*min(target-1, (rem-(flowers[l]-flowers[l-1])*l)//(l+1)+flowers[l])\\n                res = max(res,cur)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932831,
                "title": "get-tle-when-submited-but-runs-fine-when-click-run-code",
                "content": "\\n```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(flowers)\\n        n = len(flowers)\\n        i = n - 1\\n        while i >= 0 and flowers[i] >= target:\\n            i -= 1\\n        if i < 0:\\n            return n * full\\n        full_cnt = n - i - 1\\n        flowers = flowers[:i+1]\\n        n = len(flowers)\\n        psum, ssum = list(flowers), list(flowers)\\n        for i in range(1, n):\\n            psum[i] += psum[i - 1]       \\n        for i in range(-2, -(n+1), -1):\\n            ssum[i] += ssum[i + 1]\\n        \\n        max_score = flowers[0] * partial + full_cnt * full\\n        for min_flowers in range(flowers[0], target + 1):\\n            l1, r1 = 0, n - 1\\n            while l1 <= r1:\\n                m1 = (l1 + r1) // 2\\n                if flowers[m1] < min_flowers:\\n                    l1 = m1 + 1\\n                else:\\n                    r1 = m1 - 1\\n            l3, r3 = l1, n - 1\\n            while l3 <= r3:\\n                m3 = (l3 + r3) // 2\\n                if flowers[m3] <= min_flowers:\\n                    l3 = m3 + 1\\n                else:\\n                    r3 = m3 - 1\\n            remains = newFlowers if r1 < 0 else newFlowers - ((r1 + 1) * min_flowers - psum[r1])\\n            if remains < 0:\\n                break\\n            if min_flowers == target:\\n                score = full * (len(flowers) + full_cnt)\\n                max_score = max(score, max_score)\\n                break\\n            l2, r2 = l3, n - 1\\n            while l2 <= r2:\\n                m2 = (l2 + r2) // 2\\n                if (n  - m2) * target - ssum[m2] <= remains:\\n                    r2 = m2 - 1\\n                else:\\n                    l2 = m2 + 1\\n            \\n            full_cnt1 = full_cnt\\n            if l2 < n:\\n                remains -= ((n - l2) * target - ssum[l2])\\n                full_cnt1 += (n - l2)\\n            if l2 == l3 and remains > 0:\\n                full_cnt1 += min(remains // (target - min_flowers), l2 - 1)\\n            score = min_flowers * partial + full_cnt1 * full\\n            max_score = max(max_score, score)\\n            \\n        return max_score\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        flowers = sorted(flowers)\\n        n = len(flowers)\\n        i = n - 1\\n        while i >= 0 and flowers[i] >= target:\\n            i -= 1\\n        if i < 0:\\n            return n * full\\n        full_cnt = n - i - 1\\n        flowers = flowers[:i+1]\\n        n = len(flowers)\\n        psum, ssum = list(flowers), list(flowers)\\n        for i in range(1, n):\\n            psum[i] += psum[i - 1]       \\n        for i in range(-2, -(n+1), -1):\\n            ssum[i] += ssum[i + 1]\\n        \\n        max_score = flowers[0] * partial + full_cnt * full\\n        for min_flowers in range(flowers[0], target + 1):\\n            l1, r1 = 0, n - 1\\n            while l1 <= r1:\\n                m1 = (l1 + r1) // 2\\n                if flowers[m1] < min_flowers:\\n                    l1 = m1 + 1\\n                else:\\n                    r1 = m1 - 1\\n            l3, r3 = l1, n - 1\\n            while l3 <= r3:\\n                m3 = (l3 + r3) // 2\\n                if flowers[m3] <= min_flowers:\\n                    l3 = m3 + 1\\n                else:\\n                    r3 = m3 - 1\\n            remains = newFlowers if r1 < 0 else newFlowers - ((r1 + 1) * min_flowers - psum[r1])\\n            if remains < 0:\\n                break\\n            if min_flowers == target:\\n                score = full * (len(flowers) + full_cnt)\\n                max_score = max(score, max_score)\\n                break\\n            l2, r2 = l3, n - 1\\n            while l2 <= r2:\\n                m2 = (l2 + r2) // 2\\n                if (n  - m2) * target - ssum[m2] <= remains:\\n                    r2 = m2 - 1\\n                else:\\n                    l2 = m2 + 1\\n            \\n            full_cnt1 = full_cnt\\n            if l2 < n:\\n                remains -= ((n - l2) * target - ssum[l2])\\n                full_cnt1 += (n - l2)\\n            if l2 == l3 and remains > 0:\\n                full_cnt1 += min(remains // (target - min_flowers), l2 - 1)\\n            score = min_flowers * partial + full_cnt1 * full\\n            max_score = max(max_score, score)\\n            \\n        return max_score\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932616,
                "title": "simple-solution-in-java-elegant-and-concise-using-binary-search",
                "content": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        /*\\n           Sort the array,\\n           Complete the number of flowers from the last and check how much maximum minimum flowers in partial gardens we can get\\n           from the remaining flowers using binary search\\n        */\\n        \\n        long ans = 0;\\n        \\n        Arrays.sort(flowers);\\n        int numFlowers = flowers.length;\\n        long[] cost = new long[numFlowers]; // Cost to get minimum flowers as the current flower till the current index \\n        \\n        int isComplete = flowers[0] >= target ? 1 : 0;\\n        for(int i=1; i<numFlowers; i++){\\n            cost[i] = cost[i-1] + (flowers[i] - flowers[i-1])*i;\\n            if(flowers[i] >= target) isComplete++;\\n        }\\n        \\n        if(isComplete == flowers.length) return (long)numFlowers*full; // If all gardens are full\\n        \\n        long costToCompleteTillNow = 0;\\n        for(int i=numFlowers; i>=0; i--){\\n            if(i < numFlowers){\\n                costToCompleteTillNow += Math.max(0, target - flowers[i]);\\n                if(costToCompleteTillNow > newFlowers) break;\\n                if(i == 0){\\n                    ans = Math.max(ans, (numFlowers)*(long)full);\\n                    break;\\n                }   \\n            }\\n            // Find the index till which we can have partial garden from the remaining flowers\\n            long remFlower = newFlowers - costToCompleteTillNow;\\n            int maxPartialIndex = findByBinarySearch(remFlower, cost, 0, i-1);\\n            \\n            if(maxPartialIndex < 0) continue;\\n            \\n            long remFlowerAfterDist = remFlower - cost[maxPartialIndex]; // Remaining flowers after paying the cost to make all equal\\n            long flowerToAdd = remFlowerAfterDist/(maxPartialIndex + 1); // Equally distribute the remaining flowers\\n            \\n            ans = Math.max(ans, (((long)full*(numFlowers - i))  + ((long)partial)*(Math.min(target - 1, flowers[maxPartialIndex] + flowerToAdd))  ));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findByBinarySearch(long key, long[] arr, int l, int h){  \\n        if(l > h || arr[l] > key) return -1;\\n        \\n        int ans = 0;\\n        h += 1;\\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(arr[m] <= key){\\n                ans = m;\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        /*\\n           Sort the array,\\n           Complete the number of flowers from the last and check how much maximum minimum flowers in partial gardens we can get\\n           from the remaining flowers using binary search\\n        */\\n        \\n        long ans = 0;\\n        \\n        Arrays.sort(flowers);\\n        int numFlowers = flowers.length;\\n        long[] cost = new long[numFlowers]; // Cost to get minimum flowers as the current flower till the current index \\n        \\n        int isComplete = flowers[0] >= target ? 1 : 0;\\n        for(int i=1; i<numFlowers; i++){\\n            cost[i] = cost[i-1] + (flowers[i] - flowers[i-1])*i;\\n            if(flowers[i] >= target) isComplete++;\\n        }\\n        \\n        if(isComplete == flowers.length) return (long)numFlowers*full; // If all gardens are full\\n        \\n        long costToCompleteTillNow = 0;\\n        for(int i=numFlowers; i>=0; i--){\\n            if(i < numFlowers){\\n                costToCompleteTillNow += Math.max(0, target - flowers[i]);\\n                if(costToCompleteTillNow > newFlowers) break;\\n                if(i == 0){\\n                    ans = Math.max(ans, (numFlowers)*(long)full);\\n                    break;\\n                }   \\n            }\\n            // Find the index till which we can have partial garden from the remaining flowers\\n            long remFlower = newFlowers - costToCompleteTillNow;\\n            int maxPartialIndex = findByBinarySearch(remFlower, cost, 0, i-1);\\n            \\n            if(maxPartialIndex < 0) continue;\\n            \\n            long remFlowerAfterDist = remFlower - cost[maxPartialIndex]; // Remaining flowers after paying the cost to make all equal\\n            long flowerToAdd = remFlowerAfterDist/(maxPartialIndex + 1); // Equally distribute the remaining flowers\\n            \\n            ans = Math.max(ans, (((long)full*(numFlowers - i))  + ((long)partial)*(Math.min(target - 1, flowers[maxPartialIndex] + flowerToAdd))  ));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findByBinarySearch(long key, long[] arr, int l, int h){  \\n        if(l > h || arr[l] > key) return -1;\\n        \\n        int ans = 0;\\n        h += 1;\\n        while(l < h){\\n            int m = l + (h-l)/2;\\n            if(arr[m] <= key){\\n                ans = m;\\n                l = m+1;\\n            }else h = m;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932371,
                "title": "short-and-concise-prefix-sum-two-pointers-c-o-nlogn",
                "content": "Use two pointers to arrange the `newFlowers`. We arrange full gardens first by counting up `fc` (full count) from `0` to `n`, i.e. move the first pointer backward from the end of the sorted list. For each `fc`, we decrease `pc` (partial count) to fit the unused flowers after arranging the full gardens.\\n```\\nlong long maximumBeauty(vector<int>& F, long long newFlowers, int T, int full, int partial) {\\n    sort(F.begin(), F.end());\\n    vector<int64_t> ps(1); // prefix sum\\n    for (int &i : F) {\\n        i = min(i, T); // shave off those higher than target\\n        ps.push_back(ps.back() + (int64_t)i);\\n    }\\n    int64_t ans = 0;\\n    for (int64_t n = F.size(), pc = n, fc = 0; fc <= n; fc++) { // count up full ones\\n        int64_t x = newFlowers - (T * fc - (ps[n] - ps[n - fc]));\\n        if (x < 0) // x remaining flowers to fill partial ones\\n            break;\\n        for (pc = min(pc, n - fc); pc > 0 && F[pc - 1] * pc - ps[pc] > x; pc--); // count down partial ones\\n        int64_t pm = pc && F[0] < T ? min<int64_t>(T - 1, (x + ps[pc]) / pc) : 0;\\n        ans = max(ans, fc * full + pm * partial);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long maximumBeauty(vector<int>& F, long long newFlowers, int T, int full, int partial) {\\n    sort(F.begin(), F.end());\\n    vector<int64_t> ps(1); // prefix sum\\n    for (int &i : F) {\\n        i = min(i, T); // shave off those higher than target\\n        ps.push_back(ps.back() + (int64_t)i);\\n    }\\n    int64_t ans = 0;\\n    for (int64_t n = F.size(), pc = n, fc = 0; fc <= n; fc++) { // count up full ones\\n        int64_t x = newFlowers - (T * fc - (ps[n] - ps[n - fc]));\\n        if (x < 0) // x remaining flowers to fill partial ones\\n            break;\\n        for (pc = min(pc, n - fc); pc > 0 && F[pc - 1] * pc - ps[pc] > x; pc--); // count down partial ones\\n        int64_t pm = pc && F[0] < T ? min<int64_t>(T - 1, (x + ps[pc]) / pc) : 0;\\n        ans = max(ans, fc * full + pm * partial);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932339,
                "title": "java-modularized-solution-with-dp-binary-search-o-nlogn",
                "content": "Note:\\nFor test cases beyond 72 (out of 77) adding a type cast (long) prior to calculations is necessary to ensure that correct value is picked up\\n\\n```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n\\n        int countOfFullGardens = getCountOfCompletedGardens(flowers, target);\\n        int updatedLength = flowers.length - countOfFullGardens;    \\n        // If all gardens are already full, return early\\n        if(updatedLength == 0) {\\n            return (long) full*countOfFullGardens;\\n        }\\n        \\n        long[] fillUpPartialGarden = getCountNeededForPartialGarden(flowers, updatedLength);\\n        long[] fillUpCompletedGarden = getCountNeededForCompleteGarden(flowers, updatedLength, target);\\n        \\n        long ans = 0;\\n        \\n        // Try to get the maximum number of completed gardens + max value of partial garden\\n        for(int filledGardens = 0; filledGardens <= updatedLength; filledGardens++) {\\n            long remainingFlowersCount = newFlowers; //reset in each iteration\\n            long partialCount = 0;\\n                        \\n            if(filledGardens > 0) {\\n                remainingFlowersCount -= fillUpCompletedGarden[updatedLength-filledGardens];\\n            }\\n            \\n            // If no flower remains after completing one more garden, break. No need to iterate ahead\\n            if(remainingFlowersCount < 0) {\\n                break;\\n            }\\n\\n            if(filledGardens < updatedLength) {            \\n                int indexForPartialGardens = binarySearch(fillUpPartialGarden, updatedLength, remainingFlowersCount);\\n                // Don\\'t consider completed garden again\\n                if(indexForPartialGardens > (updatedLength - 1 - filledGardens)) {\\n                    indexForPartialGardens = updatedLength - filledGardens - 1;\\n                }\\n                \\n                // Minimum number of flowers across all is flowers[indexForPartialGardens]\\n                // Divide the remaining number of flowers across all the gardens. \\n\\n                partialCount = (long) flowers[indexForPartialGardens] + (long) ((remainingFlowersCount - fillUpPartialGarden[indexForPartialGardens])/(long)(indexForPartialGardens+1));\\n                \\n                //partialCount is capped at target-1\\n                partialCount = Math.min(partialCount, target-1); \\n                \\n            }\\n            long temp = (long) (countOfFullGardens + filledGardens) * (long) full +  (long) partialCount * (long) partial;\\n            ans = Math.max(temp, ans);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    // Expects sorted array of flowers and returns count of already complete gardens\\n    private int getCountOfCompletedGardens(int[] flowers, int target) {\\n        int countOfFullGardens = 0;\\n        for(int i = flowers.length - 1; i >= 0; i--) {\\n            if(flowers[i] < target)\\n                break;\\n            countOfFullGardens++;\\n        }\\n        return  countOfFullGardens;\\n    }\\n    \\n\\n    private long[] getCountNeededForPartialGarden(int[] flowers, int updatedLength) {\\n        long[] fillUpPartialGarden = new long[updatedLength];\\n        for(int i = 1; i < updatedLength; i++) {\\n            // At i, the i gardens preceding it (0 indexed) already have flowers[i-1] flowers\\n            fillUpPartialGarden[i] = (long)(flowers[i] - flowers[i-1]) *(long)i + (long)fillUpPartialGarden[i-1];\\n            \\n        }\\n        return fillUpPartialGarden;\\n    }\\n    \\n      \\n  // Returns an array where value at index i denotes the number of flowers needed so that all the length - i + 1 elements from the index onwards have completed gardens\\n    private long[] getCountNeededForCompleteGarden(int[] flowers, int updatedLength, long target) {\\n        long fillUpCompletedGarden[] = new long[updatedLength];\\n        \\n        fillUpCompletedGarden[updatedLength-1] = target - flowers[updatedLength-1];\\n        for(int i = updatedLength - 2; i >= 0; i--) {\\n            fillUpCompletedGarden[i] = (long)fillUpCompletedGarden[i+1] + (long)(target - flowers[i]); \\n        }\\n        return fillUpCompletedGarden;\\n    }\\n    \\n    // Returns the index such that nums[index] is the maximum value less than value\\n     private int binarySearch(long[] nums, int length, long value) {\\n        int low = 0;\\n        int high = length-1;\\n        int ans = low;\\n         \\n        while (low <= high) {\\n            int mid = low + (high-low)/2;\\n            if ((long) nums[mid] ==  (long) value) \\n                return mid;\\n            else if ((long) nums[mid] < (long) value) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n         \\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumBeauty(int[] flowers, long newFlowers, int target, int full, int partial) {\\n        Arrays.sort(flowers);\\n\\n        int countOfFullGardens = getCountOfCompletedGardens(flowers, target);\\n        int updatedLength = flowers.length - countOfFullGardens;    \\n        // If all gardens are already full, return early\\n        if(updatedLength == 0) {\\n            return (long) full*countOfFullGardens;\\n        }\\n        \\n        long[] fillUpPartialGarden = getCountNeededForPartialGarden(flowers, updatedLength);\\n        long[] fillUpCompletedGarden = getCountNeededForCompleteGarden(flowers, updatedLength, target);\\n        \\n        long ans = 0;\\n        \\n        // Try to get the maximum number of completed gardens + max value of partial garden\\n        for(int filledGardens = 0; filledGardens <= updatedLength; filledGardens++) {\\n            long remainingFlowersCount = newFlowers; //reset in each iteration\\n            long partialCount = 0;\\n                        \\n            if(filledGardens > 0) {\\n                remainingFlowersCount -= fillUpCompletedGarden[updatedLength-filledGardens];\\n            }\\n            \\n            // If no flower remains after completing one more garden, break. No need to iterate ahead\\n            if(remainingFlowersCount < 0) {\\n                break;\\n            }\\n\\n            if(filledGardens < updatedLength) {            \\n                int indexForPartialGardens = binarySearch(fillUpPartialGarden, updatedLength, remainingFlowersCount);\\n                // Don\\'t consider completed garden again\\n                if(indexForPartialGardens > (updatedLength - 1 - filledGardens)) {\\n                    indexForPartialGardens = updatedLength - filledGardens - 1;\\n                }\\n                \\n                // Minimum number of flowers across all is flowers[indexForPartialGardens]\\n                // Divide the remaining number of flowers across all the gardens. \\n\\n                partialCount = (long) flowers[indexForPartialGardens] + (long) ((remainingFlowersCount - fillUpPartialGarden[indexForPartialGardens])/(long)(indexForPartialGardens+1));\\n                \\n                //partialCount is capped at target-1\\n                partialCount = Math.min(partialCount, target-1); \\n                \\n            }\\n            long temp = (long) (countOfFullGardens + filledGardens) * (long) full +  (long) partialCount * (long) partial;\\n            ans = Math.max(temp, ans);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    // Expects sorted array of flowers and returns count of already complete gardens\\n    private int getCountOfCompletedGardens(int[] flowers, int target) {\\n        int countOfFullGardens = 0;\\n        for(int i = flowers.length - 1; i >= 0; i--) {\\n            if(flowers[i] < target)\\n                break;\\n            countOfFullGardens++;\\n        }\\n        return  countOfFullGardens;\\n    }\\n    \\n\\n    private long[] getCountNeededForPartialGarden(int[] flowers, int updatedLength) {\\n        long[] fillUpPartialGarden = new long[updatedLength];\\n        for(int i = 1; i < updatedLength; i++) {\\n            // At i, the i gardens preceding it (0 indexed) already have flowers[i-1] flowers\\n            fillUpPartialGarden[i] = (long)(flowers[i] - flowers[i-1]) *(long)i + (long)fillUpPartialGarden[i-1];\\n            \\n        }\\n        return fillUpPartialGarden;\\n    }\\n    \\n      \\n  // Returns an array where value at index i denotes the number of flowers needed so that all the length - i + 1 elements from the index onwards have completed gardens\\n    private long[] getCountNeededForCompleteGarden(int[] flowers, int updatedLength, long target) {\\n        long fillUpCompletedGarden[] = new long[updatedLength];\\n        \\n        fillUpCompletedGarden[updatedLength-1] = target - flowers[updatedLength-1];\\n        for(int i = updatedLength - 2; i >= 0; i--) {\\n            fillUpCompletedGarden[i] = (long)fillUpCompletedGarden[i+1] + (long)(target - flowers[i]); \\n        }\\n        return fillUpCompletedGarden;\\n    }\\n    \\n    // Returns the index such that nums[index] is the maximum value less than value\\n     private int binarySearch(long[] nums, int length, long value) {\\n        int low = 0;\\n        int high = length-1;\\n        int ans = low;\\n         \\n        while (low <= high) {\\n            int mid = low + (high-low)/2;\\n            if ((long) nums[mid] ==  (long) value) \\n                return mid;\\n            else if ((long) nums[mid] < (long) value) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n         \\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1932314,
                "title": "c-o-nlogn-suffix-sum-binary-search",
                "content": "1. sort flowers array in descending order\\n2. ss[i]: suffix sum array, it means in order to make [i, n-1] same flowers as flower[i], how many extra flowers need to be added\\n3. iterate from 0 to n-1, [0,i) are full flowers, [i,n-1] are partial flowers\\n4. use binary search to calculate minimum number of flowers (Math.Min(target-1, f[h] + (nf - ss[h])/(n-h));)\\n* be careful of overflow and the fact that minimum must be smaller than target.\\n\\n```\\npublic long MaximumBeauty(int[] f, long nf, int target, int full, int partial) {\\n\\n\\tint n = f.Length;\\n\\n\\tArray.Sort(f, (x,y)=>{\\n\\t\\treturn y.CompareTo(x);\\n\\t});\\n\\n\\t// reachable idx\\n\\tlong[] ss = new long[n];\\n\\tfor(int j=n-2; j>=0; j--) {\\n\\t\\tss[j] = ss[j+1] + ((long)(f[j] - f[j+1])) * (n - 1 - j);\\n\\t}\\n\\n\\tint i=0;\\n\\twhile(i<n && f[i] >= target) {\\n\\t\\ti++;            \\n\\t}\\n\\n\\tlong res = 0;\\n\\tfor(; i<n && nf > 0; i++) {\\n\\t\\tint h = hb(i, nf, ss);\\n\\n\\t\\tlong mn = Math.Min(target-1, f[h] + (nf - ss[h])/(n-h));\\n\\t\\tres = Math.Max(res, (long)i*(long)full + mn*(long)partial);\\n\\n\\t\\tnf -= target - f[i];\\n\\t}\\n\\tif (nf >= 0) {\\n\\t\\tres = Math.Max(res, (long)n*(long)full);\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nint hb(int l, long nf, long[] ss) {\\n\\tint h = ss.Length - 1;\\n\\n\\twhile(l < h) {\\n\\t\\tint m = (l + h) / 2;\\n\\t\\tif (nf < ss[m]) {\\n\\t\\t\\tl = m + 1;\\n\\t\\t} else {\\n\\t\\t\\th = m;\\n\\t\\t}\\n\\t}\\n\\n\\treturn h;\\n}\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\npublic long MaximumBeauty(int[] f, long nf, int target, int full, int partial) {\\n\\n\\tint n = f.Length;\\n\\n\\tArray.Sort(f, (x,y)=>{\\n\\t\\treturn y.CompareTo(x);\\n\\t});\\n\\n\\t// reachable idx\\n\\tlong[] ss = new long[n];\\n\\tfor(int j=n-2; j>=0; j--) {\\n\\t\\tss[j] = ss[j+1] + ((long)(f[j] - f[j+1])) * (n - 1 - j);\\n\\t}\\n\\n\\tint i=0;\\n\\twhile(i<n && f[i] >= target) {\\n\\t\\ti++;            \\n\\t}\\n\\n\\tlong res = 0;\\n\\tfor(; i<n && nf > 0; i++) {\\n\\t\\tint h = hb(i, nf, ss);\\n\\n\\t\\tlong mn = Math.Min(target-1, f[h] + (nf - ss[h])/(n-h));\\n\\t\\tres = Math.Max(res, (long)i*(long)full + mn*(long)partial);\\n\\n\\t\\tnf -= target - f[i];\\n\\t}\\n\\tif (nf >= 0) {\\n\\t\\tres = Math.Max(res, (long)n*(long)full);\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nint hb(int l, long nf, long[] ss) {\\n\\tint h = ss.Length - 1;\\n\\n\\twhile(l < h) {\\n\\t\\tint m = (l + h) / 2;\\n\\t\\tif (nf < ss[m]) {\\n\\t\\t\\tl = m + 1;\\n\\t\\t} else {\\n\\t\\t\\th = m;\\n\\t\\t}\\n\\t}\\n\\n\\treturn h;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932293,
                "title": "c-binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll unsigned long long int\\n    int possible(ll srt,ll end,ll left,ll target,vector<int> &flowers,vector<ll> &prefix){\\n        if(srt>end)return 0;\\n        \\n        ll n = flowers.size();\\n        ll l = flowers[end];          // min value in srt...end and minimum can\\'t be decreased than min value \\n        ll r = target-1;     // maximum value. we want to change number to atmost target-1. if we make target it becomes complete garden,\\n        ll ans = l;\\n        ll idx;\\n        while(l<=r){\\n            ll mid = l+(r-l)/2;\\n\\t\\t\\t\\n\\t\\t\\t// Finding index in flowers where flowers[idx] > mid\\n             auto it = upper_bound(flowers.rbegin(),flowers.rend(),mid);\\n            \\n            if(it==flowers.rend()){\\n                idx = srt-1;\\n            }else{\\n                idx = n-1-(it-flowers.rbegin());\\n            }\\n         \\n            // from idx+1...end all numbers will be smaller or equal to mid\\n\\t\\t\\t\\n\\t\\t\\t// This is the amount required to make all numbers in range idx+1..end to mid\\n            long long int change = mid*(end-idx)-(prefix[end+1]-prefix[idx+1]);\\n\\t\\t\\t\\n\\t\\t\\t// If change is less than flowers left we can increase every value which is less than mid, to mid and hence minimum in array becomes mid.\\n            if(change<=left){\\n                l = mid+1;\\n                ans = mid;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        ll n = flowers.size();\\n        sort(flowers.begin(),flowers.end(),greater<int>());\\n        vector<ll> prefix(n+1,0);\\n        \\n        for(int i=1;i<=n;i++){\\n            prefix[i] = prefix[i-1]+flowers[i-1];\\n        }\\n        \\n        \\n        long long int k = newFlowers;\\n        ll score = 0;\\n        ll mul = 1;\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n && k>=0;i++){\\n\\t\\t\\n\\t\\t// if garden is already full,we dont need to anything,just add up score\\n            if(flowers[i]>=target){\\n                score+=full;\\n                continue;\\n            }\\n\\t\\t\\t\\n            // Finding  maximum \"minimum value\" in leftover gardens by using the leftover flowers we have.\\n            ll mipossible = possible(i,n-1,k,target,flowers,prefix);\\n            \\n\\t\\t\\tscore = max(score,mul*i*full+mipossible*partial);\\n\\t\\t\\t\\n            // making garden[i] complete by using up flowers we have\\n\\t\\t\\tk-=(target-flowers[i]);\\n\\t\\t\\t\\n\\t\\t\\t// change flowers[i] to target as we increased flowers in i th garden\\n            flowers[i] = target;\\n        }\\n        \\n        if(k>=0)score = max(score,mul*n*full);\\n        \\n        return score;\\n    }\\n};\\n```\\n\\n*Time Complexity:   O(Nlog(target)log(N))*",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll unsigned long long int\\n    int possible(ll srt,ll end,ll left,ll target,vector<int> &flowers,vector<ll> &prefix){\\n        if(srt>end)return 0;\\n        \\n        ll n = flowers.size();\\n        ll l = flowers[end];          // min value in srt...end and minimum can\\'t be decreased than min value \\n        ll r = target-1;     // maximum value. we want to change number to atmost target-1. if we make target it becomes complete garden,\\n        ll ans = l;\\n        ll idx;\\n        while(l<=r){\\n            ll mid = l+(r-l)/2;\\n\\t\\t\\t\\n\\t\\t\\t// Finding index in flowers where flowers[idx] > mid\\n             auto it = upper_bound(flowers.rbegin(),flowers.rend(),mid);\\n            \\n            if(it==flowers.rend()){\\n                idx = srt-1;\\n            }else{\\n                idx = n-1-(it-flowers.rbegin());\\n            }\\n         \\n            // from idx+1...end all numbers will be smaller or equal to mid\\n\\t\\t\\t\\n\\t\\t\\t// This is the amount required to make all numbers in range idx+1..end to mid\\n            long long int change = mid*(end-idx)-(prefix[end+1]-prefix[idx+1]);\\n\\t\\t\\t\\n\\t\\t\\t// If change is less than flowers left we can increase every value which is less than mid, to mid and hence minimum in array becomes mid.\\n            if(change<=left){\\n                l = mid+1;\\n                ans = mid;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) {\\n        ll n = flowers.size();\\n        sort(flowers.begin(),flowers.end(),greater<int>());\\n        vector<ll> prefix(n+1,0);\\n        \\n        for(int i=1;i<=n;i++){\\n            prefix[i] = prefix[i-1]+flowers[i-1];\\n        }\\n        \\n        \\n        long long int k = newFlowers;\\n        ll score = 0;\\n        ll mul = 1;\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n && k>=0;i++){\\n\\t\\t\\n\\t\\t// if garden is already full,we dont need to anything,just add up score\\n            if(flowers[i]>=target){\\n                score+=full;\\n                continue;\\n            }\\n\\t\\t\\t\\n            // Finding  maximum \"minimum value\" in leftover gardens by using the leftover flowers we have.\\n            ll mipossible = possible(i,n-1,k,target,flowers,prefix);\\n            \\n\\t\\t\\tscore = max(score,mul*i*full+mipossible*partial);\\n\\t\\t\\t\\n            // making garden[i] complete by using up flowers we have\\n\\t\\t\\tk-=(target-flowers[i]);\\n\\t\\t\\t\\n\\t\\t\\t// change flowers[i] to target as we increased flowers in i th garden\\n            flowers[i] = target;\\n        }\\n        \\n        if(k>=0)score = max(score,mul*n*full);\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576602,
                "content": [
                    {
                        "username": "f1re",
                        "content": "Case 1: Full score >= Partial score\\n\\n1. Sort the gardens in descending order.\\n2. Add all the full gardens to score\\n3. Keep adding flowers to the gardens with less flowers than target.\\n4. break when you can\\'t add any.\\n5. Add the remaining partial gardens to a list and perform binary search to find the min no of flowers after adding remaining new flowers.\\n\\nCase 2: Partial score > Full score:\\nRepeat step5 of case1."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "I think case 2 wont work for \\n [1,1,1,1]  newFlowers=4,target=3,full=5,partial=6 . Answer will be 16.\\n I think unless the partial -full is too large , we have to take at least one full. For the below one where the difference is large, we wont take any full. \\n[1,1,1,1]  newFlowers=4,target=3,full=2,partial=10 . Answer will be 20."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Rounds to Complete All Tasks",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>tasks</code>, where <code>tasks[i]</code> represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the <strong>same difficulty level</strong>.</p>\n\n<p>Return <em>the <strong>minimum</strong> rounds required to complete all the tasks, or </em><code>-1</code><em> if it is not possible to complete all the tasks.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tasks = [2,2,3,3,2,4,4,4,4,4]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> To complete all the tasks, a possible plan is:\n- In the first round, you complete 3 tasks of difficulty level 2. \n- In the second round, you complete 2 tasks of difficulty level 3. \n- In the third round, you complete 3 tasks of difficulty level 4. \n- In the fourth round, you complete 2 tasks of difficulty level 4.  \nIt can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tasks = [2,3,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1955622,
                "title": "java-c-python-sum-up-freq-2-3",
                "content": "# **Intuition**\\nIf the frequence `freq` of a level is 1,\\nthen it is not possible to complete all the tasks.\\n\\nOtherwise, we need to decompose `freq = 3 tasks + 3 tasks + .... + 2 tasks`,\\nwith the minimum number of 3 and 2.\\n\\nWe need a lot a 3-tasks, and plus one or two 2-tasks.\\n<br>\\n\\n# **Explanation**\\nTasks with same difficulty level can be done together,\\nin group of 2-tasks or 3-tasks.\\n\\nSo we count the frequnce `freq` for each level.\\n\\nIf `freq = 1`, not possible, return -1\\nIf `freq = 2`, needs one 2-tasks\\nIf `freq = 3`, needs one 3-tasks\\nIf `freq = 3k`, `freq = 3 * k`, needs `k` batchs.\\nIf `freq = 3k + 1`, `freq = 3 * (k - 1) + 2 + 2`, needs `k + 1` batchs.\\nIf `freq = 3k + 2`, `freq = 3 * k + 2`, needs `k + 1` batchs.\\n\\nTo summarize, needs `(freq + 2) / 3` batch, \\nreturn the sum of `(freq + 2) / 3` if possible.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumRounds(int[] A) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        int res = 0;\\n        for (int freq : count.values()) {\\n            if (freq == 1) return -1;\\n            res += (freq + 2) / 3;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumRounds(vector<int>& A) {\\n        unordered_map<int, int> count;\\n        int res = 0, freq1;\\n        for (int a: A)\\n            ++count[a];\\n        for (auto& it: count) {\\n            if (it.second == 1) return -1;\\n            res += (it.second + 2) / 3;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumRounds(self, tasks):\\n        freq = Counter(tasks).values()\\n        return -1 if 1 in freq else sum((a + 2) // 3 for a in freq)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumRounds(int[] A) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        int res = 0;\\n        for (int freq : count.values()) {\\n            if (freq == 1) return -1;\\n            res += (freq + 2) / 3;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minimumRounds(vector<int>& A) {\\n        unordered_map<int, int> count;\\n        int res = 0, freq1;\\n        for (int a: A)\\n            ++count[a];\\n        for (auto& it: count) {\\n            if (it.second == 1) return -1;\\n            res += (it.second + 2) / 3;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minimumRounds(self, tasks):\\n        freq = Counter(tasks).values()\\n        return -1 if 1 in freq else sum((a + 2) // 3 for a in freq)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2995189,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** question revolves around frequency so we will use map \\n\\n**Approach:**\\nFrom observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then the possible remainders are 1 and 2. Lets check them out:\\n* If remainder is 1, i.e, lets take 7 frequency, then \\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E the groups are something like this \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\", i.e, one \\uD83D\\uDD2E is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\", i.e, one is added to the division by 3.\\n* If remainder is 2, i.e, lets take 8 frequency, then \\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E the groups are something like this \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\\uD83D\\uDD2E\" \"\\uD83D\\uDD2E\\uD83D\\uDD2E\", i.e, two \\uD83D\\uDD2E are left so the solution is to just add 1,i.e, one group of two to the solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        \\n        int output=0;\\n        \\n        for (auto freq : mp){\\n            if(freq.second==1)\\n                return -1;\\n            if(freq.second%3==0){\\n                output += freq.second/3;\\n            }\\n            else{\\n                output += freq.second/3 + 1;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\n**Time Complexity** => `O(N)`\\n**Space Complexity** => `O(N)`\\n\\n![image](https://assets.leetcode.com/users/images/12c08d97-9a80-4e62-8ff1-bd489ffd948a_1672802834.9151857.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        \\n        int output=0;\\n        \\n        for (auto freq : mp){\\n            if(freq.second==1)\\n                return -1;\\n            if(freq.second%3==0){\\n                output += freq.second/3;\\n            }\\n            else{\\n                output += freq.second/3 + 1;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995202,
                "title": "java-solution-with-2-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    // This function returns the minimum number of rounds needed to\\n    // process all tasks in the given array of tasks.\\n    public int minimumRounds(int[] tasks) {\\n\\n        // Create a HashMap to store the count of each task\\n        HashMap<Integer, Integer> getCount = new HashMap<>();\\n\\n        // Iterate through the tasks array and store the count of each task\\n        // in the HashMap\\n        for (int t : tasks) {\\n            getCount.put(t, getCount.getOrDefault(t, 0) + 1);\\n        }\\n\\n        // Initialize a result variable to 0\\n        int result = 0;\\n\\n        // Iterate through the values in the HashMap (which represent the counts of the tasks)\\n        for (int count : getCount.values()) {\\n            // If a task has a count of 1, it cannot be grouped with other tasks\\n            // and so we return -1\\n            if (count == 1) return -1;\\n\\n            // Add the number of rounds needed to process the tasks with count greater than or equal to 3\\n            result += count / 3;\\n\\n            // If there are any tasks left with count less than 3, we need an additional round\\n            // to process these tasks\\n            if(count % 3 != 0) result++;\\n        }\\n\\n        // Return the total number of rounds needed to process all tasks\\n        return result;\\n    }\\n}\\n\\n```\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // Sort the tasks array in ascending order\\n        Arrays.sort(tasks);\\n        int result = 0, count = 0;\\n        // Iterate through each task\\n        for (int i = 0; i < tasks.length; i++) {\\n            // Increment the count of tasks with the same value\\n            count++;\\n            // If we have reached the last task or the current task is different from the next task\\n            if (i == tasks.length - 1 || tasks[i] != tasks[i + 1]) {\\n                // If there is only one task with this value, we cannot create groups of 3\\n                // and we return -1\\n                if (count == 1) {\\n                    return -1;\\n                }\\n                // Add the number of full groups of 3 we can create from the tasks with this value\\n                result += count / 3;\\n                // If there are remaining tasks that cannot be included in a group of 3,\\n                // we need one more round to process these tasks\\n                if(count % 3 != 0) result++;\\n                // Reset the count for the next set of tasks\\n                count = 0;\\n           }\\n        }\\n        // Return the total number of rounds needed\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // This function returns the minimum number of rounds needed to\\n    // process all tasks in the given array of tasks.\\n    public int minimumRounds(int[] tasks) {\\n\\n        // Create a HashMap to store the count of each task\\n        HashMap<Integer, Integer> getCount = new HashMap<>();\\n\\n        // Iterate through the tasks array and store the count of each task\\n        // in the HashMap\\n        for (int t : tasks) {\\n            getCount.put(t, getCount.getOrDefault(t, 0) + 1);\\n        }\\n\\n        // Initialize a result variable to 0\\n        int result = 0;\\n\\n        // Iterate through the values in the HashMap (which represent the counts of the tasks)\\n        for (int count : getCount.values()) {\\n            // If a task has a count of 1, it cannot be grouped with other tasks\\n            // and so we return -1\\n            if (count == 1) return -1;\\n\\n            // Add the number of rounds needed to process the tasks with count greater than or equal to 3\\n            result += count / 3;\\n\\n            // If there are any tasks left with count less than 3, we need an additional round\\n            // to process these tasks\\n            if(count % 3 != 0) result++;\\n        }\\n\\n        // Return the total number of rounds needed to process all tasks\\n        return result;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // Sort the tasks array in ascending order\\n        Arrays.sort(tasks);\\n        int result = 0, count = 0;\\n        // Iterate through each task\\n        for (int i = 0; i < tasks.length; i++) {\\n            // Increment the count of tasks with the same value\\n            count++;\\n            // If we have reached the last task or the current task is different from the next task\\n            if (i == tasks.length - 1 || tasks[i] != tasks[i + 1]) {\\n                // If there is only one task with this value, we cannot create groups of 3\\n                // and we return -1\\n                if (count == 1) {\\n                    return -1;\\n                }\\n                // Add the number of full groups of 3 we can create from the tasks with this value\\n                result += count / 3;\\n                // If there are remaining tasks that cannot be included in a group of 3,\\n                // we need one more round to process these tasks\\n                if(count % 3 != 0) result++;\\n                // Reset the count for the next set of tasks\\n                count = 0;\\n           }\\n        }\\n        // Return the total number of rounds needed\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955360,
                "title": "easy-math-implementation-c",
                "content": "If you think about this question, you will get to know that actually there are only three possibility to this question.\\nLets take those three possibility into account:\\n1. If the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\n2. If the frequency is directly divided by 3, then we return the frequency/3.\\n3. If the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\n\\t* \\tIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\n\\t* \\tIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\n\\nFor calculating the frequency we have to use the hashmap.\\n\\n**Hope you get it now :)**\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> hm;\\n        for(int i=0;i<tasks.size();i++){\\n            hm[tasks[i]]++;\\n        }\\n        int freq,ans=0;\\n        for (auto i : hm){\\n            freq = i.second;\\n            if(freq==1)\\n                return -1;\\n            if(freq%3==0){\\n                ans += freq/3;\\n            }\\n            else{\\n                ans += freq/3 + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> hm;\\n        for(int i=0;i<tasks.size();i++){\\n            hm[tasks[i]]++;\\n        }\\n        int freq,ans=0;\\n        for (auto i : hm){\\n            freq = i.second;\\n            if(freq==1)\\n                return -1;\\n            if(freq%3==0){\\n                ans += freq/3;\\n            }\\n            else{\\n                ans += freq/3 + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994730,
                "title": "python3-greedy-approach-one-liner-explained",
                "content": "\\n**What the problem is asking:**\\n(1) Since at each round we can only finish tasks at the same difficulty level, we count the frequency of each number in the tasks first.\\n(2) For each frequency, we need to decide:\\n - Is it possible to bring it down to 0 by only subtracting 2 or 3?\\n - What\\'s the minimum round of only subtracting 2 or 3 to bring it down to 0?\\n\\n**Observations:**\\n(1) If it is 1, it is impossible to bring it to 0, so return -1. Think it this way, if the number is even, we can always bring it to zero by subtracting 2s. If the number is odd and greater than 2, we can always subtract 3 from it to make it even, and then make it to zero by subtracting 2s\\n(2) If it is 2, we just need 1 round (subtract a 2) to bring it to 0.\\n(3) If it is greater than 2, we want to subtract 3 as many times as possible but making sure the leftover is still divisible by 2. Here is the trick:\\n - it is import to note that the leftover can never be more than 4, this is because if the leftover is 5, we can subtract a 3 and the leftover (2) is still divisable by 2, and if the leftover is 6, we can simply bring it down to 0 by subtracting 3 two times.\\n\\n**Algorithm:**\\n - Count the frequency of unique number in ```tasks```\\n - For each frequency:\\n    - if ```freq``` is 1, return -1\\n    - if ```(freq-2) % 3 == 0```, we need ```(freq-2) / 3 + 1``` rounds to bring it to 0.\\n    - if ```(freq-4) % 3 == 0```, we need ```(freq-4) / 3 + 2``` rounds.\\n    - if ```freq % 3 == 0```, we need ```freq / 3``` rounds.\\n    - We have only one case left, which is using 2 all the way, so we need ```freq / 2``` rounds.\\n\\n**Solution 1**\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks)\\n        res = 0\\n        for freq in frequency.values():\\n            if freq == 1:\\n                return -1\\n            elif (freq-2) % 3 == 0:\\n                res += (freq-2) // 3 + 1\\n            elif (freq - 4) % 3 == 0:\\n                res += (freq - 4) // 3 +2\\n            elif freq % 3 == 0:\\n                res += freq // 3\\n            else:\\n                res += freq // 2\\n        return res\\n```\\n\\n**Solution 2**: The code can be further optimized, basically we just need ceil(freq/3) for all valid cases.\\n\\nExamples:\\nleftover = 2, we need (freq-2) / 3 + 1 == ceil(freq/3)\\nleftover = 4, we need (freq-4) / 3 + 2 == ceil(freq/3)\\n\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks)\\n        res = 0\\n        for freq in frequency.values():\\n            if freq == 1:\\n                return -1\\n            res += ceil(freq/3)\\n        return res\\n```\\n\\n**Solution 3:** one-liner (Only for the sake of making it one line...)\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        return sum(ceil(freq/3) for freq in Counter(tasks).values()) if 1 not in Counter(tasks).values() else -1\\n```\\n\\n**Solution 4:** Another interesting and better one-liner from [seibel](https://leetcode.com/seibel/)\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        return max(-1,sum(ceil(freq/3) if freq>1 else -inf for freq in Counter(tasks).values()))\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```tasks```\n```freq```\n```(freq-2) % 3 == 0```\n```(freq-2) / 3 + 1```\n```(freq-4) % 3 == 0```\n```(freq-4) / 3 + 2```\n```freq % 3 == 0```\n```freq / 3```\n```freq / 2```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks)\\n        res = 0\\n        for freq in frequency.values():\\n            if freq == 1:\\n                return -1\\n            elif (freq-2) % 3 == 0:\\n                res += (freq-2) // 3 + 1\\n            elif (freq - 4) % 3 == 0:\\n                res += (freq - 4) // 3 +2\\n            elif freq % 3 == 0:\\n                res += freq // 3\\n            else:\\n                res += freq // 2\\n        return res\\n```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks)\\n        res = 0\\n        for freq in frequency.values():\\n            if freq == 1:\\n                return -1\\n            res += ceil(freq/3)\\n        return res\\n```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        return sum(ceil(freq/3) for freq in Counter(tasks).values()) if 1 not in Counter(tasks).values() else -1\\n```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        return max(-1,sum(ceil(freq/3) if freq>1 else -inf for freq in Counter(tasks).values()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995198,
                "title": "java-o-n-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count = 0; HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int x : tasks)\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        for(int x : map.keySet())\\n            if(map.get(x)==1)return -1;\\n            else{\\n                count+=map.get(x)/3;\\n                if(map.get(x)%3!=0)count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count = 0; HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int x : tasks)\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        for(int x : map.keySet())\\n            if(map.get(x)==1)return -1;\\n            else{\\n                count+=map.get(x)/3;\\n                if(map.get(x)%3!=0)count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956121,
                "title": "java-o-n-easy-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Each round, we can complete either 2 or 3 tasks of the same difficulty level\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a map to store the key `task` and the value `number of tasks`\\n- Loop the map entries and take as many 3\\'s as possible\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n    - $$O(n)$$ Looping task array\\n    - $$O(n)$$ Looping the hashmap\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ - for the hashmap\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int round = 0;\\n        Map<Integer, Integer> taskMap = new HashMap<>(); // map of <task,  number of each task>\\n        for (int i = 0; i < tasks.length; i++) {\\n            taskMap.put(tasks[i], taskMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n        \\n        for (Map.Entry<Integer, Integer> entry : taskMap.entrySet()) {\\n            if (entry.getValue() == 1) {\\n                return -1; // we cannot complete if there is only 1 task\\n            }\\n\\t\\t\\t// try to take as many 3\\'s as possible\\n            round += entry.getValue() / 3; \\n\\t\\t\\t\\n            /*\\n\\t\\t\\t\\tWe can have 1 or 2 tasks remaining. We\\'re not supposed to take task of count 1, but we can \\'borrow\\' 1 from the previous\\n\\t\\t\\t\\tex. [5,5,5,5,5,5,5] -> [5,5,5][5,5,5][5]\\n\\t\\t\\t\\tIn this example, treat the last [5,5,5], [5] as [5,5], [5,5]\\n            */\\n            if (entry.getValue() % 3 != 0) { \\n                round++; \\n            }\\n        }\\n        return round;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int round = 0;\\n        Map<Integer, Integer> taskMap = new HashMap<>(); // map of <task,  number of each task>\\n        for (int i = 0; i < tasks.length; i++) {\\n            taskMap.put(tasks[i], taskMap.getOrDefault(tasks[i], 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2995836,
                "title": "c-easy-fully-explained-map",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n\\n# Approach\\n1.we have to count freq of each task[i]\\nFor that we will use unoredered map and count freq of the task\\n2.if we have single task ->**freq[task[i]]==1, then return -1**\\nwhy -1?->**bcz we have to complete 2 or 3 task in one time**\\nif task is multiple of three then we can do three task together\\n**then add freq[task[i]]/3 to ans**\\notherwise add **freq[task[i]]/3 +1** to ans\\nlets suppose we have 2 task then we can do in one go\\nif we have 4 task then we will do 2,2\\nif we have 5 task then we will do 3,2\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n- Space complexity:O(N)\\n\\n***If you like the solution please upvote***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int ans=0;\\n        unordered_map<int,int>freq;\\n        for(int i=0;i<tasks.size();i++){\\n            freq[tasks[i]]++;\\n        }\\n        for(auto it:freq){\\n            int k=it.second;\\n            if(k==1)return -1;\\n            if(k%3==0)\\n            ans+=k/3;\\n            else \\n            ans+=(k/3)+1;\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int ans=0;\\n        unordered_map<int,int>freq;\\n        for(int i=0;i<tasks.size();i++){\\n            freq[tasks[i]]++;\\n        }\\n        for(auto it:freq){\\n            int k=it.second;\\n            if(k==1)return -1;\\n            if(k%3==0)\\n            ans+=k/3;\\n            else \\n            ans+=(k/3)+1;\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995109,
                "title": "python-3-1-6-lines-w-example-t-m-97-32",
                "content": "Here\\'s the plan:\\n- Use`Counter` to determine the count`n`of each integer in the array.\\n- Determine whether`n = 1`for any integer. If so,`return -1`.\\n- For the count`n`of each integer in the array, add`n//3`to`ans`, plus 1 if`n%3 > 0`\\n- Return`ans`\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: list[int]) -> int:\\n                                            # Example: tasks = [2,2,3,3,2,4,4,4,4,4,4,4]\\n\\n        tasks = Counter(tasks)              #          tasks = {3:2, 2:3, 4:5}\\n        \\n        if 1 in tasks.values(): return -1   # <-- no solution if there\\'s a singleton\\n\\n        ans = 0                             # tasks.values() = [2, 3, 5]     \\n        for n in tasks.values():\\n            ans+= n//3 + bool(n%3)          # ans  = (2//3+True) + (3//3+False) + (5//3+True)\\n                                            #      = ( 0  +  1  ) + (  1 +  0 ) + (1   +  1 )\\n        return  ans                         #      = 4  <-- return\\n```\\nAnd, if you must, here\\'s a one-liner:\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: list[int]) -> int:\\n\\n        return sum(n//3 + bool(n%3) for n in Counter(tasks).values()) if 1 not in Counter(tasks).values() else -1\\n```\\n[https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/682458298/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: list[int]) -> int:\\n                                            # Example: tasks = [2,2,3,3,2,4,4,4,4,4,4,4]\\n\\n        tasks = Counter(tasks)              #          tasks = {3:2, 2:3, 4:5}\\n        \\n        if 1 in tasks.values(): return -1   # <-- no solution if there\\'s a singleton\\n\\n        ans = 0                             # tasks.values() = [2, 3, 5]     \\n        for n in tasks.values():\\n            ans+= n//3 + bool(n%3)          # ans  = (2//3+True) + (3//3+False) + (5//3+True)\\n                                            #      = ( 0  +  1  ) + (  1 +  0 ) + (1   +  1 )\\n        return  ans                         #      = 4  <-- return\\n```\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: list[int]) -> int:\\n\\n        return sum(n//3 + bool(n%3) for n in Counter(tasks).values()) if 1 not in Counter(tasks).values() else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994822,
                "title": "java-code-using-hash-map",
                "content": "# Intuition\\nIf Frequency is less than 2 then we can\\'t complete the taks if Frequency is 2 then we can do it in one round else if Frequency is greater or equal to 3 then we can make combination of 2 or 3 and done it the number of rounds needed will always will be ceiling value of Frequency/3\\n\\n# Approach\\n\\ntake int ans = 0,\\nwe are storing frequency of the element in the hash map and then we will loop through map if the frequncy is less than 2 then we can\\'t complete the task as we have to do task in group of 2 or 3 that\\'s why we will return -1\\nif frequncy is 2 then we can add 1 to the ans\\nelse we can take the ceiling value and add it to the answer variable.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity : O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] arr) {\\n        Map<Integer,Integer>map = new HashMap<>();\\n        for(int i:arr){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int ans = 0;\\n        for(Integer val:map.values()){\\n            int freq= val;\\n            if(freq<2){\\n                return -1;\\n            }\\n            else if(freq==2){\\n                ans+=1;\\n            }\\n            else{\\n                double res = freq/3.0;\\n                ans+=Math.ceil(res);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nHappy Coding \\n\\nRadhe Radhe \\u2764\\uFE0F\\uD83D\\uDD49\\uFE0F",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] arr) {\\n        Map<Integer,Integer>map = new HashMap<>();\\n        for(int i:arr){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int ans = 0;\\n        for(Integer val:map.values()){\\n            int freq= val;\\n            if(freq<2){\\n                return -1;\\n            }\\n            else if(freq==2){\\n                ans+=1;\\n            }\\n            else{\\n                double res = freq/3.0;\\n                ans+=Math.ceil(res);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955562,
                "title": "java-python-3-o-n-greedy-codes-w-brief-explanation-and-analysis",
                "content": "\\n1. If there is ONLY one task for a certain level, then impossible and return `-1`;\\n2. Otherwise, we can always complete the tasks; Use `% 3` to check the occurrence (denote as `v`) of the tasks for each level: \\na.) if the result is `0`, we group them `3` by `3` and need at least `v / 3` rounds; \\nb.) if the result is `1`, `v = 3m + 1 = 3(m - 1) + 4 = 3(m - 1) + 2 + 2`, we can group them into `m - 1` 3-groups and `2` 2-groups, totally `m + 1 = 1 + v / 3` groups; \\nc.) If the result is `2`, `v = 3m + 2`, we group the `2` into a group and the remaining into 3-groups, totally `m + 1 = 1 + v / 3` groups; \\n**NO matter the result of `% 3` is `1` or `2`, we need at least 1 + v / 3 rounds to complete**.\\n\\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int t : tasks) {\\n            cnt.put(t, 1 + cnt.getOrDefault(t, 0));\\n        } \\n        int rounds = 0;\\n        for (int v : cnt.values()) {\\n            if (v == 1) {\\n                return -1;\\n            }\\n            rounds += v % 3 == 0 ? v / 3 : 1 + v / 3;\\n        }\\n        return rounds;\\n    }\\n```\\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks)\\n        rounds = 0\\n        for v in cnt.values():\\n            if v == 1:\\n                return -1\\n            rounds += v // 3 if v % 3 == 0 else 1 + v // 3\\n        return rounds\\n```\\n\\nThe above codes can be further simplified as:\\n\\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        IntStream.of(tasks).forEach(t -> cnt.merge(t, 1, Integer::sum));\\n        int rounds = 0;\\n        for (int v : cnt.values()) {\\n            if (v == 1) {\\n                return -1;\\n            }\\n            rounds += (2 + v) / 3;\\n        }\\n        return rounds;\\n    }\\n```\\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks)\\n        rounds = 0\\n        for v in cnt.values():\\n            if v == 1:\\n                return -1\\n            rounds += (2 + v) // 3\\n        return rounds\\n```\\nor\\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Long> cnt = IntStream.of(tasks).boxed().collect(Collectors.groupingBy(t -> t, Collectors.counting()));\\n        var values = cnt.values();\\n        return values.stream().anyMatch(v -> v == 1) ? -1 : (int)values.stream().mapToLong(v -> (2 + v) / 3).sum();\\n    }\\n```\\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        occur = Counter(tasks).values()\\n        return -1 if 1 in occur else sum((2 + v) // 3 for v in occur)\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = tasks.length`.\\n\\n--------\\n\\nPlease **let me know** if you have any **questions**, and **upvote** if the original post is helpful.",
                "solutionTags": [],
                "code": "```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int t : tasks) {\\n            cnt.put(t, 1 + cnt.getOrDefault(t, 0));\\n        } \\n        int rounds = 0;\\n        for (int v : cnt.values()) {\\n            if (v == 1) {\\n                return -1;\\n            }\\n            rounds += v % 3 == 0 ? v / 3 : 1 + v / 3;\\n        }\\n        return rounds;\\n    }\\n```\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks)\\n        rounds = 0\\n        for v in cnt.values():\\n            if v == 1:\\n                return -1\\n            rounds += v // 3 if v % 3 == 0 else 1 + v // 3\\n        return rounds\\n```\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        IntStream.of(tasks).forEach(t -> cnt.merge(t, 1, Integer::sum));\\n        int rounds = 0;\\n        for (int v : cnt.values()) {\\n            if (v == 1) {\\n                return -1;\\n            }\\n            rounds += (2 + v) / 3;\\n        }\\n        return rounds;\\n    }\\n```\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks)\\n        rounds = 0\\n        for v in cnt.values():\\n            if v == 1:\\n                return -1\\n            rounds += (2 + v) // 3\\n        return rounds\\n```\n```java\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Long> cnt = IntStream.of(tasks).boxed().collect(Collectors.groupingBy(t -> t, Collectors.counting()));\\n        var values = cnt.values();\\n        return values.stream().anyMatch(v -> v == 1) ? -1 : (int)values.stream().mapToLong(v -> (2 + v) / 3).sum();\\n    }\\n```\n```python\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        occur = Counter(tasks).values()\\n        return -1 if 1 in occur else sum((2 + v) // 3 for v in occur)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1955400,
                "title": "python-o-n-explanation",
                "content": "We count the number of times each element is repeated in the array. If any element is repeated only once then we can return -1, else we need to calculate the minimum number of rounds it will take to complete that particular difficulty.\\n\\nCount = frequency of each element\\nIf the count is a multiple of 3 (count % 3 = 0): Then we can group all the tasks in groups of 3, thus we can complete it in (count / 3) rounds.\\nFor example: count = 9; rounds will be: 3, 3, 3\\n\\nIf count % 3 = 1: Then we group 4 of the tasks in a group of 2 and the rest in groups of 3, thus we will take 3 (count/3 - 1) times and take 2 twice.\\nFor example: count = 10; rounds = 3, 3, 2, 2\\n\\nIf count % 3 = 2: Then we group 2 tasks in a group of 2 and group the rest of the tasks in groups of 3, thus we will take 3 (count/3) times and take 2 one time.\\nFor example: count = 11; rounds = 3, 3, 3, 2\\n\\nFrom the above analysis we can see that if the result of (count % 3) is 0, then we will need (count / 3) rounds to complete the tasks and if the result of (count % 3) is 1 or 2, we will need (count / 3 + 1) rounds to complete the tasks.\\n\\n```python\\n\\tdef minimumRounds(self, tasks: List[int]) -> int:\\n        def tot(count):\\n            rem = count % 3\\n            div = count // 3\\n            \\n            if rem == 0: return div\\n            else: return div + 1\\n        \\n        d = {}\\n        for n in tasks:\\n            d[n] = d.get(n, 0) + 1\\n            \\n        ans = 0\\n        for count in d.values():\\n            if count == 1: return -1\\n            ans += tot(count)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\tdef minimumRounds(self, tasks: List[int]) -> int:\\n        def tot(count):\\n            rem = count % 3\\n            div = count // 3\\n            \\n            if rem == 0: return div\\n            else: return div + 1\\n        \\n        d = {}\\n        for n in tasks:\\n            d[n] = d.get(n, 0) + 1\\n            \\n        ans = 0\\n        for count in d.values():\\n            if count == 1: return -1\\n            ans += tot(count)\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2997527,
                "title": "c-solution-with-detailed-explanations-time-complexity-analysis",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- Here in the map we\\u2019re storing all the tasks count of the same difficulty level.\\n- Iterating over map and checking 3 conditions:\\n    - `if(temp < 2)` here we can\\u2019t perform the task as the minimum required task needed to do in a single day is 2 \\u2192 ***return -1.***\\n    - `if(temp == 2)` here only one day is needed to do the work, so increase 1 in our ans.\\n    - `if(temp >= 3)` here we\\u2019ve more than 2 tasks, so we\\u2019ll divide the task number by 3 & add it, even if we have more tasks to do that will be less than 3, so we\\u2019ll increase ans value by 1.\\n- Return ans.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n\\n        for(auto x:tasks){\\n            mp[x] += 1;\\n        }\\n\\n        for(auto x:mp){\\n            int temp = x.second;\\n            if(temp < 2) return -1;\\n            else if(temp == 2) ans++;\\n            else if(temp >= 3){\\n                ans += temp/3;\\n                if(temp%3 != 0) ans++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n\\n        for(auto x:tasks){\\n            mp[x] += 1;\\n        }\\n\\n        for(auto x:mp){\\n            int temp = x.second;\\n            if(temp < 2) return -1;\\n            else if(temp == 2) ans++;\\n            else if(temp >= 3){\\n                ans += temp/3;\\n                if(temp%3 != 0) ans++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995074,
                "title": "faster-than-98-45-easy-explanation-simple-map-implementation",
                "content": "# Explanation \\uD83D\\uDC47\\n```\\nif a repetition < 2 then there is no possibililty of finishing that task\\n\\nand if it is divided by 3 then best way to finish that task in max possible way,\\n i.e. repetitions/3.\\n\\nbut if (repetition % 3 == 1) or (repetition % 3 == 2)\\nthen in the both cases we will get the answer as repetition/3 + 1;\\n\\n\\nlet me explain it:\\n\\nif(repetition%3 == 1)\\nthen\\nthe possible way to execute is x*3 + 2*2, where x=repetition/3 - 1;\\nso, x + 2 = repetition/3 - 1 + 2 = repetition/3 + 1;\\n\\nelse if (repetition%3 == 2)\\nthen\\nthe possible way to execute is x*3 + 1*2, where  x = repetition/3;\\nso, x + 1 = repetition/3 + 1;\\n\\n```\\n\\n<B></B>\\n<B></B>\\n\\n#### Time Complexity - O(n)\\n#### Space Complexity - O(n)\\n<B></B>\\n<B></B>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans=0;\\n        for(auto i : mp){\\n            int cur = i.second;\\n            if(cur<2)\\n                return -1;\\n            \\n            if(cur%3 == 0)\\n                ans += cur/3;\\n            else{\\n                ans += (cur/3 + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# If you find this helpful please upvote it.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif a repetition < 2 then there is no possibililty of finishing that task\\n\\nand if it is divided by 3 then best way to finish that task in max possible way,\\n i.e. repetitions/3.\\n\\nbut if (repetition % 3 == 1) or (repetition % 3 == 2)\\nthen in the both cases we will get the answer as repetition/3 + 1;\\n\\n\\nlet me explain it:\\n\\nif(repetition%3 == 1)\\nthen\\nthe possible way to execute is x*3 + 2*2, where x=repetition/3 - 1;\\nso, x + 2 = repetition/3 - 1 + 2 = repetition/3 + 1;\\n\\nelse if (repetition%3 == 2)\\nthen\\nthe possible way to execute is x*3 + 1*2, where  x = repetition/3;\\nso, x + 1 = repetition/3 + 1;\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans=0;\\n        for(auto i : mp){\\n            int cur = i.second;\\n            if(cur<2)\\n                return -1;\\n            \\n            if(cur%3 == 0)\\n                ans += cur/3;\\n            else{\\n                ans += (cur/3 + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996805,
                "title": "very-easy-to-understand-beginner-friendly-c-solution-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find how many times each task with a same difficulty level is there, we can store the array elements in a hashmap, in which keys are the difficulty level and its values are the number of tasks in the array of that difficulty level.\\n\\nIn simpler words, keys will be the numbers in array and values will be the number of times each number is present in the array.\\n\\nCreate a variable `ans` for counting total rounds.\\n\\nThen traverse the hashmap and in each iteration:\\n\\n- if any number has frequency 1, simply return -1 (as we can\\'t complete this task).\\n```return -1;```\\n \\n- if frequency is 2 or 3, add 1 in `ans` (total rounds)\\n```ans += 1;```\\n\\n\\n- else, (from the image in intuition part, we see after every 3 numbers (in LHS) the number (in RHS) is increasing by 1.) So, simply we can divide the frequency by 3 and take ceil value of it and add in `ans`\\n```ans += ceil( frequency / 3 );```\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // function to convert a number into its ceil form.\\n\\n    int ceilTo(int x, int y) {\\n        if (x%y) {\\n            return (x/y)+1;\\n        }\\n\\n        return x/y;\\n    }\\n\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int, int> m;\\n\\n        // inserting all the array elements into hashmap.\\n        for (auto x:tasks) {\\n            m[x]++;\\n        }\\n\\n        int ans = 0;    // variable to store total rounds required\\n\\n        for (auto x:m) {\\n            if (x.second == 1) return -1;\\n\\n            if (x.second > 3) {\\n                ans += ceilTo(x.second, 3);\\n            }\\n            else {\\n                ans += 1;\\n            }\\n        }\\n        // x.second means frequency\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease LIKE :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```return -1;```\n```ans += 1;```\n```ans += ceil( frequency / 3 );```\n```\\nclass Solution {\\npublic:\\n\\n    // function to convert a number into its ceil form.\\n\\n    int ceilTo(int x, int y) {\\n        if (x%y) {\\n            return (x/y)+1;\\n        }\\n\\n        return x/y;\\n    }\\n\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int, int> m;\\n\\n        // inserting all the array elements into hashmap.\\n        for (auto x:tasks) {\\n            m[x]++;\\n        }\\n\\n        int ans = 0;    // variable to store total rounds required\\n\\n        for (auto x:m) {\\n            if (x.second == 1) return -1;\\n\\n            if (x.second > 3) {\\n                ans += ceilTo(x.second, 3);\\n            }\\n            else {\\n                ans += 1;\\n            }\\n        }\\n        // x.second means frequency\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995478,
                "title": "easy-c-and-javascript-solution-frequency-map",
                "content": "# Good Morning\\n![Spider-Man-No-Way-Home-Doctor-Strange-Puffer-Jacket-568x614.jpg](https://assets.leetcode.com/users/images/33a33a7d-4dd2-4a1d-a7ba-1a797fbeefc0_1672806815.5246909.jpeg)\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>m;\\n        for(auto &i:tasks) m[i]++;\\n        int ans=0;\\n        for(auto &i:m)\\n        {\\n            if(i.second==1)\\n            {\\n                return -1;\\n            }\\n            ans+=ceil(i.second/3.0);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    let freq={}\\n    for(let i=0;i<tasks.length;i++)\\n    {\\n        if(freq[tasks[i]])\\n        {\\n            freq[tasks[i]]+=1;\\n        }\\n        else\\n        {\\n            freq[tasks[i]]=1;\\n        }\\n        \\n    }\\n    let ans=0;\\n    // console.log(freq);\\n    for(let obj in freq)\\n    {\\n        if(freq[obj]==1) return -1;\\n        else\\n        {\\n            ans+=Math.ceil(freq[obj]/3.0);\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n#### Upvote to keep me motivated.",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>m;\\n        for(auto &i:tasks) m[i]++;\\n        int ans=0;\\n        for(auto &i:m)\\n        {\\n            if(i.second==1)\\n            {\\n                return -1;\\n            }\\n            ans+=ceil(i.second/3.0);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    let freq={}\\n    for(let i=0;i<tasks.length;i++)\\n    {\\n        if(freq[tasks[i]])\\n        {\\n            freq[tasks[i]]+=1;\\n        }\\n        else\\n        {\\n            freq[tasks[i]]=1;\\n        }\\n        \\n    }\\n    let ans=0;\\n    // console.log(freq);\\n    for(let obj in freq)\\n    {\\n        if(freq[obj]==1) return -1;\\n        else\\n        {\\n            ans+=Math.ceil(freq[obj]/3.0);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955480,
                "title": "c-easy-solution-0ms-100-faster",
                "content": "\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        //counting occuences of all values in a map\\n        for(auto i:tasks)   mp[i]++;\\n        \\n        int ans=0;\\n        \\n        for(auto i=mp.begin();i!=mp.end();i++){\\n            \\n            //corner case if count of any value is 1 then return -1\\n            if(i->second==1)    return -1;\\n            \\n            if(i->second%3==0)  ans+=((i->second)/3);\\n            \\n            else if(i->second<6)\\n                if(i->second==2)   ans+=1;\\n                else ans+=2;\\n            \\n            else{\\n                \\n                ans+=((((i->second)/6)*2));\\n                i->second%=6;\\n                if(i->second==4 || i->second==5)    ans+=2;\\n                else    ans+=1;\\n                \\n            }\\n        }//end of for\\n        \\n        return ans;\\n        \\n    }//end of main\\n};\\n\\'\\'\\'\\nPlease Upvote if you find it Helpful.\\n\\uD83D\\uDE42\\uD83D\\uDC4D",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        //counting occuences of all values in a map\\n        for(auto i:tasks)   mp[i]++;\\n        \\n        int ans=0;\\n        \\n        for(auto i=mp.begin();i!=mp.end();i++){\\n            \\n            //corner case if count of any value is 1 then return -1\\n            if(i->second==1)    return -1;\\n            \\n            if(i->second%3==0)  ans+=((i->second)/3);\\n            \\n            else if(i->second<6)\\n                if(i->second==2)   ans+=1;\\n                else ans+=2;\\n            \\n            else{\\n                \\n                ans+=((((i->second)/6)*2));\\n                i->second%=6;\\n                if(i->second==4 || i->second==5)    ans+=2;\\n                else    ans+=1;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1955367,
                "title": "well-explained-python-solution",
                "content": "**Observation:**\\nThe question just boils downs to weather the ith task can be done by grouping it into groups of 2 or 3. \\nLet number of ith tasks be ***m***, ***a*** and ***b*** are the number of groups of 2\\'s and 3\\'s where ***a*** and ***b*** can assume any non negative values here. So, **m = 2 * a + 3 * b**\\n \\nWe can observe that this equation holds true for all values of ***m*** for ***m > 1***.\\n```\\n1 = Exception | 2 = 2 * 1 + 3 * 0 | 3 = 2 * 0 + 3 * 1 | 4 = 2 * 2 + 3 * 0 | 5 = 2 * 1 + 3 * 1 | 6 = 2 * 0 + 3 * 2 | 7 = 2 * 2 + 3 * 1 | 8 = 2 * 1 + 3 * 2 | 9 = 2 * 0 + 3 * 3 | 10 = 2 * 2 + 3 * 2 | 11 = 2 * 1 + 3 * 3 | 12 = 2 * 0 + 3 * 4 | 3 * 3 | 14 = 2 * 2 + 3 * 4 | 15 = 2 * 0 + 3 * 5 | 16 = 2 * 2 + 3 * 4 | 17 = 2 * 1 + 3 * 5 \\n```\\nThe repeated pattern for 3 consecutive integers here is: **A || B || C = 2  x + 3  y || 2  (x-1) + 3  (y+1) || 2  (x-2) + 3  (y+2)** [2 goes from x to x-2 while 3 goes from y to y+2] . Look at 1,2,3 and then 4, 5, 6 then 7, 8, 9. They repeat after every 3 values. Also we can notice why this is so: **B = A + 1 = A + (3 - 2) . Similarly C = B + 1 = B (3 - 2)**, since 3 is +ve and 2 is -ve, we have **x-1 or 2** for 2 and **y+1 or 2** for 3. Thus, total number of groups ***(x+y)*** increments after 3 values. \\n\\n**Reason:**\\nTake the base case of m = 2 and 3. They can be divided into group of one 2\\'s and one 3\\'s respectively. Now ontop of this base case add 2 and 3 to m = 2 and 3, we get 2+2 = 4, 2+3=5, 3+3 = 6, three consecutive numbers. Observe that adding 2 and 3 to previous values of m will give new values that will surely be divisible into groups of 2\\'s and 3\\'s as we just added 2 and 3 to a number which previously did follow this condition. \\n\\n**Code:**\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        table, res = Counter(tasks), 0 # Counter to hold frequency of ith task and res stores the result.\\n        for count in table.values():\\n            if count <= 1: return -1 # If count <= 1 then it cannot follow the condition hence return -1.\\n            res += ceil(count / 3) # Total number of groups increments after 3 values. \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n1 = Exception | 2 = 2 * 1 + 3 * 0 | 3 = 2 * 0 + 3 * 1 | 4 = 2 * 2 + 3 * 0 | 5 = 2 * 1 + 3 * 1 | 6 = 2 * 0 + 3 * 2 | 7 = 2 * 2 + 3 * 1 | 8 = 2 * 1 + 3 * 2 | 9 = 2 * 0 + 3 * 3 | 10 = 2 * 2 + 3 * 2 | 11 = 2 * 1 + 3 * 3 | 12 = 2 * 0 + 3 * 4 | 3 * 3 | 14 = 2 * 2 + 3 * 4 | 15 = 2 * 0 + 3 * 5 | 16 = 2 * 2 + 3 * 4 | 17 = 2 * 1 + 3 * 5 \\n```\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        table, res = Counter(tasks), 0 # Counter to hold frequency of ith task and res stores the result.\\n        for count in table.values():\\n            if count <= 1: return -1 # If count <= 1 then it cannot follow the condition hence return -1.\\n            res += ceil(count / 3) # Total number of groups increments after 3 values. \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869479,
                "title": "multiple-javascript-solutions-118ms-map-maths-for-loop-object",
                "content": "***Happy Coding..!* Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n```\\n\\n// Solution 1\\nconst minimumRounds = (tasks, map = new Map(), res = 0) => {\\n    for (let i = 0; i < tasks.length; i++) {\\n        map.set(tasks[i], (map.get(tasks[i]) !== undefined ? (map.get(tasks[i]) + 1) : 1))\\n    }\\n    const iterator = map.values();\\n    for (const value of iterator) {\\n        if (value < 2) return -1;\\n        let temp = parseInt(value / 3) + (value % 3 !== 0 ? 1 : 0);\\n        res += temp;\\n    }\\n    return res;\\n};\\n\\n// Solution 2\\nconst minimumRounds = (tasks) => {\\n    const counts = {};\\n    for (let task of tasks) {\\n        counts[task] = (counts[task] || 0) + 1;\\n    }\\n    let rounds = 0;\\n    for (let count of Object.values(counts)) {\\n        if (count < 2) {\\n            return -1;\\n        }\\n        rounds += Math.ceil(count / 3);\\n    }\\n    return rounds;\\n};\\n\\n```\\n\\n***Do upvote if you find this solution useful.***",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\n\\n// Solution 1\\nconst minimumRounds = (tasks, map = new Map(), res = 0) => {\\n    for (let i = 0; i < tasks.length; i++) {\\n        map.set(tasks[i], (map.get(tasks[i]) !== undefined ? (map.get(tasks[i]) + 1) : 1))\\n    }\\n    const iterator = map.values();\\n    for (const value of iterator) {\\n        if (value < 2) return -1;\\n        let temp = parseInt(value / 3) + (value % 3 !== 0 ? 1 : 0);\\n        res += temp;\\n    }\\n    return res;\\n};\\n\\n// Solution 2\\nconst minimumRounds = (tasks) => {\\n    const counts = {};\\n    for (let task of tasks) {\\n        counts[task] = (counts[task] || 0) + 1;\\n    }\\n    let rounds = 0;\\n    for (let count of Object.values(counts)) {\\n        if (count < 2) {\\n            return -1;\\n        }\\n        rounds += Math.ceil(count / 3);\\n    }\\n    return rounds;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955543,
                "title": "watch-for-1",
                "content": "**Intuition:** When we have only 1 number, we return `-1`. For other quantities, we can always complete the tasks in rounds of twos or threes.\\n\\n#### Approach 1: Sorting\\nWe could use a counter (see approach 2 below), but I wanted to do something different. Here, we sort numbers and then count repeated numbers.\\n\\n**C++**\\n```cpp\\nint minimumRounds(vector<int>& t) {\\n    int res = 0, cnt = 1;\\n    sort(begin(t), end(t));\\n    for (int i = 1; i <= t.size(); ++i, ++cnt) {\\n        if (i == t.size() || t[i - 1] != t[i]) {\\n            if (cnt == 1)\\n                return -1;\\n            res += (cnt + 2) / 3;\\n            cnt = 0;\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n#### Approach 2: Counter\\n**Python 3**\\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks).values()\\n        return -1 if 1 in cnt else sum((t + 2) // 3 for t in cnt)\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nint minimumRounds(vector<int>& t) {\\n    int res = 0, cnt = 1;\\n    sort(begin(t), end(t));\\n    for (int i = 1; i <= t.size(); ++i, ++cnt) {\\n        if (i == t.size() || t[i - 1] != t[i]) {\\n            if (cnt == 1)\\n                return -1;\\n            res += (cnt + 2) / 3;\\n            cnt = 0;\\n        }\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt = Counter(tasks).values()\\n        return -1 if 1 in cnt else sum((t + 2) // 3 for t in cnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997037,
                "title": "short-and-easy-linq-solution",
                "content": "```csharp\\npublic class Solution\\n{\\n    public int MinimumRounds(int[] tasks)\\n    {\\n            var counts = tasks.GroupBy(x => x).Select(x => x.Count());\\n            return counts.Any(x => x == 1)\\n                ? -1\\n                : counts.Sum(x => (x + 2) / 3);\\n    }\\n}\\n```\\n## Explanation\\n1. Count the difficulty levels.\\n2. If any of them comes up only once, return `-1` because it is not possible to complete all the tasks.\\n3. Otherwise, each difficulty level will require `(x + 2) / 3` actions. Return the sum.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int MinimumRounds(int[] tasks)\\n    {\\n            var counts = tasks.GroupBy(x => x).Select(x => x.Count());\\n            return counts.Any(x => x == 1)\\n                ? -1\\n                : counts.Sum(x => (x + 2) / 3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996053,
                "title": "java-hashmap-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // Using a hashMap to store the frequency \\n        Map<Integer,Integer> m = new HashMap<>();\\n        for(int task:tasks){\\n            // storing the frequency using getOrDefault (it\\'s a function from Property class )\\n            m.put(task,m.getOrDefault(task,0)+1);\\n        }\\n        // to maintain the total round count taking one variable\\n        int rounds = 0;\\n        for(int value:m.values()){\\n            // if the frequency is 1 then we can\\'t group( Ref. Example 2) \\n            if(value==1)\\n                return -1;\\n            // else we are trying to complete 3 tasks at a time because maximum we can solve 3 tasks\\n            rounds+=(value/3);\\n            // anything is remaining that should be 2 or 1 \\n            /* If it\\'s 2 then we can solve 2 tasks at a time \\n               so simply we can do rounds++*/\\n\\n                //If it\\'s 1 then we will backtrack and we should  \\n                // have 1+3 = 4 tasks , we can solve it by 2-->2 i.e \\n                //rounds +=2 but we had backtracked once so \\n                //rounds+=(2-1) again that it rounds++;\\n            if(value%3>0)\\n            rounds++;\\n        }\\n        return rounds;\\n    }\\n}\\n```\\n# If you liked it , Please upvote it \\uD83D\\uDE09",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // Using a hashMap to store the frequency \\n        Map<Integer,Integer> m = new HashMap<>();\\n        for(int task:tasks){\\n            // storing the frequency using getOrDefault (it\\'s a function from Property class )\\n            m.put(task,m.getOrDefault(task,0)+1);\\n        }\\n        // to maintain the total round count taking one variable\\n        int rounds = 0;\\n        for(int value:m.values()){\\n            // if the frequency is 1 then we can\\'t group( Ref. Example 2) \\n            if(value==1)\\n                return -1;\\n            // else we are trying to complete 3 tasks at a time because maximum we can solve 3 tasks\\n            rounds+=(value/3);\\n            // anything is remaining that should be 2 or 1 \\n            /* If it\\'s 2 then we can solve 2 tasks at a time \\n               so simply we can do rounds++*/\\n\\n                //If it\\'s 1 then we will backtrack and we should  \\n                // have 1+3 = 4 tasks , we can solve it by 2-->2 i.e \\n                //rounds +=2 but we had backtracked once so \\n                //rounds+=(2-1) again that it rounds++;\\n            if(value%3>0)\\n            rounds++;\\n        }\\n        return rounds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995354,
                "title": "easy-c-100-faster",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n$ $log(n))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(), tasks.end());\\n        int result = 0, i, j;\\n        for(i=0; i<tasks.size(); ++i){\\n            for(j=i+1; j<tasks.size(); ++j)\\n                if(tasks[i]!=tasks[j]) break;\\n            \\n            j = j-i;\\n            if(j==1) return -1;\\n\\n            result += j/3;\\n            if(j%3)\\n                ++result;\\n\\n            i += (j-1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(), tasks.end());\\n        int result = 0, i, j;\\n        for(i=0; i<tasks.size(); ++i){\\n            for(j=i+1; j<tasks.size(); ++j)\\n                if(tasks[i]!=tasks[j]) break;\\n            \\n            j = j-i;\\n            if(j==1) return -1;\\n\\n            result += j/3;\\n            if(j%3)\\n                ++result;\\n\\n            i += (j-1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994703,
                "title": "js-fast-and-straight-forward-commented",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\nPlease upvote if you found this helpful~\\n\\n# Code\\n```\\nvar minimumRounds = function (tasks) {\\n  let counter = {}, res = 0;\\n//Count frequency of each task \\n  for (let t of tasks) {\\n    counter[t] = (counter[t] || 0) + 1;\\n  }\\n//Go through the task and try to get 3(max) done each time.\\n  for (let k in counter) {\\n//If the task only show up Once, that means not possible.\\n    if (counter[k] === 1) return -1;\\n      res += Math.ceil(counter[k] / 3);\\n  }\\n  return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRounds = function (tasks) {\\n  let counter = {}, res = 0;\\n//Count frequency of each task \\n  for (let t of tasks) {\\n    counter[t] = (counter[t] || 0) + 1;\\n  }\\n//Go through the task and try to get 3(max) done each time.\\n  for (let k in counter) {\\n//If the task only show up Once, that means not possible.\\n    if (counter[k] === 1) return -1;\\n      res += Math.ceil(counter[k] / 3);\\n  }\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2995028,
                "title": "simple-and-easy-code-conceptual-solution-c",
                "content": "# **Please try to understand the discussion for this given solution before looking at the code\\nLink to the discussion : https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/discussion/comments/1740590\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int count=1;\\n        vector<int>cnt;\\n\\n        sort(tasks.begin(),tasks.end());\\n\\n        if(tasks.size()==1)\\n        return -1;\\n\\n        for(int i=1;i<tasks.size();i++){\\n            if(tasks[i]==tasks[i-1])\\n            count++;\\n            else{\\n                cnt.push_back(count);\\n                count=1;\\n            }\\n        }\\n        cnt.push_back(count);\\n\\n        count=0;\\n\\n        for(int i=0;i<cnt.size();i++){\\n            if(cnt[i]==1)\\n            return -1;\\n            if(cnt[i]==2 or cnt[i]==3)\\n            count++;\\n            if(cnt[i]>3)\\n            count+=(cnt[i]+2)/3;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int count=1;\\n        vector<int>cnt;\\n\\n        sort(tasks.begin(),tasks.end());\\n\\n        if(tasks.size()==1)\\n        return -1;\\n\\n        for(int i=1;i<tasks.size();i++){\\n            if(tasks[i]==tasks[i-1])\\n            count++;\\n            else{\\n                cnt.push_back(count);\\n                count=1;\\n            }\\n        }\\n        cnt.push_back(count);\\n\\n        count=0;\\n\\n        for(int i=0;i<cnt.size();i++){\\n            if(cnt[i]==1)\\n            return -1;\\n            if(cnt[i]==2 or cnt[i]==3)\\n            count++;\\n            if(cnt[i]>3)\\n            count+=(cnt[i]+2)/3;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995390,
                "title": "intuitive-memoization-using-coin-change-explained",
                "content": "# Upvote if helpful \\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# Intuition\\n```\\nWhen we look at the problem we can instantly say that \\nit is coin change problem where we have only coins \\nof 2 and 3 and we want to use minimum number \\nof coins for the frequency of every element.\\n```\\n\\n# Approach\\n``` \\nfirst we will calculate the frequency of every value \\nusing map and store the frequency in another array.\\nafter that for every element in that array we will apply \\ncoin change function which will give us minimum coins required\\nfor every frequency in that array.\\nif minimum coins comes out 100005(ie >10^5) for any of \\nthe frequency then we will instantly return -1 \\nas the combinations of 2, 3 is not possible so no need to\\ncalculate further.\\n\\nNow CoinChange Function:\\n    base cases:\\n        if n is 2, 3 then we can just return 1 as 1 round will\\n        be enough for that frequency.\\n        if n==1 then we don\\'t have any choice so have to return some\\n            larger value.\\n\\n        for every frequency we have 2 recursive calls:\\n                i)either take coin of 2 (obviously if n>=2)\\n                ii)or either take coin of 3.\\n        take minimum between 2 and return to my parent call.\\n\\n    while doing so we will store it in our dp so that if next\\n    time if same value comes then we will return the stored value.\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>dp;\\n    int coinchange(int n){\\n\\n        if(n==2 || n==3)return 1;\\n\\n        //if(n<0)return 100005;\\n\\n        if(n==1){\\n            return 100005;\\n        }\\n\\n        if(dp[n]!=-1)return dp[n];\\n\\n        int a=INT_MAX;\\n        if(n>=2){\\n            a= min(a, coinchange(n-2)+1);\\n        }\\n\\n        if(n>=3){\\n            a= min(a, coinchange(n-3)+1);\\n        }\\n\\n        return dp[n]= a;\\n        \\n    }\\n    int minimumRounds(vector<int>& tasks) {\\n        dp.resize(100005, -1);\\n\\n        unordered_map<int, int>mp;\\n        for(auto i: tasks)mp[i]++;\\n\\n        vector<int>arr;\\n        for(auto k: mp){\\n            arr.push_back(k.second);\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<arr.size(); i++){\\n            int curr= coinchange(arr[i]);\\n            if(curr>=100005)return -1;\\n            else ans+=curr;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# Thank You.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nWhen we look at the problem we can instantly say that \\nit is coin change problem where we have only coins \\nof 2 and 3 and we want to use minimum number \\nof coins for the frequency of every element.\\n```\n``` \\nfirst we will calculate the frequency of every value \\nusing map and store the frequency in another array.\\nafter that for every element in that array we will apply \\ncoin change function which will give us minimum coins required\\nfor every frequency in that array.\\nif minimum coins comes out 100005(ie >10^5) for any of \\nthe frequency then we will instantly return -1 \\nas the combinations of 2, 3 is not possible so no need to\\ncalculate further.\\n\\nNow CoinChange Function:\\n    base cases:\\n        if n is 2, 3 then we can just return 1 as 1 round will\\n        be enough for that frequency.\\n        if n==1 then we don\\'t have any choice so have to return some\\n            larger value.\\n\\n        for every frequency we have 2 recursive calls:\\n                i)either take coin of 2 (obviously if n>=2)\\n                ii)or either take coin of 3.\\n        take minimum between 2 and return to my parent call.\\n\\n    while doing so we will store it in our dp so that if next\\n    time if same value comes then we will return the stored value.\\n```\n```\\nclass Solution {\\npublic:\\nvector<int>dp;\\n    int coinchange(int n){\\n\\n        if(n==2 || n==3)return 1;\\n\\n        //if(n<0)return 100005;\\n\\n        if(n==1){\\n            return 100005;\\n        }\\n\\n        if(dp[n]!=-1)return dp[n];\\n\\n        int a=INT_MAX;\\n        if(n>=2){\\n            a= min(a, coinchange(n-2)+1);\\n        }\\n\\n        if(n>=3){\\n            a= min(a, coinchange(n-3)+1);\\n        }\\n\\n        return dp[n]= a;\\n        \\n    }\\n    int minimumRounds(vector<int>& tasks) {\\n        dp.resize(100005, -1);\\n\\n        unordered_map<int, int>mp;\\n        for(auto i: tasks)mp[i]++;\\n\\n        vector<int>arr;\\n        for(auto k: mp){\\n            arr.push_back(k.second);\\n        }\\n\\n        int ans=0;\\n        for(int i=0; i<arr.size(); i++){\\n            int curr= coinchange(arr[i]);\\n            if(curr>=100005)return -1;\\n            else ans+=curr;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955377,
                "title": "greedy-every-number-is-a-sum-of-2s-and-3s-except-1",
                "content": "**Intuition : Every number is a sum of 2s and 3s, except 1.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        int ans(0);\\n        unordered_map<int, int> m;\\n        for (auto t : tasks) m[t]++;\\n        \\n        for (auto p : m) {\\n            int val = p.second;\\n            \\n            if (val == 1) return -1;\\n            if (val % 3 == 0)  ans += val / 3; // as it will always take minimum number of moves.\\n            else {\\n\\t\\t\\t// here val % 3 is either 1 or 2. \\n            // divide val into groups such that there is a group 2 and rest of 3.\\n                int groupOfThree = val / 3;\\n\\t\\t\\t\\tif (val % 3 == 1)    groupOfThree--;\\n\\t\\t\\t\\tval -= groupOfThree * 3;\\n\\t\\t\\t\\tans += groupOfThree + val / 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java Solution**\\n\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        for (int task : tasks)\\n            m.put(task, m.getOrDefault(task, 0) + 1);\\n        \\n        int ans = 0;\\n        for (int val : m.values()) {\\n            if (val == 1) return -1;\\n            if (val % 3 == 0)  ans += val / 3;\\n            else {\\n                int groupOfThree = val / 3;\\n\\t\\t\\t\\tif (val % 3 == 1)    groupOfThree--;\\n\\t\\t\\t\\tval -= groupOfThree * 3;\\n\\t\\t\\t\\tans += groupOfThree + val / 2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        int ans(0);\\n        unordered_map<int, int> m;\\n        for (auto t : tasks) m[t]++;\\n        \\n        for (auto p : m) {\\n            int val = p.second;\\n            \\n            if (val == 1) return -1;\\n            if (val % 3 == 0)  ans += val / 3; // as it will always take minimum number of moves.\\n            else {\\n\\t\\t\\t// here val % 3 is either 1 or 2. \\n            // divide val into groups such that there is a group 2 and rest of 3.\\n                int groupOfThree = val / 3;\\n\\t\\t\\t\\tif (val % 3 == 1)    groupOfThree--;\\n\\t\\t\\t\\tval -= groupOfThree * 3;\\n\\t\\t\\t\\tans += groupOfThree + val / 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        for (int task : tasks)\\n            m.put(task, m.getOrDefault(task, 0) + 1);\\n        \\n        int ans = 0;\\n        for (int val : m.values()) {\\n            if (val == 1) return -1;\\n            if (val % 3 == 0)  ans += val / 3;\\n            else {\\n                int groupOfThree = val / 3;\\n\\t\\t\\t\\tif (val % 3 == 1)    groupOfThree--;\\n\\t\\t\\t\\tval -= groupOfThree * 3;\\n\\t\\t\\t\\tans += groupOfThree + val / 2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994718,
                "title": "c-java-python-map-w-comments",
                "content": "1. Count the frequency of each task.\\n2. if a task repeats only once then it is impossible to complete ( return -1 )\\n3. Divide each frequency with the max completable tasks in a round (freq/3)\\n4. check if there\\'s tasks left after division, such that if there is, we perform another round. (+1)\\n\\n[+]  We add +2 to each frequency in consideration of leftover tasks\\n        \\n    Eg: tasks[1,1,1,1,1] freq = 5\\n            instead of 5/3 +1 do (5+2)/3\\n\\n\\n```c++ []\\nint minimumRounds(vector<int>& tasks) {\\n    unordered_map<int,int> m;\\n    for(int t : tasks) // count frequency\\n        ++m[t];\\n\\n    int rounds = 0;\\n    for(auto &p : m){ \\n        if(p.second == 1) return -1; // impossible to complete\\n        rounds+= (p.second+2)/3; // max completable tasks (3)\\n    }\\n    return rounds;\\n```\\n```java []\\npublic int minimumRounds(int[] tasks) {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    for (int t : tasks)     // Count frequency\\n        m.put(t, m.getOrDefault(t, 0) + 1);\\n\\n    int rounds = 0;\\n    for (int freq : m.values()) {\\n        if (freq == 1) return -1;// impossible to complete\\n        rounds += (freq+2)/3;   // max possible rounds\\n    }\\n    return rounds;\\n```\\n```Python3 []\\ndef minimumRounds(self, tasks: List[int]) -> int:\\n    freqs = Counter(tasks).values()\\n    rounds = 0\\n    for f in freqs:\\n        if f == 1: \\n            return -1\\n        rounds += floor((f+2)/3)\\n    return rounds\\n```\\n```Python []\\ndef minimumRounds(self, tasks):\\n    freqs = Counter(tasks).values()\\n    rounds = 0\\n    for f in freqs:\\n        if f == 1: \\n            return -1\\n        rounds += (f+2)/3\\n    return rounds\\n\\n```\\n## RAW\\n```c++ []\\nint minimumRounds(vector<int>& tasks) {\\n    unordered_map<int,int> m;\\n    for(int &t : tasks) ++m[t];\\n    int rounds = 0;\\n    for(auto &p : m){        \\n        if(p.second == 1) return -1;\\n        rounds+= (p.second+2)/3;\\n    }\\n    return rounds;\\n```\\n```java []\\npublic int minimumRounds(int[] tasks) {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    for (int t : tasks)\\n        m.put(t, m.getOrDefault(t, 0) + 1);\\n    int rounds = 0;\\n    for (int freq : m.values()) {\\n        if (freq == 1) return -1;\\n        rounds += (freq+2)/3;\\n    }\\n    return rounds;\\n```\\n### ***Complexity***\\n ***Time***  : $$O(n)$$\\n ***Sapce*** : $$O(n)$$\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```c++ []\\nint minimumRounds(vector<int>& tasks) {\\n    unordered_map<int,int> m;\\n    for(int t : tasks) // count frequency\\n        ++m[t];\\n\\n    int rounds = 0;\\n    for(auto &p : m){ \\n        if(p.second == 1) return -1; // impossible to complete\\n        rounds+= (p.second+2)/3; // max completable tasks (3)\\n    }\\n    return rounds;\\n```\n```java []\\npublic int minimumRounds(int[] tasks) {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    for (int t : tasks)     // Count frequency\\n        m.put(t, m.getOrDefault(t, 0) + 1);\\n\\n    int rounds = 0;\\n    for (int freq : m.values()) {\\n        if (freq == 1) return -1;// impossible to complete\\n        rounds += (freq+2)/3;   // max possible rounds\\n    }\\n    return rounds;\\n```\n```Python3 []\\ndef minimumRounds(self, tasks: List[int]) -> int:\\n    freqs = Counter(tasks).values()\\n    rounds = 0\\n    for f in freqs:\\n        if f == 1: \\n            return -1\\n        rounds += floor((f+2)/3)\\n    return rounds\\n```\n```Python []\\ndef minimumRounds(self, tasks):\\n    freqs = Counter(tasks).values()\\n    rounds = 0\\n    for f in freqs:\\n        if f == 1: \\n            return -1\\n        rounds += (f+2)/3\\n    return rounds\\n\\n```\n```c++ []\\nint minimumRounds(vector<int>& tasks) {\\n    unordered_map<int,int> m;\\n    for(int &t : tasks) ++m[t];\\n    int rounds = 0;\\n    for(auto &p : m){        \\n        if(p.second == 1) return -1;\\n        rounds+= (p.second+2)/3;\\n    }\\n    return rounds;\\n```\n```java []\\npublic int minimumRounds(int[] tasks) {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    for (int t : tasks)\\n        m.put(t, m.getOrDefault(t, 0) + 1);\\n    int rounds = 0;\\n    for (int freq : m.values()) {\\n        if (freq == 1) return -1;\\n        rounds += (freq+2)/3;\\n    }\\n    return rounds;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2994683,
                "title": "daily-leetcoding-challenge-january-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2999453,
                "title": "best-solution-ever-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        int count=0;\\n        int num=1;\\n        for(int i=1;i<tasks.size();i++){\\n            if(tasks[i]!=tasks[i-1]){\\n                if(num==1)return -1;\\n                if(num==3|| num==2)count=count+1;\\n                if(num>3){\\n                    count=count+num/3;\\n                    if(num%3>0){\\n                        count=count+1;\\n                    }\\n                    \\n                }\\n                num=1;\\n            }else{\\n                num++;\\n            }\\n        \\n        }\\n        if(num<2)return -1;    \\n        if(num==2)count++;\\n        else if(num%3!=0)count+=num/3+1;\\n        else count+=num/3;\\n\\n        return count;\\n\\n\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        int count=0;\\n        int num=1;\\n        for(int i=1;i<tasks.size();i++){\\n            if(tasks[i]!=tasks[i-1]){\\n                if(num==1)return -1;\\n                if(num==3|| num==2)count=count+1;\\n                if(num>3){\\n                    count=count+num/3;\\n                    if(num%3>0){\\n                        count=count+1;\\n                    }\\n                    \\n                }\\n                num=1;\\n            }else{\\n                num++;\\n            }\\n        \\n        }\\n        if(num<2)return -1;    \\n        if(num==2)count++;\\n        else if(num%3!=0)count+=num/3+1;\\n        else count+=num/3;\\n\\n        return count;\\n\\n\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997681,
                "title": "c-all-cases-explained-for-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo use minimum rounds we need to complete as many tasks possible in group of 3 and remainder could be done in pair of two.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we will completing as many tasks possible in group of 3. Following are the cases for varied frequency of tasks: -\\n\\n**Case 1: Multiple of 3**\\n```\\nfreq = 9\\n```\\nWhen frequency is multiple of 3, freq%3 would be zero and freq/3 would be the required answer.\\n\\n**Case 2: Multiple of 2 but not 3**\\n```\\nfreq = 16\\n```\\nfreq%3 = 1, so in order to minimize the rounds we would take (freq/3)-1 rounds of 3 and thus leaving us with 4 rounds which could be handled in pair of 2 more rounds.\\n\\n**Case 3: Multiple of neither 2 or 3**\\n```\\nfreq = 11\\nor\\nfreq = 7\\n```\\nif freq%3 == 1, we do same as case 2\\nelse freq%3 == 2, we use more 1 round for the remaining pair of task.\\n\\n**Case 4:**\\n```\\nfreq = 1\\n```\\nreturn -1.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(number of distinct tasks*2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m;\\n\\n        for (auto x: tasks){\\n            m[x]++;\\n        }\\n\\n        int res= 0;\\n\\n        for (auto x : m){\\n            if (x.second == 1) return -1;\\n            \\n            res += x.second/3;\\n            x.second %= 3;\\n\\n            if (x.second == 1 || x.second == 2) res += 1;\\n            \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nfreq = 9\\n```\n```\\nfreq = 16\\n```\n```\\nfreq = 11\\nor\\nfreq = 7\\n```\n```\\nfreq = 1\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m;\\n\\n        for (auto x: tasks){\\n            m[x]++;\\n        }\\n\\n        int res= 0;\\n\\n        for (auto x : m){\\n            if (x.second == 1) return -1;\\n            \\n            res += x.second/3;\\n            x.second %= 3;\\n\\n            if (x.second == 1 || x.second == 2) res += 1;\\n            \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995879,
                "title": "t-m-98-96-98-26-java-solution-easy",
                "content": "# Please upvote if you like my solution .\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = 0;\\n        int i=0;\\n        while(i<tasks.length) {\\n            int j=i+1;\\n            while(j<tasks.length && tasks[i] == tasks[j]) j++;\\n            if(j-i==1) return -1;\\n            res += (j-i)%3 == 0 ? (j-i)/3 : (j-i)/3 + 1;\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on Linkedin https://www.linkedin.com/in/kailas-rathod/",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = 0;\\n        int i=0;\\n        while(i<tasks.length) {\\n            int j=i+1;\\n            while(j<tasks.length && tasks[i] == tasks[j]) j++;\\n            if(j-i==1) return -1;\\n            res += (j-i)%3 == 0 ? (j-i)/3 : (j-i)/3 + 1;\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995275,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt=Counter(tasks)\\n        sm=0\\n        for i in cnt:\\n            if cnt[i]==1:\\n                return -1\\n            x=cnt[i]//3\\n            y=cnt[i]%3\\n            if y==0:\\n                sm+=x\\n            else:\\n                sm+=(x+1)\\n        return sm\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        cnt=Counter(tasks)\\n        sm=0\\n        for i in cnt:\\n            if cnt[i]==1:\\n                return -1\\n            x=cnt[i]//3\\n            y=cnt[i]%3\\n            if y==0:\\n                sm+=x\\n            else:\\n                sm+=(x+1)\\n        return sm\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995048,
                "title": "daily-solution-most-easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        map<int,int> m; // frequency\\n        for(int i=0; i<tasks.size(); i++)\\n        {\\n            m[tasks[i]]++;\\n        }\\n\\n        bool k = false; // to check the last if statement\\n        int ans = 0;\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second == 1) // if any one of the element comes 1 time only\\n            {\\n                k = true;\\n                break;\\n            }\\n            \\n            ans = ans + ceil(it->second/3.0); // gives the maximum number -->ceil()\\n            \\n        }\\n\\n        if(k)\\n        {\\n            return -1;\\n        }\\n        return ans; //ans\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        map<int,int> m; // frequency\\n        for(int i=0; i<tasks.size(); i++)\\n        {\\n            m[tasks[i]]++;\\n        }\\n\\n        bool k = false; // to check the last if statement\\n        int ans = 0;\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second == 1) // if any one of the element comes 1 time only\\n            {\\n                k = true;\\n                break;\\n            }\\n            \\n            ans = ans + ceil(it->second/3.0); // gives the maximum number -->ceil()\\n            \\n        }\\n\\n        if(k)\\n        {\\n            return -1;\\n        }\\n        return ans; //ans\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994998,
                "title": "cpp-solution-using-unordered-hashmap-and-math-fastest-174-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**The basic Idea to solve this problem is to get the frequency of all the tasks and then figure out how to do a task in 2 or 3 task schemes\\nThen add all such schemes**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>**Create a frequency array or simply an empty hashmap\\n>Create an integer variable rounds = 0\\n>Tabulate the frequency of each task**\\n\\n>**Iterate the frequency table**\\n>>**If frequency is 1, return -1\\n>>Else Calculate frequency/3 + 1 [if frequency is not divisible by 3] else 0\\n>> Add the calculated value to the rounds variable**\\n\\n>**Return the rounds variable**\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution // Using Unordered_Hashmap, beats 100%, 174 ms\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        unordered_map<int, int> mp;\\n        int rounds = 0;\\n        for (int task : tasks) // Get the Frequency of each element in tasks array\\n            mp[task]++;\\n        for (auto task : mp)\\n        {\\n            int frequency = task.second; // Store the frequency\\n            if (frequency == 1)       // If the frequency is 1, there is no way to do 2 or 3 tasks at the same time\\n                return -1;\\n            rounds += frequency / 3 + (frequency % 3 != 0); // Else there is always frequency/3 + (frequency % 3 > 0), chances to to the thing\\n            \\n            \\n            /*\\n            Lets say the frequency is 7\\n            it can be done as 2 2 3\\n\\n            for 8\\n            it can be done as 2 3 3\\n\\n            for 9\\n            it can be done as 3 3 3\\n\\n            for 10\\n            it can be done as 2 2 3 3\\n\\n            for 11\\n            it can be done as 2 3 3 3\\n\\n            See the pattern???\\n            */\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution // Using Unordered_Hashmap, beats 100%, 174 ms\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        unordered_map<int, int> mp;\\n        int rounds = 0;\\n        for (int task : tasks) // Get the Frequency of each element in tasks array\\n            mp[task]++;\\n        for (auto task : mp)\\n        {\\n            int frequency = task.second; // Store the frequency\\n            if (frequency == 1)       // If the frequency is 1, there is no way to do 2 or 3 tasks at the same time\\n                return -1;\\n            rounds += frequency / 3 + (frequency % 3 != 0); // Else there is always frequency/3 + (frequency % 3 > 0), chances to to the thing\\n            \\n            \\n            /*\\n            Lets say the frequency is 7\\n            it can be done as 2 2 3\\n\\n            for 8\\n            it can be done as 2 3 3\\n\\n            for 9\\n            it can be done as 3 3 3\\n\\n            for 10\\n            it can be done as 2 2 3 3\\n\\n            for 11\\n            it can be done as 2 3 3 3\\n\\n            See the pattern???\\n            */\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994702,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n=tasks.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans=0;\\n        for(auto& it:mp){\\n            if(it.second==1) return -1;\\n            ans+=ceil(it.second/3.0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n=tasks.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans=0;\\n        for(auto& it:mp){\\n            if(it.second==1) return -1;\\n            ans+=ceil(it.second/3.0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956128,
                "title": "easy-js-javascript",
                "content": "```\\nvar minimumRounds = function(tasks) {\\n    const hash = {};\\n    let minRounds = 0;\\n    \\n    for (const task of tasks) {\\n        hash[task] = hash[task] + 1 || 1;\\n    }\\n    \\n    for (const count of Object.values(hash)) {\\n        if (count < 2) return -1;\\n        minRounds += Math.ceil(count / 3);\\n    }\\n    \\n    return minRounds;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRounds = function(tasks) {\\n    const hash = {};\\n    let minRounds = 0;\\n    \\n    for (const task of tasks) {\\n        hash[task] = hash[task] + 1 || 1;\\n    }\\n    \\n    for (const count of Object.values(hash)) {\\n        if (count < 2) return -1;\\n        minRounds += Math.ceil(count / 3);\\n    }\\n    \\n    return minRounds;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955642,
                "title": "c-0ms-o-n-commented-solution-easy-to-understand",
                "content": "Here is my commented solution to this question. I hope it helps...\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m; // map to store task and its frequency\\n        for(int i=0; i<tasks.size(); i++)\\n            m[tasks[i]]++; // storing frequencies in map\\n        int answer=0;\\n        for(auto x:m){\\n            if(x.second==1) // if a task is present only once, return -1\\n                return -1;\\n            answer+=(x.second)/3;\\n            /* if x.second is not divisible by 3, then we would be required to consider the cases when only two tasks are selected \\n            - in last round for (x.second%3==2)\\n            - in last two rounds (x.second%3==1) */\\n            if(x.second%3==1 || x.second%3==2)\\n                answer++;\\n        }\\n        return answer;\\n    }\\n};\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n- where n is the size of vector tasks\\n\\nAny suggestions are highly appreciated !!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m; // map to store task and its frequency\\n        for(int i=0; i<tasks.size(); i++)\\n            m[tasks[i]]++; // storing frequencies in map\\n        int answer=0;\\n        for(auto x:m){\\n            if(x.second==1) // if a task is present only once, return -1\\n                return -1;\\n            answer+=(x.second)/3;\\n            /* if x.second is not divisible by 3, then we would be required to consider the cases when only two tasks are selected \\n            - in last round for (x.second%3==2)\\n            - in last two rounds (x.second%3==1) */\\n            if(x.second%3==1 || x.second%3==2)\\n                answer++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955299,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n     map<int,int> mp;\\n        for(auto task:tasks)\\n        {\\n            mp[task]++;\\n        }\\n        int ans=0;\\n        for(auto pr:mp)\\n        {\\n            if(pr.second==1)\\n            {\\n                return -1;\\n            }\\n            else if(pr.second==2)\\n            {\\n                ans++;\\n            }\\n            else\\n            {\\n                ans+=ceil((double)pr.second/3.0);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n     map<int,int> mp;\\n        for(auto task:tasks)\\n        {\\n            mp[task]++;\\n        }\\n        int ans=0;\\n        for(auto pr:mp)\\n        {\\n            if(pr.second==1)\\n            {\\n                return -1;\\n            }\\n            else if(pr.second==2)\\n            {\\n                ans++;\\n            }\\n            else\\n            {\\n                ans+=ceil((double)pr.second/3.0);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955288,
                "title": "clean-java-code",
                "content": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n  \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int num : tasks){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int ans = 0;\\n        for(int key : map.keySet()){\\n            int val = map.get(key);\\n            if(val == 1) return -1;\\n            \\n            ans += val/3;\\n            if(val%3 != 0) ans += 1;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n  \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int num : tasks){\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2997519,
                "title": "simplest-c-map-o-n-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically its just simple maths in which if we first take all oureences in a map and then check if frequency of a number is divsible by 3that is the minimum rounds will take. ALso if remainder is 2 then we can take one more round beacuse 2 are left and if remainder is 1 then we have to take last 4 as (2 and 2) beacuse (3 and 1) is not doable so go wiht 2 and 2 . So if rem=1 we can do first freq-4 using 3 base rounding and rest 4 as (2 and 2).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust look at the code \\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& arr) {\\n       map<int,int>mp;\\n       int n=arr.size();\\n       for(int i=0;i<n;i++){\\n           mp[arr[i]]++;\\n       }\\n       int cnt=0;\\n       for(auto x:mp){\\n           if(x.second%3==0){\\n               cnt+=x.second/3;\\n              \\n           }\\n           else if(x.second%3==2){\\n             cnt+=x.second/3;\\n             cnt++;\\n           }\\n           else{\\n               cnt+=(x.second-4)/3;\\n               if((x.second-4)<0)return -1;\\n               cnt+=2;\\n           }\\n       }\\n       return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& arr) {\\n       map<int,int>mp;\\n       int n=arr.size();\\n       for(int i=0;i<n;i++){\\n           mp[arr[i]]++;\\n       }\\n       int cnt=0;\\n       for(auto x:mp){\\n           if(x.second%3==0){\\n               cnt+=x.second/3;\\n              \\n           }\\n           else if(x.second%3==2){\\n             cnt+=x.second/3;\\n             cnt++;\\n           }\\n           else{\\n               cnt+=(x.second-4)/3;\\n               if((x.second-4)<0)return -1;\\n               cnt+=2;\\n           }\\n       }\\n       return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997121,
                "title": "c-easy-fully-explained-map",
                "content": "# Intuition\\nif freq(level) == 1\\nwe cannot express in 3 tasks + 3 tasks + .. + 2 tasks\\n\\ncheck for freq(level) > 1\\nand try to express in 3 tasks + 3 tasks + .. + 2 tasks.\\n\\nso we should select the minimum number of 3 and 2.\\n\\nwe should select maximum of 3 tasks and at last add one (1 task or 2 task).\\n\\n# Approach\\nif freq(level) == 1 --> return -1;\\nif freq(level) == 2 --> one 2-task\\nif freq(level) == 3 --> one 3-task\\n\\nFrom observation, we can see that there\\'s only 3 possible outcomes.\\n\\n(A) If the frequency is 1, the task cannot be performed so we return -1.\\n(B) If the frequency is 3, the task can be performed and we return frequency/3.\\n(C) Now if the frequency is not completely divisible by 3, then the possible remainders are 1 and 2. Lets check them out:\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;\\n        for(int i = 0;i<tasks.size(); i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans = 0;\\n        for(auto x: mp){\\n            if(x.second <=1){\\n                return -1;\\n            }\\n      \\n            else {\\n               if(x.second%3 == 0)\\n               ans = ans + x.second/3;\\n\\n               else\\n               ans = ans + x.second/3 + 1;\\n\\n            }\\n\\n         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;\\n        for(int i = 0;i<tasks.size(); i++){\\n            mp[tasks[i]]++;\\n        }\\n        int ans = 0;\\n        for(auto x: mp){\\n            if(x.second <=1){\\n                return -1;\\n            }\\n      \\n            else {\\n               if(x.second%3 == 0)\\n               ans = ans + x.second/3;\\n\\n               else\\n               ans = ans + x.second/3 + 1;\\n\\n            }\\n\\n         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996726,
                "title": "c-using-map-efficient-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int ,int> mp;\\n        for(auto task : tasks){\\n            mp[task]++;\\n        }\\n        int round = 0;\\n        for(auto x : mp){\\n            if(x.second <=1){\\n                return -1;\\n            }\\n            else if(x.second == 2){\\n                round++;\\n            }\\n            else {\\n                round += ceil((double)x.second/3.0); \\n            }\\n        }\\n        return round;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int ,int> mp;\\n        for(auto task : tasks){\\n            mp[task]++;\\n        }\\n        int round = 0;\\n        for(auto x : mp){\\n            if(x.second <=1){\\n                return -1;\\n            }\\n            else if(x.second == 2){\\n                round++;\\n            }\\n            else {\\n                round += ceil((double)x.second/3.0); \\n            }\\n        }\\n        return round;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996693,
                "title": "one-line-c-solution",
                "content": "# Intuition\\nall about frequency so using map\\n\\n# Approach\\n1.If the frequency is 1, the task cannot be performed so we return -1.\\n2.If the frequency is 3, the task can be performed and we return frequency/3.\\n3.Now if the frequency is not completely divisible by 3, then return freq/3 + 1\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint countFreq(vector<int> arr, int n)\\n{\\n    int ans=0;\\n    unordered_map<int, int> mp;\\n \\n  \\n    for (int i = 0; i < n; i++)\\n        mp[arr[i]]++;\\n \\n    for (int i = 0; i < n; i++) {\\n      if (mp[arr[i]] != -1 && mp[arr[i]]==1)\\n      {\\n          \\n          return -1;\\n      }\\n      else if (mp[arr[i]] != -1 && mp[arr[i]]%3==0)\\n      {\\n          \\n          ans+=(mp[arr[i]])/3;\\n          mp[arr[i]] = -1;\\n      }\\n      else if (mp[arr[i]] != -1)\\n      {\\n          \\n          ans+=(mp[arr[i]])/3 +1;\\n          mp[arr[i]] = -1;\\n      }\\n    }\\n    return ans;\\n}\\n    int minimumRounds(vector<int>& tasks) {\\n        int n=tasks.size();\\n        return countFreq(tasks,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint countFreq(vector<int> arr, int n)\\n{\\n    int ans=0;\\n    unordered_map<int, int> mp;\\n \\n  \\n    for (int i = 0; i < n; i++)\\n        mp[arr[i]]++;\\n \\n    for (int i = 0; i < n; i++) {\\n      if (mp[arr[i]] != -1 && mp[arr[i]]==1)\\n      {\\n          \\n          return -1;\\n      }\\n      else if (mp[arr[i]] != -1 && mp[arr[i]]%3==0)\\n      {\\n          \\n          ans+=(mp[arr[i]])/3;\\n          mp[arr[i]] = -1;\\n      }\\n      else if (mp[arr[i]] != -1)\\n      {\\n          \\n          ans+=(mp[arr[i]])/3 +1;\\n          mp[arr[i]] = -1;\\n      }\\n    }\\n    return ans;\\n}\\n    int minimumRounds(vector<int>& tasks) {\\n        int n=tasks.size();\\n        return countFreq(tasks,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996352,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        for(auto x: tasks) mp[x]++;\\n        int ans = 0;\\n        for(auto x: mp) {\\n            if(x.second < 2) return -1;\\n            ans += ceil(1.0 * x.second / 3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        for(auto x: tasks) mp[x]++;\\n        int ans = 0;\\n        for(auto x: mp) {\\n            if(x.second < 2) return -1;\\n            ans += ceil(1.0 * x.second / 3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996323,
                "title": "c-hashmap-efficient-approach",
                "content": "# Intuition\\nWe need to count frequency of each element then apply conditions given in the problem.\\n\\n# Approach\\nWe use hashmap to store frequency of elements. Then, we check each element\\'s count if it is lesser than 2 we return -1. If its count is greater than 2, then we check whether that element is totally divided by 3, if yes then rounds will be count/3 else rounds will be cound/3 + 1. \\n**Example:** \\ntasks = [2,2,2,2]\\nrounds: count(2)/3+1 = 4/3+1 = 1+1 = 2\\nWe pass 2 tasks in the 1st round and again 2 tasks in the 2nd round.\\n\\ntasks = [2,2,2,2,2]\\nrounds: count(2)/3+1 = 5/3+1 = 1+1 = 2\\nWe pass 3/2 tasks in the 1st round and 2/3 tasks in the 2nd round.\\n\\ntasks = [2,2,2,2,2,2] (its count is totally divisible by 3)\\nrounds: count(2)/3 = 6/3 = 2\\nWe pass 3 tasks in the 1st round and again 3 tasks in the 2nd round.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        unordered_map<int,int> mp;\\n        for(auto &it : tasks)\\n            mp[it]++;\\n\\n        int rounds=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second<2) return -1;\\n            if(it.second%3==0) rounds += it.second/3; //[2,2,2,2,2,2], rounds: 6/3 = 2 \\n            else rounds += it.second/3 + 1; //[2,2,2,2,2], rounds: 5/3 + 1 = 1 + 1 = 2\\n        }\\n        return rounds;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        unordered_map<int,int> mp;\\n        for(auto &it : tasks)\\n            mp[it]++;\\n\\n        int rounds=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second<2) return -1;\\n            if(it.second%3==0) rounds += it.second/3; //[2,2,2,2,2,2], rounds: 6/3 = 2 \\n            else rounds += it.second/3 + 1; //[2,2,2,2,2], rounds: 5/3 + 1 = 1 + 1 = 2\\n        }\\n        return rounds;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996272,
                "title": "c-easy-greedy-approach-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){       \\n            if(x.second ==1) return -1;\\n            while(x.second >3) {\\n                x.second-=3;\\n                count++;\\n            }\\n            if(x.second) count++;\\n        }\\n        return count;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){       \\n            if(x.second ==1) return -1;\\n            while(x.second >3) {\\n                x.second-=3;\\n                count++;\\n            }\\n            if(x.second) count++;\\n        }\\n        return count;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995917,
                "title": "c-simple-if-else-explaination-hashset",
                "content": "# Intuition\\n- We want to cover all the tasks in the lot of 2 or 3.\\n- To achieve that, we will store the frequency of tasks.\\n- If the frequency is 1, we will directly return -1. Bcz mp[it]<2 or mp[it]<3.\\n- If the frequency of any task is exactly 2 or 3. Take it as one round.\\n- Now the question arises, if the frequency is greater than 2 or 3.\\n-> We will try to cover all the tasks, which we can cover in the lot of 3.\\n-> And then for remaining tasks, we cover under lot of 2. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        // store the frequencies \\n        map<int,int> mp;\\n        for( auto &it : tasks ) mp[it]++;\\n\\n        int rounds = 0;\\n\\n        for( auto &it : mp ){\\n            // tasks = [2,3,3]\\n            if( it.second == 1 ) return -1;\\n            // tasks = [2,2,3,3,2]\\n            else if( it.second == 2 || it.second == 3 ) rounds++;\\n\\n            // tasks = [4,4,4,4,4]\\n            else if ( it.second>3 ){\\n                int rem = it.second%3;\\n                // multiple of 3 \\n                rounds += it.second/3;\\n                // multiple of 2 \\n                if( rem%2 == 0 ) rounds += rem/2;\\n                // For tasks = [4,4,4,4], rem == 1;\\n                else rounds += 1;\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        // store the frequencies \\n        map<int,int> mp;\\n        for( auto &it : tasks ) mp[it]++;\\n\\n        int rounds = 0;\\n\\n        for( auto &it : mp ){\\n            // tasks = [2,3,3]\\n            if( it.second == 1 ) return -1;\\n            // tasks = [2,2,3,3,2]\\n            else if( it.second == 2 || it.second == 3 ) rounds++;\\n\\n            // tasks = [4,4,4,4,4]\\n            else if ( it.second>3 ){\\n                int rem = it.second%3;\\n                // multiple of 3 \\n                rounds += it.second/3;\\n                // multiple of 2 \\n                if( rem%2 == 0 ) rounds += rem/2;\\n                // For tasks = [4,4,4,4], rem == 1;\\n                else rounds += 1;\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995770,
                "title": "clean-code-fully-explained-hash-map-java",
                "content": "# Request \\uD83D\\uDE0A :\\n```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\\n# Approach [Explained in Comments] :\\n```\\nclass Solution \\n{\\n    public int minimumRounds(int[] tasks) \\n    {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int t : tasks) \\n            map.put(t, map.getOrDefault(t, 0) + 1);//adding values in Map\\n        \\n        int count = 0;\\n        for (int key : map.keySet()) //creating a set and picking values form set\\n        {\\n            int value = map.get(key);\\n            if (value == 1) //single task\\n                return -1;\\n            else if (value == 2) //complete 2 task \\n                count += 1;\\n            else if (value % 3 == 0)//complete 3 task\\n                count += value / 3;//max 3 tasks & increase round count\\n            else \\n                count += value / 3 + 1;//greater than 3 tasks & increase round count\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\n```\\nclass Solution \\n{\\n    public int minimumRounds(int[] tasks) \\n    {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int t : tasks) \\n            map.put(t, map.getOrDefault(t, 0) + 1);//adding values in Map\\n        \\n        int count = 0;\\n        for (int key : map.keySet()) //creating a set and picking values form set\\n        {\\n            int value = map.get(key);\\n            if (value == 1) //single task\\n                return -1;\\n            else if (value == 2) //complete 2 task \\n                count += 1;\\n            else if (value % 3 == 0)//complete 3 task\\n                count += value / 3;//max 3 tasks & increase round count\\n            else \\n                count += value / 3 + 1;//greater than 3 tasks & increase round count\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995335,
                "title": "c-easy-greedy-solution-using-hashmap",
                "content": "# **C++ Easy Greedy Solution Using HashMap**\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(auto&task:tasks){\\n            m[task]++;\\n        }\\n        int ans=0;\\n        for(auto it=m.begin();it!=m.end();it++){\\n            if(it->second==1){\\n                ans=-1;\\n                break;\\n            }\\n            else{\\n                ans+=ceil((it->second)/3.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **Please Upvote it really Motivates me\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(auto&task:tasks){\\n            m[task]++;\\n        }\\n        int ans=0;\\n        for(auto it=m.begin();it!=m.end();it++){\\n            if(it->second==1){\\n                ans=-1;\\n                break;\\n            }\\n            else{\\n                ans+=ceil((it->second)/3.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960040,
                "title": "minimum-rounds-to-complete-all-tasks",
                "content": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        d=Counter(tasks)\\n        c=0\\n\\t\\t\"\"\" If any task is present only once it cannot be completed\"\"\"\\n        for v in d.values():\\n            if v==1:\\n                return -1\\n        \\n        for k,v in d.items():\\n            if v==2 or v==3:\\n                c+=1\\n            elif v>3:\\n                c+=math.ceil(v/3)\\n        return c\\n\\t\\t\\nPlease upvote if you find this helpful\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        d=Counter(tasks)\\n        c=0\\n\\t\\t\"\"\" If any task is present only once it cannot be completed\"\"\"\\n        for v in d.values():\\n            if v==1:\\n                return -1\\n        \\n        for k,v in d.items():\\n            if v==2 or v==3:\\n                c+=1\\n            elif v>3:\\n                c+=math.ceil(v/3)\\n        return c\\n\\t\\t\\nPlease upvote if you find this helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999499,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int t : tasks) {\\n            count.put(t, count.getOrDefault(t, 0) + 1);\\n        }\\n        int ans = 0;\\n        for (int x : count.values()) {\\n            if (x == 1) {\\n                return -1;\\n            }\\n            ans += x / 3 + (x % 3 == 0 ? 0 : 1);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n#### My initial approach\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int t : tasks) {\\n            count.put(t, count.getOrDefault(t, 0) + 1);\\n        }\\n        int result = 0;\\n        for (int x : count.values()) {\\n            if (x == 1) return -1;\\n            result += x / 3;\\n            if(x % 3 != 0) result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int t : tasks) {\\n            count.put(t, count.getOrDefault(t, 0) + 1);\\n        }\\n        int ans = 0;\\n        for (int x : count.values()) {\\n            if (x == 1) {\\n                return -1;\\n            }\\n            ans += x / 3 + (x % 3 == 0 ? 0 : 1);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int t : tasks) {\\n            count.put(t, count.getOrDefault(t, 0) + 1);\\n        }\\n        int result = 0;\\n        for (int x : count.values()) {\\n            if (x == 1) return -1;\\n            result += x / 3;\\n            if(x % 3 != 0) result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999367,
                "title": "python-solution-beats-95",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        d, count = Counter(tasks), 0\\n        if 1 in d.values():\\n            return -1\\n        for i in d.values():\\n            count+=(i+2)//3\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        d, count = Counter(tasks), 0\\n        if 1 in d.values():\\n            return -1\\n        for i in d.values():\\n            count+=(i+2)//3\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999219,
                "title": "map-c-stl-o-n-space-and-time",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> mp;\\n        for(int x:tasks) mp[x]++;\\n        int ans=0;\\n\\n        for(auto x:mp)\\n        {\\n            if(x.second==1) return -1;\\n            else if(x.second%3==0) ans+=(x.second/3);\\n            else if(x.second%3==2 || x.second%3==1) ans+=(x.second/3 + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> mp;\\n        for(int x:tasks) mp[x]++;\\n        int ans=0;\\n\\n        for(auto x:mp)\\n        {\\n            if(x.second==1) return -1;\\n            else if(x.second%3==0) ans+=(x.second/3);\\n            else if(x.second%3==2 || x.second%3==1) ans+=(x.second/3 + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997700,
                "title": "complete-all-task-mathematical-approach",
                "content": "# Intuition\\nLet\\'s understand this problem little more deeper, consider a number 10 how can we achieve it in minimum tries?\\nThe easiest way any one can figure out is the number of times 3 jobs can be done which is 3 * 3 = 9 and we have a remainder 1.\\n\\nOne key thing we may observe is that 3 can be done by subtracting one from 9 and doing it as 2 jobs of 2. which means 4 can be achieved by 2 jobs of 2.\\n\\nNOTE: this will work for any number except 1, for which we should return -1.\\n\\n# Approach\\n- Find the frequency of the number using a hashmap.\\n- Find whether the frequency is 1, if so return -1, else\\n- Find the divisibility of that number by 3 and the reminder.\\n- If the remainder is greater than 0 then add one to the result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int res=0;\\n        HashMap<Integer, Integer> map= new HashMap();\\n        for(int i: tasks){\\n        \\tint count = map.getOrDefault(i, 0);\\n        \\tmap.put(i, ++count);\\n        }\\n\\t\\tfor (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n\\t\\t\\tint i = e.getValue();\\n\\t\\t\\tif (i == 1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tres = res + i / 3;\\n\\t\\t\\tif (i % 3 == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t\\treturn res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int res=0;\\n        HashMap<Integer, Integer> map= new HashMap();\\n        for(int i: tasks){\\n        \\tint count = map.getOrDefault(i, 0);\\n        \\tmap.put(i, ++count);\\n        }\\n\\t\\tfor (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n\\t\\t\\tint i = e.getValue();\\n\\t\\t\\tif (i == 1)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tres = res + i / 3;\\n\\t\\t\\tif (i % 3 == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t\\treturn res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997255,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND THIS APPROACH HELPFUL :)**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a frequency-related problem, so we\\'ll use a map data structure to solve it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we can observe that there\\'s only 2 possible outputs:-\\n1. If the frequency is equal to 1 then task can\\'t be performed so we will return -1.\\n2. If the frequency is greater than 1 then tasks can be performed and with two sub possibilies:-\\n    a. If the frequency is divisible by 3 then number of rounds required will be task\\'s frequency/3.\\n    b. If the frequency is not divisible by 3 then number of rounds required will be task\\'s (frequency/3)+1, as 1 or 2 tasks will be remaining in last and can be shifted with other tasks using one more round.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n\\n        int rounds = 0;\\n\\n        // creating and initializing the map\\n        unordered_map<int, int> m;\\n        for(int i=0; i<tasks.size(); i++){\\n            m[tasks[i]]++;\\n        }\\n\\n        for(auto i:m){\\n            // when no of tasks with same level is only 1\\n            if(i.second == 1){\\n                return -1;\\n            }\\n            \\n            // when no of tasks with same level is more than 1\\n            else{\\n\\n                // when no of tasks with same level is divisible by 3\\n                if(i.second%3 == 0){\\n                    rounds += (i.second/3);\\n                }\\n                \\n                // when no of tasks with same level is remaining 1 or 2 in last, will add 1 more to round\\n                else if(i.second%3 == 1 || i.second%3 == 2){\\n                    rounds += (i.second/3)+1;\\n                }\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n\\n        int rounds = 0;\\n\\n        // creating and initializing the map\\n        unordered_map<int, int> m;\\n        for(int i=0; i<tasks.size(); i++){\\n            m[tasks[i]]++;\\n        }\\n\\n        for(auto i:m){\\n            // when no of tasks with same level is only 1\\n            if(i.second == 1){\\n                return -1;\\n            }\\n            \\n            // when no of tasks with same level is more than 1\\n            else{\\n\\n                // when no of tasks with same level is divisible by 3\\n                if(i.second%3 == 0){\\n                    rounds += (i.second/3);\\n                }\\n                \\n                // when no of tasks with same level is remaining 1 or 2 in last, will add 1 more to round\\n                else if(i.second%3 == 1 || i.second%3 == 2){\\n                    rounds += (i.second/3)+1;\\n                }\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997067,
                "title": "python-sol-beats-95-easy-to-understand",
                "content": "# Intuition\\nreturn -1 in case 1 in tasks\\nif not \\u2013 check the remainders of the division by 3\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        k = 0\\n        c = Counter(tasks).values()\\n        if 1 in c:\\n            return -1\\n        for j in c:\\n            k += j // 3 + bool(j % 3)\\n        return k\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        k = 0\\n        c = Counter(tasks).values()\\n        if 1 in c:\\n            return -1\\n        for j in c:\\n            k += j // 3 + bool(j % 3)\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996569,
                "title": "ruby-solution-3-lines",
                "content": "# Approach\\nFirstly, let\\'s check how many rounds the number of the same level tasks needs.\\n\\n![image.png](https://assets.leetcode.com/users/images/baf42dfb-5390-445e-bf44-4d425c67b3c0_1672817322.0993586.png)\\n\\nAs you can see, there is a pattern. If the number of the same level tasks is 1, it fails. If it is greater than 1, the necessary round can be found by adding 2 to it and dividing by 3. For example; if the total number of the same level tasks is `7`, the result is `(7 + 2) / 3 => 3`.\\n\\n# Code\\n```\\n# @param {Integer[]} tasks\\n# @return {Integer}\\ndef minimum_rounds(tasks)\\n  tasks_values = tasks.tally.values\\n\\n  return -1 if tasks_values.include? 1\\n\\n  tasks_values.sum { |val| (val + 2) / 3 }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} tasks\\n# @return {Integer}\\ndef minimum_rounds(tasks)\\n  tasks_values = tasks.tally.values\\n\\n  return -1 if tasks_values.include? 1\\n\\n  tasks_values.sum { |val| (val + 2) / 3 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2996562,
                "title": "c-easy-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\nthe first appraoch came in my mind was using linear time, i find it easy and solved it.\\n\\n# Approach\\nwe are storing the difficulty level of each tasks in map, then if it is divisible by 3 then simply add the quotient to count otherwise add quotient+1. return count.\\n\\n# Complexity\\n- Time complexity:\\nO(n) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int count=0;\\n        map <int,int> mp;\\n        for(int i:tasks){\\n            mp[i]++;\\n        }\\n        //for(auto it:mp){\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second!=0 && it.second%3==0){\\n                count+=(it.second/3);\\n            }\\n            else if(it.second!=0){\\n                count+=(it.second/3+1);\\n            }\\n           // cout<<count<<endl;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int count=0;\\n        map <int,int> mp;\\n        for(int i:tasks){\\n            mp[i]++;\\n        }\\n        //for(auto it:mp){\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second!=0 && it.second%3==0){\\n                count+=(it.second/3);\\n            }\\n            else if(it.second!=0){\\n                count+=(it.second/3+1);\\n            }\\n           // cout<<count<<endl;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2996431,
                "title": "java-simple-greedy-counting",
                "content": "# Intuition\\nCount frequencies of number. If you can divide by 3, then go for it because it will minimize the result. If you can\\'t then add +1 to the result of dividing by 3. If the frequency is 1 then return -1 because the problem states that we must take at least 2 elements at a time.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> numFreq = new HashMap<>();\\n        for (int x : tasks) {\\n            numFreq.put(x, numFreq.getOrDefault(x, 0) + 1);\\n        }\\n\\n        int rounds = 0;\\n        for (int freq : numFreq.values()) {\\n            if(freq < 2) return -1; // Can\\'t divide\\n            rounds += freq / 3;\\n            if(freq % 3 != 0) rounds++;\\n        }\\n\\n        return rounds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> numFreq = new HashMap<>();\\n        for (int x : tasks) {\\n            numFreq.put(x, numFreq.getOrDefault(x, 0) + 1);\\n        }\\n\\n        int rounds = 0;\\n        for (int freq : numFreq.values()) {\\n            if(freq < 2) return -1; // Can\\'t divide\\n            rounds += freq / 3;\\n            if(freq % 3 != 0) rounds++;\\n        }\\n\\n        return rounds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996311,
                "title": "java-5-solutions",
                "content": "# 5.counter + sort\\n```\\n    //5.counter + sort\\n    //Runtime: 15ms 95%; Memory: 84.6MB 60%\\n    //Time: O(N * logN); Space: O(logN)\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int count = 0, res = 0;\\n        for (int i = 0; i < tasks.length; i++) {\\n            count++;\\n            if (i == tasks.length - 1 || tasks[i] != tasks[i + 1]) {\\n                if (count == 1) return -1;\\n                res += count / 3;\\n                if (count % 3 != 0) res++;\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n# 4.counter\\n```\\n    //4.counter\\n    //Time: O(N); Space: O(N)\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int i = 0; i < tasks.length; i++)\\n            counter.put(tasks[i], counter.getOrDefault(tasks[i], 0) + 1);\\n\\n        int res = 0;\\n        for (Map.Entry<Integer,Integer> entry: counter.entrySet()){\\n            int count = entry.getValue();\\n            if (count <= 1) return -1;\\n            res += count / 3;\\n            if (count % 3 != 0) res++;\\n        }\\n        return res;\\n    }\\n```\\n# 3.DP bottom-up\\n```\\n    //3.DP bottom-up\\n    //Runtime: 28ms 93%; Memory: 83.6MB 62%\\n    //Time: O(N * logN + N); Space: O(logN)\\n    //Time: O(N * logN); Space: O(logN)\\n    public int minimumRounds_3(int[] tasks) {\\n        Arrays.sort(tasks);\\n\\n        int dp1 = Integer.MAX_VALUE, dp2 = 0, dp3 = 0;\\n        for (int i = tasks.length - 2; i >= 0; i--) {\\n            int tmp = Integer.MAX_VALUE;\\n\\n            if (tasks[i + 1] == tasks[i])\\n                tmp = Math.min(tmp, dp2);\\n\\n            if (i + 2 < tasks.length && tasks[i + 2] == tasks[i])\\n                tmp = Math.min(tmp, dp3);\\n\\n            dp3 = dp2;\\n            dp2 = dp1;\\n            dp1 = tmp == Integer.MAX_VALUE ? tmp : tmp + 1;\\n        }\\n        return dp1 == Integer.MAX_VALUE ? -1 : dp1;\\n    }\\n```\\n# 2.DP bottom-up\\n```\\n    //2.DP bottom-up\\n    //Runtime: 17ms 95%; Memory: 52.3MB 99%\\n    //Time: O(N * logN + N); Space: O(logN + N)\\n    //Time: O(N * logN); Space: O(N)\\n    public int minimumRounds_2(int[] tasks) {\\n        Arrays.sort(tasks);\\n\\n        int[] dp = new int[tasks.length + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[tasks.length] = 0;\\n\\n        for (int i = tasks.length - 2; i >= 0; i--) {\\n            if (tasks[i] != tasks[i + 1] ) continue;\\n\\n            if (tasks[i + 1] == tasks[i])\\n                dp[i] = Math.min(dp[i], dp[i + 2]);\\n            if (i + 2 < tasks.length && tasks[i + 2] == tasks[i])\\n                dp[i] = Math.min(dp[i], dp[i + 3]);\\n\\n            if (dp[i] != Integer.MAX_VALUE)\\n                dp[i] = dp[i] + 1;\\n        }\\n        return dp[0] == Integer.MAX_VALUE ? -1 : dp[0] ;\\n    }\\n```\\n# 1.recursion + memo\\n```\\n    //1.recursion + memo\\n    //Runtime: 28ms 93%; Memory: 58MB 75%\\n    //Time: O(N * logN + N); Space: O(logN + N)\\n    //Time: O(N * logN); Space: O(N)\\n    public int minimumRounds_1(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = helper(tasks ,0, new int[tasks.length]);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\n    private int helper(int[] tasks, int begin, int[] memo){\\n        if (begin >= tasks.length) return 0;\\n\\n        if (memo[begin] != 0) return memo[begin];\\n\\n        int res = Integer.MAX_VALUE;\\n        if (begin + 1 < tasks.length && tasks[begin + 1] == tasks[begin])\\n            res = Math.min(res, helper(tasks, begin + 2, memo));\\n        if (begin + 2 < tasks.length && tasks[begin + 2] == tasks[begin])\\n            res = Math.min(res, helper(tasks, begin + 3, memo));\\n\\n        return memo[begin] = res == Integer.MAX_VALUE ? res : res + 1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n    //5.counter + sort\\n    //Runtime: 15ms 95%; Memory: 84.6MB 60%\\n    //Time: O(N * logN); Space: O(logN)\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int count = 0, res = 0;\\n        for (int i = 0; i < tasks.length; i++) {\\n            count++;\\n            if (i == tasks.length - 1 || tasks[i] != tasks[i + 1]) {\\n                if (count == 1) return -1;\\n                res += count / 3;\\n                if (count % 3 != 0) res++;\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    //4.counter\\n    //Time: O(N); Space: O(N)\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int i = 0; i < tasks.length; i++)\\n            counter.put(tasks[i], counter.getOrDefault(tasks[i], 0) + 1);\\n\\n        int res = 0;\\n        for (Map.Entry<Integer,Integer> entry: counter.entrySet()){\\n            int count = entry.getValue();\\n            if (count <= 1) return -1;\\n            res += count / 3;\\n            if (count % 3 != 0) res++;\\n        }\\n        return res;\\n    }\\n```\n```\\n    //3.DP bottom-up\\n    //Runtime: 28ms 93%; Memory: 83.6MB 62%\\n    //Time: O(N * logN + N); Space: O(logN)\\n    //Time: O(N * logN); Space: O(logN)\\n    public int minimumRounds_3(int[] tasks) {\\n        Arrays.sort(tasks);\\n\\n        int dp1 = Integer.MAX_VALUE, dp2 = 0, dp3 = 0;\\n        for (int i = tasks.length - 2; i >= 0; i--) {\\n            int tmp = Integer.MAX_VALUE;\\n\\n            if (tasks[i + 1] == tasks[i])\\n                tmp = Math.min(tmp, dp2);\\n\\n            if (i + 2 < tasks.length && tasks[i + 2] == tasks[i])\\n                tmp = Math.min(tmp, dp3);\\n\\n            dp3 = dp2;\\n            dp2 = dp1;\\n            dp1 = tmp == Integer.MAX_VALUE ? tmp : tmp + 1;\\n        }\\n        return dp1 == Integer.MAX_VALUE ? -1 : dp1;\\n    }\\n```\n```\\n    //2.DP bottom-up\\n    //Runtime: 17ms 95%; Memory: 52.3MB 99%\\n    //Time: O(N * logN + N); Space: O(logN + N)\\n    //Time: O(N * logN); Space: O(N)\\n    public int minimumRounds_2(int[] tasks) {\\n        Arrays.sort(tasks);\\n\\n        int[] dp = new int[tasks.length + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[tasks.length] = 0;\\n\\n        for (int i = tasks.length - 2; i >= 0; i--) {\\n            if (tasks[i] != tasks[i + 1] ) continue;\\n\\n            if (tasks[i + 1] == tasks[i])\\n                dp[i] = Math.min(dp[i], dp[i + 2]);\\n            if (i + 2 < tasks.length && tasks[i + 2] == tasks[i])\\n                dp[i] = Math.min(dp[i], dp[i + 3]);\\n\\n            if (dp[i] != Integer.MAX_VALUE)\\n                dp[i] = dp[i] + 1;\\n        }\\n        return dp[0] == Integer.MAX_VALUE ? -1 : dp[0] ;\\n    }\\n```\n```\\n    //1.recursion + memo\\n    //Runtime: 28ms 93%; Memory: 58MB 75%\\n    //Time: O(N * logN + N); Space: O(logN + N)\\n    //Time: O(N * logN); Space: O(N)\\n    public int minimumRounds_1(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = helper(tasks ,0, new int[tasks.length]);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\n    private int helper(int[] tasks, int begin, int[] memo){\\n        if (begin >= tasks.length) return 0;\\n\\n        if (memo[begin] != 0) return memo[begin];\\n\\n        int res = Integer.MAX_VALUE;\\n        if (begin + 1 < tasks.length && tasks[begin + 1] == tasks[begin])\\n            res = Math.min(res, helper(tasks, begin + 2, memo));\\n        if (begin + 2 < tasks.length && tasks[begin + 2] == tasks[begin])\\n            res = Math.min(res, helper(tasks, begin + 3, memo));\\n\\n        return memo[begin] = res == Integer.MAX_VALUE ? res : res + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2996266,
                "title": "c-simple-solution-detailed-explanation",
                "content": "# Intuition\\nFirst we need to get frequency of each element as in each round, we can only do tasks with same value. We can either sort the numbers and then get their frequnecy or we can use a hashmap and get frequencies.\\n\\n# Approach\\n- If the freq (frequency) is 1, then we simply return -1 since it is not possible to remove 1 task only\\n- If the freq is 2, then we add 1 to total count since 2 elements can be removed in one go.\\n- If the freq is 3 then we add 1 to total count since 3 elements can be removed in one go.\\n- We see that we need minimum passes, so we will always try to remove 3 elements if possible rather than 2.\\n- If the freq is 4, we can remove 3 elements in one pass, for second pass we will have only 1 ele left and we will not be able to remove this. But if we remove 2 elements in first pass and 2 elments in second pass, then we can remove 4 elements in total 2 passes. The lesson from this example is that if `(freq % 3)` is 1, then we need to remove 2 elments each in 2 passes and, and the remaining `(freq - 4)` will now be multiple of 3 and can be removed in `(freq -4)/3` passes taking total to `(freq - 4)/3 + 2`.\\n- We can use if-else and do above process. Also all of this can be achieved by returning -1 in case of freq = 1 and `(freq + 2)/3` in all other cases. This will have less time complexity. \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m;\\n        int n = tasks.size();\\n        int ans = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(m.count(tasks[i]))\\n            {\\n                m[tasks[i]]++;\\n            }\\n            else{\\n                m.insert(pair(tasks[i],1));\\n            }\\n        }\\n\\n        for(auto it = m.begin(); it!= m.end(); it++)\\n        {\\n            int num = it->second;\\n            if(num == 1)\\n                return -1;\\n            if(num % 3 == 0)\\n            {\\n                ans += num/3;\\n            }\\n            else{\\n                if(num % 3 == 2)\\n                {\\n                    ans += (num/3 + 1);\\n                }\\n                else{   // remainder is 1 & num >=4\\n                    ans = ans + ((num -4)/3 + 2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> m;\\n        int n = tasks.size();\\n        int ans = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(m.count(tasks[i]))\\n            {\\n                m[tasks[i]]++;\\n            }\\n            else{\\n                m.insert(pair(tasks[i],1));\\n            }\\n        }\\n\\n        for(auto it = m.begin(); it!= m.end(); it++)\\n        {\\n            int num = it->second;\\n            if(num == 1)\\n                return -1;\\n            if(num % 3 == 0)\\n            {\\n                ans += num/3;\\n            }\\n            else{\\n                if(num % 3 == 2)\\n                {\\n                    ans += (num/3 + 1);\\n                }\\n                else{   // remainder is 1 & num >=4\\n                    ans = ans + ((num -4)/3 + 2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996137,
                "title": "c-2-approaches-greedy-approach-with-explanation-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf number of tasks with a difficulty is 1, only then it is not possible to complete all the tasks else we need to compute minimum rounds to complete tasks\\n\\nIn each round complete 3 tasks, till remaining tasks are more than 3.\\n\\nNow, when for remaining tasks there are 3 possibilities:\\n1. Remaining tasks = 0 \\n- We have our answer \\n(6 tasks at beginning, in 2 rounds all tasks are completed)\\n\\n---\\n\\n2. Remaining tasks = 1 \\n- Convert an already completed round of 3 tasks to 2 tasks. \\n- So now we have 2 tasks remaining which can be completed in 1 round of 2 tasks. \\n- Therefore add 1 more round to answer\\n\\n---\\n\\n3. Remaining tasks = 2\\n- 2 remaining tasks can be completed in 1 round of 2 tasks. \\n- Therefore add 1 more round to answer\\n\\n(I have used ceil function for these cases)\\n\\n# Approach 1\\nSort the tasks vector to group the tasks with same difficulties together\\n\\n# Complexity\\n- Time complexity:  $$O(nlogn)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ceil3(int curr)\\n    {\\n        return (curr/3)+(curr%3!=0);\\n    }\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        if(tasks.size()==1) return -1;\\n\\n        sort(tasks.begin(),tasks.end());\\n\\n        int n=tasks.size() , ans=0 , curr=1;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i==n || tasks[i]!=tasks[i-1])\\n            {\\n                if(curr==1) return -1;\\n                else ans+=ceil3(curr) , curr=1;\\n            } \\n            else\\n            {\\n                curr++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Approach 2\\nUse map to group tasks of same difficulties\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ceil3(int curr)\\n    {\\n        return (curr/3)+(curr%3!=0);\\n    }\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        if(tasks.size()==1) return -1;\\n        int n=tasks.size() , ans=0 ;\\n\\n        unordered_map<int,int>freq;\\n        for(int diff:tasks) freq[diff]++;\\n        \\n        for(auto [diff,count]:freq)\\n        {\\n            if(count==1) return -1;\\n            else ans+=ceil3(count) ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ceil3(int curr)\\n    {\\n        return (curr/3)+(curr%3!=0);\\n    }\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        if(tasks.size()==1) return -1;\\n\\n        sort(tasks.begin(),tasks.end());\\n\\n        int n=tasks.size() , ans=0 , curr=1;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i==n || tasks[i]!=tasks[i-1])\\n            {\\n                if(curr==1) return -1;\\n                else ans+=ceil3(curr) , curr=1;\\n            } \\n            else\\n            {\\n                curr++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int ceil3(int curr)\\n    {\\n        return (curr/3)+(curr%3!=0);\\n    }\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        if(tasks.size()==1) return -1;\\n        int n=tasks.size() , ans=0 ;\\n\\n        unordered_map<int,int>freq;\\n        for(int diff:tasks) freq[diff]++;\\n        \\n        for(auto [diff,count]:freq)\\n        {\\n            if(count==1) return -1;\\n            else ans+=ceil3(count) ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995559,
                "title": "ruby-1-liner",
                "content": "```\\ndef minimum_rounds(tasks)\\n\\n  tasks.tally.sum{ 1<_2 and (2+_2)/3 or return -1 }\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_rounds(tasks)\\n\\n  tasks.tally.sum{ 1<_2 and (2+_2)/3 or return -1 }\\n\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2995554,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Property to observe --> if the frequency of number is 1 then answer will be -1, but if frequency is divisible by 3 then we get ans as (frequency/3), else it will be (frequency/3) + 1.\\n2. Take few examples -->\\n   To reach 13 we can use 3 three\\'s and 2 two\\'s (most efficient), also to reach 17 most efficient way is to use 5 three\\'s and 1 two\\'s,this can be understood by taking few examples.\\n3. Now our tasks is to count frequency and if it is 1 then return -1 else we can count most efficient way to reach that value and add it to answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Hope You Understand!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ Using Map\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        map<int,int>mp;\\n        int ans=0;\\n        for(auto i:tasks)\\n        {\\n            mp[i]++;//Calculate frequency\\n        }\\n        for(auto i:mp)\\n        {\\n            if(i.second==1)\\n            return -1; // If frequency is 1 return -1\\n            while(i.second>0)\\n            {\\n                if(i.second%3==0)\\n                {\\n                    ans+=(i.second/3); // If multiple of 3\\n                    i.second=0;\\n                }\\n                else \\n                {\\n                    ans+=((i.second/3) +1); // If not multiple of 3\\n                    i.second=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        map<int,int>mp;\\n        int ans=0;\\n        for(auto i:tasks)\\n        {\\n            mp[i]++;//Calculate frequency\\n        }\\n        for(auto i:mp)\\n        {\\n            if(i.second==1)\\n            return -1; // If frequency is 1 return -1\\n            while(i.second>0)\\n            {\\n                if(i.second%3==0)\\n                {\\n                    ans+=(i.second/3); // If multiple of 3\\n                    i.second=0;\\n                }\\n                else \\n                {\\n                    ans+=((i.second/3) +1); // If not multiple of 3\\n                    i.second=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994788,
                "title": "c-o-n-using-some-linq",
                "content": "# Approach\\nWe can easily get element counts using LINQs GroupBy and Select. GroupBy generates an `IEnumerable` for each group key, with `.Select()` we can extract just the counts.\\nWe then process each of these counts.\\nIf `1` then we cant complete.\\nIf `count % 3 == 0` then we can complete the tasks in `count / 3` rounds\\nIf `count % 3 == 1` then we need 2 rounds of completing two tasks + `(count - 4) / 3` rounds of completing 3. `(count - 4)` since we completed 2 rounds of 2 tasks.\\nIf `count % 3 == 1` We need to do one round of two tasks + `(count - 2) / 3` of 3 tasks.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)` at most we have `n` groups and we need to check them all\\n\\n- Space complexity:\\n`O(n)` at most we store counts `n` groups\\n\\n# Code\\n``` CSharp\\npublic class Solution {\\n    public int MinimumRounds(int[] tasks) {\\n        var groups = tasks.GroupBy(t => t).Select(t => t.Count());\\n        var rounds = 0;\\n        foreach (var count in groups) {\\n            if (count == 1) return -1;\\n            rounds += (count % 3) switch {\\n                0 => count / 3,\\n                1 => 2 + (count - 4) / 3,\\n                2 => 1 + (count - 2) / 3\\n            };\\n        }\\n        return rounds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "``` CSharp\\npublic class Solution {\\n    public int MinimumRounds(int[] tasks) {\\n        var groups = tasks.GroupBy(t => t).Select(t => t.Count());\\n        var rounds = 0;\\n        foreach (var count in groups) {\\n            if (count == 1) return -1;\\n            rounds += (count % 3) switch {\\n                0 => count / 3,\\n                1 => 2 + (count - 4) / 3,\\n                2 => 1 + (count - 2) / 3\\n            };\\n        }\\n        return rounds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994715,
                "title": "easy-solution-with-explanation-c-o-n",
                "content": "\\nWe will keep the frequency (f) of each level in a map.\\nIf ```f == 1```, we can only complete either 2 or 3 tasks of the same level. Hence, no solution possible.\\n\\nIf ```f % 3 == 0```, then we can complete 3 tasks in every round which will be equal to ```f/3```.\\nIf ```f % 3 != 0```, then number of rounds will always be ```f/3 + 1```.\\n\\n# Complexity\\n- Time complexity:\\n*O(n)*\\n\\n- Space complexity:\\n*O(n)*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        for(int& task : tasks) mp[task]++;\\n        \\n        int ans = 0;        \\n        for(auto [_, freq] : mp)\\n        {\\n            if(freq == 1) return -1;\\n            ans += (freq % 3 == 0) ? freq/3 : freq/3 + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```f == 1```\n```f % 3 == 0```\n```f/3```\n```f % 3 != 0```\n```f/3 + 1```\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        for(int& task : tasks) mp[task]++;\\n        \\n        int ans = 0;        \\n        for(auto [_, freq] : mp)\\n        {\\n            if(freq == 1) return -1;\\n            ans += (freq % 3 == 0) ? freq/3 : freq/3 + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969673,
                "title": "python-easy-code-using-hashmap",
                "content": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        mp={}\\n        # storing frequency of each element in mp\\n        for i in tasks:\\n            if i in mp:\\n                mp[i]+=1\\n            else:\\n                mp[i]=1\\n        cnt=0\\n        for i in mp:\\n            f=0\\n            while mp[i]>3:\\n                mp[i]-=3\\n                f=1\\n                cnt+=1\\n            if mp[i]==2 or mp[i]==3:\\n                cnt+=1\\n            elif f==0:\\n                return -1\\n            else:\\n                cnt+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        mp={}\\n        # storing frequency of each element in mp\\n        for i in tasks:\\n            if i in mp:\\n                mp[i]+=1\\n            else:\\n                mp[i]=1\\n        cnt=0\\n        for i in mp:\\n            f=0\\n            while mp[i]>3:\\n                mp[i]-=3\\n                f=1\\n                cnt+=1\\n            if mp[i]==2 or mp[i]==3:\\n                cnt+=1\\n            elif f==0:\\n                return -1\\n            else:\\n                cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965957,
                "title": "c-simple-solution-unordered-map-easy-implementation",
                "content": "```\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(auto x:tasks) \\n            m[x]++;     //Storing all task one by one and increasing their frequency\\n        \\n        int ans=0;\\n        \\n        for(auto m1:m)\\n        {\\n            if(m1.second==1)\\n                return -1;          // If there is only one task we can dirctly return -1 because it will not be possible to complete task because we can complete either 2 or 3 of the same difficulty level.\\n            else if(m1.second%3==0)\\n                ans+=m1.second/3;   // if task of same diffuclty level is mutiple of 3 we can do 3 task in each round;\\n            else\\n            ans+=m1.second/3+1;     // Here we can take all the remaining case like if task of same difficulty level is 2 then it will add 1, if 4 or 5 then it will add 2 and so on.\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> m;\\n        \\n        for(auto x:tasks) \\n            m[x]++;     //Storing all task one by one and increasing their frequency\\n        \\n        int ans=0;\\n        \\n        for(auto m1:m)\\n        {\\n            if(m1.second==1)\\n                return -1;          // If there is only one task we can dirctly return -1 because it will not be possible to complete task because we can complete either 2 or 3 of the same difficulty level.\\n            else if(m1.second%3==0)\\n                ans+=m1.second/3;   // if task of same diffuclty level is mutiple of 3 we can do 3 task in each round;\\n            else\\n            ans+=m1.second/3+1;     // Here we can take all the remaining case like if task of same difficulty level is 2 then it will add 1, if 4 or 5 then it will add 2 and so on.\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1964309,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) we can use a map `m` to count the frequency of each value `x` of the input array `A`, then perform a linear scan to accumulate and memoize optimal solutions via linear bottom-up DP.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumRounds(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1 + (m[x] ?: 0)\\n        var dp = mutableListOf<Int>(INF, INF, 1, 1) // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        fun f(x: Int): Int {\\n            while (dp.size <= x) {\\n                var n = dp.size\\n                var a = dp[n - 2]\\n                var b = dp[n - 3]\\n                dp.add(1 + Math.min(a, b))\\n            }\\n            return dp[x]\\n        }\\n        var t = m.map{ (_, x) -> f(x) }.toList()\\n        if (t.any{ it == INF })\\n            return -1\\n        return t.sum()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumRounds = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1 + (m.get(x) || 0));\\n    let dp = [Infinity, Infinity, 1, 1]; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n    let f = x => {\\n        while (dp.length <= x) {\\n            let n = dp.length;\\n            let a = dp[n - 2],\\n                b = dp[n - 3];\\n            dp.push(1 + Math.min(a, b));\\n        }\\n        return dp[x];\\n    };\\n    let t = [...m].map(([_, cnt]) => cnt).map(x => f(x));\\n    if (t.some(x => x == Infinity))\\n        return -1;\\n    return _.sum(t);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumRounds(self, A: List[int], INF = float(\\'inf\\')) -> int:\\n        m = Counter(A)\\n        dp = [INF, INF, 1, 1] # \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        def f(x):\\n            while len(dp) <= x:\\n                n = len(dp)\\n                a = dp[n - 2]\\n                b = dp[n - 3]\\n                dp.append(1 + min(a, b))\\n            return dp[x]\\n        t = [f(x) for x in m.values()]\\n        if any(x == INF for x in t):\\n            return -1\\n        return sum(t)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn minimum_rounds(A: VI) -> i32 {\\n        let INF = 1000000007;\\n        let mut m = HashMap::new();\\n        let mut dp = vec![INF, INF, 1, 1]; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        for x in A {\\n            *m.entry(x).or_insert(0) += 1;\\n        }\\n        fn f(dp: &mut VI, x: i32) -> i32 {\\n            let x = x as usize;\\n            while dp.len() <= x {\\n                let n = dp.len();\\n                let a = dp[n - 2];\\n                let b = dp[n - 3];\\n                dp.push(1 + min(a, b));\\n            }\\n            dp[x]\\n        }\\n        let t: VI = m.into_values().map(|x| f(&mut dp, x)).collect();\\n        if t.iter().any(|&x| x == INF) { -1 } else { t.iter().sum() }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int minimumRounds(VI& A, int INF = 1e9 + 7, Map m = {}, VI t = {}) {\\n        for (auto x: A)\\n            ++m[x];\\n        VI dp{ INF, INF, 1, 1 }; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        auto f = [&](auto x) {\\n            while (dp.size() <= x) {\\n                int n = dp.size(),\\n                    a = dp[n - 2],\\n                    b = dp[n - 3];\\n                dp.push_back(1 + min(a, b));\\n            }\\n            return dp[x];\\n        };\\n        transform(m.begin(), m.end(), back_inserter(t), [&](auto& pair) {\\n            auto [_, x] = pair;\\n            return f(x);\\n        });\\n        if (any_of(t.begin(), t.end(), [=](auto x) { return x == INF; }))\\n            return -1;\\n        return accumulate(t.begin(), t.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumRounds(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1 + (m[x] ?: 0)\\n        var dp = mutableListOf<Int>(INF, INF, 1, 1) // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        fun f(x: Int): Int {\\n            while (dp.size <= x) {\\n                var n = dp.size\\n                var a = dp[n - 2]\\n                var b = dp[n - 3]\\n                dp.add(1 + Math.min(a, b))\\n            }\\n            return dp[x]\\n        }\\n        var t = m.map{ (_, x) -> f(x) }.toList()\\n        if (t.any{ it == INF })\\n            return -1\\n        return t.sum()!!\\n    }\\n}\\n```\n```\\nlet minimumRounds = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1 + (m.get(x) || 0));\\n    let dp = [Infinity, Infinity, 1, 1]; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n    let f = x => {\\n        while (dp.length <= x) {\\n            let n = dp.length;\\n            let a = dp[n - 2],\\n                b = dp[n - 3];\\n            dp.push(1 + Math.min(a, b));\\n        }\\n        return dp[x];\\n    };\\n    let t = [...m].map(([_, cnt]) => cnt).map(x => f(x));\\n    if (t.some(x => x == Infinity))\\n        return -1;\\n    return _.sum(t);\\n};\\n```\n```\\nclass Solution:\\n    def minimumRounds(self, A: List[int], INF = float(\\'inf\\')) -> int:\\n        m = Counter(A)\\n        dp = [INF, INF, 1, 1] # \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        def f(x):\\n            while len(dp) <= x:\\n                n = len(dp)\\n                a = dp[n - 2]\\n                b = dp[n - 3]\\n                dp.append(1 + min(a, b))\\n            return dp[x]\\n        t = [f(x) for x in m.values()]\\n        if any(x == INF for x in t):\\n            return -1\\n        return sum(t)\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn minimum_rounds(A: VI) -> i32 {\\n        let INF = 1000000007;\\n        let mut m = HashMap::new();\\n        let mut dp = vec![INF, INF, 1, 1]; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        for x in A {\\n            *m.entry(x).or_insert(0) += 1;\\n        }\\n        fn f(dp: &mut VI, x: i32) -> i32 {\\n            let x = x as usize;\\n            while dp.len() <= x {\\n                let n = dp.len();\\n                let a = dp[n - 2];\\n                let b = dp[n - 3];\\n                dp.push(1 + min(a, b));\\n            }\\n            dp[x]\\n        }\\n        let t: VI = m.into_values().map(|x| f(&mut dp, x)).collect();\\n        if t.iter().any(|&x| x == INF) { -1 } else { t.iter().sum() }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int minimumRounds(VI& A, int INF = 1e9 + 7, Map m = {}, VI t = {}) {\\n        for (auto x: A)\\n            ++m[x];\\n        VI dp{ INF, INF, 1, 1 }; // \\uD83D\\uDED1 base cases for 0, 1, 2, 3\\n        auto f = [&](auto x) {\\n            while (dp.size() <= x) {\\n                int n = dp.size(),\\n                    a = dp[n - 2],\\n                    b = dp[n - 3];\\n                dp.push_back(1 + min(a, b));\\n            }\\n            return dp[x];\\n        };\\n        transform(m.begin(), m.end(), back_inserter(t), [&](auto& pair) {\\n            auto [_, x] = pair;\\n            return f(x);\\n        });\\n        if (any_of(t.begin(), t.end(), [=](auto x) { return x == INF; }))\\n            return -1;\\n        return accumulate(t.begin(), t.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960289,
                "title": "100-beats-in-both-runtime-and-memory-c-o-n",
                "content": "If the frequency counter `freq` is exactly `1` then we can\\'t complete it. So we should return -1.\\nOtherwise, we can use this way : `3 tasks + 3 tasks + . . . + 2 tasks + 2 tasks`. That is a lot of times `3 tasks` and at most `2 times 2 tasks`. \\n(Think we don\\'t need to perform 2 tasks 3 times. Because in that situation we can complete 3 tasks in 2 times!!!)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> freq;\\n        for (auto &task : tasks) {\\n            freq[task]++;\\n        }\\n        int round = 0;\\n        for (auto &element : freq) {\\n            if (element.second == 1) return -1;\\n            round += (element.second + 2)/3;\\n        }\\n        return round;\\n    }\\n};\\n```\\n\\nHere I used `(element.second + 2)` to take ceil value after dividing by `3`.\\nYou can write it in another way like this:\\n```\\nround += element.second + (element.second%3 > 0? 1 : 0);\\n```\\n\\nFeel free to comment if this helps you or not.",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> freq;\\n        for (auto &task : tasks) {\\n            freq[task]++;\\n        }\\n        int round = 0;\\n        for (auto &element : freq) {\\n            if (element.second == 1) return -1;\\n            round += (element.second + 2)/3;\\n        }\\n        return round;\\n    }\\n};\\n```\n```\\nround += element.second + (element.second%3 > 0? 1 : 0);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958192,
                "title": "java-consise-6-liner",
                "content": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i:tasks) map.put(i,map.getOrDefault(i,0)+1);\\n        for(int i:map.values()){\\n            if(i == 1) return -1;\\n            if(i%3 == 0) res += i/3;\\n            else if((i-2) % 3 == 0) res += i/3 +1;\\n            else if(i%3 == 1) res += (i-4)/3 + 2;\\n            else if(i%2 == 0) res += i/2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res = 0;\\n        for(int i:tasks) map.put(i,map.getOrDefault(i,0)+1);\\n        for(int i:map.values()){\\n            if(i == 1) return -1;\\n            if(i%3 == 0) res += i/3;\\n            else if((i-2) % 3 == 0) res += i/3 +1;\\n            else if(i%3 == 1) res += (i-4)/3 + 2;\\n            else if(i%2 == 0) res += i/2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956025,
                "title": "easy-java-solution-hashmap",
                "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        \\n        for(int val:tasks){\\n            hm.put(val,hm.getOrDefault(val,0)+1);\\n        }\\n        \\n        int count=0;\\n        \\n        for(int key:hm.keySet()){\\n            \\n            if(hm.get(key)<2){\\n                return -1;\\n            }\\n            \\n            int freq=hm.get(key);\\n            \\n            if(freq%3==0){\\n                count+=(freq/3);\\n            }else{\\n                count+=(freq/3)+1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        \\n        for(int val:tasks){\\n            hm.put(val,hm.getOrDefault(val,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1955789,
                "title": "java-easy-implementation",
                "content": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i: tasks){\\n            if(map.containsKey(i)) map.put(i, map.get(i) +1);\\n            else map.put(i,1);\\n        }\\n        \\n        int count = 0;\\n        for(int freq: map.values()){\\n            if(freq>1){\\n                count += freq/3;\\n                if(freq%3 !=0)\\n                count++;  \\n            } else  return -1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i: tasks){\\n            if(map.containsKey(i)) map.put(i, map.get(i) +1);\\n            else map.put(i,1);\\n        }\\n        \\n        int count = 0;\\n        for(int freq: map.values()){\\n            if(freq>1){\\n                count += freq/3;\\n                if(freq%3 !=0)\\n                count++;  \\n            } else  return -1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955322,
                "title": "javascript-easy-to-understand-hashmap",
                "content": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    \\n    function solve(x, cnt) {   \\n        if (x == 0) {\\n            return 0;\\n        }\\n        \\n        if (x < 2) {\\n            return Number.MAX_VALUE;\\n        }\\n        \\n        if (cnt[x]) {\\n            return cnt[x];\\n        }\\n        \\n        let left = 1 + solve(x - 3, cnt);\\n        let right = 1 + solve(x - 2, cnt);\\n        \\n        cnt[x] = Math.min(left, right);\\n        return cnt[x];\\n    }\\n    \\n    let hash = {};\\n    for (let x of tasks) {\\n        hash[x] = hash[x] ? hash[x] + 1 : 1;\\n    }\\n    \\n    let ans = 0;\\n    for (let x of Object.values(hash)) {\\n        let temp = solve(x, {});\\n        if (temp == Number.MAX_VALUE) {\\n            ans = -1;\\n            break;\\n        } else {\\n            ans += temp;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    \\n    function solve(x, cnt) {   \\n        if (x == 0) {\\n            return 0;\\n        }\\n        \\n        if (x < 2) {\\n            return Number.MAX_VALUE;\\n        }\\n        \\n        if (cnt[x]) {\\n            return cnt[x];\\n        }\\n        \\n        let left = 1 + solve(x - 3, cnt);\\n        let right = 1 + solve(x - 2, cnt);\\n        \\n        cnt[x] = Math.min(left, right);\\n        return cnt[x];\\n    }\\n    \\n    let hash = {};\\n    for (let x of tasks) {\\n        hash[x] = hash[x] ? hash[x] + 1 : 1;\\n    }\\n    \\n    let ans = 0;\\n    for (let x of Object.values(hash)) {\\n        let temp = solve(x, {});\\n        if (temp == Number.MAX_VALUE) {\\n            ans = -1;\\n            break;\\n        } else {\\n            ans += temp;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955306,
                "title": "python-greedy-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        # idea: greedy\\n        # find as many 3 as possible\\n        \\n        counter = Counter(tasks)\\n        steps = 0\\n        \\n        for key, value in counter.items():\\n            cur_step = self.composedBy(value)\\n            \\n            if cur_step == -1:\\n                return -1\\n            else:\\n                steps += cur_step\\n        \\n        return steps\\n    \\n    # find as many 3 as possible\\n    # every time substract a 2 form the num and mod by 3\\n    def composedBy(self, num):\\n        final_step = -1\\n        tmp_step = 0\\n        \\n        while num > 0:\\n            if num % 3 == 0:\\n                final_step = num // 3 + tmp_step\\n                return final_step\\n            \\n            else:\\n                num -= 2\\n                tmp_step += 1\\n        \\n        if num == 0:\\n            return tmp_step\\n        else:\\n            return final_step\\n                \\n                \\n                \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        # idea: greedy\\n        # find as many 3 as possible\\n        \\n        counter = Counter(tasks)\\n        steps = 0\\n        \\n        for key, value in counter.items():\\n            cur_step = self.composedBy(value)\\n            \\n            if cur_step == -1:\\n                return -1\\n            else:\\n                steps += cur_step\\n        \\n        return steps\\n    \\n    # find as many 3 as possible\\n    # every time substract a 2 form the num and mod by 3\\n    def composedBy(self, num):\\n        final_step = -1\\n        tmp_step = 0\\n        \\n        while num > 0:\\n            if num % 3 == 0:\\n                final_step = num // 3 + tmp_step\\n                return final_step\\n            \\n            else:\\n                num -= 2\\n                tmp_step += 1\\n        \\n        if num == 0:\\n            return tmp_step\\n        else:\\n            return final_step\\n                \\n                \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1955304,
                "title": "python-hashmap",
                "content": "**TC:** `O(n)`\\n**SC:** `O(n)`\\n```\\ndef minimumRounds(self, tasks: List[int]) -> int:\\n    d = Counter(tasks)\\n    res = 0 \\n    for i in d:\\n        n = d[i] \\n        if n<=1:\\n            return -1\\n        res += math.ceil(n/3)\\n    return res\\n```\\n\\nPLZ, PLZ **UPVOTE  GUYS!!**",
                "solutionTags": [],
                "code": "```\\ndef minimumRounds(self, tasks: List[int]) -> int:\\n    d = Counter(tasks)\\n    res = 0 \\n    for i in d:\\n        n = d[i] \\n        if n<=1:\\n            return -1\\n        res += math.ceil(n/3)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3620358,
                "title": "beginner-friendly-explained-step-by-step-with-example",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n -  FIrst Store all the elements as key and their frequency as value in hashmap\\n - now iterate over hashmap , if you find any element which has frequency equals to 1 , we can\\'t complete that task because only 2 and 3 tasks allowed to complete.\\n - now for frequency greater than 1, since we need to return minimum rounds so we try to divide it by 3 if it is fully divisible by 3 then all quotient of it to our result --- and if it\\'s not complety divisible by 3 then we just add 1 to quotient because the remainder left by dividing by 3 will be occupied by presence of 2.\\n\\n# Example\\n\\n- 12---->completey divisible by 3 hence just add quotient [3,3,3,3]\\n- 13---->not  completey divisible by 3 hence just add quotient+1 [3,3,3,2,2]\\n- 14--->>not  completey divisible by 3 hence just add quotient+1 [3,3,3,3,2]\\n- 15---> completey divisible by 3 hence just add quotient [3,3,3,3,3]\\n\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n \\n\\n- Space complexity:\\n O(n)----for unordered_hashmap \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        int res=0;\\n        unordered_map<int,int>helper;\\n        for(auto i:tasks)\\n        {\\n            helper[i]++;\\n        }\\n        for(auto i:helper)\\n        {\\n            if(i.second==1)\\n            {\\n              return -1;\\n            }\\n            if(i.second%3==0)\\n            {\\n                res+=(i.second/3);\\n            }\\n            else\\n            {\\n                res=res+(i.second/3)+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        int res=0;\\n        unordered_map<int,int>helper;\\n        for(auto i:tasks)\\n        {\\n            helper[i]++;\\n        }\\n        for(auto i:helper)\\n        {\\n            if(i.second==1)\\n            {\\n              return -1;\\n            }\\n            if(i.second%3==0)\\n            {\\n                res+=(i.second/3);\\n            }\\n            else\\n            {\\n                res=res+(i.second/3)+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582124,
                "title": "dead-easy-detailed-description-for-dp-noob",
                "content": "\\n# Approach\\nPlease upvote\\n\\nEach time we can choose only one difficulty level.\\nLets say difficulty level X appeared K times. \\nWe need to take M rounds to finish X task which appeared K times.\\nIn each of the M rounds, we can take either 2 or 3 totalling K.\\nSo, \\nK=2x+3y where x+y=M\\nIn x rounds we collect 2 tasks, in y rounds we collect 3 tasks. Total we collect K tasks of a particular level. \\n\\nSolution: We will precompute the least number of rounds required to complete K tasks regardless of the difficulty level.\\n\\nEach difficulty level can come in the range 1-10^5\\nIf it comes only once, we cant collect the task since we can collect only 2 at a time or 3 at a time. So if a task comes only once, we return -1.\\n\\nDp definition:\\ndp[i]= least numbe of rounds required to collect a tasks of a particular difficulty level that appeard i times\\n\\nThe base conditions are:\\ndp[1]=-1\\ndp[2]=1\\ndp[3]=1\\ndp[4]=2\\n\\nDP expression:\\nfor(i=5 to 10^5)\\ndp[i]= Math.min(dp[i-2],dp[i-3])+1;\\nWe take minimum of number of rounds required to collect i-2 tasks and number of rounds rquired to collect i-3 tasks. Then we add 1 which is collecting the left over 2 or 3 tasks respectively. \\n\\nSummary:\\n1) Precompute least number of rounds required for any tasks which comes K times (k ranging from 1 to 10^5)\\n2) Use a hashmap <Task_difficulty, number_of_times_it_appeared> \\n3) Iterate over hashmap\\n    3.1) get the value for each Entry which denotes the count\\n    3.2) get the least number of rounds required for the value from the dp \\n    3.3) add it to the answer\\n    3.4) return -1 if count is 1\\n4) return ans\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nN-> for calculating dp array\\nN-> for iterating to create the hashmap\\nN-> for iterating over hashmap to calculate answer\\nO(n)\\n\\n- Space complexity:\\nN-> for HashMap\\nN-> for DP array\\nO(n)\\n\\nPlease upvote\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int n=tasks.length;\\n        HashMap<Integer,Integer>hm=new HashMap();\\n        for(int i:tasks)\\n            hm.merge(i,1,(v1,v2)->v2=v1+1);\\n        int[] dp=new int[100001];\\n        //base conditions\\n        dp[1]=-1;\\n        dp[2]=1;\\n        dp[3]=1;\\n        dp[4]=2;\\n        for(int i=5;i<=100000;i++)\\n            dp[i]=Math.min(dp[i-2],dp[i-3])+1;\\n        int ans=0;\\n        for(Map.Entry<Integer,Integer>entry:hm.entrySet()){\\n            int count=entry.getValue();\\n            if(count==1)\\n                return -1;\\n            ans+=dp[count];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int n=tasks.length;\\n        HashMap<Integer,Integer>hm=new HashMap();\\n        for(int i:tasks)\\n            hm.merge(i,1,(v1,v2)->v2=v1+1);\\n        int[] dp=new int[100001];\\n        //base conditions\\n        dp[1]=-1;\\n        dp[2]=1;\\n        dp[3]=1;\\n        dp[4]=2;\\n        for(int i=5;i<=100000;i++)\\n            dp[i]=Math.min(dp[i-2],dp[i-3])+1;\\n        int ans=0;\\n        for(Map.Entry<Integer,Integer>entry:hm.entrySet()){\\n            int count=entry.getValue();\\n            if(count==1)\\n                return -1;\\n            ans+=dp[count];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119693,
                "title": "simple-and-easy",
                "content": "cou# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        int n=tasks.size();\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto itr:mp){\\n            if(itr.second==1){\\n                return -1;\\n            }\\n            count+=itr.second/3;\\n            if(itr.second%3!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        int n=tasks.size();\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto itr:mp){\\n            if(itr.second==1){\\n                return -1;\\n            }\\n            count+=itr.second/3;\\n            if(itr.second%3!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008903,
                "title": "8-line-c-solution-using-maps",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<tasks.size();i++)  m[tasks[i]]++;\\n        int op=0;bool f=0;\\n        for(auto i:m){\\n            if(i.second==1) f=1;\\n            else op+=ceil(i.second/3.0);\\n        }\\n        return f?-1:op;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<tasks.size();i++)  m[tasks[i]]++;\\n        int op=0;bool f=0;\\n        for(auto i:m){\\n            if(i.second==1) f=1;\\n            else op+=ceil(i.second/3.0);\\n        }\\n        return f?-1:op;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999937,
                "title": "c-solution-daily-challenge",
                "content": "Runtime: 732 ms, faster than 5.73% of C++ online submissions for Minimum Rounds to Complete All Tasks.\\nMemory Usage: 104.6 MB, less than 24.39% of C++ online submissions for Minimum Rounds to \\nComplete\\n\\n\\n        int n=tasks.size();\\n        int count=0;\\n        map<int,int>Map;\\n        for(int i=0;i<n;i++)\\n            Map[tasks[i]]++;\\n        \\n         for(auto i:Map){\\n             if(i.second==1){\\n                 return -1;\\n             }\\n         }\\n        \\n        for(auto i:Map){\\n            cout<<i.first<<\"->\"<<i.second<<\"  \";\\n        }\\n        \\n        for(auto i:Map){\\n            int l=i.second;\\n            while(l>=2){\\n          if(l==2||l==3){\\n              count+=1;\\n              l=0;\\n          }else if(l==4||l==5){\\n              count+=2;\\n              l=0;\\n          }else{\\n              count=count+(l/3);\\n              l=l%3;\\n          }\\n            }\\n            if(l!=0){\\n                count+=1;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "Runtime: 732 ms, faster than 5.73% of C++ online submissions for Minimum Rounds to Complete All Tasks.\\nMemory Usage: 104.6 MB, less than 24.39% of C++ online submissions for Minimum Rounds to \\nComplete\\n\\n\\n        int n=tasks.size();\\n        int count=0;\\n        map<int,int>Map;\\n        for(int i=0;i<n;i++)\\n            Map[tasks[i]]++;\\n        \\n         for(auto i:Map){\\n             if(i.second==1){\\n                 return -1;\\n             }\\n         }\\n        \\n        for(auto i:Map){\\n            cout<<i.first<<\"->\"<<i.second<<\"  \";\\n        }\\n        \\n        for(auto i:Map){\\n            int l=i.second;\\n            while(l>=2){\\n          if(l==2||l==3){\\n              count+=1;\\n              l=0;\\n          }else if(l==4||l==5){\\n              count+=2;\\n              l=0;\\n          }else{\\n              count=count+(l/3);\\n              l=l%3;\\n          }\\n            }\\n            if(l!=0){\\n                count+=1;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2999738,
                "title": "short-code-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing Hashmap\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count = 0; HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int x : tasks)\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        for(int x : map.keySet())\\n            if(map.get(x)==1)return -1;\\n            else{\\n                count+=map.get(x)/3;\\n                if(map.get(x)%3!=0)count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count = 0; HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int x : tasks)\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        for(int x : map.keySet())\\n            if(map.get(x)==1)return -1;\\n            else{\\n                count+=map.get(x)/3;\\n                if(map.get(x)%3!=0)count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999360,
                "title": "using-simple-math-and-frequency-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the minimun number of rounds in which we can complete each task of same difficulty in either *2 tasks per round or 3 tasks per round*\\nnow any number N greater than 1 can be written in the form:\\n<c>    N = 2 * x + 3 * y; </c>\\nformally, any number *greater than 1* can be written as a sum of multiples of 2 and 3.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo the only time we will not be able to do a task in 2 or 3 rounds is then there is only 1 task of that difficulty.\\nSo, we create a frequency map of the various difficulties of the task and check if any of them occurs only once, if there is a task we return -1.\\nOtherwise, since we have to find the minimun number of rounds, we will try and do it same difficulty tasks in sets of 3 and then 2.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n = tasks.size();\\n        map<int, int> mpp;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mpp[tasks[i]]++;\\n        }\\n\\n        int numberOfRounds = 0;\\n\\n        for(auto it = mpp.begin(); it != mpp.end(); it++) {\\n            if(it -> second == 1) {\\n                return -1;\\n            }  // frequency of a task is 1, return -1.\\n\\n            int freq = it -> second;\\n\\n            if(freq % 3 == 2) {\\n                numberOfRounds += freq / 3 + 1;\\n            }   // we can do max freq/3 number of rounds of 3 and then we have to make 1 set of 2.\\n            else if(freq % 3 == 1) {\\n                numberOfRounds += (freq - 4) / 3 + 2;\\n            }   // we will make 2 sets of 2 and then remaining of them will be in sets of 3\\n            else {\\n                numberOfRounds += freq / 3;\\n            }   // min number of rounds = val / 3\\n        }\\n        return numberOfRounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n = tasks.size();\\n        map<int, int> mpp;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mpp[tasks[i]]++;\\n        }\\n\\n        int numberOfRounds = 0;\\n\\n        for(auto it = mpp.begin(); it != mpp.end(); it++) {\\n            if(it -> second == 1) {\\n                return -1;\\n            }  // frequency of a task is 1, return -1.\\n\\n            int freq = it -> second;\\n\\n            if(freq % 3 == 2) {\\n                numberOfRounds += freq / 3 + 1;\\n            }   // we can do max freq/3 number of rounds of 3 and then we have to make 1 set of 2.\\n            else if(freq % 3 == 1) {\\n                numberOfRounds += (freq - 4) / 3 + 2;\\n            }   // we will make 2 sets of 2 and then remaining of them will be in sets of 3\\n            else {\\n                numberOfRounds += freq / 3;\\n            }   // min number of rounds = val / 3\\n        }\\n        return numberOfRounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999296,
                "title": "using-ceil-function",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        map<int,int>m;\\n        for(int i = 0 ; i < tasks.size() ; i++){\\n            m[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(i.second<2) return -1;\\n            else{\\n                float gg=i.second;\\n                gg = ceil(gg/3);\\n                \\n                count+=gg;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        map<int,int>m;\\n        for(int i = 0 ; i < tasks.size() ; i++){\\n            m[tasks[i]]++;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(i.second<2) return -1;\\n            else{\\n                float gg=i.second;\\n                gg = ceil(gg/3);\\n                \\n                count+=gg;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999188,
                "title": "simple-and-easy-to-understand-code-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n \\n\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<tasks.size();i++){\\n            m[tasks[i]]++;\\n        }\\n        int sum =0;\\n        for(auto it : m){\\n            if(it.second == 1){\\n                return -1;\\n            }\\n            else if(it.second % 3 == 0){\\n                sum += (it.second/3);\\n            }\\n            else{\\n                sum += ( (it.second/3) + 1 );\\n            }\\n\\n        }\\n        return sum;\\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// class Solution {\\n// public:\\n\\n//     int count(int n){\\n//         int times =0;\\n//         while( (n!=4) || (n!=1) || (n!=0) ){\\n//             n -= 3;\\n//             times++;\\n            \\n//         }\\n//         while((n%2 ==0 ) && n>0){\\n//             n=n-2;\\n//             times++;\\n//         }\\n//         if(n==1){\\n//             return -1;\\n//         }\\n//         else{\\n//             return times;\\n//         }\\n//     }\\n\\n//     int minimumRounds(vector<int>& tasks) {\\n//         map<int,int>m;\\n//         for(int i=0;i<tasks.size();i++){\\n//             m[tasks[i]]++;\\n//         }\\n//         int sum =0;\\n//         for(auto it : m){\\n//             int ans = count(it.second);\\n//             if(ans ==-1) return -1;\\n//             else{\\n//                 sum = sum + ans;\\n//             }\\n\\n//         }\\n//         return sum;\\n\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n \\n\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<tasks.size();i++){\\n            m[tasks[i]]++;\\n        }\\n        int sum =0;\\n        for(auto it : m){\\n            if(it.second == 1){\\n                return -1;\\n            }\\n            else if(it.second % 3 == 0){\\n                sum += (it.second/3);\\n            }\\n            else{\\n                sum += ( (it.second/3) + 1 );\\n            }\\n\\n        }\\n        return sum;\\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// class Solution {\\n// public:\\n\\n//     int count(int n){\\n//         int times =0;\\n//         while( (n!=4) || (n!=1) || (n!=0) ){\\n//             n -= 3;\\n//             times++;\\n            \\n//         }\\n//         while((n%2 ==0 ) && n>0){\\n//             n=n-2;\\n//             times++;\\n//         }\\n//         if(n==1){\\n//             return -1;\\n//         }\\n//         else{\\n//             return times;\\n//         }\\n//     }\\n\\n//     int minimumRounds(vector<int>& tasks) {\\n//         map<int,int>m;\\n//         for(int i=0;i<tasks.size();i++){\\n//             m[tasks[i]]++;\\n//         }\\n//         int sum =0;\\n//         for(auto it : m){\\n//             int ans = count(it.second);\\n//             if(ans ==-1) return -1;\\n//             else{\\n//                 sum = sum + ans;\\n//             }\\n\\n//         }\\n//         return sum;\\n\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999082,
                "title": "easy-understanding-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minimumRounds(vector<int>& v) {\\n        ll n = v.size();\\n        map<ll,ll> m;\\n        for(ll i=0;i<n;i++){\\n            m[v[i]]++;\\n        }\\n        ll flag = 0,count = 0;\\n        for(auto i:m){\\n            if(i.second < 2){\\n               return -1;\\n            }else{\\n                while(i.second>1){\\n                    if(i.second%3==0){\\n                        i.second -= 3;\\n                        count++;\\n                    }else if(i.second%2==0){\\n                        i.second -= 2;\\n                        count++;\\n                    }else {i.second-=3;count++;}\\n                }\\n            }\\n        }\\n        return\\xA0count;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minimumRounds(vector<int>& v) {\\n        ll n = v.size();\\n        map<ll,ll> m;\\n        for(ll i=0;i<n;i++){\\n            m[v[i]]++;\\n        }\\n        ll flag = 0,count = 0;\\n        for(auto i:m){\\n            if(i.second < 2){\\n               return -1;\\n            }else{\\n                while(i.second>1){\\n                    if(i.second%3==0){\\n                        i.second -= 3;\\n                        count++;\\n                    }else if(i.second%2==0){\\n                        i.second -= 2;\\n                        count++;\\n                    }else {i.second-=3;count++;}\\n                }\\n            }\\n        }\\n        return\\xA0count;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998958,
                "title": "go-simple-solution",
                "content": "# Code\\n```\\nfunc minimumRounds(tasks []int) int {\\n\\tans := 0\\n\\tmp := map[int]int{}\\n\\tfor _, v := range tasks {mp[v]++}\\n\\tfor _, v := range mp {\\n\\t\\tif v == 1 {return -1}\\n\\t\\tans += int(math.Ceil(float64(v)/3.0))\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumRounds(tasks []int) int {\\n\\tans := 0\\n\\tmp := map[int]int{}\\n\\tfor _, v := range tasks {mp[v]++}\\n\\tfor _, v := range mp {\\n\\t\\tif v == 1 {return -1}\\n\\t\\tans += int(math.Ceil(float64(v)/3.0))\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998604,
                "title": "javascript-dp-o-n",
                "content": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    \\n    const mem = [];\\n    \\n    const get = (n) => {\\n        if(mem[n] != undefined) return mem[n];\\n        if(n < 0) return Infinity;\\n        if(n === 0) return 0;\\n        \\n        const ans = 1 + Math.min(get(n - 2), get(n - 3));\\n        \\n        mem[n] = ans;\\n        return ans;\\n    }\\n    \\n    let ans = 0;\\n    \\n    const map = new Map();\\n    for(const t of tasks) {\\n        map.set(t, (map.get(t) ||\\xA00) + 1);\\n    }\\n    \\n    for(const n of map.values()) {\\n        const val = get(n);\\n        if(val === Infinity) return -1;\\n        ans += val;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    \\n    const mem = [];\\n    \\n    const get = (n) => {\\n        if(mem[n] != undefined) return mem[n];\\n        if(n < 0) return Infinity;\\n        if(n === 0) return 0;\\n        \\n        const ans = 1 + Math.min(get(n - 2), get(n - 3));\\n        \\n        mem[n] = ans;\\n        return ans;\\n    }\\n    \\n    let ans = 0;\\n    \\n    const map = new Map();\\n    for(const t of tasks) {\\n        map.set(t, (map.get(t) ||\\xA00) + 1);\\n    }\\n    \\n    for(const n of map.values()) {\\n        const val = get(n);\\n        if(val === Infinity) return -1;\\n        ans += val;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998462,
                "title": "easy-approach-c-map",
                "content": "# Intuition\\n\\n\\n# Approach\\n-Store in map\\n\\n-Simply compare if it is divisble by 3 or not(in three way)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& num) {\\n        map<int, int> mp;\\n        int cnt=0;\\n        for(int i=0; i<num.size(); i++)\\n            mp[num[i]]++; \\n        for (auto i : mp)\\n        {\\n             // CASE 1// \\n            if(i.second==1) return -1;\\n            // CASE 2// \\n            else if((i.second)%3==0)\\n                 cnt += i.second/3;\\n            // CASE 3 //\\n            else if((i.second)%3==1)\\n            {\\n                cnt += (i.second-4)/3;\\n                cnt += 2;\\n            }\\n            // CASE 4//\\n            else if((i.second)%3==2)\\n            {\\n                cnt += (i.second-2)/3;\\n                cnt++;\\n            }\\n        }      \\n    return cnt;\\n }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& num) {\\n        map<int, int> mp;\\n        int cnt=0;\\n        for(int i=0; i<num.size(); i++)\\n            mp[num[i]]++; \\n        for (auto i : mp)\\n        {\\n             // CASE 1// \\n            if(i.second==1) return -1;\\n            // CASE 2// \\n            else if((i.second)%3==0)\\n                 cnt += i.second/3;\\n            // CASE 3 //\\n            else if((i.second)%3==1)\\n            {\\n                cnt += (i.second-4)/3;\\n                cnt += 2;\\n            }\\n            // CASE 4//\\n            else if((i.second)%3==2)\\n            {\\n                cnt += (i.second-2)/3;\\n                cnt++;\\n            }\\n        }      \\n    return cnt;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998451,
                "title": "java-c-100-solution-with-two-approachs-minimum-rounds-to-complete-all-tasks",
                "content": "- # Hashing Approach \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer> hash = new HashMap<>();\\n        int ans = 0;\\n\\n        for(int x:tasks)\\n            hash.put(x,hash.getOrDefault(x,0)+1);\\n        \\n        for (Map.Entry<Integer, Integer> me : hash.entrySet()) {\\n            int x = me.getValue();\\n            if(x==1)\\n                return -1;\\n            if (x % 3 == 0) \\n                ans += x / 3;\\n            else if (x % 3 == 2) \\n                ans += (x - 2) / 3 + 1;\\n            else\\n                ans += (x - 4) / 3 + 2;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> hash;\\n        int ans = 0;\\n\\n        for(auto x:tasks)\\n            hash[x]++;\\n        \\n        for (auto asd : hash) {\\n            int x = asd.second;\\n            if(x==1)\\n                return -1;\\n            if (x % 3 == 0) \\n                ans += x / 3;\\n            else if (x % 3 == 2) \\n                ans += (x - 2) / 3 + 1;\\n            else\\n                ans += (x - 4) / 3 + 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n- # Sorting Approach \\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Java Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = 0;\\n        for (int i = 0; i < tasks.length;) {\\n            int j = i + 1;\\n            while (j < tasks.length && tasks[j] == tasks[i])\\n                j++;\\n            if (j == i + 1)\\n                return -1;\\n            res += compute(j - i);\\n            i = j;\\n        }\\n        return res; \\n    }\\n\\n    private int compute(int i) {\\n        if (i % 3 == 0)\\n            return i / 3;\\n        if (i % 3 == 2)\\n            return (i - 2) / 3 + 1;\\n        return (i - 4) / 3 + 2;\\n    }\\n}\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int compute(int i) {\\n        if (i % 3 == 0)\\n            return i / 3;\\n        if (i % 3 == 2)\\n            return (i - 2) / 3 + 1;\\n        return (i - 4) / 3 + 2;\\n    }\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        int ans = 0;\\n        for (int i = 0; i < tasks.size();) {\\n            int j = i + 1;\\n            while (j < tasks.size() && tasks[j] == tasks[i])\\n                j++;\\n            if (j == i + 1) \\n                return -1;\\n            ans += compute(j - i);\\n            i = j;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer> hash = new HashMap<>();\\n        int ans = 0;\\n\\n        for(int x:tasks)\\n            hash.put(x,hash.getOrDefault(x,0)+1);\\n        \\n        for (Map.Entry<Integer, Integer> me : hash.entrySet()) {\\n            int x = me.getValue();\\n            if(x==1)\\n                return -1;\\n            if (x % 3 == 0) \\n                ans += x / 3;\\n            else if (x % 3 == 2) \\n                ans += (x - 2) / 3 + 1;\\n            else\\n                ans += (x - 4) / 3 + 2;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> hash;\\n        int ans = 0;\\n\\n        for(auto x:tasks)\\n            hash[x]++;\\n        \\n        for (auto asd : hash) {\\n            int x = asd.second;\\n            if(x==1)\\n                return -1;\\n            if (x % 3 == 0) \\n                ans += x / 3;\\n            else if (x % 3 == 2) \\n                ans += (x - 2) / 3 + 1;\\n            else\\n                ans += (x - 4) / 3 + 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int res = 0;\\n        for (int i = 0; i < tasks.length;) {\\n            int j = i + 1;\\n            while (j < tasks.length && tasks[j] == tasks[i])\\n                j++;\\n            if (j == i + 1)\\n                return -1;\\n            res += compute(j - i);\\n            i = j;\\n        }\\n        return res; \\n    }\\n\\n    private int compute(int i) {\\n        if (i % 3 == 0)\\n            return i / 3;\\n        if (i % 3 == 2)\\n            return (i - 2) / 3 + 1;\\n        return (i - 4) / 3 + 2;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int compute(int i) {\\n        if (i % 3 == 0)\\n            return i / 3;\\n        if (i % 3 == 2)\\n            return (i - 2) / 3 + 1;\\n        return (i - 4) / 3 + 2;\\n    }\\n    int minimumRounds(vector<int>& tasks) {\\n        sort(tasks.begin(),tasks.end());\\n        int ans = 0;\\n        for (int i = 0; i < tasks.size();) {\\n            int j = i + 1;\\n            while (j < tasks.size() && tasks[j] == tasks[i])\\n                j++;\\n            if (j == i + 1) \\n                return -1;\\n            ans += compute(j - i);\\n            i = j;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998041,
                "title": "clean-go-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc minimumRounds(tasks []int) int {\\n    frequency := make(map[int]int)\\n    rounds := 0\\n\\n    for _, difficulty := range tasks {\\n        frequency[difficulty]++\\n    }\\n\\n    for _, count := range frequency {\\n        if count < 2 {\\n            return -1\\n        }\\n\\n        rounds += count / 3\\n\\n        if count % 3 > 0 {\\n            rounds++\\n        }\\n    }\\n\\n    return rounds\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumRounds(tasks []int) int {\\n    frequency := make(map[int]int)\\n    rounds := 0\\n\\n    for _, difficulty := range tasks {\\n        frequency[difficulty]++\\n    }\\n\\n    for _, count := range frequency {\\n        if count < 2 {\\n            return -1\\n        }\\n\\n        rounds += count / 3\\n\\n        if count % 3 > 0 {\\n            rounds++\\n        }\\n    }\\n\\n    return rounds\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997980,
                "title": "c-easy-to-understand-easy-to-code-array-map",
                "content": "# Please upvote if you like this solution.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)  --> For map operation.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nint minimumRounds(vector<int> &tasks)\\n{\\n    unordered_map<int, int> mp;\\n\\n    for (int i = 0; i < tasks.size(); i++)\\n    {\\n        mp[tasks[i]]++;\\n    }\\n\\n    int count = 0;\\n\\n    for (auto element : mp)\\n    {\\n        if (element.second < 2)\\n        {\\n            return -1;\\n        }\\n\\n        else if (element.second % 3 == 0)\\n        {\\n            count += (element.second / 3);\\n        }\\n\\n        else\\n        {\\n            count += (element.second) / 3 + 1;\\n        }\\n    }\\n    return count;\\n}\\n```\\n![tp.png](https://assets.leetcode.com/users/images/cc759ec9-9dad-4dfd-8518-8a03f8a3054b_1672837424.4885995.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Suffix Array"
                ],
                "code": "```\\nint minimumRounds(vector<int> &tasks)\\n{\\n    unordered_map<int, int> mp;\\n\\n    for (int i = 0; i < tasks.size(); i++)\\n    {\\n        mp[tasks[i]]++;\\n    }\\n\\n    int count = 0;\\n\\n    for (auto element : mp)\\n    {\\n        if (element.second < 2)\\n        {\\n            return -1;\\n        }\\n\\n        else if (element.second % 3 == 0)\\n        {\\n            count += (element.second / 3);\\n        }\\n\\n        else\\n        {\\n            count += (element.second) / 3 + 1;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997940,
                "title": "java-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count=0;\\n        Map<Integer,Integer> maplist=new HashMap<Integer,Integer>();\\n        for(int a:tasks)  maplist.put(a,maplist.getOrDefault(a,0)+1);\\n        Set<Integer> setlist=maplist.keySet();\\n        for(int key:setlist){\\n            int number=maplist.get(key);\\n            int i=0;\\n            while(true){\\n                if((number-3*i)<0){\\n                    if(number%2==0){\\n                         count+=(number/2);\\n                    }else return -1;\\n                }\\n                int rem=(number-3*i)/3;\\n                int rem1=number-3*rem;\\n                if(rem1%2==0){\\n                   count+=rem;\\n                   count+=(rem1)/2;  \\n                   break;\\n                }\\n                i++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        int count=0;\\n        Map<Integer,Integer> maplist=new HashMap<Integer,Integer>();\\n        for(int a:tasks)  maplist.put(a,maplist.getOrDefault(a,0)+1);\\n        Set<Integer> setlist=maplist.keySet();\\n        for(int key:setlist){\\n            int number=maplist.get(key);\\n            int i=0;\\n            while(true){\\n                if((number-3*i)<0){\\n                    if(number%2==0){\\n                         count+=(number/2);\\n                    }else return -1;\\n                }\\n                int rem=(number-3*i)/3;\\n                int rem1=number-3*rem;\\n                if(rem1%2==0){\\n                   count+=rem;\\n                   count+=(rem1)/2;  \\n                   break;\\n                }\\n                i++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997735,
                "title": "easy-solution-java-beginner-friendly-best-method",
                "content": "# Intuition\\nIf we observe the inputs carefully we can count the no. of tasks of same difficulty level in a HashMap and then check for the rounds a particular difficulty level is going to take if it is possible otherwise return -1.\\n\\nNow to calculate the no. of rounds required to complete a particular difficulty level we can see that it is following the below pattern :\\n1 -> -1\\n2 -> 1\\n3 -> 1\\n4 -> 2\\n5 -> 2\\n6 -> 2\\n7 -> 3\\n8 -> 3\\n9 -> 3\\n10 -> 4\\n11 -> 4\\n12 -> 4\\n\\nSo we can easily see that the answer the changing periodically except the edge case 1 as we can complete the task i.e. need to return -1.\\n\\n# Approach\\n- Check for the edge cases\\n- Initialize a int variable \\'rounds\\' as 0 and a HashMap \\'counts\\' to count the occurences of same difficulty level.\\n- Iterate over the tasks and count the occurences.\\n- Now for each difficulty level check the count : \\n    1. When count is 1 return -1\\n    2. When count is multiple of 3 add (count / 3)\\n    3. Otherwise add (count / 3 + 1)\\n    \\n- Return the result \\n\\n\\n# Complexity\\n- Time complexity:O(N) where N is length of the tasks\\n\\n- Space complexity: O(N) where N is length of the tasks\\n\\n**Please Upvote If this solution helps you to learn something. Thanks in advance.**\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // edge cases\\n        if(tasks == null || tasks.length == 0){\\n            return -1;\\n        }\\n\\n        // intitalization\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        int rounds = 0;\\n\\n        // iterate over the tasks\\n        for(int diffLevel : tasks){\\n            counts.put(diffLevel, counts.getOrDefault(diffLevel, 0) + 1);\\n        }\\n\\n        // iterate over the counts of same difficulty level\\n        for(int diffLevel : counts.keySet()){\\n            int count = counts.get(diffLevel);\\n            // when current count is 1\\n            if(count == 1){\\n                return -1;\\n            }\\n            if(count % 3 == 0){\\n                rounds += count / 3;\\n            }else{\\n                rounds += count / 3 + 1;\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n}\\n```\\n\\n**Please Upvote If this solution helps you to learn something. Thanks in advance.**",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        // edge cases\\n        if(tasks == null || tasks.length == 0){\\n            return -1;\\n        }\\n\\n        // intitalization\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        int rounds = 0;\\n\\n        // iterate over the tasks\\n        for(int diffLevel : tasks){\\n            counts.put(diffLevel, counts.getOrDefault(diffLevel, 0) + 1);\\n        }\\n\\n        // iterate over the counts of same difficulty level\\n        for(int diffLevel : counts.keySet()){\\n            int count = counts.get(diffLevel);\\n            // when current count is 1\\n            if(count == 1){\\n                return -1;\\n            }\\n            if(count % 3 == 0){\\n                rounds += count / 3;\\n            }else{\\n                rounds += count / 3 + 1;\\n            }\\n        }\\n\\n        return rounds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997469,
                "title": "c-hashmap-easy-84-time-72-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& v) {\\n      unordered_map<int, int> um;\\n      for(auto &i: v) um[i]++;\\n      int ans = 0;\\n      for(auto &[f, s]: um){\\n        if(s < 2) return -1;\\n        else if(s % 3 == 0) ans += s / 3;\\n        else ans += s / 3 + 1;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& v) {\\n      unordered_map<int, int> um;\\n      for(auto &i: v) um[i]++;\\n      int ans = 0;\\n      for(auto &[f, s]: um){\\n        if(s < 2) return -1;\\n        else if(s % 3 == 0) ans += s / 3;\\n        else ans += s / 3 + 1;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997075,
                "title": "easiest-explanation-with-examples-o-n-beginner-friendly-very-fast",
                "content": "# PreRequisite\\nReader should know map STL.\\n\\n# Approach\\nMAPPING VALUES AND THEIR OCCURENCE .FOR MINIMUM ROUNDS ,GROUP OF 3\\'S SHOULD BE MAXIMUM . \\nTHEREFORE ONLY THREE CASES ACCORDING TO OUR PROBLEM .\\n\\nCASE I :\\n# **IF (it.second%3==0)**\\nThen ans+=it.second/3;\\n\\nCASE II :\\n# IF (it.second%3==1)\\nThen ans+=2(2 group of 2\\'s)+ (it.second-4)/3(remaining group of 3\\'s);\\n\\nexample :\\ni. [69,69,69,69,69,69,69,69,69,69] \\nTotal number of 69 is 10 .\\nNow 10 can be divided into 2 group of 3\\'s{6 elements} and\\n2 group of 2\\'s{4 elements}.\\n\\nii.Let frequency be 40 then 40%3==1 .\\nTherefore ans+= 2(from 2\\'s) +36/3 (from 3\\'s)\\n\\nCASE III.\\n# IF (it.second%3==2)\\nThen ans+= 1(1 group of 2\\'s)+ (it.second-2)/3(remaining group of 3\\'s)\\n\\n\\n# Complexity\\n- Time complexity:\\n O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mpp;\\n        for(auto it : tasks)mpp[it]++;\\n        int ans=0;\\n        for(auto it : mpp){\\n            if(it.second<2)return -1;\\n            else{\\n                if(it.second%3==0){\\n                    ans+=(it.second/3);\\n                }\\n                else if(it.second%3==1){\\n                    ans+=2;\\n                    ans+=(it.second-4)/3; // 40 - 40%3==1 .therefore ans=2(from 2\\'s) +36/3 (from 3\\'s) \\n                }\\n                else if(it.second%3==2){\\n                    ans+=1;           \\n                    ans+=(it.second-2)/3; //17%3==2. 17 - 3 3 3 3 3 2 \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// 4 -- 2 2 \\n// 7 -- 2 2 3 \\n// 10 - 2 2 3 3\\n\\n// 5 -- 3 2 \\n// 8 -- 3 3 2\\n\\n// 6 -- 3 3 \\n// 9 -- 3 3 3 \\n\\n\\n\\n\\n\\n\\n```\\n\\nTHANK YOU READERS.UPVOTE IF LIKED THE EXPALANATION \\uD83D\\uDE0A\\nAMAN MAURYA .\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mpp;\\n        for(auto it : tasks)mpp[it]++;\\n        int ans=0;\\n        for(auto it : mpp){\\n            if(it.second<2)return -1;\\n            else{\\n                if(it.second%3==0){\\n                    ans+=(it.second/3);\\n                }\\n                else if(it.second%3==1){\\n                    ans+=2;\\n                    ans+=(it.second-4)/3; // 40 - 40%3==1 .therefore ans=2(from 2\\'s) +36/3 (from 3\\'s) \\n                }\\n                else if(it.second%3==2){\\n                    ans+=1;           \\n                    ans+=(it.second-2)/3; //17%3==2. 17 - 3 3 3 3 3 2 \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// 4 -- 2 2 \\n// 7 -- 2 2 3 \\n// 10 - 2 2 3 3\\n\\n// 5 -- 3 2 \\n// 8 -- 3 3 2\\n\\n// 6 -- 3 3 \\n// 9 -- 3 3 3 \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996789,
                "title": "very-easy-approach-in-java-explained",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will count the frequency of each task in the input array and stores it in a map. Then, it iterates over the values (frequencies) in the map and checks if any task has a frequency of `less than 2`. \\n- If it finds such a task, it `returns -1` as required. Otherwise, it calculates the minimum number of rounds needed to complete all tasks. \\n\\n1. If the frequency of a task is greater than or equal to 3, we can complete 3 tasks in each round, so we need `map_count / 3` rounds.\\n1. If the frequency of a task is 2, we need at least one round to complete all tasks so we increment the ans.\\n- Finally, it adds the number of rounds needed for each task to the ans.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> m = new HashMap<Integer, Integer>();\\n\\n        for(int i=0; i<tasks.length; i++){\\n            if(m.containsKey(tasks[i])){\\n                m.put(tasks[i], m.get(tasks[i])+1);\\n            }else{\\n                m.put(tasks[i], 1);\\n            }\\n        }\\n        int ans =0;\\n        for(int map_count : m.values()){\\n            if(map_count < 2){\\n                return -1;\\n            }\\n            ans = ans+(map_count/3);\\n            if(map_count % 3 != 0){\\n                ans++;\\n            }\\n         }\\n        return ans;\\n    }\\n}\\n```\\n# Please Upvote if it was helpful",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> m = new HashMap<Integer, Integer>();\\n\\n        for(int i=0; i<tasks.length; i++){\\n            if(m.containsKey(tasks[i])){\\n                m.put(tasks[i], m.get(tasks[i])+1);\\n            }else{\\n                m.put(tasks[i], 1);\\n            }\\n        }\\n        int ans =0;\\n        for(int map_count : m.values()){\\n            if(map_count < 2){\\n                return -1;\\n            }\\n            ans = ans+(map_count/3);\\n            if(map_count % 3 != 0){\\n                ans++;\\n            }\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996734,
                "title": "easy-and-very-short-solution",
                "content": "# Intuition\\nOnly one case the result will be -1. If frequency of any number is 1. If not then the answer is always \\n\\n ```\\n    int((frequency+2)/3)\\n```\\nFor example:\\n    if 2 then answer is (2+2)/3 => 1 same for others\\n-  3 (3+2)/3 => 1\\n-    4 (4+2)/3 => 2\\n-    5 (5+2)/3 => 3\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        countFreq = Counter(tasks)\\n        res = 0\\n        for element in countFreq:\\n            if countFreq[element] == 1:\\n                return -1\\n            res += int((countFreq[element]+2)/3)\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    int((frequency+2)/3)\\n```\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        countFreq = Counter(tasks)\\n        res = 0\\n        for element in countFreq:\\n            if countFreq[element] == 1:\\n                return -1\\n            res += int((countFreq[element]+2)/3)\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996542,
                "title": "minimum-rounds-to-complete-all-tasks-using-queue-and-hashtable",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks)\\n    {\\n        unordered_map<int,int>mp;\\n        for(auto x:tasks)\\n        {\\n            mp[x]++;\\n        }\\n        queue<int>q;\\n        for(auto x:mp){\\n            if(x.second==1)\\n                return -1;\\n            else\\n                q.push(x.second);\\n        }\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n= q.front();\\n            q.pop();\\n            if(n>=3)\\n            {\\n                n-=3;\\n                ans++;\\n                \\n            }\\n            else if(n==2)\\n            {\\n                n-=2;\\n                ans++;\\n            }\\n            if(n==1)\\n            {\\n                ans++;\\n                continue;\\n            }\\n            else if (n==0)\\n                continue;\\n            else\\n                q.push(n);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks)\\n    {\\n        unordered_map<int,int>mp;\\n        for(auto x:tasks)\\n        {\\n            mp[x]++;\\n        }\\n        queue<int>q;\\n        for(auto x:mp){\\n            if(x.second==1)\\n                return -1;\\n            else\\n                q.push(x.second);\\n        }\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int n= q.front();\\n            q.pop();\\n            if(n>=3)\\n            {\\n                n-=3;\\n                ans++;\\n                \\n            }\\n            else if(n==2)\\n            {\\n                n-=2;\\n                ans++;\\n            }\\n            if(n==1)\\n            {\\n                ans++;\\n                continue;\\n            }\\n            else if (n==0)\\n                continue;\\n            else\\n                q.push(n);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996182,
                "title": "swift-easy-solution-with-hashmap",
                "content": "HashMap - Counting solution\\n\\n```\\nclass Solution {\\n    func minimumRounds(_ tasks: [Int]) -> Int {\\n        var hm: [Int: Int] = [:]\\n        for i in tasks {\\n            hm[i, default: 0] += 1\\n        }\\n        var count = 0\\n        for i in hm {\\n            if i.value > 1 {\\n                count += Int(i.value / 3)\\n                count += i.value % 3 == 0 ? 0 : 1    \\n            } else {\\n                return -1\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    func minimumRounds(_ tasks: [Int]) -> Int {\\n        var hm: [Int: Int] = [:]\\n        for i in tasks {\\n            hm[i, default: 0] += 1\\n        }\\n        var count = 0\\n        for i in hm {\\n            if i.value > 1 {\\n                count += Int(i.value / 3)\\n                count += i.value % 3 == 0 ? 0 : 1    \\n            } else {\\n                return -1\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996150,
                "title": "c-using-hashmap-intuitive-approach",
                "content": "**Approach:**\\n*  Store frequencies of tasks in hashmap, and take frequencies of tasks one by one. \\n* We can either take 2 or 3 tasks at once but we have to minimize the rounds so first we will check if 3 can be taken else take 2 tasks.\\n* After taking all pair of 2 or 3 tasks check in case at the end 1 task is left so that can\\'t be taken so return -1;\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mpp;\\n        for(auto &it: tasks)\\n            mpp[it]++;\\n        \\n        int cnt = 0;\\n        for(auto &it: mpp){\\n            while(it.second>=2){\\n                cnt++;\\n                //greedily substract\\n                if(it.second%3==0)\\n                    it.second -= 3;\\n                else\\n                    it.second -= 2;\\n            }\\n            \\n            if(it.second != 0) return -1;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mpp;\\n        for(auto &it: tasks)\\n            mpp[it]++;\\n        \\n        int cnt = 0;\\n        for(auto &it: mpp){\\n            while(it.second>=2){\\n                cnt++;\\n                //greedily substract\\n                if(it.second%3==0)\\n                    it.second -= 3;\\n                else\\n                    it.second -= 2;\\n            }\\n            \\n            if(it.second != 0) return -1;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995933,
                "title": "javascript-solution-with-comments-map-o-n-tc-o-n-sc",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) N for hashMap to store frequencies \\n    \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    <!-- map to store frequencies -->\\n    const hash = new Map();\\n    <!-- total count | answer  -->\\n    let count = 0;\\n\\n    for(let task of tasks){\\n        <!-- if that number already exit in table than update it\\'s value -->\\n        if(hash.has(task)){\\n            hash.set(task, hash.get(task) + 1)\\n        }else{\\n            <!-- if that number don\\'t exit add ti table -->\\n            hash.set(task, 1)\\n        }\\n    }\\n    <!-- iterate over Map -->\\n    for(let [key, value] of hash){\\n        <!-- \\n            if frequncy is 1 the its not possible to complete tasks\\n            so return -1 \\n        -->\\n        if(value <= 1) return -1\\n\\n        <!-- if completely divisible to 3 than add directly to count -->\\n        if(value % 3 === 0){\\n            count += value/3\\n        }else{\\n        <!-- if not divisible with 3 -->\\n            count += Math.floor(value / 3) + 1\\n        }\\n    }\\n\\n    return count;\\n};\\n\\n```\\n\\n**If you like this solution please upvote, Thanks**",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    <!-- map to store frequencies -->\\n    const hash = new Map();\\n    <!-- total count | answer  -->\\n    let count = 0;\\n\\n    for(let task of tasks){\\n        <!-- if that number already exit in table than update it\\'s value -->\\n        if(hash.has(task)){\\n            hash.set(task, hash.get(task) + 1)\\n        }else{\\n            <!-- if that number don\\'t exit add ti table -->\\n            hash.set(task, 1)\\n        }\\n    }\\n    <!-- iterate over Map -->\\n    for(let [key, value] of hash){\\n        <!-- \\n            if frequncy is 1 the its not possible to complete tasks\\n            so return -1 \\n        -->\\n        if(value <= 1) return -1\\n\\n        <!-- if completely divisible to 3 than add directly to count -->\\n        if(value % 3 === 0){\\n            count += value/3\\n        }else{\\n        <!-- if not divisible with 3 -->\\n            count += Math.floor(value / 3) + 1\\n        }\\n    }\\n\\n    return count;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2995894,
                "title": "java-soln-hashmap",
                "content": "```\\nclass Solution {\\n    // This function returns the minimum number of rounds needed to\\n    // process all tasks in the given array of tasks.\\n    public int minimumRounds(int[] tasks) {\\n\\n        // Create a HashMap to store the count of each task\\n        HashMap<Integer, Integer> getCount = new HashMap<>();\\n\\n        // Iterate through the tasks array and store the count of each task\\n        // in the HashMap\\n        for (int t : tasks) {\\n            getCount.put(t, getCount.getOrDefault(t, 0) + 1);\\n        }\\n\\n        // Initialize a result variable to 0\\n        int result = 0;\\n\\n        // Iterate through the values in the HashMap (which represent the counts of the tasks)\\n        for (int count : getCount.values()) {\\n            // If a task has a count of 1, it cannot be grouped with other tasks\\n            // and so we return -1\\n            if (count == 1) return -1;\\n\\n            // Add the number of rounds needed to process the tasks with count greater than or equal to 3\\n            result += count / 3;\\n\\n            // If there are any tasks left with count less than 3, we need an additional round\\n            // to process these tasks\\n            if(count % 3 != 0) result++;\\n        }\\n\\n        // Return the total number of rounds needed to process all tasks\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "class Solution {\\n    // This function returns the minimum number of rounds needed to\\n    // process all tasks in the given array of tasks.\\n    public int minimumRounds(int[] tasks) {\\n\\n        // Create a HashMap to store the count of each task\\n        HashMap<Integer, Integer> getCount = new HashMap<>();\\n\\n        // Iterate through the tasks array and store the count of each task\\n        // in the HashMap\\n        for (int t : tasks) {\\n            getCount.put(t, getCount.getOrDefault(t, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2995830,
                "title": "c-100-working-maps-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n    unordered_map<int, int> mp;\\n    int c=0;\\n    for(int i=0;i<tasks.size();i++) mp[tasks[i]]++;\\n    for(auto x:mp) {\\n      if(x.second == 1) return -1;\\n      else if(x.second%3==0) c+=x.second/3;\\n      else c+=x.second/3+1;\\n    }\\n    return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n    unordered_map<int, int> mp;\\n    int c=0;\\n    for(int i=0;i<tasks.size();i++) mp[tasks[i]]++;\\n    for(auto x:mp) {\\n      if(x.second == 1) return -1;\\n      else if(x.second%3==0) c+=x.second/3;\\n      else c+=x.second/3+1;\\n    }\\n    return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995666,
                "title": "python-solution-using-mapping-counter-function",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst count the frequency of tasks using the python\\'s inbuilt counter function.\\nTake count variable as 0 for counting number of rounds.\\nIterate over the frequency array and if frequency is smaller than 2 then we simply return -1 as the answer else we will add floor value of (freq[i]+2)/3 to the existing count variable and then simply return it. \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks).values()\\n        count = 0\\n        for f in frequency:\\n            if f < 2:\\n                return -1\\n            count += floor((f+2)/3)\\n        return count\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst count the frequency of tasks using the python\\'s inbuilt counter function.\\nTake count variable as 0 for counting number of rounds.\\nIterate over the frequency array and if frequency is smaller than 2 then we simply return -1 as the answer else we will add floor value of (freq[i]+2)/3 to the existing count variable and then simply return it. \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        frequency = Counter(tasks).values()\\n        count = 0\\n        for f in frequency:\\n            if f < 2:\\n                return -1\\n            count += floor((f+2)/3)\\n        return count\\n",
                "codeTag": "Java"
            },
            {
                "id": 2995639,
                "title": "c-using-map-ceiling-function",
                "content": "# Intuition\\nAs it frequency based question, we have to use map for it.\\n\\n# Approach\\nIf frequency of any task is 1. then return -1 because we can not do that task as we have to do 2 or 3 tasks in one go.\\n\\nNow, all we have is the remainder if we devide particular frequency by 3.\\n\\nIf remainder is 1, eg. freq task == 4, then we have to do two round each of 2-2 tasks which is indeed ceil(freq task / 3).\\n\\nIf remainder is 2, eg. freq task == 5, then we have to do two round each of 2-3 tasks which is indeed ceil(freq task / 3).\\n\\nIf remainder is 0, eg. freq task == 6, then we have to do two round each of 3-3 tasks which is indeed ceil(freq task / 3).\\n\\nThis is it !!!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        unordered_map<int, int> mp;\\n        for (auto i : tasks)\\n            mp[i]++;\\n        int ans = 0;\\n        for (auto i : mp)\\n            if (i.second == 1)\\n                return -1;\\n        for (auto i : mp)\\n            ans += ceil(i.second / 3.0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        unordered_map<int, int> mp;\\n        for (auto i : tasks)\\n            mp[i]++;\\n        int ans = 0;\\n        for (auto i : mp)\\n            if (i.second == 1)\\n                return -1;\\n        for (auto i : mp)\\n            ans += ceil(i.second / 3.0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995571,
                "title": "simple-and-easy-to-understand-using-ceil-and-unordered-map-detailed-explaination",
                "content": "# Intuition\\nIf the count of element is 1 ans is -1.\\nIf the count of element is\\ncount : ans\\n2 ____: 1\\n3_____: 1\\n4_____: 2\\n5_____: 2\\n6_____: 2\\n7_____: 3\\n8_____: 3\\n9_____: 3\\n....\\n\\nBy obseving this,we can easily predict that if we divide the number by 3 and use the ceil value we get correct answer.\\n\\n\\n# Approach\\nStore the count of each element in map and iterate it to get the result. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& arr) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                return -1;\\n            }\\n            else{\\n                ans+=ceil(x.second/3.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& arr) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                return -1;\\n            }\\n            else{\\n                ans+=ceil(x.second/3.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995512,
                "title": "c-solution-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> hm;\\n        for(int i=0;i<tasks.size();i++){\\n            hm[tasks[i]]++;\\n        }\\n        int num,freq,ans=0;\\n        for (auto i : hm){\\n            freq = i.second;\\n            if(freq==1)\\n                return -1;\\n            if(freq%3==0){\\n                ans += freq/3;\\n            }\\n            else{\\n                ans += freq/3 + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> hm;\\n        for(int i=0;i<tasks.size();i++){\\n            hm[tasks[i]]++;\\n        }\\n        int num,freq,ans=0;\\n        for (auto i : hm){\\n            freq = i.second;\\n            if(freq==1)\\n                return -1;\\n            if(freq%3==0){\\n                ans += freq/3;\\n            }\\n            else{\\n                ans += freq/3 + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995422,
                "title": "c-hashing-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Mathematics\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> mp;\\n        for(int ele:tasks){\\n            mp[ele]++;\\n        }\\n        for(auto item:mp){\\n            int item_freq=item.second;\\n            if(item_freq==1){ // if element frequency==1 \\n                return -1;\\n            }\\n        }\\n        int res=0;\\n        for(auto p:mp){\\n            int item=p.first;\\n            int item_freq=p.second;\\n            int round=item_freq/3; \\n                                  //  if freq=9 --> it will be 3,3,3\\n            if(item_freq%3!=0)     //  if freq=7 --> it will be 3,2,2 .i.e. at least 3 round\\n               round++;\\n            res+=round;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        unordered_map<int,int> mp;\\n        for(int ele:tasks){\\n            mp[ele]++;\\n        }\\n        for(auto item:mp){\\n            int item_freq=item.second;\\n            if(item_freq==1){ // if element frequency==1 \\n                return -1;\\n            }\\n        }\\n        int res=0;\\n        for(auto p:mp){\\n            int item=p.first;\\n            int item_freq=p.second;\\n            int round=item_freq/3; \\n                                  //  if freq=9 --> it will be 3,3,3\\n            if(item_freq%3!=0)     //  if freq=7 --> it will be 3,2,2 .i.e. at least 3 round\\n               round++;\\n            res+=round;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995358,
                "title": "easy-cp-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the number of tasks with the same difficulty level exceeds one, there must be one valid result for those tasks.Otherwise, return -1.\\n\\nBy analysing the conditions, all tasks can be solved by taking three tasks at a time, and if the task is less than 3 (which means 2), it can also be done.\\nSo divide the number of tasks (same difference) by three, and add one if the remainder is 2 for all difficulty levels. Finally, return the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>mp;\\n        for(auto a:tasks){\\n            if(mp.find(a)!=mp.end()){\\n                  mp[a]++;  \\n            }\\n            else{\\n                mp.insert({a,1});\\n            }\\n        }\\n        int c=0;\\n        for(auto it:mp){\\n            int k=it.second;\\n            if(k<2)return -1;\\n            c+=(k+2)/3;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>mp;\\n        for(auto a:tasks){\\n            if(mp.find(a)!=mp.end()){\\n                  mp[a]++;  \\n            }\\n            else{\\n                mp.insert({a,1});\\n            }\\n        }\\n        int c=0;\\n        for(auto it:mp){\\n            int k=it.second;\\n            if(k<2)return -1;\\n            c+=(k+2)/3;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995347,
                "title": "c-easy-understanding",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;int c=0;\\n        for(int p=0;p<tasks.size();p++) mp[tasks[p]]++;\\n        for(auto &p:mp){\\n            if(p.second==1) return -1;\\n            c+=(p.second+2)/3;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;int c=0;\\n        for(int p=0;p<tasks.size();p++) mp[tasks[p]]++;\\n        for(auto &p:mp){\\n            if(p.second==1) return -1;\\n            c+=(p.second+2)/3;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995306,
                "title": "simple-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        c=0\\n        d={}\\n        tasks.sort()\\n        for i in tasks:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for i in d:\\n            while d[i]:\\n                if d[i]==1:\\n                    return -1\\n                if d[i]%3==0:\\n                    d[i]-=3\\n                else:\\n                    d[i]-=2\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        c=0\\n        d={}\\n        tasks.sort()\\n        for i in tasks:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for i in d:\\n            while d[i]:\\n                if d[i]==1:\\n                    return -1\\n                if d[i]%3==0:\\n                    d[i]-=3\\n                else:\\n                    d[i]-=2\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995285,
                "title": "c-begineer-friendly-easy-understanding-greedy-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=IVISUum7jVA/\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int minimumRounds(vector<int>& tasks) {\\n        // store the frequency in map.\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n\\n        // store the ans. for 3 cases..\\n        int ans =0;\\n\\n        for(auto x:mp){\\n            int frequency = x.second;\\n\\n            // if freq is 1 return -1, not possible.\\n            if(frequency == 1) return -1;\\n\\n            // if frequ is divided by 3 with rem == 0\\n            else if(frequency%3  == 0 ) ans+= frequency/3;\\n\\n            // if rem == 2 or rem == 1\\n            else if(frequency%3 == 1 || frequency%3 == 2){\\n                ans += frequency/3 + 1;\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int minimumRounds(vector<int>& tasks) {\\n        // store the frequency in map.\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<tasks.size();i++){\\n            mp[tasks[i]]++;\\n        }\\n\\n        // store the ans. for 3 cases..\\n        int ans =0;\\n\\n        for(auto x:mp){\\n            int frequency = x.second;\\n\\n            // if freq is 1 return -1, not possible.\\n            if(frequency == 1) return -1;\\n\\n            // if frequ is divided by 3 with rem == 0\\n            else if(frequency%3  == 0 ) ans+= frequency/3;\\n\\n            // if rem == 2 or rem == 1\\n            else if(frequency%3 == 1 || frequency%3 == 2){\\n                ans += frequency/3 + 1;\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995238,
                "title": "c-easiest-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        unordered_map<int,int>mp;\\n\\t\\t\\n\\t\\t//counting occurance of all value \\n        for(auto i:tasks)\\n        {\\n            mp[i]++;\\n        }\\n        \\n        int count = 0;\\n        for(auto i:mp)\\n        {\\n\\t\\t\\t// if any value is having count = 1 then definetely solution is not exist\\n\\t\\t\\t// because in one operation either we can take 2 or 3 tasks of same difficulty\\n            if(i.second == 1)return -1;\\n\\t\\t\\t\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif value 2 occurs 3 times -> count = 3/3 = 1 means in 1 round we can take all tasks\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif value 3 occurs 2 times -> count = 2/3 = 0\\n\\t\\t\\t\\tbut also we are cheking \\n\\t\\t\\t\\tif occurance%3 > 0 then we count++\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlet\\'s understand better in this example\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif any value is having occurance 7\\n\\t\\t\\t\\tso we shoud take 3 2 2 tasks means total 3 round\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount = 7/3 = 2 \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif 7%3 >1 count++\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tso count = 3\\n\\t\\t\\t*/\\n            count+=i.second/3;\\n            if(i.second%3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        unordered_map<int,int>mp;\\n\\t\\t\\n\\t\\t//counting occurance of all value \\n        for(auto i:tasks)\\n        {\\n            mp[i]++;\\n        }\\n        \\n        int count = 0;\\n        for(auto i:mp)\\n        {\\n\\t\\t\\t// if any value is having count = 1 then definetely solution is not exist\\n\\t\\t\\t// because in one operation either we can take 2 or 3 tasks of same difficulty\\n            if(i.second == 1)return -1;\\n\\t\\t\\t\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif value 2 occurs 3 times -> count = 3/3 = 1 means in 1 round we can take all tasks\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif value 3 occurs 2 times -> count = 2/3 = 0\\n\\t\\t\\t\\tbut also we are cheking \\n\\t\\t\\t\\tif occurance%3 > 0 then we count++\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlet\\'s understand better in this example\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif any value is having occurance 7\\n\\t\\t\\t\\tso we shoud take 3 2 2 tasks means total 3 round\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount = 7/3 = 2 \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif 7%3 >1 count++\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tso count = 3\\n\\t\\t\\t*/\\n            count+=i.second/3;\\n            if(i.second%3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995235,
                "title": "python-greedy-solution-dictionary",
                "content": "# Intuition\\nWhenever we encounter with frequency 1 then we can\\'t able finish our task any number of rounds. While in other cases we see that every three number there minimum is always comes same.\\nEx - for 2 with freq 4,5,6,  we always get minimum round is 2\\n     for 2 with freq 7,8,9,  we always get minimum round is 3\\n     for 2 with freq 10,11,12,  we always get minimum round is 4\\nHence, we conclude frequency of element greater than 1 will always required minimum round ceiling value of (freq(n) / 3). Where n represent the diffulty level. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        hashTable = defaultdict(int)\\n        for task in tasks:\\n            hashTable[task] += 1\\n\\n        ans = 0\\n        for key in hashTable:\\n            if hashTable[key] == 1: return -1\\n            ans += ceil(hashTable[key]/3)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        hashTable = defaultdict(int)\\n        for task in tasks:\\n            hashTable[task] += 1\\n\\n        ans = 0\\n        for key in hashTable:\\n            if hashTable[key] == 1: return -1\\n            ans += ceil(hashTable[key]/3)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995228,
                "title": "easy-hash-map-approach-linear-time-complexity-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) || for ordered hash-map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n\\n        int ans=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second == 1)\\n                return -1;      // tasks is impossible to complete\\n            \\n            int cnt=0;\\n\\n            while(it.second > 3)\\n            {\\n                it.second -= 3; cnt++;     // calculate the rounds it will take to complete tasks\\n            }\\n            if(it.second)   // if total tasks would be in odd no. then after subtracting from 3 we\\'ll \\n                cnt++;      // increment the count  ex: 7-3 -> 4-3 -> 1  completed in 3 rounds [2,2,3]\\n\\n            ans+= cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **PLEASE UPVOTE IF YOU UNDESTOOD THE SOLUTION!!**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int>mp;\\n        for(int i=0;i<tasks.size();i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n\\n        int ans=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second == 1)\\n                return -1;      // tasks is impossible to complete\\n            \\n            int cnt=0;\\n\\n            while(it.second > 3)\\n            {\\n                it.second -= 3; cnt++;     // calculate the rounds it will take to complete tasks\\n            }\\n            if(it.second)   // if total tasks would be in odd no. then after subtracting from 3 we\\'ll \\n                cnt++;      // increment the count  ex: 7-3 -> 4-3 -> 1  completed in 3 rounds [2,2,3]\\n\\n            ans+= cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995190,
                "title": "c-faster-than-100-5-lines-only-beginner-friendly-clean-code",
                "content": "\\n\\n# Code\\n```\\n//PLEASE UPVOTE IN CASE YOU LIKED THE SOLUTION\\n\\nclass Solution {\\npublic:\\n\\n    int minimumRounds(vector<int>& tasks) {\\n\\n       unordered_map<int,int>mpp;\\n       int res = 0;\\n\\n       for(auto &it : tasks) mpp[it]++;\\n\\n       for(auto &it : mpp) \\n       {\\n           if(it.second < 2) return -1;\\n\\n           res+= (it.second / 3) + (it.second % 3 > 0);\\n       }\\n\\n       return res;       \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\n//PLEASE UPVOTE IN CASE YOU LIKED THE SOLUTION\\n\\nclass Solution {\\npublic:\\n\\n    int minimumRounds(vector<int>& tasks) {\\n\\n       unordered_map<int,int>mpp;\\n       int res = 0;\\n\\n       for(auto &it : tasks) mpp[it]++;\\n\\n       for(auto &it : mpp) \\n       {\\n           if(it.second < 2) return -1;\\n\\n           res+= (it.second / 3) + (it.second % 3 > 0);\\n       }\\n\\n       return res;       \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995099,
                "title": "easy-to-understand-count-math",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/array/MinRoundsCompleteTasks.kt",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2995046,
                "title": "daily-leetcode-solution-minimum-rounds-to-complete-all-tasks-easy-c-sol-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <iostream>\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < tasks.size(); i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n        int rounds = 0;\\n        for (auto &val : mp)\\n        {\\n            if (val.second == 1)\\n            {\\n                return -1;\\n            }\\n            else if (val.second % 3 == 0)\\n            {\\n                rounds += (val.second / 3);\\n            }\\n            else\\n            {\\n                rounds += (val.second / 3) + 1;\\n            }\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <iostream>\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < tasks.size(); i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n        int rounds = 0;\\n        for (auto &val : mp)\\n        {\\n            if (val.second == 1)\\n            {\\n                return -1;\\n            }\\n            else if (val.second % 3 == 0)\\n            {\\n                rounds += (val.second / 3);\\n            }\\n            else\\n            {\\n                rounds += (val.second / 3) + 1;\\n            }\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2995022,
                "title": "daily-leetcode-challenge-c-detailed-explaination-code-day-4",
                "content": "# Approach\\n**Keep in mind we need to Return the minimum rounds required to complete all the tasks**\\n1. First we create unordered_map to store tasks and number of times task repeated as key and value respectively.\\n2. now we will go through the number of tasks(i.e. val.second) having same difficulty level(i.e. val.first)\\n    1. if the number of tasks is equal to 1(i.e. val.second) then, you can never complete either 2 or 3 tasks having same difficulty level in each round. In this case you will return -1.\\n    2. if the number of tasks is equal to 2(i.e. val.second) then, you can complete 2 tasks having same difficulty level in each round at a time. In this case you will add count = count + 1.\\n    3. if the number of tasks is >= 3(i.e. val.second) then, you can complete either 2 or 3 tasks having same difficulty level in each round at a time. lets understand with examples\\n        1. suppose we have vector, tasks = [4, 4, 4], then output will be 1, bcz we will take 3 tasks having same difficulty level(i.e. 4) at a time.\\n        2. suppose we have vector, tasks = [4, 4, 4, 4], then output will be 2, bcz we will not pick [[4, 4, 4], [4]] instead of picking this we will pick [[4, 4], [4, 4]].\\n        3. suppose we have vector, tasks = [4, 4, 4, 4, 4], then output will be 2, bcz we will not pick [[4, 4], [4, 4], [4]], instead of picking this we will pick [[4, 4, 4], [4, 4]].\\n        4. same logic implemented in the coding part.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(n)** // where  n is the size of vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** // where n is the size of vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> ump;\\n        for(int task : tasks){\\n            ump[task]++;\\n        }\\n        int count = 0; // it counts minimum rounds required to complete all the tasks\\n        for(auto val : ump){\\n            if(val.second == 1){\\n                return -1;\\n            }\\n            else if(val.second == 2){\\n                count = count + 1;\\n            }\\n            else if(val.second >= 3){\\n                int x = val.second / 3;\\n                int y = val.second % 3;\\n                if(y == 1 || y == 2)\\n                    count = count + x + 1;\\n                else if(y == 0)\\n                    count = count + x;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> ump;\\n        for(int task : tasks){\\n            ump[task]++;\\n        }\\n        int count = 0; // it counts minimum rounds required to complete all the tasks\\n        for(auto val : ump){\\n            if(val.second == 1){\\n                return -1;\\n            }\\n            else if(val.second == 2){\\n                count = count + 1;\\n            }\\n            else if(val.second >= 3){\\n                int x = val.second / 3;\\n                int y = val.second % 3;\\n                if(y == 1 || y == 2)\\n                    count = count + x + 1;\\n                else if(y == 0)\\n                    count = count + x;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994970,
                "title": "c-unordered-maps-intuitive-solution-easy-understand",
                "content": "# ***please give an upvote if you like the solution***\\n\\n\\n **Complexity**\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) --> n is size of tasks array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n) --> for map\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> map;\\n        for(int task: tasks){\\n            map[task]++;\\n        }\\n        int rounds = 0;\\n        for(auto task: map){\\n            if(task.second == 1) return -1;\\n            else rounds += task.second % 3 == 0 ? (task.second / 3) : (task.second / 3) + 1;\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> map;\\n        for(int task: tasks){\\n            map[task]++;\\n        }\\n        int rounds = 0;\\n        for(auto task: map){\\n            if(task.second == 1) return -1;\\n            else rounds += task.second % 3 == 0 ? (task.second / 3) : (task.second / 3) + 1;\\n        }\\n        return rounds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994926,
                "title": "python-one-liner-just-for-the-fun-of-it-but-still-o-n-and-faster-than-90-sometimes",
                "content": "Python one-liner just for the fun of it, but still O(n) and faster than 90% (sometimes)\\n\\n    return max(-1,sum([(ct + 2) // 3 if ct > 1 else float(\\'-inf\\') for key,ct in Counter(tasks).items()]))\\n\\nThe general idea is the same as the algorithm in the official solution\\n\\n1. Count how often each element occurs\\n2. Rounds for each level equals the ceiling of the number of occurrences divided by 3 (which (ct + 2) //3 means) and add all together\\n3. If a difficulty only occurs once, the entire input is \"invalid\", we need to return -1. The \"float(\\'-inf\\') is just a small trick to \"save\" that we need to return -1 after the sum has been taken.",
                "solutionTags": [],
                "code": "Python one-liner just for the fun of it, but still O(n) and faster than 90% (sometimes)\\n\\n    return max(-1,sum([(ct + 2) // 3 if ct > 1 else float(\\'-inf\\') for key,ct in Counter(tasks).items()]))\\n\\nThe general idea is the same as the algorithm in the official solution\\n\\n1. Count how often each element occurs\\n2. Rounds for each level equals the ceiling of the number of occurrences divided by 3 (which (ct + 2) //3 means) and add all together\\n3. If a difficulty only occurs once, the entire input is \"invalid\", we need to return -1. The \"float(\\'-inf\\') is just a small trick to \"save\" that we need to return -1 after the sum has been taken.",
                "codeTag": "Unknown"
            },
            {
                "id": 2994904,
                "title": "dart-100",
                "content": "\\nIf you Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minimumRounds(List<int> tasks) {\\n      Map<int, int> freq = {} ;\\n        int cont=0 ;\\n        for(int t in tasks)freq[t]=(freq[t] ?? 0) + 1;\\n        for(int it in freq.values){\\n            if(it == 1)return -1;\\n            if(it%3 == 0)cont += it~/3;\\n            else cont += it~/3+1 ;\\n        }\\n        return cont ;\\n  }\\n}\\n```\\n\\n\\nPls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding :)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minimumRounds(List<int> tasks) {\\n      Map<int, int> freq = {} ;\\n        int cont=0 ;\\n        for(int t in tasks)freq[t]=(freq[t] ?? 0) + 1;\\n        for(int it in freq.values){\\n            if(it == 1)return -1;\\n            if(it%3 == 0)cont += it~/3;\\n            else cont += it~/3+1 ;\\n        }\\n        return cont ;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416918,
                "title": "c-easy-solution-using-map-o-n",
                "content": "class Solution {\\npublic:\\n    int minimumRounds(vector<int>& task) {\\n\\t\\n        map<int,int>mp;\\n\\t\\t\\n\\t\\t// First calculate frequency of each element.\\n\\t\\t\\n        for(int i=0;i<task.size();++i){\\n            mp[task[i]]++;\\n        }\\n\\t\\t// If any element frequency is 1 then return -1 otherwise calculate minimum rounds required to complete all    the tasks.\\n\\t\\t\\n        int ans=0;\\n        for(auto &x: mp){\\n            if(x.second==1){\\n                return -1;\\n                break;\\n            }\\n            else{\\n            \\n                int div=x.second/3;\\n                int mod=x.second%3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If number of frequency a number which divisible by 3 that means  minimum rounds required  is (number of frequency/3) \\n\\t\\t\\t\\t\\n                if(mod==0){\\n                    ans+=div;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We know that number of frequency a number always is not divisible by 3. Always remainder is 2 or 1. If remainder is 2 that means we  can complete 2  tasks of the same difficulty level and minimum required round is (number of frequency/3) +1 . For example a number which frequency is 20 . where (20%3)=2  , to complete first 18 task required minimum round  is  (20/3)=6 and remainder 2 complete 1 round. so total round is = 6+1 =7\\n\\t\\t\\t\\t\\n                else if(mod==2){\\n                    ans+=(div+1);\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if remainder is 1 then we can calculate minimum round this way . for example a number which frequency is 10 . where (10%3)=1 , it\\'s not accepted because either 2 or 3 task completed at a time same difficulty level. If we bring 3 task from the value of (number of frequency/3) now remainder is 1+3=4 which is divisible by 2.  so, minimum require round is = ((number of frequency/3)-1) + 2 .\\n\\t\\t\\t\\t\\n                else{\\n                    ans+=((div-1)+2);\\n                }\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Time complexity O(n). Thanks all.\\n// If you think it\\'s helpful for you then please upvote.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumRounds(vector<int>& task) {\\n\\t\\n        map<int,int>mp;\\n\\t\\t\\n\\t\\t// First calculate frequency of each element.\\n\\t\\t\\n        for(int i=0;i<task.size();++i){\\n            mp[task[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2396456,
                "title": "easy-java-solution-with-sorting-greedy-98-26-faster-and-81-32-memory",
                "content": "I originally thought that I am taking a brute force approach by sorting and greedily checking for numbers, but seems like this was the most optimal approach. Sharing it since everyone else is sharing HashMap approach and it seems not necessary.\\n\\n```\\nclass Solution {\\n    \\n    // Runtime: 15 ms, faster than 98.26% of Java online submissions for Minimum Rounds to Complete All Tasks.\\n    // Memory Usage: 94.3 MB, less than 81.32% of Java online submissions for Minimum Rounds to Complete All Tasks.\\n    public int minimumRounds(int[] tasks) {\\n        // Sort them to make all the same numbers come next to each other\\n        Arrays.sort(tasks);\\n        \\n        int count = 0;\\n        \\n        int currCount = 1;\\n        for(int i = 1; i < tasks.length; i++) {\\n            if(tasks[i] == tasks[i-1]) {\\n                currCount++;\\n            } else if(currCount < 2) {\\n                return -1;\\n            } else {\\n                if(currCount % 3 == 0) {\\n                    count += currCount / 3;\\n                } else {\\n                    count += currCount / 3 + 1;\\n                }\\n                currCount = 1;\\n            }\\n        }\\n        \\n        // Following is required to handle the last remaining currCount.\\n        if(currCount < 2) {\\n            return -1;\\n        } else {\\n            if(currCount % 3 == 0) {\\n                count += currCount / 3;\\n            } else {\\n                count += currCount / 3 + 1;\\n            }\\n            currCount = 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Runtime: 15 ms, faster than 98.26% of Java online submissions for Minimum Rounds to Complete All Tasks.\\n    // Memory Usage: 94.3 MB, less than 81.32% of Java online submissions for Minimum Rounds to Complete All Tasks.\\n    public int minimumRounds(int[] tasks) {\\n        // Sort them to make all the same numbers come next to each other\\n        Arrays.sort(tasks);\\n        \\n        int count = 0;\\n        \\n        int currCount = 1;\\n        for(int i = 1; i < tasks.length; i++) {\\n            if(tasks[i] == tasks[i-1]) {\\n                currCount++;\\n            } else if(currCount < 2) {\\n                return -1;\\n            } else {\\n                if(currCount % 3 == 0) {\\n                    count += currCount / 3;\\n                } else {\\n                    count += currCount / 3 + 1;\\n                }\\n                currCount = 1;\\n            }\\n        }\\n        \\n        // Following is required to handle the last remaining currCount.\\n        if(currCount < 2) {\\n            return -1;\\n        } else {\\n            if(currCount % 3 == 0) {\\n                count += currCount / 3;\\n            } else {\\n                count += currCount / 3 + 1;\\n            }\\n            currCount = 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372941,
                "title": "java-easy-simple-clean-solution",
                "content": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        final Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int task: tasks) {\\n            map.compute(task, (k,v) -> v == null ? 1 : 1 + v);            \\n        }\\n        \\n        int groups = 0;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            final int task = entry.getKey();\\n            final int count = entry.getValue();\\n            \\n            if (count == 1) return -1;\\n            groups += (count / 3) + (count % 3 == 0 ? 0 : 1);\\n        }\\n        \\n        return groups;\\n    }\\n}\\n```\\n\\nOR to ignore reminder check we can always add 2 and do int division\\n\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        final Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int task: tasks) {\\n            map.compute(task, (k,v) -> v == null ? 1 : 1 + v);            \\n        }\\n        \\n        int groups = 0;\\n        \\n        for (int count : map.values()) {\\n            if (count == 1) return -1;\\n            groups += (count + 2) / 3;\\n        }\\n        \\n        return groups;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        \\n        final Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int task: tasks) {\\n            map.compute(task, (k,v) -> v == null ? 1 : 1 + v);            \\n        }\\n        \\n        int groups = 0;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            final int task = entry.getKey();\\n            final int count = entry.getValue();\\n            \\n            if (count == 1) return -1;\\n            groups += (count / 3) + (count % 3 == 0 ? 0 : 1);\\n        }\\n        \\n        return groups;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214803,
                "title": "c-logical-explanation",
                "content": "First of all think on the cases when it is impossible to do the tasks. For this we need to think about odd and even numbers separately.\\nFor even numbers, it is crystal clear that atleast one way is possible since we can divide it into two tasks each.\\nFor odd numbers, taking into consideration that odd-odd=even, i.e. if we take 3 tasks in one turn then the left tasks would be even which can also result to a certain output. But in this case the odd number needs to be more than 1.\\nThis implies there is no solution for task whose difficulty level is unique in the array given.\\nNow, for calculating the minimum count, we need to club more 3 tasks than 2. \\nWe know that any natural number can be represented in the form of 3n, 3n+1, 3n+2 where n is any natural number. Hence, we just need to take care of the case when the remainder is 1 on division by 3 since both other cases can be covered by taking 0 and 2 tasks in the next turn simultaneously. \\nNow for remainder 1, subtract 2 one time from its value. This is required since 3n+1 needs to be converted to either 3m or 3m+2, now 3n+1 becomes 3n+1-2=3n-1=3(n-1)+2=3m+2.\\nUpvote if it helps:)\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> m;\\n        for(int i=0; i<tasks.size(); i++) m[tasks[i]]++;\\n        int count=0;\\n        for(auto it:m) {\\n            if(it.second==1) return -1;\\n            else {\\n                if(it.second%3==1) {\\n                    count++;\\n                    it.second-=2;\\n                }\\n                count+=((it.second%3)==2)?1:0;\\n                count+=it.second/3;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> m;\\n        for(int i=0; i<tasks.size(); i++) m[tasks[i]]++;\\n        int count=0;\\n        for(auto it:m) {\\n            if(it.second==1) return -1;\\n            else {\\n                if(it.second%3==1) {\\n                    count++;\\n                    it.second-=2;\\n                }\\n                count+=((it.second%3)==2)?1:0;\\n                count+=it.second/3;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101837,
                "title": "c-mathematical-solution-with-explanation-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //INTUITION: We can greedily want to minimize the no. of rounds by taking max no. of 3 task groups possible.\\n    //Now whatever the number of tasks be, it can either be divisible by 3, or leave a remainder of 1 or 2 when divided by 3.\\n    \\n    //Say 8 tasks are there ########...we can group them like ###/###/##, so remainder of 2, and 2 tasks are grouped into an extra group\\n    //Say 7 tasks are there #######.. we can divide like ###/###/#, that would leave 1 task ungrouped, so we would group it like ###/##/##\\n    //So in both cases of remainder 1 or 2 when divided by 3, we need to create an extra group apart from the 3-task groups\\n    \\n    \\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(auto t:tasks) ++mp[t];\\n        int ans = 0;\\n        for(auto m:mp) {\\n            if(m.second==1) return -1;\\n            ans+=m.second/3 + (m.second%3!=0 ? 1 : 0); //adding 1 extra group only when dividing by 3 leaves a remainder(either 1 or 2)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //INTUITION: We can greedily want to minimize the no. of rounds by taking max no. of 3 task groups possible.\\n    //Now whatever the number of tasks be, it can either be divisible by 3, or leave a remainder of 1 or 2 when divided by 3.\\n    \\n    //Say 8 tasks are there ########...we can group them like ###/###/##, so remainder of 2, and 2 tasks are grouped into an extra group\\n    //Say 7 tasks are there #######.. we can divide like ###/###/#, that would leave 1 task ungrouped, so we would group it like ###/##/##\\n    //So in both cases of remainder 1 or 2 when divided by 3, we need to create an extra group apart from the 3-task groups\\n    \\n    \\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int> mp;\\n        for(auto t:tasks) ++mp[t];\\n        int ans = 0;\\n        for(auto m:mp) {\\n            if(m.second==1) return -1;\\n            ans+=m.second/3 + (m.second%3!=0 ? 1 : 0); //adding 1 extra group only when dividing by 3 leaves a remainder(either 1 or 2)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040286,
                "title": "c-space-o-n-time-o-n",
                "content": "As simple As possible\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>mp;\\n        for(int x:tasks)mp[x]++;\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                return -1;\\n            }else{\\n                int a=x.second/3;\\n                int b=x.second%3;\\n                ans+=a;\\n                ans+=b==0?0:1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int,int>mp;\\n        for(int x:tasks)mp[x]++;\\n        int ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1981732,
                "title": "simple-c-solution-and-easy-to-understand",
                "content": "```\\n//In this solution, we are basically trying all possiblities like doing work with blocks of 2 then with blocks 3 and at last combination of both 2 and 3.\\nclass Solution {\\n    private:\\n    int find(int val,int count,int y,int div) //This fun works for finding days if we do it in combination of 2 and 3;\\n    {\\n           int mini = INT_MAX;\\n           while(val>=y)\\n           {\\n               val-=y;\\n               ++count;\\n               if(val%div==0)\\n               {\\n                   mini = min(mini,count+val/div);\\n               }\\n           }\\n        \\n        return mini;\\n            \\n    }\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        map<int,int> mpp;\\n        for(int x:tasks)\\n        {\\n            mpp[x]++; \\n        }\\n        int days=0;\\n        for(auto &x:mpp)\\n        {\\n           int mini = INT_MAX; \\n           if(x.second==1)return -1; \\n           if(x.second%3==0)mini = min(mini,x.second/3);//only if we use blocks of 3\\n           if(x.second%2==0)mini = min(mini,x.second/2);//only if we use blocks of 2\\n           mini = min(mini,find(x.second,0,3,2));\\n           mini = min(mini,find(x.second,0,2,3)); \\n            \\n          // cout<<mini<<endl; \\n           days+=mini; \\n        } \\n        \\n        return days;\\n        \\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//In this solution, we are basically trying all possiblities like doing work with blocks of 2 then with blocks 3 and at last combination of both 2 and 3.\\nclass Solution {\\n    private:\\n    int find(int val,int count,int y,int div) //This fun works for finding days if we do it in combination of 2 and 3;\\n    {\\n           int mini = INT_MAX;\\n           while(val>=y)\\n           {\\n               val-=y;\\n               ++count;\\n               if(val%div==0)\\n               {\\n                   mini = min(mini,count+val/div);\\n               }\\n           }\\n        \\n        return mini;\\n            \\n    }\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        \\n        map<int,int> mpp;\\n        for(int x:tasks)\\n        {\\n            mpp[x]++; \\n        }\\n        int days=0;\\n        for(auto &x:mpp)\\n        {\\n           int mini = INT_MAX; \\n           if(x.second==1)return -1; \\n           if(x.second%3==0)mini = min(mini,x.second/3);//only if we use blocks of 3\\n           if(x.second%2==0)mini = min(mini,x.second/2);//only if we use blocks of 2\\n           mini = min(mini,find(x.second,0,3,2));\\n           mini = min(mini,find(x.second,0,2,3)); \\n            \\n          // cout<<mini<<endl; \\n           days+=mini; \\n        } \\n        \\n        return days;\\n        \\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1961911,
                "title": "c-easy-simple-code-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        int res = 0;\\n        for (int x : tasks) {mp[x]++;}\\n        for (auto x : mp) {\\n            if (x.second == 1) {return -1;} \\n            else {res += x.second / 3 + (x.second % 3 != 0);}\\n        }\\n        return res;\\n    }\\n};\\n```\\nDo up vote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        unordered_map<int, int> mp;\\n        int res = 0;\\n        for (int x : tasks) {mp[x]++;}\\n        for (auto x : mp) {\\n            if (x.second == 1) {return -1;} \\n            else {res += x.second / 3 + (x.second % 3 != 0);}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961075,
                "title": "c-simple-greedy-solution-explained-using-comments-hashmap-solution",
                "content": "**Time Complexity: O(N) as we are using simple traversal\\nSpace Complexity: O(N) as we are storing each element in the hashmap**\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        for(int x: tasks){\\n            mp[x]++;\\n        }\\n        \\n        for(auto x: mp){\\n            //if the occurence of any difficulty is only 1 then there is no chance that the task can be done so we will simply return -1\\n            if(x.second == 1){\\n                return -1;\\n            }\\n            \\n            else{\\n                //as we are moving greedily so we will try to minimize the rounds so firstly we will prefer to complete the tasks in the group of three\\n                int rem = x.second%3;\\n                int usedrounds = x.second/3;\\n                ans+=usedrounds;\\n                \\n                //when we divide a number by 3  then the possible remainders can be 0 1 or 2\\n                if(rem == 1){\\n                    //for removing the last entry of the 3 so that remainder will now be 1 + 3\\n                    ans-=1;\\n                    \\n                    //if now the remainder is 4 then we can do it in the group of 2 2 \\n                    ans+=2;\\n                }\\n                \\n                else if(rem == 2){\\n                    //if the remainder is 2 then that level can be completely in one round by doing 2 tasks\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        for(int x: tasks){\\n            mp[x]++;\\n        }\\n        \\n        for(auto x: mp){\\n            //if the occurence of any difficulty is only 1 then there is no chance that the task can be done so we will simply return -1\\n            if(x.second == 1){\\n                return -1;\\n            }\\n            \\n            else{\\n                //as we are moving greedily so we will try to minimize the rounds so firstly we will prefer to complete the tasks in the group of three\\n                int rem = x.second%3;\\n                int usedrounds = x.second/3;\\n                ans+=usedrounds;\\n                \\n                //when we divide a number by 3  then the possible remainders can be 0 1 or 2\\n                if(rem == 1){\\n                    //for removing the last entry of the 3 so that remainder will now be 1 + 3\\n                    ans-=1;\\n                    \\n                    //if now the remainder is 4 then we can do it in the group of 2 2 \\n                    ans+=2;\\n                }\\n                \\n                else if(rem == 2){\\n                    //if the remainder is 2 then that level can be completely in one round by doing 2 tasks\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957459,
                "title": "simple-python-solution-with-explanation-dictionary-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        tasks_dict = defaultdict(int)\\n        for i in range(len(tasks)):\\n            tasks_dict[tasks[i]] += 1\\n        \\n        min_tasks = 0\\n        for i in tasks_dict:\\n            if tasks_dict[i] <= 1:\\n                # if there is 0 or 1 tasks for a difficulty level, it is not possible to complete task\\n                return -1\\n            else:\\n                # anything above 2, it is possible to complete tasks\\n                # to keep rounds to a minimum, we will try to complete 3 tasks in a single round as much as possible\\n                # hence \\n                # 6 tasks - 2 rounds - [3,3]\\n                # 7 tasks - 3 rounds - [3,2,2]\\n                # 8 tasks - 3 rounds - [3,3,2]\\n                # 9 tasks - 3 rounds - [3,3,3]\\n                # 10 tasks - 4 rounds - [3,3,2,2]\\n                # we can generalise the formula as:\\n                min_tasks += int((tasks_dict[i] + 2)/3)\\n                \\n        return min_tasks\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        tasks_dict = defaultdict(int)\\n        for i in range(len(tasks)):\\n            tasks_dict[tasks[i]] += 1\\n        \\n        min_tasks = 0\\n        for i in tasks_dict:\\n            if tasks_dict[i] <= 1:\\n                # if there is 0 or 1 tasks for a difficulty level, it is not possible to complete task\\n                return -1\\n            else:\\n                # anything above 2, it is possible to complete tasks\\n                # to keep rounds to a minimum, we will try to complete 3 tasks in a single round as much as possible\\n                # hence \\n                # 6 tasks - 2 rounds - [3,3]\\n                # 7 tasks - 3 rounds - [3,2,2]\\n                # 8 tasks - 3 rounds - [3,3,2]\\n                # 9 tasks - 3 rounds - [3,3,3]\\n                # 10 tasks - 4 rounds - [3,3,2,2]\\n                # we can generalise the formula as:\\n                min_tasks += int((tasks_dict[i] + 2)/3)\\n                \\n        return min_tasks\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956480,
                "title": "detailed-math-explanation-python-o-n-hash-map-both-beats-100",
                "content": "First, we need to know the frequency of each number, so using hash map is a good choice, run time will be O(N). If we use .sort() then go through the list, the run time will increase to O(NlogN). After we knowing the frequency (let\\'s denote it as **n**) of each number, we can get the minimum round to complete the process by solving the following\\n\\n![image](https://assets.leetcode.com/users/images/9b031e81-883b-47fe-8b78-b18d87c05299_1650183614.7385616.png)\\n\\nWe can write a function **solve**.  Want to get the minimum of **x+y** under the contrains, we can see that there are some trivial cases.  They are the followings:\\n1. **n \\u2261 0 (mod 3)**, n is a multiple of 3, we can just return **n // 3** \\n2.  **n = 2**, return 1 immediately\\n3.  **n = 1**, there is no solution then return -1\\n\\nAfter the easy cases, we get into the harder and the last case, that is  **n > 1 *and* n is not multiple of 3**. \\nLet\\'s see a useful fact, **gcd(2,3) = 1** implies the diophantine equation **2x + 3y = n** for **n > 1** **always has non-negative solution**.\\nNow we can let the **result = n // 2 and y = n // 3** and do the iteration from **n // 3** to **0**, when gets **(n - 3y) \\u2261 0 (mod 2)** in the iteration process, we can stop then return **y + (n - 3y) // 2**. If there is no a such **y**, we can just return the **result**\\n\\n```\\ndef solve(n):\\n    if (n % 3 == 0):\\n        return n // 3\\n    if (n == 2):\\n        return 1\\n    if (n == 1):\\n        return -1\\n    three_count = n // 3 # y\\n    res = n // 2 # result\\n    while(n - 3*three_count < n):\\n        if ((n - 3*three_count) % 2 == 0):\\n            res = three_count + (n - 3*three_count) // 2\\n            break\\n        three_count -= 1\\n    return res\\n```\\n\\nBy adding the minimum rounds for each numbers, we can get the desired result\\n**The final code**\\n```\\nclass Solution(object):\\n    def minimumRounds(self, tasks):\\n        \"\"\"\\n        :type tasks: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dic = {}\\n        for num in tasks:\\n            if num in dic:\\n                dic[num] += 1\\n            else:\\n                dic[num] = 1\\n        \\n        res = 0\\n        for i in dic:\\n            if (solve(dic[i]) == -1):\\n                return -1\\n            else:\\n                res += solve(dic[i])\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef solve(n):\\n    if (n % 3 == 0):\\n        return n // 3\\n    if (n == 2):\\n        return 1\\n    if (n == 1):\\n        return -1\\n    three_count = n // 3 # y\\n    res = n // 2 # result\\n    while(n - 3*three_count < n):\\n        if ((n - 3*three_count) % 2 == 0):\\n            res = three_count + (n - 3*three_count) // 2\\n            break\\n        three_count -= 1\\n    return res\\n```\n```\\nclass Solution(object):\\n    def minimumRounds(self, tasks):\\n        \"\"\"\\n        :type tasks: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dic = {}\\n        for num in tasks:\\n            if num in dic:\\n                dic[num] += 1\\n            else:\\n                dic[num] = 1\\n        \\n        res = 0\\n        for i in dic:\\n            if (solve(dic[i]) == -1):\\n                return -1\\n            else:\\n                res += solve(dic[i])\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955669,
                "title": "c-concise-solution",
                "content": "The trick to this problem is realizing that the solution is to group all equal numbers, and for each group just divide by 3 and add that to the result. If you do it on paper you can see the pattern form.\\n```\\npublic int MinimumRounds(int[] tasks) {\\n\\tvar freq = tasks.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\t// group\\n\\tif (freq.Any(x => x.Value < 2)) // Check if invalid\\n\\t\\treturn -1; \\n\\tint result = 0;\\n\\tforeach (var kvp in freq) \\n\\t\\tresult += (int)Math.Ceiling((decimal)kvp.Value / (decimal)3);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MinimumRounds(int[] tasks) {\\n\\tvar freq = tasks.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\t// group\\n\\tif (freq.Any(x => x.Value < 2)) // Check if invalid\\n\\t\\treturn -1; \\n\\tint result = 0;\\n\\tforeach (var kvp in freq) \\n\\t\\tresult += (int)Math.Ceiling((decimal)kvp.Value / (decimal)3);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955550,
                "title": "c-hashmap-dp-clean-code",
                "content": "```\\n int minimumRounds(vector<int>& tasks) {\\n        \\n        // We can do 2 task or 3 tasks \\n        int n=tasks.size();\\n        unordered_map<int , int> mp;\\n        int max_count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            mp[tasks[i]]++;\\n            max_count=max(max_count , mp[tasks[i]]);\\n        }\\n        \\n        vector<int> dp(100001);\\n        dp[0]=0;\\n        dp[1]=0;\\n        \\n        dp[2]=1;\\n        dp[3]=1;\\n        dp[4]=2;\\n        \\n        for(int i=5;i<=100000;i++)\\n        {\\n            dp[i]= 1 + min(dp[i-2] , dp[i-3]);\\n        }\\n        \\n        \\n        int ans=0;\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second==1)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans = ans + (long long )(dp[it->second]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int minimumRounds(vector<int>& tasks) {\\n        \\n        // We can do 2 task or 3 tasks \\n        int n=tasks.size();\\n        unordered_map<int , int> mp;\\n        int max_count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            mp[tasks[i]]++;\\n            max_count=max(max_count , mp[tasks[i]]);\\n        }\\n        \\n        vector<int> dp(100001);\\n        dp[0]=0;\\n        dp[1]=0;\\n        \\n        dp[2]=1;\\n        dp[3]=1;\\n        dp[4]=2;\\n        \\n        for(int i=5;i<=100000;i++)\\n        {\\n            dp[i]= 1 + min(dp[i-2] , dp[i-3]);\\n        }\\n        \\n        \\n        int ans=0;\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second==1)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans = ans + (long long )(dp[it->second]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955503,
                "title": "go-golang-time-o-n-log-n-163-ms-100-space-o-n-10-mb-100",
                "content": "```\\nfunc minimumRounds(tasks []int) int {\\n    result, count := 0, make(map[int]int)\\n\\n    for _, t := range tasks {\\n        count[t]++\\n    }\\n    for _, v := range count {\\n        for v > 0 {\\n            switch {\\n            case v % 3 == 0:\\n                result, v = result + v / 3, 0\\n            case v > 4:\\n                result++\\n                v -= 3\\n            case v % 2 == 0:\\n                result, v = result + v / 2, 0\\n            case v == 1:\\n                return -1\\n            }\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumRounds(tasks []int) int {\\n    result, count := 0, make(map[int]int)\\n\\n    for _, t := range tasks {\\n        count[t]++\\n    }\\n    for _, v := range count {\\n        for v > 0 {\\n            switch {\\n            case v % 3 == 0:\\n                result, v = result + v / 3, 0\\n            case v > 4:\\n                result++\\n                v -= 3\\n            case v % 2 == 0:\\n                result, v = result + v / 2, 0\\n            case v == 1:\\n                return -1\\n            }\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955484,
                "title": "easy-hashmap-o-n-explained-using-dry-run",
                "content": "If you like it, pls **Upvote** :)\\n\\n## Code:\\n\\tclass Solution {\\n\\t\\tpublic int minimumRounds(int[] tasks) {\\n\\t\\t    // Create & Update HashMap\\n\\t\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor(int task : tasks){\\n\\t\\t\\t\\tif(! map.containsKey(task)){ map.put(task, 1); }\\n\\t\\t\\t\\telse{ map.put(task, map.get(task)+1); }\\n\\t\\t\\t}\\t\\t\\t\\n\\t\\t\\tint rounds = 0;\\n\\t\\t\\tfor(Map.Entry entry : map.entrySet()){                      // traverse hashmap\\n\\t\\t\\t\\tint val = (int) entry.getValue();\\n\\t\\t\\t\\tif(val == 1){ return -1; }                              // if any val == 1, just return -1\\n\\t\\t\\t\\tif(val >= 3){                                           // first check, if val >= 3        \\n\\t\\t\\t\\t\\trounds += val / 3;\\n\\t\\t\\t\\t\\tif(val % 3 != 0){ rounds += 1; }                    // if val % 3 != 0.  e.g.  4, 5, 7, 8, 10, 11........so on\\n\\t\\t\\t\\t}else if(val == 2){ rounds += 1; }\\n\\t\\t\\t}\\n\\t\\t\\treturn rounds;\\n\\t\\t}\\n\\t}\\n\\n## Dry Run:\\n\\tInput = [2,2,3,3,2,4,4,4,4,4]\\n\\tSteps:\\n\\tmap: \\n\\t\\t2 : 3\\n\\t\\t3 : 2\\n\\t\\t4 : 5\\n\\t\\t\\n\\tNow,\\t\\n\\t2 : 3\\n\\t\\trounds: 1\\n\\t3 : 2\\n\\t\\trounds: 2\\n\\t4 : 5\\n\\t\\trounds: 4\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked it, pls **Upvote** :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minimumRounds(int[] tasks) {\\n\\t\\t    // Create & Update HashMap\\n\\t\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor(int task : tasks){\\n\\t\\t\\t\\tif(! map.containsKey(task)){ map.put(task, 1); }",
                "codeTag": "Java"
            },
            {
                "id": 1955434,
                "title": "python-counter-method",
                "content": "\\'\\'\\'\\nfrom collections import Counter\\n\\nclass Solution:\\n\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        task_ct = Counter(tasks)\\n\\n\\t\\t# Since has to be 2 or 3 at a time, any occurrence of 1 will return -1\\n        if 1 in task_ct.values():\\n            return(-1)\\n\\n        output = 0\\n\\n        for i in task_ct.values():\\n\\t\\t\\n\\t\\t\\t# 3 at a time is the quickest\\n            this_round = i//3\\n\\t\\t\\t\\n\\t\\t\\t# If there\\'s a leftover 2, it counts as well\\n\\t\\t\\t# If there\\'s a leftover 1, it won\\'t affect the situation\\n\\t\\t\\t#     we can just \"borrow\" 1 from any of the 3 so there are two 2s\\n            if i%3 != 0:\\n                this_round += 1\\n            output += this_round\\n\\n        return(output)\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\nfrom collections import Counter\\n\\nclass Solution:\\n\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        task_ct = Counter(tasks)\\n\\n\\t\\t# Since has to be 2 or 3 at a time, any occurrence of 1 will return -1\\n        if 1 in task_ct.values():\\n            return(-1)\\n\\n        output = 0\\n\\n        for i in task_ct.values():\\n\\t\\t\\n\\t\\t\\t# 3 at a time is the quickest\\n            this_round = i//3\\n\\t\\t\\t\\n\\t\\t\\t# If there\\'s a leftover 2, it counts as well\\n\\t\\t\\t# If there\\'s a leftover 1, it won\\'t affect the situation\\n\\t\\t\\t#     we can just \"borrow\" 1 from any of the 3 so there are two 2s\\n            if i%3 != 0:\\n                this_round += 1\\n            output += this_round\\n\\n        return(output)\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1955358,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> m;\\n        set<int> s;\\n        int n=tasks.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[tasks[i]]++;\\n            s.insert(tasks[i]);\\n        }\\n        \\n        int ans=0;\\n        for(auto it=s.begin();it!=s.end();it++)\\n        {\\n            if(m[*it]==1) return -1;\\n            ans+=m[*it]/3;\\n            if(m[*it]%3) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        map<int,int> m;\\n        set<int> s;\\n        int n=tasks.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[tasks[i]]++;\\n            s.insert(tasks[i]);\\n        }\\n        \\n        int ans=0;\\n        for(auto it=s.begin();it!=s.end();it++)\\n        {\\n            if(m[*it]==1) return -1;\\n            ans+=m[*it]/3;\\n            if(m[*it]%3) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958259,
                "title": "beats-100-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumRounds(_ tasks: [Int]) -> Int {\\n        var map = [Int: Int]()\\n        var count = 0\\n            \\n        for item in tasks {\\n            map[item, default: 0] += 1\\n        }\\n        for (_, value) in map {\\n            if value < 2 {\\n                return -1\\n            }\\n            if value%3 == 0 {\\n                count += value/3\\n            } else {\\n                count += value/3+1\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumRounds(_ tasks: [Int]) -> Int {\\n        var map = [Int: Int]()\\n        var count = 0\\n            \\n        for item in tasks {\\n            map[item, default: 0] += 1\\n        }\\n        for (_, value) in map {\\n            if value < 2 {\\n                return -1\\n            }\\n            if value%3 == 0 {\\n                count += value/3\\n            } else {\\n                count += value/3+1\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808074,
                "title": "c-easy-to-understand-3x-2y-freq",
                "content": "```\\n\\n pair<int, int> check(int num)\\n    {\\n\\n        for (int i = num / 3 + 1; i >= 0; i--)\\n        {\\n            for (int j = num / 2 + 1; j >= 0; j--)\\n            {\\n\\n                if (3 * i + 2 * j == num)\\n                {\\n                    return {i, j};\\n                }\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        int n = tasks.size();\\n        map<int, int> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n        int ans = 0;\\n\\n        for (auto itr : mp)\\n        { \\n            pair<int, int> p = check(itr.second);\\n            if (p.first != -1 and p.second != -1)\\n            {\\n                ans += p.first + p.second;\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n\\n pair<int, int> check(int num)\\n    {\\n\\n        for (int i = num / 3 + 1; i >= 0; i--)\\n        {\\n            for (int j = num / 2 + 1; j >= 0; j--)\\n            {\\n\\n                if (3 * i + 2 * j == num)\\n                {\\n                    return {i, j};\\n                }\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n    int minimumRounds(vector<int> &tasks)\\n    {\\n        int n = tasks.size();\\n        map<int, int> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[tasks[i]]++;\\n        }\\n        int ans = 0;\\n\\n        for (auto itr : mp)\\n        { \\n            pair<int, int> p = check(itr.second);\\n            if (p.first != -1 and p.second != -1)\\n            {\\n                ans += p.first + p.second;\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3498291,
                "title": "java-solution-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();\\n\\n       if (tasks.length <2 ) return -1;\\n\\n        for (int i=0; i < tasks.length; i++){\\n            int task = tasks[i];\\n            Integer count = freq.get(task);\\n            if (count == null){\\n                count = 0;\\n            }\\n            freq.put(task,count+1);\\n        }\\n        \\n        int numRounds = 0;\\n\\n        for (int key : freq.keySet()){\\n            int round = getRounds(freq.get(key));\\n            \\n            if (round == 0) return -1;\\n\\n            numRounds += round;\\n\\n        }\\n        return numRounds;\\n    }\\n\\n    private int getRounds(int frequency){\\n        if (frequency < 2) return 0;\\n        if (frequency%3 ==0){\\n            return frequency/3;\\n        } else if (frequency%3 == 1){\\n            return (frequency-1)/3 + 1;\\n        } else {\\n            return (frequency-2)/3 + 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();\\n\\n       if (tasks.length <2 ) return -1;\\n\\n        for (int i=0; i < tasks.length; i++){\\n            int task = tasks[i];\\n            Integer count = freq.get(task);\\n            if (count == null){\\n                count = 0;\\n            }\\n            freq.put(task,count+1);\\n        }\\n        \\n        int numRounds = 0;\\n\\n        for (int key : freq.keySet()){\\n            int round = getRounds(freq.get(key));\\n            \\n            if (round == 0) return -1;\\n\\n            numRounds += round;\\n\\n        }\\n        return numRounds;\\n    }\\n\\n    private int getRounds(int frequency){\\n        if (frequency < 2) return 0;\\n        if (frequency%3 ==0){\\n            return frequency/3;\\n        } else if (frequency%3 == 1){\\n            return (frequency-1)/3 + 1;\\n        } else {\\n            return (frequency-2)/3 + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472861,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        std::ios::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        std::cout.tie(nullptr);\\n        int res = 0 ; \\n        unordered_map<int,int> m ; \\n        for(auto x:tasks)\\n        m[x]++ ; \\n\\n        for(auto x:m)\\n        {\\n            if(x.second==1)\\n            return -1;\\n            if(x.second%3==1)\\n            {\\n                res += (x.second-4)/3 +2;\\n            }\\n            else  res += x.second/3 + (x.second%3)/2;\\n\\n\\n        }\\n\\n\\n        return res; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) \\n    {\\n        std::ios::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        std::cout.tie(nullptr);\\n        int res = 0 ; \\n        unordered_map<int,int> m ; \\n        for(auto x:tasks)\\n        m[x]++ ; \\n\\n        for(auto x:m)\\n        {\\n            if(x.second==1)\\n            return -1;\\n            if(x.second%3==1)\\n            {\\n                res += (x.second-4)/3 +2;\\n            }\\n            else  res += x.second/3 + (x.second%3)/2;\\n\\n\\n        }\\n\\n\\n        return res; \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3133221,
                "title": "1000-iq-solution",
                "content": "So long as difficulty d occurs more than once, all tasks of that difficulty can be completed in at best `ceil(frequency of d / 3)` operations.\\nThink about it.:)\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn minimum_rounds(tasks: Vec<i32>) -> i32 {\\n        let mut map = HashMap::new();\\n        let mut ans = 0;\\n\\n        for task in tasks {\\n            let val = map.get_mut(&task);\\n\\n            if let Some(v) = val {\\n                *v += 1;\\n            } else {\\n                map.insert(task, 1);\\n            }\\n        }\\n\\n        for count in map.into_values() {\\n            if count == 1 {\\n                return -1;\\n            }\\n            ans += (count + 2) / 3;\\n        }\\n\\n        ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn minimum_rounds(tasks: Vec<i32>) -> i32 {\\n        let mut map = HashMap::new();\\n        let mut ans = 0;\\n\\n        for task in tasks {\\n            let val = map.get_mut(&task);\\n\\n            if let Some(v) = val {\\n                *v += 1;\\n            } else {\\n                map.insert(task, 1);\\n            }\\n        }\\n\\n        for count in map.into_values() {\\n            if count == 1 {\\n                return -1;\\n            }\\n            ans += (count + 2) / 3;\\n        }\\n\\n        ans\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3064993,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumRounds(int[] tasks) {\\n        Dictionary<int,int> dict = new Dictionary<int,int>();\\n        int result = 0;\\n        foreach(int item in tasks){\\n            if(dict.ContainsKey(item)){\\n                dict[item]++;\\n            }else{\\n                dict.Add(item,1);\\n            }\\n        }\\n        foreach(var item in dict){            \\n            if(item.Value < 2){\\n                return -1;\\n            }\\n            result += (item.Value + 2) / 3;\\n        }    \\n        return result;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumRounds(int[] tasks) {\\n        Dictionary<int,int> dict = new Dictionary<int,int>();\\n        int result = 0;\\n        foreach(int item in tasks){\\n            if(dict.ContainsKey(item)){\\n                dict[item]++;\\n            }else{\\n                dict.Add(item,1);\\n            }\\n        }\\n        foreach(var item in dict){            \\n            if(item.Value < 2){\\n                return -1;\\n            }\\n            result += (item.Value + 2) / 3;\\n        }    \\n        return result;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015660,
                "title": "easy-and-simple-java-solution-by-sorting-the-array",
                "content": "\\n```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);        //sort the Array\\n        int round=0;\\n        int count=0;\\n        for(int i=0;i<tasks.length-1;i++)\\n        {\\n            if(tasks[i]==tasks[i+1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count++;\\n                if(count==2||count==3)\\n                {\\n                    round++;\\n                }\\n                else if(count>3)\\n                {\\n                    int dif=count/3;\\n                    round=round+dif;\\n                    if(count%3==1||count%3==2)\\n                        round++;\\n                }\\n                else //count==1;\\n                    return -1;\\n                count=0;\\n            }\\n        }\\n\\t\\t//Now check for last element\\n        if(count>0)\\n            {\\n                count++;\\n                if(count==2||count==3)\\n                {\\n                    round++;\\n                }\\n                else if(count>3)\\n                {\\n                    int dif=count/3;\\n                    round=round+dif;\\n                    if(count%3==1||count%3==2)\\n                        round++;\\n                }\\n                else //count==1;\\n                    return -1;\\n        }\\n        if(tasks.length==1)\\n            return -1;\\n        if(tasks[tasks.length-1]!=tasks[tasks.length-2])\\n            return -1;\\n        else\\n            return round;\\n    }\\n}\\n\\n```\\nTime Complexity- O(N)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRounds(int[] tasks) {\\n        Arrays.sort(tasks);        //sort the Array\\n        int round=0;\\n        int count=0;\\n        for(int i=0;i<tasks.length-1;i++)\\n        {\\n            if(tasks[i]==tasks[i+1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count++;\\n                if(count==2||count==3)\\n                {\\n                    round++;\\n                }\\n                else if(count>3)\\n                {\\n                    int dif=count/3;\\n                    round=round+dif;\\n                    if(count%3==1||count%3==2)\\n                        round++;\\n                }\\n                else //count==1;\\n                    return -1;\\n                count=0;\\n            }\\n        }\\n\\t\\t//Now check for last element\\n        if(count>0)\\n            {\\n                count++;\\n                if(count==2||count==3)\\n                {\\n                    round++;\\n                }\\n                else if(count>3)\\n                {\\n                    int dif=count/3;\\n                    round=round+dif;\\n                    if(count%3==1||count%3==2)\\n                        round++;\\n                }\\n                else //count==1;\\n                    return -1;\\n        }\\n        if(tasks.length==1)\\n            return -1;\\n        if(tasks[tasks.length-1]!=tasks[tasks.length-2])\\n            return -1;\\n        else\\n            return round;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003319,
                "title": "c-daily-challenge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n = tasks.size() ;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++ ;\\n        }\\n        int c=0;\\n        for(auto it : mp){\\n            if(it.second==1) return -1;\\n            if(it.second % 3==0){\\n                c+=it.second/3 ;\\n            }\\n            else{\\n                c+=it.second/3 + 1;\\n            }\\n        }\\n      return c ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRounds(vector<int>& tasks) {\\n        int n = tasks.size() ;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[tasks[i]]++ ;\\n        }\\n        int c=0;\\n        for(auto it : mp){\\n            if(it.second==1) return -1;\\n            if(it.second % 3==0){\\n                c+=it.second/3 ;\\n            }\\n            else{\\n                c+=it.second/3 + 1;\\n            }\\n        }\\n      return c ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003071,
                "title": "javascript-time-space-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/e56b4b4c-89f7-44e6-8f83-abe0a5ef624d_1672924306.9503403.png)\\n\\n\\n\\nText from the image: \\nWe can immedietly `return -1` if any of the frequencies is `1`.\\n\\nIf the frequency is `2`, simply increment the steps by one.\\n\\nIf we divide by `3` these numbers `(6, 7, 8)`\\nwe get following remainders: `6 % 3 = 0, 6 % 7 = 1, 6 % 8 = 2`\\n\\nSo, for `6`, we increment steps by 2 `(6 / 3 = 2)` since 6 is basically `3 + 3`\\n\\nFor `7`, we have a leftover. But `7` is just `2 + 2 + 3` and `7 / 3 = 2.333`\\nso if we take just the whole number part of the result `(2)` and add `1` we\\nget the size of our group aka steps.\\n\\nIn case of an 8 which is basically `3 + 3 + 2` and `8 / 3 = 2.6666` we have\\nsimilar case. Just take the whole number `(2)` and add 1 to it.\\n\\nThus we end up with the following formula\\n\\nIf number is divisible by 3, add `frequency / 3 `to steps\\notherwise, get the whole number part of `frequency / 3 `and add `1` to it\\n\\n> NB! If we divide by 2, we will end up with higher step count\\n\\n---\\n\\n***Fun mini game**: think of a number and try to use minimum number of 2s and 3s to get to it :)*\\n\\n---\\n# Complexity\\n- Time complexity: O(N); \\n    - To get frequiency is O(N) the looping to get the steps is also O(N). Getting an item from a map via key is O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n    - We are creating a frequency map so extra space is allocated\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    let map = {} // freq map\\n    let steps = 0 // steps result\\n\\n    for (let i of tasks) {\\n        if (map[i] !== undefined) {\\n            map[i]++\\n        } else {\\n            map[i] = 1\\n        }\\n    }\\n\\n    for (let i in map) {\\n        if (map[i] === 1) return -1\\n        else if (map[i] === 2) steps++\\n        else if (map[i] > 2) {\\n            if (map[i] % 3 > 0) steps += Math.trunc(map[i] / 3) + 1\\n            else steps += map[i] / 3\\n        }\\n    }\\n    return steps\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    let map = {} // freq map\\n    let steps = 0 // steps result\\n\\n    for (let i of tasks) {\\n        if (map[i] !== undefined) {\\n            map[i]++\\n        } else {\\n            map[i] = 1\\n        }\\n    }\\n\\n    for (let i in map) {\\n        if (map[i] === 1) return -1\\n        else if (map[i] === 2) steps++\\n        else if (map[i] > 2) {\\n            if (map[i] % 3 > 0) steps += Math.trunc(map[i] / 3) + 1\\n            else steps += map[i] / 3\\n        }\\n    }\\n    return steps\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1740459,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740590,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1741055,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740503,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740448,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740599,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1735490,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740415,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740413,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740637,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740459,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740590,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1741055,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740503,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740448,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740599,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1735490,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740415,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740413,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740637,
                "content": [
                    {
                        "username": "calm27",
                        "content": "at least the statement is clear today"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Msey](/Msey)  hahahaha"
                    },
                    {
                        "username": "Msey",
                        "content": "every day is difficult but it\\'s own way"
                    },
                    {
                        "username": "Msey",
                        "content": "lol, totally"
                    },
                    {
                        "username": "sagardambal3",
                        "content": "Hahaha True calm27 :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "To solve this problem, think about all the possible constraints that has to be included\n\nFirstly, if the vector contains only one element, it'll return -1\nSecondly, if any of the elements occur only once, still it returns -1\nThirdly, if the element occurs twice or thrice, it will need 1 step\n\nTo start with, we have to initialize a counter variable with 0 and create an empty vector to store the occurrences of each element. As we can see, not all the given vectors are sorted, so sorting the vector will make the process easier.\n\nNow we will put a condition to satisfy the first constraint, i.e, if the size of the vector is equals to 1, we will return -1\n\nThen, we will create a for loop that goes from 1 to size-1 and count the recurrence of each element. To do so, we will check the ith element equals (i-1)th element. If equal, counter continues incrementing, if not the counter value gets stored in the created vector and counter updates to 1.\n\nAs the for loop continues till size-1, the counter value for last element will not get stored in the vector so, we will store the last counter value in the vector manually.\n\nNow, update the counter to 0. This will save space as we need counter for next step.\n\nAgain, initiate a for loop that goes from 0 to the size of the counter vector. Here we will check different possibilities for input - \n1. if the current ith element = 1, return -1\n2. if the current ith element = 2 or 3, increment the counter\n3. if the current ith element > 3, increment the counter by (ith element + 2) / 3\n\nThe above mentioned third step is such because:\nWe want the ceil value of the (ith element/3), that's why we are using a formula that takes ceil value for a divided number. (Note we can directly use the ceil function)\n\nCeil function can be used here directly as suggested in the replies: ans+=ceil((double)(x.second)/3);\n\nExample: We have 5 as ith element which is greater than 3, if we follow the logic first 3 elements will get stored and then another two elements will get stored. So the counter increments twice. But if we divide 5/3, we get 1 which is not the correct result. So to get the upper value for 5/3, we use the formula (5+3-1)/3 and here 3 is fixed for all values so we get a formula (x-2)/3 where x is the ith element.\n\nThat is all inside the for loop. All we need to do is now return the counter value.\n\nSolution link for better understanding: [https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995028/simple-and-easy-code-conceptual-solution-c/?orderBy=newest_to_oldest)\n\nI hope it helps :)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@nt34542](/nt34542) I edited the solution. Thanks for suggesting!"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "[@tonybuidn](/tonybuidn) I edited the discussion. Thanks for pointing out the mistake!"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "x-2/3 is different from (x-2)/3 :)\\nBut the formula that we want to get is (x + 2)/3, not x-2/3 or (x-2)/3"
                    },
                    {
                        "username": "nt34542",
                        "content": "   ans+=ceil((double)(x.second)/3);\\nwe can do this to resolve what you said."
                    },
                    {
                        "username": "ayush__88",
                        "content": "# Easy to understand, Beginner Friendly approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/ca029011-b3cf-4b23-8a3e-a20f7c675b56_1672819112.4886549.png)\\n\\nIn the picture above, we can see the minimum number of rounds for completing all tasks of same difficulty level (doing only 2 or 3 tasks in each round).\\nSo, if there\\'s a task which has a unique difficulty level (occured only once in the array `tasks[]`), we can\\'t remove it.\\n\\nIf there are 5 tasks with same difficulty level, we can do 2 tasks in 1 round and rest of 3 in next round. Thus, min rounds required for 5 tasks with same difficulty level = 2.\\n\\n\\nfor detailed solution,  [visit this](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996805/very-easy-to-understand-beginner-friendly-c-solution-with-intuition/)\\n\\nPlease Upvote :)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ayush Singh](/ayush__88) hah! I love how you have extra large font in image to explain to even those that have small doubts left. Nice!!"
                    },
                    {
                        "username": "six519",
                        "content": "this should be easy..."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "[@BLOCKS](/BLOCKS) Thank you so much, I realized that my original idea was too complicated and I could have actually made it simpler!\\nThe key I found was that I didn\\'t know \"count += (value + 2) // 3\" and applying this equation made the program very concise."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "[@qazFatNerd](/qazFatNerd)  Well using 2 sets is costly, I recommend you to learn Counter in python, it will come in handy in many problems"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I use a dict and two sets, it\\'s not easy to me..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I disagree, while it is easy to solve, it can be tricky to do it fast enough. You have to think of using a hashMap or something similar. This is not very difficult. But compared to the easy problems from the last couple of days it\\'s definitely more tricky. I haven\\'t used hashMap that often, so this took me a while. I wrote two solutions that were too slow first"
                    },
                    {
                        "username": "shikharscout",
                        "content": "I agree"
                    },
                    {
                        "username": "k2bilimo",
                        "content": "The only circumstance we return -1 is if there\\'s only 1 task within a given difficulty level."
                    },
                    {
                        "username": "dadick",
                        "content": "Can someone please explain why  `result += (count + 2)/3` works? Sorry if it\\'s a dumb question but I just don\\'t understand."
                    },
                    {
                        "username": "gpta_me",
                        "content": "because if we add 2 then no effect on round\\nif count <2 then we firstly handle\\nfor(auto x:mp)\\n        {\\n            if(x.second<2)return -1;\\n        }\\nif count>=2\\n for example if count == 4\\nthen we need 2 round to complete this task\\nif we add 2 with 4 then count == 6\\nnow we also need 2 round to complete this task\\n "
                    },
                    {
                        "username": "nt34542",
                        "content": "Instead you can do this\\n   ans+=ceil((double)(x.second)/3);"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "I borrowed this explanation: \\nIf the frequency of a number is only 1, then it is not possible to solve this question, so we return -1.\\nIf the frequency is directly divided by 3, then we return the frequency/3.\\nIf the remainder of dividing the number by 3 is 1 or 2 then, again there can be two cases:\\nIf remainder is 1, i.e, lets take 7 frequency, then o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"o\", i.e, one o is left alone so the solution is to break the second last group into two parts of 2 and 1 so that it becomes like: \"ooo\" \"oo\" \"oo\", i.e, one is added to the division by 3.\\nIf remainder is 2, i.e, lets take 8 frequency, then o o o o o o o o the groups are something like this \"ooo\" \"ooo\" \"oo\", i.e, two o are left so the solution is to just add 1,i.e, one group of two to the solution.\\nFor calculating the frequency we have to use the hashmap."
                    },
                    {
                        "username": "dadick",
                        "content": "[@ajaygonepuri](/ajaygonepuri) I see. Thank you!"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "you can formulate the total tasks as => n = 2*a + 3*b\\nHence, whenever you add 2 to any count and than divide it by 3 it gets divided into the max possible values of a and b in the above equation."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "I did the problem using HashMap which took almost 35ms whereas sorting array , counting occurrences  then solving took 10ms.\\nisn\\'t that O(n*log(n)) whereas HashMap is O(n)?\\nwhy does performance differ this much?"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "[@Finesse](/Finesse) great explanation thank you"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because Big O only shows how the execution time increase when the input size increases. It doesn't consider the execution complexity that doesn't depend on the input size. HashMap is slow because it makes many calculations under the hood. While sorting is just swapping bytes in memory.\n\nLet's say that one HashMap operation takes `10μs` of time and one swapping operation takes `1μs`. So the real time of the HashMap solution will be `n*10μs` and the real time of the sorting solution will be `n*log(n)*1μs`. If `n` is `10⁵`, then the HashMap time will be `1000ms` and the sorting time will be `500ms`.\n\nConclusion: don't neglect the complexity of individual `O(1)` operations."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "[@Surendra](/SurendraChakravarthula) See the constraints.... 1<=tasks[i]<=10^9\nwhich means your hashmap will have 10^9 iterations\nbut lets talk about task vector size \n1<=tasks.size()<=10^5 ---- This means that even after sorting -- O(N*logN) will still be less than 10^9"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "such a nice explanation , tbh I was about to  go and check submissions and learn , but I implemented on my own after your approach . Thanks"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula) Yes, at least on the given test cases. Hashmap gives 50% on time complexity, while array sorting ~95% all the time..."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "It\\'s not that simple. I suggest reading up no only hash maps, but on the implementation you are using. For this problem there should be no collisions as they keys are integers. However, that is something to consider for other problems.\\n\\nAlso look up \"stack vs heap performance\".  Accessing data on the stack is always faster than the heap. There is also cache locality which comes into play.  These are all low level details which affect the runtime but not the time complexity of the algorithm. This is all important stuff to know."
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "accessing a hashmap has higher constant factors"
                    },
                    {
                        "username": "redocmi7",
                        "content": "[@SurendraChakravarthula](/SurendraChakravarthula)  Only for huge set of data or huge number of operations to be performed."
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@gaijinpunch](/gaijinpunch) so , hashmap method takes more time than the sorting method all the time?"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "[@Strinex92](/Strinex92)  I did those two methods in same programming language (java) which is why iam trying to check performance.."
                    },
                    {
                        "username": "gaijinpunch",
                        "content": "You\\'re paying for heap allocations. Speed differ from language to language, but all have to pay the penalty of the heap.  You generally need a huge set of data for the overhead of the hash map to pay off.  "
                    },
                    {
                        "username": "Strinex92",
                        "content": "i guess the \"ms\" varies from one programming language to another language. I did it using hashmap in java i got around 82ms. "
                    },
                    {
                        "username": "Kratos50",
                        "content": "In greedy we call this \"Activity Selection Problem\" for those wondering "
                    },
                    {
                        "username": "itsishu2",
                        "content": "thankyou so much [@Kratos50](/Afzal50)"
                    },
                    {
                        "username": "VKartik_0-03",
                        "content": "[@Afzal50](/Afzal50)  online / offline course??"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@Afzal50](/Afzal50) can you share what course is that?\\n"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "[@wtain](/wtain) thanks mate"
                    },
                    {
                        "username": "wtain",
                        "content": "[@christiangazzingan38](/christiangazzingan38) I think this could help: \\nhttps://www.studytonight.com/data-structures/activity-selection-problem#:~:text=The%20Activity%20Selection%20Problem%20is,a%20start%20and%20finish%20time.\\n\\n\\nBut this problem is different from ASP (and I think it is simpler) - as long as we have freedom to start them at any time, but we have different constraints - executing 2 or 3 of the same difficulty (of the same type actually) in parallel."
                    },
                    {
                        "username": "Kratos50",
                        "content": "[@CarlosBalladares](/CarlosBalladares) i am doing a data structure course and it covers everything from basic to advance"
                    },
                    {
                        "username": "christiangazzingan38",
                        "content": "where can i find / learn more of this greedy thing?"
                    },
                    {
                        "username": "CarlosBalladares",
                        "content": "how do you learn these terms\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "another day of suffering"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can you solve in better than O(n) auxiliary space complexity?"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "You sure could by sorting the tasks first"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "[@Finesse](/Finesse) yepp, that is possible..\\n[@kriket](/kriket) Thanks for you responses.. It seems there is a trade for space and time complexity in this case as well.. \\nThanks!!\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Yes, `O(1)` is possible. Sort the input array in place. You\\'ll only need to store the start index of the current difficulty level."
                    },
                    {
                        "username": "close27",
                        "content": "[@Trojanhorse_](/Trojanhorse_) Yeah. Tradeoff for now."
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@kriket](/kriket) At the same time you are making the complexity of time to n*log(n)."
                    },
                    {
                        "username": "close27",
                        "content": "sure. https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/870869801/"
                    }
                ]
            },
            {
                "id": 1740857,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1740675,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1741997,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1741848,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1740891,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1740748,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1740559,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1855200,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1808911,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1745387,
                "content": [
                    {
                        "username": "sachinbaral02",
                        "content": "A medium problem today hmmm.... lemme grab my coffee first\\u2615."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@cswartzell](/cswartzell) Using a sorting method can do it in O(1) space but I don\\'t consider this a big win, since we are also ruining  the original list provided. Regarding time complexity for array vs hashmap. I think this debate will always come in such questions. As a thumb rule I avoid using a hashmap if the values are continuous since there can be an even better solution where we just initialize an array to all zeroes and use it just as a map, but due to memory constraints, it wont be wise to use it when range is >10^6. \\n\\nHaving said that, I don\\'t think this question is about that, it is just a simple question for number theory and any way should be fine so I don\\'t give much significance to \\'Beats %\\' as long as runtime is in sane limits."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Are than any easier mediums than this? I was trying to see what the trick might be... I guess there kind of is one if you note that sorting O(nlogn) for 10^5 is still smaller than 10^9 so sorting solutions are actually faster than hashmap solutions despite the worse Time Complexity. Plus using a sorting method you can do it with O(1) space. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sachin](/sachinbaral02) not really a medium, on the easy side of medium!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "No Need to put a **lot of condition**\\ntake map ...count the freq....check if map contain 1 or not \\nif not then just do `count += ceil(it.second/3.0);` \\nif yes `return -1;`"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@sarpalmadhav](/sarpalmadhav) could you please explain is bit more ."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dhvani](/Knight-03), as pointed out in some other comment, I think `(it.second + 2)/3` is much better than using ceil function as it avoids pointer arithmetic."
                    },
                    {
                        "username": "CarterMacLennan",
                        "content": "Think of how to handle 5 & 7 :) That was the step I was missing for my solution."
                    },
                    {
                        "username": "safinghoghabori65",
                        "content": "Can someone please post recursive/dp solution? (i know it will give tle but i want to know how can i do using recursion)"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871518370/ bro i did it but it was failing a testcase . you can have a look ."
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "Sort the array of tasks in ascending order.\\nIterate through each task and count how many tasks have the same value.\\nIf there is only one task with a particular value, return -1 since we cannot create any groups of 3 from these tasks.\\nOtherwise, add the number of full groups of 3 that can be created from the tasks with this value to the result.\\nIf there are any remaining tasks that cannot be included in a group of 3, increment the result by 1 to indicate that another round is needed to process these tasks.\\nReturn the total number of rounds needed to process all of the tasks."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "these easy-mid questions are the silence before the storm that LC is going to bring soon"
                    },
                    {
                        "username": "fengvang24",
                        "content": "bro don\\'t rain on my parade"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": ":) kill me"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "The intuition is quite simple, just store freq of elements and then think how to group the freq in 3 or 2 \\nHint: Grouping in 3 would result in lesser rounds"
                    },
                    {
                        "username": "tanayak",
                        "content": "Simple Map based solution\\n```class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        TreeMap<Integer, Integer> difficultyMap = new TreeMap<>();\\n\\n        for(int i = 0; i < tasks.length; i++) {\\n            difficultyMap.put(tasks[i], difficultyMap.getOrDefault(tasks[i], 0) + 1);\\n        }\\n\\n        int count = 0;\\n        while(!difficultyMap.isEmpty()) {\\n            Map.Entry<Integer, Integer> entry = difficultyMap.firstEntry();\\n            if(entry.getValue() < 2)\\n                return -1;\\n            else if(entry.getValue() == 2 || entry.getValue() == 3) {\\n                count++;\\n                difficultyMap.remove(entry.getKey());\\n            } else {\\n                int value = entry.getValue() - 3;\\n                if(value < 2) {\\n                    value = entry.getValue() - 2;\\n                }\\n                difficultyMap.put(entry.getKey(), value);\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n}```"
                    },
                    {
                        "username": "ArianLC",
                        "content": "// Javascript\\n```\\n/**\\n * @param {number[]} tasks\\n * @return {number}\\n */\\nvar minimumRounds = function(tasks) {\\n    const totalDifficulties = {};\\n    for (const task of tasks) {\\n      totalDifficulties[task] = (totalDifficulties[task] || 0) + 1;\\n    }\\n    let totalRoundsToComplete = 0;\\n    for (const total of Object.values(totalDifficulties)) {\\n      if (total === 1) {return -1;}\\n      const remainderThree = total % 3;\\n      if (remainderThree === 0) {\\n        totalRoundsToComplete += Math.floor(total / 3);\\n      } else {\\n        totalRoundsToComplete += Math.floor((total / 3)) + 1\\n      }\\n    }\\n    return totalRoundsToComplete;\\n};\\n```"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "This was my first Medium level question and I brute forced it without using HashMap in C++, and it was accepted with 1175 ms runtime, lol."
                    }
                ]
            },
            {
                "id": 1742018,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741993,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741886,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741769,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741740,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741651,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741602,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741581,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741577,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741569,
                "content": [
                    {
                        "username": "aminuolawale",
                        "content": "Well you only need to realise that \\n1. If an element occurs only once, the condition is violated\\n2. tasks of any difficulty level takes `ceil(no_occurences/3)` rounds.\\nWith this you have your solution."
                    },
                    {
                        "username": "user4037uh",
                        "content": "my 71st testcase is showing time limit exceeded can someone help its my 1st weeek on leetcode"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "same here, although mine was 75/79 case. I brute forced it by adding a loop counter. if the no. of loop exceeds 500, just print length of vector divided by count. The reason this worked is because my base logic was correct but slow and the later test cases had same count of occurrences for each task.  "
                    },
                    {
                        "username": "omi23",
                        "content": "Easiest medium questions I have ever seen."
                    },
                    {
                        "username": "MrSlend",
                        "content": "I keep getting time exceeded error when testing about 50,000 cases. Can anyone tell me what\\'s wrong?\\n\\nclass Solution {\\n    fun minimumRounds(tasks: IntArray):Int {\\n        var size = tasks.size;\\n        var arr = ArrayList<Int>();\\n        var store = 0;\\n        var result = 0;\\n        tasks.sort(); //sorts the array\\n\\n        for(i in 0..size-1){\\n            if(!arr.contains(tasks[i])){ \\n                arr.add(tasks[i]);\\n                store = occurences(tasks[i],tasks); //function\\n                if( store == -1) return -1;\\n                else result += store;\\n            }\\n        }\\n        \\n    return result;\\n    }\\n\\n    fun occurences(num:Int, t:IntArray):Int{\\n        var count = 0.0;\\n        for(i in 0..t.size-1){\\n            if(num == t[i])\\n                count++;\\n        }\\n        if (count==1.0)\\n            return -1;\\n        return Math.ceil(count/3.0).toInt();\\n    }\\n}"
                    },
                    {
                        "username": "deepeshsai1312",
                        "content": "i dont understand the question\\n"
                    },
                    {
                        "username": "rambabu135",
                        "content": "at first I filled whole my code with if else conditions.\\nat last I wrote for answers  for occurances from 1 to 16.\\nAnd magically I found the pattern. \\nThis question shows that pen and paper are really important while solving question even if you don\\'t know anything about question\\nstart writing the things on paper and question starts breaking into chunks."
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "    int minimumRounds(vector<int>& tasks) {\n        map<int,int>mp;\n        for(auto e : tasks) {\n            mp[e]++;\n        }\n        int counter=0;\n        for(auto p : mp){\n            if(p.second==1) return -1;\n            counter+=(p.second/3) + (bool)(p.second%3);\n        }\n        return counter;\n    }"
                    },
                    {
                        "username": "user3904Q",
                        "content": "For count(task[i]) % 3 == 2 and count(task[i]) % 3 == 1 the result is same, count//3 + 1 so :\\n\\nclass Solution:\\n    def minimumRounds(self, tasks: List[int]) -> int:\\n        counter = collections.Counter(tasks)\\n        ans = 0\\n        for k in counter:\\n            count = counter[k]\\n            if count < 2:\\n                return - 1\\n            if count % 3 == 0:\\n                ans += count//3\\n            else:\\n                ans += count//3 + 1\\n        return ans \\n                \\n\\n"
                    },
                    {
                        "username": "imankitg",
                        "content": "Me: Solved medium-level question in under 10 minutes\\nOthers comment: This should be an easy question"
                    },
                    {
                        "username": "adarsh301998",
                        "content": "Golang (O)N \\n `func minimumRounds(tasks []int) int {\\n    count := map[int]int{}\\n    for _, v := range tasks {\\n        data, ok := count[v]\\n        if ok {\\n            data++\\n        }else {\\n            data = 1\\n        }\\n        count[v] = data\\n    }\\n    round := 0\\n    fmt.Println(\"1\", count)\\n    for _, v := range count {\\n        if v == 1 {\\n            return -1\\n        }\\n        round += (v/3)\\n        if v%3 != 0 {\\n            round++\\n        }\\n    }\\n    return round\\n}`"
                    }
                ]
            },
            {
                "id": 1741530,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741482,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741479,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741465,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741403,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741386,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741344,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741296,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741265,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741111,
                "content": [
                    {
                        "username": "esper_desk",
                        "content": "The question looks complicated but all we need to understand is that any number greater than 1 can be split into rounds. If there is no task with difficulty level 1, then they can always be completed. We take as many 3\\'s as we can and remaining are used by 2\\'s. "
                    },
                    {
                        "username": "KalyanAmmisetty",
                        "content": "Every Number can be expressed as the sum of 2's and 3's except 1. so if we find the element frequency as 1 then we can return -1.\notherwise to reduce the cycles we will find a greedy way.\n1. we will find wheather it is multiple of 3 or not. if so we will increase count by that many times.\n2. suppose we have remainder 2(like 5,8,11..) we can simply add (freq/3(3's) + 1(2's)) to the value.\n3. we have a remainder 1.(like 7,10,13...)  we need to scarifice one 3 to make allocation for 2. \n         suppose we have 7 which greedly goes as (3+3+1) . to write this interms of 2's and 3's we need to scarifice one 3.  {7= 3+2+2}. so when the reaminder is 1 we need to increse count with ((freq/3) -1 +2) = (freq/3  + 1 ). \n\n            Here one corner case is there if we have frequency as 4 (3+1). we need to add it by 2.\n             check out my code if you have any douts.\n \nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int x:tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        int count = 0;\n        for(Map.Entry<Integer,Integer> entry : map.entrySet())\n        {\n            int temp = entry.getValue();\n            if(temp==1) return -1;\n            else if(temp%3==0)  count+=(temp/3);\n            else if(temp%3==2) count+=((temp/3)+1);\n            else\n            {\n                if(temp==4) \n                    count+=2;\n                else\n                    count+=((temp/3)+1);\n            }\n        }\n        return count;\n    }\n}"
                    },
                    {
                        "username": "Khushi260",
                        "content": "the only condition for return -1 if count of a particular task ==1 otherwise if (count % 3 == 0) then result += 1 else result+=2;"
                    },
                    {
                        "username": "sanjay1e7",
                        "content": "We have to return -1 only if the frequency of any element is 1 otherwise, we can easily break them in parts of 3 and 2."
                    },
                    {
                        "username": "Balwierz",
                        "content": "Why is this problem medium? It should be easy."
                    },
                    {
                        "username": "prady8339",
                        "content": " HINT to understand pattern.\nfrequency : answer \n 1 :  return -1 \n 2 : 1 ans+=1\n 3 : 1 ans+=1\n 4 : 2 (n-1)%3==0 so ans += (n-1)/3 + 1; { 3 2 }\n 6 : 2 n%3==0 so ans += n/3; {3 3}\n 7 : 3 (n-1)%3==0 so ans += (n-1)/3 + 1; { 2 2 3 }\n 8 : 3 (n-2)%3==0 so ans += (n-1)/3 + 1; { 3 2 2 }\n 9 : 3  n%3==0 so ans += n/3; {3 3 3}\n10 : 4 (n-1)%3==0 so ans += (n-1)/3 + 1; \n11 : 4 (n-2)%3==0 so ans += (n-1)/3 + 1;\n12 : 4  n%3==0 so ans += n/3;\n\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997905/simple-to-understand-cpp-solution/"
                    },
                    {
                        "username": "vineethvijayan314",
                        "content": "I am getting 35 instead of 38 for \\n[119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nI don\\'t see how my result is flawed"
                    },
                    {
                        "username": "GD18",
                        "content": "Isnt this a little on the easier side to be a medium question lol"
                    },
                    {
                        "username": "surajku2022",
                        "content": "There are 3 ways to solve this question.\\n1. Brute force method using visited array. We can count occurrence of each number and then calculate minimum rounds.\\n2. By sorting the given array, so that we don\\'t have to iterate over array to get count of occurrences of a number.\\n3. Just use map to store the occurrence and then calculate by iterating over map."
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "Simply we just count tasks numbers in hash map then we iterate over it \nthen we have 2 conditions \n- if the freqency of this task is 1 so we can't batch it in group of 2's or 3's  so **return -1**\n- other wise mnRounds = freq/3 + (freq%3 != 0)  "
                    }
                ]
            },
            {
                "id": 1741105,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741093,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741076,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741069,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741035,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741008,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1741002,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1740989,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1740984,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1740967,
                "content": [
                    {
                        "username": "LiamAlsbury11",
                        "content": "My code works for all but 4 test cases (TLE). How can I optimize this piece of code? (I am a beginner).\\n\\n        tasks = sorted(tasks)\\n        t = 0\\n        h = 0\\n        for i in tasks:\\n            if h == i:\\n                continue\\n            if tasks.count(i) == 1:\\n                return -1\\n            elif tasks.count(i) == 2:\\n                t += 1\\n            elif (tasks.count(i)-1) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            elif (tasks.count(i)-2) % 3 == 0:\\n                t += ((tasks.count(i)/3)+1)\\n            else:\\n                t += (tasks.count(i)/3)\\n            h = i\\n            tasks = [z for z in tasks if z != i]\\n        return t"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "can someone please clear my doubt that why my code is showing TLE ? \\nI am using only one while loop so time comlexity is o(n)  then why TLE?\\n int minimumRounds(vector<int>& v) {\\n        int c=0;\\n        while(!v.empty()){\\n        sort(v.begin(), v.end());\\n        int co =count(v.begin(), v.end(),v[v.size()-1]);\\n        if(co==1) return -1;\\n          if (co==2 || co==4 ){\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n        if(co==3 ||  co>4){\\n            v.pop_back();\\n            v.pop_back();\\n            v.pop_back();\\n            c++;\\n        }\\n      \\n        \\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Oitanny](/Oitanny) Cheers!, Here's another tip: instead of using prev variable for counting, you can use the following code.\n```\nfor(int i = 0; i<n; i++)\n{\n  count = 1;\n  while(arr[i+1] == arr[i])\n    {\n      count++;\n      i++;\n    }\n  // here we get curr num as arr[i] and count as the count for currnum\n  // and can write actual logic here..\n}\n````\nThis is much neater, and is more efficient since we don't need to copy values in prev variable again and again!!"
                    },
                    {
                        "username": "Oitanny",
                        "content": "[@sarpalmadhav](/sarpalmadhav)  Thank you so much!! Because of your suggestion i removed each occurence of count function from my code and it worked!! Keep spreading the knowledge and helping ppl in need :)"
                    },
                    {
                        "username": "udaybhardwaj01",
                        "content": "[@sarpalmadhav](/sarpalmadhav) thank you brother. I was unaware about the fact that count function is very expensive. thats why it is showing TLE\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Uday](/udaybhardwaj01) That\\'s not how you should count, the count function is very expensive, in each loop it will check full array. You are making this a n*n solution this way and it will give TLE for 10^5 nums. Just sort it and start from i = 0 and then move forward until the element is same, this is how you will get count for cur element.. then continue from next index, Don\\'t do this pop_back logic, even pop_back is expensive when all we have to do is read the sorted array."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "For some reason I get stack overflow and I cannot understand where it may be...\\nPlease Help!\\nLang: C++11\\n\\n`#define D (int)1e9`\\n`int minimumRounds(vector<int>& tasks) {`\\n`    int cnt[D+1], ans=0;`\\n`    for (int t:tasks) ++cnt[t];`\\n`        for (int i=1; i<=D; ++i) {`\\n`          `  `if (!cnt[i]) continue;`\\n`           `  `if (cnt[i]==1) return -1;`\\n`           `  `ans += (cnt[i]+2)/3;`\\n`    }`\\n`    return ans;`\\n`}`\\n\\nThanks in advance."
                    },
                    {
                        "username": "kyriakoskourk",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Thanks for your quick answer! My first optimization would be to find the mininum and maximum difficulties, in order to limit the lower and upper bound for the loop."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@kyriakoskourk](/kyriakoskourk), This has obvious loopholes, that #define D 1e9 is a nuclear bomb. You cant do 1e9 operations in 2 sec time limit. So that it self is big No. Also, Stack overlflow might be because you cant just right an int array of 1e9. At 4 bytes per int, you are asking for 4 GB of memory!!. As a thumb rule never declare static int array of more than 1e6 size. Regarding question, you will need to optimize approach. Read hashmaps or maybe read about how to sort and count frequencies in an array."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for easiest explanation\\nhttps://youtu.be/c--4FVRqa5g"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "    \\n      class Solution:\\n         def minimumRounds(self, tasks: List[int]) -> int:\\n               tacks=Counter(tasks)\\n               if 1 in tacks.values():return -1\\n               ans=0\\n              for n in tacks.values():\\n                  ans+=n//3 + bool(n%3)\\n             return ans\\n    def minDeletionSize(strs):\\n        for j in range(len(strs[0])):\\n            res=0\\n            for i in range(len(strs)):\\n                if strs[i][j] < strs[i-1][j]:\\n                   res+=1\\n        return res \\uD83E\\uDD17\\uD83E\\uDD70\\n        "
                    },
                    {
                        "username": "varunkumarkandakatla",
                        "content": "here we need to take frequencies of tasks[i] to count the level of difficulty\\n\\nthen traverse the frequency loop and check if(freq[i]<2) return -1 \\nelse if(freq[i]>3) check remainder of freq[i]%3  if it is 0 direct add quotient to answer else add quotient+1 to answer .\\n\\nfinally return answerl\\n        "
                    },
                    {
                        "username": "mrping_11",
                        "content": "finally good old hashmap, this should be an easy problem."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int minimumRounds(int[] tasks) {\\n        HashMap<Integer,Integer>h=new HashMap<>();\\n        int x=0;\\n        for(int i=0;i<tasks.length;i++){\\n            h.put(tasks[i],h.getOrDefault(tasks[i],0)+1);\\n        }\\n        // int i=0;\\n        int c=0;\\n        for(Map.Entry<Integer,Integer>e:h.entrySet()){\\n            if(e.getValue()==1) return -1;\\n            c+=(e.getValue()+2)/3;\\n        }\\n        return c;\\n    }"
                    },
                    {
                        "username": "cswartzell",
                        "content": "ceil(freq/3)"
                    },
                    {
                        "username": "itshimashis",
                        "content": "we should make a map and store all the frequency of the numbers.\\nthen we traverse through the map ans check for every element.\\nif any element has frequency<2 then we should return at that very point . ans will be -1.\\nin a general sense an element can be picked in a multiple number of 2 and 3. lets say we take x1 turns where we pick up 2 pieces of that element and x2 turns where we take 3 pieces of that element in a go.\\n\\n\\nwe represent a equation 2*x1+3*x2=y \\nwhere y is the element\\'s frequency.  if a integer pair exists (x1,x2) that satisfies the equation, we take it. if there are a lot of that solution pair, we take the pair having the smallest sum (x1+x2). \\n \\nmy code :\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/submissions/871018276/"
                    }
                ]
            },
            {
                "id": 1740953,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740948,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740893,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740888,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740876,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740860,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740838,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740825,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740816,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740805,
                "content": [
                    {
                        "username": "IamUday",
                        "content": "Its more of a Math topic problem may be."
                    },
                    {
                        "username": "PulkitAgga01",
                        "content": "From observation, we can see that there\\'s only 3 possible outcomes.\\n1. If the frequency is 1, the task cannot be performed so we return -1.\\n2. If the frequency is 3, the task can be performed and we return frequency/3.\\n3. Now if the frequency is not completely divisible by 3, then we can return frequency/3 +1."
                    },
                    {
                        "username": "IamAJ22",
                        "content": "I am gonna code every single day in this year #resolution"
                    },
                    {
                        "username": "loknadh_reddy",
                        "content": "is there no way to solve it using brute force without TLE ?\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2996141/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Just use table of 3 and think along its remainders."
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good after tackling a greedy one :)"
                    },
                    {
                        "username": "prasadpreetish",
                        "content": "Hey I stored the frequencies in a HashMap and then I found the same pattern of the minwork i.e. if f =1 return -1 if f=2 || f=3 return 1 but I am not able to get this intution that minwork+= (f+2)/3; how to get this type of thinking. I mean how do I develop the skills to get through such thought process.\\n\\n`    // frequencies       [1,2,3,4,5,6,7,8,9]`\\n\\n`   // minwork return   [-1,1,1,2,2,2,3,3,3]`\\n\\nI was getting this pattern but didn\\'t get the formula sadly."
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "You don\\'t have to it will develope automatically just practice as many questions as possible \\nHere is my solution which is similar to climbing stairs problem or coin change problem:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Count frequency in a hash-map.\\n2. Sum up (frequency + 2) / 3."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Santanu Sen](/santanusen) That\\'s one way of giving the full answer in as little words as possible! This is a perfect spoiler for those who have not thought about it, but I like the brevity!!"
                    },
                    {
                        "username": "omscode",
                        "content": "really help , thanks!!"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Well we can solve this problem using dp ( top down approach) \n"
                    }
                ]
            },
            {
                "id": 1740795,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740787,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740774,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740766,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740758,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740733,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740696,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740695,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740691,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            },
            {
                "id": 1740683,
                "content": [
                    {
                        "username": "Katrinakaif9",
                        "content": "My code is not satisfying the first test case here but is running perfectly on other compilers with the same testcases. What do I do?"
                    },
                    {
                        "username": "How_Absurd",
                        "content": "a basic greedy question \\uD83D\\uDE0B\\uD83D\\uDE0B"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "Far better than the last one"
                    },
                    {
                        "username": "wentaog",
                        "content": "My approach was to get an occurrence count table for how many times each task number occurred. Then I iterated through the table, and found whether each number\\'s count can be split by 2s and 3s. The only occasion it would return -1 would be the number only occurred 1 time. The hard part then was to think about how to come up with the condition that checks the minimum step count to cut up the tasks count in 2s and 3s. Since you divide any number larger than 3, if it doesn\\'t have remainder, great, add that divided number to the result sum. But if it doesn\\'t, the remainder would be either 2 or 1. Since we omitted the 1 from failure condition, I was thinking we could simple get a 3 from counted, and cut the 4 to 2 2s. Which eventually becomes if there is a remainder, add one to the divide by 3 number, and eventually to the res. After iterating through the table, you will either return -1 midway when found 1, or return the correct result. "
                    },
                    {
                        "username": "SAURABH_YADAV_CSE",
                        "content": " map<int,int> mp;\\n        int count=0;\\n        int n = tasks.size();\\n        for(int i=0; i<n;i++){\\n            mp[tasks[i]]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second==1) return -1;\\n            if(it.second%3==0){\\n                count = count+it.second/3;\\n            }\\n            else count = count+ it.second/3+1;\\n        }\\n\\n    return count;"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "GargShubham",
                        "content": "Tasks : [119,115,115,119,118,113,118,120,110,113,119,115,116,118,120,117,116,111,113,119,115,113,115,111,112,119,111,111,110,112,113,120,110,111,112,111,119,112,113,112,115,116,113,114,118,119,115,114,114,112,110,117,120,110,117,116,120,118,110,120,119,113,119,120,113,110,120,114,119,115,119,117,120,116,113,113,110,118,117,116,114,114,111,116,119,112,113,116,112,116,119,112,114,114,112,118,116,113,117,116]\\n\\nPAIR : \\n{112=10, 113=13, 114=8, 115=8, 116=11, 117=6, 118=7, 119=13, 120=9, 110=8, 111=7}\\nMy Ans : -1 (for 116 = 11)\\nRight Ans : 38 (According Leetcode)\\nFor  this test cases don\\'t you think for 11 there should be -1 but in ans it is not right why? \\nanyone ?"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "11 can be split up into 3+3+3+2 in total 4 tasks..."
                    },
                    {
                        "username": "close27",
                        "content": "Hashtable is not needed if we sort the input array."
                    },
                    {
                        "username": "calm27",
                        "content": "with hashtable it could be resolved in `O(n)`, and sorting is `O(nlogn)`. "
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple recursion problem similar to factorial use dp array not to get TLE"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "yes but you dont have to create freq to each element , just sort that array and using topdown approach , you can check it here\\n\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995897/go-top-down-knapsack-dp/?orderBy=most_relevant"
                    },
                    {
                        "username": "__CODE_IN_BLACK_HOLE__",
                        "content": "Yeah Question is similar to climbing stairs where we can go climb 2 or 3 steps from current stair and have to find minimum:\\nHere is my memoized solution:\\nhttps://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995390/intuitive-memoization-using-coin-change-explained/"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using recursion + memoization. Basic idea was to use recursion to find out minimum rounds required for count of each task. Here\\'s my [solution](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2995412/no-dp-solutions/) in python."
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Video Sharing Platform",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1986530,
                "content": [
                    {
                        "username": "SkinheadBob",
                        "content": "Not sure why this is labeled as \\'Hard\\' ... ?\\nIs it because of the \\'uploaded video always associated with the smallest available videoId\\' constraint? "
                    },
                    {
                        "username": "N8m3u",
                        "content": "Is there a typo in the example?\\n\\n> videoSharingPlatform.watch(1, 0, 5);         // The video associated with videoId 1 is \"456\", The video from minute 0 to min(5, 3 - 1) = 2 is \"456\", so return \"453\".\\n\\nShouldn\\'t that return \"456\" instead of \"453\"??"
                    }
                ]
            },
            {
                "id": 2010208,
                "content": [
                    {
                        "username": "SkinheadBob",
                        "content": "Not sure why this is labeled as \\'Hard\\' ... ?\\nIs it because of the \\'uploaded video always associated with the smallest available videoId\\' constraint? "
                    },
                    {
                        "username": "N8m3u",
                        "content": "Is there a typo in the example?\\n\\n> videoSharingPlatform.watch(1, 0, 5);         // The video associated with videoId 1 is \"456\", The video from minute 0 to min(5, 3 - 1) = 2 is \"456\", so return \"453\".\\n\\nShouldn\\'t that return \"456\" instead of \"453\"??"
                    }
                ]
            }
        ]
    },
    {
        "title": "Largest 3-Same-Digit Number in String",
        "question_content": "<p>You are given a string <code>num</code> representing a large integer. An integer is <strong>good</strong> if it meets the following conditions:</p>\n\n<ul>\n\t<li>It is a <strong>substring</strong> of <code>num</code> with length <code>3</code>.</li>\n\t<li>It consists of only one unique digit.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum good </strong>integer as a <strong>string</strong> or an empty string </em><code>&quot;&quot;</code><em> if no such integer exists</em>.</p>\n\n<p>Note:</p>\n\n<ul>\n\t<li>A <strong>substring</strong> is a contiguous sequence of characters within a string.</li>\n\t<li>There may be <strong>leading zeroes</strong> in <code>num</code> or a good integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;6<strong><u>777</u></strong>133339&quot;\n<strong>Output:</strong> &quot;777&quot;\n<strong>Explanation:</strong> There are two distinct good integers: &quot;777&quot; and &quot;333&quot;.\n&quot;777&quot; is the largest, so we return &quot;777&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;23<strong><u>000</u></strong>19&quot;\n<strong>Output:</strong> &quot;000&quot;\n<strong>Explanation:</strong> &quot;000&quot; is the only good integer.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;42352338&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>num</code> only consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2017786,
                "title": "compare-with-2-previous",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def largestGoodInteger(self, n: str) -> str:\\n        return max(n[i-2:i+1] if n[i] == n[i - 1] == n[i - 2] else \"\" for i in range(2, len(n)))\\n```\\n**C++**\\n```cpp\\nstring largestGoodInteger(string num) {\\n    char res = 0;\\n    for(int i = 2; i < num.size(); ++i)\\n        if (num[i] == num[i - 1] && num[i] == num[i - 2])\\n            res = max(res, num[i]);\\n    return res == 0 ? \"\" : string(3, res);\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def largestGoodInteger(self, n: str) -> str:\\n        return max(n[i-2:i+1] if n[i] == n[i - 1] == n[i - 2] else \"\" for i in range(2, len(n)))\\n```\n```cpp\\nstring largestGoodInteger(string num) {\\n    char res = 0;\\n    for(int i = 2; i < num.size(); ++i)\\n        if (num[i] == num[i - 1] && num[i] == num[i - 2])\\n            res = max(res, num[i]);\\n    return res == 0 ? \"\" : string(3, res);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017778,
                "title": "o-1-space-vs-o-3-space-intuition-c",
                "content": "> **Get maximum by checking only single digit.**\\n\\n**Intuition behind O(1) Space**:\\nIn the question it is given that `a number is unique if all digits are same`.\\nSo instead of **comparing subtrings**, we can simple compare single digit because **if(7<8) then (777<888)**.\\n\\n**C++ VERSION O(1) SPACE**\\n   \\n    string largestGoodInteger(string num) {\\n        int ans=-1;\\n        for(int i=0;i+2<num.size();i++){\\n            if(num[i]==num[i+1] && num[i]==num[i+2]) ans= max(ans,num[i]-\\'0\\');\\n        }\\n        return ans!=-1? string(3,ans+\\'0\\') : \"\";\\n     }\\n\\t \\n**JAVA VERSION O(1) SPACE**\\n     \\n\\t public String largestGoodInteger(String num) {\\n        int ans=-1;\\n        for(int i=0;i+2<num.length();i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)) \\n                ans= Math.max(ans,num.charAt(i)-\\'0\\');\\n        }\\n        StringBuilder sb = new StringBuilder(3); \\n        for(int i=0;i<3;i++) sb.append((char)(48+ans));\\n        return ans!=-1? sb.toString() : \"\";\\n     }\\n\\n**Time** - O(N)\\n**Space** - O(1)\\n\\n**Brute Approach with space: [String comparison]**\\n**C++**\\n     \\n\\tstring largestGoodInteger(string num) {\\n        string ans=\"\";\\n        for(int i=0;i+2<num.size();i++){\\n            if(num[i]==num[i+1] && num[i]==num[i+2]) ans= max(ans,{num[i],num[i+1],num[i+2]});\\n        }\\n        return ans;\\n    }\\n**Time** - O(N)\\n**Space** - O(3) [resultant string is always of size 3]",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "> **Get maximum by checking only single digit.**\\n\\n**Intuition behind O(1) Space**:\\nIn the question it is given that `a number is unique if all digits are same`.\\nSo instead of **comparing subtrings**, we can simple compare single digit because **if(7<8) then (777<888)**.\\n\\n**C++ VERSION O(1) SPACE**\\n   \\n    string largestGoodInteger(string num) {\\n        int ans=-1;\\n        for(int i=0;i+2<num.size();i++){\\n            if(num[i]==num[i+1] && num[i]==num[i+2]) ans= max(ans,num[i]-\\'0\\');\\n        }\\n        return ans!=-1? string(3,ans+\\'0\\') : \"\";\\n     }\\n\\t \\n**JAVA VERSION O(1) SPACE**\\n     \\n\\t public String largestGoodInteger(String num) {\\n        int ans=-1;\\n        for(int i=0;i+2<num.length();i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)) \\n                ans= Math.max(ans,num.charAt(i)-\\'0\\');\\n        }\\n        StringBuilder sb = new StringBuilder(3); \\n        for(int i=0;i<3;i++) sb.append((char)(48+ans));\\n        return ans!=-1? sb.toString() : \"\";\\n     }\\n\\n**Time** - O(N)\\n**Space** - O(1)\\n\\n**Brute Approach with space: [String comparison]**\\n**C++**\\n     \\n\\tstring largestGoodInteger(string num) {\\n        string ans=\"\";\\n        for(int i=0;i+2<num.size();i++){\\n            if(num[i]==num[i+1] && num[i]==num[i+2]) ans= max(ans,{num[i],num[i+1],num[i+2]});\\n        }\\n        return ans;\\n    }\\n**Time** - O(N)\\n**Space** - O(3) [resultant string is always of size 3]",
                "codeTag": "Unknown"
            },
            {
                "id": 2017719,
                "title": "java-compareto",
                "content": "```\\nclass Solution\\n{\\n    public String largestGoodInteger(String num)\\n    {\\n        String ans = \"\";\\n        for(int i = 2; i < num.length(); i++)\\n            if(num.charAt(i) == num.charAt(i-1) && num.charAt(i-1) == num.charAt(i-2))\\n                if(num.substring(i-2,i+1).compareTo(ans) > 0) // Check if the new one is larger\\n                    ans = num.substring(i-2,i+1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public String largestGoodInteger(String num)\\n    {\\n        String ans = \"\";\\n        for(int i = 2; i < num.length(); i++)\\n            if(num.charAt(i) == num.charAt(i-1) && num.charAt(i-1) == num.charAt(i-2))\\n                if(num.substring(i-2,i+1).compareTo(ans) > 0) // Check if the new one is larger\\n                    ans = num.substring(i-2,i+1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018649,
                "title": "c-2-method-easy-to-understand",
                "content": "**M1**\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n       \\n        vector<string>v = {\"999\",\"888\",\"777\",\"666\",\"555\",\"444\",\"333\",\"222\",\"111\",\"000\"};\\n        for(auto x : v)\\n        {\\n            if(num.find(x) != -1)\\n            return x;\\n        }\\n        return \"\";\\n    }\\n};\\n```\\n\\n\\n**M2**\\n```\\nclass Solution {\\npublic:\\n\\tstring largestGoodInteger(string num) {\\n\\t\\tstring ans;\\n\\t\\tint n = num.length();\\n\\t\\tfor(int i=0;i<n-2;i++){\\n\\t\\t\\tif(num[i]==num[i+1] && num[i+1]==num[i+2]){\\n\\t\\t\\t\\tstring temp;\\n\\t\\t\\t\\ttemp.push_back(num[i]);\\n\\t\\t\\t\\ttemp.push_back(num[i+1]);\\n\\t\\t\\t\\ttemp.push_back(num[i+2]);\\n\\t\\t\\t\\tans = max(ans,temp);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n       \\n        vector<string>v = {\"999\",\"888\",\"777\",\"666\",\"555\",\"444\",\"333\",\"222\",\"111\",\"000\"};\\n        for(auto x : v)\\n        {\\n            if(num.find(x) != -1)\\n            return x;\\n        }\\n        return \"\";\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tstring largestGoodInteger(string num) {\\n\\t\\tstring ans;\\n\\t\\tint n = num.length();\\n\\t\\tfor(int i=0;i<n-2;i++){\\n\\t\\t\\tif(num[i]==num[i+1] && num[i+1]==num[i+2]){\\n\\t\\t\\t\\tstring temp;\\n\\t\\t\\t\\ttemp.push_back(num[i]);\\n\\t\\t\\t\\ttemp.push_back(num[i+1]);\\n\\t\\t\\t\\ttemp.push_back(num[i+2]);\\n\\t\\t\\t\\tans = max(ans,temp);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018123,
                "title": "simple-solution-using-brute-force-approach-o-3-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans = \"\";\\n        for(int i=1; i<num.size()-1; i++) {\\n            if(num[i-1] == num[i] && num[i] == num[i+1]) {\\n\\t\\t\\t\\tstring temp = {num[i-1], num[i], num[i+1]};\\n                ans = max(ans, temp);\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans = \"\";\\n        for(int i=1; i<num.size()-1; i++) {\\n            if(num[i-1] == num[i] && num[i] == num[i+1]) {\\n\\t\\t\\t\\tstring temp = {num[i-1], num[i], num[i+1]};\\n                ans = max(ans, temp);\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102821,
                "title": "easy-python-solution",
                "content": "```\\ndef largestGoodInteger(self, num: str) -> str:\\n        m,l=[],[\"000\",\"111\",\"222\",\"333\",\"444\",\"555\",\"666\",\"777\",\"888\",\"999\"]\\n        for i in l:\\n            if i in num:\\n                m.append(i)\\n        m.sort()\\n        return m[-1] if len(m)>0 else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef largestGoodInteger(self, num: str) -> str:\\n        m,l=[],[\"000\",\"111\",\"222\",\"333\",\"444\",\"555\",\"666\",\"777\",\"888\",\"999\"]\\n        for i in l:\\n            if i in num:\\n                m.append(i)\\n        m.sort()\\n        return m[-1] if len(m)>0 else \"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2018671,
                "title": "c-simple-short-full-explanation-with-comments-o-n",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        // taking a char with 0 initially that will store our ans\\n        char ans = 0;\\n        \\n        // just iterating from the 3rd element and start comparing with 1st and 2nd element\\n        for(int i=2;i<num.size();i++)\\n        {\\n            // if we found triplet then just update the max if it is\\n            if(num[i-2]==num[i-1] && num[i-1]==num[i])\\n                ans = max(ans,num[i]);\\n        }\\n        \\n        // after all the iteration if our ans is empty (means no triplet) then return empty string\\n        if(ans==0)\\n            return \"\";\\n        \\n        // else return the max char in the form of string\\n        // string(3,ans) == just returning the same char 3 times in the form of string\\n        else\\n            return string(3,ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        // taking a char with 0 initially that will store our ans\\n        char ans = 0;\\n        \\n        // just iterating from the 3rd element and start comparing with 1st and 2nd element\\n        for(int i=2;i<num.size();i++)\\n        {\\n            // if we found triplet then just update the max if it is\\n            if(num[i-2]==num[i-1] && num[i-1]==num[i])\\n                ans = max(ans,num[i]);\\n        }\\n        \\n        // after all the iteration if our ans is empty (means no triplet) then return empty string\\n        if(ans==0)\\n            return \"\";\\n        \\n        // else return the max char in the form of string\\n        // string(3,ans) == just returning the same char 3 times in the form of string\\n        else\\n            return string(3,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017844,
                "title": "java-basic-understandable",
                "content": "```\\nclass Solution {\\n    public static String largestGoodInteger(String str) {\\n        if (str.contains(\"999\")) {\\n\\t\\t\\treturn \"999\";\\n\\t\\t} else if (str.contains(\"888\")) {\\n\\t\\t\\treturn \"888\";\\n\\t\\t} else if (str.contains(\"777\")) {\\n\\t\\t\\treturn \"777\";\\n\\t\\t} else if (str.contains(\"666\")) {\\n\\t\\t\\treturn \"666\";\\n\\t\\t} else if (str.contains(\"555\")) {\\n\\t\\t\\treturn \"555\";\\n\\t\\t} else if (str.contains(\"444\")) {\\n\\t\\t\\treturn \"444\";\\n\\t\\t} else if (str.contains(\"333\")) {\\n\\t\\t\\treturn \"333\";\\n\\t\\t} else if (str.contains(\"222\")) {\\n\\t\\t\\treturn \"222\";\\n\\t\\t} else if (str.contains(\"111\")) {\\n\\t\\t\\treturn \"111\";\\n\\t\\t} else if (str.contains(\"000\")) {\\n\\t\\t\\treturn \"000\";\\n\\t\\t} else\\n\\t\\t\\treturn \"\";\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static String largestGoodInteger(String str) {\\n        if (str.contains(\"999\")) {\\n\\t\\t\\treturn \"999\";\\n\\t\\t} else if (str.contains(\"888\")) {\\n\\t\\t\\treturn \"888\";\\n\\t\\t} else if (str.contains(\"777\")) {\\n\\t\\t\\treturn \"777\";\\n\\t\\t} else if (str.contains(\"666\")) {\\n\\t\\t\\treturn \"666\";\\n\\t\\t} else if (str.contains(\"555\")) {\\n\\t\\t\\treturn \"555\";\\n\\t\\t} else if (str.contains(\"444\")) {\\n\\t\\t\\treturn \"444\";\\n\\t\\t} else if (str.contains(\"333\")) {\\n\\t\\t\\treturn \"333\";\\n\\t\\t} else if (str.contains(\"222\")) {\\n\\t\\t\\treturn \"222\";\\n\\t\\t} else if (str.contains(\"111\")) {\\n\\t\\t\\treturn \"111\";\\n\\t\\t} else if (str.contains(\"000\")) {\\n\\t\\t\\treturn \"000\";\\n\\t\\t} else\\n\\t\\t\\treturn \"\";\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017809,
                "title": "python-o-1-space-solution-beats-90",
                "content": "The logic is quite straightforward. The code will count the consecutive same characters and if it matches the conditions of good integer, we will compare and update the max integer string in `res`.\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        res = \\'\\' \\n        cnt = 1\\n        for i in range(1, len(num)):\\n            if num[i] == num[i-1]:\\n                cnt+=1\\n            else:\\n                cnt = 1\\n            if cnt == 3:\\n                res = max(res, num[i] * 3)\\n                \\n        return res\\n\\t\\t\\n```\\n**Time = O(N)**\\n**Space = O(1)**\\n\\n----\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        res = \\'\\' \\n        cnt = 1\\n        for i in range(1, len(num)):\\n            if num[i] == num[i-1]:\\n                cnt+=1\\n            else:\\n                cnt = 1\\n            if cnt == 3:\\n                res = max(res, num[i] * 3)\\n                \\n        return res\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018632,
                "title": "clean-javascript-solution-beats-100",
                "content": "```\\nvar largestGoodInteger = function (num) {\\n    let max = \"\";\\n    for (let i = 2; i < num.length; i++) {\\n        if (num[i] === num[i - 1] && num[i] === num[i - 2]) {\\n            const subString = num[i].repeat(3);\\n            if (subString > max) {\\n                max = subString;\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestGoodInteger = function (num) {\\n    let max = \"\";\\n    for (let i = 2; i < num.length; i++) {\\n        if (num[i] === num[i - 1] && num[i] === num[i - 2]) {\\n            const subString = num[i].repeat(3);\\n            if (subString > max) {\\n                max = subString;\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033589,
                "title": "ultra-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        l = [\\'999\\',\\'888\\',\\'777\\',\\'666\\',\\'555\\',\\'444\\',\\'333\\',\\'222\\',\\'111\\',\\'000\\']\\n        \\n        for i in l:\\n            if i in num:\\n                return i\\n        return \"\"\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        l = [\\'999\\',\\'888\\',\\'777\\',\\'666\\',\\'555\\',\\'444\\',\\'333\\',\\'222\\',\\'111\\',\\'000\\']\\n        \\n        for i in l:\\n            if i in num:\\n                return i\\n        return \"\"\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2019061,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn largest_good_integer(num: String) -> String {\\n        num.chars()\\n            .zip(num.chars().skip(1))\\n            .zip(num.chars().skip(2))\\n            .filter_map(|((a, b), c)| {\\n                if a == b && b == c {\\n                    Some(format!(\"{}{}{}\", a, b, c))\\n                } else {\\n                    None\\n                }\\n            })\\n            .max()\\n            .unwrap_or_default()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_good_integer(num: String) -> String {\\n        num.chars()\\n            .zip(num.chars().skip(1))\\n            .zip(num.chars().skip(2))\\n            .filter_map(|((a, b), c)| {\\n                if a == b && b == c {\\n                    Some(format!(\"{}{}{}\", a, b, c))\\n                } else {\\n                    None\\n                }\\n            })\\n            .max()\\n            .unwrap_or_default()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018379,
                "title": "easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string str) {\\n     \\n        string ans;\\n        int n = size(str);\\n        for (int i=0; i<n-2; i++) \\n        {\\n            if (str[i] == str[i+1] and str[i+1] == str[i+2]) {\\n                ans = max(ans, str.substr(i, 3));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string str) {\\n     \\n        string ans;\\n        int n = size(str);\\n        for (int i=0; i<n-2; i++) \\n        {\\n            if (str[i] == str[i+1] and str[i+1] == str[i+2]) {\\n                ans = max(ans, str.substr(i, 3));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018231,
                "title": "javascript-o-n-time-o-1-space-complexity-with-explanation",
                "content": "The idea is to loop through the given string, and check the 3-consecutive elements: ```num[i], num[i+1], num[i+2]```. If they are all equal, they will \"qualify\" for the 3-same-digit criteria. \\nAt the same time, we also need to track the largest number, hence a variable to store it called ```maxGoodInt``` would be used to compare against the current ```num[i]``` that we are iterating. If ```num[i]``` is greater than the current ```maxGoodInt```, it will replace and update ```maxGoodInt```.\\nFinally we return the result as a string of 3 ```maxGoodInt``` digits.\\n\\nBelow is the implementation. Please upvote if it helps :)\\n\\n```\\nvar largestGoodInteger = function(num) {\\n    let maxGoodInt = \\'\\';\\n    for (let i = 0; i <= num.length - 3; i++) {\\n        if (num[i] === num[i+1] && num[i+1] === num[i+2]) {\\n            if (num[i] >= maxGoodInt) {\\n                maxGoodInt = num[i];\\n            }\\n        }\\n    }\\n    return maxGoodInt + maxGoodInt + maxGoodInt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```num[i], num[i+1], num[i+2]```\n```maxGoodInt```\n```num[i]```\n```num[i]```\n```maxGoodInt```\n```maxGoodInt```\n```maxGoodInt```\n```\\nvar largestGoodInteger = function(num) {\\n    let maxGoodInt = \\'\\';\\n    for (let i = 0; i <= num.length - 3; i++) {\\n        if (num[i] === num[i+1] && num[i+1] === num[i+2]) {\\n            if (num[i] >= maxGoodInt) {\\n                maxGoodInt = num[i];\\n            }\\n        }\\n    }\\n    return maxGoodInt + maxGoodInt + maxGoodInt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2017792,
                "title": "python3-simple-easy-to-understand-very-elegant-and-pythonic",
                "content": "list comprehension to generate descending number triplets. Could have done a 999 decrement by -111 even I guess.\\n\\n```\\n    @timeit\\n    def largest_good_integer2(self, num: str) -> str:\\n        for test in [str(i)*3 for i in range(9, -1, -1)]:\\n            if test in num:\\n                return test\\n        return \\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    @timeit\\n    def largest_good_integer2(self, num: str) -> str:\\n        for test in [str(i)*3 for i in range(9, -1, -1)]:\\n            if test in num:\\n                return test\\n        return \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2556916,
                "title": "my-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String ans = \"\";\\n        for (int i = 1; i != num.length() - 1; ++i) {\\n            if(num.charAt(i - 1) == num.charAt(i) && num.charAt(i) == num.charAt(i + 1)) {\\n                if(ans.length() == 0) {\\n                    ans = num.substring(i - 1, i + 2);\\n                } else if (num.charAt(i) > ans.charAt(0)) {\\n                    ans = num.substring(i - 1, i + 2);\\n                }           \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String ans = \"\";\\n        for (int i = 1; i != num.length() - 1; ++i) {\\n            if(num.charAt(i - 1) == num.charAt(i) && num.charAt(i) == num.charAt(i + 1)) {\\n                if(ans.length() == 0) {\\n                    ans = num.substring(i - 1, i + 2);\\n                } else if (num.charAt(i) > ans.charAt(0)) {\\n                    ans = num.substring(i - 1, i + 2);\\n                }           \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029490,
                "title": "easy-check-anyone-of-999-888-or-000-present-in-num",
                "content": "```\\nclass Solution\\n{ \\n    public String largestGoodInteger(String num)\\n    {\\n        // largest to smallest good integers\\n        String [] goodIntegers={\"999\", \"888\", \"777\", \"666\", \"555\", \"444\", \"333\", \"222\", \"111\", \"000\"};\\n        // check if anyone present \\n        for(String goodInteger:goodIntegers){\\n            \\n            if(num.contains(goodInteger)){\\n                return goodInteger;\\n            }\\n        }\\n         //no good integers present\\n         return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{ \\n    public String largestGoodInteger(String num)\\n    {\\n        // largest to smallest good integers\\n        String [] goodIntegers={\"999\", \"888\", \"777\", \"666\", \"555\", \"444\", \"333\", \"222\", \"111\", \"000\"};\\n        // check if anyone present \\n        for(String goodInteger:goodIntegers){\\n            \\n            if(num.contains(goodInteger)){\\n                return goodInteger;\\n            }\\n        }\\n         //no good integers present\\n         return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018684,
                "title": "easy-to-understand-using-substr-function",
                "content": "```\\nstring largestGoodInteger(string num) {\\n        string ans=\"\";\\n        int mx = INT_MIN;\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num[i]==num[i+1] && num[i]==num[i+2]){\\n                string temp = num.substr(i,3);\\n                int x = stoi(temp);\\n                if(x>mx){\\n                    ans=temp;\\n                    mx=x;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nstring largestGoodInteger(string num) {\\n        string ans=\"\";\\n        int mx = INT_MIN;\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num[i]==num[i+1] && num[i]==num[i+2]){\\n                string temp = num.substr(i,3);\\n                int x = stoi(temp);\\n                if(x>mx){\\n                    ans=temp;\\n                    mx=x;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2017878,
                "title": "c-2-approaches-easy-o-n-solution-with-comments",
                "content": "**Please upvote it you find this solution helpful:)**\\n**Approach-1:**\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        int count=1; //count triplet\\n        string res; //store result triplet\\n        int max=INT_MIN; //helps in store max triplet\\n        \\n        //iterate over string\\n        for(int i=0; i<num.size()-1; i++)\\n        {\\n            //if current char is equal to the next char, increase the count by 1\\n            if(num[i]==num[i+1])\\n                count++;\\n            \\n            //if current char is not equal to the next char, re-initialize the count by 1\\n            else\\n                count=1;\\n            \\n            //if count is equal to 3 and num[i] is greater than the max, store the triplet into the result\\n            if(count==3 && (num[i]-\\'0\\') > max)\\n            {\\n                res=\"\";\\n                while(count--) //store triplet\\n                    res += num[i];\\n                max = (num[i]-\\'0\\');\\n                count=1; //re-initialize count by 1\\n            }\\n        }\\n        return res; \\n    }\\n};\\n```\\n\\n**Approach-2:**\\n```\\nstring largestGoodInteger(string num) \\n{\\n\\tchar res = 0;\\n\\n\\tfor(int i = 2; i < num.size(); i++)\\n\\t\\tif(num[i-2] == num[i-1] && num[i-1] == num[i])\\n\\t\\t\\tres = max(res, num[i]);\\n\\n\\treturn res == 0 ? \"\" : string(3, res);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        int count=1; //count triplet\\n        string res; //store result triplet\\n        int max=INT_MIN; //helps in store max triplet\\n        \\n        //iterate over string\\n        for(int i=0; i<num.size()-1; i++)\\n        {\\n            //if current char is equal to the next char, increase the count by 1\\n            if(num[i]==num[i+1])\\n                count++;\\n            \\n            //if current char is not equal to the next char, re-initialize the count by 1\\n            else\\n                count=1;\\n            \\n            //if count is equal to 3 and num[i] is greater than the max, store the triplet into the result\\n            if(count==3 && (num[i]-\\'0\\') > max)\\n            {\\n                res=\"\";\\n                while(count--) //store triplet\\n                    res += num[i];\\n                max = (num[i]-\\'0\\');\\n                count=1; //re-initialize count by 1\\n            }\\n        }\\n        return res; \\n    }\\n};\\n```\n```\\nstring largestGoodInteger(string num) \\n{\\n\\tchar res = 0;\\n\\n\\tfor(int i = 2; i < num.size(); i++)\\n\\t\\tif(num[i-2] == num[i-1] && num[i-1] == num[i])\\n\\t\\t\\tres = max(res, num[i]);\\n\\n\\treturn res == 0 ? \"\" : string(3, res);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113018,
                "title": "c-most-optimized-5-lines",
                "content": "# Intuition\\nfind 777 to 000 from the input string in decreasing order, once you get it return that number as string else return empty string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string s=\"\";\\n        for(char i=\\'9\\';i>=\\'0\\';i--)\\n        {   string x=to_string(i-\\'0\\');\\n            s=x+x+x;\\n            if(num.find(s)!=string::npos)\\n                return s;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string s=\"\";\\n        for(char i=\\'9\\';i>=\\'0\\';i--)\\n        {   string x=to_string(i-\\'0\\');\\n            s=x+x+x;\\n            if(num.find(s)!=string::npos)\\n                return s;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955118,
                "title": "simple-java-solution-o-n-time",
                "content": "# Intuition\\nLoop and return  the answer but 65 test case filed then used HashMap\\n\\n# Approach\\nLoop over the string for every three strings ans store them in HashMap if it satisfies the condition. Why HashMap because it store element in Order wise. \\nThen loop over the HashMap and print the last entry in the Map.\\n\\n# Complexity\\n- Time complexity:\\n     $$O(n)$$ \\n\\n- Space complexity:\\n     $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n         if (num.length() <= 1)\\n            return \"\";\\n\\n        Map<Integer, String> stringMap = new HashMap<>();\\n\\n        for (int i = 0; i < num.length() - 2; i++) {\\n            if (num.charAt(i) == num.charAt(i + 2) && num.charAt(i) == num.charAt(i + 1))\\n                stringMap.putIfAbsent(num.charAt(i) - \\'0\\', num.substring(i, i + 3));\\n        }\\n\\n        for (int i = 9; i >=0; i--)\\n            if (stringMap.containsKey(i))\\n                return stringMap.get(i);\\n\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n         if (num.length() <= 1)\\n            return \"\";\\n\\n        Map<Integer, String> stringMap = new HashMap<>();\\n\\n        for (int i = 0; i < num.length() - 2; i++) {\\n            if (num.charAt(i) == num.charAt(i + 2) && num.charAt(i) == num.charAt(i + 1))\\n                stringMap.putIfAbsent(num.charAt(i) - \\'0\\', num.substring(i, i + 3));\\n        }\\n\\n        for (int i = 9; i >=0; i--)\\n            if (stringMap.containsKey(i))\\n                return stringMap.get(i);\\n\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846791,
                "title": "easiest-solution-c-plus-plus-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<string> vec;\\n        for(int i=0;i<num.length()-2;i++){\\n            string a = \"\";\\n            if(num[i]==num[i+1] && num[i+1]==num[i+2]){\\n                int c = 3;\\n                while(c--) a+=num[i];\\n            }\\n            if(a!=\"\") vec.push_back(a);\\n        }\\n        sort(vec.begin(),vec.end());\\n        return vec.size()>0?vec[vec.size()-1]:\"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<string> vec;\\n        for(int i=0;i<num.length()-2;i++){\\n            string a = \"\";\\n            if(num[i]==num[i+1] && num[i+1]==num[i+2]){\\n                int c = 3;\\n                while(c--) a+=num[i];\\n            }\\n            if(a!=\"\") vec.push_back(a);\\n        }\\n        sort(vec.begin(),vec.end());\\n        return vec.size()>0?vec[vec.size()-1]:\"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682568,
                "title": "easy-solution-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<int>nums;\\n        int n = num.length();\\n        vector<int>freq(n,1);\\n         stack<int>st;\\n        st.push(0);\\n        for(int i = 1 ; i<n ; i++){\\n         if(!st.empty()){\\n             if(num[st.top()]==num[i]){\\n                 freq[i] = freq[st.top()] + 1;\\n             }\\n         }\\n            st.push(i);\\n            if(freq[st.top()]==3){\\n                int temp = num[st.top()] - \\'0\\';\\n                nums.push_back(temp);\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        int m = nums.size();\\n        sort(nums.begin() , nums.end());\\n        int temp;\\n        if(m>0){\\n        temp = nums[m-1];\\n         \\n        string cat = to_string(temp);\\n        for(int i = 0; i<3 ; i++){\\n            ans+= cat;\\n        }\\n    }     \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<int>nums;\\n        int n = num.length();\\n        vector<int>freq(n,1);\\n         stack<int>st;\\n        st.push(0);\\n        for(int i = 1 ; i<n ; i++){\\n         if(!st.empty()){\\n             if(num[st.top()]==num[i]){\\n                 freq[i] = freq[st.top()] + 1;\\n             }\\n         }\\n            st.push(i);\\n            if(freq[st.top()]==3){\\n                int temp = num[st.top()] - \\'0\\';\\n                nums.push_back(temp);\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        int m = nums.size();\\n        sort(nums.begin() , nums.end());\\n        int temp;\\n        if(m>0){\\n        temp = nums[m-1];\\n         \\n        string cat = to_string(temp);\\n        for(int i = 0; i<3 ; i++){\\n            ans+= cat;\\n        }\\n    }     \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526773,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        for i in range(9, -1, -1):\\n            r = str(i) * 3\\n            if r in num:\\n                return r\\n        return \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        for i in range(9, -1, -1):\\n            r = str(i) * 3\\n            if r in num:\\n                return r\\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129478,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        for(int i=9; i>=0; i--){\\n            String str = \"\"+i+i+i;\\n            if(num.contains(str))\\n                return str;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        for(int i=9; i>=0; i--){\\n            String str = \"\"+i+i+i;\\n            if(num.contains(str))\\n                return str;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057147,
                "title": "simple-c-soln-eay-to-understand",
                "content": "class Solution {\\npublic:\\n    string largestGoodInteger(string nums) {\\n        int n=nums.size();\\n        string temp;\\n        \\n        string res=\"\";\\n        int maxgood=0;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            if (nums[i+1]== nums[i] && nums[i+2]== nums[i])\\n            {\\n                temp= nums.substr(i, 3);\\n                 res= max(res, temp);\\n            }\\n        }\\n         \\n        return res;}\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestGoodInteger(string nums) {\\n        int n=nums.size();\\n        string temp;\\n        \\n        string res=\"\";\\n        int maxgood=0;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            if (nums[i+1]== nums[i] && nums[i+2]== nums[i])\\n            {\\n                temp= nums.substr(i, 3);\\n                 res= max(res, temp);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2036367,
                "title": "easy-c-solution",
                "content": "smjh\\n```\\nstring largestGoodInteger(string num) {\\n        char result =0;\\n     for(int i =1;i<num.length()-1;i++){\\n         if(num[i]==num[i-1] && num[i]==num[i+1]){\\n            result= max(result,num[i]); \\n         }\\n     }\\n        if(result ==0)return \"\";\\n        \\n        return string(3,result);\\n      \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring largestGoodInteger(string num) {\\n        char result =0;\\n     for(int i =1;i<num.length()-1;i++){\\n         if(num[i]==num[i-1] && num[i]==num[i+1]){\\n            result= max(result,num[i]); \\n         }\\n     }\\n        if(result ==0)return \"\";\\n        \\n        return string(3,result);\\n      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021050,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string nums) {\\n        string maxResp = \"\";\\n        string temp;\\n        for (int i = 1; i < nums.size() - 1; i++) {\\n            if ((nums[i-1] == nums[i]) && (nums[i] == nums[i+1])) {\\n                string temp = nums.substr(i-1, 3);\\n                if (temp > maxResp) {\\n                    maxResp = temp;\\n                }\\n            }\\n        }\\n        return maxResp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string nums) {\\n        string maxResp = \"\";\\n        string temp;\\n        for (int i = 1; i < nums.size() - 1; i++) {\\n            if ((nums[i-1] == nums[i]) && (nums[i] == nums[i+1])) {\\n                string temp = nums.substr(i-1, 3);\\n                if (temp > maxResp) {\\n                    maxResp = temp;\\n                }\\n            }\\n        }\\n        return maxResp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019015,
                "title": "use-sub-str",
                "content": "c++ easy approch\\n\\n class Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        int m=INT_MIN;\\n        string res;\\n        for(int i=0;i<num.length()-2;i++)\\n        {\\n            string temp=num.substr(i,3);\\n            int flag=0;\\n            for(int i=1;i<temp.length();i++)\\n            {\\n                if(char(temp[i-1])!=char(temp[i]))\\n                {\\n                    flag=1;\\n                    break;\\n                } \\n            }\\n            if(flag==0&&stoi(temp)>m)\\n            {\\n              m=stoi(temp);\\n                res=temp;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        int m=INT_MIN;\\n        string res;\\n        for(int i=0;i<num.length()-2;i++)\\n        {\\n            string temp=num.substr(i,3);\\n            int flag=0;\\n            for(int i=1;i<temp.length();i++)\\n            {\\n                if(char(temp[i-1])!=char(temp[i]))\\n                {\\n                    flag=1;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2018067,
                "title": "c-brute-force-easy-to-understand-comments-added",
                "content": "\\n\\n     class Solution {\\n     public:\\n     string largestGoodInteger(string num) {\\n        int c=0;\\n        int d=1;\\n        int l=-1;\\n        vector<string>vect;\\n        string x=\"\";\\n        for(int i=0;i<num.length();i++){\\n            if(num[i]==num[i+1]){\\n                if(c==0){\\n                    d=i;   //Taking the starting index of repeating element\\n                }\\n                c++;\\n            }\\n            else{\\n                c=0;\\n            }\\n            if(c==2){\\n                x=num.substr(d,3);  // Get the substring of 3 element from num where starting index is d\\n                vect.push_back(x);\\n                c=0;\\n                l=1;\\n            }\\n        }\\n        if(l==-1){  // Checking if there is no substring of 3 element then return empty string\\n            return x;\\n        }\\n        string y=*max_element(vect.begin(),vect.end());  // For comparison and getting largest element\\n        return y;\\n       }\\n      };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n     public:\\n     string largestGoodInteger(string num) {\\n        int c=0;\\n        int d=1;\\n        int l=-1;\\n        vector<string>vect;\\n        string x=\"\";\\n        for(int i=0;i<num.length();i++){\\n            if(num[i]==num[i+1]){\\n                if(c==0){\\n                    d=i;   //Taking the starting index of repeating element\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2018057,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n = -1;\\n        String str = \"\";\\n        for (int i = 0; i < num.length() - 1; i++) {\\n            if (i + 2 < num.length() && num.charAt(i) == num.charAt(i + 1) && num.charAt(i + 1) == num.charAt(i + 2)) {\\n                int ans = 0;\\n                ans = Integer.parseInt(num.substring(i, i + 3));\\n                System.out.println(ans);\\n                if (n < ans) {\\n                    n = ans;\\n                    str = \"\";\\n                    str += num.substring(i, i + 3);\\n                } else {}\\n            }\\n        }\\n        return str;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public String largestGoodInteger(String num) {\\n        int n = -1;\\n        String str = \"\";\\n        for (int i = 0; i < num.length() - 1; i++) {\\n            if (i + 2 < num.length() && num.charAt(i) == num.charAt(i + 1) && num.charAt(i + 1) == num.charAt(i + 2)) {\\n                int ans = 0;\\n                ans = Integer.parseInt(num.substring(i, i + 3));\\n                System.out.println(ans);\\n                if (n < ans) {\\n                    n = ans;\\n                    str = \"\";\\n                    str += num.substring(i, i + 3);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2017783,
                "title": "python-java-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef largestGoodInteger(self, num: str) -> str:\\n\\t\\t\\tmaxNum = -float(\"inf\")\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor i in range(len(num) - 2):\\n\\t\\t\\t\\tif num[i:i + 3] == num[i] * 3 and int(num[i:i + 3]) > maxNum:\\n\\t\\t\\t\\t\\tmaxNum = int(num[i:i + 3])\\n\\t\\t\\t\\t\\tres = num[i:i + 3]\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic String largestGoodInteger(String num) {\\n\\t\\t\\tint maxNum = Integer.MIN_VALUE;\\n\\t\\t\\tString res = \"\";\\n\\t\\t\\tfor (int i = 0; i < num.length() - 2; i ++) {\\n\\t\\t\\t\\tString c = String.valueOf(num.charAt(i));\\n\\t\\t\\t\\tString s = num.substring(i, i + 3);\\n\\t\\t\\t\\tif (s.equals(c + c + c) && Integer.valueOf(s) > maxNum) {\\n\\t\\t\\t\\t\\tmaxNum = Integer.valueOf(s);\\n\\t\\t\\t\\t\\tres = s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef largestGoodInteger(self, num: str) -> str:\\n\\t\\t\\tmaxNum = -float(\"inf\")\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor i in range(len(num) - 2):\\n\\t\\t\\t\\tif num[i:i + 3] == num[i] * 3 and int(num[i:i + 3]) > maxNum:\\n\\t\\t\\t\\t\\tmaxNum = int(num[i:i + 3])\\n\\t\\t\\t\\t\\tres = num[i:i + 3]\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic String largestGoodInteger(String num) {\\n\\t\\t\\tint maxNum = Integer.MIN_VALUE;\\n\\t\\t\\tString res = \"\";\\n\\t\\t\\tfor (int i = 0; i < num.length() - 2; i ++) {\\n\\t\\t\\t\\tString c = String.valueOf(num.charAt(i));\\n\\t\\t\\t\\tString s = num.substring(i, i + 3);\\n\\t\\t\\t\\tif (s.equals(c + c + c) && Integer.valueOf(s) > maxNum) {\\n\\t\\t\\t\\t\\tmaxNum = Integer.valueOf(s);\\n\\t\\t\\t\\t\\tres = s;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3770350,
                "title": "very-easy-explanation-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public String largestGoodInteger(String num){\\n        int ans = -1;\\n        for(int i=0; i<num.length()-2; i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i+1)==num.charAt(i+2)){\\n                String t = num.substring(i, i+3);\\n                ans = Math.max(ans, Integer.parseInt(t));\\n            }\\n        }\\n        if(ans==-1) return \"\";\\n        if(ans==0) return \"000\";\\n        return \"\"+ans;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public String largestGoodInteger(String num){\\n        int ans = -1;\\n        for(int i=0; i<num.length()-2; i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i+1)==num.charAt(i+2)){\\n                String t = num.substring(i, i+3);\\n                ans = Math.max(ans, Integer.parseInt(t));\\n            }\\n        }\\n        if(ans==-1) return \"\";\\n        if(ans==0) return \"000\";\\n        return \"\"+ans;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408679,
                "title": "2264-largest-3-same-digit-number-in-string",
                "content": "# Code\\n```\\nfunc largestGoodInteger(num string) string {\\n\\ttmp, cnt, n := num[0], 0, []int{}\\n\\tfor i := 1; i < len(num); i++ {\\n\\t\\tif tmp == num[i] {\\n\\t\\t\\tcnt += 1\\n\\t\\t} else {\\n\\t\\t\\tcnt = 0\\n\\t\\t}\\n\\t\\tif cnt == 2 {\\n\\t\\t\\tt := string(tmp) + string(tmp) + string(tmp)\\n\\t\\t\\ttt, _ := strconv.Atoi(t)\\n\\t\\t\\tn = append(n, tt)\\n\\t\\t\\tcnt = 0\\n\\t\\t}\\n\\t\\ttmp = num[i]\\n\\t}\\n\\tif len(n) == 0 {\\n\\t\\treturn \"\"\\n\\t}\\n\\tsort.Ints(n)\\n\\tans := strconv.Itoa(n[len(n)-1])\\n\\tif ans == \"0\" {\\n\\t\\treturn \"000\"\\n\\t}\\n\\treturn ans\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc largestGoodInteger(num string) string {\\n\\ttmp, cnt, n := num[0], 0, []int{}\\n\\tfor i := 1; i < len(num); i++ {\\n\\t\\tif tmp == num[i] {\\n\\t\\t\\tcnt += 1\\n\\t\\t} else {\\n\\t\\t\\tcnt = 0\\n\\t\\t}\\n\\t\\tif cnt == 2 {\\n\\t\\t\\tt := string(tmp) + string(tmp) + string(tmp)\\n\\t\\t\\ttt, _ := strconv.Atoi(t)\\n\\t\\t\\tn = append(n, tt)\\n\\t\\t\\tcnt = 0\\n\\t\\t}\\n\\t\\ttmp = num[i]\\n\\t}\\n\\tif len(n) == 0 {\\n\\t\\treturn \"\"\\n\\t}\\n\\tsort.Ints(n)\\n\\tans := strconv.Itoa(n[len(n)-1])\\n\\tif ans == \"0\" {\\n\\t\\treturn \"000\"\\n\\t}\\n\\treturn ans\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3219969,
                "title": "beats-100-typescript-4-liner-returns-first-match-instead-of-iterating-over-all-possibilities",
                "content": "\\n# Code\\n```\\n\\n//My Second and objectively Better Function\\n\\nconst matches = new Set([\\n    \\'999\\', \\'888\\', \\'777\\', \\'666\\', \\'555\\', \\'444\\', \\'333\\', \\'222\\', \\'111\\', \\'000\\'\\n])\\n\\nfunction largestGoodInteger(num: string): string {\\n    for(const match of matches) {\\n        if (num.includes(match)) {\\n            return match;\\n            //Returns as soon as value is found, as such a value will always be the highest \\n            //(as we start iterating from the highest values)\\n        } \\n    }\\n    return \\'\\'; //if none of the 10 values is found, return \\'\\';\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//My First Function\\n\\n/*function largestGoodInteger(num: string): string {\\n    const set = new Set([]);\\n    for(let i = 0; i < num.length-2; i++) {\\n        let curr = num[i];\\n        if(curr == num[i+1] && curr == num[i+2]) {\\n            set.add(+curr)\\n            if(set.size == 10) {\\n                return \\'999\\';\\n            }\\n        }\\n    }\\n    return set.size > 0 ? Math.max(...set).toString().repeat(3) : \\'\\';\\n};*/\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n\\n//My Second and objectively Better Function\\n\\nconst matches = new Set([\\n    \\'999\\', \\'888\\', \\'777\\', \\'666\\', \\'555\\', \\'444\\', \\'333\\', \\'222\\', \\'111\\', \\'000\\'\\n])\\n\\nfunction largestGoodInteger(num: string): string {\\n    for(const match of matches) {\\n        if (num.includes(match)) {\\n            return match;\\n            //Returns as soon as value is found, as such a value will always be the highest \\n            //(as we start iterating from the highest values)\\n        } \\n    }\\n    return \\'\\'; //if none of the 10 values is found, return \\'\\';\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//My First Function\\n\\n/*function largestGoodInteger(num: string): string {\\n    const set = new Set([]);\\n    for(let i = 0; i < num.length-2; i++) {\\n        let curr = num[i];\\n        if(curr == num[i+1] && curr == num[i+2]) {\\n            set.add(+curr)\\n            if(set.size == 10) {\\n                return \\'999\\';\\n            }\\n        }\\n    }\\n    return set.size > 0 ? Math.max(...set).toString().repeat(3) : \\'\\';\\n};*/\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167990,
                "title": "c-easy-solution",
                "content": "```\\n string largestGoodInteger(string a) {\\n        int n=a.size();\\n        int maxx=-11111;\\n        char maxch;\\n        int flag=0;\\n        for(int i=0;i<n-2;i++){\\n            if(a[i]==a[i+1] && a[i]==a[i+2]){\\n                if(a[i]-48 >= maxx){\\n                    maxx=(a[i]-48);\\n                    maxch=a[i];\\n                    flag=1;\\n                }\\n            }\\n        }\\n        string ans;\\n        if(flag==1){\\n            for(int i=0;i<3;i++) ans.push_back(maxch);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n string largestGoodInteger(string a) {\\n        int n=a.size();\\n        int maxx=-11111;\\n        char maxch;\\n        int flag=0;\\n        for(int i=0;i<n-2;i++){\\n            if(a[i]==a[i+1] && a[i]==a[i+2]){\\n                if(a[i]-48 >= maxx){\\n                    maxx=(a[i]-48);\\n                    maxch=a[i];\\n                    flag=1;\\n                }\\n            }\\n        }\\n        string ans;\\n        if(flag==1){\\n            for(int i=0;i<3;i++) ans.push_back(maxch);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3070249,
                "title": "python-easy-99-83-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n\\n        lst1 = [\\'999\\', \\'888\\', \\'777\\', \\'666\\', \\'555\\', \\'444\\', \\'333\\', \\'222\\', \\'111\\', \\'000\\']\\n        \\n        \\n        for x in lst1:\\n            if x in num:\\n                return(x)\\n                break\\n        else:\\n            return(\\'\\')\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n\\n        lst1 = [\\'999\\', \\'888\\', \\'777\\', \\'666\\', \\'555\\', \\'444\\', \\'333\\', \\'222\\', \\'111\\', \\'000\\']\\n        \\n        \\n        for x in lst1:\\n            if x in num:\\n                return(x)\\n                break\\n        else:\\n            return(\\'\\')\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935124,
                "title": "c-not-clever-but-simple-solution",
                "content": "```\\npublic class Solution {\\n    public string LargestGoodInteger(string num) {\\n        if(num.Contains(\"999\")) return \"999\";\\n        else if (num.Contains(\"888\")) return \"888\";\\n        else if (num.Contains(\"777\")) return \"777\";\\n        else if (num.Contains(\"666\")) return \"666\";\\n        else if (num.Contains(\"555\")) return \"555\";\\n        else if (num.Contains(\"444\")) return \"444\";\\n        else if (num.Contains(\"333\")) return \"333\";\\n        else if (num.Contains(\"222\")) return \"222\";\\n        else if (num.Contains(\"111\")) return \"111\";\\n        else if (num.Contains(\"000\")) return \"000\";\\n        else return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestGoodInteger(string num) {\\n        if(num.Contains(\"999\")) return \"999\";\\n        else if (num.Contains(\"888\")) return \"888\";\\n        else if (num.Contains(\"777\")) return \"777\";\\n        else if (num.Contains(\"666\")) return \"666\";\\n        else if (num.Contains(\"555\")) return \"555\";\\n        else if (num.Contains(\"444\")) return \"444\";\\n        else if (num.Contains(\"333\")) return \"333\";\\n        else if (num.Contains(\"222\")) return \"222\";\\n        else if (num.Contains(\"111\")) return \"111\";\\n        else if (num.Contains(\"000\")) return \"000\";\\n        else return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804322,
                "title": "largest-3-same-digit-number-in-string-solution-java",
                "content": "class Solution {\\n  public String largestGoodInteger(String num) {\\n    String ans = \"\";\\n\\n    for (int i = 2; i < num.length(); ++i)\\n      if (num.charAt(i - 2) == num.charAt(i - 1) && num.charAt(i - 1) == num.charAt(i) &&\\n          num.substring(i - 2, i + 1).compareTo(ans) > 0)\\n        ans = num.substring(i - 2, i + 1);\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n  public String largestGoodInteger(String num) {\\n    String ans = \"\";\\n\\n    for (int i = 2; i < num.length(); ++i)\\n      if (num.charAt(i - 2) == num.charAt(i - 1) && num.charAt(i - 1) == num.charAt(i) &&\\n          num.substring(i - 2, i + 1).compareTo(ans) > 0)\\n        ans = num.substring(i - 2, i + 1);\\n\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2682871,
                "title": "easy-approach-beginner-friendly-o-n",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        string largestGoodInteger(string num)\\n        {\\n\\n            string temp = \"\";\\n            string str;\\n            char c = num[0];\\n            str.push_back(c);\\n            for (int i = 1; i < num.length(); i++)\\n            {\\n                if (num[i] == c) str.push_back(num[i]);\\n                else\\n                {\\n                    c = num[i];\\n                    str = \"\";\\n                    i--;\\n                }\\n                if (str.length() == 3 && str > temp) temp = str;\\n            }\\n            return temp;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        string largestGoodInteger(string num)\\n        {\\n\\n            string temp = \"\";\\n            string str;\\n            char c = num[0];\\n            str.push_back(c);\\n            for (int i = 1; i < num.length(); i++)\\n            {\\n                if (num[i] == c) str.push_back(num[i]);\\n                else\\n                {\\n                    c = num[i];\\n                    str = \"\";\\n                    i--;\\n                }\\n                if (str.length() == 3 && str > temp) temp = str;\\n            }\\n            return temp;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651751,
                "title": "c-easy-to-understand-short-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        char good = \\'0\\'-1;\\n        \\n        for(int i = 0; i+2 < num.size(); i++){\\n            if(num[i] == num[i+1] && num[i+1] == num[i+2] && num[i]  > good)\\n                good = num[i];\\n        }\\n        \\n        if(good < \\'0\\') return \"\";\\n        \\n        return string(3,good);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        char good = \\'0\\'-1;\\n        \\n        for(int i = 0; i+2 < num.size(); i++){\\n            if(num[i] == num[i+1] && num[i+1] == num[i+2] && num[i]  > good)\\n                good = num[i];\\n        }\\n        \\n        if(good < \\'0\\') return \"\";\\n        \\n        return string(3,good);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599949,
                "title": "java-stringbuilder-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n=-1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                if(Integer.parseInt(sb.toString())>n)\\n                    n=Integer.parseInt(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        if(n==-1)\\n            return \"\";\\n        String s = Integer.toString(n);\\n        if(s.equals(\"0\"))\\n            return \"000\";\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n=-1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                if(Integer.parseInt(sb.toString())>n)\\n                    n=Integer.parseInt(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        if(n==-1)\\n            return \"\";\\n        String s = Integer.toString(n);\\n        if(s.equals(\"0\"))\\n            return \"000\";\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567084,
                "title": "java-2-ways-of-doing-it",
                "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String[] possibilities = {\"999\", \"888\", \"777\", \"666\", \"555\", \"444\", \"333\", \"222\", \"111\", \"000\"};\\n        for (String possible : possibilities) {\\n            if (num.indexOf(possible) != -1) {\\n                return possible;\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int max = Integer.MIN_VALUE;\\n        if (num.length() < 3) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < num.length() - 2; i++) {\\n            if (num.charAt(i) == num.charAt(i + 1) &&\\n                num.charAt(i) == num.charAt(i + 2)) {\\n                sb.append(num.charAt(i)).append(num.charAt(i + 1)).append(num.charAt(i + 2));\\n                int goodOne = Integer.parseInt(sb.toString());\\n                max = Math.max(max, goodOne);\\n                sb.setLength(0);\\n            }\\n        }\\n        if (max == Integer.MIN_VALUE) {\\n            return \"\";\\n        } else if (max == 0) {\\n            return \"000\";\\n        }\\n        return max + \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String[] possibilities = {\"999\", \"888\", \"777\", \"666\", \"555\", \"444\", \"333\", \"222\", \"111\", \"000\"};\\n        for (String possible : possibilities) {\\n            if (num.indexOf(possible) != -1) {\\n                return possible;\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int max = Integer.MIN_VALUE;\\n        if (num.length() < 3) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < num.length() - 2; i++) {\\n            if (num.charAt(i) == num.charAt(i + 1) &&\\n                num.charAt(i) == num.charAt(i + 2)) {\\n                sb.append(num.charAt(i)).append(num.charAt(i + 1)).append(num.charAt(i + 2));\\n                int goodOne = Integer.parseInt(sb.toString());\\n                max = Math.max(max, goodOne);\\n                sb.setLength(0);\\n            }\\n        }\\n        if (max == Integer.MIN_VALUE) {\\n            return \"\";\\n        } else if (max == 0) {\\n            return \"000\";\\n        }\\n        return max + \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550593,
                "title": "easy-java-solution-simple-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n = num.length();\\n        HashMap<Integer,String> map = new HashMap<Integer,String>();\\n        for(int i = 0 ; i < 10 ; i ++){\\n            int count = 0;\\n            String s = \"\";\\n            while(count++ != 3){\\n                s = s + (i);\\n            }\\n            int ans = num.indexOf(s);\\n            if(ans != -1){\\n                map.put(i+1,s);\\n            }\\n        }\\n        if(map.size() != 0){\\n            int max = 0;\\n            for(Map.Entry<Integer,String> e : map.entrySet()){\\n                if(e.getKey() > max){\\n                    max = e.getKey();\\n                }\\n            }\\n            return map.get(max);\\n        }\\n        return \"\";\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n = num.length();\\n        HashMap<Integer,String> map = new HashMap<Integer,String>();\\n        for(int i = 0 ; i < 10 ; i ++){\\n            int count = 0;\\n            String s = \"\";\\n            while(count++ != 3){\\n                s = s + (i);\\n            }\\n            int ans = num.indexOf(s);\\n            if(ans != -1){\\n                map.put(i+1,s);\\n            }\\n        }\\n        if(map.size() != 0){\\n            int max = 0;\\n            for(Map.Entry<Integer,String> e : map.entrySet()){\\n                if(e.getKey() > max){\\n                    max = e.getKey();\\n                }\\n            }\\n            return map.get(max);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461868,
                "title": "python-easy-solution",
                "content": "```\\na=[]\\n        for i in range(len(num)-1):\\n            if(num[i]==num[i+1]==num[i-1]):\\n                a.append(int(num[i]))\\n\\n        if(len(a)!=0):\\n            b=max(a)\\n            return (str(b)*3)\\n        else:\\n            return(\"\")",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\na=[]\\n        for i in range(len(num)-1):\\n            if(num[i]==num[i+1]==num[i-1]):\\n                a.append(int(num[i]))\\n\\n        if(len(a)!=0):\\n            b=max(a)\\n            return (str(b)*3)\\n        else:\\n            return(\"\")",
                "codeTag": "Unknown"
            },
            {
                "id": 2385105,
                "title": "python-easy-straightforward",
                "content": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        num = \"0\"+num+\"0\"\\n        i=0\\n        l=len(num)\\n        max_=-1\\n        for i in range(1,l-1):\\n            if num[i]==num[i-1]==num[i+1]:\\n                max_=max(int(num[i]),max_)\\n        if max_==-1:\\n            return \"\"\\n        return str(max_)*3\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        num = \"0\"+num+\"0\"\\n        i=0\\n        l=len(num)\\n        max_=-1\\n        for i in range(1,l-1):\\n            if num[i]==num[i-1]==num[i+1]:\\n                max_=max(int(num[i]),max_)\\n        if max_==-1:\\n            return \"\"\\n        return str(max_)*3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345385,
                "title": "c-easy-solution-8ms-string-conversion-100-understandable-have-a-nice-day",
                "content": "Logic:\\nwe are simply checking 3 consecutive numbers first, if every number is same. then we proceed, else not.\\nwe simply find the integer value of these 3 digits. and according to the max value we found in this process. we store its corresponding string in our final ans string variable.\\n\\n```\\nstring largestGoodInteger(string num) {\\n\\t\\t//CD stands for current candidate, fs is final string ans.\\n        string cd=\"\",fs=\"\";\\n\\t\\t//Current string val, final string val.\\n        int cv=0,fv=0;\\n\\t\\t\\n        for(int i=2;i<=num.size()-1;i++){\\n           //Checking all 3 values, if equal then we proceed.\\n\\t\\tif(num[i-2]==num[i-1]&&num[i-1]==num[i]){\\n                cd=cd+num[i-2]+num[i-1]+num[i];\\n\\t\\t\\t\\t//Taking out the int value of the string to compare and store our result.\\n\\t\\t\\t\\t//Its like finding the maximum value in an array.\\n                cv=stoi(cd);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//If the current value is greater than final string value, change final string.\\n                if(cv>=fv){\\n                    fv=cv;\\n                    fs=cd;\\n                    cv=0;\\n                    \\n                }\\n\\t\\t\\t\\t//Clearing the string variable for next iteration.\\n                    cd=\"\";\\n            }\\n        }        \\n\\t\\t//Returning ans at last.\\n        return fs;\\n    }\\n\\n```\\n\\n\\nPls upvote if u loved it, or do comment for any suggestions.\\nThank u for your time leetcoders.\\nHAPPY LEETCODING.",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nstring largestGoodInteger(string num) {\\n\\t\\t//CD stands for current candidate, fs is final string ans.\\n        string cd=\"\",fs=\"\";\\n\\t\\t//Current string val, final string val.\\n        int cv=0,fv=0;\\n\\t\\t\\n        for(int i=2;i<=num.size()-1;i++){\\n           //Checking all 3 values, if equal then we proceed.\\n\\t\\tif(num[i-2]==num[i-1]&&num[i-1]==num[i]){\\n                cd=cd+num[i-2]+num[i-1]+num[i];\\n\\t\\t\\t\\t//Taking out the int value of the string to compare and store our result.\\n\\t\\t\\t\\t//Its like finding the maximum value in an array.\\n                cv=stoi(cd);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//If the current value is greater than final string value, change final string.\\n                if(cv>=fv){\\n                    fv=cv;\\n                    fs=cd;\\n                    cv=0;\\n                    \\n                }\\n\\t\\t\\t\\t//Clearing the string variable for next iteration.\\n                    cd=\"\";\\n            }\\n        }        \\n\\t\\t//Returning ans at last.\\n        return fs;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276113,
                "title": "simple-python3-solution-brute-force-approach-o-3-space-o-n-time-faster-than-97-58",
                "content": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        ss = 0\\n        res=\\'\\'\\n        for i in set(num):\\n            if i*3 in num:\\n                if ss <= int(i):\\n                    ss = int(i)\\n                    res=i*3\\n        return res\\n```\\n\\n**Runtime: 30 ms\\nfaster than 97.58% \\nTime: O(n)**\\n\\n***Please UPVOTE, if you found my code helpful.***\\n\\n*Please do help me to optimize this code.*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        ss = 0\\n        res=\\'\\'\\n        for i in set(num):\\n            if i*3 in num:\\n                if ss <= int(i):\\n                    ss = int(i)\\n                    res=i*3\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268445,
                "title": "c-sliding-window-with-comments",
                "content": "class Solution {\\npublic:\\n\\n    //sliding window\\n    string largestGoodInteger(string num) {\\n        int i = 0;\\n        int j = 0;\\n        string s = \"\";\\n        int x = 0;\\n        int mx = 0;\\n        string ans = \"\";\\n        while(j < num.size()){\\n           //calculation\\n            s += num[j];\\n            if(j - i +1  < 3){\\n                j++;\\n            }\\n           else if(j - i +1 == 3){\\n              //checking for if string is same digit of not\\n\\t\\t\\t  //from calculation find the answer\\n              if(s[0] == s[1] && s[0] == s[2] && s[1] == s[2]){\\n                  //convrting string s to int so that we can find the maximum value\\n                  x = stoi(s);\\n                  //calculating maximum\\n                  mx = max(mx , x);\\n                  //again converting maximum value to string \\n                 ans = to_string(mx);\\n                  //handling speacial case of trailing zero \\n                  if(mx == 0){\\n                      ans = \"000\";\\n                  }  \\n              }\\n               //when window hit the size the we increase the remove the calculation from s\\n               s.erase(0, 1);\\n               j++;\\n               i++;\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    //sliding window\\n    string largestGoodInteger(string num) {\\n        int i = 0;\\n        int j = 0;\\n        string s = \"\";\\n        int x = 0;\\n        int mx = 0;\\n        string ans = \"\";\\n        while(j < num.size()){\\n           //calculation\\n            s += num[j];\\n            if(j - i +1  < 3){\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2210544,
                "title": "c-solution-faster-than-100",
                "content": "string largestGoodInteger(string num) {\\n        string res=\"\";\\n        for(int i=0;i<num.size()-2;i++)\\n        {\\n            if(num[i]==num[i+1] && num[i+1]==num[i+2])\\n            {\\n                string t=num.substr(i,3);\\n                if(t>res)\\n                    res=t;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "string largestGoodInteger(string num) {\\n        string res=\"\";\\n        for(int i=0;i<num.size()-2;i++)\\n        {\\n            if(num[i]==num[i+1] && num[i+1]==num[i+2])\\n            {\\n                string t=num.substr(i,3);\\n                if(t>res)\\n                    res=t;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2205182,
                "title": "using-three-pointers-simple-approach",
                "content": "```\\n def largestGoodInteger(self, num: str) -> str:\\n        pos =  2\\n        res = \"\"\\n        while(pos < len(num)):\\n            nex = num[pos]\\n            curr = num[pos-1]\\n            prev = num[pos-2]\\n            if(prev == curr and curr == nex):\\n                temp = prev + curr + nex\\n                if( res < temp):\\n                    res = temp\\n                pos+=2                   \\n            pos+=1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n def largestGoodInteger(self, num: str) -> str:\\n        pos =  2\\n        res = \"\"\\n        while(pos < len(num)):\\n            nex = num[pos]\\n            curr = num[pos-1]\\n            prev = num[pos-2]\\n            if(prev == curr and curr == nex):\\n                temp = prev + curr + nex\\n                if( res < temp):\\n                    res = temp\\n                pos+=2                   \\n            pos+=1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2194124,
                "title": "easy-python",
                "content": "class Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        maxs=[]\\n        ans=\\'0\\'\\n        for i in range(2,len(num)):\\n            if num[i]==num[i-1]==num[i-2]:\\n                maxs.append(str(num[i]+num[i-1]+num[i-2]))\\n        if len(maxs)==0:\\n            return \"\"\\n        elif len(maxs)==1:\\n            return \"\".join(maxs)\\n        else:\\n            for i in maxs:\\n                ans=max(ans,str(i))\\n        return str(ans)\\n                \\n        \\n                \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        maxs=[]\\n        ans=\\'0\\'\\n        for i in range(2,len(num)):\\n            if num[i]==num[i-1]==num[i-2]:\\n                maxs.append(str(num[i]+num[i-1]+num[i-2]))\\n        if len(maxs)==0:\\n            return \"\"\\n        elif len(maxs)==1:\\n            return \"\".join(maxs)\\n        else:\\n            for i in maxs:\\n                ans=max(ans,str(i))\\n        return str(ans)\\n                \\n        \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 2167791,
                "title": "python-solution",
                "content": "```\\nlst = []\\nfor i in range(len(num)-2):\\n\\t# print(int(num[i:i+3]))\\n\\tif int(num[i:i+3]) % 111 == 0:\\n\\t\\tlst.append((num[i:i+3]))\\n\\nreturn max(lst) if lst else \"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nlst = []\\nfor i in range(len(num)-2):\\n\\t# print(int(num[i:i+3]))\\n\\tif int(num[i:i+3]) % 111 == 0:\\n\\t\\tlst.append((num[i:i+3]))\\n\\nreturn max(lst) if lst else \"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2126775,
                "title": "for-noobs-like-me",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        string ans = \"\";\\n        int c = 0;\\n        for (int i = 0; i < num.length() - 2; i++)\\n            if (num[i] == num[i + 1] && num[i + 1] == num[i + 2])\\n            {\\n                int a = stoi (num.substr(i, 3));\\n                if (a >= c)\\n                {\\n                    ans = num.substr(i, 3);\\n                    c = a;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```\\n\\nMuch Better Code - (From votrubac)\\n\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        char res = 0;\\n        for(int i = 2; i < num.size(); ++i)\\n            if (num[i] == num[i - 1] && num[i] == num[i - 2])\\n                res = max(res, num[i]);\\n        return res == 0 ? \"\" : string(3, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        string ans = \"\";\\n        int c = 0;\\n        for (int i = 0; i < num.length() - 2; i++)\\n            if (num[i] == num[i + 1] && num[i + 1] == num[i + 2])\\n            {\\n                int a = stoi (num.substr(i, 3));\\n                if (a >= c)\\n                {\\n                    ans = num.substr(i, 3);\\n                    c = a;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        char res = 0;\\n        for(int i = 2; i < num.size(); ++i)\\n            if (num[i] == num[i - 1] && num[i] == num[i - 2])\\n                res = max(res, num[i]);\\n        return res == 0 ? \"\" : string(3, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090541,
                "title": "just-tried-to-be-clever-java-lol-implementation",
                "content": "I don\\'t think anything could be easy than this!         (  hehe ) \\n\\nclass Solution{\\n\\n    public String largestGoodInteger(String num)\\n\\t{\\n        String[] possible={\"000\",\"111\",\"222\",\"333\",\"444\",\"555\",\"666\",\"777\",\"888\",\"999\"};\\n\\t\\t\\n        for(int i=9;i>=0;i--){\\n        if(num.indexOf(possible[i])!=-1)  return possible[i];\\n        }\\n        \\n       return \"\";\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution{\\n\\n    public String largestGoodInteger(String num)\\n\\t{\\n        String[] possible={\"000\",\"111\",\"222\",\"333\",\"444\",\"555\",\"666\",\"777\",\"888\",\"999\"}",
                "codeTag": "Java"
            },
            {
                "id": 2045422,
                "title": "compare-with-previous-2-char-javascript",
                "content": "**Javascript** \\n```js\\nvar largestGoodInteger = function(num) {\\n    let res = -1;\\n    for(let i = 2; i < num.length; i++) {\\n        if(num[i] === num[i - 1] && num[i] === num[i - 2]) {\\n            res = Math.max(res, +num[i]);\\n        }\\n    }\\n    \\n    return res === -1 ? \"\" : `${res}`.repeat(3)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```js\\nvar largestGoodInteger = function(num) {\\n    let res = -1;\\n    for(let i = 2; i < num.length; i++) {\\n        if(num[i] === num[i - 1] && num[i] === num[i - 2]) {\\n            res = Math.max(res, +num[i]);\\n        }\\n    }\\n    \\n    return res === -1 ? \"\" : `${res}`.repeat(3)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2040878,
                "title": "c-set-and-sliding-window-approach",
                "content": "```\\n string largestGoodInteger(string num) {\\n        \\n        string s=\"\";\\n        \\n        \\n        multiset<char> st;\\n        \\n        set<char> ch;\\n        \\n        for(int i=0;i<3;i++){\\n            st.insert(num[i]);\\n            s+=num[i];\\n        }\\n        \\n        \\n        for(auto x : s){\\n           ch.insert(x);\\n        }\\n        \\n        vector<string> ans;\\n       \\n        \\n        \\n        if(ch.size()==1) ans.push_back(s);\\n         ch.clear();\\n        \\n        for(int i=3;i<num.size();i++){\\n            s.erase(s.begin());\\n            s+=num[i];\\n            st.erase(st.find(num[i-3]));\\n            st.insert(num[i]);\\n            \\n              for(auto x : s){\\n                   ch.insert(x);\\n               }\\n            \\n\\n               if(ch.size()==1) ans.push_back(s);\\n                           ch.clear();\\n        }\\n        \\n        \\n        sort(ans.begin(),ans.end(),greater<string>());\\n        \\n        \\n        return ans.size() ? ans[0] : \"\" ;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n string largestGoodInteger(string num) {\\n        \\n        string s=\"\";\\n        \\n        \\n        multiset<char> st;\\n        \\n        set<char> ch;\\n        \\n        for(int i=0;i<3;i++){\\n            st.insert(num[i]);\\n            s+=num[i];\\n        }\\n        \\n        \\n        for(auto x : s){\\n           ch.insert(x);\\n        }\\n        \\n        vector<string> ans;\\n       \\n        \\n        \\n        if(ch.size()==1) ans.push_back(s);\\n         ch.clear();\\n        \\n        for(int i=3;i<num.size();i++){\\n            s.erase(s.begin());\\n            s+=num[i];\\n            st.erase(st.find(num[i-3]));\\n            st.insert(num[i]);\\n            \\n              for(auto x : s){\\n                   ch.insert(x);\\n               }\\n            \\n\\n               if(ch.size()==1) ans.push_back(s);\\n                           ch.clear();\\n        }\\n        \\n        \\n        sort(ans.begin(),ans.end(),greater<string>());\\n        \\n        \\n        return ans.size() ? ans[0] : \"\" ;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038379,
                "title": "javascript-time-o-n-space-o-1",
                "content": "```\\nconst largestGoodInteger = function(num) {\\n    let a = 0\\n    let maxGood = \\'\\'\\n    while (a < num.length - 2) {\\n        let b = a + 1\\n        let c = b + 1    \\n        if (num[a] === num[b] && num[b] === num[c]) {\\n            if ((num[a] + num[b] + num[c]) > maxGood) {\\n                maxGood = num[a].repeat(3)\\n            }\\n        }\\n        a++\\n    }\\n    return maxGood\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst largestGoodInteger = function(num) {\\n    let a = 0\\n    let maxGood = \\'\\'\\n    while (a < num.length - 2) {\\n        let b = a + 1\\n        let c = b + 1    \\n        if (num[a] === num[b] && num[b] === num[c]) {\\n            if ((num[a] + num[b] + num[c]) > maxGood) {\\n                maxGood = num[a].repeat(3)\\n            }\\n        }\\n        a++\\n    }\\n    return maxGood\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2036449,
                "title": "swift-easy-solution",
                "content": "\\n```\\nfunc largestGoodInteger(_ num: String) -> String {\\n\\tvar last = Character(\" \")\\n\\tvar maximum = -1\\n\\tvar counter = 0\\n\\n\\tfor char in num {\\n\\t\\tcounter = (last == char) ? counter + 1 : 1\\n\\t\\tlast = char\\n\\n\\t\\tif counter == 3 {\\n\\t\\t\\tmaximum = max(maximum, Int(String(char))!)\\n\\t\\t}\\n\\t}\\n\\n\\treturn maximum < 0 ? \"\" : \"\\\\(maximum)\\\\(maximum)\\\\(maximum)\"\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc largestGoodInteger(_ num: String) -> String {\\n\\tvar last = Character(\" \")\\n\\tvar maximum = -1\\n\\tvar counter = 0\\n\\n\\tfor char in num {\\n\\t\\tcounter = (last == char) ? counter + 1 : 1\\n\\t\\tlast = char\\n\\n\\t\\tif counter == 3 {\\n\\t\\t\\tmaximum = max(maximum, Int(String(char))!)\\n\\t\\t}\\n\\t}\\n\\n\\treturn maximum < 0 ? \"\" : \"\\\\(maximum)\\\\(maximum)\\\\(maximum)\"\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035868,
                "title": "python3-1-line",
                "content": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        return max([num[i:i+3] for i in range(len(num)-2) if num[i]==num[i+1]==num[i+2]],default=\\'\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        return max([num[i:i+3] for i in range(len(num)-2) if num[i]==num[i+1]==num[i+2]],default=\\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028596,
                "title": "c-easy-solution",
                "content": "\\n\\tstring largestGoodInteger(string num) {\\n        if(num.length()<3)return \"\";\\n        string ans=\"\";\\n        for(int i=1;i<num.length()-1;i++){\\n            if(num[i-1]==num[i] && num[i]==num[i+1]){\\n                if(ans==\"\" || ans[0]<num[i]){\\n                ans = num.substr(i-1,3);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\n\\tstring largestGoodInteger(string num) {\\n        if(num.length()<3)return \"\";\\n        string ans=\"\";\\n        for(int i=1;i<num.length()-1;i++){\\n            if(num[i-1]==num[i] && num[i]==num[i+1]){\\n                if(ans==\"\" || ans[0]<num[i]){\\n                ans = num.substr(i-1,3);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2023498,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String n) {\\n        for(int i=9;i>=0;i--)\\n        {\\n            StringBuilder nm=new StringBuilder();\\n            for(int j=1;j<=3;j++)\\n            {\\n                nm.append(i);\\n            }\\n            if(n.contains(nm.toString()))\\n                return nm.toString();\\n        }\\n        return \"\";\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String largestGoodInteger(String n) {\\n        for(int i=9;i>=0;i--)\\n        {\\n            StringBuilder nm=new StringBuilder();\\n            for(int j=1;j<=3;j++)\\n            {\\n                nm.append(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2022499,
                "title": "php-100-speed-100-mem-simple",
                "content": "![image](https://assets.leetcode.com/users/images/211b3255-ad7e-4ac8-a326-d112035a0fad_1652098181.715758.png)\\n```\\nclass Solution\\n{\\n    const PATTERNS = [\\n      \"999\",\\n      \"888\",\\n      \"777\",\\n      \"666\",\\n      \"555\",\\n      \"444\",\\n      \"333\",\\n      \"222\",\\n      \"111\",\\n      \"000\",\\n    ];\\n\\n    /**\\n     * @param String $num\\n     * @return String\\n     */\\n    public function largestGoodInteger($num)\\n    {\\n        foreach (self::PATTERNS as $pattern) {\\n            if (str_contains($num, $pattern)) {\\n                return $pattern;\\n            }\\n        }\\n        return \\'\\';\\n    }\\n}\\n",
                "solutionTags": [
                    "PHP"
                ],
                "code": "class Solution\\n{\\n    const PATTERNS = [\\n      \"999\",\\n      \"888\",\\n      \"777\",\\n      \"666\",\\n      \"555\",\\n      \"444\",\\n      \"333\",\\n      \"222\",\\n      \"111\",\\n      \"000\",\\n    ];\\n\\n    /**\\n     * @param String $num\\n     * @return String\\n     */\\n    public function largestGoodInteger($num)\\n    {\\n        foreach (self::PATTERNS as $pattern) {\\n            if (str_contains($num, $pattern)) {\\n                return $pattern;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2021732,
                "title": "java-compare-all-the-valid-substrings-that-follow-the-rule",
                "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        \\n        String ans = \"\";\\n        for(int i=2; i< num.length(); i++){\\n            if(num.charAt(i) == num.charAt(i-1) && num.charAt(i-1) == num.charAt(i-2)){\\n                if(ans.length() == 0){\\n                    ans = num.substring(i-2, i+1);\\n                }else{\\n                    if(ans.compareTo(num.substring(i-2, i+1)) < 0){\\n                        ans = num.substring(i-2, i+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        \\n        String ans = \"\";\\n        for(int i=2; i< num.length(); i++){\\n            if(num.charAt(i) == num.charAt(i-1) && num.charAt(i-1) == num.charAt(i-2)){\\n                if(ans.length() == 0){\\n                    ans = num.substring(i-2, i+1);\\n                }else{\\n                    if(ans.compareTo(num.substring(i-2, i+1)) < 0){\\n                        ans = num.substring(i-2, i+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021711,
                "title": "largest-3-same-digit-number-in-string-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string res = \"\";\\n        \\n        int tempNum = 0;\\n        \\n        for(int i=0;i<num.length()-2;i++){\\n            int numCheck = num[i]-48;\\n\\t\\t\\t//Check with previous 2 digit same or not\\n            if((tempNum<=numCheck) && (num[i] == num[i+1]) && (num[i] == num[i+2]) && (num[i] != num[i+3])){\\n                res = \"\";\\n                res += num[i];\\n                res += num[i];\\n                res += num[i];\\n                tempNum = numCheck;\\n                i +=2;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string res = \"\";\\n        \\n        int tempNum = 0;\\n        \\n        for(int i=0;i<num.length()-2;i++){\\n            int numCheck = num[i]-48;\\n\\t\\t\\t//Check with previous 2 digit same or not\\n            if((tempNum<=numCheck) && (num[i] == num[i+1]) && (num[i] == num[i+2]) && (num[i] != num[i+3])){\\n                res = \"\";\\n                res += num[i];\\n                res += num[i];\\n                res += num[i];\\n                tempNum = numCheck;\\n                i +=2;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020932,
                "title": "go-golang-solution",
                "content": "```go\\nfunc largestGoodInteger(num string) string {\\n    ans, n := -1, len(num)\\n    for i := 1; i < n - 1; i++ {\\n        if num[i - 1] == num[i] && num[i] == num[i + 1] {\\n            ans = max(ans, int(num[i] - \\'0\\'))\\n        }\\n    }\\n    if ans == -1 { return \"\" }\\n    return string(ans + \\'0\\') + string(ans + \\'0\\') + string(ans + \\'0\\')\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc largestGoodInteger(num string) string {\\n    ans, n := -1, len(num)\\n    for i := 1; i < n - 1; i++ {\\n        if num[i - 1] == num[i] && num[i] == num[i + 1] {\\n            ans = max(ans, int(num[i] - \\'0\\'))\\n        }\\n    }\\n    if ans == -1 { return \"\" }\\n    return string(ans + \\'0\\') + string(ans + \\'0\\') + string(ans + \\'0\\')\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2020088,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string s) {\\n        string m=\"\";\\n        for(int i=1;i<s.length()-1;i+=1){\\n            string st=\"\";\\n            if(s[i]==s[i-1] and s[i]==s[i+1]){\\n            st+=s[i-1];\\n            st+=s[i];\\n            st+=s[i+1];\\n            m=max(st,m);\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string s) {\\n        string m=\"\";\\n        for(int i=1;i<s.length()-1;i+=1){\\n            string st=\"\";\\n            if(s[i]==s[i-1] and s[i]==s[i+1]){\\n            st+=s[i-1];\\n            st+=s[i];\\n            st+=s[i+1];\\n            m=max(st,m);\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019973,
                "title": "easy-java-c-solutions-beat-100-0ms",
                "content": "The idea is to check for a number starting from 999 to 000.  We start checking from 999 because we need to find the maximum substring. At each step, we subtract 1 from each digit. Please write your thoughts about this solution.\\n# Java\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        StringBuilder toFind = new StringBuilder(\"999\");\\n        \\n        for (int i = 10; i > 0; i--) {\\n            if (num.indexOf(toFind.toString()) != -1) {\\n                return toFind.toString();\\n            }\\n            \\n            for (int j = 0; j < 3; j++) {\\n                toFind.setCharAt(j, (char) (toFind.charAt(j) - 1));\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string toFind = \"999\";\\n        \\n        for (int i = 0; i < 10; i++) {\\n            if (num.find(toFind) != string::npos) {\\n                return toFind;\\n            }\\n            \\n            for (int j = 0; j < 3; j++) {\\n                toFind[j]--;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        StringBuilder toFind = new StringBuilder(\"999\");\\n        \\n        for (int i = 10; i > 0; i--) {\\n            if (num.indexOf(toFind.toString()) != -1) {\\n                return toFind.toString();\\n            }\\n            \\n            for (int j = 0; j < 3; j++) {\\n                toFind.setCharAt(j, (char) (toFind.charAt(j) - 1));\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string toFind = \"999\";\\n        \\n        for (int i = 0; i < 10; i++) {\\n            if (num.find(toFind) != string::npos) {\\n                return toFind;\\n            }\\n            \\n            for (int j = 0; j < 3; j++) {\\n                toFind[j]--;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019714,
                "title": "python-faster-than-50-less-than-100",
                "content": "Runtime: 77 ms, faster than 50.00% of Python online submissions for Largest 3-Same-Digit Number in String.\\nMemory Usage: 13.5 MB, less than 100.00% of Python online submissions for Largest 3-Same-Digit Number in String.\\n```\\n    def largestGoodInteger(self, num):\\n        \"\"\"\\n        :type num: str\\n        :rtype: str\\n        \"\"\"\\n        result = \"\"\\n        result_num = 0\\n        for i in range(len(num)-2):\\n            num1 = int(num[i])\\n            num2 = int(num[i+1])            \\n            num3 = int(num[i+2])\\n            if (num1==num2 and num2==num3):\\n                if result_num <= (num1*100+num2*10+num3):\\n                    result = num[i]+num[i+1]+num[i+2]\\n                    result_num = int(result)\\n        return result  \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def largestGoodInteger(self, num):\\n        \"\"\"\\n        :type num: str\\n        :rtype: str\\n        \"\"\"\\n        result = \"\"\\n        result_num = 0\\n        for i in range(len(num)-2):\\n            num1 = int(num[i])\\n            num2 = int(num[i+1])            \\n            num3 = int(num[i+2])\\n            if (num1==num2 and num2==num3):\\n                if result_num <= (num1*100+num2*10+num3):\\n                    result = num[i]+num[i+1]+num[i+2]\\n                    result_num = int(result)\\n        return result  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2019599,
                "title": "o-n-java-solution-o-1-space",
                "content": "```\\n\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String ans = \"\";\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < num.length()-2 ; i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                if(Character.getNumericValue(num.charAt(i))>max){\\n                    max=Character.getNumericValue(num.charAt(i));\\n                    ans=num.substring(i,i+3);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String ans = \"\";\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < num.length()-2 ; i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                if(Character.getNumericValue(num.charAt(i))>max){\\n                    max=Character.getNumericValue(num.charAt(i));\\n                    ans=num.substring(i,i+3);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019342,
                "title": "probably-the-easiest-solution-c",
                "content": "There are better solutions availabe, here I\\'m trying to present a code that is really easy to understand\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int x = 0;\\n        string s = \"\";\\n        for(int i = 1; i + 1 < num.size(); ++i){\\n            if(num[i] == num[i - 1] && num[i] == num[i + 1]){\\n                string p = \"\";\\n                p += num[i];\\n                p += num[i];\\n                p += num[i];                                  //adding the number three times (can also be done by using substr())\\n                if(stoi(p) >= x)                              //stoi converts strig to int\\n                    x = stoi(p), s = p;                      //if current number is greater than previous seen number we update\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int x = 0;\\n        string s = \"\";\\n        for(int i = 1; i + 1 < num.size(); ++i){\\n            if(num[i] == num[i - 1] && num[i] == num[i + 1]){\\n                string p = \"\";\\n                p += num[i];\\n                p += num[i];\\n                p += num[i];                                  //adding the number three times (can also be done by using substr())\\n                if(stoi(p) >= x)                              //stoi converts strig to int\\n                    x = stoi(p), s = p;                      //if current number is greater than previous seen number we update\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019064,
                "title": "c-easy-o-n-complexity",
                "content": "class Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n     const int n = num.size();\\n     string ans = \"\";\\n     int start = 0;   \\n       for(int i = 0;i<n;i++){\\n          \\n     if(i <n-1 and num[i]==num[i+1]) continue;\\n          else{\\n               if(i-start+1>=3)ans = max(ans,num.substr(start,3));\\n               start = i+1;     \\n          }       \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n     const int n = num.size();\\n     string ans = \"\";\\n     int start = 0;   \\n       for(int i = 0;i<n;i++){\\n          \\n     if(i <n-1 and num[i]==num[i+1]) continue;\\n          else{\\n               if(i-start+1>=3)ans = max(ans,num.substr(start,3));\\n               start = i+1;     \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2018846,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string str=\"\";\\n        int maxi=-1;\\n        for(int i=0;i<num.size()-2;i++)\\n            if(num[i]==num[i+1]  && num[i]==num[i+2])   \\n\\t\\t\\t\\tmaxi=max(maxi,num[i]-\\'0\\');\\n       \\n        if(maxi==-1)    return str;\\n        for(int i=0;i<3;i++)    str+=(maxi+\\'0\\');\\n        return str;\\n    }\\n};\\n```\\n\\nif you liked the solution, then please upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string str=\"\";\\n        int maxi=-1;\\n        for(int i=0;i<num.size()-2;i++)\\n            if(num[i]==num[i+1]  && num[i]==num[i+2])   \\n\\t\\t\\t\\tmaxi=max(maxi,num[i]-\\'0\\');\\n       \\n        if(maxi==-1)    return str;\\n        for(int i=0;i<3;i++)    str+=(maxi+\\'0\\');\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018411,
                "title": "java-indexof-4-liner",
                "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        for(int i=9; i>=0; i--){\\n            String str = String.valueOf(i);\\n            String s = IntStream.range(0, 3).mapToObj(a ->str).collect(Collectors.joining(\"\"));\\n            if(num.indexOf(s)!=-1) return s;    \\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        for(int i=9; i>=0; i--){\\n            String str = String.valueOf(i);\\n            String s = IntStream.range(0, 3).mapToObj(a ->str).collect(Collectors.joining(\"\"));\\n            if(num.indexOf(s)!=-1) return s;    \\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018143,
                "title": "easy-one-pass-comapre-only-next-or-previous",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans;\\n     for(int i=2;i<num.size();i++)\\n     {\\n         if(num[i]==num[i-1] && num[i]==num[i-2])\\n             ans=max(ans,string (3,num[i]));\\n         \\n     }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans;\\n     for(int i=2;i<num.size();i++)\\n     {\\n         if(num[i]==num[i-1] && num[i]==num[i-2])\\n             ans=max(ans,string (3,num[i]));\\n         \\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2018114,
                "title": "java",
                "content": "class Solution {\\n    public String largestGoodInteger(String num) {\\n      \\n        String str=\"\";\\n        int n=Integer.MIN_VALUE;\\n        for(int i=0;i<num.length()-2;i++)\\n        {\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i+1)==num.charAt(i+2))\\n            {\\n                String t=\"\"+num.charAt(i)+num.charAt(i)+num.charAt(i);\\n                if(Integer.parseInt(t)>n)\\n                {\\n                    n=Integer.parseInt(t);\\n                }\\n            }\\n        }\\n        \\n        if(n==Integer.MIN_VALUE)\\n            return \"\";\\n        if(n==0)\\n            return \"000\";\\n        return Integer.toString(n);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String largestGoodInteger(String num) {\\n      \\n        String str=\"\";\\n        int n=Integer.MIN_VALUE;\\n        for(int i=0;i<num.length()-2;i++)\\n        {\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i+1)==num.charAt(i+2))\\n            {\\n                String t=\"\"+num.charAt(i)+num.charAt(i)+num.charAt(i);\\n                if(Integer.parseInt(t)>n)\\n                {\\n                    n=Integer.parseInt(t);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2018094,
                "title": "largest-3-same-digit-number-in-string",
                "content": "class Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        \\n        r=-2**63-1\\n        stri=\\'\\'\\n        for i in range(len(num) -2):\\n            n=num[i:i+3]\\n            print(n)\\n            if (len(set(n))==1):\\n                print(\"holla\",n,r)\\n                stri=max(int(n),r)\\n                r=stri\\n        print(r)\\n        if r<0:\\n            return \\'\\'\\n        if r==0:\\n            return \\'000\\'\\n        return str(r)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        \\n        r=-2**63-1\\n        stri=\\'\\'\\n        for i in range(len(num) -2):\\n            n=num[i:i+3]\\n            print(n)\\n            if (len(set(n))==1):\\n                print(\"holla\",n,r)\\n                stri=max(int(n),r)\\n                r=stri\\n        print(r)\\n        if r<0:\\n            return \\'\\'\\n        if r==0:\\n            return \\'000\\'\\n        return str(r)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2018069,
                "title": "largest-3-digit",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n      vector<char>v;\\n        int n=num.size()-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]==num[i+1] and num[i]==num[i+2])\\n            {\\n                v.push_back(num[i]);\\n            }\\n        }\\n           if(v.size()==0)\\n           \\n               return \"\";\\n           \\n            sort(v.begin(),v.end());\\n        char x=v[v.size()-1];\\n            string ans=\"\";\\n            for(int i=0;i<3;i++)\\n            {\\n                ans+=x;\\n            } \\n               \\n         return ans;        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n      vector<char>v;\\n        int n=num.size()-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]==num[i+1] and num[i]==num[i+2])\\n            {\\n                v.push_back(num[i]);\\n            }\\n        }\\n           if(v.size()==0)\\n           \\n               return \"\";\\n           \\n            sort(v.begin(),v.end());\\n        char x=v[v.size()-1];\\n            string ans=\"\";\\n            for(int i=0;i<3;i++)\\n            {\\n                ans+=x;\\n            } \\n               \\n         return ans;        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018039,
                "title": "very-easy-java-o-n-approach-simple-logic",
                "content": "Amidst, all the **server issues with Leetcode** during the contest today, I managed to solve this one question :) I tried implementing the solution with a **very basic and logical** approach, and with the help of **Collections Framework** in java I computed the result. Please **upvote**, it really helps me to write even better in future. **Happy Coding :)**\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        ArrayList<Integer> result=new ArrayList<>();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2))\\n            {\\n                StringBuilder sb=new StringBuilder();\\n                for(int j=0;j<3;j++){\\n                    sb.append(num.charAt(i));\\n                }\\n                result.add(Integer.parseInt(sb.toString()));\\n                i+=2;\\n            }    \\n        }\\n        if(result.size()==0)\\n            return \"\";\\n        int answer=Collections.max(result);\\n        if(answer==0)\\n            return \"000\";\\n        return Integer.toString(answer);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        ArrayList<Integer> result=new ArrayList<>();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2))\\n            {\\n                StringBuilder sb=new StringBuilder();\\n                for(int j=0;j<3;j++){\\n                    sb.append(num.charAt(i));\\n                }\\n                result.add(Integer.parseInt(sb.toString()));\\n                i+=2;\\n            }    \\n        }\\n        if(result.size()==0)\\n            return \"\";\\n        int answer=Collections.max(result);\\n        if(answer==0)\\n            return \"000\";\\n        return Integer.toString(answer);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017989,
                "title": "video-solution",
                "content": "https://www.youtube.com/watch?v=kVWus9fljrU\\n\\nProblem 1 - 00:00\\nProblem 2 - 02:50\\nProblem 3 - 08:47\\nProblem 4 - 17:49 \\nComment for appreciation or need for improvement.\\nThank You",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=kVWus9fljrU\\n\\nProblem 1 - 00:00\\nProblem 2 - 02:50\\nProblem 3 - 08:47\\nProblem 4 - 17:49 \\nComment for appreciation or need for improvement.\\nThank You",
                "codeTag": "Unknown"
            },
            {
                "id": 2017979,
                "title": "simple-brute-force-easy-to-understand-c-code",
                "content": "We will iterate over the string and for each **ith** index we create a new string of length 3 and check if its good by a function.\\nIf the string satisfies all conditions we store it in a max heap priority queue.\\n\\nAt last if the priority_queue is empty i.e no possible answer therefore `return \"\"; `\\nelse return the top of priority_queue `pq.top();` as it is the maximum number of all others (if any).\\n\\n```\\nclass Solution {\\n    \\n    bool good(string &s){\\n        \\n        if(s.size()!=3) return false;\\n        \\n        map<char,int> mp;\\n        for(int i=0;i<3;i++){\\n            mp[s[i]]++;          // stores the frequency of digits\\n        }\\n        \\n        return mp.size()==1;  // returns true if consists only one unique digit\\n    }\\n    \\npublic:\\n    string largestGoodInteger(string num) {\\n        \\n        priority_queue<string> pq;\\n        \\n        int n = num.size();\\n        for(int i=0;i<n;i++){\\n            string tmp = num.substr(i,3);         // creating substring of length 3 at every ith index\\n            \\n            if(good(tmp)) pq.push(tmp);              // pushes the possible answer into the priority queue\\n        }\\n        \\n        return pq.size()==0 ? \"\" : pq.top();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool good(string &s){\\n        \\n        if(s.size()!=3) return false;\\n        \\n        map<char,int> mp;\\n        for(int i=0;i<3;i++){\\n            mp[s[i]]++;          // stores the frequency of digits\\n        }\\n        \\n        return mp.size()==1;  // returns true if consists only one unique digit\\n    }\\n    \\npublic:\\n    string largestGoodInteger(string num) {\\n        \\n        priority_queue<string> pq;\\n        \\n        int n = num.size();\\n        for(int i=0;i<n;i++){\\n            string tmp = num.substr(i,3);         // creating substring of length 3 at every ith index\\n            \\n            if(good(tmp)) pq.push(tmp);              // pushes the possible answer into the priority queue\\n        }\\n        \\n        return pq.size()==0 ? \"\" : pq.top();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017953,
                "title": "java-very-simple-solution-o-n",
                "content": "**Please** \\uD83D\\uDD3C **upvote this post if you find the answer useful & do comment about your thoughts** \\uD83D\\uDCAC\\n\\n## Java Code:\\n\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n\\t\\tint count = 0;\\n\\t\\tString max = \"\";\\n\\t\\tif (num.length() < 3)\\n\\t\\t\\treturn max;\\n\\t\\tint maxNum = 0;\\n\\t\\tfor (int i = 1; i < num.length(); i++) {\\n\\t\\t\\tif (num.charAt(i) == num.charAt(i - 1)) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif (count == 2 && maxNum < (int) num.charAt(i)) {\\n\\t\\t\\t\\t\\tmax = \"\" + num.charAt(i) + num.charAt(i) + num.charAt(i);\\n\\t\\t\\t\\t\\tmaxNum = num.charAt(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n\\t\\tint count = 0;\\n\\t\\tString max = \"\";\\n\\t\\tif (num.length() < 3)\\n\\t\\t\\treturn max;\\n\\t\\tint maxNum = 0;\\n\\t\\tfor (int i = 1; i < num.length(); i++) {\\n\\t\\t\\tif (num.charAt(i) == num.charAt(i - 1)) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif (count == 2 && maxNum < (int) num.charAt(i)) {\\n\\t\\t\\t\\t\\tmax = \"\" + num.charAt(i) + num.charAt(i) + num.charAt(i);\\n\\t\\t\\t\\t\\tmaxNum = num.charAt(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017817,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nstring largestGoodInteger(string num) \\n    {\\n        int n=num.size();\\n        \\n        string ans=\"\";\\n        \\n        int j;\\n        for(int i=0;i<=n-3;i++)\\n        {\\n            for(j=0;j<3;j++)\\n            {\\n                if(num[i]!=num[i+j])\\n                {\\n                    break;\\n                }\\n            }\\n            if(j==3)\\n            {\\n                if(ans.size()==0)\\n                {\\n                    ans+=num[i];\\n                    ans+=num[i];\\n                    ans+=num[i];\\n                }\\n                else if(ans[0]<num[i])\\n                {\\n                    for(j=0;j<3;j++)\\n                    {\\n                        ans[j]=num[i];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nstring largestGoodInteger(string num) \\n    {\\n        int n=num.size();\\n        \\n        string ans=\"\";\\n        \\n        int j;\\n        for(int i=0;i<=n-3;i++)\\n        {\\n            for(j=0;j<3;j++)\\n            {\\n                if(num[i]!=num[i+j])\\n                {\\n                    break;\\n                }\\n            }\\n            if(j==3)\\n            {\\n                if(ans.size()==0)\\n                {\\n                    ans+=num[i];\\n                    ans+=num[i];\\n                    ans+=num[i];\\n                }\\n                else if(ans[0]<num[i])\\n                {\\n                    for(j=0;j<3;j++)\\n                    {\\n                        ans[j]=num[i];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2017806,
                "title": "java-o-1-space-3ms-easy-to-understand-code",
                "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        char[] arr = num.toCharArray();\\n        int l= 0, r = arr.length - 1;\\n        int max = Integer.MIN_VALUE;\\n        String ans = \"\";\\n        while(l < r){\\n            if(l+2 < arr.length && arr[l] == arr[l + 1] && arr[l+1] == arr[l + 2]){\\n                int a = arr[l] - \\'0\\';\\n                max = Math.max(max, a);\\n                \\n                l++;\\n            }\\n            else if(r-2 > 0 && arr[r] == arr[r - 1] && arr[r - 1] == arr[r-2]){\\n                int a = arr[r] - \\'0\\';\\n                max = Math.max(max, a);\\n                r--;\\n\\n            }else{\\n                l++;\\n                r--;\\n            }\\n        }\\n        if(max < 0){\\n            return \"\";\\n        }\\n        ans += Integer.toString(max);\\n        ans = ans.repeat(3);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        char[] arr = num.toCharArray();\\n        int l= 0, r = arr.length - 1;\\n        int max = Integer.MIN_VALUE;\\n        String ans = \"\";\\n        while(l < r){\\n            if(l+2 < arr.length && arr[l] == arr[l + 1] && arr[l+1] == arr[l + 2]){\\n                int a = arr[l] - \\'0\\';\\n                max = Math.max(max, a);\\n                \\n                l++;\\n            }\\n            else if(r-2 > 0 && arr[r] == arr[r - 1] && arr[r - 1] == arr[r-2]){\\n                int a = arr[r] - \\'0\\';\\n                max = Math.max(max, a);\\n                r--;\\n\\n            }else{\\n                l++;\\n                r--;\\n            }\\n        }\\n        if(max < 0){\\n            return \"\";\\n        }\\n        ans += Integer.toString(max);\\n        ans = ans.repeat(3);\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017780,
                "title": "python3-1-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/9aa0edb0815f3e0a75a47808e1690ca424f169e5) for solutions of weekly 292. \\n\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        return next((x*3 for x in \"9876543210\" if x*3 in num), \"\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        return next((x*3 for x in \"9876543210\" if x*3 in num), \"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017731,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    string largestGoodInteger(string s) {\\n        \\n        \\n        int n=s.size();\\n        \\n        string res=\"\";\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(s[i-2]==s[i-1] && s[i-1]==s[i])\\n            {\\n                string s1=\"\";\\n                s1+=s[i];\\n                s1+=s[i];\\n                s1+=s[i];\\n                if(res.size()==0)\\n                {\\n                    res=s1;\\n                }\\n                else\\n                {\\n                    res=max(res,s1);\\n                }\\n            }\\n        }\\n            \\n        return res;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestGoodInteger(string s) {\\n        \\n        \\n        int n=s.size();\\n        \\n        string res=\"\";\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(s[i-2]==s[i-1] && s[i-1]==s[i])\\n            {\\n                string s1=\"\";\\n                s1+=s[i];\\n                s1+=s[i];\\n                s1+=s[i];\\n                if(res.size()==0)\\n                {\\n                    res=s1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4079348,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String ans = \"\";\\n\\n        for (int i = 2; i < num.length(); ++i)\\n        if (num.charAt(i - 2) == num.charAt(i - 1) && num.charAt(i - 1) == num.charAt(i) &&\\n            num.substring(i - 2, i + 1).compareTo(ans) > 0)\\n            ans = num.substring(i - 2, i + 1);\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String ans = \"\";\\n\\n        for (int i = 2; i < num.length(); ++i)\\n        if (num.charAt(i - 2) == num.charAt(i - 1) && num.charAt(i - 1) == num.charAt(i) &&\\n            num.substring(i - 2, i + 1).compareTo(ans) > 0)\\n            ans = num.substring(i - 2, i + 1);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077953,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        return max((num[i:i+3] for i in range(len(num)-2) if num[i] == num[i+1] == num[i+2]), default= \"\")       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        return max((num[i:i+3] for i in range(len(num)-2) if num[i] == num[i+1] == num[i+2]), default= \"\")       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076322,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int ans =0, num1 =0;\\n        String res = \"\";\\n        for(int i=0;i<num.length()-2;i++){\\n            num1 = num.charAt(i)-\\'0\\';\\n            if(num1 == num.charAt(i+1)-\\'0\\' && num1 == num.charAt(i+2)-\\'0\\'){\\n                num1 = num1*10 + num.charAt(i+1)-\\'0\\';\\n                num1 = num1*10 + num.charAt(i+2)-\\'0\\';\\n                if(ans <= num1){\\n                    ans = num1;\\n                    res = String.valueOf(num.substring(i, i+3));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int ans =0, num1 =0;\\n        String res = \"\";\\n        for(int i=0;i<num.length()-2;i++){\\n            num1 = num.charAt(i)-\\'0\\';\\n            if(num1 == num.charAt(i+1)-\\'0\\' && num1 == num.charAt(i+2)-\\'0\\'){\\n                num1 = num1*10 + num.charAt(i+1)-\\'0\\';\\n                num1 = num1*10 + num.charAt(i+2)-\\'0\\';\\n                if(ans <= num1){\\n                    ans = num1;\\n                    res = String.valueOf(num.substring(i, i+3));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072566,
                "title": "o-n-solution-easy-approach-c-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the string characters and compare the characters and if count is equal to 3 then update the string if the Greater than previous string .\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int cnt=1;\\n        string x=\"\";\\n        string s=\"\";\\n        for(int i=0;i<num.size()-1;i++){\\n            if(num[i]==num[i+1]){\\n                cnt++;\\n                if(cnt==3){\\n                    s+=num[i];\\n                    s+=num[i];\\n                    s+=num[i];\\n                    if(x.size()==0){\\n                        x=s;\\n                    }\\n                    else if(x[0]<s[0]){\\n                        x=s;\\n                    }\\n                }\\n                s=\"\";\\n            }\\n            else{\\n                cnt=1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int cnt=1;\\n        string x=\"\";\\n        string s=\"\";\\n        for(int i=0;i<num.size()-1;i++){\\n            if(num[i]==num[i+1]){\\n                cnt++;\\n                if(cnt==3){\\n                    s+=num[i];\\n                    s+=num[i];\\n                    s+=num[i];\\n                    if(x.size()==0){\\n                        x=s;\\n                    }\\n                    else if(x[0]<s[0]){\\n                        x=s;\\n                    }\\n                }\\n                s=\"\";\\n            }\\n            else{\\n                cnt=1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070914,
                "title": "beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        string ans;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<num.size()-2;i++)\\n        {\\n            if(num[i]==num[i+1]&&num[i+1]==num[i+2])\\n            {\\n                string y=num.substr(i,3);\\n                int x=stoi(y);\\n                if(x>maxi)\\n                {\\n                    maxi=x;\\n                    ans=y;\\n                }\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) \\n    {\\n        string ans;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<num.size()-2;i++)\\n        {\\n            if(num[i]==num[i+1]&&num[i+1]==num[i+2])\\n            {\\n                string y=num.substr(i,3);\\n                int x=stoi(y);\\n                if(x>maxi)\\n                {\\n                    maxi=x;\\n                    ans=y;\\n                }\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060958,
                "title": "code-with-python",
                "content": "simple one\\n\\n# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        a=[]\\n        i=9\\n        while i!=-1:\\n            k=\"{}{}{}\".format(i,i,i)\\n            if k in num:\\n                return k\\n            i-=1\\n        return \"\"        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        a=[]\\n        i=9\\n        while i!=-1:\\n            k=\"{}{}{}\".format(i,i,i)\\n            if k in num:\\n                return k\\n            i-=1\\n        return \"\"        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036786,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        m = float(\\'-inf\\')\\n        result = \"\"\\n        for i in range(0,len(num)-2):\\n            if len(set(num[i:i+3])) == 1:\\n                if int(num[i:i+3]) > m:\\n                    m = int(num[i:i+3])\\n                    result = num[i:i+3]\\n\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        m = float(\\'-inf\\')\\n        result = \"\"\\n        for i in range(0,len(num)-2):\\n            if len(set(num[i:i+3])) == 1:\\n                if int(num[i:i+3]) > m:\\n                    m = int(num[i:i+3])\\n                    result = num[i:i+3]\\n\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013068,
                "title": "simple-js-solution-can-be-improved",
                "content": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nconst largestGoodInteger = function(num) {\\n\\n    let max = 0\\n\\n    for (let i = 0; i < num.length; i++) {\\n\\n        if (num[i - 1] === num[i]  && num[i - 2] === num[i]) {\\n            let int  = parseInt(num[i])\\n            max = Math.max(max, int)\\n        }\\n\\n    }\\n\\n    if (max === 0) {\\n        if (num.includes(\\'000\\')) {\\n            max = \\'0\\'\\n        } else {\\n            max = \\'\\'\\n        }\\n    }\\n\\n    max = max + \\'\\'\\n\\n    return max.repeat(3)\\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nconst largestGoodInteger = function(num) {\\n\\n    let max = 0\\n\\n    for (let i = 0; i < num.length; i++) {\\n\\n        if (num[i - 1] === num[i]  && num[i - 2] === num[i]) {\\n            let int  = parseInt(num[i])\\n            max = Math.max(max, int)\\n        }\\n\\n    }\\n\\n    if (max === 0) {\\n        if (num.includes(\\'000\\')) {\\n            max = \\'0\\'\\n        } else {\\n            max = \\'\\'\\n        }\\n    }\\n\\n    max = max + \\'\\'\\n\\n    return max.repeat(3)\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991212,
                "title": "open-and-take-a-look-you-will-get-the-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int ans = Integer.MIN_VALUE ; \\n        int index= 0 ; \\n        for(int i = 0 ; i<num.length()-2;i++){\\n            String s=num.substring(i,i+3);\\n            if(s.charAt(0)==s.charAt(1) && s.charAt(1)==s.charAt(2))\\n            {\\n                if(Integer.valueOf(s)>ans){\\n                    ans=Integer.valueOf(s);\\n                    index= i;\\n                }\\n                \\n            }\\n        }\\n        if(ans== Integer.MIN_VALUE)return \"\";\\n        return num.substring(index,index+3)  ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int ans = Integer.MIN_VALUE ; \\n        int index= 0 ; \\n        for(int i = 0 ; i<num.length()-2;i++){\\n            String s=num.substring(i,i+3);\\n            if(s.charAt(0)==s.charAt(1) && s.charAt(1)==s.charAt(2))\\n            {\\n                if(Integer.valueOf(s)>ans){\\n                    ans=Integer.valueOf(s);\\n                    index= i;\\n                }\\n                \\n            }\\n        }\\n        if(ans== Integer.MIN_VALUE)return \"\";\\n        return num.substring(index,index+3)  ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990207,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n String largestGoodInteger(String num) {\\n  List<String> sameDigit = [];\\n  String result = \"\";\\n  int max = -1;\\n  for (int i = 1; i < num.length - 1; i++) {\\n    if (num[i - 1] == num[i] && num[i] == num[i + 1]) {\\n      String threeNumbers = num[i - 1] + num[i] + num[i + 1];\\n      sameDigit.add(threeNumbers);\\n      if (int.parse(threeNumbers) > max) {\\n        max = int.parse(threeNumbers);\\n        result = threeNumbers;\\n      }\\n    }\\n  }\\n  return result;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n String largestGoodInteger(String num) {\\n  List<String> sameDigit = [];\\n  String result = \"\";\\n  int max = -1;\\n  for (int i = 1; i < num.length - 1; i++) {\\n    if (num[i - 1] == num[i] && num[i] == num[i + 1]) {\\n      String threeNumbers = num[i - 1] + num[i] + num[i + 1];\\n      sameDigit.add(threeNumbers);\\n      if (int.parse(threeNumbers) > max) {\\n        max = int.parse(threeNumbers);\\n        result = threeNumbers;\\n      }\\n    }\\n  }\\n  return result;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965437,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  String largestGoodInteger(String num) {\\n      var maxi = -1;\\n      var curMax = \"\";\\n      for (int i = 0; i <= num.length - 3; i++) {\\n          if (num[i] == num[i + 1] && num[i + 1] == num[i + 2]) {\\n              final sub = num.substring(i, i + 3);\\n              if (int.parse(sub) > maxi) {\\n                  maxi = int.parse(sub);\\n                  curMax = sub;\\n              }\\n          }\\n      }\\n\\n      return curMax;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String largestGoodInteger(String num) {\\n      var maxi = -1;\\n      var curMax = \"\";\\n      for (int i = 0; i <= num.length - 3; i++) {\\n          if (num[i] == num[i + 1] && num[i + 1] == num[i + 2]) {\\n              final sub = num.substring(i, i + 3);\\n              if (int.parse(sub) > maxi) {\\n                  maxi = int.parse(sub);\\n                  curMax = sub;\\n              }\\n          }\\n      }\\n\\n      return curMax;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962874,
                "title": "c-sol-using-stringbuilder",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public string LargestGoodInteger(string num) {\\n            \\n            char temp = \\'0\\';\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 2; i < num.Length; i++) {\\n                if (num[i] == num[i - 1] && num[i-1] == num[i-2])\\n                {\\n                    \\n                    temp = num[i] > temp ? num[i] : temp;\\n                    if (temp == num[i]) {\\n                        res.Clear();\\n                        res.Append(num[i]);\\n                        res.Append(num[i-1]);\\n                        res.Append(num[i-2]);\\n                    \\n                    }\\n                    \\n                }\\n                \\n            }\\n\\n            return res.ToString();  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestGoodInteger(string num) {\\n            \\n            char temp = \\'0\\';\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 2; i < num.Length; i++) {\\n                if (num[i] == num[i - 1] && num[i-1] == num[i-2])\\n                {\\n                    \\n                    temp = num[i] > temp ? num[i] : temp;\\n                    if (temp == num[i]) {\\n                        res.Clear();\\n                        res.Append(num[i]);\\n                        res.Append(num[i-1]);\\n                        res.Append(num[i-2]);\\n                    \\n                    }\\n                    \\n                }\\n                \\n            }\\n\\n            return res.ToString();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962126,
                "title": "clean-code-100-check-it-out",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt aims to find the largest \"good\" integer in the input string num. A \"good\" integer is defined as a sequence of three consecutive identical digits in the input string. For example, \"111\" or \"999\" are considered good integers.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize a variable good to \\'0\\' - 1, which is a character that is less than \\'0\\'. This variable will be used to keep track of the largest \"good\" digit encountered.\\n2.Initialize a variable count to 0. This variable will be used to count consecutive identical digits in the input string.\\n3.Iterate through the characters of the input string num using a for loop. The loop runs until the second-to-last character of the string because the code compares each character with the next one (i.e., num[i] and num[i + 1]).\\n4.Inside the loop, if the current character num[i] is equal to the next character num[i + 1], increment the count variable. This counts consecutive identical digits.\\n5.If count reaches 2 (meaning there are three consecutive identical digits), then check if the current digit num[i] is greater than the current maximum good. If it is, update good to the current digit.\\n6.After processing three consecutive identical digits, increment the loop counter i by 1 to skip the next character, and reset count to 0 since you\\'ve already counted three identical digits.\\n7.Finally, after the loop, check if good is still less than \\'0\\'. If it is, return an empty string, indicating that there are no \"good\" integers in the input string. Otherwise, return a string containing three instances of the good character.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of the input string num. This is because the code iterates through the string once, and each iteration involves constant-time operations.\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) because it uses a fixed amount of additional memory to store variables (good, count, and the loop index i) regardless of the size of the input string.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        \\n        char good = \\'0\\' - 1;\\n\\n        int count = 0;\\n        for(int i = 0; i < num.length() - 1; ++i){\\n            \\n            if(num[i] == num[i + 1]) ++count;\\n            else count = 0;\\n\\n            if(count == 2){\\n                if(good < num[i]){\\n                    good = num[i];\\n                }\\n                \\n                ++i;\\n                count = 0;\\n            }\\n        }\\n\\n\\n        if(good < \\'0\\') return \"\";\\n\\n        return string(3, good);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        \\n        char good = \\'0\\' - 1;\\n\\n        int count = 0;\\n        for(int i = 0; i < num.length() - 1; ++i){\\n            \\n            if(num[i] == num[i + 1]) ++count;\\n            else count = 0;\\n\\n            if(count == 2){\\n                if(good < num[i]){\\n                    good = num[i];\\n                }\\n                \\n                ++i;\\n                count = 0;\\n            }\\n        }\\n\\n\\n        if(good < \\'0\\') return \"\";\\n\\n        return string(3, good);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957684,
                "title": "easy-java-code-simple-for-begginers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String s) {\\n        char[] arr = new char[3];\\n        String ans=\"\";\\n        int maxx=Integer.MIN_VALUE;\\n        for(int i=0;i<s.length()-2;i++){\\n            arr[0]=s.charAt(i);\\n            arr[1]=s.charAt(i+1);\\n            arr[2]=s.charAt(i+2);\\n            if(arr[0]==arr[1] && arr[1]==arr[2]){\\n                \\n                \\n               if(ans.length()!=0){\\n                String str=s.substring(i,i+3);\\n                int n1=Integer.parseInt(str);\\n                int n2=Integer.parseInt(ans);\\n                if(n1>n2){\\n                    ans=str;\\n                }\\n               }\\n               else{\\n                ans=s.substring(i,i+3);\\n               }  \\n            }\\n\\n        }\\n    return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String s) {\\n        char[] arr = new char[3];\\n        String ans=\"\";\\n        int maxx=Integer.MIN_VALUE;\\n        for(int i=0;i<s.length()-2;i++){\\n            arr[0]=s.charAt(i);\\n            arr[1]=s.charAt(i+1);\\n            arr[2]=s.charAt(i+2);\\n            if(arr[0]==arr[1] && arr[1]==arr[2]){\\n                \\n                \\n               if(ans.length()!=0){\\n                String str=s.substring(i,i+3);\\n                int n1=Integer.parseInt(str);\\n                int n2=Integer.parseInt(ans);\\n                if(n1>n2){\\n                    ans=str;\\n                }\\n               }\\n               else{\\n                ans=s.substring(i,i+3);\\n               }  \\n            }\\n\\n        }\\n    return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951302,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string res;\\n        for(int i = 2; i < num.size(); i++)\\n\\t\\t{\\n            if(num[i-2] == num[i-1] && num[i-1] == num[i])\\n\\t\\t\\t{\\n                res = max(res, string(3,num[i]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string res;\\n        for(int i = 2; i < num.size(); i++)\\n\\t\\t{\\n            if(num[i-2] == num[i-1] && num[i-1] == num[i])\\n\\t\\t\\t{\\n                res = max(res, string(3,num[i]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948790,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        ans = []\\n\\n        start, end = 0, 3\\n\\n        while end <= len(num):\\n            if len(set(list(num[start:end]))) == 1:\\n                print()\\n                ans.append(num[start:end])\\n            \\n            start = start + 1\\n            end = end + 1\\n            \\n        if not ans:\\n            return \"\"\\n\\n\\n        return max(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        ans = []\\n\\n        start, end = 0, 3\\n\\n        while end <= len(num):\\n            if len(set(list(num[start:end]))) == 1:\\n                print()\\n                ans.append(num[start:end])\\n            \\n            start = start + 1\\n            end = end + 1\\n            \\n        if not ans:\\n            return \"\"\\n\\n\\n        return max(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945650,
                "title": "cheater-no-loop",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        if \\'999\\' in num:\\n            return \\'999\\'\\n        if \\'888\\' in num:\\n            return \\'888\\'\\n        if \\'777\\' in num:\\n            return \\'777\\'\\n        if \\'666\\' in num:\\n            return \\'666\\'\\n        if \\'555\\' in num:\\n            return \\'555\\'\\n        if \\'444\\' in num:\\n            return \\'444\\'\\n        if \\'333\\' in num:\\n            return \\'333\\'\\n        if \\'222\\' in num:\\n            return \\'222\\'\\n        if \\'111\\' in num:\\n            return \\'111\\'\\n        if \\'000\\' in num:\\n            return \\'000\\'\\n        return \\'\\'\\n```",
                "solutionTags": [
                    "Python3",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        if \\'999\\' in num:\\n            return \\'999\\'\\n        if \\'888\\' in num:\\n            return \\'888\\'\\n        if \\'777\\' in num:\\n            return \\'777\\'\\n        if \\'666\\' in num:\\n            return \\'666\\'\\n        if \\'555\\' in num:\\n            return \\'555\\'\\n        if \\'444\\' in num:\\n            return \\'444\\'\\n        if \\'333\\' in num:\\n            return \\'333\\'\\n        if \\'222\\' in num:\\n            return \\'222\\'\\n        if \\'111\\' in num:\\n            return \\'111\\'\\n        if \\'000\\' in num:\\n            return \\'000\\'\\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920660,
                "title": "java-clean-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        char[] chars = num.toCharArray();\\n        int n = chars.length;\\n        String max = \"\";\\n\\n        for(int i = 2; i < n; i++)\\n            if(chars[i] == chars[i-1] && chars[i-1] == chars[i-2]){\\n                if(max.length() == 0) max = num.substring(i-2, i+1);\\n                else if(max.charAt(0) < chars[i-2])\\n                  max = num.substring(i-2, i+1);\\n            }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        char[] chars = num.toCharArray();\\n        int n = chars.length;\\n        String max = \"\";\\n\\n        for(int i = 2; i < n; i++)\\n            if(chars[i] == chars[i-1] && chars[i-1] == chars[i-2]){\\n                if(max.length() == 0) max = num.substring(i-2, i+1);\\n                else if(max.charAt(0) < chars[i-2])\\n                  max = num.substring(i-2, i+1);\\n            }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915273,
                "title": "python3-one-liner-beats-99-81",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        return next((s for i in range(9, -1, -1) if (s := str(i) * 3) in num), \"\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        return next((s for i in range(9, -1, -1) if (s := str(i) * 3) in num), \"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914604,
                "title": "easy-solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String[] arr = {\"999\",\"888\",\"777\",\"666\",\"555\",\"444\",\"333\",\"222\",\"111\",\"000\"};\\n        for(int i = 0; i < 10; i++){\\n            if(num.contains(arr[i])){\\n                return arr[i];\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String[] arr = {\"999\",\"888\",\"777\",\"666\",\"555\",\"444\",\"333\",\"222\",\"111\",\"000\"};\\n        for(int i = 0; i < 10; i++){\\n            if(num.contains(arr[i])){\\n                return arr[i];\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913780,
                "title": "javascript-2-solutions",
                "content": "# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nconst matches = new Set([\\n    \\'999\\', \\'888\\', \\'777\\', \\'666\\', \\'555\\', \\'444\\', \\'333\\', \\'222\\', \\'111\\', \\'000\\'\\n])\\n\\nfunction largestGoodInteger(num) {\\n    for(const match of matches) {\\n        if (num.includes(match)) return match;\\n    }\\n    return \\'\\'\\n};\\n```\\n\\n# Code\\n\\n```\\nvar largestGoodInteger = function(num) {\\n    let returnVal = \\'\\'\\n    for(let i=0;i<num.length;i++){\\n        if(num[i] === num[i+1] && num[i] === num[i+2]){\\n            const n = num[i] + num[i+1] + num[i+2]\\n            if(returnVal < n) returnVal=n\\n        }\\n    }\\n    return returnVal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nconst matches = new Set([\\n    \\'999\\', \\'888\\', \\'777\\', \\'666\\', \\'555\\', \\'444\\', \\'333\\', \\'222\\', \\'111\\', \\'000\\'\\n])\\n\\nfunction largestGoodInteger(num) {\\n    for(const match of matches) {\\n        if (num.includes(match)) return match;\\n    }\\n    return \\'\\'\\n};\\n```\n```\\nvar largestGoodInteger = function(num) {\\n    let returnVal = \\'\\'\\n    for(let i=0;i<num.length;i++){\\n        if(num[i] === num[i+1] && num[i] === num[i+2]){\\n            const n = num[i] + num[i+1] + num[i+2]\\n            if(returnVal < n) returnVal=n\\n        }\\n    }\\n    return returnVal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910874,
                "title": "c-beats-100-runtime-easy-to-understand-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n-Initialize the number with -1, and everytime we found a good integer, it will be updated and to that number.\\n-Compares the character before and after, also the good string number to the currently searched.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int number = -1;\\n        string result = \"\";\\n        for(int i = 1; i < (num.size()-1);i++){\\n            if(num[i] > number && num[i] == num[i-1] && num[i] == num[i+1]){\\n                number = num[i];\\n                result = num.substr(i-1,3);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int number = -1;\\n        string result = \"\";\\n        for(int i = 1; i < (num.size()-1);i++){\\n            if(num[i] > number && num[i] == num[i-1] && num[i] == num[i+1]){\\n                number = num[i];\\n                result = num.substr(i-1,3);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3901041,
                "title": "easy-c-code-beginner-s-friendly-string",
                "content": "\\n# Approach\\nYou should know some of the predefined functions in string like **stoi(), substr()**.\\n- stoi() -> Change string to int.\\n- substr(start,length) -> prints the substring from the given string.\\n\\nNow the solution approach would be:\\n1. If three consecutive number are equal then cut that substring part and store that part to some other variable.And change the string to int for comparison.\\n2. If the number is greater than max then update the max and ans.\\n3. Return ans.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        \\n        int max=-1;\\n        string ans=\"\";\\n        int number=0;\\n        for(int i=0;i<num.size()-2;i++){\\n            if(num[i]==num[i+1]&& num[i+1]==num[i+2]){\\n                string temp=num.substr(i,3);\\n                int number=stoi(temp);\\n                \\n                if(number>max){\\n                    ans=temp;\\n                    max=number;\\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        \\n        int max=-1;\\n        string ans=\"\";\\n        int number=0;\\n        for(int i=0;i<num.size()-2;i++){\\n            if(num[i]==num[i+1]&& num[i+1]==num[i+2]){\\n                string temp=num.substr(i,3);\\n                int number=stoi(temp);\\n                \\n                if(number>max){\\n                    ans=temp;\\n                    max=number;\\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886436,
                "title": "easy-solution-in-c-beats-100",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans=\"\";\\n        int count=-1111111;\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num[i]==num[i+1] && num[i]==num[i+2]){\\n                string substr=num.substr(i,3);\\n                if(stoi(substr)>count){\\n                    ans=substr;\\n                    count=stoi(substr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans=\"\";\\n        int count=-1111111;\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num[i]==num[i+1] && num[i]==num[i+2]){\\n                string substr=num.substr(i,3);\\n                if(stoi(substr)>count){\\n                    ans=substr;\\n                    count=stoi(substr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875517,
                "title": "best-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string s) {\\n    string ans;\\n    for(int j=0;j<s.length()-2;j++)\\n    {\\n        if(s[j]== s[j+1] && s[j+1]==s[j+2]){\\n            string result;\\n            result.push_back(s[j]);\\n            result.push_back(s[j+1]);\\n            result.push_back(s[j+2]);\\n            ans= max(ans,result);\\n        }\\n            \\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string s) {\\n    string ans;\\n    for(int j=0;j<s.length()-2;j++)\\n    {\\n        if(s[j]== s[j+1] && s[j+1]==s[j+2]){\\n            string result;\\n            result.push_back(s[j]);\\n            result.push_back(s[j+1]);\\n            result.push_back(s[j+2]);\\n            ans= max(ans,result);\\n        }\\n            \\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871721,
                "title": "k-jebasraja-very-easy",
                "content": "# Intuition:KARUNYA UNIVERSITY::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public String largestGoodInteger(String num) \\n    {\\n\\n\\nint thrice=0;\\n\\nint finalanswer=-1;\\n\\nchar[] ch=num.toCharArray();\\n\\nint previoius=Character.getNumericValue(ch[0]);\\n\\nfor (int i = 0; i < ch.length; i++) \\n{\\n   \\n  if (previoius==Character.getNumericValue(ch[i])) \\n  {   \\n\\n    System.out.println(\"equal---->\"+Character.getNumericValue(ch[i]));\\n     thrice++; \\n     \\n     if (thrice==3) \\n     {\\n      if (Character.getNumericValue(ch[i])>finalanswer) \\n      {\\n         finalanswer=Character.getNumericValue(ch[i]);  \\n      }\\n      thrice=0;\\n     }\\n  }\\n  else\\n  {\\n    //System.out.println(\"not equal--->\"+Character.getNumericValue(ch[i]));\\n  previoius=Character.getNumericValue(ch[i]);\\n  thrice=1;\\n  }\\n} \\n\\nreturn finalanswer!=-1?Integer.toString(finalanswer)+\"\"+Integer.toString(finalanswer)+\"\"+Integer.toString(finalanswer):\"\";\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public String largestGoodInteger(String num) \\n    {\\n\\n\\nint thrice=0;\\n\\nint finalanswer=-1;\\n\\nchar[] ch=num.toCharArray();\\n\\nint previoius=Character.getNumericValue(ch[0]);\\n\\nfor (int i = 0; i < ch.length; i++) \\n{\\n   \\n  if (previoius==Character.getNumericValue(ch[i])) \\n  {   \\n\\n    System.out.println(\"equal---->\"+Character.getNumericValue(ch[i]));\\n     thrice++; \\n     \\n     if (thrice==3) \\n     {\\n      if (Character.getNumericValue(ch[i])>finalanswer) \\n      {\\n         finalanswer=Character.getNumericValue(ch[i]);  \\n      }\\n      thrice=0;\\n     }\\n  }\\n  else\\n  {\\n    //System.out.println(\"not equal--->\"+Character.getNumericValue(ch[i]));\\n  previoius=Character.getNumericValue(ch[i]);\\n  thrice=1;\\n  }\\n} \\n\\nreturn finalanswer!=-1?Integer.toString(finalanswer)+\"\"+Integer.toString(finalanswer)+\"\"+Integer.toString(finalanswer):\"\";\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871376,
                "title": "simple-solution-using-c-using-string-and-vector",
                "content": "# Flow of Code\\n1. Seperating the string elements into three three characters and storing it in a vector.\\n2. Storing all the common elements in seperate vector.\\n3. Converting all the string elements into int anf finding the max of it and returning it in string form, if max element is 0 then returning \"000\" as answer. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<string> B,C;\\n        vector<int> D;\\n        string A;\\n        for(int i=0;i<num.size()-2;i++){\\n            A+=num[i];\\n            A+=num[i+1];\\n            A+=num[i+2];\\n            B.push_back(A);\\n            A.clear();\\n        }\\n        for(int i=0;i<B.size();i++){\\n            A=B[i];\\n            if(A[0]==A[1] && A[0]==A[2] && A[1]==A[2])\\n                C.push_back(A);\\n        }\\n        if(C.size()==0)\\n            return \"\";\\n        for(int i=0;i<C.size();i++){\\n            int Num=stoi(C[i]);\\n            D.push_back(Num);\\n        }\\n        int Max=*max_element(D.begin(),D.end());\\n        if(Max==0)\\n            return \"000\";\\n        return to_string(Max);\\n    }\\n};\\n```\\n# Happy Coding...\\uD83E\\uDD1D",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<string> B,C;\\n        vector<int> D;\\n        string A;\\n        for(int i=0;i<num.size()-2;i++){\\n            A+=num[i];\\n            A+=num[i+1];\\n            A+=num[i+2];\\n            B.push_back(A);\\n            A.clear();\\n        }\\n        for(int i=0;i<B.size();i++){\\n            A=B[i];\\n            if(A[0]==A[1] && A[0]==A[2] && A[1]==A[2])\\n                C.push_back(A);\\n        }\\n        if(C.size()==0)\\n            return \"\";\\n        for(int i=0;i<C.size();i++){\\n            int Num=stoi(C[i]);\\n            D.push_back(Num);\\n        }\\n        int Max=*max_element(D.begin(),D.end());\\n        if(Max==0)\\n            return \"000\";\\n        return to_string(Max);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854012,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int ans=0,max = Integer.MIN_VALUE;\\n        int flag =0;\\n        for(int i=2;i<num.length();i++)\\n        {\\n            if(num.charAt(i)==num.charAt(i-1) && num.charAt(i-1)==num.charAt(i-2))\\n            {\\n               String s = num.substring(i-2,i+1);\\n               ans = Integer.parseInt(s);\\n                if(ans>max)\\n                {\\n                    max=ans;\\n                    flag=1;\\n                }\\n            }\\n            \\n        }\\n        if(max==0 && flag==1) return \"000\";\\n        if(max==-2147483648) return \"\";\\n        return Integer.toString(max);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int ans=0,max = Integer.MIN_VALUE;\\n        int flag =0;\\n        for(int i=2;i<num.length();i++)\\n        {\\n            if(num.charAt(i)==num.charAt(i-1) && num.charAt(i-1)==num.charAt(i-2))\\n            {\\n               String s = num.substring(i-2,i+1);\\n               ans = Integer.parseInt(s);\\n                if(ans>max)\\n                {\\n                    max=ans;\\n                    flag=1;\\n                }\\n            }\\n            \\n        }\\n        if(max==0 && flag==1) return \"000\";\\n        if(max==-2147483648) return \"\";\\n        return Integer.toString(max);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832984,
                "title": "largest-3-same-digit-number-in-string-optimized-solution",
                "content": "# Complexity\\n- Time complexity:\\n- The time complexity of the code is $$O(n)$$, where N is the length of the input string num.\\n\\n- Space complexity:\\n- The space complexity of the code is $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        \\n        int ln = -1; // Variable to store the largest good integer found so far, initialized as -1.\\n        char s; // Variable to store the current character being checked.\\n\\n        // Loop through the string \\'num\\' up to the third-to-last character (num.length() - 2).\\n        for (int i = 0; i < num.length() - 2; i++) {\\n            s = num.charAt(i); // Get the character at index \\'i\\'.\\n\\n            // Check if the current character is the same as the next two characters.\\n            if (s == num.charAt(i + 1) && s == num.charAt(i + 2)) {\\n                // If the condition is met, we have found a good integer (a substring of length 3 with one unique digit).\\n\\n                // Compare the current digit with the largest good integer found so far.\\n                // If it is greater, update the \\'ln\\' variable to the current digit.\\n                if (s - \\'0\\' > ln) {\\n                    ln = s - \\'0\\';\\n                }\\n\\n                // Increment \\'i\\' by 2 since we have already checked the next two characters of the good integer.\\n                // This is to avoid counting the same good integer multiple times.\\n                i += 2;\\n            }\\n        }\\n\\n        // If \\'ln\\' remains -1, it means no good integer was found, so return an empty string.\\n        // Otherwise, return the largest good integer found repeated three times as a string.\\n        return ln == -1 ? \"\" : String.valueOf(ln).repeat(3);\\n    }\\n}\\n\\n```\\nIf it can help you to solve that task, i will be happy.\\uD83D\\uDE0A",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        \\n        int ln = -1; // Variable to store the largest good integer found so far, initialized as -1.\\n        char s; // Variable to store the current character being checked.\\n\\n        // Loop through the string \\'num\\' up to the third-to-last character (num.length() - 2).\\n        for (int i = 0; i < num.length() - 2; i++) {\\n            s = num.charAt(i); // Get the character at index \\'i\\'.\\n\\n            // Check if the current character is the same as the next two characters.\\n            if (s == num.charAt(i + 1) && s == num.charAt(i + 2)) {\\n                // If the condition is met, we have found a good integer (a substring of length 3 with one unique digit).\\n\\n                // Compare the current digit with the largest good integer found so far.\\n                // If it is greater, update the \\'ln\\' variable to the current digit.\\n                if (s - \\'0\\' > ln) {\\n                    ln = s - \\'0\\';\\n                }\\n\\n                // Increment \\'i\\' by 2 since we have already checked the next two characters of the good integer.\\n                // This is to avoid counting the same good integer multiple times.\\n                i += 2;\\n            }\\n        }\\n\\n        // If \\'ln\\' remains -1, it means no good integer was found, so return an empty string.\\n        // Otherwise, return the largest good integer found repeated three times as a string.\\n        return ln == -1 ? \"\" : String.valueOf(ln).repeat(3);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831171,
                "title": "c-easy-solution-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string s=\"\";\\n        vector<string>res;\\n        for(int i=0;i<num.size();i++){\\n            s+=num[i];\\n            s+=num[i];\\n            s+=num[i];\\n            if(num.find(s)!=-1){\\n                res.push_back(s);\\n            }\\n            s=\"\";\\n        }\\n        if(res.size()==0){\\n            return \"\";\\n        }\\n        sort(res.begin(),res.end());\\n        return res[res.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string s=\"\";\\n        vector<string>res;\\n        for(int i=0;i<num.size();i++){\\n            s+=num[i];\\n            s+=num[i];\\n            s+=num[i];\\n            if(num.find(s)!=-1){\\n                res.push_back(s);\\n            }\\n            s=\"\";\\n        }\\n        if(res.size()==0){\\n            return \"\";\\n        }\\n        sort(res.begin(),res.end());\\n        return res[res.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831124,
                "title": "c-very-easy-to-understand-find-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans;\\n        for(int i=9;i>=0;i--){\\n            string str=to_string(i);\\n            str+= str+str;\\n            size_t pos = num.find(str);\\n            if (pos != string::npos) {\\n                ans = str;\\n                break; // Once we find the largest good integer, we can stop the loop.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans;\\n        for(int i=9;i>=0;i--){\\n            string str=to_string(i);\\n            str+= str+str;\\n            size_t pos = num.find(str);\\n            if (pos != string::npos) {\\n                ans = str;\\n                break; // Once we find the largest good integer, we can stop the loop.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810822,
                "title": "largest-3-same-digit-number-in-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        for(int i=9;i>=0;i--)\\n        {\\n            String s = new String();\\n            for(int j=0;j<3;j++)\\n            {\\n                s=s+(char)(i+\\'0\\');\\n            }\\n            arr.add(s);\\n        }\\n        for(int i=0;i<=9;i++)\\n        {\\n            if(num.contains(arr.get(i)))\\n            return arr.get(i);\\n        }\\n        return \"\";\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        for(int i=9;i>=0;i--)\\n        {\\n            String s = new String();\\n            for(int j=0;j<3;j++)\\n            {\\n                s=s+(char)(i+\\'0\\');\\n            }\\n            arr.add(s);\\n        }\\n        for(int i=0;i<=9;i++)\\n        {\\n            if(num.contains(arr.get(i)))\\n            return arr.get(i);\\n        }\\n        return \"\";\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807988,
                "title": "java-for-loop-sol",
                "content": "# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String ans = \"\";\\n    // System.out.println(num.length());\\n    for (int i = 2; i < num.length(); i++) {\\n      if (\\n        num.charAt(i) == num.charAt(i - 1) &&\\n        num.charAt(i) == num.charAt(i - 2) &&\\n        (ans == \"\" || ans.charAt(1) < num.charAt(i))\\n      ) {\\n        ans = num.substring(i - 2, i + 1);\\n      }\\n    //   System.out.println(num.charAt(i));\\n    }\\n    return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        String ans = \"\";\\n    // System.out.println(num.length());\\n    for (int i = 2; i < num.length(); i++) {\\n      if (\\n        num.charAt(i) == num.charAt(i - 1) &&\\n        num.charAt(i) == num.charAt(i - 2) &&\\n        (ans == \"\" || ans.charAt(1) < num.charAt(i))\\n      ) {\\n        ans = num.substring(i - 2, i + 1);\\n      }\\n    //   System.out.println(num.charAt(i));\\n    }\\n    return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795805,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n     int c=1;\\n     int n=num.size();\\n     int i=0;\\n     int maxi=INT_MIN;\\n     int ind=-1;\\n     while(i<n-1)\\n     {\\n         if(num[i]==num[i+1])\\n         c++;\\n         else\\n         c=1;\\n\\n         if(c==3 && num[i]-\\'0\\' > maxi)\\n         {\\n         maxi=num[i]-\\'0\\';\\n         ind=i;\\n         }\\n     i++;\\n     }   \\n    if(maxi != INT_MIN)\\n    return num.substr(ind-1,3);\\n\\nreturn \"\"; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n     int c=1;\\n     int n=num.size();\\n     int i=0;\\n     int maxi=INT_MIN;\\n     int ind=-1;\\n     while(i<n-1)\\n     {\\n         if(num[i]==num[i+1])\\n         c++;\\n         else\\n         c=1;\\n\\n         if(c==3 && num[i]-\\'0\\' > maxi)\\n         {\\n         maxi=num[i]-\\'0\\';\\n         ind=i;\\n         }\\n     i++;\\n     }   \\n    if(maxi != INT_MIN)\\n    return num.substr(ind-1,3);\\n\\nreturn \"\"; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794292,
                "title": "beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int n = num.length();\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n          if(num[i]==num[i+1] && num[i]==num[i+2]){\\n              ans+=num[i]; \\n              ans+=num[i];\\n              ans+=num[i];\\n           } \\n        }\\n        if(ans.size()==0) return \"\";   \\n        sort(ans.rbegin(), ans.rend());\\n        return ans.erase(3, ans.size());    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int n = num.length();\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n          if(num[i]==num[i+1] && num[i]==num[i+2]){\\n              ans+=num[i]; \\n              ans+=num[i];\\n              ans+=num[i];\\n           } \\n        }\\n        if(ans.size()==0) return \"\";   \\n        sort(ans.rbegin(), ans.rend());\\n        return ans.erase(3, ans.size());    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792978,
                "title": "2-pointer-solution-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int n=num.size();\\n        int i=0,j=0;\\n        vector<string> st;\\n        int cnt=0,cnt1=0;\\n        while(j<n){\\n         if(num[i]==num[j])\\n         {\\n             cnt++;\\n             j++;\\n         }\\n         else{\\n             cnt1++;\\n         }\\n         if((cnt+cnt1)%3==0){\\n            if(cnt==3){\\n                string s=num.substr(i,3);\\n                st.push_back(s);\\n            }\\n            i++;\\n            j=i;\\n            cnt=0;\\n            cnt1=0;\\n         }\\n        }\\n        sort(st.begin(),st.end());\\n        if(st.size()==0)\\n        return \"\";\\n        else\\n        return st[st.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int n=num.size();\\n        int i=0,j=0;\\n        vector<string> st;\\n        int cnt=0,cnt1=0;\\n        while(j<n){\\n         if(num[i]==num[j])\\n         {\\n             cnt++;\\n             j++;\\n         }\\n         else{\\n             cnt1++;\\n         }\\n         if((cnt+cnt1)%3==0){\\n            if(cnt==3){\\n                string s=num.substr(i,3);\\n                st.push_back(s);\\n            }\\n            i++;\\n            j=i;\\n            cnt=0;\\n            cnt1=0;\\n         }\\n        }\\n        sort(st.begin(),st.end());\\n        if(st.size()==0)\\n        return \"\";\\n        else\\n        return st[st.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786101,
                "title": "python-set-and-for-loop",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        result = -1\\n        \\n        for i in range(len(num) - 2):\\n            if len(set(num[i:i + 3])) == 1:\\n                result = max(result, int(num[i]))\\n        \\n        if result == -1:\\n            return \"\"\\n        return f\"{result}{result}{result}\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        result = -1\\n        \\n        for i in range(len(num) - 2):\\n            if len(set(num[i:i + 3])) == 1:\\n                result = max(result, int(num[i]))\\n        \\n        if result == -1:\\n            return \"\"\\n        return f\"{result}{result}{result}\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783123,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans = \"\";\\n\\n        char prev = num[0];\\n        for (int i=1 ; i<num.length()-1 ; i++){\\n            if (num[i] == prev && num[i] == num[i+1]){\\n                if (ans[0]-\\'0\\' < prev - \\'0\\'){ \\n                    ans = \"\";   \\n                    ans += prev;\\n                    ans += prev;\\n                    ans += prev;\\n                }\\n            }\\n            prev = num[i];\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans = \"\";\\n\\n        char prev = num[0];\\n        for (int i=1 ; i<num.length()-1 ; i++){\\n            if (num[i] == prev && num[i] == num[i+1]){\\n                if (ans[0]-\\'0\\' < prev - \\'0\\'){ \\n                    ans = \"\";   \\n                    ans += prev;\\n                    ans += prev;\\n                    ans += prev;\\n                }\\n            }\\n            prev = num[i];\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768247,
                "title": "lame-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string n){\\n        string s;\\n        for(int i=0; i<n.size()-2; i++){\\n            if(n[i]==n[i+1] && n[i+1]==n[i+2]){\\n                if(s==\"\"){\\n                    s+=n[i];\\n                    s+=n[i+1];\\n                    s+=n[i+2];\\n                    i+=2;\\n                }\\n                else{\\n                    if(s[0]<n[i]){\\n                        s[0]=n[i];\\n                        s[1]=n[i+1];\\n                        s[2]=n[i+2];\\n                        i+=2;\\n                    }\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string n){\\n        string s;\\n        for(int i=0; i<n.size()-2; i++){\\n            if(n[i]==n[i+1] && n[i+1]==n[i+2]){\\n                if(s==\"\"){\\n                    s+=n[i];\\n                    s+=n[i+1];\\n                    s+=n[i+2];\\n                    i+=2;\\n                }\\n                else{\\n                    if(s[0]<n[i]){\\n                        s[0]=n[i];\\n                        s[1]=n[i+1];\\n                        s[2]=n[i+2];\\n                        i+=2;\\n                    }\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765558,
                "title": "simplest-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int n=num.size();\\n        string s=\"\",ans=\"\";\\n        for(int i=0;i<n-2;i++){\\n            s=\"\";\\n            if(num[i]==num[i+1] && num[i]==num[i+2]){\\n                for(int j=i;j<i+3;j++){\\n                    s+=num[j];\\n                }\\n                if(ans.size()==0 || stoi(s)>stoi(ans)){\\n                    ans=s;\\n                }\\n                i+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int n=num.size();\\n        string s=\"\",ans=\"\";\\n        for(int i=0;i<n-2;i++){\\n            s=\"\";\\n            if(num[i]==num[i+1] && num[i]==num[i+2]){\\n                for(int j=i;j<i+3;j++){\\n                    s+=num[j];\\n                }\\n                if(ans.size()==0 || stoi(s)>stoi(ans)){\\n                    ans=s;\\n                }\\n                i+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761992,
                "title": "easy-solution-in-java-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String s) {\\n        int n=s.length();\\n        ArrayList<String> l=new ArrayList<>();\\n        for(int i=0;i<n-2;i++){\\n            String g=\"\";\\n            if(s.charAt(i)==s.charAt(i+1) && s.charAt(i+1)==s.charAt(i+2)){\\n                g+=s.charAt(i)+\"\"+s.charAt(i+1)+\"\"+s.charAt(i+2)+\"\";\\n                l.add(g);\\n            }\\n        }\\n       // System.out.print(l);\\n        Collections.sort(l);\\n        int p=l.size();\\n        if(p==0)\\n        return \"\";\\n        else\\n        return l.get(p-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String s) {\\n        int n=s.length();\\n        ArrayList<String> l=new ArrayList<>();\\n        for(int i=0;i<n-2;i++){\\n            String g=\"\";\\n            if(s.charAt(i)==s.charAt(i+1) && s.charAt(i+1)==s.charAt(i+2)){\\n                g+=s.charAt(i)+\"\"+s.charAt(i+1)+\"\"+s.charAt(i+2)+\"\";\\n                l.add(g);\\n            }\\n        }\\n       // System.out.print(l);\\n        Collections.sort(l);\\n        int p=l.size();\\n        if(p==0)\\n        return \"\";\\n        else\\n        return l.get(p-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753883,
                "title": "java-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        if(num.contains(\"999\"))\\n           return \"999\";\\n        else if(num.contains(\"888\"))\\n           return \"888\";\\n             else if(num.contains(\"777\"))\\n                return \"777\";\\n                  else if(num.contains(\"666\"))\\n                       return \"666\";\\n                       else if(num.contains(\"555\"))\\n                           return \"555\";\\n                            else if(num.contains(\"444\"))\\n                                return \"444\";\\n                                 else if(num.contains(\"333\"))\\n                                    return \"333\";\\n                                      else if(num.contains(\"222\"))\\n                                        return \"222\";\\n                                           else if(num.contains(\"111\"))\\n                                            return \"111\";\\n                                                else if(num.contains(\"000\"))\\n                                                    return \"000\";\\n\\n    return \"\";\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        if(num.contains(\"999\"))\\n           return \"999\";\\n        else if(num.contains(\"888\"))\\n           return \"888\";\\n             else if(num.contains(\"777\"))\\n                return \"777\";\\n                  else if(num.contains(\"666\"))\\n                       return \"666\";\\n                       else if(num.contains(\"555\"))\\n                           return \"555\";\\n                            else if(num.contains(\"444\"))\\n                                return \"444\";\\n                                 else if(num.contains(\"333\"))\\n                                    return \"333\";\\n                                      else if(num.contains(\"222\"))\\n                                        return \"222\";\\n                                           else if(num.contains(\"111\"))\\n                                            return \"111\";\\n                                                else if(num.contains(\"000\"))\\n                                                    return \"000\";\\n\\n    return \"\";\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749673,
                "title": "direct-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.length()-2;i++){\\n            string t=\"\";\\n            if(s[i]==s[i+1] && s[i+1]==s[i+2]){\\n                t+=s[i];\\n                t+=s[i];\\n                t+=s[i];\\n               \\n            }\\n            \\n            if(t>ans)\\n                ans=t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.length()-2;i++){\\n            string t=\"\";\\n            if(s[i]==s[i+1] && s[i+1]==s[i+2]){\\n                t+=s[i];\\n                t+=s[i];\\n                t+=s[i];\\n               \\n            }\\n            \\n            if(t>ans)\\n                ans=t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745236,
                "title": "python-simple-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        good_number = \"\"\\n        for i in range(1, len(num) - 1):\\n            if num[i - 1] == num[i] and num[i] == num[i + 1]:\\n                good_number = max(num[i - 1:i + 2], good_number)\\n\\n        return good_number\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        good_number = \"\"\\n        for i in range(1, len(num) - 1):\\n            if num[i - 1] == num[i] and num[i] == num[i + 1]:\\n                good_number = max(num[i - 1:i + 2], good_number)\\n\\n        return good_number\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720217,
                "title": "easy-javascript-solutions",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar largestGoodInteger = function(num) {\\n    let largestNumber = \"\";\\n\\n  for (let i = 0; i <= num.length - 3; i++) {\\n    const currentNumber = num.substring(i, i + 3);\\n\\n    if (\\n      currentNumber[0] === currentNumber[1] &&\\n      currentNumber[1] === currentNumber[2]\\n    ) {\\n      if (largestNumber === \"\" || currentNumber > largestNumber) {\\n        largestNumber = currentNumber;\\n      }\\n    }\\n  }\\n\\n  return largestNumber;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar largestGoodInteger = function(num) {\\n    let largestNumber = \"\";\\n\\n  for (let i = 0; i <= num.length - 3; i++) {\\n    const currentNumber = num.substring(i, i + 3);\\n\\n    if (\\n      currentNumber[0] === currentNumber[1] &&\\n      currentNumber[1] === currentNumber[2]\\n    ) {\\n      if (largestNumber === \"\" || currentNumber > largestNumber) {\\n        largestNumber = currentNumber;\\n      }\\n    }\\n  }\\n\\n  return largestNumber;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704782,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int n= num.size();\\n        vector<string> res;\\n        string re=\"\";\\n        for(int i=0;i<n-2;i++){\\n            if(num[i]!=num[i+1]||num[i]!=num[i+2]) continue;\\n            else{\\n                string s = \"\";\\n                for(int j=i;j<=i+2;j++){\\n                    s+=num[j];\\n                }\\n                \\n                if(re.compare(s)<0) re = s;\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        int n= num.size();\\n        vector<string> res;\\n        string re=\"\";\\n        for(int i=0;i<n-2;i++){\\n            if(num[i]!=num[i+1]||num[i]!=num[i+2]) continue;\\n            else{\\n                string s = \"\";\\n                for(int j=i;j<=i+2;j++){\\n                    s+=num[j];\\n                }\\n                \\n                if(re.compare(s)<0) re = s;\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700530,
                "title": "dart-solution-with-map",
                "content": "# Code\\n```\\nclass Solution {\\n  String largestGoodInteger(String num) {\\n    if (num.length <= 1) return \\'\\';\\n\\n    Map<int, String> stringMap = {};\\n\\n    for (int i = 0; i < num.length - 2; i++) {\\n      if (num[i] == num[i + 2] && num[i] == num[i + 1]) {\\n        stringMap.putIfAbsent(int.parse(num[i]), () => num.substring(i, i + 3));\\n      }\\n    }\\n\\n    for (int i = 9; i >= 0; i--) {\\n      if (stringMap.containsKey(i)) {\\n        return stringMap[i]!;\\n      }\\n    }\\n\\n    return \\'\\';\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String largestGoodInteger(String num) {\\n    if (num.length <= 1) return \\'\\';\\n\\n    Map<int, String> stringMap = {};\\n\\n    for (int i = 0; i < num.length - 2; i++) {\\n      if (num[i] == num[i + 2] && num[i] == num[i + 1]) {\\n        stringMap.putIfAbsent(int.parse(num[i]), () => num.substring(i, i + 3));\\n      }\\n    }\\n\\n    for (int i = 9; i >= 0; i--) {\\n      if (stringMap.containsKey(i)) {\\n        return stringMap[i]!;\\n      }\\n    }\\n\\n    return \\'\\';\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697515,
                "title": "python3-o-n-2-where-n-len-num",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        res = set()\\n        for x,y,z in zip(num[:], num[1:], num[2:]):\\n            if x == y == z :\\n                res.add(x)\\n        return max(res, default=\"\") * 3\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        res = set()\\n        for x,y,z in zip(num[:], num[1:], num[2:]):\\n            if x == y == z :\\n                res.add(x)\\n        return max(res, default=\"\") * 3\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691695,
                "title": "easy-c-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code finds and returns the largest sequence of three consecutive equal digits from the input string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach of the code is to scan the input string and identify the largest contiguous sequence of three equal digits, returning it as a string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N log N) $$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(M)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<int> v;\\n        for (int i = 0; i < num.size() - 2; i++) {\\n            if (num[i] == num[i + 1] && num[i] == num[i + 2]) {\\n                v.push_back(num[i] - \\'0\\');\\n                v.push_back(num[i + 1] - \\'0\\');\\n                v.push_back(num[i + 2] - \\'0\\');\\n                i += 2;\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if (v.empty()) {\\n            return \"\";\\n        } else {\\n            string result;\\n            result.push_back(v[v.size() - 1] + \\'0\\');\\n            result.push_back(v[v.size() - 2] + \\'0\\');\\n            result.push_back(v[v.size() - 3] + \\'0\\');\\n            return result;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<int> v;\\n        for (int i = 0; i < num.size() - 2; i++) {\\n            if (num[i] == num[i + 1] && num[i] == num[i + 2]) {\\n                v.push_back(num[i] - \\'0\\');\\n                v.push_back(num[i + 1] - \\'0\\');\\n                v.push_back(num[i + 2] - \\'0\\');\\n                i += 2;\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if (v.empty()) {\\n            return \"\";\\n        } else {\\n            string result;\\n            result.push_back(v[v.size() - 1] + \\'0\\');\\n            result.push_back(v[v.size() - 2] + \\'0\\');\\n            result.push_back(v[v.size() - 3] + \\'0\\');\\n            return result;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688365,
                "title": "easy-two-c-solution-string-string-npos",
                "content": "# Code 1>>>\\n```\\n string largestGoodInteger(string num) {\\n         string ans = \"\";\\n         for(char i=\\'9\\'; i>=0; i--)\\n         {\\n           string x = to_string(i-\\'0\\');\\n           ans = x+x+x;\\n           if(num.find(ans) != string::npos)\\n           {\\n             return ans;\\n           }\\n         }\\n         return \"\";\\n   }\\n};\\n```\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code 2>>>\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        char res = 0;\\n    for(int i = 2; i < num.size(); ++i)\\n        if (num[i] == num[i - 1] && num[i] == num[i - 2])\\n            res = max(res, num[i]);\\n    return res == 0 ? \"\" : string(3, res);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n string largestGoodInteger(string num) {\\n         string ans = \"\";\\n         for(char i=\\'9\\'; i>=0; i--)\\n         {\\n           string x = to_string(i-\\'0\\');\\n           ans = x+x+x;\\n           if(num.find(ans) != string::npos)\\n           {\\n             return ans;\\n           }\\n         }\\n         return \"\";\\n   }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        char res = 0;\\n    for(int i = 2; i < num.size(); ++i)\\n        if (num[i] == num[i - 1] && num[i] == num[i - 2])\\n            res = max(res, num[i]);\\n    return res == 0 ? \"\" : string(3, res);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685877,
                "title": "using-regex-in-javascript",
                "content": "# Explanation\\n\\n* Use regex to get the list of 3 digit numbers of same number as string\\n* Sort the resultant array\\n* The result would be the last element in the array\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar largestGoodInteger = function(num) {\\n    const strArray = num.match(/000|111|222|333|444|555|666|777|888|999/gm);\\n    if (strArray) return strArray.sort().pop();\\n    return \\'\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar largestGoodInteger = function(num) {\\n    const strArray = num.match(/000|111|222|333|444|555|666|777|888|999/gm);\\n    if (strArray) return strArray.sort().pop();\\n    return \\'\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683956,
                "title": "my-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans=\"\";int cnt=0;string maxi=\"\";\\n        for(int i=0;i<num.size();i++){\\nwhile(i<num.size()-1&&num[i]==num[i+1]){\\n    cnt++;ans+=num[i];i++;\\n}\\nif(cnt==2){\\n    ans+=ans[0];maxi=max(maxi,ans);\\n}\\nelse if(cnt>2){\\n    char s=ans[0];\\n    ans=\"\";\\n    for(int i=0;i<3;i++){\\nans+=s;\\n    }\\n    maxi=max(maxi,ans);\\n}\\nans=\"\";cnt=0;\\n        }\\nreturn maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans=\"\";int cnt=0;string maxi=\"\";\\n        for(int i=0;i<num.size();i++){\\nwhile(i<num.size()-1&&num[i]==num[i+1]){\\n    cnt++;ans+=num[i];i++;\\n}\\nif(cnt==2){\\n    ans+=ans[0];maxi=max(maxi,ans);\\n}\\nelse if(cnt>2){\\n    char s=ans[0];\\n    ans=\"\";\\n    for(int i=0;i<3;i++){\\nans+=s;\\n    }\\n    maxi=max(maxi,ans);\\n}\\nans=\"\";cnt=0;\\n        }\\nreturn maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668144,
                "title": "you-can-understand-100-easy-way-for-this-problem",
                "content": "\\n# Code\\n```\\nvar largestGoodInteger = function (num) {\\n  let digits = [\\n    \"000\",\\n    \"111\",\\n    \"222\",\\n    \"333\",\\n    \"444\",\\n    \"555\",\\n    \"666\",\\n    \"777\",\\n    \"888\",\\n    \"999\",\\n  ];\\n  let uniqueDigits = [];\\n  let nums = [num].toString().split(\"\").join(\"\");\\n  for (let i = 0; i < digits.length; i++) {\\n    if (nums.includes(digits[i])) {\\n      uniqueDigits.push(digits[i]);\\n    }\\n  }\\n  return uniqueDigits.length === 1 || uniqueDigits.length === 0\\n    ? uniqueDigits.join(\"\")\\n    : String(Math.max.apply(Math, uniqueDigits));\\n};\\n\\nconsole.log(largestGoodInteger(\"42352338\"));\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestGoodInteger = function (num) {\\n  let digits = [\\n    \"000\",\\n    \"111\",\\n    \"222\",\\n    \"333\",\\n    \"444\",\\n    \"555\",\\n    \"666\",\\n    \"777\",\\n    \"888\",\\n    \"999\",\\n  ];\\n  let uniqueDigits = [];\\n  let nums = [num].toString().split(\"\").join(\"\");\\n  for (let i = 0; i < digits.length; i++) {\\n    if (nums.includes(digits[i])) {\\n      uniqueDigits.push(digits[i]);\\n    }\\n  }\\n  return uniqueDigits.length === 1 || uniqueDigits.length === 0\\n    ? uniqueDigits.join(\"\")\\n    : String(Math.max.apply(Math, uniqueDigits));\\n};\\n\\nconsole.log(largestGoodInteger(\"42352338\"));\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667800,
                "title": "0ms-one-travesal",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans = \"\", temp = \"\";\\n        int n = num.length();\\n        for(int i = 1; i < n - 1; i++){\\n            if(num[i]==num[i-1]&&num[i]==num[i+1]){\\n                temp = num.substr(i-1, 3);\\n                if(ans < temp) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans = \"\", temp = \"\";\\n        int n = num.length();\\n        for(int i = 1; i < n - 1; i++){\\n            if(num[i]==num[i-1]&&num[i]==num[i+1]){\\n                temp = num.substr(i-1, 3);\\n                if(ans < temp) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640769,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n\\n        String ans = \"\";\\n       for(int i=9;i>=0;i--){\\n            ans = ans.concat(\"\"+i+i+i);\\n            if(num.contains(ans)) return ans;\\n            ans = \"\";\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n\\n        String ans = \"\";\\n       for(int i=9;i>=0;i--){\\n            ans = ans.concat(\"\"+i+i+i);\\n            if(num.contains(ans)) return ans;\\n            ans = \"\";\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635272,
                "title": "brute-force-approach",
                "content": "> # Complexity\\n- Time complexity:  O(n)\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public:\\n\\n    bool containsUnique(string s)\\n    {\\n        if(s[0]==s[1] && s[1]==s[2])\\n            return true;\\n        return false;\\n    }\\n\\n    string largestGoodInteger(string num) \\n    {\\n        //code here\\n        string ans = \"\";\\n        for(int i=0;i<num.length()-2;i++)\\n        {\\n            string s = num.substr(i,3);\\n            cout << s << endl;\\n            if(containsUnique(s))\\n            {\\n                if(ans==\"\")\\n                    ans = s;\\n                else\\n                {\\n                    if(stoi(ans) < stoi(s))\\n                        ans = s;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n\\n    bool containsUnique(string s)\\n    {\\n        if(s[0]==s[1] && s[1]==s[2])\\n            return true;\\n        return false;\\n    }\\n\\n    string largestGoodInteger(string num) \\n    {\\n        //code here\\n        string ans = \"\";\\n        for(int i=0;i<num.length()-2;i++)\\n        {\\n            string s = num.substr(i,3);\\n            cout << s << endl;\\n            if(containsUnique(s))\\n            {\\n                if(ans==\"\")\\n                    ans = s;\\n                else\\n                {\\n                    if(stoi(ans) < stoi(s))\\n                        ans = s;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3629681,
                "title": "dumb-solution-o-1-time-o-1-space",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        if \"999\" in num:\\n            return \"999\"\\n        if \"888\" in num:\\n            return \"888\"\\n        if \"777\" in num:\\n            return \"777\"\\n        if \"666\" in num:\\n            return \"666\"\\n        if \"555\" in num:\\n            return \"555\"\\n        if \"444\" in num:\\n            return \"444\"\\n        if \"333\" in num:\\n            return \"333\"\\n        if \"222\" in num:\\n            return \"222\"\\n        if \"111\" in num:\\n            return \"111\"\\n        if \"000\" in num:\\n            return \"000\"\\n        else:\\n            return \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        if \"999\" in num:\\n            return \"999\"\\n        if \"888\" in num:\\n            return \"888\"\\n        if \"777\" in num:\\n            return \"777\"\\n        if \"666\" in num:\\n            return \"666\"\\n        if \"555\" in num:\\n            return \"555\"\\n        if \"444\" in num:\\n            return \"444\"\\n        if \"333\" in num:\\n            return \"333\"\\n        if \"222\" in num:\\n            return \"222\"\\n        if \"111\" in num:\\n            return \"111\"\\n        if \"000\" in num:\\n            return \"000\"\\n        else:\\n            return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629411,
                "title": "easy-solution-beats-95",
                "content": "# Intuition\\n- Create a list of repeated nums and return the max of that list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n# Code\\n```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        if not num:\\n            return \\'\\'\\n        num=str(num)\\n        ans=[]\\n        for i in range(0,len((num))-2):\\n            if num[i]==num[i+1]==num[i+2]:\\n                ans.append((num)[i])\\n        \\n        if ans:\\n            return max(ans)*3\\n        else:return \\'\\'\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestGoodInteger(self, num: str) -> str:\\n        if not num:\\n            return \\'\\'\\n        num=str(num)\\n        ans=[]\\n        for i in range(0,len((num))-2):\\n            if num[i]==num[i+1]==num[i+2]:\\n                ans.append((num)[i])\\n        \\n        if ans:\\n            return max(ans)*3\\n        else:return \\'\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619540,
                "title": "first-draft",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string LargestGoodInteger(string num) {\\n        char lastChar = \\'a\\';\\n        int count = 1;\\n        string highest = string.Empty;\\n\\n        foreach (char c in num)\\n        {\\n            if (lastChar.Equals(c))\\n            {\\n                count++;\\n\\n                if (count == 3)\\n                {\\n                    if (highest != string.Empty)\\n                    {\\n                        if (int.TryParse(c.ToString(), out int current) && int.TryParse(highest, out int highestInt))\\n                        {\\n                            if (current > highestInt)\\n                            {\\n                                highest = current.ToString();\\n                            }\\n                        }\\n                    }\\n                    else\\n                    {\\n                        highest = c.ToString();\\n                    }\\n\\n                    count = 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n\\n            lastChar = c;\\n        }\\n\\n        return highest + highest + highest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestGoodInteger(string num) {\\n        char lastChar = \\'a\\';\\n        int count = 1;\\n        string highest = string.Empty;\\n\\n        foreach (char c in num)\\n        {\\n            if (lastChar.Equals(c))\\n            {\\n                count++;\\n\\n                if (count == 3)\\n                {\\n                    if (highest != string.Empty)\\n                    {\\n                        if (int.TryParse(c.ToString(), out int current) && int.TryParse(highest, out int highestInt))\\n                        {\\n                            if (current > highestInt)\\n                            {\\n                                highest = current.ToString();\\n                            }\\n                        }\\n                    }\\n                    else\\n                    {\\n                        highest = c.ToString();\\n                    }\\n\\n                    count = 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n\\n            lastChar = c;\\n        }\\n\\n        return highest + highest + highest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583513,
                "title": "java-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int res = 999;\\n        while(res > 0){\\n            if(num.contains(String.valueOf(res))){\\n                return String.valueOf(res);\\n            }\\n            res -= 111;\\n        }\\n        if(num.contains(\"000\"))\\n        {\\n            return \"000\";\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int res = 999;\\n        while(res > 0){\\n            if(num.contains(String.valueOf(res))){\\n                return String.valueOf(res);\\n            }\\n            res -= 111;\\n        }\\n        if(num.contains(\"000\"))\\n        {\\n            return \"000\";\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563391,
                "title": "beats-100-o-n-easy-solution-count",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<int>v;\\n        int count=1,maxi=-1;\\n        char x;\\n        for(int i=1;i<num.size();i++)\\n        {\\n            if(num[i]==num[i-1])\\n            {\\n                count++;\\n                if(count==3)\\n                {\\n                    maxi=max(maxi,num[i]-\\'0\\');\\n                }\\n            }\\n            else\\n             count=1;\\n        }\\n        string str=\"\"; \\n       if(maxi==-1)\\n        return \"\";\\n        char ch=maxi+\\'0\\';\\n        str=str+ch+ch+ch;\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        vector<int>v;\\n        int count=1,maxi=-1;\\n        char x;\\n        for(int i=1;i<num.size();i++)\\n        {\\n            if(num[i]==num[i-1])\\n            {\\n                count++;\\n                if(count==3)\\n                {\\n                    maxi=max(maxi,num[i]-\\'0\\');\\n                }\\n            }\\n            else\\n             count=1;\\n        }\\n        string str=\"\"; \\n       if(maxi==-1)\\n        return \"\";\\n        char ch=maxi+\\'0\\';\\n        str=str+ch+ch+ch;\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550626,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string result;\\n        char max = \\'0\\';\\n        for (auto i = 2; i < num.size(); ++i)\\n            if (num[i - 2] == num[i - 1] && num[i - 1] == num[i] && num[i] >= max) {\\n                result = string(3, num[i]);\\n                max = num[i];\\n            }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string result;\\n        char max = \\'0\\';\\n        for (auto i = 2; i < num.size(); ++i)\\n            if (num[i - 2] == num[i - 1] && num[i - 1] == num[i] && num[i] >= max) {\\n                result = string(3, num[i]);\\n                max = num[i];\\n            }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546520,
                "title": "simple-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans=\"\";\\n        int temp=0;\\n        for(int i=0; i<num.size()-2; i++)\\n        {\\n            if(num[i]==num[i+1] && num[i]==num[i+2])\\n            {\\n                int curr = (num[i]-\\'0\\')*100 + (num[i]-\\'0\\')*10 + (num[i]-\\'0\\');\\n                temp = max(temp, curr);\\n                ans=to_string(temp);\\n            }\\n        }\\n        if(ans==\"0\") return \"000\";\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestGoodInteger(string num) {\\n        string ans=\"\";\\n        int temp=0;\\n        for(int i=0; i<num.size()-2; i++)\\n        {\\n            if(num[i]==num[i+1] && num[i]==num[i+2])\\n            {\\n                int curr = (num[i]-\\'0\\')*100 + (num[i]-\\'0\\')*10 + (num[i]-\\'0\\');\\n                temp = max(temp, curr);\\n                ans=to_string(temp);\\n            }\\n        }\\n        if(ans==\"0\") return \"000\";\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543572,
                "title": "concise-solution-with-regex",
                "content": "# Code\\n```\\nfunction largestGoodInteger(num: string): string {\\n  return (num.match(/(\\\\d)\\\\1{2}/g) ?? []).sort().at(-1) ?? \\'\\';\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestGoodInteger(num: string): string {\\n  return (num.match(/(\\\\d)\\\\1{2}/g) ?? []).sort().at(-1) ?? \\'\\';\\n}\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1721310,
                "content": [
                    {
                        "username": "topswe",
                        "content": "brute force all 10 3 length strings. start from largest \\'999\\' and if found return it."
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Integers in Intervals",
        "question_content": "<p>Given an <strong>empty</strong> set of intervals, implement a data structure that can:</p>\n\n<ul>\n\t<li><strong>Add</strong> an interval to the set of intervals.</li>\n\t<li><strong>Count</strong> the number of integers that are present in <strong>at least one</strong> interval.</li>\n</ul>\n\n<p>Implement the <code>CountIntervals</code> class:</p>\n\n<ul>\n\t<li><code>CountIntervals()</code> Initializes the object with an empty set of intervals.</li>\n\t<li><code>void add(int left, int right)</code> Adds the interval <code>[left, right]</code> to the set of intervals.</li>\n\t<li><code>int count()</code> Returns the number of integers that are present in <strong>at least one</strong> interval.</li>\n</ul>\n\n<p><strong>Note</strong> that an interval <code>[left, right]</code> denotes all the integers <code>x</code> where <code>left &lt;= x &lt;= right</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;CountIntervals&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;]\n[[], [2, 3], [7, 10], [], [5, 8], []]\n<strong>Output</strong>\n[null, null, null, 6, null, 8]\n\n<strong>Explanation</strong>\nCountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals. \ncountIntervals.add(2, 3);  // add [2, 3] to the set of intervals.\ncountIntervals.add(7, 10); // add [7, 10] to the set of intervals.\ncountIntervals.count();    // return 6\n                           // the integers 2 and 3 are present in the interval [2, 3].\n                           // the integers 7, 8, 9, and 10 are present in the interval [7, 10].\ncountIntervals.add(5, 8);  // add [5, 8] to the set of intervals.\ncountIntervals.count();    // return 8\n                           // the integers 2 and 3 are present in the interval [2, 3].\n                           // the integers 5 and 6 are present in the interval [5, 8].\n                           // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10].\n                           // the integers 9 and 10 are present in the interval [7, 10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls <strong>in total</strong> will be made to <code>add</code> and <code>count</code>.</li>\n\t<li>At least <strong>one</strong> call will be made to <code>count</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2039706,
                "title": "merge-intervals",
                "content": "We use a map to add new intervals in O(log n). As we add an interval, we need to merge it with the existing ones, and update the counter. That way, the `count` function is O(1).\\n\\nMerging intervals is always tricky. The best is to use pen and paper to go through various scenarios.\\n\\nWhen we add an interval, we check for overlapping intervals before and after. We extend `left` and `right` accordingly, remove all overlapping intervals, and add the new interval `[left, right]` in the end. This is an example how we merge `[4, 14]` interval with the existing ones:\\n- Note that all existing overlapping intervals are removed, and their integers substracted from `cnt`.\\n\\t- We remove 3 intervals, and subtract `12`  from `cnt`.\\n- We extend the new interval to `[2, 15]`.\\n- We add the new interval `[2, 15]` and add `14` to the count .\\n\\t- The new interval resulted in adding `14 - 12 == 2` new integers.  \\n\\n![image](https://assets.leetcode.com/users/images/b0298dab-b861-4dd9-9904-90cd37e93fca_1652647113.0372255.png)\\n\\n**C++**\\n```cpp\\nclass CountIntervals {\\npublic:\\n    map<int, int> m;\\n    int cnt = 0;\\n    void add(int left, int right) {\\n        auto it = m.upper_bound(left);\\n        if (it != begin(m) && prev(it)->second >= left)\\n            it = prev(it);\\n        for (; it != end(m) && it->first <= right; m.erase(it++)) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            cnt -= it->second - it->first + 1;\\n        }\\n        cnt += right - left + 1;\\n        m[left] = right;\\n    }\\n    int count() { return cnt; }\\n};\\n```\\n\\n**Java**\\n```java\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> m = new TreeMap<>();\\n    int cnt = 0;\\n    public void add(int left, int right) {\\n        var it = m.floorEntry(left);\\n        if (it == null || it.getValue() < left)\\n            it = m.higherEntry(left);\\n        for (; it != null && it.getKey() <= right; it = m.higherEntry(left)) {\\n            left = Math.min(left, it.getKey());\\n            right = Math.max(right, it.getValue());\\n            cnt -= it.getValue() - it.getKey() + 1;\\n            m.remove(it.getKey());\\n        }\\n        m.put(left, right);\\n        cnt += right - left + 1;        \\n    }\\n    public int count() { return cnt; }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nclass CountIntervals {\\npublic:\\n    map<int, int> m;\\n    int cnt = 0;\\n    void add(int left, int right) {\\n        auto it = m.upper_bound(left);\\n        if (it != begin(m) && prev(it)->second >= left)\\n            it = prev(it);\\n        for (; it != end(m) && it->first <= right; m.erase(it++)) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            cnt -= it->second - it->first + 1;\\n        }\\n        cnt += right - left + 1;\\n        m[left] = right;\\n    }\\n    int count() { return cnt; }\\n};\\n```\n```java\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> m = new TreeMap<>();\\n    int cnt = 0;\\n    public void add(int left, int right) {\\n        var it = m.floorEntry(left);\\n        if (it == null || it.getValue() < left)\\n            it = m.higherEntry(left);\\n        for (; it != null && it.getKey() <= right; it = m.higherEntry(left)) {\\n            left = Math.min(left, it.getKey());\\n            right = Math.max(right, it.getValue());\\n            cnt -= it.getValue() - it.getKey() + 1;\\n            m.remove(it.getKey());\\n        }\\n        m.put(left, right);\\n        cnt += right - left + 1;        \\n    }\\n    public int count() { return cnt; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039728,
                "title": "java-treemap-w-explanation-readability",
                "content": "```\\nclass CountIntervals {\\n    // Interval treemap start -> finish.\\n    TreeMap<Integer, Integer> s;\\n    int count;\\n    public CountIntervals() {\\n        s = new TreeMap<Integer, Integer>();\\n        count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        // Add interval if there is no overlapping.\\n        if (s.floorKey(right) == null || s.get(s.floorKey(right)) < left) {\\n            s.put(left, right);\\n            count += (right - left + 1);\\n        } else {\\n            int start = left;\\n            int end = right;\\n            \\n            // Remove overlapping intervals and update count.\\n            while (true) {\\n                int l = s.floorKey(end);\\n                int r = s.get(l);\\n                start = Math.min(start, l);\\n                end = Math.max(end, r);\\n                count -= (r - l + 1);\\n                s.remove(l);\\n                // Break the loop until there is no overlapping with interval (start, end).\\n                if (s.floorKey(end) == null || s.get(s.floorKey(end)) < start) {\\n                    break;\\n                }\\n            }\\n            // Add (start, end) to TreeMap and update count.\\n            s.put(start, end);\\n            count += (end - start + 1);\\n        }\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass CountIntervals {\\n    // Interval treemap start -> finish.\\n    TreeMap<Integer, Integer> s;\\n    int count;\\n    public CountIntervals() {\\n        s = new TreeMap<Integer, Integer>();\\n        count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        // Add interval if there is no overlapping.\\n        if (s.floorKey(right) == null || s.get(s.floorKey(right)) < left) {\\n            s.put(left, right);\\n            count += (right - left + 1);\\n        } else {\\n            int start = left;\\n            int end = right;\\n            \\n            // Remove overlapping intervals and update count.\\n            while (true) {\\n                int l = s.floorKey(end);\\n                int r = s.get(l);\\n                start = Math.min(start, l);\\n                end = Math.max(end, r);\\n                count -= (r - l + 1);\\n                s.remove(l);\\n                // Break the loop until there is no overlapping with interval (start, end).\\n                if (s.floorKey(end) == null || s.get(s.floorKey(end)) < start) {\\n                    break;\\n                }\\n            }\\n            // Add (start, end) to TreeMap and update count.\\n            s.put(start, end);\\n            count += (end - start + 1);\\n        }\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2040021,
                "title": "set-cleanest-short-c",
                "content": "- Use set to keep intervals in sorted order.\\n- Find the overlapping intervals and remove them.\\n- Add the new intervals\\n- Keep track of number of elements.\\n\\n```c++\\nclass CountIntervals {\\n    set<pair<int, int>> st;\\n    int cnt;\\npublic:\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = st.upper_bound({left, INT_MIN});\\n        \\n        if(it != st.begin() && (--it)->second < left) {\\n            ++it;\\n        }\\n        \\n        while(it != st.end() && it->first <= right) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            \\n            cnt -= (it->second - it->first + 1);\\n            it = st.erase(it);\\n        }\\n        \\n        st.insert({ left, right });\\n        cnt += (right - left + 1);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```c++\\nclass CountIntervals {\\n    set<pair<int, int>> st;\\n    int cnt;\\npublic:\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = st.upper_bound({left, INT_MIN});\\n        \\n        if(it != st.begin() && (--it)->second < left) {\\n            ++it;\\n        }\\n        \\n        while(it != st.end() && it->first <= right) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            \\n            cnt -= (it->second - it->first + 1);\\n            it = st.erase(it);\\n        }\\n        \\n        st.insert({ left, right });\\n        cnt += (right - left + 1);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039730,
                "title": "python3-built-in-list-beats-sortedlist",
                "content": "### Idea\\n1. Initialize list `interv` with  `[(-inf, -inf), (inf, inf)]` to store the merged intervals and integer `cov = 0`, to be updated after addition of each interval\\n2. Whenever an interval must be added, the following must be done\\n- Using binary search, find the range of affected intervals in `interv`, denoted by `li` for left most, `ri` for right most + 1\\n- the range of the new merged interval (`lval`, `rval`)\\n- replace the range of [li, ri - 1], inclusive with the new merged interval `(lval, rval)`\\n3. Update the coverege by\\n- Finding and subtracting the coverage of deleted intervals `to_delete`\\n- Adding the coverage of new interval `rval - lval + 1`\\n\\n### Code\\n#### Built-in List\\n```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n\\t# initialize the merged intervals list as below to handle edge cases\\n        self.interv = [(-inf, -inf), (inf, inf)]\\n        self.cov = 0   \\n\\n    def add(self, left: int, right: int) -> None:\\n        \\n        interv = self.interv\\n        \\n\\t\\t# find the left most position for inserting of the new potentially merged interval\\n\\t\\t# we use `left - 1` because the interval coverage is inclusive\\n        li = bisect.bisect_left(interv, left - 1, key=itemgetter(1))\\n        lval = min(interv[li][0], left)\\n\\t\\t\\n\\t\\t# find the right most position for inserting the new potentially merged interval\\n\\t\\t# we use `right + 1` because the interval coverage is inclusive\\n        ri = bisect.bisect_right(interv, right + 1, key=itemgetter(0))\\n        rval = max(interv[ri - 1][1], right)\\n\\n\\t\\t# find the coverage of the intervals that will be replaced by the new interval\\n        to_delete = 0\\n        for _ in range(li, ri):\\n            to_delete += interv[_][1] - interv[_][0] + 1\\n            \\n\\t\\t# udpate the coverage\\n        self.cov += rval - lval + 1 - to_delete\\n        interv[li: ri] = [(lval, rval)]\\n\\n    def count(self) -> int:\\n        return self.cov\\n```\\n\\n#### SortedList\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.cov = 0 \\n        self.interv = SortedList([(-inf, -inf), (inf, inf)])\\n\\n    def add(self, left: int, right: int) -> None:\\n        li = self.interv.bisect_left((left - 1, -inf))\\n        if self.interv[li - 1][1] >= left - 1:\\n            li -= 1\\n        lval = min(self.interv[li][0], left)\\n        ri = self.interv.bisect_right((right + 1, inf))\\n        rval = max(self.interv[ri - 1][1], right)\\n        \\n        \\n        to_delete = 0\\n        for _ in range(li, ri):\\n            to_delete += self.interv[_][1] - self.interv[_][0] + 1\\n        self.cov += rval - lval + 1 - to_delete\\n        del self.interv[li: ri]\\n        self.interv.add((lval, rval))\\n\\n    def count(self) -> int:\\n        return self.cov\\n```\\n\\n### Feedback\\nI appreciate your feedback and support! :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n\\t# initialize the merged intervals list as below to handle edge cases\\n        self.interv = [(-inf, -inf), (inf, inf)]\\n        self.cov = 0   \\n\\n    def add(self, left: int, right: int) -> None:\\n        \\n        interv = self.interv\\n        \\n\\t\\t# find the left most position for inserting of the new potentially merged interval\\n\\t\\t# we use `left - 1` because the interval coverage is inclusive\\n        li = bisect.bisect_left(interv, left - 1, key=itemgetter(1))\\n        lval = min(interv[li][0], left)\\n\\t\\t\\n\\t\\t# find the right most position for inserting the new potentially merged interval\\n\\t\\t# we use `right + 1` because the interval coverage is inclusive\\n        ri = bisect.bisect_right(interv, right + 1, key=itemgetter(0))\\n        rval = max(interv[ri - 1][1], right)\\n\\n\\t\\t# find the coverage of the intervals that will be replaced by the new interval\\n        to_delete = 0\\n        for _ in range(li, ri):\\n            to_delete += interv[_][1] - interv[_][0] + 1\\n            \\n\\t\\t# udpate the coverage\\n        self.cov += rval - lval + 1 - to_delete\\n        interv[li: ri] = [(lval, rval)]\\n\\n    def count(self) -> int:\\n        return self.cov\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.cov = 0 \\n        self.interv = SortedList([(-inf, -inf), (inf, inf)])\\n\\n    def add(self, left: int, right: int) -> None:\\n        li = self.interv.bisect_left((left - 1, -inf))\\n        if self.interv[li - 1][1] >= left - 1:\\n            li -= 1\\n        lval = min(self.interv[li][0], left)\\n        ri = self.interv.bisect_right((right + 1, inf))\\n        rval = max(self.interv[ri - 1][1], right)\\n        \\n        \\n        to_delete = 0\\n        for _ in range(li, ri):\\n            to_delete += self.interv[_][1] - self.interv[_][0] + 1\\n        self.cov += rval - lval + 1 - to_delete\\n        del self.interv[li: ri]\\n        self.interv.add((lval, rval))\\n\\n    def count(self) -> int:\\n        return self.cov\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040175,
                "title": "python3-sortedlist",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/5edf72d3865cd9791f0a89b968c0c1aeeaa381c3) for solutions of weekly 293. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.cnt = 0 \\n        self.intervals = SortedList()\\n\\n    def add(self, left: int, right: int) -> None:\\n        k = self.intervals.bisect_left((left, right))\\n        while k < len(self.intervals) and self.intervals[k][0] <= right: \\n            l, r = self.intervals.pop(k)\\n            self.cnt -= r - l + 1\\n            right = max(right, r)\\n        if k and left <= self.intervals[k-1][1]: \\n            l, r = self.intervals.pop(k-1)\\n            self.cnt -= r - l + 1\\n            left = l\\n            right = max(right, r)\\n        self.cnt += right - left + 1\\n        self.intervals.add((left, right))\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.cnt = 0 \\n        self.intervals = SortedList()\\n\\n    def add(self, left: int, right: int) -> None:\\n        k = self.intervals.bisect_left((left, right))\\n        while k < len(self.intervals) and self.intervals[k][0] <= right: \\n            l, r = self.intervals.pop(k)\\n            self.cnt -= r - l + 1\\n            right = max(right, r)\\n        if k and left <= self.intervals[k-1][1]: \\n            l, r = self.intervals.pop(k-1)\\n            self.cnt -= r - l + 1\\n            left = l\\n            right = max(right, r)\\n        self.cnt += right - left + 1\\n        self.intervals.add((left, right))\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039705,
                "title": "java-bst-solution-with-pictures",
                "content": "We need a data structure that will store intervals without storing overlapping ranges. A data structure that comes to mind that is often used to handle intervals (and ignoring duplicates) is a bst. Instead of inserting numbers, we insert intervals. If an interval is completely to the left of another, it will be in its left subtree and if an interval is completely to the right, it will be in its right subtree. \\n\\nBut what about intervals that overlap ? \\nWe will cut the intervals so that they will not overlap. This not only allows us to compare intervals easily, we also remove overlapping ranges. The picture attached below should give an idea about what im talking about.\\n![image](https://assets.leetcode.com/users/images/03fc91f4-5bbf-4a08-a264-9c8acf782fbf_1652586842.3461363.jpeg)\\n\\nThe code for inserting an interval would look something like this:\\n```\\nprivate Node insert(Node node, int l, int r) {\\n            if(l > r) {\\n                return node;\\n            }\\n\\n            if(node == null) {\\n                return new Node(l, r);\\n            }\\n\\t\\t\\t\\n            node.left = insert(node.left, l, Math.min(node.l - 1, r));\\n            node.right = insert(node.right, Math.max(node.r + 1, l), r);\\n\\n            update(node);\\n            return balance(node);\\n        }\\n```\\nNow that inserting intervals is taken care of , how do we count the sum of the ranges ? this can easily be done by storing the sum of the ranges of the subtree, for every subtree and always maintaining the invariant subtree_sum = cur_range_sum + left_sum + right_sum.\\n![image](https://assets.leetcode.com/users/images/c4adb5e7-c7d5-4695-a84c-5f874a97a733_1652587858.1101189.jpeg)\\n\\n\\nfull code: (a bit long and messy):\\n```\\nclass CountIntervals {\\n\\n    private static class AVL {\\n        private static class Node {\\n            int l, r;\\n            int subtree_size;\\n            int balance_factor;\\n            int height;\\n            Node left, right;\\n            int range_size;\\n\\n            Node(int l, int r) {\\n                this.l = l;\\n                this.r = r;\\n                subtree_size = r - l + 1;\\n                balance_factor = 0;\\n                height = 0;\\n                left = right = null;\\n                range_size = r - l + 1;\\n            }\\n            \\n            @Override\\n            public String toString() {\\n                return \"Node{\" +\\n                        \"l=\" + l +\\n                        \", r=\" + r +\\n                        \", subtree_size=\" + subtree_size +\\n                        \"} range_size: \" + range_size;\\n            }\\n        }\\n\\n        Node root;\\n        AVL() {\\n            root = null;\\n        }\\n\\n        public void add(int l, int r) {\\n            root = insert(root, l, r);\\n        }\\n\\n        public int size() {\\n            if(root == null) {\\n                return 0;\\n            }\\n            return root.subtree_size;\\n        }\\n\\n        private Node insert(Node node, int l, int r) {\\n            if(l > r) {\\n                return node;\\n            }\\n\\n            if(node == null) {\\n                return new Node(l, r);\\n            }\\n\\n           \\n            node.left = insert(node.left, l, Math.min(node.l - 1, r));\\n            node.right = insert(node.right, Math.max(node.r + 1, l), r);\\n\\n            update(node);\\n            return balance(node);\\n        }\\n\\n        private void update(Node node) {\\n            int lh = node.left == null ? -1 : node.left.height;\\n            int rh = node.right == null ? -1 : node.right.height;\\n            node.height = 1 + Math.max(lh, rh);\\n            node.balance_factor = rh - lh;\\n\\n            int ls = node.left == null ? 0 : node.left.subtree_size;\\n            int rs = node.right == null ? 0 : node.right.subtree_size;\\n            node.subtree_size = node.range_size + ls + rs;\\n        }\\n\\n        private Node balance(Node node) {\\n            //left heavy\\n            if(node.balance_factor == -2) {\\n                //left left\\n                if(node.left.balance_factor <= 0) {\\n                    return rightRotate(node);\\n                }\\n                //left right\\n                else {\\n                    node.left = leftRotate(node.left);\\n                    return rightRotate(node);\\n                }\\n            }\\n            //right heavy\\n            else if(node.balance_factor == 2) {\\n                //right right\\n                if(node.right.balance_factor >= 0) {\\n                    return leftRotate(node);\\n                }\\n                //right left\\n                else {\\n                    node.right = rightRotate(node.right);\\n                    return leftRotate(node);\\n                }\\n            }\\n            return node;\\n        }\\n\\n        private Node rightRotate(Node A) {\\n            Node B = A.left;\\n            A.left = B.right;\\n            B.right = A;\\n\\n            update(A);\\n            update(B);\\n            return B;\\n        }\\n\\n        private Node leftRotate(Node B) {\\n            Node A = B.right;\\n            B.right = A.left;\\n            A.left = B;\\n\\n            update(B);\\n            update(A);\\n            return A;\\n        }\\n        \\n        private void preorder(Node node) {\\n            if(node == null) {\\n                return;\\n            }\\n            System.out.println(node);\\n            preorder(node.left);\\n            preorder(node.right);\\n        }\\n    }\\n    \\n    AVL avl;\\n    public CountIntervals() {\\n        avl = new AVL();\\n    }\\n    \\n    public void add(int left, int right) {\\n        avl.add(left, right);\\n    }\\n    \\n    public int count() {\\n        return avl.size();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nprivate Node insert(Node node, int l, int r) {\\n            if(l > r) {\\n                return node;\\n            }\\n\\n            if(node == null) {\\n                return new Node(l, r);\\n            }\\n\\t\\t\\t\\n            node.left = insert(node.left, l, Math.min(node.l - 1, r));\\n            node.right = insert(node.right, Math.max(node.r + 1, l), r);\\n\\n            update(node);\\n            return balance(node);\\n        }\\n```\n```\\nclass CountIntervals {\\n\\n    private static class AVL {\\n        private static class Node {\\n            int l, r;\\n            int subtree_size;\\n            int balance_factor;\\n            int height;\\n            Node left, right;\\n            int range_size;\\n\\n            Node(int l, int r) {\\n                this.l = l;\\n                this.r = r;\\n                subtree_size = r - l + 1;\\n                balance_factor = 0;\\n                height = 0;\\n                left = right = null;\\n                range_size = r - l + 1;\\n            }\\n            \\n            @Override\\n            public String toString() {\\n                return \"Node{\" +\\n                        \"l=\" + l +\\n                        \", r=\" + r +\\n                        \", subtree_size=\" + subtree_size +\\n                        \"} range_size: \" + range_size;\\n            }\\n        }\\n\\n        Node root;\\n        AVL() {\\n            root = null;\\n        }\\n\\n        public void add(int l, int r) {\\n            root = insert(root, l, r);\\n        }\\n\\n        public int size() {\\n            if(root == null) {\\n                return 0;\\n            }\\n            return root.subtree_size;\\n        }\\n\\n        private Node insert(Node node, int l, int r) {\\n            if(l > r) {\\n                return node;\\n            }\\n\\n            if(node == null) {\\n                return new Node(l, r);\\n            }\\n\\n           \\n            node.left = insert(node.left, l, Math.min(node.l - 1, r));\\n            node.right = insert(node.right, Math.max(node.r + 1, l), r);\\n\\n            update(node);\\n            return balance(node);\\n        }\\n\\n        private void update(Node node) {\\n            int lh = node.left == null ? -1 : node.left.height;\\n            int rh = node.right == null ? -1 : node.right.height;\\n            node.height = 1 + Math.max(lh, rh);\\n            node.balance_factor = rh - lh;\\n\\n            int ls = node.left == null ? 0 : node.left.subtree_size;\\n            int rs = node.right == null ? 0 : node.right.subtree_size;\\n            node.subtree_size = node.range_size + ls + rs;\\n        }\\n\\n        private Node balance(Node node) {\\n            //left heavy\\n            if(node.balance_factor == -2) {\\n                //left left\\n                if(node.left.balance_factor <= 0) {\\n                    return rightRotate(node);\\n                }\\n                //left right\\n                else {\\n                    node.left = leftRotate(node.left);\\n                    return rightRotate(node);\\n                }\\n            }\\n            //right heavy\\n            else if(node.balance_factor == 2) {\\n                //right right\\n                if(node.right.balance_factor >= 0) {\\n                    return leftRotate(node);\\n                }\\n                //right left\\n                else {\\n                    node.right = rightRotate(node.right);\\n                    return leftRotate(node);\\n                }\\n            }\\n            return node;\\n        }\\n\\n        private Node rightRotate(Node A) {\\n            Node B = A.left;\\n            A.left = B.right;\\n            B.right = A;\\n\\n            update(A);\\n            update(B);\\n            return B;\\n        }\\n\\n        private Node leftRotate(Node B) {\\n            Node A = B.right;\\n            B.right = A.left;\\n            A.left = B;\\n\\n            update(B);\\n            update(A);\\n            return A;\\n        }\\n        \\n        private void preorder(Node node) {\\n            if(node == null) {\\n                return;\\n            }\\n            System.out.println(node);\\n            preorder(node.left);\\n            preorder(node.right);\\n        }\\n    }\\n    \\n    AVL avl;\\n    public CountIntervals() {\\n        avl = new AVL();\\n    }\\n    \\n    public void add(int left, int right) {\\n        avl.add(left, right);\\n    }\\n    \\n    public int count() {\\n        return avl.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039734,
                "title": "c-easy-bst-recursion",
                "content": "The idea is simple.\\nBefore insert new interval, check any previous intervals overlap.\\nIf any, remove these intevals and recurse with merged interval.\\n\\n**Time Complexity**\\nBest: O(log n) per add call\\nWorst: O(n log n) per add call\\n* Worst case can be optimized to O(n) with iterative approach: [Merge-intervals](https://leetcode.com/problems/count-integers-in-intervals/discuss/2039706/Merge-Intervals)\\n\\n```\\nclass CountIntervals {\\nprivate:\\n    int cnt;\\n    set<pair<int, int>> pool;\\n    \\npublic:\\n    CountIntervals() {\\n        cnt = 0;        \\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = pool.lower_bound({left, right});\\n        if (it != pool.end()) {\\n            auto [qleft, qright] = *it;\\n            if (qleft <= right) {\\n                cnt -= qright - qleft + 1;\\n                pool.erase(it);\\n                add(left, max(right, qright));\\n                return;\\n            }\\n        }\\n        if (it != pool.begin()) {\\n            auto [pleft, pright] = *(--it);\\n            if (pright >= left) {\\n                cnt -= pright - pleft + 1;\\n                pool.erase(it);\\n                add(pleft, max(pright, right));\\n                return;\\n            }\\n        }\\n        cnt += right - left + 1;\\n        pool.insert({left, right});\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass CountIntervals {\\nprivate:\\n    int cnt;\\n    set<pair<int, int>> pool;\\n    \\npublic:\\n    CountIntervals() {\\n        cnt = 0;        \\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = pool.lower_bound({left, right});\\n        if (it != pool.end()) {\\n            auto [qleft, qright] = *it;\\n            if (qleft <= right) {\\n                cnt -= qright - qleft + 1;\\n                pool.erase(it);\\n                add(left, max(right, qright));\\n                return;\\n            }\\n        }\\n        if (it != pool.begin()) {\\n            auto [pleft, pright] = *(--it);\\n            if (pright >= left) {\\n                cnt -= pright - pleft + 1;\\n                pool.erase(it);\\n                add(pleft, max(pright, right));\\n                return;\\n            }\\n        }\\n        cnt += right - left + 1;\\n        pool.insert({left, right});\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039857,
                "title": "c-sweep-line-based-approach-with-lazy-computation",
                "content": "Intuition:\\n\\n1. In the given problem, we are given two APIs: `add` to add a specific interval and `count` to get the number of integers included in the already added intervals.\\n2. In order to implement `add`, we need to find a way to efficiently mark the added interval.\\n\\t1. Let\\'s assume that we have a number line where we mark all the integers which are part of interval. For instance,\\n\\t```\\n\\t0 0 0 0 0 0  => occurrence\\n\\t1 2 3 4 5 6 => integers\\n\\t```\\n\\t2. Let\\'s say I add interval [2,4] to it, my number line will look something like this:\\n\\t```\\n\\t0 1 1 1 0 0  => occurrence\\n\\t1 2 3 4 5 6 => integers\\n\\t```\\n\\t3. For smaller constraints, It may be done. But for larger constraints, Let\\'s say [1,10^9], It is **not feasible**.\\n\\t4. Hence, Instead of marking each and every integer, We only mark the boundaries of the interval. For instance,\\n\\t```\\n\\t0 0 0 0 0 0  => occurrence\\n\\t1 2 3 4 5 6 => integers\\n\\t```\\n\\t5. Now on adding [2,4] to it, We will add 1 to 2 (to mark the starting of interval) and -1 to 5 (to mark the end of the interval).\\n\\t```\\n\\t0 1 0 0 -1 0  => occurrence\\n\\t1 2 3 4 5 6 => integers\\n\\t```\\n\\t6. Now, the **cumulative sum** at any given integer can tell me whether it is included in some interval. **If its non zero, it means that it is included.**\\n\\t7. But there is another problem. This approach requires creating a big array of integers (probably of size 10^9) which will end up giving **memory limit exceeded** issues.\\n\\t8. Instead, What we can do is we can store the boundaries in a ordered map. For instance, \\n    ```\\n\\t[] => ordered map\\n\\t```\\n\\t9. On adding [2, 4], It will look something like this:\\n\\t```\\n\\t[[2, 1], [5, -1]] => ordered map\\n\\t```\\n3. For `count`,\\n    1. We can traverse the ordered map created by adding the intervals and determine the number of integers by considering the **cumulative sum**.\\n    2. One important thing to note here is that we can merge our intervals at this phase only. This will help us in optimising our future `add` and `count` calls since merged intervals will always be smaller.\\n\\t\\t1. If cumulative sum is 0 before processing a event (or boundary), that means that it is a **start** of the merged interval.\\n\\t\\t2. If cumulative sum is 0 after processing a event (or boundary), that means that it is a **end** of the merged interval.\\n\\nHere is the C++ Code:\\n\\n```\\nclass CountIntervals {\\n    map<int, int> events; /* to store start and end events */\\n    int lastCnt; /* to store last count. This avoids recomputation in case of subsequent count() calls */\\n    \\npublic:\\n    CountIntervals(): lastCnt(-1) {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n\\t    /*\\n\\t\\t\\tAdding +1 for marking start, -1 for marking end.\\n\\t\\t\\tright + 1 is being done since both start and end are inclusive.\\n\\t\\t\\tSet lastCnt to -1 since recomputation has to be done.\\n\\t\\t*/\\n        events[left]++, events[right + 1]--, lastCnt = -1;\\n    }\\n    \\n    int count() {\\n\\t    /* If recomputation has to be done */\\n        if (lastCnt == -1) {\\n            lastCnt = 0;\\n\\t\\t\\t/* curInt stores number of active intervals,\\n\\t\\t\\tllim stores starting position of currently active merged interval */\\n            int curInt = 0, llim = 0;\\n            \\n\\t\\t\\t/* map to store merged events */\\n            map<int, int> newEvents;\\n            \\n            for (const auto& p: events) {\\n\\t\\t\\t    /* if no ongoing merged interval, then this is our start of our merged interval */\\n                if (curInt == 0) {\\n                    llim = p.first, newEvents[llim]++;\\n                }\\n                \\n                curInt += p.second;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* If after adding p.second, curInt is zero, it means that we have found the end of merged interval */\\n                if (curInt == 0) {\\n                    lastCnt += (p.first - llim), newEvents[p.first]--;\\n                }\\n            }\\n            \\n\\t\\t\\t/* assigning merged intervals to originally stored intervals. */\\n            events = newEvents;\\n        }\\n        \\n        return lastCnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t0 0 0 0 0 0  => occurrence\\n\\t1 2 3 4 5 6 => integers\\n\\t```\n```\\n\\t0 1 1 1 0 0  => occurrence\\n\\t1 2 3 4 5 6 => integers\\n\\t```\n```\\n\\t0 0 0 0 0 0  => occurrence\\n\\t1 2 3 4 5 6 => integers\\n\\t```\n```\\n\\t0 1 0 0 -1 0  => occurrence\\n\\t1 2 3 4 5 6 => integers\\n\\t```\n```\\n\\t[] => ordered map\\n\\t```\n```\\n\\t[[2, 1], [5, -1]] => ordered map\\n\\t```\n```\\nclass CountIntervals {\\n    map<int, int> events; /* to store start and end events */\\n    int lastCnt; /* to store last count. This avoids recomputation in case of subsequent count() calls */\\n    \\npublic:\\n    CountIntervals(): lastCnt(-1) {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n\\t    /*\\n\\t\\t\\tAdding +1 for marking start, -1 for marking end.\\n\\t\\t\\tright + 1 is being done since both start and end are inclusive.\\n\\t\\t\\tSet lastCnt to -1 since recomputation has to be done.\\n\\t\\t*/\\n        events[left]++, events[right + 1]--, lastCnt = -1;\\n    }\\n    \\n    int count() {\\n\\t    /* If recomputation has to be done */\\n        if (lastCnt == -1) {\\n            lastCnt = 0;\\n\\t\\t\\t/* curInt stores number of active intervals,\\n\\t\\t\\tllim stores starting position of currently active merged interval */\\n            int curInt = 0, llim = 0;\\n            \\n\\t\\t\\t/* map to store merged events */\\n            map<int, int> newEvents;\\n            \\n            for (const auto& p: events) {\\n\\t\\t\\t    /* if no ongoing merged interval, then this is our start of our merged interval */\\n                if (curInt == 0) {\\n                    llim = p.first, newEvents[llim]++;\\n                }\\n                \\n                curInt += p.second;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* If after adding p.second, curInt is zero, it means that we have found the end of merged interval */\\n                if (curInt == 0) {\\n                    lastCnt += (p.first - llim), newEvents[p.first]--;\\n                }\\n            }\\n            \\n\\t\\t\\t/* assigning merged intervals to originally stored intervals. */\\n            events = newEvents;\\n        }\\n        \\n        return lastCnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039866,
                "title": "java-python-segment-tree",
                "content": "```\\nclass Node {\\n    int lower, upper, val;\\n    Node left, right;\\n    public Node(int lower, int upper, int val) {\\n        this.lower = lower;\\n        this.upper = upper;\\n        this.val = val;\\n    }\\n}\\nclass CountIntervals {\\n    Node root;\\n    public CountIntervals() {\\n        root = new Node(0, 1000000000, 0);\\n    }\\n    \\n    private void setRange(Node node, int left, int right) {\\n        if (left <= node.lower && node.upper <= right) {\\n            node.val = node.upper - node.lower + 1;\\n            node.left = null;\\n            node.right = null;\\n            return;\\n        } \\n        int mid = (node.upper + node.lower) / 2;\\n        if (node.left == null && node.right == null) {\\n            node.left = new Node(node.lower, mid, node.val > 0 ? mid - node.lower + 1 : 0);\\n            node.right = new Node(mid + 1, node.upper, node.val > 0 ? node.upper - (mid + 1) + 1 : 0);\\n        }\\n        if (left <= mid) \\n            setRange(node.left, left, right);\\n        if (right > mid) \\n            setRange(node.right, left, right);\\n        node.val = node.left.val + node.right.val;\\n    }\\n    \\n    public void add(int left, int right) {\\n        setRange(root, left, right);\\n    }\\n    \\n    public int count() {\\n        return root.val;\\n    }\\n}\\n```\\n\\n```\\nclass Node:\\n    def __init__(self, lower, upper, val):\\n        self.lower = lower\\n        self.upper = upper\\n        self.left = None\\n        self.right = None\\n        self.val = val\\n        \\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.root = Node(0, 1000000000, 0)\\n\\n    def _set_range(self, node, left, right): \\n        # print(left, right, node.lower, node.upper)\\n        if left <= node.lower and node.upper <= right: \\n            node.val = node.upper - node.lower + 1\\n            node.left = node.right = None\\n            return \\n        mid = (node.upper + node.lower) // 2\\n        if not node.left and not node.right:\\n            node.left = Node(node.lower, mid, mid - node.lower + 1 if node.val else 0)\\n            node.right = Node(mid + 1, node.upper, node.upper - (mid + 1) + 1 if node.val else 0)\\n        if left <= mid: \\n            self._set_range(node.left, left, right)\\n        if right > mid: \\n            self._set_range(node.right, left, right)\\n        node.val = node.left.val + node.right.val\\n        \\n    def add(self, left: int, right: int) -> None:\\n        self._set_range(self.root, left, right)\\n\\n    def count(self) -> int:\\n        return self.root.val\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    int lower, upper, val;\\n    Node left, right;\\n    public Node(int lower, int upper, int val) {\\n        this.lower = lower;\\n        this.upper = upper;\\n        this.val = val;\\n    }\\n}\\nclass CountIntervals {\\n    Node root;\\n    public CountIntervals() {\\n        root = new Node(0, 1000000000, 0);\\n    }\\n    \\n    private void setRange(Node node, int left, int right) {\\n        if (left <= node.lower && node.upper <= right) {\\n            node.val = node.upper - node.lower + 1;\\n            node.left = null;\\n            node.right = null;\\n            return;\\n        } \\n        int mid = (node.upper + node.lower) / 2;\\n        if (node.left == null && node.right == null) {\\n            node.left = new Node(node.lower, mid, node.val > 0 ? mid - node.lower + 1 : 0);\\n            node.right = new Node(mid + 1, node.upper, node.val > 0 ? node.upper - (mid + 1) + 1 : 0);\\n        }\\n        if (left <= mid) \\n            setRange(node.left, left, right);\\n        if (right > mid) \\n            setRange(node.right, left, right);\\n        node.val = node.left.val + node.right.val;\\n    }\\n    \\n    public void add(int left, int right) {\\n        setRange(root, left, right);\\n    }\\n    \\n    public int count() {\\n        return root.val;\\n    }\\n}\\n```\n```\\nclass Node:\\n    def __init__(self, lower, upper, val):\\n        self.lower = lower\\n        self.upper = upper\\n        self.left = None\\n        self.right = None\\n        self.val = val\\n        \\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.root = Node(0, 1000000000, 0)\\n\\n    def _set_range(self, node, left, right): \\n        # print(left, right, node.lower, node.upper)\\n        if left <= node.lower and node.upper <= right: \\n            node.val = node.upper - node.lower + 1\\n            node.left = node.right = None\\n            return \\n        mid = (node.upper + node.lower) // 2\\n        if not node.left and not node.right:\\n            node.left = Node(node.lower, mid, mid - node.lower + 1 if node.val else 0)\\n            node.right = Node(mid + 1, node.upper, node.upper - (mid + 1) + 1 if node.val else 0)\\n        if left <= mid: \\n            self._set_range(node.left, left, right)\\n        if right > mid: \\n            self._set_range(node.right, left, right)\\n        node.val = node.left.val + node.right.val\\n        \\n    def add(self, left: int, right: int) -> None:\\n        self._set_range(self.root, left, right)\\n\\n    def count(self) -> int:\\n        return self.root.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039727,
                "title": "java-treemap-merge-intervals-with-comments-and-similar-questions-for-reference",
                "content": "Pretty much the same as the [Data Stream as Disjoint Intervals](https://leetcode.com/problems/data-stream-as-disjoint-intervals/) and [Amount of New Area Painted Each Day](https://leetcode.com/problems/amount-of-new-area-painted-each-day/).\\nWe just need to maintain a tree map with non-overlapping intervals. When the new interval overlaps with any floor and ceilings, simply merge them and deduct the overlapping numbers (no need to add those numbers again).\\nIn the meantime, we just need to use a global variable to record the total numbers.\\n\\nMore details can be found in the comments.\\n\\n```\\nTreeMap<Integer, Integer> intervals;\\nint count;\\n\\npublic CountIntervals() {\\n    this.intervals = new TreeMap<>();\\n    this.count = 0;\\n}\\n\\npublic void add(int left, int right) {\\n\\t// start and end to record the merged interval\\n    int start = left;\\n    int end = right;\\n    int toAdd = end - start + 1;\\n\\n    Map.Entry<Integer, Integer> floor = intervals.floorEntry(left);\\n    if (floor != null) {\\n        if (floor.getValue() >= end) {\\n            // the entire current interval has been covered by the floor, so no new numbers need to add, simply just return.\\n            return;\\n        }\\n        if (floor.getValue() >= start) {\\n            // the current interval has been partially covered by the floor, so deduct the overlapping numbers.\\n            toAdd -= floor.getValue() - start + 1;\\n            intervals.remove(floor.getKey());\\n            start = floor.getKey();\\n        }\\n    }\\n\\n    Map.Entry<Integer, Integer> ceiling = intervals.ceilingEntry(left);\\n    // there could be multiple ceilings overlap with the current interval.\\n    // e.g. current [5, 20], ceilings: [6, 8], [10, 15], [18, 22]\\n    // we need to deduct the overlapping numbers properly\\n    while (ceiling != null && ceiling.getKey() <= end) {\\n        toAdd -= Math.min(end, ceiling.getValue()) - ceiling.getKey() + 1;\\n        intervals.remove(ceiling.getKey());\\n        end = Math.max(end, ceiling.getValue());\\n        ceiling = intervals.ceilingEntry(left);\\n    }\\n    \\n    // add the new numbers to the count/result.\\n    count += toAdd;\\n    // add the merged interval to treemap\\n    intervals.put(start, end);\\n}\\n\\npublic int count() {\\n    return count;\\n}\\n```\\n\\nMy previous post on the [Amount of New Area Painted Each Day](https://leetcode.com/problems/amount-of-new-area-painted-each-day/discuss/1784268/java-treemap-merge-intervals-easy-to-understand-beats-9583) which is essentially the same as this one.",
                "solutionTags": [
                    "Tree",
                    "Sorting"
                ],
                "code": "```\\nTreeMap<Integer, Integer> intervals;\\nint count;\\n\\npublic CountIntervals() {\\n    this.intervals = new TreeMap<>();\\n    this.count = 0;\\n}\\n\\npublic void add(int left, int right) {\\n\\t// start and end to record the merged interval\\n    int start = left;\\n    int end = right;\\n    int toAdd = end - start + 1;\\n\\n    Map.Entry<Integer, Integer> floor = intervals.floorEntry(left);\\n    if (floor != null) {\\n        if (floor.getValue() >= end) {\\n            // the entire current interval has been covered by the floor, so no new numbers need to add, simply just return.\\n            return;\\n        }\\n        if (floor.getValue() >= start) {\\n            // the current interval has been partially covered by the floor, so deduct the overlapping numbers.\\n            toAdd -= floor.getValue() - start + 1;\\n            intervals.remove(floor.getKey());\\n            start = floor.getKey();\\n        }\\n    }\\n\\n    Map.Entry<Integer, Integer> ceiling = intervals.ceilingEntry(left);\\n    // there could be multiple ceilings overlap with the current interval.\\n    // e.g. current [5, 20], ceilings: [6, 8], [10, 15], [18, 22]\\n    // we need to deduct the overlapping numbers properly\\n    while (ceiling != null && ceiling.getKey() <= end) {\\n        toAdd -= Math.min(end, ceiling.getValue()) - ceiling.getKey() + 1;\\n        intervals.remove(ceiling.getKey());\\n        end = Math.max(end, ceiling.getValue());\\n        ceiling = intervals.ceilingEntry(left);\\n    }\\n    \\n    // add the new numbers to the count/result.\\n    count += toAdd;\\n    // add the merged interval to treemap\\n    intervals.put(start, end);\\n}\\n\\npublic int count() {\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516057,
                "title": "dynamic-segment-tree-c-fully-commented-code",
                "content": "# Code\\n```\\nclass node{\\n    public:\\n    int val, lazy;\\n    node *left, *right;\\n    node() {\\n        val = 0, lazy = 0;\\n        left = right = NULL;\\n    }\\n};\\n\\nclass ST{\\n    public:\\n    node *root = new node();\\n\\n    node* getRoot() {\\n        return root;\\n    }\\n\\n    void update(node *root, int low, int high, int l, int r) {\\n        // non overlap -> low high l r, l r low high\\n        if(high < l || r < low)return;\\n\\n        if(!root->left) {\\n            root->left = new node();\\n            root->right = new node();\\n        }\\n\\n        //update current node and propagate laziness to the child nodes\\n        if(root->lazy) {\\n            root->val = high - low + 1;\\n            if(low != high) {\\n                root->left->lazy = 1;\\n                root->right->lazy = 1;\\n            }\\n            root->lazy = 0;\\n        }\\n\\n        // all ranges are covered then return \\n        if(root->val == high - low + 1)return;\\n\\n        // comp overlap -> l low high r\\n        // assign value (high-low+1) and propagate laziness to the child nodes \\n        if(low >= l && high <= r) {\\n            root->val = high - low + 1;\\n            if(low != high) {\\n                root->left->lazy = 1;\\n                root->right->lazy = 1;\\n            }\\n            root->lazy = 0;\\n            return;\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        update(root->left, low, mid, l, r);\\n        update(root->right, mid+1, high, l, r);\\n        // update node range from its child nodes\\' ranges\\n        root->val = root->left->val + root->right->val;\\n    }\\n};\\n\\nclass CountIntervals {\\npublic:\\n    ST obj;\\n    node *root = obj.getRoot();\\n\\n    CountIntervals() {\\n    }\\n    \\n    void add(int left, int right) {\\n        obj.update(root, 0, 1e9, left, right);\\n    }\\n    \\n    int count() {\\n        return root->val;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass node{\\n    public:\\n    int val, lazy;\\n    node *left, *right;\\n    node() {\\n        val = 0, lazy = 0;\\n        left = right = NULL;\\n    }\\n};\\n\\nclass ST{\\n    public:\\n    node *root = new node();\\n\\n    node* getRoot() {\\n        return root;\\n    }\\n\\n    void update(node *root, int low, int high, int l, int r) {\\n        // non overlap -> low high l r, l r low high\\n        if(high < l || r < low)return;\\n\\n        if(!root->left) {\\n            root->left = new node();\\n            root->right = new node();\\n        }\\n\\n        //update current node and propagate laziness to the child nodes\\n        if(root->lazy) {\\n            root->val = high - low + 1;\\n            if(low != high) {\\n                root->left->lazy = 1;\\n                root->right->lazy = 1;\\n            }\\n            root->lazy = 0;\\n        }\\n\\n        // all ranges are covered then return \\n        if(root->val == high - low + 1)return;\\n\\n        // comp overlap -> l low high r\\n        // assign value (high-low+1) and propagate laziness to the child nodes \\n        if(low >= l && high <= r) {\\n            root->val = high - low + 1;\\n            if(low != high) {\\n                root->left->lazy = 1;\\n                root->right->lazy = 1;\\n            }\\n            root->lazy = 0;\\n            return;\\n        }\\n\\n        int mid = low + (high - low) / 2;\\n        update(root->left, low, mid, l, r);\\n        update(root->right, mid+1, high, l, r);\\n        // update node range from its child nodes\\' ranges\\n        root->val = root->left->val + root->right->val;\\n    }\\n};\\n\\nclass CountIntervals {\\npublic:\\n    ST obj;\\n    node *root = obj.getRoot();\\n\\n    CountIntervals() {\\n    }\\n    \\n    void add(int left, int right) {\\n        obj.update(root, 0, 1e9, left, right);\\n    }\\n    \\n    int count() {\\n        return root->val;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045859,
                "title": "very-clean-short-c-std-set",
                "content": "In short, we use a set (Self-Balancing BST) to manage the sorted intervals and keep track of count as we go.\\nThe set will always contain DISJOINT, inclusive intervals.\\nWhen we add, we insert a new interval into the set, and try to merge in both directions as far as we can.\\n\\n`count()` is `O(1)`\\n\\n`add()` has amortized complexity `O(N log N)`\\nAlthough we may merge many intervals in a single call, once an interval has been merged, it\\'s no longer in the set anymore. Therefore, each call to `add()` may introduce at most 1 new interval, and may merge (and remove) as many as have been added so far. An easy way to think of it is: in the worst case, every interval gets added a maximum of one time, and removed a maximum of one time. In other words, the number of deletions is bounded by the number of insertions.\\n\\n\\n\\n```cpp\\n// https://leetcode.com/contest/weekly-contest-293/problems/count-integers-in-intervals/\\nusing iv = pair<int,int>;\\nusing IT = set<iv>::iterator;\\n\\nstruct CountIntervals {\\n    int cnt = 0;  // track the current count\\n    set<iv> ivals = { {-1,-1}, {INT_MAX,INT_MAX} };  // dummy values for edges\\n    \\n    template <class F>\\n    pair<IT,bool> merge(IT it, F dir) {         // -> {resulting IT, keep going?}\\n        auto [L,R] = *it;\\n        auto cmp = dir(it, 1);                  // dir is prev() or next()\\n        auto [x,y] = *cmp;\\n\\t\\tbool intersectL = (L <= x && x <= R);  \\n\\t\\tbool intersectR = (x <= L && L <= y);\\n        if (intersectL || intersectR) {         // if `cmp` overlaps with `it`\\n            cnt -= y-x+1;                       // remove contribution from cmp\\n            ivals.erase(cmp);                   // erase both\\n            ivals.erase(it); \\n            iv q = { min(x, L), max(y, R) };    // merge into new, big interval\\n            return ivals.insert(q);             // insert merged interval\\n        }\\n        return {it, false};  // otherwise, return it and indicate stop merging\\n    }\\n    void add(int L, int R) {\\n        auto [it, go] = ivals.insert( {L,R} );\\n        if (!go) return;\\n        do {  tie(it,go) = merge(it, prev<IT>);  } while (go);  // merge left\\n        do {  tie(it,go) = merge(it, next<IT>);  } while (go);  // merge right\\n        tie(L, R) = *it;\\n        cnt += R-L+1;\\n    }\\n    int count() { return cnt; }\\n};\\n```\\n___\\n___\\n---\\n\\nFor reference, `set::insert()` returns a `pair<Iterator, bool>` of `{insertedIT, succeeded}`.\\n\\n`tie(...) = ` is \"tuple assignment\" in C++. For example,\\n```cpp\\nint a=1, b=2, c=3;\\npair<int, int> p = {3,4};\\ntie(a,c) = p;\\nprintf(\"%d %d %d\\\\n\", a, b, c);  // prints \"3 2 4\"\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n// https://leetcode.com/contest/weekly-contest-293/problems/count-integers-in-intervals/\\nusing iv = pair<int,int>;\\nusing IT = set<iv>::iterator;\\n\\nstruct CountIntervals {\\n    int cnt = 0;  // track the current count\\n    set<iv> ivals = { {-1,-1}, {INT_MAX,INT_MAX} };  // dummy values for edges\\n    \\n    template <class F>\\n    pair<IT,bool> merge(IT it, F dir) {         // -> {resulting IT, keep going?}\\n        auto [L,R] = *it;\\n        auto cmp = dir(it, 1);                  // dir is prev() or next()\\n        auto [x,y] = *cmp;\\n\\t\\tbool intersectL = (L <= x && x <= R);  \\n\\t\\tbool intersectR = (x <= L && L <= y);\\n        if (intersectL || intersectR) {         // if `cmp` overlaps with `it`\\n            cnt -= y-x+1;                       // remove contribution from cmp\\n            ivals.erase(cmp);                   // erase both\\n            ivals.erase(it); \\n            iv q = { min(x, L), max(y, R) };    // merge into new, big interval\\n            return ivals.insert(q);             // insert merged interval\\n        }\\n        return {it, false};  // otherwise, return it and indicate stop merging\\n    }\\n    void add(int L, int R) {\\n        auto [it, go] = ivals.insert( {L,R} );\\n        if (!go) return;\\n        do {  tie(it,go) = merge(it, prev<IT>);  } while (go);  // merge left\\n        do {  tie(it,go) = merge(it, next<IT>);  } while (go);  // merge right\\n        tie(L, R) = *it;\\n        cnt += R-L+1;\\n    }\\n    int count() { return cnt; }\\n};\\n```\n```cpp\\nint a=1, b=2, c=3;\\npair<int, int> p = {3,4};\\ntie(a,c) = p;\\nprintf(\"%d %d %d\\\\n\", a, b, c);  // prints \"3 2 4\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040236,
                "title": "python-binary-search",
                "content": "**Approach**\\n1. If there is no intervals yet, just add it and keep track of the count. Otherwise:\\n2. Search through intervals for where left of the new interval is less than the end of any interval.\\n3. Search through intervals for where right of the new interval is greater than the start of any interval.\\n4. If our found left index is inside an interval, take the minimum of it and the interval.\\n5. If our found right index is inside of an interval, take hte maximum of it and the interval.\\n6. Otherwise [left, right] will be inserted into the list. \\n7. Keep track of counts as we go, we\\'re going to add to counts the amount of the new interval\\n8. We\\'re going to remove from counts all intervals between our left index and right index. If we\\'re just inserting, the space between left index and right index will be 0. So we\\'ll only be adding.\\n\\n**Other Considerations**\\nIn the competition two things caused my time limit exceeded:\\n1. Not keeping track of counts and walking it instead. One of the test cases is, add add add... for 50+ iterations followed by count count count... for 100+ iterations. So if you have to walk count each time, you\\'ll TLE.\\n2. Even with that, updating the interval list afterwards with array slicing. This is confusing for me.\\n\\nHad to look at yag313\\'s solution to see array slice + assignment which is much much faster. I think python does extra memory allocation and will add two arrays together followed by another addition of the third array in my naive attempt.\\n\\n***Would love a detailed explanation from anyone on what the time complexity between the two lines are please.***\\n\\n```\\nimport bisect\\nfrom operator import itemgetter\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.cur_count = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        if not self.intervals:\\n            self.intervals.append([left, right])\\n            self.cur_count = right - left + 1\\n            return\\n\\n        l = bisect.bisect_left(self.intervals, left, key=itemgetter(1))\\n        r = bisect.bisect_right(self.intervals, right, key=itemgetter(0))\\n        \\n        if l < len(self.intervals):\\n            left = min(left, self.intervals[l][0])\\n            \\n        if r > 0:\\n            right = max(right, self.intervals[r-1][1])\\n        \\n        to_add = right - left + 1\\n        \\n        to_remove = 0\\n        for i in range(l, r):\\n            to_remove += self.intervals[i][1] - self.intervals[i][0] + 1\\n            \\n        self.cur_count += to_add - to_remove\\n        \\n        # TOO SLOW!!\\n        # 15 seconds!!\\n        # self.intervals = self.intervals[:l] + [[left, right]] + self.intervals[r:]\\n        \\n        # 1.3 - 1.6 seconds\\n        self.intervals[l:r] = [[left, right]]\\n\\n    def count(self) -> int:\\n        return self.cur_count\\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nfrom operator import itemgetter\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.cur_count = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        if not self.intervals:\\n            self.intervals.append([left, right])\\n            self.cur_count = right - left + 1\\n            return\\n\\n        l = bisect.bisect_left(self.intervals, left, key=itemgetter(1))\\n        r = bisect.bisect_right(self.intervals, right, key=itemgetter(0))\\n        \\n        if l < len(self.intervals):\\n            left = min(left, self.intervals[l][0])\\n            \\n        if r > 0:\\n            right = max(right, self.intervals[r-1][1])\\n        \\n        to_add = right - left + 1\\n        \\n        to_remove = 0\\n        for i in range(l, r):\\n            to_remove += self.intervals[i][1] - self.intervals[i][0] + 1\\n            \\n        self.cur_count += to_add - to_remove\\n        \\n        # TOO SLOW!!\\n        # 15 seconds!!\\n        # self.intervals = self.intervals[:l] + [[left, right]] + self.intervals[r:]\\n        \\n        # 1.3 - 1.6 seconds\\n        self.intervals[l:r] = [[left, right]]\\n\\n    def count(self) -> int:\\n        return self.cur_count\\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041626,
                "title": "c-merge-interval-line-sweep-dynamic-segment-tree-solution",
                "content": "**Merge Interval Solution:**\\n\\nRuntime: 734 ms, faster than 100.00% of C++ online submissions for Count Integers in Intervals.\\nMemory Usage: 186.2 MB, less than 83.33% of C++ online submissions for Count Integers in Intervals.\\n\\n\\n```\\nMerge intervals in the range start to end in Map and update total count.\\nStore updated start and end pair in BST Map.\\n```\\n\\n\\n```\\nclass CountIntervals {\\npublic:\\n    \\n    // store intervals in start and end pair\\n    map<int,int>track;\\n    int total;\\n    \\n    CountIntervals() \\n    {\\n        total = 0;\\n    }\\n\\n    void add(int left, int right) {\\n\\n        // get upper bound of the left\\n        auto iter = track.upper_bound(left);\\n        \\n        int minRange = left;\\n        int maxRange = right;\\n        \\n        // if not first element then check previous element\\n        if(iter!=track.begin())\\n        {\\n            auto piter = prev(iter);\\n            \\n            // if previous interval overlaps with current interval deduct count and merge range\\n            if(piter->second >= left)\\n            {\\n                minRange = min(minRange,piter->first);\\n                maxRange = max(maxRange,piter->second);\\n                total -= (piter->second-piter->first+1);\\n                \\n                // delete overlapped interval\\n                track.erase(piter);\\n            }\\n        }\\n        \\n        // loop until current interval overlaps with Map intervals\\n        while(iter!=track.end() && iter->first<=right)\\n        {\\n            maxRange = max(maxRange,iter->second);\\n            total -= (iter->second-iter->first+1);\\n            \\n            // delete overlapped interval\\n            track.erase(iter++);\\n        }\\n        \\n        // update total count with merged range\\n        total += maxRange - minRange + 1;\\n        \\n        // store updated range in Map\\n        track[minRange] = maxRange;\\n    }\\n\\n    int count() {\\n\\n        return total;\\n    }\\n};\\n```\\n\\n\\n**Line Sweep Solution:**\\n\\nRuntime: 819 ms, faster than 83.33% of C++ online submissions for Count Integers in Intervals.\\nMemory Usage: 205.2 MB, less than 83.33% of C++ online submissions for Count Integers in Intervals.\\n\\n```\\nMerge Intervals using Line Sweep in count API call if BST is modified.\\nUpdate previous BST with modified BST.\\nMark start as +1 and end+1 as -1 in BST in add API call.\\n```\\n\\n```\\nclass CountIntervals {\\npublic:\\n\\n    // BST to track the start and end of intervals\\n    map<int,int>track;\\n    int total;\\n    bool modified;\\n    \\n    CountIntervals() {\\n        total = 0;\\n        modified = false;\\n    }\\n\\n    void add(int left, int right) {\\n\\n        // mark start as +1 and end+1 as -1 \\n        track[left]++;\\n        track[right+1]--;\\n        \\n        // mark BST as modified\\n        modified = true;\\n    }\\n\\n    int count() {\\n\\n        // perform line sweep if BST modified\\n        if(modified)\\n        {\\n            total = 0;\\n            int curr = 0;\\n            int start;\\n            \\n            // store merged start and end in new BST\\n            map<int,int>mtrack;\\n            \\n            for(const auto &iter : track)\\n            {\\n                // start of interval\\n                if(curr==0)start = iter.first;\\n                \\n                curr+= iter.second;                \\n                \\n                // end of interval\\n                if(curr==0)\\n                {\\n                    // update merged start and end in new BST\\n                    mtrack[start]++;\\n                    mtrack[iter.first]--;\\n                    \\n                    // interval length\\n                    total+= iter.first - start;\\n                }                \\n            }\\n            \\n            // store merged intervals of new BST\\n            track = mtrack;\\n        }\\n        \\n        modified = false;\\n        return total;\\n    }\\n};\\n\\n```\\n\\n\\n**Dynamic Segment Tree Solution:**\\n\\nRuntime: 1262 ms, faster than 16.67% of C++ online submissions for Count Integers in Intervals.\\nMemory Usage: 609.3 MB, less than 33.33% of C++ online submissions for Count Integers in Intervals.\\n\\n\\n```\\n1. Update ranges in dynamic segment tree and update ranges covered for node from child nodes\\n2. Early return for non overlap case\\n3. Early return for node covered total range\\n4. Lazy propagate node cover to child nodes\\n5. Return root node range cover count when count API is called\\n```\\n\\n```\\nclass SegmentTree\\n{\\npublic:\\n    struct Node\\n    {\\n        Node* left;\\n        Node* right;\\n        int val;\\n        bool lazy;\\n    };\\n\\n    Node* root;\\n    int LIMIT = 1000000001;\\n\\n    Node* getNode()\\n    {\\n        Node* node = new Node();\\n        node->left = NULL;\\n        node->right = NULL;\\n        node->val = 0;\\n        node->lazy = false;\\n\\n        return node;\\n    }\\n\\n    SegmentTree()\\n    {\\n        root = getNode();\\n    }\\n\\n    int getTotal()\\n    {\\n        return root->val;\\n    }\\n    \\n    void update(Node* node, int lower, int upper, int& left, int& right)\\n    {\\n        // return for non-overlap case\\n        if (lower > right || upper < left) return;\\n        \\n        if (lower != upper)\\n        {\\n            if (!node->left)node->left = getNode();\\n            if (!node->right)node->right = getNode();\\n        }\\n\\n        // propagate lazy value to child nodes and update current value with lazy value\\n        if (node->lazy)\\n        {\\n            node->val = upper-lower+1;  // total range\\n            if (lower != upper)\\n            {\\n                node->left->lazy = node->lazy;\\n                node->right->lazy = node->lazy;\\n            }\\n            node->lazy = false;\\n        }\\n\\n        // all ranges are covered then return \\n        if(node->val == upper-lower+1) return;\\n        \\n        // update value with total range in case of full-overlap and propagate lazy value to child nodes \\n        if (lower >= left && upper <= right)\\n        {\\n            node->val = upper - lower + 1;  // total range\\n            if (lower != upper)\\n            {\\n                node->left->lazy = true;\\n                node->right->lazy = true;\\n            }\\n\\n            node->lazy = false;\\n            return;\\n        }\\n\\n        int mid = lower + (upper - lower) / 2;\\n\\n        update(node->left, lower, mid, left, right);\\n        update(node->right, mid + 1, upper, left, right);\\n\\n        // update node range from child node ranges\\n        node->val = node->left->val + node->right->val;\\n    }\\n\\n    void updateVal(int left, int right)\\n    {\\n        update(root, 1, LIMIT, left, right);\\n    }\\n};\\n\\nclass CountIntervals {\\npublic:\\n    \\n    SegmentTree tree;\\n    CountIntervals() {}\\n\\n    void add(int left, int right) {\\n\\n        // update range from left to right in Segment tree\\n        tree.updateVal(left,right);\\n    }\\n\\n    int count() {\\n\\n        // return total ranges covered by root node\\n        return tree.getTotal();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Counting"
                ],
                "code": "```\\nMerge intervals in the range start to end in Map and update total count.\\nStore updated start and end pair in BST Map.\\n```\n```\\nclass CountIntervals {\\npublic:\\n    \\n    // store intervals in start and end pair\\n    map<int,int>track;\\n    int total;\\n    \\n    CountIntervals() \\n    {\\n        total = 0;\\n    }\\n\\n    void add(int left, int right) {\\n\\n        // get upper bound of the left\\n        auto iter = track.upper_bound(left);\\n        \\n        int minRange = left;\\n        int maxRange = right;\\n        \\n        // if not first element then check previous element\\n        if(iter!=track.begin())\\n        {\\n            auto piter = prev(iter);\\n            \\n            // if previous interval overlaps with current interval deduct count and merge range\\n            if(piter->second >= left)\\n            {\\n                minRange = min(minRange,piter->first);\\n                maxRange = max(maxRange,piter->second);\\n                total -= (piter->second-piter->first+1);\\n                \\n                // delete overlapped interval\\n                track.erase(piter);\\n            }\\n        }\\n        \\n        // loop until current interval overlaps with Map intervals\\n        while(iter!=track.end() && iter->first<=right)\\n        {\\n            maxRange = max(maxRange,iter->second);\\n            total -= (iter->second-iter->first+1);\\n            \\n            // delete overlapped interval\\n            track.erase(iter++);\\n        }\\n        \\n        // update total count with merged range\\n        total += maxRange - minRange + 1;\\n        \\n        // store updated range in Map\\n        track[minRange] = maxRange;\\n    }\\n\\n    int count() {\\n\\n        return total;\\n    }\\n};\\n```\n```\\nMerge Intervals using Line Sweep in count API call if BST is modified.\\nUpdate previous BST with modified BST.\\nMark start as +1 and end+1 as -1 in BST in add API call.\\n```\n```\\nclass CountIntervals {\\npublic:\\n\\n    // BST to track the start and end of intervals\\n    map<int,int>track;\\n    int total;\\n    bool modified;\\n    \\n    CountIntervals() {\\n        total = 0;\\n        modified = false;\\n    }\\n\\n    void add(int left, int right) {\\n\\n        // mark start as +1 and end+1 as -1 \\n        track[left]++;\\n        track[right+1]--;\\n        \\n        // mark BST as modified\\n        modified = true;\\n    }\\n\\n    int count() {\\n\\n        // perform line sweep if BST modified\\n        if(modified)\\n        {\\n            total = 0;\\n            int curr = 0;\\n            int start;\\n            \\n            // store merged start and end in new BST\\n            map<int,int>mtrack;\\n            \\n            for(const auto &iter : track)\\n            {\\n                // start of interval\\n                if(curr==0)start = iter.first;\\n                \\n                curr+= iter.second;                \\n                \\n                // end of interval\\n                if(curr==0)\\n                {\\n                    // update merged start and end in new BST\\n                    mtrack[start]++;\\n                    mtrack[iter.first]--;\\n                    \\n                    // interval length\\n                    total+= iter.first - start;\\n                }                \\n            }\\n            \\n            // store merged intervals of new BST\\n            track = mtrack;\\n        }\\n        \\n        modified = false;\\n        return total;\\n    }\\n};\\n\\n```\n```\\n1. Update ranges in dynamic segment tree and update ranges covered for node from child nodes\\n2. Early return for non overlap case\\n3. Early return for node covered total range\\n4. Lazy propagate node cover to child nodes\\n5. Return root node range cover count when count API is called\\n```\n```\\nclass SegmentTree\\n{\\npublic:\\n    struct Node\\n    {\\n        Node* left;\\n        Node* right;\\n        int val;\\n        bool lazy;\\n    };\\n\\n    Node* root;\\n    int LIMIT = 1000000001;\\n\\n    Node* getNode()\\n    {\\n        Node* node = new Node();\\n        node->left = NULL;\\n        node->right = NULL;\\n        node->val = 0;\\n        node->lazy = false;\\n\\n        return node;\\n    }\\n\\n    SegmentTree()\\n    {\\n        root = getNode();\\n    }\\n\\n    int getTotal()\\n    {\\n        return root->val;\\n    }\\n    \\n    void update(Node* node, int lower, int upper, int& left, int& right)\\n    {\\n        // return for non-overlap case\\n        if (lower > right || upper < left) return;\\n        \\n        if (lower != upper)\\n        {\\n            if (!node->left)node->left = getNode();\\n            if (!node->right)node->right = getNode();\\n        }\\n\\n        // propagate lazy value to child nodes and update current value with lazy value\\n        if (node->lazy)\\n        {\\n            node->val = upper-lower+1;  // total range\\n            if (lower != upper)\\n            {\\n                node->left->lazy = node->lazy;\\n                node->right->lazy = node->lazy;\\n            }\\n            node->lazy = false;\\n        }\\n\\n        // all ranges are covered then return \\n        if(node->val == upper-lower+1) return;\\n        \\n        // update value with total range in case of full-overlap and propagate lazy value to child nodes \\n        if (lower >= left && upper <= right)\\n        {\\n            node->val = upper - lower + 1;  // total range\\n            if (lower != upper)\\n            {\\n                node->left->lazy = true;\\n                node->right->lazy = true;\\n            }\\n\\n            node->lazy = false;\\n            return;\\n        }\\n\\n        int mid = lower + (upper - lower) / 2;\\n\\n        update(node->left, lower, mid, left, right);\\n        update(node->right, mid + 1, upper, left, right);\\n\\n        // update node range from child node ranges\\n        node->val = node->left->val + node->right->val;\\n    }\\n\\n    void updateVal(int left, int right)\\n    {\\n        update(root, 1, LIMIT, left, right);\\n    }\\n};\\n\\nclass CountIntervals {\\npublic:\\n    \\n    SegmentTree tree;\\n    CountIntervals() {}\\n\\n    void add(int left, int right) {\\n\\n        // update range from left to right in Segment tree\\n        tree.updateVal(left,right);\\n    }\\n\\n    int count() {\\n\\n        // return total ranges covered by root node\\n        return tree.getTotal();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039888,
                "title": "c-using-segment-tree",
                "content": "```c++\\nstruct Node {\\n    int left_, right_, cnt_;\\n    Node *lc_, *rc_;\\n    \\n    Node (int left, int right, int cnt = 0) {\\n        left_ = left;\\n        right_ = right;\\n        cnt_ = cnt;\\n        lc_ = NULL;\\n        rc_ = NULL;\\n    }\\n    \\n    int cnt() {\\n        return cnt_;\\n    }\\n    \\n    int size() {\\n        return right_ - left_ + 1;\\n    }\\n    \\n    int mid() {\\n        return (left_ + right_) >> 1;\\n    }\\n    \\n    Node *lc() {\\n        if (lc_ == NULL) {\\n            lc_ = new Node(left_, mid());\\n        }\\n        return lc_;\\n    }\\n    \\n    Node *rc() {\\n        if (rc_ == NULL) {\\n            rc_ = new Node(mid() + 1, right_);\\n        }\\n        return rc_;\\n    }\\n    \\n    void insert(int left, int right) {\\n        if (size() == cnt()) {\\n            return;\\n        }\\n        if (left <= left_ && right >= right_) {\\n            cnt_ = size();\\n            return;\\n        }\\n        if (left <= mid()) {\\n            lc()->insert(left, min(mid(), right));\\n        }\\n        if (right > mid()) {\\n            rc()->insert(max(mid() + 1, left), right);\\n        }\\n        cnt_ = 0;\\n        if (lc_ != NULL) {\\n            cnt_ += lc_->cnt();\\n        }\\n        if (rc_ != NULL) {\\n            cnt_ += rc_->cnt();\\n        }\\n    }\\n};\\n\\nclass CountIntervals {\\nprivate:\\n    Node *root;\\n    \\npublic:\\n    CountIntervals() {\\n        root = new Node(1, 1E9);\\n    }\\n    \\n    void add(int left, int right) {\\n        root->insert(left, right);\\n    }\\n    \\n    int count() {\\n        return root->cnt();\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```c++\\nstruct Node {\\n    int left_, right_, cnt_;\\n    Node *lc_, *rc_;\\n    \\n    Node (int left, int right, int cnt = 0) {\\n        left_ = left;\\n        right_ = right;\\n        cnt_ = cnt;\\n        lc_ = NULL;\\n        rc_ = NULL;\\n    }\\n    \\n    int cnt() {\\n        return cnt_;\\n    }\\n    \\n    int size() {\\n        return right_ - left_ + 1;\\n    }\\n    \\n    int mid() {\\n        return (left_ + right_) >> 1;\\n    }\\n    \\n    Node *lc() {\\n        if (lc_ == NULL) {\\n            lc_ = new Node(left_, mid());\\n        }\\n        return lc_;\\n    }\\n    \\n    Node *rc() {\\n        if (rc_ == NULL) {\\n            rc_ = new Node(mid() + 1, right_);\\n        }\\n        return rc_;\\n    }\\n    \\n    void insert(int left, int right) {\\n        if (size() == cnt()) {\\n            return;\\n        }\\n        if (left <= left_ && right >= right_) {\\n            cnt_ = size();\\n            return;\\n        }\\n        if (left <= mid()) {\\n            lc()->insert(left, min(mid(), right));\\n        }\\n        if (right > mid()) {\\n            rc()->insert(max(mid() + 1, left), right);\\n        }\\n        cnt_ = 0;\\n        if (lc_ != NULL) {\\n            cnt_ += lc_->cnt();\\n        }\\n        if (rc_ != NULL) {\\n            cnt_ += rc_->cnt();\\n        }\\n    }\\n};\\n\\nclass CountIntervals {\\nprivate:\\n    Node *root;\\n    \\npublic:\\n    CountIntervals() {\\n        root = new Node(1, 1E9);\\n    }\\n    \\n    void add(int left, int right) {\\n        root->insert(left, right);\\n    }\\n    \\n    int count() {\\n        return root->cnt();\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039785,
                "title": "python3-sorted-list-merge-intervals-in-stream-fb-follow-up-for-56",
                "content": "Directly modified from my another post of solution: https://leetcode.com/problems/merge-intervals/discuss/1889983/python-binary-search-solution-for-fb-follow-up-merge-in-stream\\n\\n#### Original idea\\nThis is the idea when I tried to come up with the solution for the follow-up question of 56 with out BST:\\n\\nThe basic idea of the solution is, when we merge intervals we are placing the points on a line segment. Let\\'s denote start points as 0 and endpoints as 1 for separating different points, then we could get a representation. For instance, merged intervals: [1, 4], [7, 9], we could denote as\\n[1,0], [4, 1], [7, 0], [9, 1]\\n\\nThen every time we have a new start and end, we could insert [st, 0], [ed, 1] to this list.\\n\\nThere are 2 key observations for this representations:\\n\\n1. we should not get 2 continous start or 2 continous end.\\nFor instance, if after insert we get sth. like [1,0], [2, 0], [3, 1], [4,1], we know a merge should happens.\\n\\n2. If it is an insertion that will not trigger any merges, we could know that the place we insert start and end should differ only by 1.\\nFor instance, we already have [1,0], [4,1] denotes the merged interval [1, 4] and we want to insert [5, 6] , we will get the index to insert is 2 and 3 which differs by 1\\n\\nBased on 1 and 2, let\\'s denote the place to insert [st, 0] is idx1 and [ed, 1] is idx2, then:\\n\\n1. if idx2 - idx1 != 1, we know the elements between should be removed\\n2. If we encounter invalid situation #1, we set idx1 = idx1 - 1 or idx2 = idx2 + 1 for further checks\\n\\n\\n#### Update specified for this problem\\nTo further modify for this question, we need to maintain a count variable and update it when new intervals come.\\n\\nWe added the number of [st, ed] for all new intervals to be added, and then remove the duplicates when we pop out the intervals that should cause duplicate additions.\\n\\n```Python\\nfrom sortedcontainers import SortedList\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.sorted_list = SortedList()\\n        self.num = 0\\n\\n    def add(self, st: int, ed: int) -> None:\\n        self.sorted_list.add([st, 0])\\n        self.sorted_list.add([ed, 1])\\n        \\n        self.num += ed - st + 1\\n        # print(self.sorted_list)\\n        \\n        idx1 = self.sorted_list.index([st, 0])\\n        idx2 = self.sorted_list.index([ed, 1])\\n        \\n     \\n        if idx1 - 1 >= 0 and self.sorted_list[idx1 - 1][1] == 0:\\n            idx1 -= 1\\n        if idx2 + 1 < len(self.sorted_list) and self.sorted_list[idx2 + 1][1] == 1:\\n            idx2 += 1\\n        \\n        if idx2 - idx1 != 1:\\n            j = idx1 + 1\\n            for _ in range(idx1 + 1, idx2):\\n                if self.sorted_list[j][1] == 0: # encounter a start point need to be remove\\n                    self.num -= (self.sorted_list[j + 1][0] - self.sorted_list[j][0] + 1) # so we need to decrease the duplicated addition to the total number\\n                self.sorted_list.pop(j)\\n\\n    def count(self) -> int: # O(1)\\n        return self.num\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nfrom sortedcontainers import SortedList\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.sorted_list = SortedList()\\n        self.num = 0\\n\\n    def add(self, st: int, ed: int) -> None:\\n        self.sorted_list.add([st, 0])\\n        self.sorted_list.add([ed, 1])\\n        \\n        self.num += ed - st + 1\\n        # print(self.sorted_list)\\n        \\n        idx1 = self.sorted_list.index([st, 0])\\n        idx2 = self.sorted_list.index([ed, 1])\\n        \\n     \\n        if idx1 - 1 >= 0 and self.sorted_list[idx1 - 1][1] == 0:\\n            idx1 -= 1\\n        if idx2 + 1 < len(self.sorted_list) and self.sorted_list[idx2 + 1][1] == 1:\\n            idx2 += 1\\n        \\n        if idx2 - idx1 != 1:\\n            j = idx1 + 1\\n            for _ in range(idx1 + 1, idx2):\\n                if self.sorted_list[j][1] == 0: # encounter a start point need to be remove\\n                    self.num -= (self.sorted_list[j + 1][0] - self.sorted_list[j][0] + 1) # so we need to decrease the duplicated addition to the total number\\n                self.sorted_list.pop(j)\\n\\n    def count(self) -> int: # O(1)\\n        return self.num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042728,
                "title": "simple-easy-solution-with-comments",
                "content": "```\\nclass CountIntervals {\\n    \\n    //for storing intervals\\n    TreeMap<Integer,Integer> map=new TreeMap<>();\\n    int count=0;\\n    public CountIntervals() {\\n    }\\n    \\n    public void add(int left, int right) {\\n        //we are taking left side as reference and calculating ans\\n        \\n        //this is the current length\\n        int add=right-left+1;\\n        \\n        //var is the default data type\\n        //lowerentry gives the value of smaller(smaller largest) entry compared to (left+1)\\n        //we added +1 bcz there may be a case where left is present in a map\\n        //lowerentry gives the  value(that is)<left+1\\n        var left_bound = map.lowerEntry(left + 1);\\n        \\n        \\n        //if there is some value present then go\\n        //getvalue gives the right positon\\n        //if current left is cover under map.right value means there is a overlap\\n        if(left_bound!=null && left_bound.getValue()>=left){\\n            //positions are map.left <= left <= min(map.right,right) <= max(map.right,right)\\n            \\n//examples:   (1)                       (2)                     (3)\\n//       ____________                 _________            _______________     (map)\\n//                ___________                  ________           ____         (our)\\n            \\n            //now, left become the smallest value which in this case is map.left\\n            left=left_bound.getKey();\\n            \\n            //same as right become the maximum value\\n            right=Math.max(left_bound.getValue(),right);\\n            \\n            //value overlap means curr answer(add) also change\\n            //we already calculated the map value (covered area) and added into ans variable\\n            //calculate/add the new uncovered value\\n            //    right            - map.right\\n            //max(right,map.right) - map.right\\n            //we are not adding +1 bcz that is already handled by overlaping area\\n            add=right-left_bound.getValue();\\n            \\n            //this is taken so we have to remove\\n            //at last we added the largest area (which is stored int left,right)\\n            map.remove(left_bound.getKey());\\n        }\\n        \\n        //check is right overlaping\\n        //if yes then take the correct values\\n        //higherEntry gives the largest(largest smallest) value in map\\n        //we are not taking left+1 bcz that condition is already been satisfied\\n        //eg. left=5 map contains (5,value)\\n        //condition is checked in left_bound\\n        //i.getKey()<=right means curr is beneath our map.left and covering area(overlaping)\\n        for(var i=map.higherEntry(left); i!=null && i.getKey()<=right; i=map.higherEntry(left)){\\n            //left <= map.left <= min(right,map.right) <= max(right,map.right)\\n            \\n            \\n//examples:   (1)                       (2)                         (3)\\n//            ____________                _________              _______             (map)\\n//     ___________                ________                 _________________         (our)\\n            \\n            \\n            //now we have our add which is current ans but some area is overlaping\\n            //so we have to subtract overlaping area\\n            //+1 bcz [2,5] we have 4 position (2,3,4,5) ; 5-2=>3 ; we ned to add 1\\n            add-=Math.min(right,i.getValue())-i.getKey()+1;\\n            \\n            //right value become the largest among them\\n            right=Math.max(right,i.getValue());\\n            \\n            //we have taken care this entry and calculated left and right now we don\\'t need\\n            map.remove(i.getKey());\\n        }\\n        \\n        //we pushed the values\\n        //this entry can be essential for next calls\\n        map.put(left,right);\\n        \\n        //add the current ans\\n        count+=add;\\n        \\n        \\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```\\n\\nCredits: @votrubac",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass CountIntervals {\\n    \\n    //for storing intervals\\n    TreeMap<Integer,Integer> map=new TreeMap<>();\\n    int count=0;\\n    public CountIntervals() {\\n    }\\n    \\n    public void add(int left, int right) {\\n        //we are taking left side as reference and calculating ans\\n        \\n        //this is the current length\\n        int add=right-left+1;\\n        \\n        //var is the default data type\\n        //lowerentry gives the value of smaller(smaller largest) entry compared to (left+1)\\n        //we added +1 bcz there may be a case where left is present in a map\\n        //lowerentry gives the  value(that is)<left+1\\n        var left_bound = map.lowerEntry(left + 1);\\n        \\n        \\n        //if there is some value present then go\\n        //getvalue gives the right positon\\n        //if current left is cover under map.right value means there is a overlap\\n        if(left_bound!=null && left_bound.getValue()>=left){\\n            //positions are map.left <= left <= min(map.right,right) <= max(map.right,right)\\n            \\n//examples:   (1)                       (2)                     (3)\\n//       ____________                 _________            _______________     (map)\\n//                ___________                  ________           ____         (our)\\n            \\n            //now, left become the smallest value which in this case is map.left\\n            left=left_bound.getKey();\\n            \\n            //same as right become the maximum value\\n            right=Math.max(left_bound.getValue(),right);\\n            \\n            //value overlap means curr answer(add) also change\\n            //we already calculated the map value (covered area) and added into ans variable\\n            //calculate/add the new uncovered value\\n            //    right            - map.right\\n            //max(right,map.right) - map.right\\n            //we are not adding +1 bcz that is already handled by overlaping area\\n            add=right-left_bound.getValue();\\n            \\n            //this is taken so we have to remove\\n            //at last we added the largest area (which is stored int left,right)\\n            map.remove(left_bound.getKey());\\n        }\\n        \\n        //check is right overlaping\\n        //if yes then take the correct values\\n        //higherEntry gives the largest(largest smallest) value in map\\n        //we are not taking left+1 bcz that condition is already been satisfied\\n        //eg. left=5 map contains (5,value)\\n        //condition is checked in left_bound\\n        //i.getKey()<=right means curr is beneath our map.left and covering area(overlaping)\\n        for(var i=map.higherEntry(left); i!=null && i.getKey()<=right; i=map.higherEntry(left)){\\n            //left <= map.left <= min(right,map.right) <= max(right,map.right)\\n            \\n            \\n//examples:   (1)                       (2)                         (3)\\n//            ____________                _________              _______             (map)\\n//     ___________                ________                 _________________         (our)\\n            \\n            \\n            //now we have our add which is current ans but some area is overlaping\\n            //so we have to subtract overlaping area\\n            //+1 bcz [2,5] we have 4 position (2,3,4,5) ; 5-2=>3 ; we ned to add 1\\n            add-=Math.min(right,i.getValue())-i.getKey()+1;\\n            \\n            //right value become the largest among them\\n            right=Math.max(right,i.getValue());\\n            \\n            //we have taken care this entry and calculated left and right now we don\\'t need\\n            map.remove(i.getKey());\\n        }\\n        \\n        //we pushed the values\\n        //this entry can be essential for next calls\\n        map.put(left,right);\\n        \\n        //add the current ans\\n        count+=add;\\n        \\n        \\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040452,
                "title": "java-clean-treemap-with-explanations-o-log-n-time",
                "content": "### Idea\\nIn `add()` function, use merge intervals approach and update the counter.\\nIn this way, the `count()` function is `O(1)`\\n\\nTo merge intervals, we need to (1) search overlap intervals, (2) delete overlap intervals, and (3) add new interval.\\n\\nTherefore, **tree map** will be a good data structure here,\\nbecause it (1) has sorted elements (2) can add/remove element in O(log n)\\n\\n### Steps of add()\\n\\n**Case 1: if no overlap**\\n- just update the count, and add the interval to map\\n\\n**Case 2: overlap**\\n1. define `new` as new interval(start, end)\\n2. find the overlap interval (which is the right-most interval `cur` from map where `cur.end >= new.start`\\n3. do merge:\\n    count -= the count of interval `cur` \\n\\tremove interval `cur` from map\\n    update the start, end of the internval `new`\\n4. repeat 2-3 until there is no interval satisfy `cur.end >= new.start`\\n5. count += the count of interval `new`\\n6. add interval `new` to map\\n\\n### Solution v1\\n```java\\n// key, value => left, right\\nTreeMap<Integer, Integer> m;\\nint count = 0;\\n\\npublic CountIntervals() {\\n    m = new TreeMap<>();\\n}\\n\\npublic void add(int left, int right) {\\n    if (m.floorKey(right) != null && m.get(m.floorKey(right)) < left) {\\n        count += right - left + 1;\\n        m.put(left, right);\\n    } else {\\n        int start = left, end = right;\\n        while (m.floorKey(end) != null && m.get(m.floorKey(end)) >= left) {\\n            int l = m.floorKey(end);\\n            int r = m.get(l);\\n            count -= r - l + 1;\\n            m.remove(l);\\n\\n            start = Math.min(start, l);\\n            end = Math.max(end, r);\\n        }\\n        count += end - start + 1;\\n        m.put(start, end);\\n    }\\n}\\n\\npublic int count() {\\n    return count;\\n}\\n```\\n\\n### Solution v2\\nFor the case 1 & 2, they share the same logic. case 1 is redundant.\\nTherefore, the `add()` could be improved to this:\\n```java\\npublic void add(int left, int right) {\\n\\tint start = left, end = right;\\n\\twhile (m.floorKey(end) != null && m.get(m.floorKey(end)) >= left) {\\n\\t\\tint l = m.floorKey(end);\\n\\t\\tint r = m.get(l);\\n\\t\\tcount -= r - l + 1;\\n\\t\\tm.remove(l);\\n\\n\\t\\tstart = Math.min(start, l);\\n\\t\\tend = Math.max(end, r);\\n\\t}\\n\\tcount += end - start + 1;\\n\\tm.put(start, end);\\n}\\n```\\n\\n### Time complexity - Add(): `O(logn)`\\nGiven there is `n` add operation. \\nEach key in tree map is removed and added at most 1 respectively.\\nThe time taken for `n` add() is `O(nlogn)`\\nTherefore, the average time complexity for add() is `O(logn)`\\n\\n\\n### Space complexity: `O(n)`\\nThe max size of tree map is `n`\\nTherefore, space = `O(n)`\\n\\n-------\\nThe solution is based on [[Java] TreeMap w/ Explanation & Readability](https://leetcode.com/problems/count-integers-in-intervals/discuss/2039728/Java-TreeMap-w-Explanation-and-Readability). Credit to @wangdi814\\n\\nPlease upvote this if the explanation is helpful to you, thanks!\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```java\\n// key, value => left, right\\nTreeMap<Integer, Integer> m;\\nint count = 0;\\n\\npublic CountIntervals() {\\n    m = new TreeMap<>();\\n}\\n\\npublic void add(int left, int right) {\\n    if (m.floorKey(right) != null && m.get(m.floorKey(right)) < left) {\\n        count += right - left + 1;\\n        m.put(left, right);\\n    } else {\\n        int start = left, end = right;\\n        while (m.floorKey(end) != null && m.get(m.floorKey(end)) >= left) {\\n            int l = m.floorKey(end);\\n            int r = m.get(l);\\n            count -= r - l + 1;\\n            m.remove(l);\\n\\n            start = Math.min(start, l);\\n            end = Math.max(end, r);\\n        }\\n        count += end - start + 1;\\n        m.put(start, end);\\n    }\\n}\\n\\npublic int count() {\\n    return count;\\n}\\n```\n```java\\npublic void add(int left, int right) {\\n\\tint start = left, end = right;\\n\\twhile (m.floorKey(end) != null && m.get(m.floorKey(end)) >= left) {\\n\\t\\tint l = m.floorKey(end);\\n\\t\\tint r = m.get(l);\\n\\t\\tcount -= r - l + 1;\\n\\t\\tm.remove(l);\\n\\n\\t\\tstart = Math.min(start, l);\\n\\t\\tend = Math.max(end, r);\\n\\t}\\n\\tcount += end - start + 1;\\n\\tm.put(start, end);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039995,
                "title": "c-segment-tree",
                "content": "```\\nclass node{\\npublic:\\n    int l,r,lz,k;\\n    node* left; node* right;\\n    node(int l,int r,int k,int lz){\\n        this->l= l;this->r= r;this->k= k;this->lz= lz;\\n        left=right=NULL;\\n    }\\n};\\nclass CountIntervals {\\n    node* root;  int m = 0;\\n    void find(node* root){\\n        if(root->l<root->r){\\n            int m = (root->l+root->r)/2;\\n            int l = root->l, r = root->r;\\n            if(root->left==NULL && root->right==NULL){\\n                root->left = new node(l,m,root->lz*(m-l+1),root->lz);\\n                root->right = new node(m+1,r,root->lz*(r-(m+1)+1),root->lz);\\n            }\\n            else if(root->lz>0){\\n                root->left->k=root->lz*(root->left->r-root->left->l+1);\\n                root->left->lz=root->lz; \\n                \\n                root->right->k=root->lz*(root->right->r-root->right->l+1);\\n                root->right->lz=root->lz; \\n            }\\n        }\\n    }\\n    void update(node* root,int l,int h,int val){\\n       if(l<=h){\\n           int m = (root->l+root->r)/2;\\n           if(root->r<l || root->l>h) return;\\n           if(l <= root->l && root->r <= h){\\n               root->k=val*(root->r-root->l+1); root->lz=val; return;\\n           }\\n           find(root);\\n           update(root->left,l,h,val);\\n           update(root->right,l,h,val);\\n           root->k = root->left->k + root->right->k;\\n       }\\n    }\\npublic:\\n    CountIntervals() {\\n        root = new node(0,1000000001,0,0);\\n    }\\n    \\n    void add(int left, int right) {\\n        update(root,left,right,1);\\n    }\\n    \\n    int count() {\\n        return root->k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass node{\\npublic:\\n    int l,r,lz,k;\\n    node* left; node* right;\\n    node(int l,int r,int k,int lz){\\n        this->l= l;this->r= r;this->k= k;this->lz= lz;\\n        left=right=NULL;\\n    }\\n};\\nclass CountIntervals {\\n    node* root;  int m = 0;\\n    void find(node* root){\\n        if(root->l<root->r){\\n            int m = (root->l+root->r)/2;\\n            int l = root->l, r = root->r;\\n            if(root->left==NULL && root->right==NULL){\\n                root->left = new node(l,m,root->lz*(m-l+1),root->lz);\\n                root->right = new node(m+1,r,root->lz*(r-(m+1)+1),root->lz);\\n            }\\n            else if(root->lz>0){\\n                root->left->k=root->lz*(root->left->r-root->left->l+1);\\n                root->left->lz=root->lz; \\n                \\n                root->right->k=root->lz*(root->right->r-root->right->l+1);\\n                root->right->lz=root->lz; \\n            }\\n        }\\n    }\\n    void update(node* root,int l,int h,int val){\\n       if(l<=h){\\n           int m = (root->l+root->r)/2;\\n           if(root->r<l || root->l>h) return;\\n           if(l <= root->l && root->r <= h){\\n               root->k=val*(root->r-root->l+1); root->lz=val; return;\\n           }\\n           find(root);\\n           update(root->left,l,h,val);\\n           update(root->right,l,h,val);\\n           root->k = root->left->k + root->right->k;\\n       }\\n    }\\npublic:\\n    CountIntervals() {\\n        root = new node(0,1000000001,0,0);\\n    }\\n    \\n    void add(int left, int right) {\\n        update(root,left,right,1);\\n    }\\n    \\n    int count() {\\n        return root->k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854030,
                "title": "asked-in-my-google-l4-onsite",
                "content": "A question very similar to this one was asked in my google onsite.\\n\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/trees/CountIntervals.java\\n\\nThis is my detailed interview experience:\\nhttps://medium.com/p/3b035eb9e9f1",
                "solutionTags": [
                    "Java"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2070461,
                "title": "go-insertion-sort-merge-with-comments",
                "content": "Very Go-unfriendly problem. We don\\'t have TreeMaps or sets..\\n\\nKeep a slice of intervals. Binary search for the relevant interval to consider for [left, right].\\n\\nThen consider all cases. If necessary, merge several intervals into a single one using `copy`.\\n\\n```go\\ntype CountIntervals struct {\\n\\tintervals []interval\\n\\tcount     int\\n}\\n\\ntype interval struct {\\n\\tstart, end int\\n}\\n\\nfunc Constructor() CountIntervals {\\n\\tc := CountIntervals{\\n\\t\\tintervals: make([]interval, 0, 100),\\n\\t}\\n\\t// Add sentinel values to make indexing easier\\n\\tc.intervals = append(c.intervals,\\n\\t\\tinterval{-100, -99},\\n\\t\\tinterval{1e9 + 1, 1e9 + 2},\\n\\t)\\n\\treturn c\\n}\\n\\nfunc (this *CountIntervals) Add(left int, right int) {\\n\\tright++ // easier to work with open-ended intervals\\n\\n\\t// Binary search for first and second interval.\\n\\t// These may be the same interval\\n\\tfirst := sort.Search(len(this.intervals), func(i int) bool {\\n\\t\\treturn left <= this.intervals[i].end\\n\\t})\\n\\tsecond := sort.Search(len(this.intervals), func(i int) bool {\\n\\t\\treturn this.intervals[i].start > right\\n\\t}) - 1\\n\\n\\t// In the following if-statements, I will use the notation <left> <right>\\n\\t// [ ), where [ ) refers to an interval.\\n\\t//\\n\\t// For example: \"<left> [ )\" means that the left value is smaller than the\\n\\t// start value of an interval.\\n\\n\\tif right < this.intervals[first].start {\\n\\t\\t// <left> <right> [ )\\n\\t\\t// Create a new interval and return.\\n\\t\\tthis.intervals = append(this.intervals, interval{})\\n\\t\\tcopy(this.intervals[first+1:], this.intervals[first:])\\n\\t\\tthis.intervals[first] = interval{left, right}\\n\\t\\tthis.count += right - left\\n\\t\\treturn\\n\\t} else if right > this.intervals[second].end {\\n\\t\\t// We know that <left> is <= the right boundary of the first interval.\\n\\t\\t// So [ ) <left> <right> cannot happen.\\n\\t\\t//\\n\\t\\t// It\\'s safe to assume that we should update the right-boundary of the\\n\\t\\t// second interval, i.e. we have\\n\\t\\t// [ ) <right>\\n\\t\\tthis.count += right - this.intervals[second].end\\n\\t\\tthis.intervals[second].end = right\\n\\t} else {\\n\\t\\t// right is inside the second interval - no need to update any intervals\\n\\t\\t// (however, we might need to merge later on).\\n\\t\\t// [ <right> )\\n\\t}\\n\\n\\tif left < this.intervals[first].start {\\n\\t\\t// We know that <right> to the right of the start boundary of the first\\n\\t\\t// interval. So we can safely assume that the start boundary of the first\\n\\t\\t// interval should be updated.\\n\\t\\t//\\n\\t\\t// Example cases:\\n\\t\\t// <left> [ <right> ) or <left> [ ) <right>, etc\\n\\t\\tthis.count += this.intervals[first].start - left\\n\\t\\tthis.intervals[first].start = left\\n\\t} else {\\n\\t\\t// <left> is inside the interval - no need to update\\n\\t}\\n\\n\\t// If first != second, merge intervals. These actions will do nothing when\\n\\t// start == end so no need to check.\\n\\tfor j := first + 1; j <= second; j++ {\\n\\t\\tthis.count += this.intervals[j].start - this.intervals[j-1].end\\n\\t}\\n\\tthis.intervals[second].start = this.intervals[first].start\\n\\tcopy(this.intervals[first:], this.intervals[second:])\\n\\tthis.intervals = this.intervals[:len(this.intervals)-(second-first)]\\n}\\n\\nfunc (this *CountIntervals) Count() int {\\n\\treturn this.count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype CountIntervals struct {\\n\\tintervals []interval\\n\\tcount     int\\n}\\n\\ntype interval struct {\\n\\tstart, end int\\n}\\n\\nfunc Constructor() CountIntervals {\\n\\tc := CountIntervals{\\n\\t\\tintervals: make([]interval, 0, 100),\\n\\t}\\n\\t// Add sentinel values to make indexing easier\\n\\tc.intervals = append(c.intervals,\\n\\t\\tinterval{-100, -99},\\n\\t\\tinterval{1e9 + 1, 1e9 + 2},\\n\\t)\\n\\treturn c\\n}\\n\\nfunc (this *CountIntervals) Add(left int, right int) {\\n\\tright++ // easier to work with open-ended intervals\\n\\n\\t// Binary search for first and second interval.\\n\\t// These may be the same interval\\n\\tfirst := sort.Search(len(this.intervals), func(i int) bool {\\n\\t\\treturn left <= this.intervals[i].end\\n\\t})\\n\\tsecond := sort.Search(len(this.intervals), func(i int) bool {\\n\\t\\treturn this.intervals[i].start > right\\n\\t}) - 1\\n\\n\\t// In the following if-statements, I will use the notation <left> <right>\\n\\t// [ ), where [ ) refers to an interval.\\n\\t//\\n\\t// For example: \"<left> [ )\" means that the left value is smaller than the\\n\\t// start value of an interval.\\n\\n\\tif right < this.intervals[first].start {\\n\\t\\t// <left> <right> [ )\\n\\t\\t// Create a new interval and return.\\n\\t\\tthis.intervals = append(this.intervals, interval{})\\n\\t\\tcopy(this.intervals[first+1:], this.intervals[first:])\\n\\t\\tthis.intervals[first] = interval{left, right}\\n\\t\\tthis.count += right - left\\n\\t\\treturn\\n\\t} else if right > this.intervals[second].end {\\n\\t\\t// We know that <left> is <= the right boundary of the first interval.\\n\\t\\t// So [ ) <left> <right> cannot happen.\\n\\t\\t//\\n\\t\\t// It\\'s safe to assume that we should update the right-boundary of the\\n\\t\\t// second interval, i.e. we have\\n\\t\\t// [ ) <right>\\n\\t\\tthis.count += right - this.intervals[second].end\\n\\t\\tthis.intervals[second].end = right\\n\\t} else {\\n\\t\\t// right is inside the second interval - no need to update any intervals\\n\\t\\t// (however, we might need to merge later on).\\n\\t\\t// [ <right> )\\n\\t}\\n\\n\\tif left < this.intervals[first].start {\\n\\t\\t// We know that <right> to the right of the start boundary of the first\\n\\t\\t// interval. So we can safely assume that the start boundary of the first\\n\\t\\t// interval should be updated.\\n\\t\\t//\\n\\t\\t// Example cases:\\n\\t\\t// <left> [ <right> ) or <left> [ ) <right>, etc\\n\\t\\tthis.count += this.intervals[first].start - left\\n\\t\\tthis.intervals[first].start = left\\n\\t} else {\\n\\t\\t// <left> is inside the interval - no need to update\\n\\t}\\n\\n\\t// If first != second, merge intervals. These actions will do nothing when\\n\\t// start == end so no need to check.\\n\\tfor j := first + 1; j <= second; j++ {\\n\\t\\tthis.count += this.intervals[j].start - this.intervals[j-1].end\\n\\t}\\n\\tthis.intervals[second].start = this.intervals[first].start\\n\\tcopy(this.intervals[first:], this.intervals[second:])\\n\\tthis.intervals = this.intervals[:len(this.intervals)-(second-first)]\\n}\\n\\nfunc (this *CountIntervals) Count() int {\\n\\treturn this.count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2047969,
                "title": "c-map-easy-logic",
                "content": "class CountIntervals {\\npublic:\\n    map<int,int>mp;\\n    int ans;\\n    \\n    CountIntervals() \\n    {\\n        mp.clear();\\n        ans=0;\\n    }\\n    \\n    void add(int left, int right) \\n    {\\n        // main idea is to find less than or equal staring point in map which has ending proint greater than or equal to l (current interval) and merge it\\n        \\n        int l=left,r=right,cnt=0;\\n        bool ok=true;\\n        \\n        if(mp.size()==0)\\n        {\\n            mp[left]=right;\\n            ans+=r-l+1;\\n            return;\\n        }\\n        \\n        // idea is l.....r hai so r se chhota ya barabar starting point dhoonhdo jiska ending point >=l ho aur usko merge krdo\\n        // think and u will get it, small milate jaao large banate jaao \\n        \\n        while(ok)\\n        {\\n            auto itl=mp.upper_bound(r);\\n    \\n            ok=false;\\n            \\n            if(itl!=mp.begin())\\n            {\\n                itl--;\\n            }\\n            \\n            if(itl!=mp.end() && itl->first<=r && itl->second>=l)\\n            {\\n                ok=true;\\n                ans=ans-(itl->second-itl->first+1);\\n                l=min(l,itl->first);\\n                r=max(r,itl->second);\\n                mp.erase(itl);\\n            }\\n        }\\n        \\n        \\n        mp[l]=r;\\n        ans+=r-l+1;\\n    }\\n    \\n    int count() \\n    {\\n       return ans; \\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class CountIntervals {\\npublic:\\n    map<int,int>mp;\\n    int ans;\\n    \\n    CountIntervals() \\n    {\\n        mp.clear();\\n        ans=0;\\n    }\\n    \\n    void add(int left, int right) \\n    {\\n        // main idea is to find less than or equal staring point in map which has ending proint greater than or equal to l (current interval) and merge it\\n        \\n        int l=left,r=right,cnt=0;\\n        bool ok=true;\\n        \\n        if(mp.size()==0)\\n        {\\n            mp[left]=right;\\n            ans+=r-l+1;\\n            return;\\n        }\\n        \\n        // idea is l.....r hai so r se chhota ya barabar starting point dhoonhdo jiska ending point >=l ho aur usko merge krdo\\n        // think and u will get it, small milate jaao large banate jaao \\n        \\n        while(ok)\\n        {\\n            auto itl=mp.upper_bound(r);\\n    \\n            ok=false;\\n            \\n            if(itl!=mp.begin())\\n            {\\n                itl--;\\n            }\\n            \\n            if(itl!=mp.end() && itl->first<=r && itl->second>=l)\\n            {\\n                ok=true;\\n                ans=ans-(itl->second-itl->first+1);\\n                l=min(l,itl->first);\\n                r=max(r,itl->second);\\n                mp.erase(itl);\\n            }\\n        }\\n        \\n        \\n        mp[l]=r;\\n        ans+=r-l+1;\\n    }\\n    \\n    int count() \\n    {\\n       return ans; \\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2043134,
                "title": "python-merge-intervals-without-binary-search-faster-than-100",
                "content": "My basic idea is using a dictionary to represent the left and right boundary of intervals. \\n1. Insert keys into map.\\n\\tif we add intervals [2, 3], [7, 10], [5, 8], the dict `boundary_cnt` will be  {2: 1, 4: -1, 5: 1, 7: 1, 9: -1,11: -1} (the value is sorted)\\n2. Go through the intervals and count.\\n\\tUse `cur_sum` to decide if we reach the left boundary or right boundary of an interval. Initailize the left boundary with -1. `cur_sum += boundary_cnt[v]` , if `cur_sum > 0`, v must be in the interval. if `cur_sum == 0`, v is the right boundary of the interval. \\nFor example, \\nv = 2, cur_sum = 1, since `left` = -1, v = 2 is the left boundary of interval\\nv = 4, cur_sum = 0, v = 4 is right most one. The length of this interval is 2. Then we re-initialize the `left`\\nv = 5, cur_sum = 1, find a new `left`\\nv = 7, cur_sum = 2, it\\'s not the left nor right, we can delete the key \\nv = 9, cur_sum = 1, same as above\\nv = 11, cur_sum = 0, finally find the `right`.  The length of this interval is 6, total count is 8. In the meanwhile, since we delete some keys between (5, 11), to make sure we can still find the paired left and right next time, update the value of `boundary_cnt[11]`\\n\\n\\n```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.boundary_cnt = defaultdict(int)\\n        self.cur_res = -1\\n        \\n    def add(self, left: int, right: int) -> None:\\n        self.boundary_cnt[left] += 1\\n        self.boundary_cnt[right + 1] -= 1\\n        self.cur_res = -1\\n        \\n    def count(self) -> int:\\n        if not self.boundary_cnt:\\n            return 0\\n        if self.cur_res != -1:\\n            return self.cur_res\\n        \\n        res = 0\\n        values = sorted(self.boundary_cnt.keys())\\n        left = -1\\n        cur_sum = 0\\n\\n        for v in values:\\n            if v not in self.boundary_cnt:\\n                continue\\n            \\n            cur_sum += self.boundary_cnt[v]\\n            if left == -1:\\n                if cur_sum > 0:\\n                    left = v\\n                continue\\n                \\n            if cur_sum > 0:\\n                del self.boundary_cnt[v]\\n            else:\\n                right = v\\n                res += right - left \\n                self.boundary_cnt[v] = - self.boundary_cnt[left]\\n                left = -1\\n\\n        self.cur_res = res\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.boundary_cnt = defaultdict(int)\\n        self.cur_res = -1\\n        \\n    def add(self, left: int, right: int) -> None:\\n        self.boundary_cnt[left] += 1\\n        self.boundary_cnt[right + 1] -= 1\\n        self.cur_res = -1\\n        \\n    def count(self) -> int:\\n        if not self.boundary_cnt:\\n            return 0\\n        if self.cur_res != -1:\\n            return self.cur_res\\n        \\n        res = 0\\n        values = sorted(self.boundary_cnt.keys())\\n        left = -1\\n        cur_sum = 0\\n\\n        for v in values:\\n            if v not in self.boundary_cnt:\\n                continue\\n            \\n            cur_sum += self.boundary_cnt[v]\\n            if left == -1:\\n                if cur_sum > 0:\\n                    left = v\\n                continue\\n                \\n            if cur_sum > 0:\\n                del self.boundary_cnt[v]\\n            else:\\n                right = v\\n                res += right - left \\n                self.boundary_cnt[v] = - self.boundary_cnt[left]\\n                left = -1\\n\\n        self.cur_res = res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041411,
                "title": "merge-intervals",
                "content": "```\\nclass CountIntervals {\\nprivate:\\n    set<pair<int, int>> interval;\\n    int ans;\\npublic:\\n    CountIntervals() {\\n        interval = * new set<pair<int, int>>();\\n        ans = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        if (interval.size() == 0) {\\n            interval.insert(make_pair(left, right));\\n            ans += right - left + 1;\\n        } else {\\n            pair<int, int> num = make_pair(left, right);\\n            int sub = 0;\\n            \\n            if (interval.lower_bound(num) == interval.begin()) {\\n                while (interval.begin()->second <= right) {\\n                    sub += interval.begin()->second - interval.begin()->first + 1;\\n                    interval.erase(interval.begin());\\n                    \\n                    if (interval.empty())\\n                        break;\\n                }\\n                \\n                if (!interval.empty() && interval.begin()->first <= right) {\\n                    sub += right - interval.begin()->first + 1;\\n                    num.second = interval.begin()->second;\\n                    interval.erase(interval.begin());\\n                }\\n            } else {\\n                if (prev(interval.lower_bound(num))->second >= left) {\\n                    int ll = prev(interval.lower_bound(num))->first;\\n                    \\n                    if (prev(interval.lower_bound(num))->second >= right) {\\n                        sub += right - left + 1;\\n                        num.second = prev(interval.lower_bound(num))->second;\\n                        interval.erase(prev(interval.lower_bound(num)));\\n                    } else {\\n                        sub += prev(interval.lower_bound(num))->second - left + 1;\\n                        interval.erase(prev(interval.lower_bound(num)));\\n                    }\\n                    \\n                    num.first = ll;\\n                }\\n                \\n                while (interval.lower_bound(num) != interval.end() && right >= interval.lower_bound(num)->first) {\\n                    if (right > interval.lower_bound(num)->second)\\n                        sub += interval.lower_bound(num)->second - interval.lower_bound(num)->first + 1;\\n                    else {\\n                        sub += right - interval.lower_bound(num)->first + 1;\\n                        num.second = interval.lower_bound(num)->second;\\n                    }\\n                    \\n                    interval.erase(interval.lower_bound(num));\\n                }\\n            }\\n            \\n            interval.insert(num);\\n            ans += right - left + 1 - sub;\\n        }\\n    }\\n    \\n    int count() {\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CountIntervals {\\nprivate:\\n    set<pair<int, int>> interval;\\n    int ans;\\npublic:\\n    CountIntervals() {\\n        interval = * new set<pair<int, int>>();\\n        ans = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        if (interval.size() == 0) {\\n            interval.insert(make_pair(left, right));\\n            ans += right - left + 1;\\n        } else {\\n            pair<int, int> num = make_pair(left, right);\\n            int sub = 0;\\n            \\n            if (interval.lower_bound(num) == interval.begin()) {\\n                while (interval.begin()->second <= right) {\\n                    sub += interval.begin()->second - interval.begin()->first + 1;\\n                    interval.erase(interval.begin());\\n                    \\n                    if (interval.empty())\\n                        break;\\n                }\\n                \\n                if (!interval.empty() && interval.begin()->first <= right) {\\n                    sub += right - interval.begin()->first + 1;\\n                    num.second = interval.begin()->second;\\n                    interval.erase(interval.begin());\\n                }\\n            } else {\\n                if (prev(interval.lower_bound(num))->second >= left) {\\n                    int ll = prev(interval.lower_bound(num))->first;\\n                    \\n                    if (prev(interval.lower_bound(num))->second >= right) {\\n                        sub += right - left + 1;\\n                        num.second = prev(interval.lower_bound(num))->second;\\n                        interval.erase(prev(interval.lower_bound(num)));\\n                    } else {\\n                        sub += prev(interval.lower_bound(num))->second - left + 1;\\n                        interval.erase(prev(interval.lower_bound(num)));\\n                    }\\n                    \\n                    num.first = ll;\\n                }\\n                \\n                while (interval.lower_bound(num) != interval.end() && right >= interval.lower_bound(num)->first) {\\n                    if (right > interval.lower_bound(num)->second)\\n                        sub += interval.lower_bound(num)->second - interval.lower_bound(num)->first + 1;\\n                    else {\\n                        sub += right - interval.lower_bound(num)->first + 1;\\n                        num.second = interval.lower_bound(num)->second;\\n                    }\\n                    \\n                    interval.erase(interval.lower_bound(num));\\n                }\\n            }\\n            \\n            interval.insert(num);\\n            ans += right - left + 1 - sub;\\n        }\\n    }\\n    \\n    int count() {\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041004,
                "title": "python-easy-binary-search",
                "content": "**Idea**: stored a list of interval points, where the even indices are the start points (included) of the intervals and odd indices are the end points (excluded) of the intervals. For example, \\nthe intervals [[2, 3], [7, 10]] is stored as [2, 4, 7, 11]\\n\\nWhen adding a new interval, I use binary search to find the insertion points (bisect_left for the start points and bisect_right to the end points). I add the new intervals and delete the intervals in between.\\n\\nHowever, I need to handle the case when the indicies of the insertion points are odd, which means the points are within existing intervals. For example, adding [5, 9) to [2, 4, 7, 11], the insertion point of 5 is 2, so it is fine, while the insertion point of 9 is 3, so I need to move it to the right (11). \\nAnother example, adding [3, 5) to [2, 4, 7, 11], the insertion points are 1 and 2, so I moved the insertion points of 3 to the left (2).\\n\\nWhen adding and deleting the intervals, I also store the value of the total interval count.\\n\\n**Python**\\n\\n```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.c = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        right += 1\\n        i = bisect_left(self.intervals, left)\\n        j = bisect_right(self.intervals, right)\\n\\n        if i % 2 == 1:\\n            left = self.intervals[i-1]\\n            i -= 1\\n            \\n        if j % 2 == 1:\\n            right = self.intervals[j]\\n            j += 1\\n            \\n        for k in range(i, j, 2):\\n             self.c -= self.intervals[k+1] - self.intervals[k]        \\n        \\n        self.c += right - left\\n        self.intervals[i:j] = [left, right]\\n        \\n    def count(self) -> int:\\n        return self.c\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.c = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        right += 1\\n        i = bisect_left(self.intervals, left)\\n        j = bisect_right(self.intervals, right)\\n\\n        if i % 2 == 1:\\n            left = self.intervals[i-1]\\n            i -= 1\\n            \\n        if j % 2 == 1:\\n            right = self.intervals[j]\\n            j += 1\\n            \\n        for k in range(i, j, 2):\\n             self.c -= self.intervals[k+1] - self.intervals[k]        \\n        \\n        self.c += right - left\\n        self.intervals[i:j] = [left, right]\\n        \\n    def count(self) -> int:\\n        return self.c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040829,
                "title": "tree-of-merged-intervals-thorough-explaination",
                "content": "**Thought Process:**\\n\\n*What are the possibilities when inserting a new interval?*\\n\\n1. The new interval partly intersects with existing intervals. \\n\\t- Ex: [1, 2] partly intersects with [2, 3]\\n\\t- This pair can be merged as [1,3] and the existing interval of [2,3] can be removed.\\n2. The new interval is encapsualted by an existing interval. \\n\\t- Ex: [2,3] is encapsulated by [1,4]\\n\\t- In this case, there is no need to add any interval.\\n3. The new interval does not intersect with any existing intervals.\\n\\t- Ex: [1,2] does not intersect with [3,4]\\n\\t- [1,2] can simply be added as the new interval\\n\\n*Which operations do we want to perform on the intervals?*\\n\\n1. Inserting a new interval seems critical.\\n3. Searching for existing intervals that partly intersects or encapsulates a new interval.\\n2. Deleting intervals when some may intersect and need to be merged.\\n3. Maintaining the count of the unique integers between all intervals.\\n\\n*Which data structures can be used to store intervals, and which one is best? Keep in mind that each operation will be run N times.*\\n\\n1. List of Intervals: This data structure takes O(N) time to insert/delete/search an interval. When these operations are run N times each, the total Time Complexity is O(N^2) and will most likely TLE.\\n\\t- This may be the first idea borrowed from Merge Intervals, but is too inefficient.\\n\\n2. Balanced Binary Search Tree of Intervals: This data structure is far more ideal since it can insert/search/delete an interval in log(N). When applied to N operations the final Time Complexity is O(Nlog(N)).\\n\\t- This is the optimal runtime for searching and delete. Implementing such a self-balancing Tree from scratch would be quite tedious, so let\\'s use a TreeMap.\\n\\t- TreeMaps operate as HashMaps with key/val pairs, but the operations do not run in O(1). The upside is that entries are sorted by key, allowing for in-order successor and pre-order predecessors to be looked up.\\n\\n*How should this Tree be used to insert/search/delete for new intervals, and resolve encapusalations + intersections?*\\n\\n1. The Tree can be represented by nodes, where each node holds the [left, right] of its interval.\\n\\t- For any node, all nodes the left must have a smaller [**left**, right], while all nodes on the right must have a greater [**left**, right]. This makes the BST property simple to allow for searching.\\n\\n2. For any new intervals, let\\'s check for an intersection on the left side or encapsulation.\\n\\t- Example:  existingIntervals = [[1,5], [6, 9]] | newInterval = [7, 11]\\n\\t- Clearly [6, 9] & [7, 11] intersect.\\n\\t\\n\\ta) From the root of the tree, search for an existing interval with a left value **less than or equal** to the new interval\\'s left.\\n\\t\\t\\n\\t- There may be many such intervals, so which one is most likely to intersect with the new interval? That would be the existing interval with the **greatest** left value. This is known as the pre-order predecessor, resulting in finding [6, 9].\\n\\t- To check if they intersect, simply check ```node.right >=  left``` meaning 9 > 7 from above example. In this case the ```left = 7``` should be updated to the existing node\\'s left so ```left = 6```.\\n\\t- For encapsulation, it is possible that ```node.right >=  right``` meaning the existing interval goes past the new interval\\'s right bounds. And the existing interval has a left value going below the new interval\\'s left bounds. In this case, no interval needs to be added.\\n\\n3. *How should intervals on the right side be checked?*\\n\\t- Example:  existingIntervals = [[6, 9], [10,11]] | newInterval = [2, 11]\\n\\t- Clearly [2,11] intersects with [6, 9], [10,11] thru the right side .\\n\\t\\n\\ta) From the root of the tree, search for an existing interval with a left value **greater than or equal** to the new interval\\'s left.\\n\\t\\t\\n\\t- There may be many such intervals, so which one is most likely to intersect with the new interval? That would be the existing interval with the **smallest** left value. This is known as the in-order successor, resulting in finding [6, 9].\\n\\t- To check if they intersect, simply check ```node.right <=  right``` meaning 9 <= 11  from above example. The Tree is only sorted by left values, so it is not clear which right is greate. Will update the right value based on whichever is greater ```right = max(right, node.right);```\\n\\t- In the above example, the intersections on the right side are not completely handled by finding just 1 intersecting interval. Hence, we need a loop to find the reamining right side intersection so long as the condition ```node.right <=  right``` holds true.\\n\\n\\n4. The hard work is done, but how can count be maintained?\\n\\t- Initially assume the new interval size is ```intervalSize = right - left + 1```\\n\\t- If an encapsulation is found, there are no new numbers in our data structure.\\n\\t- If an intersection is found, simply decrement ```intervalSize``` based on the shared intersecting numbers.\\n\\t- Finally, add the updated ```intervalSize``` to the global counter variable.\\n```\\nclass CountIntervals {\\n    \\n    TreeMap<Integer, Integer> intervals = new TreeMap();\\n    int existingNumbers = 0;\\n\\n    public void add(int left, int right) {\\n        // Get number count in interval\\n        int intervalSize = right - left + 1;\\n        \\n        // Check for left intersection\\n        Map.Entry<Integer, Integer> leftEntry = intervals.floorEntry(left);\\n        if (leftEntry != null) {\\n            // Parse potentially intersecting interval\\n            int newLeft = leftEntry.getKey(), newRight = leftEntry.getValue();\\n\\n            // Check if left side encapsualtes new interval\\n            if (newRight >= right)\\n                return;\\n\\n            // Check if left side intersects new interval\\n            if (newRight >= left) {\\n                // Subtract intersecting/uduplicate numbers\\n                intervalSize -= newRight - left + 1; // Count numbers deleted/intersected\\n                \\n                // Delete intersecting interval\\n                intervals.remove(newLeft);\\n                \\n                // Update left to merge as smaller value\\n                left = newLeft;\\n            }\\n        }\\n        \\n        // Check for right intersection\\n        Map.Entry<Integer, Integer> rightEntry = intervals.ceilingEntry(left);\\n        while (rightEntry != null && rightEntry.getKey() <= right) {\\n            // Parse intersecting interval\\n            int newLeft = rightEntry.getKey(), newRight = rightEntry.getValue();\\n            \\n            // Subtract intersecting/duplicate numbers\\n            intervalSize -= Math.min(right, newRight) - newLeft + 1;\\n            \\n            // Delete intersecting interval\\n            intervals.remove(newLeft);\\n            \\n            // Update right to merge as greater value\\n            right = Math.max(right, newRight);\\n            \\n            // Check for another intersection\\n            rightEntry = intervals.ceilingEntry(left);\\n        }\\n        \\n        // Add new numbers and insert interval\\n        existingNumbers += intervalSize;\\n        intervals.put(left, right);\\n    }\\n    \\n    public int count() {\\n        return existingNumbers;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```node.right >=  left```\n```left = 7```\n```left = 6```\n```node.right >=  right```\n```node.right <=  right```\n```right = max(right, node.right);```\n```node.right <=  right```\n```intervalSize = right - left + 1```\n```intervalSize```\n```intervalSize```",
                "codeTag": "Unknown"
            },
            {
                "id": 2040384,
                "title": "c-solution-using-set",
                "content": "```\\nclass CountIntervals {\\npublic:\\n    int sum=0;\\n    set<pair<int,int>>s;\\n    CountIntervals() \\n    {\\n        s.clear();\\n    }\\n    \\n    void add(int left, int right) \\n    {\\n        auto it=s.lower_bound({left,INT_MIN});\\n        if(it!=s.begin()&&(--it)->second<left)\\n        {\\n            it++;\\n        }\\n        while(it!=s.end()&&(it->first)<=right)\\n        {\\n            left=min(left,it->first);\\n            right=max(right,it->second);\\n            sum-=(it->second-it->first+1);\\n            s.erase(it++);\\n        }\\n        s.insert({left,right});\\n        sum+=(right-left+1);\\n    }\\n    int count() \\n    {\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    int sum=0;\\n    set<pair<int,int>>s;\\n    CountIntervals() \\n    {\\n        s.clear();\\n    }\\n    \\n    void add(int left, int right) \\n    {\\n        auto it=s.lower_bound({left,INT_MIN});\\n        if(it!=s.begin()&&(--it)->second<left)\\n        {\\n            it++;\\n        }\\n        while(it!=s.end()&&(it->first)<=right)\\n        {\\n            left=min(left,it->first);\\n            right=max(right,it->second);\\n            sum-=(it->second-it->first+1);\\n            s.erase(it++);\\n        }\\n        s.insert({left,right});\\n        sum+=(right-left+1);\\n    }\\n    int count() \\n    {\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039723,
                "title": "clean-java",
                "content": "For here, we need to consider 3 cases.\\nwe use \\'us\\' as current interval will be insert.\\n1. most close left interval which has overlap with us.\\n2. most close right interval which has overlap with us (included in case3)\\n3. clean up all the intervals within us range\\n\\nwe can guarantee step3 does out bound of our range due to we do it everytime so there would only be 1 left close, 1 right close to merge. And all the interval in the middle can be safely pruned.\\n```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n    int sum = 0;\\n    public void add(int left, int right) {\\n        Integer leftIntervalStart = map.floorKey(left);\\n        Integer rightIntervalStart = map.ceilingKey(left);\\n        if (leftIntervalStart != null) {\\n            int leftIntervalEnd = map.get(leftIntervalStart);\\n            if (leftIntervalEnd >= left) {\\n                int preLen = leftIntervalEnd - leftIntervalStart + 1;\\n                sum = sum - preLen;\\n                map.remove(leftIntervalStart);\\n                left = Math.min(leftIntervalStart, left);\\n                right = Math.max(right, leftIntervalEnd);\\n            }\\n        }\\n        while (map.ceilingKey(left) != null && map.ceilingKey(left) <= right) {\\n            int nextIntervalStart = map.ceilingKey(left);\\n            int nextIntervalEnd = map.get(nextIntervalStart);\\n            right = Math.max(nextIntervalEnd, right);\\n            left = Math.min(nextIntervalStart, left);\\n            sum = sum - (nextIntervalEnd - nextIntervalStart + 1);\\n            map.remove(nextIntervalStart);\\n        }\\n        map.put(left, right);\\n        sum += (right - left + 1);\\n    }\\n    public int count() {\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n    int sum = 0;\\n    public void add(int left, int right) {\\n        Integer leftIntervalStart = map.floorKey(left);\\n        Integer rightIntervalStart = map.ceilingKey(left);\\n        if (leftIntervalStart != null) {\\n            int leftIntervalEnd = map.get(leftIntervalStart);\\n            if (leftIntervalEnd >= left) {\\n                int preLen = leftIntervalEnd - leftIntervalStart + 1;\\n                sum = sum - preLen;\\n                map.remove(leftIntervalStart);\\n                left = Math.min(leftIntervalStart, left);\\n                right = Math.max(right, leftIntervalEnd);\\n            }\\n        }\\n        while (map.ceilingKey(left) != null && map.ceilingKey(left) <= right) {\\n            int nextIntervalStart = map.ceilingKey(left);\\n            int nextIntervalEnd = map.get(nextIntervalStart);\\n            right = Math.max(nextIntervalEnd, right);\\n            left = Math.min(nextIntervalStart, left);\\n            sum = sum - (nextIntervalEnd - nextIntervalStart + 1);\\n            map.remove(nextIntervalStart);\\n        }\\n        map.put(left, right);\\n        sum += (right - left + 1);\\n    }\\n    public int count() {\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731737,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass CountIntervals {\\n    set<pair<int, int>> st;\\n    int cnt;\\npublic:\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = st.upper_bound({left, INT_MIN});\\n        \\n        if(it != st.begin() && (--it)->second < left) {\\n            ++it;\\n        }\\n        \\n        while(it != st.end() && it->first <= right) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            \\n            cnt -= (it->second - it->first + 1);\\n            it = st.erase(it);\\n        }\\n        \\n        st.insert({ left, right });\\n        cnt += (right - left + 1);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CountIntervals {\\n    set<pair<int, int>> st;\\n    int cnt;\\npublic:\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = st.upper_bound({left, INT_MIN});\\n        \\n        if(it != st.begin() && (--it)->second < left) {\\n            ++it;\\n        }\\n        \\n        while(it != st.end() && it->first <= right) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            \\n            cnt -= (it->second - it->first + 1);\\n            it = st.erase(it);\\n        }\\n        \\n        st.insert({ left, right });\\n        cnt += (right - left + 1);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671470,
                "title": "one-ordered-map-491ms-beats-97",
                "content": "##### Data Structure\\nUse ordered map, also called tree map, to store all the intervals.\\nThe map has key=right and value=left. \\nUsing `right` as key is helpful for later binary search by calling lower_bound()\\nAnother int value to store the total count\\n\\n##### Algorithm\\n1. Binary search to find the closest intervals by `left`\\n2. Check if the found interval has intersection with new segment `[left, right]`\\n3. Cover the new segment by extending the left margin (also increasing the `count` in the mean time)\\n4. If there is still some segment not covered, repeat 2~4 for next iteration\\n5. After the iteration if there is still some segment not covered, add it into the tree map\\n\\n##### C++\\n```\\nclass CountIntervals {\\npublic:\\n    CountIntervals() {\\n\\n    }\\n\\n    void add(int left, int right) {\\n        auto it = m.lower_bound(left);\\n\\n        while (it != m.end() && left <= right) {\\n            auto &sl = it->second; // segment left\\n            auto &sr = it->first;  // segment right\\n\\n            if (right < sl) { // no intersection\\n                break;\\n            }\\n\\n            // extend left margin to cover the left part of new sement\\n            if (left < sl) {\\n                cnt += sl - left;\\n                sl = left;\\n            }\\n\\n            // move left to the un-covered part for next iteration\\n            left = min(sr, right)+1;\\n\\n            ++it;\\n        }\\n\\n        if (left <= right) {\\n            cnt += right-left+1;\\n            m[right] = left;\\n        }\\n    }\\n\\n    int count() {\\n        return cnt;\\n    }\\n\\nprivate:\\n    map<int, int> m; // right -> left\\n    int cnt = 0;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    CountIntervals() {\\n\\n    }\\n\\n    void add(int left, int right) {\\n        auto it = m.lower_bound(left);\\n\\n        while (it != m.end() && left <= right) {\\n            auto &sl = it->second; // segment left\\n            auto &sr = it->first;  // segment right\\n\\n            if (right < sl) { // no intersection\\n                break;\\n            }\\n\\n            // extend left margin to cover the left part of new sement\\n            if (left < sl) {\\n                cnt += sl - left;\\n                sl = left;\\n            }\\n\\n            // move left to the un-covered part for next iteration\\n            left = min(sr, right)+1;\\n\\n            ++it;\\n        }\\n\\n        if (left <= right) {\\n            cnt += right-left+1;\\n            m[right] = left;\\n        }\\n    }\\n\\n    int count() {\\n        return cnt;\\n    }\\n\\nprivate:\\n    map<int, int> m; // right -> left\\n    int cnt = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169827,
                "title": "simple-c-and-set",
                "content": "```\\nclass CountIntervals {\\npublic:\\n    set<pair<int,int>> s;\\n    int sum = 0;\\n    CountIntervals() {\\n        sum = 0;\\n    }\\n    void add(int left, int right)  {\\n        auto iter = s.upper_bound({left, INT_MAX});\\n        if (iter != s.begin())\\n            iter--;\\n        if (iter != s.end() && iter->second < left)\\n            iter++;\\n        while (iter != s.end() && iter->first <= right) {\\n            left = min(left, iter->first);\\n            right = max(right, iter->second);\\n            sum -= (iter->second - iter->first + 1);\\n            iter = s.erase(iter);\\n        }\\n        s.insert({left, right});\\n        sum += (right - left + 1);\\n    }\\n    int count()  {\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    set<pair<int,int>> s;\\n    int sum = 0;\\n    CountIntervals() {\\n        sum = 0;\\n    }\\n    void add(int left, int right)  {\\n        auto iter = s.upper_bound({left, INT_MAX});\\n        if (iter != s.begin())\\n            iter--;\\n        if (iter != s.end() && iter->second < left)\\n            iter++;\\n        while (iter != s.end() && iter->first <= right) {\\n            left = min(left, iter->first);\\n            right = max(right, iter->second);\\n            sum -= (iter->second - iter->first + 1);\\n            iter = s.erase(iter);\\n        }\\n        s.insert({left, right});\\n        sum += (right - left + 1);\\n    }\\n    int count()  {\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040939,
                "title": "javascript-binary-range-tree-700-1000ms",
                "content": "Not sure what to call this data structure. It probably exists or I\\'m doing some incorrect version of something that exists. I had what I think a Segment Tree might be in my head, but you can let me know.\\n\\nEssentially we can keep a tree of ranges\\n- the root will range from 1 to 1_000_000_000\\n- if we add an interval and the current node doesn\\'t have anything, we\\'ll just set its interval\\n- if the current node doesn\\'t have children, and we add an interval that overlaps with the current interval, we\\'ll just expand the current interval\\n- if the current node doesn\\'t have children, and we add an interval that doesn\\'t overlap with the current interval, we\\'ll split the interval in half and add left + right children, then distribute the current interval + the new interval in-so-far as it overlaps with each child\\n- if the current node has children, we\\'ll add the interval to each child if it overlaps with them\\n\\n\\n```\\n\\nvar CountIntervals = function() {\\n  this.root = new TreeNode(1, 10 ** 9);\\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {void}\\n */\\nCountIntervals.prototype.add = function(left, right) {\\n  this.root.addInterval(left, right);\\n};\\n\\n/**\\n * @return {number}\\n */\\nCountIntervals.prototype.count = function() {\\n  return this.root.total;\\n};\\n\\n/** \\n * Your CountIntervals object will be instantiated and called as such:\\n * var obj = new CountIntervals()\\n * obj.add(left,right)\\n * var param_2 = obj.count()\\n */\\n\\nclass TreeNode {\\n  constructor(min, max) {\\n    this.min = min;\\n    this.max = max;\\n    this.currentMin = -1;\\n    this.currentMax = -1;\\n    this.total = 0;\\n    this.left = null;\\n    this.right = null;\\n  }\\n  \\n  addInterval(left, right) {\\n    // no interval has been set, so just add it\\n    if (this.currentMin < 0) {\\n      this.currentMin = left;\\n      this.currentMax = right;\\n      this.total = right - left + 1;\\n      return this.total;\\n    }\\n    \\n    const mid = this.min + this.max >> 1;\\n    \\n\\t// we have children, so just add the interval to the children if it overlaps\\n    if (this.left) {\\n      if (left <= mid) this.left.addInterval(left, Math.min(mid, right));\\n      if (right > mid) this.right.addInterval(Math.max(mid + 1, left), right);\\n      \\n      this.total = this.left.total + this.right.total;\\n      return;\\n    }\\n    \\n\\t// we don\\'t have children\\n\\t// update the current interval if the new one overlaps with it\\n    if (left <= this.currentMax + 1 && right >= this.currentMin - 1) {\\n      this.currentMin = Math.min(this.currentMin, left);\\n      this.currentMax = Math.max(this.currentMax, right);\\n      this.total = this.currentMax - this.currentMin + 1;\\n      return;\\n    }\\n    \\n\\t// the interval doesn\\'t overlap and we don\\'t have children\\n\\t// create left + right children and split our current interval amongst them\\n\\t// along with adding the new interval to the children if it overlaps\\n    this.left = new TreeNode(this.min, mid);\\n    this.right = new TreeNode(mid + 1, this.max);\\n    \\n    if (left <= mid) this.left.addInterval(left, Math.min(mid, right));\\n    if (right > mid) this.right.addInterval(Math.max(left, mid + 1), right);\\n    if (this.currentMin <= mid) this.left.addInterval(this.currentMin, Math.min(mid, this.currentMax));\\n    if (this.currentMax > mid) this.right.addInterval(Math.max(mid + 1, this.currentMin), this.currentMax);\\n    \\n    this.total = this.left.total + this.right.total;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar CountIntervals = function() {\\n  this.root = new TreeNode(1, 10 ** 9);\\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {void}\\n */\\nCountIntervals.prototype.add = function(left, right) {\\n  this.root.addInterval(left, right);\\n};\\n\\n/**\\n * @return {number}\\n */\\nCountIntervals.prototype.count = function() {\\n  return this.root.total;\\n};\\n\\n/** \\n * Your CountIntervals object will be instantiated and called as such:\\n * var obj = new CountIntervals()\\n * obj.add(left,right)\\n * var param_2 = obj.count()\\n */\\n\\nclass TreeNode {\\n  constructor(min, max) {\\n    this.min = min;\\n    this.max = max;\\n    this.currentMin = -1;\\n    this.currentMax = -1;\\n    this.total = 0;\\n    this.left = null;\\n    this.right = null;\\n  }\\n  \\n  addInterval(left, right) {\\n    // no interval has been set, so just add it\\n    if (this.currentMin < 0) {\\n      this.currentMin = left;\\n      this.currentMax = right;\\n      this.total = right - left + 1;\\n      return this.total;\\n    }\\n    \\n    const mid = this.min + this.max >> 1;\\n    \\n\\t// we have children, so just add the interval to the children if it overlaps\\n    if (this.left) {\\n      if (left <= mid) this.left.addInterval(left, Math.min(mid, right));\\n      if (right > mid) this.right.addInterval(Math.max(mid + 1, left), right);\\n      \\n      this.total = this.left.total + this.right.total;\\n      return;\\n    }\\n    \\n\\t// we don\\'t have children\\n\\t// update the current interval if the new one overlaps with it\\n    if (left <= this.currentMax + 1 && right >= this.currentMin - 1) {\\n      this.currentMin = Math.min(this.currentMin, left);\\n      this.currentMax = Math.max(this.currentMax, right);\\n      this.total = this.currentMax - this.currentMin + 1;\\n      return;\\n    }\\n    \\n\\t// the interval doesn\\'t overlap and we don\\'t have children\\n\\t// create left + right children and split our current interval amongst them\\n\\t// along with adding the new interval to the children if it overlaps\\n    this.left = new TreeNode(this.min, mid);\\n    this.right = new TreeNode(mid + 1, this.max);\\n    \\n    if (left <= mid) this.left.addInterval(left, Math.min(mid, right));\\n    if (right > mid) this.right.addInterval(Math.max(left, mid + 1), right);\\n    if (this.currentMin <= mid) this.left.addInterval(this.currentMin, Math.min(mid, this.currentMax));\\n    if (this.currentMax > mid) this.right.addInterval(Math.max(mid + 1, this.currentMin), this.currentMax);\\n    \\n    this.total = this.left.total + this.right.total;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040825,
                "title": "c-implicit-segment-tree-19-lines-add-o-log-max-count-o-1",
                "content": "This task could be solved by **SegmentTree** ([Range updates (Lazy Propagation)](https://cp-algorithms.com/data_structures/segment_tree.html#range-updates-lazy-propagation)), if not for the `1 <= left <= right <= 10^9`. \\nBut we can use **Implicit Segment Tree** (the idea can be found here [Implicit segment tree](https://cp-algorithms.com/data_structures/segment_tree.html#implicit-segment-tree)).\\nThis is my implementation specialized for this task, it turned out to be quite short.\\n\\n```\\npublic class CountIntervals \\n{\\n    private class SegmentTreeNode \\n    {\\n        private int _begin, _end;\\n        private SegmentTreeNode _leftNode = null, _rightNode = null;\\n        \\n        public int Count { get; private set; }\\n        \\n        public SegmentTreeNode(int begin, int end) => (_begin, _end) = (begin, end);\\n\\n        public int Add(int l, int r) \\n        {\\n            if (l > r || l > _end || r < _begin) return Count;\\n            if ((l == _begin && r == _end) || Count == _end - _begin + 1) return Count = _end - _begin + 1;\\n            \\n            int middle = _begin + (_end - _begin) / 2;\\n            \\n            _leftNode = _leftNode ?? new SegmentTreeNode(_begin, middle);\\n            _rightNode = _rightNode ?? new SegmentTreeNode(middle + 1, _end);\\n            \\n            return Count = _leftNode.Add(l, Math.Min(middle, r)) + _rightNode.Add(Math.Max(l, middle + 1), r);\\n        }\\n    }\\n    \\n    private SegmentTreeNode _root = new(1, 1_000_000_000);\\n    \\n    public void Add(int left, int right) => _root.Add(left, right);\\n    \\n    public int Count() => _root.Count;\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\npublic class CountIntervals \\n{\\n    private class SegmentTreeNode \\n    {\\n        private int _begin, _end;\\n        private SegmentTreeNode _leftNode = null, _rightNode = null;\\n        \\n        public int Count { get; private set; }\\n        \\n        public SegmentTreeNode(int begin, int end) => (_begin, _end) = (begin, end);\\n\\n        public int Add(int l, int r) \\n        {\\n            if (l > r || l > _end || r < _begin) return Count;\\n            if ((l == _begin && r == _end) || Count == _end - _begin + 1) return Count = _end - _begin + 1;\\n            \\n            int middle = _begin + (_end - _begin) / 2;\\n            \\n            _leftNode = _leftNode ?? new SegmentTreeNode(_begin, middle);\\n            _rightNode = _rightNode ?? new SegmentTreeNode(middle + 1, _end);\\n            \\n            return Count = _leftNode.Add(l, Math.Min(middle, r)) + _rightNode.Add(Math.Max(l, middle + 1), r);\\n        }\\n    }\\n    \\n    private SegmentTreeNode _root = new(1, 1_000_000_000);\\n    \\n    public void Add(int left, int right) => _root.Add(left, right);\\n    \\n    public int Count() => _root.Count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040710,
                "title": "javascript-treemap-1650ms",
                "content": "```\\n///////////////////////////////////////////////////// Template /////////////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\n/*\\nusage:\\nlet ts = new TreeMap();\\nlet ts = new TreeMap([[3, 1], [7, 1], [7, 2], [1, 1], [3, 2]]); // Map { 1 => 1, 3 => 2, 7 => 2 }  (console.log(ts.show()))\\n*/\\nfunction TreeMap(g) {\\n    let ts = [], m = new Map(), bisect = new Bisect();\\n    initialize();\\n    return { put, ceilingKey, higherKey, lowerKey, floorKey, ceilingEntry, higherEntry, lowerEntry, floorEntry, remove, contains, size, clear, show };\\n    function initialize() {\\n        if (g) {\\n            for (const [k, v] of g) {\\n                if (!m.has(k)) bisect.insort_right(ts, k);\\n                m.set(k, v);\\n            }\\n        }\\n    }\\n    function put(k, v) {\\n        if (!m.has(k)) bisect.insort_right(ts, k); // ts has no duplicates/unique key\\n        m.set(k, v); // update key with most recent value\\n    }\\n    function ceilingKey(e) { // >= lower_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx - 1] == e ? e : ts[bisect.bisect_right(ts, e)];\\n        return res == undefined ? null : res;\\n    }\\n    function higherKey(e) { // > upper_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx] > e ? ts[idx] : ts[bisect.bisect_right(ts, e) + 1];\\n        return res == undefined ? null : res;\\n    }\\n    function floorKey(e) { // <= \\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] == e ? e : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function lowerKey(e) { // <\\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] < e ? ts[idx] : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function data(k) {\\n        return k == null ? null : { key: k, value: m.get(k) }\\n    }\\n    function ceilingEntry(k) {\\n        return data(ceilingKey(k));\\n    }\\n    function higherEntry(k) {\\n        return data(higherKey(k));\\n    }\\n    function floorEntry(k) {\\n        return data(floorKey(k));\\n    }\\n    function lowerEntry(k) {\\n        return data(lowerKey(k));\\n    }\\n    function remove(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) ts.splice(idx, 1);\\n        m.delete(e);\\n    }\\n    function contains(e) {\\n        return m.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function clear() {\\n        ts = [];\\n        m.clear();\\n    }\\n    function show() {\\n        let res = new Map();\\n        for (const x of ts) res.set(x, m.get(x));\\n        return res;\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfunction CountIntervals() {\\n    let tm = new TreeMap(), cnt = 0;\\n    return { add, count }\\n    function add(left, right) {\\n        let lower = tm.floorEntry(left);\\n        if (lower != null && lower.value >= left) {\\n            let k = lower.key, v = lower.value;\\n            cnt -= v - k + 1;\\n            left = Math.min(left, k);\\n            right = Math.max(right, v);\\n            tm.remove(k);\\n        }\\n        while (1) {\\n           let higher = tm.ceilingEntry(left);\\n           if (higher == null || higher.key > right) break;\\n           let k = higher.key, v = higher.value;\\n           tm.remove(k);\\n           cnt -= v - k + 1;\\n           right = Math.max(right, v);\\n        }\\n        cnt += right - left + 1;\\n        tm.put(left, right);\\n    }\\n    function count() {\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\n///////////////////////////////////////////////////// Template /////////////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\n/*\\nusage:\\nlet ts = new TreeMap();\\nlet ts = new TreeMap([[3, 1], [7, 1], [7, 2], [1, 1], [3, 2]]); // Map { 1 => 1, 3 => 2, 7 => 2 }  (console.log(ts.show()))\\n*/\\nfunction TreeMap(g) {\\n    let ts = [], m = new Map(), bisect = new Bisect();\\n    initialize();\\n    return { put, ceilingKey, higherKey, lowerKey, floorKey, ceilingEntry, higherEntry, lowerEntry, floorEntry, remove, contains, size, clear, show };\\n    function initialize() {\\n        if (g) {\\n            for (const [k, v] of g) {\\n                if (!m.has(k)) bisect.insort_right(ts, k);\\n                m.set(k, v);\\n            }\\n        }\\n    }\\n    function put(k, v) {\\n        if (!m.has(k)) bisect.insort_right(ts, k); // ts has no duplicates/unique key\\n        m.set(k, v); // update key with most recent value\\n    }\\n    function ceilingKey(e) { // >= lower_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx - 1] == e ? e : ts[bisect.bisect_right(ts, e)];\\n        return res == undefined ? null : res;\\n    }\\n    function higherKey(e) { // > upper_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx] > e ? ts[idx] : ts[bisect.bisect_right(ts, e) + 1];\\n        return res == undefined ? null : res;\\n    }\\n    function floorKey(e) { // <= \\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] == e ? e : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function lowerKey(e) { // <\\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] < e ? ts[idx] : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function data(k) {\\n        return k == null ? null : { key: k, value: m.get(k) }\\n    }\\n    function ceilingEntry(k) {\\n        return data(ceilingKey(k));\\n    }\\n    function higherEntry(k) {\\n        return data(higherKey(k));\\n    }\\n    function floorEntry(k) {\\n        return data(floorKey(k));\\n    }\\n    function lowerEntry(k) {\\n        return data(lowerKey(k));\\n    }\\n    function remove(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) ts.splice(idx, 1);\\n        m.delete(e);\\n    }\\n    function contains(e) {\\n        return m.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function clear() {\\n        ts = [];\\n        m.clear();\\n    }\\n    function show() {\\n        let res = new Map();\\n        for (const x of ts) res.set(x, m.get(x));\\n        return res;\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfunction CountIntervals() {\\n    let tm = new TreeMap(), cnt = 0;\\n    return { add, count }\\n    function add(left, right) {\\n        let lower = tm.floorEntry(left);\\n        if (lower != null && lower.value >= left) {\\n            let k = lower.key, v = lower.value;\\n            cnt -= v - k + 1;\\n            left = Math.min(left, k);\\n            right = Math.max(right, v);\\n            tm.remove(k);\\n        }\\n        while (1) {\\n           let higher = tm.ceilingEntry(left);\\n           if (higher == null || higher.key > right) break;\\n           let k = higher.key, v = higher.value;\\n           tm.remove(k);\\n           cnt -= v - k + 1;\\n           right = Math.max(right, v);\\n        }\\n        cnt += right - left + 1;\\n        tm.put(left, right);\\n    }\\n    function count() {\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2811351,
                "title": "java-interval-tree-based-on-self-balancing-avl-bst",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/trees/CountIntervals.java",
                "solutionTags": [
                    "Java"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2363373,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Map***\\n\\n* ***Time Complexity :- O(logN) in best case and O(N) in worst case for add operation***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass CountIntervals {\\npublic:\\n    \\n    map<int, int> mp;\\n    \\n    int total_count = 0;\\n    \\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        \\n        // find the upper bound of left in map\\n        \\n        auto it = mp.upper_bound(left);\\n        \\n        // check if previous interval is overlapping with new_interval\\n        \\n        if(it != mp.begin() && left <= prev(it) -> second)\\n        {\\n            it = prev(it);\\n        }\\n        \\n        // delete the overlapping intervals and update total_count\\n        \\n        while(it != mp.end() && it -> first <= right)\\n        {\\n            // update left \\n            \\n            left = min(left, it -> first);\\n            \\n            // update right\\n            \\n            right = max(right, it -> second);\\n            \\n            // update count\\n            \\n            total_count -= it -> second - it -> first + 1;\\n            \\n            // erase the current interval and update pointer\\n            \\n            it = mp.erase(it);\\n        }\\n        \\n        // push into map\\n        \\n        mp[left] = right;\\n        \\n        // update total_count\\n        \\n        total_count += right - left + 1;\\n    }\\n    \\n    int count() {\\n        \\n        return total_count;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    \\n    map<int, int> mp;\\n    \\n    int total_count = 0;\\n    \\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        \\n        // find the upper bound of left in map\\n        \\n        auto it = mp.upper_bound(left);\\n        \\n        // check if previous interval is overlapping with new_interval\\n        \\n        if(it != mp.begin() && left <= prev(it) -> second)\\n        {\\n            it = prev(it);\\n        }\\n        \\n        // delete the overlapping intervals and update total_count\\n        \\n        while(it != mp.end() && it -> first <= right)\\n        {\\n            // update left \\n            \\n            left = min(left, it -> first);\\n            \\n            // update right\\n            \\n            right = max(right, it -> second);\\n            \\n            // update count\\n            \\n            total_count -= it -> second - it -> first + 1;\\n            \\n            // erase the current interval and update pointer\\n            \\n            it = mp.erase(it);\\n        }\\n        \\n        // push into map\\n        \\n        mp[left] = right;\\n        \\n        // update total_count\\n        \\n        total_count += right - left + 1;\\n    }\\n    \\n    int count() {\\n        \\n        return total_count;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189307,
                "title": "c-segment-tree-solution",
                "content": "I thought for this question my solution worth to be posted, I used segment tree to solved this problem, in the first glance is not possible to solve this problem using regular segment tree as your segment is from 0 to 10^9. The point that we should consider is that we have only 10^5 queries so it is possible to make the regular segment tree using map(note that we can\\'t have an array with size 10^9). After building our segment, our add and get function will be pretty straight forward, seg[v] equals the number of elements in subtree of v. Obviously the solution to each count is the number of elements in the root or seg[1]. Please ask me if you have any question about this solution.\\n```\\nclass CountIntervals {\\npublic:\\n    unordered_map<int, int> seg;\\n    void update(int l, int r, int v = 1, int s = 0, int e = 1000000000)\\n    {\\n        if (l <= s && e <= r)\\n        {\\n            seg[v] = (e - s);\\n            return;\\n        }\\n        if (r <= s || e <= l)\\n        {\\n            return;\\n        }\\n        if (seg[v] == e - s)\\n            return;\\n        int mid = (e + s) / 2;\\n        int lc = 2 * v;\\n        int rc = lc + 1;\\n        update(l, r, lc, s, mid);\\n        update(l, r, rc, mid, e);\\n        seg[v] = seg[lc] + seg[rc];\\n    }\\n    CountIntervals() {\\n        seg[0] = 0;\\n    }\\n    void add(int left, int right) {\\n        update(left - 1, right);\\n    }\\n    \\n    int count() {\\n        return seg[1];\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n ```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    unordered_map<int, int> seg;\\n    void update(int l, int r, int v = 1, int s = 0, int e = 1000000000)\\n    {\\n        if (l <= s && e <= r)\\n        {\\n            seg[v] = (e - s);\\n            return;\\n        }\\n        if (r <= s || e <= l)\\n        {\\n            return;\\n        }\\n        if (seg[v] == e - s)\\n            return;\\n        int mid = (e + s) / 2;\\n        int lc = 2 * v;\\n        int rc = lc + 1;\\n        update(l, r, lc, s, mid);\\n        update(l, r, rc, mid, e);\\n        seg[v] = seg[lc] + seg[rc];\\n    }\\n    CountIntervals() {\\n        seg[0] = 0;\\n    }\\n    void add(int left, int right) {\\n        update(left - 1, right);\\n    }\\n    \\n    int count() {\\n        return seg[1];\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2161703,
                "title": "c-set-binary-search-solution",
                "content": "**Task: Implement a data structure which allows you to merge intervals, and gives the count of the number of integers that belong atleast to a single range.**\\n\\n**Approach:**\\nSo, notice that these type of problems involve merging segments/ranges.\\nWe begin by taking a set of pairs which would hold the \"disjoint\" segments inside of it. Notice that we would always be having disjoint segments in our set, so:\\nr1 < l2, r2 < l3 .. and so on.\\n\\nNow, whenever we get a new segment that has to be added to our data structure, we firstly check whether it is overlapping with any of our existing segments, and try to merge this new segment with the existing segments.\\n\\nHow do you check which existing segments overlap with our current segment?\\nWe use binary search to find out the first segment in the set which might be overlapping with the new segment.\\nWe just take the lower bound of \"left\" on the set, and decrease the iterator (think why we\\'re decreasing the iterator here).\\nThen, we keep iterating until we find a non-overlapping segment.\\nWe then erase the existing segments that overlap with the new segment, and add the newly updated segment into the set. \\n\\nCode: \\n```\\nclass CountIntervals {\\npublic:\\n    CountIntervals() {\\n        \\n    }\\n    \\n    set<pair<int,int>> s;\\n    int cnt = 0;\\n    \\n    void add(int left, int right) {\\n        auto it = s.lower_bound({left, 0});\\n        if(it != s.begin()) it--;\\n        vector<pair<int,int>> to_erase;\\n        int newl = left, newr = right;\\n        while(it != s.end()){\\n            //check whether *it overlaps with our new seg or not\\n            pair<int,int> p = *it;\\n            if(p.first > right) break;\\n            if(!(right < p.first || p.second < left)){\\n                to_erase.push_back(p);\\n                newl = min(p.first, newl), newr = max(p.second, newr);\\n            }\\n            it++;\\n        }\\n        for(auto p : to_erase){\\n            cnt -= (p.second - p.first + 1);\\n            s.erase(p);\\n        }\\n        cnt += (newr - newl + 1);\\n        s.insert({newl, newr});\\n        \\n        // Debugging\\n        // for(auto p : s){\\n        //     cout << p.first << \" \" << p.second << endl;\\n        // }\\n        // cout << cnt << endl;\\n        // cout << endl;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```\\n\\n**Takeaways**: \\nHow do you check whether two segments (l1, r1) and (l2, r2) are overlapping or not?\\nIf: r1 < l1 (or) r2 < l2, then the two segments are non-overlapping\\nelse: overlapping",
                "solutionTags": [
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    CountIntervals() {\\n        \\n    }\\n    \\n    set<pair<int,int>> s;\\n    int cnt = 0;\\n    \\n    void add(int left, int right) {\\n        auto it = s.lower_bound({left, 0});\\n        if(it != s.begin()) it--;\\n        vector<pair<int,int>> to_erase;\\n        int newl = left, newr = right;\\n        while(it != s.end()){\\n            //check whether *it overlaps with our new seg or not\\n            pair<int,int> p = *it;\\n            if(p.first > right) break;\\n            if(!(right < p.first || p.second < left)){\\n                to_erase.push_back(p);\\n                newl = min(p.first, newl), newr = max(p.second, newr);\\n            }\\n            it++;\\n        }\\n        for(auto p : to_erase){\\n            cnt -= (p.second - p.first + 1);\\n            s.erase(p);\\n        }\\n        cnt += (newr - newl + 1);\\n        s.insert({newl, newr});\\n        \\n        // Debugging\\n        // for(auto p : s){\\n        //     cout << p.first << \" \" << p.second << endl;\\n        // }\\n        // cout << cnt << endl;\\n        // cout << endl;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2046787,
                "title": "c-segment-tree",
                "content": "only need to insert the range\\n1. if range is aleady there, early return\\n2. add -> time complexity O(n*log( |ai| )), |ai| is the range of value domain, n is the # of add operations\\n3. count ->  time = O(1) \\n\\n```\\n\\nstruct node{\\n    int start, end, val;\\n    node* left, *right;\\n    node(int start, int end, int val) : start(start), end(end), val(val), left(nullptr), right(nullptr){\\n        \\n    }\\n};\\n\\nclass CountIntervals {\\n    node* root;\\n    \\n    void update(node* n, int start, int end){\\n        if(n->start > end || n->end < start) \\n            return;\\n        \\n        if(n->val == (  n->end - n->start + 1) ) return;\\n        \\n        if(n->start >= start && n->end <= end){\\n            n->val = n->end - n->start +1;\\n            return;\\n        }\\n        \\n        int mid = (n->start + n->end)>>1;\\n        if(!n->left){\\n            n->left = new node(n->start, mid, 0);\\n        }\\n        if(!n->right){\\n            n->right = new node(mid+1, n->end, 0);\\n        }\\n        update(n->left, start, end);\\n        update(n->right, start, end);\\n        n->val = n->left->val + n->right->val;\\n    }\\n    \\npublic:\\n    CountIntervals() {\\n        root = new node(1, 1e9, 0);\\n    }\\n    \\n    void add(int left, int right) {\\n        update(root, left, right);\\n    }\\n    \\n    int count() {\\n        return root->val;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n\\nstruct node{\\n    int start, end, val;\\n    node* left, *right;\\n    node(int start, int end, int val) : start(start), end(end), val(val), left(nullptr), right(nullptr){\\n        \\n    }\\n};\\n\\nclass CountIntervals {\\n    node* root;\\n    \\n    void update(node* n, int start, int end){\\n        if(n->start > end || n->end < start) \\n            return;\\n        \\n        if(n->val == (  n->end - n->start + 1) ) return;\\n        \\n        if(n->start >= start && n->end <= end){\\n            n->val = n->end - n->start +1;\\n            return;\\n        }\\n        \\n        int mid = (n->start + n->end)>>1;\\n        if(!n->left){\\n            n->left = new node(n->start, mid, 0);\\n        }\\n        if(!n->right){\\n            n->right = new node(mid+1, n->end, 0);\\n        }\\n        update(n->left, start, end);\\n        update(n->right, start, end);\\n        n->val = n->left->val + n->right->val;\\n    }\\n    \\npublic:\\n    CountIntervals() {\\n        root = new node(1, 1e9, 0);\\n    }\\n    \\n    void add(int left, int right) {\\n        update(root, left, right);\\n    }\\n    \\n    int count() {\\n        return root->val;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042852,
                "title": "java-object-oriented-treeset-using-ceiling-and-floor-o-n-log-n-for-each-insert",
                "content": "This question uses components of https://leetcode.com/problems/insert-interval/.\\nHowever there is one difference. \"Insert Interval\" asks us to insert only one element. So I used a stack, and inserted. And it worked. Using a stack is O(n)\\nHowever doing same in this question leads to Time Limit Exceeded.\\n\\nAn alternative to using stack is using a Tree data structure.\\nWhy? Because tree will help me do binary search in O(log n) time. So I can find any interval or my place among intervals in O(log n).\\nFunctions I will use are floor() and ceiling(). Please read about floor() and ceiling() here: https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html.\\n\\nAssumption: I will sort all intervals using \"start\".\\n\\nInsertion steps for newInterval:\\n1. Datastructure: TreeSet. \\n1. find floor() value for newInterval\\n\\ta. is previous mergeable into me? (previous.end >= newInterval.start)? \\n\\tb. YES: then remove previous and merge into newInterval.\\n2. now I may merge intervals coming after me\\n\\ta. for each interval after me\\n\\t\\t- is next mergable into me?\\n\\t\\t- YES: remove next and merge it into newInterval\\n3. Since all the elements mergeable into me are merged, just insert me into Tree.\\n\\nCode has two classes\\nclass Interval - holds start, end, length, and has functions isMergeable() and merge().\\nclass Solution - holds treeset, add() and count().\\n\\nInterval class\\n```\\nclass Interval implements Comparable<Interval> {\\n    int start;\\n    int end;\\n    int len;\\n    public Interval(int start, int end) {\\n        this.start = start;\\n        this.end = end;\\n        this.len = end - start + 1;\\n    }\\n    \\n    public void merge(Interval other) {\\n        start = Integer.min(start, other.start);\\n        end = Integer.max(end, other.end);\\n        len = end - start + 1;\\n    }\\n    \\n    public boolean isMergable(Interval other) {\\n        return (start <= other.start && other.start <= end) \\n            || (start <= other.end && other.end <= end) \\n            || (other.start <= start && end <= other.end);\\n    }\\n    \\n    public int compareTo(Interval other) {\\n        if(start == other.start) {\\n            return end - other.end;\\n        } else {\\n            return start - other.start;\\n        }\\n    }\\n}\\n```\\n\\nAnd the solution class\\n```\\nclass CountIntervals {\\n    TreeSet<Interval> ts = new TreeSet();\\n    int count = 0;\\n    \\n    public void add(int left, int right) {\\n        Interval newInterval = new Interval(left, right);\\n\\n        // I may get merged into previous interval if my start < previous\\' end.\\n        Interval prev = ts.floor(newInterval);\\n        if(prev != null && newInterval.isMergable(prev)) {\\n            count -= prev.len;\\n            ts.remove(prev);\\n            newInterval.merge(prev);\\n        }\\n\\n        // I may get merged into next interval(s) if my end > their start.\\n        while(true) {\\n            Interval next = ts.ceiling(newInterval);\\n            if(next != null && newInterval.isMergable(next)) {\\n                count -= next.len;\\n                ts.remove(next);\\n                newInterval.merge(next);\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        ts.add(newInterval);\\n        count += newInterval.len;   \\n    }\\n\\n    public int count() {\\n        return count;\\n    }\\n}\\n```\\n\\nNow what is effective time complexity for each insertion?\\nIt is O(log n) for floor(), ceiling(), remove() and insert().\\nBut notice the infinite while loop - it runs for all elements after my start, that are mergeable into me. In worst case, that will happen to all the n elements present in Tree. \\nSo for insertion, worst case time complexity is O(n log n).\\n\\nRemember that using stack has time complexity O(n)\\nThis is worse than using a stack. However remember that \"big O\" time complexity only tells about worst case and cannot be always used to judge the best solution.",
                "solutionTags": [],
                "code": "```\\nclass Interval implements Comparable<Interval> {\\n    int start;\\n    int end;\\n    int len;\\n    public Interval(int start, int end) {\\n        this.start = start;\\n        this.end = end;\\n        this.len = end - start + 1;\\n    }\\n    \\n    public void merge(Interval other) {\\n        start = Integer.min(start, other.start);\\n        end = Integer.max(end, other.end);\\n        len = end - start + 1;\\n    }\\n    \\n    public boolean isMergable(Interval other) {\\n        return (start <= other.start && other.start <= end) \\n            || (start <= other.end && other.end <= end) \\n            || (other.start <= start && end <= other.end);\\n    }\\n    \\n    public int compareTo(Interval other) {\\n        if(start == other.start) {\\n            return end - other.end;\\n        } else {\\n            return start - other.start;\\n        }\\n    }\\n}\\n```\n```\\nclass CountIntervals {\\n    TreeSet<Interval> ts = new TreeSet();\\n    int count = 0;\\n    \\n    public void add(int left, int right) {\\n        Interval newInterval = new Interval(left, right);\\n\\n        // I may get merged into previous interval if my start < previous\\' end.\\n        Interval prev = ts.floor(newInterval);\\n        if(prev != null && newInterval.isMergable(prev)) {\\n            count -= prev.len;\\n            ts.remove(prev);\\n            newInterval.merge(prev);\\n        }\\n\\n        // I may get merged into next interval(s) if my end > their start.\\n        while(true) {\\n            Interval next = ts.ceiling(newInterval);\\n            if(next != null && newInterval.isMergable(next)) {\\n                count -= next.len;\\n                ts.remove(next);\\n                newInterval.merge(next);\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        ts.add(newInterval);\\n        count += newInterval.len;   \\n    }\\n\\n    public int count() {\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040171,
                "title": "easy-short-c",
                "content": "\\tclass CountIntervals {\\n\\tpublic:\\n\\t\\tset<pair<int,int>>s;\\n\\t\\tint cnt = 0;\\n\\t\\tCountIntervals() {\\n\\n\\t\\t}\\n\\n\\t\\tvoid add(int left, int right) {\\n\\t\\t\\tauto it = s.upper_bound({left,-1});\\n\\t\\t\\tif(it!=begin(s) and (--it)->second<left) ++it;\\n\\n\\t\\t\\twhile(it!=end(s) and it->first<=right){\\n\\t\\t\\t\\tleft = min(left,it->first);\\n\\t\\t\\t\\tright = max(right,it->second);\\n\\t\\t\\t\\tcnt-=(it->second-it->first)+1;\\n\\t\\t\\t\\tit = s.erase(it);\\n\\t\\t\\t}\\n\\t\\t\\tcnt+=(right-left+1);\\n\\t\\t\\ts.insert({left,right});\\n\\t\\t}\\n\\n\\t\\tint count() {\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass CountIntervals {\\n\\tpublic:\\n\\t\\tset<pair<int,int>>s;\\n\\t\\tint cnt = 0;\\n\\t\\tCountIntervals() {\\n\\n\\t\\t}\\n\\n\\t\\tvoid add(int left, int right) {\\n\\t\\t\\tauto it = s.upper_bound({left,-1});\\n\\t\\t\\tif(it!=begin(s) and (--it)->second<left) ++it;\\n\\n\\t\\t\\twhile(it!=end(s) and it->first<=right){\\n\\t\\t\\t\\tleft = min(left,it->first);\\n\\t\\t\\t\\tright = max(right,it->second);\\n\\t\\t\\t\\tcnt-=(it->second-it->first)+1;\\n\\t\\t\\t\\tit = s.erase(it);\\n\\t\\t\\t}\\n\\t\\t\\tcnt+=(right-left+1);\\n\\t\\t\\ts.insert({left,right});\\n\\t\\t}\\n\\n\\t\\tint count() {\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2040090,
                "title": "stupid-python-sorteddict",
                "content": "I understand that in python, SortedDict is alter of TreeMap.\\nBut why there isn\\'t floorEntity or cellingEntity?  That makes me feel stupid.\\nShould I use Java next time when it comes? or I just use floorEntity anyway in python in real interview?\\n\\n```\\nfrom sortedcontainers import SortedDict\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.SD = SortedDict()\\n        self.total = 0\\n\\t\\t\\n\\t# from the right most of insert, merge all saved lefts that less than it, until no next left or no overlapping next left.\\n\\t# (reason we choose R to L is, R is natually \\'hiden\\' in treemap and not able to bisect.\\n\\t# E.g   we insert with right 8, so for 5 - 9, floor of 8 (5) is what we just need for merging from right to left.\\n    def add(self, left: int, right: int) -> None:\\n\\t\\t# Added 1 here, as I hope \\'right\\' means \"the just next one of the current interval\", it\\'s easier with \\'-\\'.\\n        right += 1 \\n        while True:\\n            i = self.SD.bisect_right(right) -1 # that bisect_right is inferior to floorEntity in TreeMap\\n            if i < 0:\\n                break\\n            savedLeft, savedRight = self.SD.peekitem(i)\\n            if savedRight < left:\\n                break\\n            \\n            self.total -= (savedRight -savedLeft)\\n            self.SD.popitem(i)\\n            left = min(left, savedLeft)\\n            right = max(right, savedRight)\\n            \\n        self.total += (right - left)\\n        self.SD[left] = right\\n\\n    def count(self) -> int:\\n        return self.total\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nfrom sortedcontainers import SortedDict\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.SD = SortedDict()\\n        self.total = 0\\n\\t\\t\\n\\t# from the right most of insert, merge all saved lefts that less than it, until no next left or no overlapping next left.\\n\\t# (reason we choose R to L is, R is natually \\'hiden\\' in treemap and not able to bisect.\\n\\t# E.g   we insert with right 8, so for 5 - 9, floor of 8 (5) is what we just need for merging from right to left.\\n    def add(self, left: int, right: int) -> None:\\n\\t\\t# Added 1 here, as I hope \\'right\\' means \"the just next one of the current interval\", it\\'s easier with \\'-\\'.\\n        right += 1 \\n        while True:\\n            i = self.SD.bisect_right(right) -1 # that bisect_right is inferior to floorEntity in TreeMap\\n            if i < 0:\\n                break\\n            savedLeft, savedRight = self.SD.peekitem(i)\\n            if savedRight < left:\\n                break\\n            \\n            self.total -= (savedRight -savedLeft)\\n            self.SD.popitem(i)\\n            left = min(left, savedLeft)\\n            right = max(right, savedRight)\\n            \\n        self.total += (right - left)\\n        self.SD[left] = right\\n\\n    def count(self) -> int:\\n        return self.total\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2039798,
                "title": "c-o-n-log-n-simple-merge-intervals-with-multimap",
                "content": "This problem can be solved by maintaining non-intersected intervals and counting all covered integers when a new interval is added. When it is added:\\n1. Just add the new interval, and increase `cnt` by the new interval size.\\n2. Handle all introduced intersections:\\n\\t2.1 start with `previous` interval - it is the first which can be affected\\n\\t2.2 while current interval start is <= `right` - check it, and if it is intersected with the next interval - fix this, maintain `cnt` at the same time.\\n\\n`multimap<int, int>` is handy here.\\n\\n```cpp\\nclass CountIntervals {\\n    multimap<int, int> mm;\\n    int cnt = 0;\\npublic:\\n    void add(int left, int right) {\\n        cnt += right - left + 1;\\n        mm.insert({left, right + 1});\\n        \\n        auto it = mm.lower_bound(left);\\n        if (it != mm.begin()) {\\n            it = prev(it);\\n        }\\n        while (it != mm.end() && it->first <= right) {\\n            auto nextIt = next(it);\\n            if (nextIt == mm.end()) break;\\n            \\n            if (it->second >= nextIt->first) {\\n                if (it->second >= nextIt->second) {\\n                    cnt -= (nextIt->second - nextIt->first);\\n                } else {\\n                    cnt -= (it->second - nextIt->first);\\n                    it->second = nextIt->second;\\n                }\\n                mm.erase(nextIt);\\n            } else {\\n                it = next(it);\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass CountIntervals {\\n    multimap<int, int> mm;\\n    int cnt = 0;\\npublic:\\n    void add(int left, int right) {\\n        cnt += right - left + 1;\\n        mm.insert({left, right + 1});\\n        \\n        auto it = mm.lower_bound(left);\\n        if (it != mm.begin()) {\\n            it = prev(it);\\n        }\\n        while (it != mm.end() && it->first <= right) {\\n            auto nextIt = next(it);\\n            if (nextIt == mm.end()) break;\\n            \\n            if (it->second >= nextIt->first) {\\n                if (it->second >= nextIt->second) {\\n                    cnt -= (nextIt->second - nextIt->first);\\n                } else {\\n                    cnt -= (it->second - nextIt->first);\\n                    it->second = nextIt->second;\\n                }\\n                mm.erase(nextIt);\\n            } else {\\n                it = next(it);\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039753,
                "title": "c-merging-intervals-using-set",
                "content": "```\\nusing pii = pair<int,int>;\\nconst int inf = 1e9+7;\\n\\nclass CountIntervals {\\npublic:\\n  set<pii> s;\\n  int cnt = 0 ;\\n  CountIntervals() {\\n    // Give some boundary for safety. \\n    s.insert({-1,-1});   \\n    s.insert({inf,inf}); \\n  }\\n\\n  // Note that each interval inserted by a single call of add(int left, int right) can be removed at most once. \\n  // So the overall complexity is O(nlogn).\\n  void add(int left, int right) {\\n    auto it = s.lower_bound({left,0});  // look for an interval with smallest l s.t. left <= l\\n    int l,r;  // the left end and the right end of to-be-inserted interval {l,r}\\n    l = left; \\n    r = right;\\n    if (it!=s.begin()) { // if there is an interval left side of it\\n      auto temp = prev(it);\\n      if ((*temp).second >= left) { // check if the cur.r >= left \\n        l = (*temp).first;          // l should be updated \\n        it = temp;\\n      }\\n    }\\n    while (it != s.end()) {  // traverse through the set of intervals\\n      if ((*it).second <= right) {  // the entire interval is included in [left,right]\\n        auto [ll,rr] = *it;\\n        cnt -= rr-ll+1;             // update cnt\\n        auto temp = next(it);\\n        s.erase(it);                // remove current interval represented by it\\n        it = temp;\\n      }  \\n      else {                         // the entire interval is not included in [left,right]\\n        if ((*it).first > right) {   // current interval represented by it does not overlap with to-be-inserted interval {l,r}\\n          break;\\n        }\\n        else {                       // current interval represented by it overlaps with to-be-inserted interval, so we update r\\n          r = ((*it).second);\\n          auto [ll,rr] = *it;\\n          cnt -= rr-ll+1;           // update cnt\\n          s.erase(it);              // remove current interval represented by it\\n          break;\\n        }\\n      }\\n    }\\n    s.insert({l,r});          // finally insert what we have prepared so far.\\n    cnt += r-l+1;             // update cnt\\n  }\\n\\n  int count() {\\n      return cnt;\\n  }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n ```\\n \\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nusing pii = pair<int,int>;\\nconst int inf = 1e9+7;\\n\\nclass CountIntervals {\\npublic:\\n  set<pii> s;\\n  int cnt = 0 ;\\n  CountIntervals() {\\n    // Give some boundary for safety. \\n    s.insert({-1,-1});   \\n    s.insert({inf,inf}); \\n  }\\n\\n  // Note that each interval inserted by a single call of add(int left, int right) can be removed at most once. \\n  // So the overall complexity is O(nlogn).\\n  void add(int left, int right) {\\n    auto it = s.lower_bound({left,0});  // look for an interval with smallest l s.t. left <= l\\n    int l,r;  // the left end and the right end of to-be-inserted interval {l,r}\\n    l = left; \\n    r = right;\\n    if (it!=s.begin()) { // if there is an interval left side of it\\n      auto temp = prev(it);\\n      if ((*temp).second >= left) { // check if the cur.r >= left \\n        l = (*temp).first;          // l should be updated \\n        it = temp;\\n      }\\n    }\\n    while (it != s.end()) {  // traverse through the set of intervals\\n      if ((*it).second <= right) {  // the entire interval is included in [left,right]\\n        auto [ll,rr] = *it;\\n        cnt -= rr-ll+1;             // update cnt\\n        auto temp = next(it);\\n        s.erase(it);                // remove current interval represented by it\\n        it = temp;\\n      }  \\n      else {                         // the entire interval is not included in [left,right]\\n        if ((*it).first > right) {   // current interval represented by it does not overlap with to-be-inserted interval {l,r}\\n          break;\\n        }\\n        else {                       // current interval represented by it overlaps with to-be-inserted interval, so we update r\\n          r = ((*it).second);\\n          auto [ll,rr] = *it;\\n          cnt -= rr-ll+1;           // update cnt\\n          s.erase(it);              // remove current interval represented by it\\n          break;\\n        }\\n      }\\n    }\\n    s.insert({l,r});          // finally insert what we have prepared so far.\\n    cnt += r-l+1;             // update cnt\\n  }\\n\\n  int count() {\\n      return cnt;\\n  }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3393136,
                "title": "c-shortest-solution-set-with-custom-comparer",
                "content": "\\n```\\nclass CountIntervals {\\npublic:   \\n    void add(int left, int right) {\\n        const auto [lo, hi] = _s.equal_range(std::make_pair(left, ++right));\\n        if (lo != hi) {\\n            for (auto it = lo; it != hi; ++it)\\n                _count -= it->second - it->first;\\n            left = std::min(left, lo->first);\\n            right = std::max(right, std::prev(hi)->second);\\n            _s.erase(lo, hi);\\n        }\\n        _s.emplace(left, right);\\n        _count += right - left;\\n    }\\n    \\n    int count() const noexcept {\\n        return _count;\\n    }\\n\\nprivate:\\n    struct Comparer { bool operator () (const std::pair<int, int> & a, const std::pair<int, int> & b) const noexcept { return a.second < b.first; }; };\\n    std::set<std::pair<int, int>, Comparer> _s;\\n    int _count = 0;\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n```\\nclass CountIntervals {\\npublic:   \\n    void add(int left, int right) {\\n        const auto [lo, hi] = _s.equal_range(std::make_pair(left, ++right));\\n        if (lo != hi) {\\n            for (auto it = lo; it != hi; ++it)\\n                _count -= it->second - it->first;\\n            left = std::min(left, lo->first);\\n            right = std::max(right, std::prev(hi)->second);\\n            _s.erase(lo, hi);\\n        }\\n        _s.emplace(left, right);\\n        _count += right - left;\\n    }\\n    \\n    int count() const noexcept {\\n        return _count;\\n    }\\n\\nprivate:\\n    struct Comparer { bool operator () (const std::pair<int, int> & a, const std::pair<int, int> & b) const noexcept { return a.second < b.first; }; };\\n    std::set<std::pair<int, int>, Comparer> _s;\\n    int _count = 0;\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3371285,
                "title": "python-merge-intervals",
                "content": "1. We save non-overlapping intervals by two arrays, `self.L` and `self.R`. `[self.L[i], self.R[i]]` is the `i`th interval.\\n2. When a new interval `I = [left, right]` is added, use binary search to find:\\n\\t- `idx_l`: index of the first interval whose right endpoint >= `left`.\\n\\t- `idx_r`: index of the first interval whose left endpoint > `right` .\\nHere are some examples:\\n![image](https://assets.leetcode.com/users/images/1f6cfb34-b2b7-4b98-9963-249588b92a40_1680449623.203056.png)\\n\\t- case 1: `idx_l = 2, idx_r = 4`.\\n\\t- case 2: `idx_l = 1, idx_r = 4`.\\n\\t- case 3: `idx_l = 2, idx_r = 3`.\\n3. From `idx_r-1` to `idx_l`, pop the interval one by one. Each time an interval is popped out, merge it with `I`.\\n4. After all overlapping intervals are popped out, insert the merged `I`.\\n```\\nfrom bisect import bisect_left, bisect_right\\n\\nclass CountIntervals:\\n    def __init__(self):\\n        self.L = []\\n        self.R = []\\n        self.total = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        if not self.L:\\n            self.L.append(left)\\n            self.R.append(right)\\n            self.total += right-left+1\\n        else:\\n            idx_l, idx_r = bisect_left(self.R, left), bisect_right(self.L, right)\\n            lm, rm = left, right\\n            while idx_l < idx_r:\\n                l1 = self.L.pop(idx_r-1)\\n                r1 = self.R.pop(idx_r-1)\\n                self.total -= r1-l1+1\\n                lm = min(lm, l1)\\n                rm = max(rm, r1)\\n                idx_r -= 1\\n            self.L.insert(idx_l, lm)\\n            self.R.insert(idx_l, rm)\\n            self.total += rm-lm+1\\n        \\n    def count(self) -> int:\\n        return self.total",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. We save non-overlapping intervals by two arrays, `self.L` and `self.R`. `[self.L[i], self.R[i]]` is the `i`th interval.\\n2. When a new interval `I = [left, right]` is added, use binary search to find:\\n\\t- `idx_l`: index of the first interval whose right endpoint >= `left`.\\n\\t- `idx_r`: index of the first interval whose left endpoint > `right` .\\nHere are some examples:\\n![image](https://assets.leetcode.com/users/images/1f6cfb34-b2b7-4b98-9963-249588b92a40_1680449623.203056.png)\\n\\t- case 1: `idx_l = 2, idx_r = 4`.\\n\\t- case 2: `idx_l = 1, idx_r = 4`.\\n\\t- case 3: `idx_l = 2, idx_r = 3`.\\n3. From `idx_r-1` to `idx_l`, pop the interval one by one. Each time an interval is popped out, merge it with `I`.\\n4. After all overlapping intervals are popped out, insert the merged `I`.\\n```\\nfrom bisect import bisect_left, bisect_right\\n\\nclass CountIntervals:\\n    def __init__(self):\\n        self.L = []\\n        self.R = []\\n        self.total = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        if not self.L:\\n            self.L.append(left)\\n            self.R.append(right)\\n            self.total += right-left+1\\n        else:\\n            idx_l, idx_r = bisect_left(self.R, left), bisect_right(self.L, right)\\n            lm, rm = left, right\\n            while idx_l < idx_r:\\n                l1 = self.L.pop(idx_r-1)\\n                r1 = self.R.pop(idx_r-1)\\n                self.total -= r1-l1+1\\n                lm = min(lm, l1)\\n                rm = max(rm, r1)\\n                idx_r -= 1\\n            self.L.insert(idx_l, lm)\\n            self.R.insert(idx_l, rm)\\n            self.total += rm-lm+1\\n        \\n    def count(self) -> int:\\n        return self.total",
                "codeTag": "Java"
            },
            {
                "id": 3108167,
                "title": "c-very-easy-to-understand-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Total time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CountIntervals {\\npublic:\\n    multiset<pair<int, int>> setIntervals;\\n    int numIntegers = 0;\\n\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        setIntervals.insert({left, right});\\n        numIntegers += right - left + 1;\\n\\n        auto it = setIntervals.lower_bound({left, right});\\n        while (next(it) != setIntervals.end() && next(it)->first <= right) {\\n            it = mergeTwoIntervals(it, next(it));\\n        }\\n\\n        while (it != setIntervals.begin() && prev(it)->second >= left) {\\n            it = mergeTwoIntervals(prev(it), it);\\n        }\\n    }\\n\\n    multiset<pair<int, int>>::iterator mergeTwoIntervals(multiset<pair<int, int>>::iterator it1, multiset<pair<int, int>>::iterator it2) {\\n        int rightRangeDuplicate = min(it1->second, it2->second);\\n        int leftRangeDuplicate = max(it1->first, it2->first);\\n        int newRightRange = max(it1->second, it2->second);\\n        int newLeftRange = min(it1->first, it2->first);\\n        setIntervals.erase(it2);\\n        setIntervals.erase(it1);\\n        setIntervals.insert({newLeftRange, newRightRange});\\n        numIntegers -= rightRangeDuplicate - leftRangeDuplicate + 1;\\n        return setIntervals.lower_bound({newLeftRange, newRightRange});\\n    }\\n    \\n    int count() {\\n        return numIntegers;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    multiset<pair<int, int>> setIntervals;\\n    int numIntegers = 0;\\n\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        setIntervals.insert({left, right});\\n        numIntegers += right - left + 1;\\n\\n        auto it = setIntervals.lower_bound({left, right});\\n        while (next(it) != setIntervals.end() && next(it)->first <= right) {\\n            it = mergeTwoIntervals(it, next(it));\\n        }\\n\\n        while (it != setIntervals.begin() && prev(it)->second >= left) {\\n            it = mergeTwoIntervals(prev(it), it);\\n        }\\n    }\\n\\n    multiset<pair<int, int>>::iterator mergeTwoIntervals(multiset<pair<int, int>>::iterator it1, multiset<pair<int, int>>::iterator it2) {\\n        int rightRangeDuplicate = min(it1->second, it2->second);\\n        int leftRangeDuplicate = max(it1->first, it2->first);\\n        int newRightRange = max(it1->second, it2->second);\\n        int newLeftRange = min(it1->first, it2->first);\\n        setIntervals.erase(it2);\\n        setIntervals.erase(it1);\\n        setIntervals.insert({newLeftRange, newRightRange});\\n        numIntegers -= rightRangeDuplicate - leftRangeDuplicate + 1;\\n        return setIntervals.lower_bound({newLeftRange, newRightRange});\\n    }\\n    \\n    int count() {\\n        return numIntegers;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943204,
                "title": "python-easy-to-read-and-understand-merge-intervals",
                "content": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n\\n    def add(self, left: int, right: int) -> None:\\n        self.intervals.append([left, right])\\n        self.intervals.sort(key = lambda x:x[0])\\n        res = [self.intervals[0]]\\n        for u, v in self.intervals[1:]:\\n            if u <= res[-1][1]:\\n                res[-1][1] = max(res[-1][1], v)\\n            else:\\n                res.append([u, v])\\n        self.intervals = res.copy()\\n\\n    def count(self) -> int:\\n        res = 0\\n        for u, v in self.intervals:\\n            res += (v-u+1)\\n        return res\\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n\\n    def add(self, left: int, right: int) -> None:\\n        self.intervals.append([left, right])\\n        self.intervals.sort(key = lambda x:x[0])\\n        res = [self.intervals[0]]\\n        for u, v in self.intervals[1:]:\\n            if u <= res[-1][1]:\\n                res[-1][1] = max(res[-1][1], v)\\n            else:\\n                res.append([u, v])\\n        self.intervals = res.copy()\\n\\n    def count(self) -> int:\\n        res = 0\\n        for u, v in self.intervals:\\n            res += (v-u+1)\\n        return res\\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()",
                "codeTag": "Java"
            },
            {
                "id": 2732892,
                "title": "c-dynamic-segment-tree-implicit-online-search",
                "content": "\\n# Code\\n```\\npublic class CountIntervals {\\n    public class Node{\\n        public int l, r, add, cnt;\\n    }\\n    const int N = (int)1e9 + 7, M = 1000010;\\n    Node[] tr = new Node[M * 4];\\n    int pos = 1, st = 0;\\n\\n    public CountIntervals() {\\n\\n    }\\n    \\n    public void Add(int left, int right) {\\n        st++;\\n        Update(1, 1, N - 1, left, right, 1);\\n    }\\n    \\n    public int Count() {\\n        if(st == 0) return 0;\\n        return Query(1, 1, N - 1, 1, N - 1);\\n    }\\n\\n    public void PushUp(int u){\\n        tr[u].cnt = tr[tr[u].l].cnt + tr[tr[u].r].cnt;\\n    }\\n\\n    public void PushDown(int u, int len){\\n        if(tr[u] == null)\\n            tr[u] = new Node();\\n        if(tr[u].l == 0){\\n            tr[u].l = ++pos;\\n            tr[tr[u].l] = new Node();\\n        }\\n        if(tr[u].r == 0){\\n            tr[u].r = ++pos;\\n            tr[tr[u].r] = new Node();\\n        }\\n\\n        if(tr[u].add == 0) return;\\n        tr[tr[u].l].cnt = len - len / 2;\\n        tr[tr[u].r].cnt = len / 2;\\n        tr[tr[u].l].add = tr[tr[u].r].add = tr[u].add;\\n        tr[u].add = 0;\\n    }\\n\\n    public void Update(int u, int lc, int rc, int l, int r, int k){\\n        if(l <= lc && rc <= r){\\n            tr[u].add = k;\\n            tr[u].cnt = rc - lc + 1;\\n            return;\\n        }\\n\\n        PushDown(u, rc - lc + 1);\\n        int mid = rc + lc >> 1;\\n        if(mid >= l) Update(tr[u].l, lc, mid, l, r, k);\\n        if(mid < r) Update(tr[u].r, mid + 1, rc, l, r, k);\\n        PushUp(u);\\n    }\\n\\n    public int Query(int u, int lc, int rc, int l, int r){\\n        if(l <= lc && rc <= r)\\n            return tr[u].cnt;\\n        \\n        PushDown(u, rc - lc + 1);\\n        int mid = lc + rc >> 1, ans = 0;\\n        if(l <= mid) ans = Query(tr[u].l, lc, mid, l, r);\\n        if(r > mid) ans += Query(tr[u].r, mid + 1, rc, l, r);\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.Add(left,right);\\n * int param_2 = obj.Count();\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class CountIntervals {\\n    public class Node{\\n        public int l, r, add, cnt;\\n    }\\n    const int N = (int)1e9 + 7, M = 1000010;\\n    Node[] tr = new Node[M * 4];\\n    int pos = 1, st = 0;\\n\\n    public CountIntervals() {\\n\\n    }\\n    \\n    public void Add(int left, int right) {\\n        st++;\\n        Update(1, 1, N - 1, left, right, 1);\\n    }\\n    \\n    public int Count() {\\n        if(st == 0) return 0;\\n        return Query(1, 1, N - 1, 1, N - 1);\\n    }\\n\\n    public void PushUp(int u){\\n        tr[u].cnt = tr[tr[u].l].cnt + tr[tr[u].r].cnt;\\n    }\\n\\n    public void PushDown(int u, int len){\\n        if(tr[u] == null)\\n            tr[u] = new Node();\\n        if(tr[u].l == 0){\\n            tr[u].l = ++pos;\\n            tr[tr[u].l] = new Node();\\n        }\\n        if(tr[u].r == 0){\\n            tr[u].r = ++pos;\\n            tr[tr[u].r] = new Node();\\n        }\\n\\n        if(tr[u].add == 0) return;\\n        tr[tr[u].l].cnt = len - len / 2;\\n        tr[tr[u].r].cnt = len / 2;\\n        tr[tr[u].l].add = tr[tr[u].r].add = tr[u].add;\\n        tr[u].add = 0;\\n    }\\n\\n    public void Update(int u, int lc, int rc, int l, int r, int k){\\n        if(l <= lc && rc <= r){\\n            tr[u].add = k;\\n            tr[u].cnt = rc - lc + 1;\\n            return;\\n        }\\n\\n        PushDown(u, rc - lc + 1);\\n        int mid = rc + lc >> 1;\\n        if(mid >= l) Update(tr[u].l, lc, mid, l, r, k);\\n        if(mid < r) Update(tr[u].r, mid + 1, rc, l, r, k);\\n        PushUp(u);\\n    }\\n\\n    public int Query(int u, int lc, int rc, int l, int r){\\n        if(l <= lc && rc <= r)\\n            return tr[u].cnt;\\n        \\n        PushDown(u, rc - lc + 1);\\n        int mid = lc + rc >> 1, ans = 0;\\n        if(l <= mid) ans = Query(tr[u].l, lc, mid, l, r);\\n        if(r > mid) ans += Query(tr[u].r, mid + 1, rc, l, r);\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.Add(left,right);\\n * int param_2 = obj.Count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676814,
                "title": "single-ordered-map-based-solution-with-516ms-91-12-fast",
                "content": "We use ordered map to store all intervals as there right as keys and left as values then whenever a new interval comes we test if we have any itersecting interval or not if no intersection is found the insert it directly and update the count(cnt) as right-left+1,else if itersection is found then we need to modify the boundaries and then again re-insert the new interval recursively.\\n\\n\\nTo find the interval that might intersect with this we can use lower_bound() to find the next ending after the current starting point.\\n\\n**C++:**\\n\\'\\'\\'\\n\\n    class CountIntervals {\\n    public:\\n        CountIntervals() {\\n\\n        }\\n    \\n    void add(int left, int right) {\\n       \\n        //find the interval which is equal or just next right as the current interval e.g [2,5] with [5,6]\\n        //because it may have intersection with the current one\\n        auto it = hm.lower_bound(left);\\n        \\n        //if not interval is found just add this and increment integer count\\n        if(it == hm.end()){\\n            hm[right] = left;\\n            cnt+=(right-left+1);\\n        }\\n        \\n        //if next interval fount\\n        else{\\n            \\n            //take the start and end value of the suspected interval\\n            int s = it->second;\\n            int e = it->first;\\n            \\n            \\n            //no intersection is fount as the interval which is found comes after the current interval\\n            if(s > right){\\n                hm[right] = left;\\n                cnt+=(right-left+1);\\n            }\\n            \\n            //if intersection fount erase that interval as we need to modify its boundaries\\n        //remove its contribution from cnt and the find new boundary as min(start,left) and max(end,right)\\n            \\n            else{\\n                hm.erase(e);\\n                cnt -= (e-s+1);\\n                int ns = min(left,s),ne = max(right,e);\\n                //add the new interval to the map reccursively.\\n                add(ns,ne);\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    private:\\n        map<int,int> hm;\\n        int cnt = 0;\\n    };\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "We use ordered map to store all intervals as there right as keys and left as values then whenever a new interval comes we test if we have any itersecting interval or not if no intersection is found the insert it directly and update the count(cnt) as right-left+1,else if itersection is found then we need to modify the boundaries and then again re-insert the new interval recursively.\\n\\n\\nTo find the interval that might intersect with this we can use lower_bound() to find the next ending after the current starting point.\\n\\n**C++:**\\n\\'\\'\\'\\n\\n    class CountIntervals {\\n    public:\\n        CountIntervals() {\\n\\n        }\\n    \\n    void add(int left, int right) {\\n       \\n        //find the interval which is equal or just next right as the current interval e.g [2,5] with [5,6]\\n        //because it may have intersection with the current one\\n        auto it = hm.lower_bound(left);\\n        \\n        //if not interval is found just add this and increment integer count\\n        if(it == hm.end()){\\n            hm[right] = left;\\n            cnt+=(right-left+1);\\n        }\\n        \\n        //if next interval fount\\n        else{\\n            \\n            //take the start and end value of the suspected interval\\n            int s = it->second;\\n            int e = it->first;\\n            \\n            \\n            //no intersection is fount as the interval which is found comes after the current interval\\n            if(s > right){\\n                hm[right] = left;\\n                cnt+=(right-left+1);\\n            }\\n            \\n            //if intersection fount erase that interval as we need to modify its boundaries\\n        //remove its contribution from cnt and the find new boundary as min(start,left) and max(end,right)\\n            \\n            else{\\n                hm.erase(e);\\n                cnt -= (e-s+1);\\n                int ns = min(left,s),ne = max(right,e);\\n                //add the new interval to the map reccursively.\\n                add(ns,ne);\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    private:\\n        map<int,int> hm;\\n        int cnt = 0;\\n    };\\n\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2652598,
                "title": "python-sorteddict-sortedlist-bisect-left-with-clear-comments",
                "content": "**SortedDict**\\n\\n```python\\nfrom sortedcontainers import SortedDict\\n\\nclass CountIntervals(object):\\n\\n    def __init__(self):\\n\\t\\t# { right -> left } sorted by key (right end of the interval)\\n        self.d = SortedDict()\\n        # sum of all merged intervals == number of integers that are present in at least one interval.\\n        self.cnt = 0 \\n\\n    def add(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: None\\n        \"\"\"\\n        # Find the first interval whose key >= left, i.e. whose right end >= left\\n        i = self.d.bisect_left(left)\\n        # iterate all the intervals covered or partially covered by [left, right] \\n        while i < len(self.d) and self.d.values()[i] <= right:\\n            r, l = self.d.items()[i]\\n            # Merge interval into a new larger interal:\\n            left = min(left, l)\\n            right = max(right, r)\\n            # Subtracting the sum of merged smaller interval\\n            self.cnt -= r - l + 1\\n            # deleted the merged smaller interval from the SortedDict\\n            self.d.popitem(i)\\n        \\n        # Adding by the sum of merged larger interval\\n        self.cnt += right - left + 1\\n        # Add the new merged interval \\n        self.d[right] = left\\n\\n    def count(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.cnt\\n      \\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n\\n```\\n\\n`Time = log(N)`: each interval will be update (add/delete) once at most , so the amortized time complexity of `add` is O(logN), N is the number of time of `add` was called.\\n`Space = O(N)`: SortedDict\\n\\n**SortedList**\\nSame idea, just replace {right -> left} with the tuple (right, left)\\n\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.cnt = 0 \\n        self.intervals = SortedList()\\n\\n    def add(self, left, right):\\n        k = self.intervals.bisect_left((left - 1, right))\\n        while k < len(self.intervals) and self.intervals[k][1] <= right: \\n            r, l = self.intervals.pop(k)\\n            self.cnt -= r - l + 1\\n            right = max(right, r)\\n            left = min(left, l)\\n            \\n        self.cnt += right - left + 1\\n        self.intervals.add((right, left))\\n\\n    def count(self):\\n        return self.cnt\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedDict\\n\\nclass CountIntervals(object):\\n\\n    def __init__(self):\\n\\t\\t# { right -> left } sorted by key (right end of the interval)\\n        self.d = SortedDict()\\n        # sum of all merged intervals == number of integers that are present in at least one interval.\\n        self.cnt = 0 \\n\\n    def add(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: None\\n        \"\"\"\\n        # Find the first interval whose key >= left, i.e. whose right end >= left\\n        i = self.d.bisect_left(left)\\n        # iterate all the intervals covered or partially covered by [left, right] \\n        while i < len(self.d) and self.d.values()[i] <= right:\\n            r, l = self.d.items()[i]\\n            # Merge interval into a new larger interal:\\n            left = min(left, l)\\n            right = max(right, r)\\n            # Subtracting the sum of merged smaller interval\\n            self.cnt -= r - l + 1\\n            # deleted the merged smaller interval from the SortedDict\\n            self.d.popitem(i)\\n        \\n        # Adding by the sum of merged larger interval\\n        self.cnt += right - left + 1\\n        # Add the new merged interval \\n        self.d[right] = left\\n\\n    def count(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.cnt\\n      \\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n\\n```\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.cnt = 0 \\n        self.intervals = SortedList()\\n\\n    def add(self, left, right):\\n        k = self.intervals.bisect_left((left - 1, right))\\n        while k < len(self.intervals) and self.intervals[k][1] <= right: \\n            r, l = self.intervals.pop(k)\\n            self.cnt -= r - l + 1\\n            right = max(right, r)\\n            left = min(left, l)\\n            \\n        self.cnt += right - left + 1\\n        self.intervals.add((right, left))\\n\\n    def count(self):\\n        return self.cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577866,
                "title": "java-sol",
                "content": "```\\nclass CountIntervals {\\n    \\n    TreeMap<Integer, Integer> intervals;\\n    int sz = 0;\\n        \\n    public CountIntervals() {\\n        intervals = new TreeMap();\\n        sz = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        \\n        int s = left, e = right; \\n        Integer s1 = intervals.floorKey(left);\\n        \\n        if (s1 != null) {\\n            int e1 = intervals.get(s1);\\n            \\n            if (e1 >= e) return;\\n            if (e1 >= s) {\\n                sz -= (e1 - s1 + 1);\\n                s = Math.min(s1, s);\\n                intervals.remove(s1);\\n            }\\n        }\\n        \\n        while (intervals.floorKey(e) !=null && intervals.floorKey(e) >= s) {\\n            \\n            int s2 = intervals.floorKey(e);\\n            int e2 = intervals.get(s2);\\n            sz -= (e2 - s2 + 1);\\n            \\n            e = Math.max(e2, e);\\n            intervals.remove(s2);\\n        }\\n        \\n        sz += (e - s + 1);\\n        intervals.put(s, e);\\n    }\\n    \\n    public int count() {\\n        return sz;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\n    \\n    TreeMap<Integer, Integer> intervals;\\n    int sz = 0;\\n        \\n    public CountIntervals() {\\n        intervals = new TreeMap();\\n        sz = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        \\n        int s = left, e = right; \\n        Integer s1 = intervals.floorKey(left);\\n        \\n        if (s1 != null) {\\n            int e1 = intervals.get(s1);\\n            \\n            if (e1 >= e) return;\\n            if (e1 >= s) {\\n                sz -= (e1 - s1 + 1);\\n                s = Math.min(s1, s);\\n                intervals.remove(s1);\\n            }\\n        }\\n        \\n        while (intervals.floorKey(e) !=null && intervals.floorKey(e) >= s) {\\n            \\n            int s2 = intervals.floorKey(e);\\n            int e2 = intervals.get(s2);\\n            sz -= (e2 - s2 + 1);\\n            \\n            e = Math.max(e2, e);\\n            intervals.remove(s2);\\n        }\\n        \\n        sz += (e - s + 1);\\n        intervals.put(s, e);\\n    }\\n    \\n    public int count() {\\n        return sz;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399810,
                "title": "python-segment-tree",
                "content": "```\\nclass Node:\\n    def __init__(self, start, end, val=0):\\n        self.start = start\\n        self.end = end\\n        self.val = val\\n        self.left = self.right = None\\n        \\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.root = Node(1, 10**9)\\n\\n    def add(self, start: int, end: int) -> None:\\n        self.update(self.root, start, end)\\n    \\n    def update(self, node, start, end):\\n#         to avoid updating what we already have with a lesser value...\\n        if node.val == node.end-node.start+1:\\n            return\\n        \\n        if node.start == start and node.end == end:\\n            node.val = node.end - node.start +1\\n            return\\n        \\n        mid = (node.start + node.end) // 2\\n        \\n        if not node.left:\\n            node.left = Node(node.start, mid, 0)\\n        if not node.right:\\n            node.right = Node(mid+1, node.end, 0)\\n        \\n        if end <= mid:\\n            self.update(node.left, start, end)\\n        elif start >= mid + 1:\\n            self.update(node.right, start, end)\\n        else:\\n            self.update(node.left, start, mid)\\n            self.update(node.right, mid+1, end)\\n            \\n        node.val = node.left.val + node.right.val \\n        return\\n\\n    def count(self) -> int:\\n        return self.root.val\\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, start, end, val=0):\\n        self.start = start\\n        self.end = end\\n        self.val = val\\n        self.left = self.right = None\\n        \\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.root = Node(1, 10**9)\\n\\n    def add(self, start: int, end: int) -> None:\\n        self.update(self.root, start, end)\\n    \\n    def update(self, node, start, end):\\n#         to avoid updating what we already have with a lesser value...\\n        if node.val == node.end-node.start+1:\\n            return\\n        \\n        if node.start == start and node.end == end:\\n            node.val = node.end - node.start +1\\n            return\\n        \\n        mid = (node.start + node.end) // 2\\n        \\n        if not node.left:\\n            node.left = Node(node.start, mid, 0)\\n        if not node.right:\\n            node.right = Node(mid+1, node.end, 0)\\n        \\n        if end <= mid:\\n            self.update(node.left, start, end)\\n        elif start >= mid + 1:\\n            self.update(node.right, start, end)\\n        else:\\n            self.update(node.left, start, mid)\\n            self.update(node.right, mid+1, end)\\n            \\n        node.val = node.left.val + node.right.val \\n        return\\n\\n    def count(self) -> int:\\n        return self.root.val\\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375879,
                "title": "rust-solution-using-btreemap",
                "content": "~~~\\nuse std::collections::BTreeMap;\\nstruct CountIntervals {\\n    cnt: i32,\\n    mp: BTreeMap<i32, i32>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl CountIntervals {\\n\\n    fn new() -> Self {\\n        let mp: BTreeMap<i32, i32> = BTreeMap::new(); \\n        Self { cnt: 0, mp }\\n    }\\n    \\n    fn add(&mut self, left: i32, right: i32) {\\n        let (mut left, mut right) = (left, right);\\n       \\n        self.cnt += right - left + 1;\\n        if self.mp.is_empty() {\\n            self.mp.insert(left, right);\\n            return\\n        }\\n        \\n        let (a, _) = self.mp.iter().next().unwrap();\\n        let (_, b) = self.mp.iter().rev().next().unwrap();\\n        if a - 1 > right || b + 1 < left {\\n            self.mp.insert(left, right);\\n            return\\n        }\\n        \\n\\t\\t// left end joining\\n        if let Some((&key, &value)) = self.mp.range(..left + 1).rev().next() {\\n            if value + 1 >= left {\\n                if value > right { self.cnt -= right - left + 1; }\\n                else { self.cnt -= value + 1  - left; }\\n                left = key;\\n                right = right.max(value);\\n            }\\n        }\\n        \\n\\t\\t// removing containing intervals\\n        let mut done = false;\\n        while done == false {\\n            done = true;\\n            if let Some((&key, &value)) = self.mp.range(left + 1..).next() {\\n                if value > right { break; }\\n                self.cnt -= value - key + 1;\\n                self.mp.remove(&key);\\n                done = false;\\n            }\\n        }\\n        \\n\\t\\t// right end joining\\n        if let Some((&key, &value)) = self.mp.range(left + 1..).next() {\\n            if right + 1 >= key {\\n                self.cnt -= right + 1 - key;\\n                right = value;\\n                self.mp.remove(&key);\\n            }\\n        }\\n        \\n        self.mp.insert(left, right);\\n    }\\n    \\n    fn count(&self) -> i32 {\\n        self.cnt\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nuse std::collections::BTreeMap;\\nstruct CountIntervals {\\n    cnt: i32,\\n    mp: BTreeMap<i32, i32>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl CountIntervals {\\n\\n    fn new() -> Self {\\n        let mp: BTreeMap<i32, i32> = BTreeMap::new(); \\n        Self { cnt: 0, mp }\\n    }\\n    \\n    fn add(&mut self, left: i32, right: i32) {\\n        let (mut left, mut right) = (left, right);\\n       \\n        self.cnt += right - left + 1;\\n        if self.mp.is_empty() {\\n            self.mp.insert(left, right);\\n            return\\n        }\\n        \\n        let (a, _) = self.mp.iter().next().unwrap();\\n        let (_, b) = self.mp.iter().rev().next().unwrap();\\n        if a - 1 > right || b + 1 < left {\\n            self.mp.insert(left, right);\\n            return\\n        }\\n        \\n\\t\\t// left end joining\\n        if let Some((&key, &value)) = self.mp.range(..left + 1).rev().next() {\\n            if value + 1 >= left {\\n                if value > right { self.cnt -= right - left + 1; }\\n                else { self.cnt -= value + 1  - left; }\\n                left = key;\\n                right = right.max(value);\\n            }\\n        }\\n        \\n\\t\\t// removing containing intervals\\n        let mut done = false;\\n        while done == false {\\n            done = true;\\n            if let Some((&key, &value)) = self.mp.range(left + 1..).next() {\\n                if value > right { break; }\\n                self.cnt -= value - key + 1;\\n                self.mp.remove(&key);\\n                done = false;\\n            }\\n        }\\n        \\n\\t\\t// right end joining\\n        if let Some((&key, &value)) = self.mp.range(left + 1..).next() {\\n            if right + 1 >= key {\\n                self.cnt -= right + 1 - key;\\n                right = value;\\n                self.mp.remove(&key);\\n            }\\n        }\\n        \\n        self.mp.insert(left, right);\\n    }\\n    \\n    fn count(&self) -> i32 {\\n        self.cnt\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2058740,
                "title": "python-list",
                "content": "similiar to 715\\n```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.arr = []\\n        self.cnt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        pos = bisect_left(self.arr, (left, right))\\n        if pos > 0: pos-=1\\n        while pos<len(self.arr):\\n            if left>self.arr[pos][1]:\\n                pos+=1\\n                continue\\n            if self.arr[pos][0]>right: break\\n            left = min(left, self.arr[pos][0])\\n            right = max(right, self.arr[pos][1])\\n            removed = self.arr.pop(pos)\\n            self.cnt-=removed[1]-removed[0]+1\\n        self.arr.insert(pos, (left, right))  \\n        self.cnt+=right-left+1\\n\\n    def count(self) -> int:\\n        return self.cnt\\n        \\n\\n",
                "solutionTags": [],
                "code": "similiar to 715\\n```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.arr = []\\n        self.cnt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        pos = bisect_left(self.arr, (left, right))\\n        if pos > 0: pos-=1\\n        while pos<len(self.arr):\\n            if left>self.arr[pos][1]:\\n                pos+=1\\n                continue\\n            if self.arr[pos][0]>right: break\\n            left = min(left, self.arr[pos][0])\\n            right = max(right, self.arr[pos][1])\\n            removed = self.arr.pop(pos)\\n            self.cnt-=removed[1]-removed[0]+1\\n        self.arr.insert(pos, (left, right))  \\n        self.cnt+=right-left+1\\n\\n    def count(self) -> int:\\n        return self.cnt\\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2056882,
                "title": "java-treemap",
                "content": "```\\nclass CountIntervals {\\n    TreeMap<Integer,Integer> map;\\n    int count=0;\\n    public CountIntervals() {\\n        map=new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n        int l=left;\\n        int r=right;\\n        \\n        while(true){\\n            if(map.floorKey(r)==null || map.get(map.floorKey(r))<l)\\n                break;\\n            \\n            int prevLeft=map.floorKey(r);\\n            int prevRight=map.get(prevLeft);\\n            \\n            count-=(prevRight-prevLeft+1);\\n            map.remove(prevLeft);\\n            \\n            l=Math.min(l,prevLeft);\\n            r=Math.max(r,prevRight);\\n        }\\n        \\n        map.put(l,r);\\n        count+=(r-l+1);\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass CountIntervals {\\n    TreeMap<Integer,Integer> map;\\n    int count=0;\\n    public CountIntervals() {\\n        map=new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n        int l=left;\\n        int r=right;\\n        \\n        while(true){\\n            if(map.floorKey(r)==null || map.get(map.floorKey(r))<l)\\n                break;\\n            \\n            int prevLeft=map.floorKey(r);\\n            int prevRight=map.get(prevLeft);\\n            \\n            count-=(prevRight-prevLeft+1);\\n            map.remove(prevLeft);\\n            \\n            l=Math.min(l,prevLeft);\\n            r=Math.max(r,prevRight);\\n        }\\n        \\n        map.put(l,r);\\n        count+=(r-l+1);\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045239,
                "title": "racket-skip-list-solution",
                "content": "Find overlapping intervals, remove and merge them with new `left` and `right`.\\nFinally, insert new `left` and `right`.\\n\\nThere are two ordered dict implementation in Racket: splay-tree and skip-list.\\nsplay-tree can\\'t pass on Leetcode while skip-list can.\\n\\n```scheme\\n(require data/skip-list)\\n\\n(define count-intervals%\\n  (class object%\\n    (super-new)\\n\\n    (init-field [m (make-skip-list)]\\n                [cnt 0])\\n\\n    (define (len lower upper)\\n      (- upper lower -1))\\n\\n    (define/public (add left right)\\n      (let loop ([pos (dict-iterate-least/>=? m left)])\\n        (when pos\\n          (let ([lower (dict-iterate-value m pos)]\\n                [upper (dict-iterate-key m pos)])\\n            (when (<= lower right)\\n              (set! left (min left lower))\\n              (set! right (max right upper))\\n              (set! cnt (- cnt (len lower upper))) \\n\\n              (dict-remove! m upper)\\n              (loop (dict-iterate-next m pos))))))\\n\\n      (set! cnt (+ cnt (len left right)))\\n      (dict-set! m right left))\\n\\n    (define/public (count)\\n      cnt)))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```scheme\\n(require data/skip-list)\\n\\n(define count-intervals%\\n  (class object%\\n    (super-new)\\n\\n    (init-field [m (make-skip-list)]\\n                [cnt 0])\\n\\n    (define (len lower upper)\\n      (- upper lower -1))\\n\\n    (define/public (add left right)\\n      (let loop ([pos (dict-iterate-least/>=? m left)])\\n        (when pos\\n          (let ([lower (dict-iterate-value m pos)]\\n                [upper (dict-iterate-key m pos)])\\n            (when (<= lower right)\\n              (set! left (min left lower))\\n              (set! right (max right upper))\\n              (set! cnt (- cnt (len lower upper))) \\n\\n              (dict-remove! m upper)\\n              (loop (dict-iterate-next m pos))))))\\n\\n      (set! cnt (+ cnt (len left right)))\\n      (dict-set! m right left))\\n\\n    (define/public (count)\\n      cnt)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042524,
                "title": "merge-intervals-java-easy-to-understand-not-the-most-performant",
                "content": "```\\nclass CountIntervals {\\n    \\n    TreeMap<Integer, Integer> tree;\\n    int count;\\n\\n    public CountIntervals() {\\n        this.tree = new TreeMap<>();\\n        this.count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n\\t    // Keep removing lower entries as long as they extend current interval\\n        while (this.tree.floorKey(left) != null) {\\n            int fk = this.tree.floorKey(left);\\n\\t\\t\\t// The lower range is totally out of the current range\\n            if (this.tree.get(fk) < left) {\\n                break;\\n            }\\n            left = Math.min(left, fk);\\n            right = Math.max(right, this.tree.get(fk));\\n\\t\\t\\t// remove the previously counted values\\n            this.count -= (this.tree.get(fk) - fk + 1);\\n            this.tree.remove(fk);\\n        }\\n\\t\\t// Keep removing higher entries as long as they extend current interval\\n        while (this.tree.floorKey(right) != null) {\\n            int fk = this.tree.floorKey(right);\\n\\t\\t\\t// the range is totally out of the current range\\n            if (this.tree.get(fk) < left) {\\n                break;\\n            }\\n            left = Math.min(left, fk);\\n            right = Math.max(right, this.tree.get(fk));\\n\\t\\t\\t// remove the previously counted values\\n            this.count -= (this.tree.get(fk) - fk + 1);\\n            this.tree.remove(fk);\\n        }\\n        this.count += (right - left + 1);\\n        this.tree.put(left, right);\\n    }\\n    \\n    public int count() {\\n        return this.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CountIntervals {\\n    \\n    TreeMap<Integer, Integer> tree;\\n    int count;\\n\\n    public CountIntervals() {\\n        this.tree = new TreeMap<>();\\n        this.count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n\\t    // Keep removing lower entries as long as they extend current interval\\n        while (this.tree.floorKey(left) != null) {\\n            int fk = this.tree.floorKey(left);\\n\\t\\t\\t// The lower range is totally out of the current range\\n            if (this.tree.get(fk) < left) {\\n                break;\\n            }\\n            left = Math.min(left, fk);\\n            right = Math.max(right, this.tree.get(fk));\\n\\t\\t\\t// remove the previously counted values\\n            this.count -= (this.tree.get(fk) - fk + 1);\\n            this.tree.remove(fk);\\n        }\\n\\t\\t// Keep removing higher entries as long as they extend current interval\\n        while (this.tree.floorKey(right) != null) {\\n            int fk = this.tree.floorKey(right);\\n\\t\\t\\t// the range is totally out of the current range\\n            if (this.tree.get(fk) < left) {\\n                break;\\n            }\\n            left = Math.min(left, fk);\\n            right = Math.max(right, this.tree.get(fk));\\n\\t\\t\\t// remove the previously counted values\\n            this.count -= (this.tree.get(fk) - fk + 1);\\n            this.tree.remove(fk);\\n        }\\n        this.count += (right - left + 1);\\n        this.tree.put(left, right);\\n    }\\n    \\n    public int count() {\\n        return this.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040221,
                "title": "python-segment-tree-got-tle-why",
                "content": "I got TLE for using segment tree. Why is my solution so slow? I had to rewrite the solution with SortedList and interval-merge to make it pass during the contest. It costs me another 20 minutes.\\n\\n```\\nclass Node:\\n    def __init__(self):\\n        self.count = 0\\n        self.left = self.right = None\\n\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.root = Node()\\n\\n\\n    def add(self, left: int, right: int) -> None:\\n        self._add(self.root, 1, 10**9, left, right)\\n\\n\\n    def _add(self, node, l, r, left, right):\\n        if not node:\\n            node = Node()\\n        if node.count == r-l+1:\\n            return node\\n        if l > right or r < left:\\n            return node\\n        if left <= l and r <= right:\\n            node.count = r-l+1\\n            # print(l, r, node.count)\\n            return node\\n        mid = (l+r) // 2\\n        node.left = self._add(node.left, l, mid, left, right)\\n        node.right = self._add(node.right, mid+1, r, left, right)\\n        node.count = node.left.count + node.right.count\\n        # print(l, r, node.count, node.left.count, node.right.count)\\n        return node\\n\\n\\n    def count(self) -> int:\\n        return self.root.count\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.count = 0\\n        self.left = self.right = None\\n\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.root = Node()\\n\\n\\n    def add(self, left: int, right: int) -> None:\\n        self._add(self.root, 1, 10**9, left, right)\\n\\n\\n    def _add(self, node, l, r, left, right):\\n        if not node:\\n            node = Node()\\n        if node.count == r-l+1:\\n            return node\\n        if l > right or r < left:\\n            return node\\n        if left <= l and r <= right:\\n            node.count = r-l+1\\n            # print(l, r, node.count)\\n            return node\\n        mid = (l+r) // 2\\n        node.left = self._add(node.left, l, mid, left, right)\\n        node.right = self._add(node.right, mid+1, r, left, right)\\n        node.count = node.left.count + node.right.count\\n        # print(l, r, node.count, node.left.count, node.right.count)\\n        return node\\n\\n\\n    def count(self) -> int:\\n        return self.root.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040201,
                "title": "java-unique-solution-using-arraylist-passed-68-72-testcases",
                "content": "This is my approach to this question. Approach is quite unique and passed 68/72 testcases. \\nThis approach is not perfect as I am getting TLE, This is just for the learning purpose. \\n\\n***UPVOTE  if you find it useful. ***\\n\\n**Approach is simple:**\\n1. Fill the ArrayList \"Big\" whenever add() is called.\\n2. Sort the ArrayList \"Big\" based on the left interval and count the numbers.\\n\\n```\\nclass CountIntervals {\\n     ArrayList<ArrayList<Integer>> big;\\n    \\n    public CountIntervals() {\\n        big=new ArrayList<>();\\n        \\n    }\\n    \\n    public void add(int left, int right) {\\n        ArrayList<Integer> small=new ArrayList<>();\\n        small.add(left);\\n        small.add(right);\\n        \\n        big.add(small);\\n    }\\n    \\n    public int count() {\\n        //Each Time sorting the intervals whenever count() is called\\n        Collections.sort(big,(a,b)->Integer.compare(a.get(0),b.get(0)));\\n        \\n        int prevStart=0;\\n        int prevEnd=0;\\n        \\n        int i=0;\\n        int count=0;\\n        \\n        while(i<big.size())\\n        {\\n            \\n            int newStart=big.get(i).get(0);\\n            int newEnd=big.get(i).get(1);\\n            \\n            if(i==0)\\n            {\\n                count=count+newEnd-newStart+1;\\n                prevStart=newStart;\\n                prevEnd=newEnd;\\n            }\\n            \\n            else\\n            {\\n                if(newStart==prevStart)\\n                {\\n                    if(newEnd>prevEnd)\\n                    {\\n                        count=count+newEnd-prevEnd;\\n                    }\\n                }\\n                \\n                else if(newStart>prevEnd)\\n                {\\n                    count=count+newEnd-newStart+1;\\n                }\\n                \\n                else if(newStart<prevEnd)\\n                {\\n                    if(newEnd>prevEnd)\\n                    count=count+newEnd-prevEnd;\\n                }\\n                \\n                else if(newStart==prevEnd)\\n                {\\n                    count=count+newEnd-prevEnd;\\n                }\\n                \\n                \\n                prevStart=newStart;\\n                \\n                if(newEnd>prevEnd)\\n                prevEnd=newEnd;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CountIntervals {\\n     ArrayList<ArrayList<Integer>> big;\\n    \\n    public CountIntervals() {\\n        big=new ArrayList<>();\\n        \\n    }\\n    \\n    public void add(int left, int right) {\\n        ArrayList<Integer> small=new ArrayList<>();\\n        small.add(left);\\n        small.add(right);\\n        \\n        big.add(small);\\n    }\\n    \\n    public int count() {\\n        //Each Time sorting the intervals whenever count() is called\\n        Collections.sort(big,(a,b)->Integer.compare(a.get(0),b.get(0)));\\n        \\n        int prevStart=0;\\n        int prevEnd=0;\\n        \\n        int i=0;\\n        int count=0;\\n        \\n        while(i<big.size())\\n        {\\n            \\n            int newStart=big.get(i).get(0);\\n            int newEnd=big.get(i).get(1);\\n            \\n            if(i==0)\\n            {\\n                count=count+newEnd-newStart+1;\\n                prevStart=newStart;\\n                prevEnd=newEnd;\\n            }\\n            \\n            else\\n            {\\n                if(newStart==prevStart)\\n                {\\n                    if(newEnd>prevEnd)\\n                    {\\n                        count=count+newEnd-prevEnd;\\n                    }\\n                }\\n                \\n                else if(newStart>prevEnd)\\n                {\\n                    count=count+newEnd-newStart+1;\\n                }\\n                \\n                else if(newStart<prevEnd)\\n                {\\n                    if(newEnd>prevEnd)\\n                    count=count+newEnd-prevEnd;\\n                }\\n                \\n                else if(newStart==prevEnd)\\n                {\\n                    count=count+newEnd-prevEnd;\\n                }\\n                \\n                \\n                prevStart=newStart;\\n                \\n                if(newEnd>prevEnd)\\n                prevEnd=newEnd;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040080,
                "title": "union-of-intervals",
                "content": "every time when add method is called we are adding it in the set and checking if the prev interval\\'s right is greater than left of current interval if its greater than we are merging them same we are doing for the next element\\'s starting is lesser than cur than we are merging curent element with that interval \\n\\nsuppose our set is like {1,2}, {4,5}\\nwhen we add {1,3 } in the set  {1,2}, {1,3},{4,5}\\nthen we will remove {1,2} and {1,3 } and insert {1,3} then our set will be like {1,3} , {4,5} same can be dont for greater element \\nalso in count method we need to have count in o(1) else it will give tle if traverse set again and again \\nwe can keep track of count using a global variable \\n```\\n#define mp make_pair\\n#define ff first\\n#define pii pair<int,int>\\n#define ss second\\nset<pair<int,int>> s;\\nint cnt=0;\\nclass CountIntervals {\\npublic:\\n    \\n    CountIntervals() {\\n        s.clear();\\n\\t\\tcnt=0;\\n    }\\n    \\n    void add(int l, int r) {\\n\\t\\tauto iz = s.find(mp(l,r));\\n\\t\\tif(iz!=s.end())return;\\n        s.insert(mp(l,r));\\n\\t\\tcnt+=(r-l+1);\\n        auto it = s.find(mp(l,r));\\n\\t\\tfor(int i = 0 ;i<2;i++)\\n\\t\\t{\\n\\n        int flag=0;\\n        pii to_insert;\\n        if(it!=s.begin())\\n        {\\n            auto pr = prev(it);\\n            if(pr->ss>=it->ff)\\n            {\\n            flag=1;\\n                 to_insert=(mp(min(pr->ff,it->ff),max(it->ss,pr->ss)));\\n\\t\\t\\t\\tcnt-=(pr->ss-pr->ff+1);\\n\\t\\t\\t\\tcnt-=(it->ss-it->ff+1);\\n\\t\\t\\t\\tcnt+=(to_insert.ss-to_insert.ff+1);\\n                s.erase(pr);\\n                s.erase(it);\\n                s.insert(to_insert);\\n\\t\\t\\t\\tit = s.find(to_insert);\\n            }\\n        }\\n      \\n        if(it!=prev(s.end()))\\n        {\\n            auto nx = next(it);\\n            if(it->ss>=nx->ff)\\n            {\\n                to_insert=(mp(min(it->ff,nx->ff),max(nx->ss,it->ss)));\\t\\t\\t\\n\\t\\t\\t\\tcnt-=(nx->ss-nx->ff+1);\\n\\t\\t\\t\\tcnt-=(it->ss-it->ff)+1;\\n\\t\\t\\t\\tcnt+=(to_insert.ss-to_insert.ff+1);\\n                s.erase(nx);\\n                s.erase(it);\\n                s.insert(to_insert);\\n\\t\\t\\t\\tit=s.find(to_insert);\\n            }\\n        }\\n\\t\\t}\\n\\t\\treturn;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Ordered Set"
                ],
                "code": "```\\n#define mp make_pair\\n#define ff first\\n#define pii pair<int,int>\\n#define ss second\\nset<pair<int,int>> s;\\nint cnt=0;\\nclass CountIntervals {\\npublic:\\n    \\n    CountIntervals() {\\n        s.clear();\\n\\t\\tcnt=0;\\n    }\\n    \\n    void add(int l, int r) {\\n\\t\\tauto iz = s.find(mp(l,r));\\n\\t\\tif(iz!=s.end())return;\\n        s.insert(mp(l,r));\\n\\t\\tcnt+=(r-l+1);\\n        auto it = s.find(mp(l,r));\\n\\t\\tfor(int i = 0 ;i<2;i++)\\n\\t\\t{\\n\\n        int flag=0;\\n        pii to_insert;\\n        if(it!=s.begin())\\n        {\\n            auto pr = prev(it);\\n            if(pr->ss>=it->ff)\\n            {\\n            flag=1;\\n                 to_insert=(mp(min(pr->ff,it->ff),max(it->ss,pr->ss)));\\n\\t\\t\\t\\tcnt-=(pr->ss-pr->ff+1);\\n\\t\\t\\t\\tcnt-=(it->ss-it->ff+1);\\n\\t\\t\\t\\tcnt+=(to_insert.ss-to_insert.ff+1);\\n                s.erase(pr);\\n                s.erase(it);\\n                s.insert(to_insert);\\n\\t\\t\\t\\tit = s.find(to_insert);\\n            }\\n        }\\n      \\n        if(it!=prev(s.end()))\\n        {\\n            auto nx = next(it);\\n            if(it->ss>=nx->ff)\\n            {\\n                to_insert=(mp(min(it->ff,nx->ff),max(nx->ss,it->ss)));\\t\\t\\t\\n\\t\\t\\t\\tcnt-=(nx->ss-nx->ff+1);\\n\\t\\t\\t\\tcnt-=(it->ss-it->ff)+1;\\n\\t\\t\\t\\tcnt+=(to_insert.ss-to_insert.ff+1);\\n                s.erase(nx);\\n                s.erase(it);\\n                s.insert(to_insert);\\n\\t\\t\\t\\tit=s.find(to_insert);\\n            }\\n        }\\n\\t\\t}\\n\\t\\treturn;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040066,
                "title": "java-binary-tree-segmenttree-idea",
                "content": "```\\nclass CountIntervals {\\n    private TreeNode root = null;\\n    public CountIntervals() {\\n        root = new TreeNode();\\n    }\\n    public void add(int left, int right) {\\n\\t\\t// Given number range is [1, 10^9]\\n        add(root, 1, (int)(1e9+1), left, right);\\n    }\\n    public int add(TreeNode node, int start, int end, int left, int right) {\\n\\t\\t// If interval is out of the node range, don\\'t need to update current node, return count directly.\\n        if (left > end || right < start) {\\n            return node.val;\\n        }\\n\\t\\t// If the current node is fully covered, return count directly.\\n        if(end - start + 1 == node.val){\\n            return node.val;\\n        }\\n\\t\\t// If is the leaf node, update the node count.\\n        if(start == left && end == right){\\n            return node.val = end - start + 1;\\n        }\\n\\t\\t// Update the children tree nodes when needed(the interval added is between the node range)\\n        int mid = start + (end - start) / 2;\\n        if(node.left == null){\\n            node.left = new TreeNode();\\n        }\\n        if(node.right == null){\\n           node.right = new TreeNode(); \\n        }\\n        int cnt = 0;\\n        cnt += add(node.left, start, mid, Math.max(start, left), Math.min(mid, right));\\n        cnt += add(node.right, mid+1, end, Math.max(mid+1, left), Math.min(end, right));\\n        return node.val = cnt;\\n    }\\n    public int count() {\\n        return root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass CountIntervals {\\n    private TreeNode root = null;\\n    public CountIntervals() {\\n        root = new TreeNode();\\n    }\\n    public void add(int left, int right) {\\n\\t\\t// Given number range is [1, 10^9]\\n        add(root, 1, (int)(1e9+1), left, right);\\n    }\\n    public int add(TreeNode node, int start, int end, int left, int right) {\\n\\t\\t// If interval is out of the node range, don\\'t need to update current node, return count directly.\\n        if (left > end || right < start) {\\n            return node.val;\\n        }\\n\\t\\t// If the current node is fully covered, return count directly.\\n        if(end - start + 1 == node.val){\\n            return node.val;\\n        }\\n\\t\\t// If is the leaf node, update the node count.\\n        if(start == left && end == right){\\n            return node.val = end - start + 1;\\n        }\\n\\t\\t// Update the children tree nodes when needed(the interval added is between the node range)\\n        int mid = start + (end - start) / 2;\\n        if(node.left == null){\\n            node.left = new TreeNode();\\n        }\\n        if(node.right == null){\\n           node.right = new TreeNode(); \\n        }\\n        int cnt = 0;\\n        cnt += add(node.left, start, mid, Math.max(start, left), Math.min(mid, right));\\n        cnt += add(node.right, mid+1, end, Math.max(mid+1, left), Math.min(end, right));\\n        return node.val = cnt;\\n    }\\n    public int count() {\\n        return root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039839,
                "title": "c-map-solution-with-explaination-in-detail",
                "content": "#### NOTE\\nThis problem is similar to [715. Range Module](https://leetcode.com/problems/range-module/). You can start that first and will find it easy to implement an additional counting system required in this problem.\\n```\\nclass CountIntervals {\\npublic:\\n    // use map to store interval [start, end)\\n    map<int, int> mp;\\n    int length;\\n\\t// the following function returns a new interval given one interval\\n\\t// overlapped ones will be deleted from map and merged with the current one\\n    pair<int, int> find(int left, int right) {\\n        // find segment.first > left and segment.first > right\\n        auto l = mp.upper_bound(left);\\n        auto r = mp.upper_bound(right);\\n        // move back first segment and check if its end < left\\n        // if yes, move forward first segment\\n        if (l != mp.begin() && (--l)->second < left) ++l;\\n        \\n        // if now l == r, it does not overlap with others\\n        if (l == r) {\\n            // update the total covered length\\n            length += (right - left);\\n            return {left, right};\\n        }\\n        \\n        // get the min val\\n        int minVal = min(l->first, left);\\n        // get the max val by moving back the second segment\\n        int maxVal = max(right, (--r)->second);\\n        \\n        // update the total covered length by deleting overlapped ones\\n        // r++: [l, r] -> [l, r) to half-open interval\\n        auto it = l;\\n        r++; \\n        while (it != r) {\\n            length -= (it->second - it->first);\\n            it++;\\n        }\\n        // update the total covered length by the new interval\\n        length += (maxVal - minVal);\\n        \\n        // remove overlap segment\\n        mp.erase(l, r);\\n        // return new interval\\n        return {minVal, maxVal};\\n    }\\n    CountIntervals() {\\n        length = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        // use half-open interval to simply the implementation\\n        right++;\\n        auto x = find(left, right);\\n        mp[x.first] = x.second;\\n    }\\n    \\n    int count() {\\n        return length;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    // use map to store interval [start, end)\\n    map<int, int> mp;\\n    int length;\\n\\t// the following function returns a new interval given one interval\\n\\t// overlapped ones will be deleted from map and merged with the current one\\n    pair<int, int> find(int left, int right) {\\n        // find segment.first > left and segment.first > right\\n        auto l = mp.upper_bound(left);\\n        auto r = mp.upper_bound(right);\\n        // move back first segment and check if its end < left\\n        // if yes, move forward first segment\\n        if (l != mp.begin() && (--l)->second < left) ++l;\\n        \\n        // if now l == r, it does not overlap with others\\n        if (l == r) {\\n            // update the total covered length\\n            length += (right - left);\\n            return {left, right};\\n        }\\n        \\n        // get the min val\\n        int minVal = min(l->first, left);\\n        // get the max val by moving back the second segment\\n        int maxVal = max(right, (--r)->second);\\n        \\n        // update the total covered length by deleting overlapped ones\\n        // r++: [l, r] -> [l, r) to half-open interval\\n        auto it = l;\\n        r++; \\n        while (it != r) {\\n            length -= (it->second - it->first);\\n            it++;\\n        }\\n        // update the total covered length by the new interval\\n        length += (maxVal - minVal);\\n        \\n        // remove overlap segment\\n        mp.erase(l, r);\\n        // return new interval\\n        return {minVal, maxVal};\\n    }\\n    CountIntervals() {\\n        length = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        // use half-open interval to simply the implementation\\n        right++;\\n        auto x = find(left, right);\\n        mp[x.first] = x.second;\\n    }\\n    \\n    int count() {\\n        return length;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973753,
                "title": "c-beats-100-simple-sorting-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea here is to store the intervals in ascending order by left in a list and keep variable for number of intergers. Whenever a new intervals comes in search for best place to insert it and increment the count. If newly inserted interval can be merged with any on its neighbour then merged it and adjust the counter.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class CountIntervals\\n{\\n    private List<Interval> _intervals;\\n    private int _count;\\n\\n    public CountIntervals()\\n    {\\n        _intervals = new();\\n        _count = 0;\\n    }\\n\\n    public int Count() => _count;\\n\\n    public void Add(int left, int right)\\n    {\\n        if(_intervals.Count == 0)\\n        {\\n            _intervals.Add(new Interval(left, right));\\n            _count += (right - left + 1);\\n            return;\\n        }\\n\\n        int index = GetIndexToInsert(left);\\n        _intervals.Insert(index, new Interval(left, right));\\n        _count += (right - left + 1);\\n\\n        while(true)\\n        {\\n            if(index + 1 < _intervals.Count\\n                && _intervals[index].Right >= _intervals[index + 1].Left)\\n            {\\n                // case 1: Merge to right.\\n                MergeInterval(index, index + 1);\\n            }\\n            else if (index - 1 >= 0\\n                && _intervals[index - 1].Right >= _intervals[index].Left)\\n            {\\n                // case 2: Merge to left.\\n                MergeInterval(index - 1, index);\\n                index--;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n\\n        }\\n    }\\n\\n\\n\\n    private int GetIndexToInsert(int left)\\n    {\\n        if (left <= _intervals[0].Left)\\n            return 0;\\n\\n        if (left >= _intervals[^1].Right)\\n            return _intervals.Count;\\n\\n        int index = 1;\\n\\n        while(index < _intervals.Count && left > _intervals[index].Left)\\n            index++;\\n\\n        return index;\\n    }\\n\\n    private void MergeInterval(int x, int y)\\n    {\\n        // assuming x.Left < y.Left\\n\\n        // case 1: Partially merging\\n        if (_intervals[x].Right < _intervals[y].Right)\\n        {\\n            _count -= (_intervals[x].Right - _intervals[y].Left + 1);\\n            _intervals[x].Right = _intervals[y].Right;\\n            _intervals.RemoveAt(y);\\n            return;\\n        }\\n\\n\\n        _count -= (_intervals[y].Right - _intervals[y].Left + 1);\\n        _intervals.RemoveAt(y);\\n    }\\n\\n\\n}\\n\\npublic class Interval\\n{\\n    public int Left { get; set; }\\n\\n    public int Right { get; set; }\\n\\n    public Interval(int left, int right)\\n    {\\n        Left = left;\\n        Right = right;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.Add(left,right);\\n * int param_2 = obj.Count();\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Sort"
                ],
                "code": "```\\npublic class CountIntervals\\n{\\n    private List<Interval> _intervals;\\n    private int _count;\\n\\n    public CountIntervals()\\n    {\\n        _intervals = new();\\n        _count = 0;\\n    }\\n\\n    public int Count() => _count;\\n\\n    public void Add(int left, int right)\\n    {\\n        if(_intervals.Count == 0)\\n        {\\n            _intervals.Add(new Interval(left, right));\\n            _count += (right - left + 1);\\n            return;\\n        }\\n\\n        int index = GetIndexToInsert(left);\\n        _intervals.Insert(index, new Interval(left, right));\\n        _count += (right - left + 1);\\n\\n        while(true)\\n        {\\n            if(index + 1 < _intervals.Count\\n                && _intervals[index].Right >= _intervals[index + 1].Left)\\n            {\\n                // case 1: Merge to right.\\n                MergeInterval(index, index + 1);\\n            }\\n            else if (index - 1 >= 0\\n                && _intervals[index - 1].Right >= _intervals[index].Left)\\n            {\\n                // case 2: Merge to left.\\n                MergeInterval(index - 1, index);\\n                index--;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n\\n        }\\n    }\\n\\n\\n\\n    private int GetIndexToInsert(int left)\\n    {\\n        if (left <= _intervals[0].Left)\\n            return 0;\\n\\n        if (left >= _intervals[^1].Right)\\n            return _intervals.Count;\\n\\n        int index = 1;\\n\\n        while(index < _intervals.Count && left > _intervals[index].Left)\\n            index++;\\n\\n        return index;\\n    }\\n\\n    private void MergeInterval(int x, int y)\\n    {\\n        // assuming x.Left < y.Left\\n\\n        // case 1: Partially merging\\n        if (_intervals[x].Right < _intervals[y].Right)\\n        {\\n            _count -= (_intervals[x].Right - _intervals[y].Left + 1);\\n            _intervals[x].Right = _intervals[y].Right;\\n            _intervals.RemoveAt(y);\\n            return;\\n        }\\n\\n\\n        _count -= (_intervals[y].Right - _intervals[y].Left + 1);\\n        _intervals.RemoveAt(y);\\n    }\\n\\n\\n}\\n\\npublic class Interval\\n{\\n    public int Left { get; set; }\\n\\n    public int Right { get; set; }\\n\\n    public Interval(int left, int right)\\n    {\\n        Left = left;\\n        Right = right;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.Add(left,right);\\n * int param_2 = obj.Count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912521,
                "title": "using-ordered-set-c",
                "content": "\\'\\'\\'\\n\\n\\n\\n\\nclass CountIntervals {\\n    private:\\n    set<pair<int,int>> st;\\n    int cnt;\\n    \\npublic:\\n    CountIntervals() {\\n        cnt=0;\\n        st.clear();\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it=st.lower_bound({left,0});\\n        if(it!=st.begin()){\\n            auto p=prev(it);\\n            if(!(p->first>right or p->second<left)){\\n                it--;\\n            }\\n        }\\n        \\n        while(it!=st.end() && it->first<=right){\\n            left=min(left,it->first);\\n            right=max(right,it->second);\\n            cnt-=(it->second-it->first+1);\\n            auto erase=it++;\\n            st.erase(erase);\\n        }\\n        cnt+=right-left+1;\\n        st.insert({left,right});\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n\\n\\nclass CountIntervals {\\n    private:\\n    set<pair<int,int>> st;\\n    int cnt;\\n    \\npublic:\\n    CountIntervals() {\\n        cnt=0;\\n        st.clear();\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it=st.lower_bound({left,0});\\n        if(it!=st.begin()){\\n            auto p=prev(it);\\n            if(!(p->first>right or p->second<left)){\\n                it--;\\n            }\\n        }\\n        \\n        while(it!=st.end() && it->first<=right){\\n            left=min(left,it->first);\\n            right=max(right,it->second);\\n            cnt-=(it->second-it->first+1);\\n            auto erase=it++;\\n            st.erase(erase);\\n        }\\n        cnt+=right-left+1;\\n        st.insert({left,right});\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 3879021,
                "title": "python-3-merge-intervals",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe solve the problem by merging the intervals and keeping the count updated at the same time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen a new interval comes we check whether it can be merged with any other interval or not. If it merges with one interval or many, we do that by deleting the interval first while keeping the left and right boundary updated.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\u02C62)$$\\nIn details the time complexity is O(n*(logN + N) + N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass CountIntervals:\\n    def __init__(self):\\n        self.intervals = []\\n        self.cnt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        l,r = left,right\\n\\n        while True:\\n            idx = bisect.bisect_left(self.intervals, (r, ))\\n            if not len(self.intervals):\\n                break\\n            if (idx == 0 and self.intervals[idx][0] > right) or self.intervals[idx-1][1] < l:\\n                break\\n            \\n            prev_l, prev_r = self.intervals[idx-1]\\n            self.cnt -= (prev_r - prev_l + 1)\\n            del self.intervals[idx - 1]\\n\\n            l = min(prev_l, l)\\n            r = max(prev_r, r)\\n        \\n        self.intervals.insert(idx, (l,r))\\n        self.cnt += (r - l + 1)\\n\\n    def count(self) -> int:\\n        return self.cnt\\n        \\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass CountIntervals:\\n    def __init__(self):\\n        self.intervals = []\\n        self.cnt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        l,r = left,right\\n\\n        while True:\\n            idx = bisect.bisect_left(self.intervals, (r, ))\\n            if not len(self.intervals):\\n                break\\n            if (idx == 0 and self.intervals[idx][0] > right) or self.intervals[idx-1][1] < l:\\n                break\\n            \\n            prev_l, prev_r = self.intervals[idx-1]\\n            self.cnt -= (prev_r - prev_l + 1)\\n            del self.intervals[idx - 1]\\n\\n            l = min(prev_l, l)\\n            r = max(prev_r, r)\\n        \\n        self.intervals.insert(idx, (l,r))\\n        self.cnt += (r - l + 1)\\n\\n    def count(self) -> int:\\n        return self.cnt\\n        \\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805081,
                "title": "using-treemap-and-count",
                "content": "\\n\\n# Code\\n```\\nimport java.util.*;\\nclass CountIntervals {\\n    private NavigableMap<Integer, Integer> map;\\n    private int count;\\n    public CountIntervals() {\\n        map = new TreeMap<>();\\n        count = 0;\\n    }\\n\\n    \\n    public void add(int left, int right) {\\n        int low = left;\\n        int high = right;\\n        while(map.floorKey(high) != null && map.get(map.floorKey(high)) >= low) {\\n            var prev = map.floorEntry(high);\\n\\n            count -= (prev.getValue() - prev.getKey() + 1);\\n            map.remove(prev.getKey());\\n            low = Integer.min(prev.getKey(), low);\\n            high = Integer.max(prev.getValue(), high);\\n        }\\n        \\n        map.put(low, high);\\n        count += (high - low + 1);\\n        return;\\n\\n    }\\n    \\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass CountIntervals {\\n    private NavigableMap<Integer, Integer> map;\\n    private int count;\\n    public CountIntervals() {\\n        map = new TreeMap<>();\\n        count = 0;\\n    }\\n\\n    \\n    public void add(int left, int right) {\\n        int low = left;\\n        int high = right;\\n        while(map.floorKey(high) != null && map.get(map.floorKey(high)) >= low) {\\n            var prev = map.floorEntry(high);\\n\\n            count -= (prev.getValue() - prev.getKey() + 1);\\n            map.remove(prev.getKey());\\n            low = Integer.min(prev.getKey(), low);\\n            high = Integer.max(prev.getValue(), high);\\n        }\\n        \\n        map.put(low, high);\\n        count += (high - low + 1);\\n        return;\\n\\n    }\\n    \\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750724,
                "title": "c-beats-78-79-using-ordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CountIntervals {\\n    map<int, int> intervals;\\n    int total = 0;\\npublic:\\n    void add(int left, int right) {\\n        const auto& [it, inserted] = intervals.emplace(left, right - left + 1);\\n        if (!inserted) {\\n            if (right - left + 1 < it->second)\\n                return;\\n            total -= it->second;\\n            it->second = right - left + 1; \\n            total += it->second;\\n        }\\n        else\\n            total += it->second;\\n\\n        for (auto next_it = next(it); next_it != end(intervals); next_it = intervals.erase(next_it)) {\\n            if (it->first + it->second >= next_it->first) {\\n                // 13 + 49 - 39 = sub 23\\n                const auto proposed_new_end = (next_it->first - it->first) + next_it->second;\\n                if (proposed_new_end > it->second) {\\n                    total -= it->second;\\n                    it->second = proposed_new_end;\\n                    total += it->second;\\n                }\\n            }\\n            else\\n                break;\\n            total -= next_it->second;\\n        }\\n\\n        if (auto prev_it = make_reverse_iterator(it); prev_it != rend(intervals)) {\\n            if (prev_it->first + prev_it->second >= it->first) {\\n                total -= prev_it->second;\\n                prev_it->second = max(prev_it->second, (it->first - prev_it->first) + it->second);\\n                total += prev_it->second;\\n                total -= it->second;\\n                intervals.erase(it);\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return total;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CountIntervals {\\n    map<int, int> intervals;\\n    int total = 0;\\npublic:\\n    void add(int left, int right) {\\n        const auto& [it, inserted] = intervals.emplace(left, right - left + 1);\\n        if (!inserted) {\\n            if (right - left + 1 < it->second)\\n                return;\\n            total -= it->second;\\n            it->second = right - left + 1; \\n            total += it->second;\\n        }\\n        else\\n            total += it->second;\\n\\n        for (auto next_it = next(it); next_it != end(intervals); next_it = intervals.erase(next_it)) {\\n            if (it->first + it->second >= next_it->first) {\\n                // 13 + 49 - 39 = sub 23\\n                const auto proposed_new_end = (next_it->first - it->first) + next_it->second;\\n                if (proposed_new_end > it->second) {\\n                    total -= it->second;\\n                    it->second = proposed_new_end;\\n                    total += it->second;\\n                }\\n            }\\n            else\\n                break;\\n            total -= next_it->second;\\n        }\\n\\n        if (auto prev_it = make_reverse_iterator(it); prev_it != rend(intervals)) {\\n            if (prev_it->first + prev_it->second >= it->first) {\\n                total -= prev_it->second;\\n                prev_it->second = max(prev_it->second, (it->first - prev_it->first) + it->second);\\n                total += prev_it->second;\\n                total -= it->second;\\n                intervals.erase(it);\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return total;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740472,
                "title": "golang-treemap-solution",
                "content": "# Intuition\\nMerge ranges on `Add` operation to avoid counting same range elements multiple times\\n\\n# Approach\\nUse a treemap data structure to store the ranges in increasing order\\nOn `Add` operation, find the previous range and next range\\n\\nMerge the ranges if there is an overlap and update the total count\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) as finding floor and ceiling along with put operation takes log(n) time. And there are n operations\\n\\n- Space complexity:\\nO(n) to store the ranges\\n\\n# Code\\n```\\ntype CountIntervals struct {\\n    ranges *treemap.Map\\n    count int\\n}\\n\\nfunc comparator(a, b interface{}) int {\\n    aInt := a.(int)\\n    bInt := b.(int)\\n    if aInt > bInt { return 1 }\\n    if aInt < bInt { return -1 }\\n    return 0\\n}\\n\\nfunc Constructor() CountIntervals {\\n    return CountIntervals{ranges: treemap.NewWith(comparator)}\\n}\\n\\n\\nfunc (this *CountIntervals) Add(left int, right int)  {\\n    prevStart, prevEnd := this.ranges.Floor(left)\\n    nextStart, nextEnd := this.ranges.Ceiling(left)\\n    if prevStart == nil && nextStart == nil {\\n        this.ranges.Put(left, right)\\n        this.count = right - left + 1\\n        return\\n    }\\n    start, end := left, right\\n    if prevStart != nil {\\n        // overlap and merge\\n        if prevEnd.(int) >= left {\\n            // Remove the previous range as merged one will be added\\n            this.ranges.Remove(prevStart)\\n            start = prevStart.(int)\\n            end = max(right, prevEnd.(int))\\n            // Remove the previous range count from total\\n            this.count -= (prevEnd.(int) - prevStart.(int)) + 1\\n        }\\n    }\\n    // Re-fetch next to avoid scenario where next is same as prev\\n    nextStart, nextEnd = this.ranges.Ceiling(left)\\n    // Keep finding next range until there is an overlap\\n    for nextStart != nil && end >= nextStart.(int) {\\n        // Remove the next range as merged one will be added\\n        this.ranges.Remove(nextStart)\\n        end = max(end, nextEnd.(int))\\n        // Remove the next range count from total\\n        this.count -= (nextEnd.(int) - nextStart.(int)) + 1\\n        nextStart, nextEnd = this.ranges.Ceiling(left)\\n    }\\n    \\n    // Add the count of merged range\\n    this.count += end - start + 1\\n    // Add the merged range to list of ranges\\n    this.ranges.Put(start, end)\\n}\\n\\n\\nfunc (this *CountIntervals) Count() int {\\n    return this.count\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(left,right);\\n * param_2 := obj.Count();\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Ordered Map"
                ],
                "code": "```\\ntype CountIntervals struct {\\n    ranges *treemap.Map\\n    count int\\n}\\n\\nfunc comparator(a, b interface{}) int {\\n    aInt := a.(int)\\n    bInt := b.(int)\\n    if aInt > bInt { return 1 }\\n    if aInt < bInt { return -1 }\\n    return 0\\n}\\n\\nfunc Constructor() CountIntervals {\\n    return CountIntervals{ranges: treemap.NewWith(comparator)}\\n}\\n\\n\\nfunc (this *CountIntervals) Add(left int, right int)  {\\n    prevStart, prevEnd := this.ranges.Floor(left)\\n    nextStart, nextEnd := this.ranges.Ceiling(left)\\n    if prevStart == nil && nextStart == nil {\\n        this.ranges.Put(left, right)\\n        this.count = right - left + 1\\n        return\\n    }\\n    start, end := left, right\\n    if prevStart != nil {\\n        // overlap and merge\\n        if prevEnd.(int) >= left {\\n            // Remove the previous range as merged one will be added\\n            this.ranges.Remove(prevStart)\\n            start = prevStart.(int)\\n            end = max(right, prevEnd.(int))\\n            // Remove the previous range count from total\\n            this.count -= (prevEnd.(int) - prevStart.(int)) + 1\\n        }\\n    }\\n    // Re-fetch next to avoid scenario where next is same as prev\\n    nextStart, nextEnd = this.ranges.Ceiling(left)\\n    // Keep finding next range until there is an overlap\\n    for nextStart != nil && end >= nextStart.(int) {\\n        // Remove the next range as merged one will be added\\n        this.ranges.Remove(nextStart)\\n        end = max(end, nextEnd.(int))\\n        // Remove the next range count from total\\n        this.count -= (nextEnd.(int) - nextStart.(int)) + 1\\n        nextStart, nextEnd = this.ranges.Ceiling(left)\\n    }\\n    \\n    // Add the count of merged range\\n    this.count += end - start + 1\\n    // Add the merged range to list of ranges\\n    this.ranges.Put(start, end)\\n}\\n\\n\\nfunc (this *CountIntervals) Count() int {\\n    return this.count\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(left,right);\\n * param_2 := obj.Count();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650727,
                "title": "fast-simple-python-solution",
                "content": "# Code\\n```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.boundary_cnt = defaultdict(int)\\n        self.cur_res = -1\\n        \\n    def add(self, left, right):\\n        self.boundary_cnt[left] += 1\\n        self.boundary_cnt[right + 1] -= 1\\n        self.cur_res = -1\\n        \\n    def count(self):\\n        if not self.boundary_cnt:\\n            return 0\\n        if self.cur_res != -1:\\n            return self.cur_res\\n        \\n        res = 0\\n        values = sorted(self.boundary_cnt.keys())\\n        left = -1\\n        cur_sum = 0\\n\\n        for v in values:\\n            if v not in self.boundary_cnt:\\n                continue\\n            \\n            cur_sum += self.boundary_cnt[v]\\n            if left == -1:\\n                if cur_sum > 0:\\n                    left = v\\n                continue\\n                \\n            if cur_sum > 0:\\n                del self.boundary_cnt[v]\\n            else:\\n                right = v\\n                res += right - left \\n                self.boundary_cnt[v] = - self.boundary_cnt[left]\\n                left = -1\\n\\n        self.cur_res = res\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.boundary_cnt = defaultdict(int)\\n        self.cur_res = -1\\n        \\n    def add(self, left, right):\\n        self.boundary_cnt[left] += 1\\n        self.boundary_cnt[right + 1] -= 1\\n        self.cur_res = -1\\n        \\n    def count(self):\\n        if not self.boundary_cnt:\\n            return 0\\n        if self.cur_res != -1:\\n            return self.cur_res\\n        \\n        res = 0\\n        values = sorted(self.boundary_cnt.keys())\\n        left = -1\\n        cur_sum = 0\\n\\n        for v in values:\\n            if v not in self.boundary_cnt:\\n                continue\\n            \\n            cur_sum += self.boundary_cnt[v]\\n            if left == -1:\\n                if cur_sum > 0:\\n                    left = v\\n                continue\\n                \\n            if cur_sum > 0:\\n                del self.boundary_cnt[v]\\n            else:\\n                right = v\\n                res += right - left \\n                self.boundary_cnt[v] = - self.boundary_cnt[left]\\n                left = -1\\n\\n        self.cur_res = res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629152,
                "title": "c-map",
                "content": "check for the collapsing intervals and update the sum along the way while adding\\n2 methods are shown \\n1) using map\\n2) using vector (TLE)\\n\\n# Code\\n```\\nclass CountIntervals {\\npublic:\\n    map<int,int> mp;\\n    int num=0;\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        auto pos = mp.upper_bound(left);\\n        if(pos!=mp.begin()){\\n            pos--;\\n            \\n            if(left > pos->second)\\n                pos++;\\n        }\\n        while(pos!=mp.end() && pos->first <= right){\\n            left=min(left,pos->first);\\n\\n            right=max(right,pos->second);\\n\\n            num-=(pos->second - pos->first + 1);\\n\\n            auto temp=pos++;\\n            mp.erase(temp);\\n        }\\n        mp[left]=right;\\n        num+=(right-left+1);\\n    }\\n    \\n    int count() {\\n        return num;\\n    }\\n};\\n\\n//  2nd approach but TLE\\n\\n// class CountIntervals {\\n// public:\\n//     vector<vector<int>> range;\\n//     int val=0;\\n//     CountIntervals() {\\n        \\n//     }\\n    \\n//     void add(int left, int right) {\\n//         vector<int> ser={left,left};\\n//         int i = upper_bound(range.begin(),range.end(),ser)-range.begin();\\n//         i=max(i-1,0);\\n//         for( ;i< range.size() ;i++){\\n//             if(range[i][0] <= left && right <= range[i][1] )\\n//                 return;\\n//             if(right<range[i][0])\\n//                 break;\\n//             if(left<=range[i][0] && range[i][0]<=right){\\n//                 right=max(right,range[i][1]);\\n//                 val-=(range[i][1]-range[i][0]+1);\\n//                 range.erase(range.begin()+i);\\n//                 i--;\\n//                 continue;\\n//             }\\n//             if(left<=range[i][1] && range[i][1]<=right){\\n//                 left=min(left,range[i][0]);\\n//                 val-=(range[i][1]-range[i][0]+1);\\n//                 range.erase(range.begin()+i);\\n//                 i--;\\n//                 continue;\\n//             }\\n//         }\\n\\n//         vector<int> temp={left,right};\\n//         auto index = upper_bound(range.begin(),range.end(),temp);\\n//         range.insert(index,temp);\\n//         val+=right-left+1;\\n//     }\\n    \\n//     int count() {\\n//         return val;\\n//     }\\n// };\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    map<int,int> mp;\\n    int num=0;\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        auto pos = mp.upper_bound(left);\\n        if(pos!=mp.begin()){\\n            pos--;\\n            \\n            if(left > pos->second)\\n                pos++;\\n        }\\n        while(pos!=mp.end() && pos->first <= right){\\n            left=min(left,pos->first);\\n\\n            right=max(right,pos->second);\\n\\n            num-=(pos->second - pos->first + 1);\\n\\n            auto temp=pos++;\\n            mp.erase(temp);\\n        }\\n        mp[left]=right;\\n        num+=(right-left+1);\\n    }\\n    \\n    int count() {\\n        return num;\\n    }\\n};\\n\\n//  2nd approach but TLE\\n\\n// class CountIntervals {\\n// public:\\n//     vector<vector<int>> range;\\n//     int val=0;\\n//     CountIntervals() {\\n        \\n//     }\\n    \\n//     void add(int left, int right) {\\n//         vector<int> ser={left,left};\\n//         int i = upper_bound(range.begin(),range.end(),ser)-range.begin();\\n//         i=max(i-1,0);\\n//         for( ;i< range.size() ;i++){\\n//             if(range[i][0] <= left && right <= range[i][1] )\\n//                 return;\\n//             if(right<range[i][0])\\n//                 break;\\n//             if(left<=range[i][0] && range[i][0]<=right){\\n//                 right=max(right,range[i][1]);\\n//                 val-=(range[i][1]-range[i][0]+1);\\n//                 range.erase(range.begin()+i);\\n//                 i--;\\n//                 continue;\\n//             }\\n//             if(left<=range[i][1] && range[i][1]<=right){\\n//                 left=min(left,range[i][0]);\\n//                 val-=(range[i][1]-range[i][0]+1);\\n//                 range.erase(range.begin()+i);\\n//                 i--;\\n//                 continue;\\n//             }\\n//         }\\n\\n//         vector<int> temp={left,right};\\n//         auto index = upper_bound(range.begin(),range.end(),temp);\\n//         range.insert(index,temp);\\n//         val+=right-left+1;\\n//     }\\n    \\n//     int count() {\\n//         return val;\\n//     }\\n// };\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584093,
                "title": "ruby-solution-with-binary-search-to-merge-intervals-100-100",
                "content": "# Intuition\\nKeep track of the count and merge intervals as you add them.\\n\\n# Approach\\n0. Initialize intervals to include endpoints for comparison and count to 0\\n\\n1. Find all intervals that will merge with the new interval, using binary search.  (Because @intervals was initialized with endpoints outside the range, both bsearches will always return a valid index.)\\n2. Find the ends of the merged interval.  Note that you use r-1 for the right side, because bsearch finds the first interval that will *not* merge.\\n3. Increment count by the the number of integers in the merged interval.\\n4. Decrement count by the number of integers in each interval that\\'s being removed.\\n5. Replace the old intervals that merge with the new interval.\\n\\n6. Return @count for count.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ for add, $$O(1)$$ for initialize and count\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass CountIntervals\\n    def initialize()\\n        @intervals = [[0,0],[Float::INFINITY,Float::INFINITY]]\\n        @count = 0\\n    end\\n\\n    def add(left, right)\\n\\n        len = @intervals.length\\n        l = (0...len).bsearch { |i| @intervals[i][1] >= left } # end is bigger than left -- could merge\\n        r = (0...len).bsearch { |i| @intervals[i][0] > right } # start is bigger than right -- first interval that can\\'t merge\\n\\n        int_left = [left,@intervals[l][0]].min\\n        int_right = [right,@intervals[r-1][1]].max\\n\\n        @count += int_right - int_left + 1\\n\\n        (l...r).each do |i|\\n            int = @intervals[i]\\n            remove = int[1] - int[0] + 1\\n            @count -= remove\\n        end\\n\\n        @intervals[l...r] = [[int_left,int_right]]\\n    end\\n\\n    def count()\\n        @count\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass CountIntervals\\n    def initialize()\\n        @intervals = [[0,0],[Float::INFINITY,Float::INFINITY]]\\n        @count = 0\\n    end\\n\\n    def add(left, right)\\n\\n        len = @intervals.length\\n        l = (0...len).bsearch { |i| @intervals[i][1] >= left } # end is bigger than left -- could merge\\n        r = (0...len).bsearch { |i| @intervals[i][0] > right } # start is bigger than right -- first interval that can\\'t merge\\n\\n        int_left = [left,@intervals[l][0]].min\\n        int_right = [right,@intervals[r-1][1]].max\\n\\n        @count += int_right - int_left + 1\\n\\n        (l...r).each do |i|\\n            int = @intervals[i]\\n            remove = int[1] - int[0] + 1\\n            @count -= remove\\n        end\\n\\n        @intervals[l...r] = [[int_left,int_right]]\\n    end\\n\\n    def count()\\n        @count\\n    end\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573602,
                "title": "binary-search-with-a-list-of-numbers-no-sortedlist-similar-to-range-module",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis uses a list of numbers instead of list of lists which all other solutions are using. \\n\\nIf the index of the number to be added is even, it means there is no overlap and we can insert/replace it as a subinterval.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimilar to [Range Module](https://leetcode.com/problems/range-module/) problem\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N) to add\\n    O(1) to search\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass CountIntervals:\\n    def __init__(self):\\n        self.interval = []\\n        self.cnt = 0\\n\\n    # TC - add - O(N)\\n    def add(self, left: int, right: int) -> None:\\n        left_idx = bisect.bisect_left(self.interval, left)\\n        right_idx = bisect.bisect_right(self.interval, right)\\n\\n        subinterval = []\\n        if left_idx % 2 == 0:\\n            subinterval.append(left)\\n        if right_idx % 2 == 0:\\n            subinterval.append(right)\\n        \\n        # Replace/add the interval\\n        self.interval[left_idx:right_idx] = subinterval\\n        \\n        if len(subinterval) == 2 and len(self.interval[left_idx:right_idx]) == 0:\\n            self.cnt += abs(subinterval[1]-subinterval[0]+1)\\n        else:\\n            # Recalculating - Optimization possible here\\n            self.cnt = 0\\n            for i in range(0,len(self.interval),2):\\n                self.cnt += abs(self.interval[i+1] - self.interval[i] + 1) \\n        \\n    def count(self) -> int:\\n        return self.cnt\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass CountIntervals:\\n    def __init__(self):\\n        self.interval = []\\n        self.cnt = 0\\n\\n    # TC - add - O(N)\\n    def add(self, left: int, right: int) -> None:\\n        left_idx = bisect.bisect_left(self.interval, left)\\n        right_idx = bisect.bisect_right(self.interval, right)\\n\\n        subinterval = []\\n        if left_idx % 2 == 0:\\n            subinterval.append(left)\\n        if right_idx % 2 == 0:\\n            subinterval.append(right)\\n        \\n        # Replace/add the interval\\n        self.interval[left_idx:right_idx] = subinterval\\n        \\n        if len(subinterval) == 2 and len(self.interval[left_idx:right_idx]) == 0:\\n            self.cnt += abs(subinterval[1]-subinterval[0]+1)\\n        else:\\n            # Recalculating - Optimization possible here\\n            self.cnt = 0\\n            for i in range(0,len(self.interval),2):\\n                self.cnt += abs(self.interval[i+1] - self.interval[i] + 1) \\n        \\n    def count(self) -> int:\\n        return self.cnt\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572282,
                "title": "c-map-int-int",
                "content": "# Approach\\nThis problem is an easier version of [715 - Range Module](https://leetcode.com/problems/range-module/solutions/3569928/c-map-int-int-and-edge-cases/). \\n# Complexity\\n- Time complexity: $$O(n~\\\\textrm{log}~n)$$ where $$n$$ is the number of intervals\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass CountIntervals {\\n    map<int,int> dat;\\n    int cnt;\\npublic:\\n    CountIntervals() {\\n        int INF = 2e9;\\n        dat[-INF] = -INF;\\n        dat[INF] = INF;\\n        cnt = 0;\\n    }\\n    \\n    void add(int l, int r) {\\n        if (prev(dat.upper_bound(l))->second >= r) return;\\n        auto lo = dat.lower_bound(l);\\n        auto hi = dat.upper_bound(r);\\n        int L = l;\\n        if (prev(lo)->second >= l-1) {\\n            L = prev(lo)->first;\\n            lo = prev(lo);\\n        }\\n        int R = r;\\n        if (prev(hi)->second > r) {\\n            R = prev(hi)->second;\\n        }\\n        if (hi->first == r+1) {\\n            R = hi->second;\\n            hi = next(hi);\\n        }\\n        vector<map<int,int>::iterator> rem;\\n        for (auto it = lo; it != hi; ++it) rem.push_back(it);\\n        for (auto it : rem) {\\n            cnt -= it->second - it->first + 1;\\n            dat.erase(it);\\n        }\\n        dat[L] = R;\\n        cnt += R - L + 1;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass CountIntervals {\\n    map<int,int> dat;\\n    int cnt;\\npublic:\\n    CountIntervals() {\\n        int INF = 2e9;\\n        dat[-INF] = -INF;\\n        dat[INF] = INF;\\n        cnt = 0;\\n    }\\n    \\n    void add(int l, int r) {\\n        if (prev(dat.upper_bound(l))->second >= r) return;\\n        auto lo = dat.lower_bound(l);\\n        auto hi = dat.upper_bound(r);\\n        int L = l;\\n        if (prev(lo)->second >= l-1) {\\n            L = prev(lo)->first;\\n            lo = prev(lo);\\n        }\\n        int R = r;\\n        if (prev(hi)->second > r) {\\n            R = prev(hi)->second;\\n        }\\n        if (hi->first == r+1) {\\n            R = hi->second;\\n            hi = next(hi);\\n        }\\n        vector<map<int,int>::iterator> rem;\\n        for (auto it = lo; it != hi; ++it) rem.push_back(it);\\n        for (auto it : rem) {\\n            cnt -= it->second - it->first + 1;\\n            dat.erase(it);\\n        }\\n        dat[L] = R;\\n        cnt += R - L + 1;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549948,
                "title": "python-bisect-merge",
                "content": "```python\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.total = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        # insert\\n        index = bisect.bisect(self.intervals, [left, right])\\n        self.intervals.insert(index, [left, right])\\n        self.total += right - left + 1\\n\\n        # merge\\n        i, j = max(0, index - 1), len(self.intervals) - 1\\n        while i < j:\\n            if self.intervals[i][1] + 1 < self.intervals[i+1][0]:\\n                i += 1\\n                continue\\n\\n            # calculate difference\\n            a = self.intervals[i+0][1] - self.intervals[i+0][0] + 1\\n            b = self.intervals[i+1][1] - self.intervals[i+1][0] + 1\\n            c = a + b\\n\\n            self.intervals[i][1] = max(self.intervals[i][1], self.intervals[i+1][1])\\n            self.total -= c - (self.intervals[i][1] - self.intervals[i][0] + 1)\\n\\n            # remove next\\n            self.intervals.pop(i + 1)\\n            j -= 1\\n\\n    def count(self) -> int:\\n        return self.total\\n```",
                "solutionTags": [],
                "code": "```python\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.total = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        # insert\\n        index = bisect.bisect(self.intervals, [left, right])\\n        self.intervals.insert(index, [left, right])\\n        self.total += right - left + 1\\n\\n        # merge\\n        i, j = max(0, index - 1), len(self.intervals) - 1\\n        while i < j:\\n            if self.intervals[i][1] + 1 < self.intervals[i+1][0]:\\n                i += 1\\n                continue\\n\\n            # calculate difference\\n            a = self.intervals[i+0][1] - self.intervals[i+0][0] + 1\\n            b = self.intervals[i+1][1] - self.intervals[i+1][0] + 1\\n            c = a + b\\n\\n            self.intervals[i][1] = max(self.intervals[i][1], self.intervals[i+1][1])\\n            self.total -= c - (self.intervals[i][1] - self.intervals[i][0] + 1)\\n\\n            # remove next\\n            self.intervals.pop(i + 1)\\n            j -= 1\\n\\n    def count(self) -> int:\\n        return self.total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534572,
                "title": "dynamic-segment-tree-with-statically-allocated-nodes",
                "content": "# Code\\n```\\nint i;\\n\\ntemplate<typename T=int>\\nstruct SegTreeNode {\\n    int left, right;\\n    T val, lazy;\\n    SegTreeNode<T> *leftChild, *rightChild;\\n    T noOverlapVal = 0;\\n\\n    SegTreeNode<int>* nodes;\\n\\n    SegTreeNode() {\\n\\n    }\\n\\n    void init(int left, int right, SegTreeNode<int>* nodes) {\\n        this->nodes = nodes;\\n        this->left = left;\\n        this->right = right;\\n        this->val = 0;\\n        this->lazy = 0;\\n        this->leftChild = NULL;\\n        this->rightChild = NULL;\\n    }\\n\\n    void extend() {\\n        if(not leftChild and left != right) {\\n            int mid = (left + right) / 2;\\n            leftChild = &(*(nodes+(i++)));\\n            leftChild->init(left, mid, nodes);\\n            rightChild = &(*(nodes+(i++)));\\n            rightChild->init(mid+1, right, nodes);\\n        }\\n    }\\n\\n    T operate(T a, T b) {\\n        return a + b;\\n    }\\n\\n    void pull() {\\n        val = operate(leftChild->val, rightChild->val);\\n    }\\n\\n    void push() {\\n        extend();\\n\\n        if(lazy) {\\n            val = right-left+1;\\n\\n            if(left != right) {\\n                leftChild->lazy = 1;\\n                rightChild->lazy = 1;\\n            }\\n\\n            lazy = 0;\\n        }\\n    }\\n\\n    T query(int qs, int qe) {\\n        push();\\n\\n        if(right < qs or left > qe) return noOverlapVal;\\n\\n        if(left >= qs and right <= qe) return val;\\n\\n        return operate(leftChild->query(qs, qe), rightChild->query(qs, qe));\\n    }\\n\\n    T query(int i) {\\n        return query(i, i);\\n    }\\n\\n    void update(int qs, int qe, T upd) {\\n        push();\\n\\n        if(right < qs or left > qe) return;\\n\\n        if(left >= qs and right <= qe) {\\n            lazy = 1;\\n            push();\\n            return;\\n        }\\n\\n        leftChild->update(qs, qe, upd);\\n        rightChild->update(qs, qe, upd);\\n\\n        pull();\\n    }\\n};\\n\\nSegTreeNode<int> nodes[(int)3e6];\\n\\n\\nclass CountIntervals {\\npublic:\\n    SegTreeNode<int>* root;\\n\\n    CountIntervals() {\\n        i = 0;\\n        root = &(*(nodes+(i++)));\\n        root->init(0, 1e9, nodes);\\n    }\\n    \\n    void add(int left, int right) {\\n        root->update(left, right, 1);\\n    }\\n    \\n    int count() {\\n        return root->query(0, 1e9);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nint i;\\n\\ntemplate<typename T=int>\\nstruct SegTreeNode {\\n    int left, right;\\n    T val, lazy;\\n    SegTreeNode<T> *leftChild, *rightChild;\\n    T noOverlapVal = 0;\\n\\n    SegTreeNode<int>* nodes;\\n\\n    SegTreeNode() {\\n\\n    }\\n\\n    void init(int left, int right, SegTreeNode<int>* nodes) {\\n        this->nodes = nodes;\\n        this->left = left;\\n        this->right = right;\\n        this->val = 0;\\n        this->lazy = 0;\\n        this->leftChild = NULL;\\n        this->rightChild = NULL;\\n    }\\n\\n    void extend() {\\n        if(not leftChild and left != right) {\\n            int mid = (left + right) / 2;\\n            leftChild = &(*(nodes+(i++)));\\n            leftChild->init(left, mid, nodes);\\n            rightChild = &(*(nodes+(i++)));\\n            rightChild->init(mid+1, right, nodes);\\n        }\\n    }\\n\\n    T operate(T a, T b) {\\n        return a + b;\\n    }\\n\\n    void pull() {\\n        val = operate(leftChild->val, rightChild->val);\\n    }\\n\\n    void push() {\\n        extend();\\n\\n        if(lazy) {\\n            val = right-left+1;\\n\\n            if(left != right) {\\n                leftChild->lazy = 1;\\n                rightChild->lazy = 1;\\n            }\\n\\n            lazy = 0;\\n        }\\n    }\\n\\n    T query(int qs, int qe) {\\n        push();\\n\\n        if(right < qs or left > qe) return noOverlapVal;\\n\\n        if(left >= qs and right <= qe) return val;\\n\\n        return operate(leftChild->query(qs, qe), rightChild->query(qs, qe));\\n    }\\n\\n    T query(int i) {\\n        return query(i, i);\\n    }\\n\\n    void update(int qs, int qe, T upd) {\\n        push();\\n\\n        if(right < qs or left > qe) return;\\n\\n        if(left >= qs and right <= qe) {\\n            lazy = 1;\\n            push();\\n            return;\\n        }\\n\\n        leftChild->update(qs, qe, upd);\\n        rightChild->update(qs, qe, upd);\\n\\n        pull();\\n    }\\n};\\n\\nSegTreeNode<int> nodes[(int)3e6];\\n\\n\\nclass CountIntervals {\\npublic:\\n    SegTreeNode<int>* root;\\n\\n    CountIntervals() {\\n        i = 0;\\n        root = &(*(nodes+(i++)));\\n        root->init(0, 1e9, nodes);\\n    }\\n    \\n    void add(int left, int right) {\\n        root->update(left, right, 1);\\n    }\\n    \\n    int count() {\\n        return root->query(0, 1e9);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521575,
                "title": "extension-to-merge-two-intervals-o-nlogn-add-o-1-count",
                "content": "# Intuition\\nThis is an extension of the problem of merging two intervals.\\n\\n# Approach\\nIntervals are coming in a stream. We keep all previous intervals in the sorted order. We should be able to add a new element, access new element, access one previus element to maybe merge it with the new element and access all succeeding elements up to the one that is disjoint for merging. We want to be able to remove all intervals that are merged. The appropriate data strtucture for all of the above is balanced BST (multiset in C++). One thing to pay attention is to keep count in long long to avoid int overflow. Second thing that popped up is that a pointer to an element in BST is constant iterator so to update it in place when we merged another interval into it, we need to remove const with the cast:\\n\\n((pair<long long, int>*)&*pointer_to_el_in_bst)->second = ...\\n\\n# Complexity\\n- Time complexity:\\nCount question: O(1)\\nAdd new interval: insert O(logN), merge with the previous if necessary O(1), remove merged interval O(logN), merge with all succeeding up to the last that is disjoint O(N), remove merged interval O(logN). Overall complexity: O(logN) + O(1) + O(logN) + N*(O(1) + O(logN)) = O(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass CountIntervals {\\npublic:\\n    multiset<pair<long long, int>, less<pair<long long, int>>> bst;\\n    long long totalcount = 0;\\n\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        bst.insert({left, right});\\n        totalcount += right - left + 1;\\n        auto currel = bst.find({left, right});\\n        if (currel != bst.begin()) {\\n            auto prevel = prev(currel);\\n            if (prevel->second >= currel->first) {\\n                totalcount -= prevel->second - prevel->first + 1 + currel->second - currel->first + 1;\\n                ((pair<long long, int>*)&*prevel)->second = max(prevel->second, currel->second);\\n                totalcount += prevel->second - prevel->first + 1;\\n                bst.erase(currel);\\n                currel = prevel;\\n            }\\n        }\\n\\n        for (auto el = next(currel), mergel = currel; el != bst.end();) {\\n            if (mergel->second >= el->first) {\\n                totalcount -= mergel->second - mergel->first + 1 + el->second - el->first + 1;\\n                ((pair<long long, int>*)&*mergel)->second = max(mergel->second, el->second);\\n                totalcount += mergel->second - mergel->first + 1;\\n                auto toremove = el;\\n                el = next(el);\\n                bst.erase(toremove);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return totalcount;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    multiset<pair<long long, int>, less<pair<long long, int>>> bst;\\n    long long totalcount = 0;\\n\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        bst.insert({left, right});\\n        totalcount += right - left + 1;\\n        auto currel = bst.find({left, right});\\n        if (currel != bst.begin()) {\\n            auto prevel = prev(currel);\\n            if (prevel->second >= currel->first) {\\n                totalcount -= prevel->second - prevel->first + 1 + currel->second - currel->first + 1;\\n                ((pair<long long, int>*)&*prevel)->second = max(prevel->second, currel->second);\\n                totalcount += prevel->second - prevel->first + 1;\\n                bst.erase(currel);\\n                currel = prevel;\\n            }\\n        }\\n\\n        for (auto el = next(currel), mergel = currel; el != bst.end();) {\\n            if (mergel->second >= el->first) {\\n                totalcount -= mergel->second - mergel->first + 1 + el->second - el->first + 1;\\n                ((pair<long long, int>*)&*mergel)->second = max(mergel->second, el->second);\\n                totalcount += mergel->second - mergel->first + 1;\\n                auto toremove = el;\\n                el = next(el);\\n                bst.erase(toremove);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return totalcount;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502863,
                "title": "c-expand-left-right-to-include-existing-interval-to-avoid-interval-split",
                "content": "1. `++right` to make interval open - math is always cleaner this way.\\n2. use `set`, with left/right annotation, to represent ordered intervals.\\n3. if `left` touches or inside existing interval, expand left `left`.\\n4. if `right` touches or inside exisiting interval, expand right `right`.\\n5. add end sentinel to `set` to avoid `end()` check.\\n```\\nclass CountIntervals {\\n    set<pair<int,int>> intervals { { pair(INT_MAX, 0) } };  // interval [i, j) will be stored as (i,0) and (j,1)\\n    int cnt = 0;\\npublic:\\n    void add(int left, int right) {\\n        auto l = intervals.lower_bound(pair(left,0));\\n        auto r = intervals.lower_bound(pair(++right,0)); //make interval right open\\n\\n        if(l->second)               //left inside interval ending at l\\n            left = (--l)->first;    //expand left to inclue this interval\\n\\n        if(r->second)               //right inside interval ending at r\\n            right = r++->first;     //expand right to include this interval\\n        else if(r->first == right) {//right touch interval left\\n            right = (++r)->first;   //expand right to include this interval\\n            ++r;\\n        }\\n\\n        while(l != r) {             //remove all intervals from [l to r)\\n            cnt += l->first; l = intervals.erase(l);\\n            cnt -= l->first; l = intervals.erase(l);\\n        }\\n\\n        intervals.emplace(left,0);  //now add the new expanded interval [left, right)\\n        intervals.emplace(right,1);\\n        cnt += right - left;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CountIntervals {\\n    set<pair<int,int>> intervals { { pair(INT_MAX, 0) } };  // interval [i, j) will be stored as (i,0) and (j,1)\\n    int cnt = 0;\\npublic:\\n    void add(int left, int right) {\\n        auto l = intervals.lower_bound(pair(left,0));\\n        auto r = intervals.lower_bound(pair(++right,0)); //make interval right open\\n\\n        if(l->second)               //left inside interval ending at l\\n            left = (--l)->first;    //expand left to inclue this interval\\n\\n        if(r->second)               //right inside interval ending at r\\n            right = r++->first;     //expand right to include this interval\\n        else if(r->first == right) {//right touch interval left\\n            right = (++r)->first;   //expand right to include this interval\\n            ++r;\\n        }\\n\\n        while(l != r) {             //remove all intervals from [l to r)\\n            cnt += l->first; l = intervals.erase(l);\\n            cnt -= l->first; l = intervals.erase(l);\\n        }\\n\\n        intervals.emplace(left,0);  //now add the new expanded interval [left, right)\\n        intervals.emplace(right,1);\\n        cnt += right - left;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496631,
                "title": "my-solution",
                "content": "```\\n/**\\n * let `n` is the number of the unoverlapping intervals of the data structure `CountIntervals`\\n *\\n * Space Complexity: O(n)\\n */\\nclass CountIntervals {\\n public:\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  CountIntervals() : count_(0) {\\n  }\\n\\n  /**\\n   * Time Complexity [Average]: O(log(n))\\n   * Space Complexity: O(1)\\n   */\\n  void add(const int left, const int right) {\\n    int start = left;\\n    int end = right + 1;\\n    auto lb = intervals_.lower_bound(start);\\n    auto prev_lb = lb == intervals_.begin() ? intervals_.end() : prev(lb);\\n    for (auto itr = lb; itr != intervals_.end() && itr->first <= end; itr = intervals_.erase(itr)) {\\n      end = max(itr->second, end);\\n      count_ -= itr->second - itr->first;\\n    }\\n    if (prev_lb != intervals_.end() && prev_lb->second >= left) {\\n      end = max(prev_lb->second, end);\\n      start = prev_lb->first;\\n      count_ -= prev_lb->second - prev_lb->first;\\n      intervals_.erase(prev_lb);\\n    }\\n    count_ += end - start;\\n    intervals_[start] = end;\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  int count() {\\n    return count_;\\n  }\\n  \\n private:\\n  map<int, int> intervals_;\\n  int count_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * let `n` is the number of the unoverlapping intervals of the data structure `CountIntervals`\\n *\\n * Space Complexity: O(n)\\n */\\nclass CountIntervals {\\n public:\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  CountIntervals() : count_(0) {\\n  }\\n\\n  /**\\n   * Time Complexity [Average]: O(log(n))\\n   * Space Complexity: O(1)\\n   */\\n  void add(const int left, const int right) {\\n    int start = left;\\n    int end = right + 1;\\n    auto lb = intervals_.lower_bound(start);\\n    auto prev_lb = lb == intervals_.begin() ? intervals_.end() : prev(lb);\\n    for (auto itr = lb; itr != intervals_.end() && itr->first <= end; itr = intervals_.erase(itr)) {\\n      end = max(itr->second, end);\\n      count_ -= itr->second - itr->first;\\n    }\\n    if (prev_lb != intervals_.end() && prev_lb->second >= left) {\\n      end = max(prev_lb->second, end);\\n      start = prev_lb->first;\\n      count_ -= prev_lb->second - prev_lb->first;\\n      intervals_.erase(prev_lb);\\n    }\\n    count_ += end - start;\\n    intervals_[start] = end;\\n  }\\n\\n  /**\\n   * Time Complexity: O(1)\\n   * Space Complexity: O(1)\\n   */\\n  int count() {\\n    return count_;\\n  }\\n  \\n private:\\n  map<int, int> intervals_;\\n  int count_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428406,
                "title": "image-explanation-c",
                "content": "\\n![image](https://assets.leetcode.com/users/images/80e8a9a2-5fd4-4c2e-9c18-92c2e401ec01_1681762337.9427881.png)\\n![image](https://assets.leetcode.com/users/images/10666b59-660b-42d2-9883-c7dd5ca26daf_1681762429.5587714.png)\\n![image](https://assets.leetcode.com/users/images/cfdd0529-3c4e-4b9c-8ea9-9c657e0074c8_1681762429.699208.png)\\n\\n```\\nclass CountIntervals {\\npublic:\\n     set<pair<int, int>> st;\\n     int cnt;\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = st.lower_bound({left, right});\\n        \\n        if(it != st.begin() && (--it)->second < left) {\\n            ++it;\\n        }\\n        \\n        while(it != st.end() and it->first<=right) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            \\n            cnt -= (it->second - it->first + 1);\\n            it = st.erase(it);\\n        }\\n        \\n        st.insert({ left, right });\\n        cnt += (right - left + 1);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n     set<pair<int, int>> st;\\n     int cnt;\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = st.lower_bound({left, right});\\n        \\n        if(it != st.begin() && (--it)->second < left) {\\n            ++it;\\n        }\\n        \\n        while(it != st.end() and it->first<=right) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            \\n            cnt -= (it->second - it->first + 1);\\n            it = st.erase(it);\\n        }\\n        \\n        st.insert({ left, right });\\n        cnt += (right - left + 1);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415179,
                "title": "merge-intervals-using-set",
                "content": "\\n\\n# Code\\n```\\nclass CountIntervals {\\npublic:\\n    int k=0;\\n    set<pair<int,int>>s;\\n    CountIntervals() {\\n        k=0;\\n        s.clear();\\n    }\\n    \\n    void add(int l, int r) {\\n        \\n        auto it=s.upper_bound({l,r});\\n        \\n        auto p=it;\\n        if(p!=s.begin())\\n        p--;\\n\\n        if(it!=s.begin())\\n        {\\n            if(p->second>=l)\\n            {\\n                --it;\\n            }\\n        }\\n\\n        while(true)\\n        {\\n            if(it==s.end())\\n                break;\\n            if(it->first>r)\\n                break;\\n\\n            k-=(it->second-it->first+1);\\n            \\n            l=min(l,it->first);\\n            r=max(r,it->second);\\n            it=s.erase(it);\\n\\n            if(it==s.end())\\n                break;\\n        }\\n\\n        k+=(r-l+1);\\n        s.insert({l,r});\\n    }\\n    \\n    int count() {\\n        return k;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    int k=0;\\n    set<pair<int,int>>s;\\n    CountIntervals() {\\n        k=0;\\n        s.clear();\\n    }\\n    \\n    void add(int l, int r) {\\n        \\n        auto it=s.upper_bound({l,r});\\n        \\n        auto p=it;\\n        if(p!=s.begin())\\n        p--;\\n\\n        if(it!=s.begin())\\n        {\\n            if(p->second>=l)\\n            {\\n                --it;\\n            }\\n        }\\n\\n        while(true)\\n        {\\n            if(it==s.end())\\n                break;\\n            if(it->first>r)\\n                break;\\n\\n            k-=(it->second-it->first+1);\\n            \\n            l=min(l,it->first);\\n            r=max(r,it->second);\\n            it=s.erase(it);\\n\\n            if(it==s.end())\\n                break;\\n        }\\n\\n        k+=(r-l+1);\\n        s.insert({l,r});\\n    }\\n    \\n    int count() {\\n        return k;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392786,
                "title": "simple-dimple-cpp-solution-using-set-cleanest-self-explanatory",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Use set in order to keep intervals in sorted order.\\n- Find the overlapping intervals and erase them.\\n- Add the new intervals.\\n- Keep the count of the number of elements.\\n\\n# Complexity\\n- Time complexity: O(N + logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\nWhere, N = Number of intervals.\\n\\n# Code\\n```\\nclass CountIntervals {\\n    set<pair<int, int>> st;\\n    int cnt = 0;\\npublic:\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = st.upper_bound({left, INT_MIN});\\n        if(it != st.begin() && (--it)->second < left) {\\n            ++it;\\n        }\\n        \\n        while(it != st.end() && it->first <= right) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            \\n            cnt -= (it->second - it->first + 1);\\n            it = st.erase(it);\\n        }\\n        \\n        st.insert({ left, right });\\n        cnt += (right - left + 1);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```\\n\\nPLEASEEEEE UPVOTE",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass CountIntervals {\\n    set<pair<int, int>> st;\\n    int cnt = 0;\\npublic:\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = st.upper_bound({left, INT_MIN});\\n        if(it != st.begin() && (--it)->second < left) {\\n            ++it;\\n        }\\n        \\n        while(it != st.end() && it->first <= right) {\\n            left = min(left, it->first);\\n            right = max(right, it->second);\\n            \\n            cnt -= (it->second - it->first + 1);\\n            it = st.erase(it);\\n        }\\n        \\n        st.insert({ left, right });\\n        cnt += (right - left + 1);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361766,
                "title": "c-merge-intervals",
                "content": "<iframe src=\"https://leetcode.com/playground/gSHHM8Ke/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>",
                "solutionTags": [],
                "code": "<iframe src=\"https://leetcode.com/playground/gSHHM8Ke/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3312230,
                "title": "easiest-possible-solution-using-treemap-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CountIntervals {\\n    TreeMap<Integer,Integer> tm;\\n    int count;\\n    public CountIntervals() {\\n        tm = new TreeMap<>();\\n        count =0;\\n    }\\n    \\n    public void add(int left, int right) {\\n\\n        if(tm.floorKey(left)!=null) {\\n            int floorKey1 = tm.floorKey(left);\\n            if(tm.get(floorKey1)>=left){\\n                left = floorKey1;\\n            }\\n        }\\n        if(tm.floorKey(right)!=null) {\\n            int floorKey2 = tm.floorKey(right);\\n            if(tm.get(floorKey2)>right) {\\n                right = tm.get(floorKey2);\\n            }     \\n        }\\n\\n        int countToRemove = 0;\\n        for(int key: tm.subMap(left,right+1).keySet()) {\\n            countToRemove+=tm.get(key)-key+1;\\n        }\\n        count-=countToRemove;\\n\\n        // Clear all inbetween values\\n        tm.subMap(left,right+1).clear();\\n\\n        tm.put(left,right);\\n        count+=right-left+1;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CountIntervals {\\n    TreeMap<Integer,Integer> tm;\\n    int count;\\n    public CountIntervals() {\\n        tm = new TreeMap<>();\\n        count =0;\\n    }\\n    \\n    public void add(int left, int right) {\\n\\n        if(tm.floorKey(left)!=null) {\\n            int floorKey1 = tm.floorKey(left);\\n            if(tm.get(floorKey1)>=left){\\n                left = floorKey1;\\n            }\\n        }\\n        if(tm.floorKey(right)!=null) {\\n            int floorKey2 = tm.floorKey(right);\\n            if(tm.get(floorKey2)>right) {\\n                right = tm.get(floorKey2);\\n            }     \\n        }\\n\\n        int countToRemove = 0;\\n        for(int key: tm.subMap(left,right+1).keySet()) {\\n            countToRemove+=tm.get(key)-key+1;\\n        }\\n        count-=countToRemove;\\n\\n        // Clear all inbetween values\\n        tm.subMap(left,right+1).clear();\\n\\n        tm.put(left,right);\\n        count+=right-left+1;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235017,
                "title": "java-treemap-easy-to-explain-and-memorize-in-interview-with-pictures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse TreeMap (Balanced Binary Search Tree) to track every interval, and maintain order.\\n\\nWhen \"add(left, right)\" causes overlap with existing intervals, remove every interval \"covered\" by [left,right], and add [left,right] into the TreeMap.\\n\\nI am trying to make code as memorizable and easy to understand as possible.\\n\\nThere are many cases in this problem.\\n- Overlap between existing and new intervals\\n- The new interval just overlaps (but does not totally cover) some existing intervals.\\n\\n\\nConverge some cases to some easily-explainable steps, **easy to explain in interview**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn some solutions, in TreeMap, key is left edge, value is right edge of interval. Then there are many corner cases.\\nIn my solution, in TreeMap, key is edge of interval (either left or right), value is Boolean (false means left edge, true means right edge).\\n\\n```\\nTreeMap<Integer, Boolean> edges;\\n\\n// true -- right edge\\n// false -- left edge\\n// If add(3,5), then the map has (3,false), (6,true)\\n// range [3,6) -- left included, right not included\\n\\n// Use \"Example 1\" in the description\\n// [\"CountIntervals\", \"add\", \"add\", \"count\", \"add\", \"count\"]\\n// [[], [2, 3], [7, 10], [], [5, 8], []]\\n// 1. add 2,3\\n// edges: (2,false), (4,true)\\n// 2. add 7,10\\n// edges: (2,false), (4,true), (7,false), (11, true)\\n// 3. add 5,8 -- handle overlap\\n// edges: (2,false), (4,true), (5,false), (11, true)\\n```\\n\\nHow to handle overlap?\\n\\n## Step 1\\n![code1.jpg](https://assets.leetcode.com/users/images/378188b2-5d0d-457b-9ca8-111bb624043d_1677472560.4769201.jpeg)\\nIn this picture,\\n- If `left` is inside one existing interval, **extend** `left` to the left edge of the interval.\\n- If `right` is inside one existing interval, same, **extend** `right` to the right edge of the interval.\\nThen every interval which overlaps with `[left,right]` is **totally covered** by `[left,right]` now.\\n\\n![code2.jpg](https://assets.leetcode.com/users/images/c466c59a-3677-47df-ae8e-e2f7cf4ac02a_1677473888.111718.jpeg)\\n\\n## Step 2\\nRemove every interval covered by `[left,right]` from TreeMap, also update `count0` (see in code).\\n\\n## Step 3\\nAdd interval `[left,right]` to TreeMap, and also update `count0`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`void add(left,right)` is amortized $$O(log(n))$$\\n`int count()` is $$O(1)$$\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.SortedMap;\\n\\nclass CountIntervals {\\n\\n    TreeMap<Integer, Boolean> edges;\\n    int count0 = 0;\\n\\n    public CountIntervals() {\\n        edges = new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n        ++right; // right not included\\n\\n        // $left can be inside one existing interval\\n        // Extend $left!\\n        Integer a = edges.floorKey(left);\\n        if (a!=null) {\\n            if (!edges.get(a)) {\\n                // left edge\\n                left = a;\\n            } else {\\n                // right edge\\n                if (left == a) {\\n                    left = edges.lowerKey(a);\\n                }\\n            }\\n        }\\n\\n        // $right can be inside one existing interval\\n        // Extend $right!\\n        Integer b = edges.ceilingKey(right);\\n        if (b!=null) {\\n            if (edges.get(b)) {\\n                // right edge\\n                right = b;\\n            } else {\\n                // left edge\\n                if (right == b) {\\n                    right = edges.higherKey(b);\\n                }\\n            }\\n        }\\n\\n        // remove everything between a, b (include a,b)\\n        SortedMap<Integer, Boolean> submap = \\n            edges.headMap(right,true).tailMap(left,true);\\n\\n        int curr = -12345;\\n        for (Map.Entry<Integer, Boolean> e : submap.entrySet()) {\\n            if (e.getValue()) {\\n                count0 -= (e.getKey()-curr);\\n            } else {\\n                curr = e.getKey();\\n            }\\n        }\\n        submap.clear();\\n\\n        // Insert this interval\\n        edges.put(left, false);\\n        edges.put(right, true);\\n        count0 += (right-left);\\n    }\\n    \\n    public int count() {\\n        return count0;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nTreeMap<Integer, Boolean> edges;\\n\\n// true -- right edge\\n// false -- left edge\\n// If add(3,5), then the map has (3,false), (6,true)\\n// range [3,6) -- left included, right not included\\n\\n// Use \"Example 1\" in the description\\n// [\"CountIntervals\", \"add\", \"add\", \"count\", \"add\", \"count\"]\\n// [[], [2, 3], [7, 10], [], [5, 8], []]\\n// 1. add 2,3\\n// edges: (2,false), (4,true)\\n// 2. add 7,10\\n// edges: (2,false), (4,true), (7,false), (11, true)\\n// 3. add 5,8 -- handle overlap\\n// edges: (2,false), (4,true), (5,false), (11, true)\\n```\n```\\nimport java.util.SortedMap;\\n\\nclass CountIntervals {\\n\\n    TreeMap<Integer, Boolean> edges;\\n    int count0 = 0;\\n\\n    public CountIntervals() {\\n        edges = new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n        ++right; // right not included\\n\\n        // $left can be inside one existing interval\\n        // Extend $left!\\n        Integer a = edges.floorKey(left);\\n        if (a!=null) {\\n            if (!edges.get(a)) {\\n                // left edge\\n                left = a;\\n            } else {\\n                // right edge\\n                if (left == a) {\\n                    left = edges.lowerKey(a);\\n                }\\n            }\\n        }\\n\\n        // $right can be inside one existing interval\\n        // Extend $right!\\n        Integer b = edges.ceilingKey(right);\\n        if (b!=null) {\\n            if (edges.get(b)) {\\n                // right edge\\n                right = b;\\n            } else {\\n                // left edge\\n                if (right == b) {\\n                    right = edges.higherKey(b);\\n                }\\n            }\\n        }\\n\\n        // remove everything between a, b (include a,b)\\n        SortedMap<Integer, Boolean> submap = \\n            edges.headMap(right,true).tailMap(left,true);\\n\\n        int curr = -12345;\\n        for (Map.Entry<Integer, Boolean> e : submap.entrySet()) {\\n            if (e.getValue()) {\\n                count0 -= (e.getKey()-curr);\\n            } else {\\n                curr = e.getKey();\\n            }\\n        }\\n        submap.clear();\\n\\n        // Insert this interval\\n        edges.put(left, false);\\n        edges.put(right, true);\\n        count0 += (right-left);\\n    }\\n    \\n    public int count() {\\n        return count0;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224895,
                "title": "python-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node:\\n    def __init__(self):\\n        self.val = self.left = self.right = None\\n\\n    def add(self, node, x, y, s, e):\\n        if e <= x or y <= s or node and node.val == y-x: return node\\n\\n        if not node: node = Node()\\n\\n        if s <= x and y <= e:\\n            node.val = y-x\\n            return node\\n\\n        mid = (x+y)//2\\n\\n        node.left = self.add(node.left, x, mid, s, e)\\n        node.right = self.add(node.right, mid, y, s, e)\\n\\n        node.val = 0\\n\\n        if node.left: node.val += node.left.val\\n        if node.right: node.val += node.right.val \\n\\n        return node\\n\\nclass CountIntervals:\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def add(self, left, right):\\n        self.root.add(self.root,1,10**9+1,left,right+1)\\n\\n    def count(self):\\n        return self.root.val or 0\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.val = self.left = self.right = None\\n\\n    def add(self, node, x, y, s, e):\\n        if e <= x or y <= s or node and node.val == y-x: return node\\n\\n        if not node: node = Node()\\n\\n        if s <= x and y <= e:\\n            node.val = y-x\\n            return node\\n\\n        mid = (x+y)//2\\n\\n        node.left = self.add(node.left, x, mid, s, e)\\n        node.right = self.add(node.right, mid, y, s, e)\\n\\n        node.val = 0\\n\\n        if node.left: node.val += node.left.val\\n        if node.right: node.val += node.right.val \\n\\n        return node\\n\\nclass CountIntervals:\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def add(self, left, right):\\n        self.root.add(self.root,1,10**9+1,left,right+1)\\n\\n    def count(self):\\n        return self.root.val or 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184729,
                "title": "java-solution-using-binary-search",
                "content": "n = maxNumber - minNumber\\n# Complexity\\n- Time complexity:\\ncount -> O(1), add -> worst case O(n), amortized O(logn) \\n\\n- Space complexity:\\nO(n), n = (max number - min number)\\n\\n# Code\\n```\\nclass CountIntervals {\\n\\n    public class Interval {\\n\\n        private int left;\\n        private int right;\\n\\n        public Interval(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int size() {\\n            return this.right - this.left + 1;\\n        }\\n\\n        public int compareTo(Interval other) {\\n            /* This and other intervals can be merged */ \\n            if (isInside(other) || isOutside(other) || isRightColliding(other) || \\n            isLeftColliding(other)) {\\n                return 0;\\n            /* If other is to the right of this, return negative number */\\n            } else if (this.left < other.left) {\\n                return this.right - other.left + 1;\\n            /* If other is to the left of this, return positive number */\\n            } else {\\n                return this.left - other.right - 1;\\n            }\\n        }\\n\\n        public boolean mergeInto(Interval other) {\\n            if (isInside(other)) return true;\\n            if (isOutside(other)) {\\n                this.left = other.left;\\n                this.right = other.right;\\n            } else if (isRightColliding(other)) {\\n                this.right = other.right;\\n            } else if (isLeftColliding(other)) {\\n                this.left = other.left;\\n            } else {\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        public String toString() {\\n            return \"[\" + this.left + \",\" + this.right + \"]\";\\n        }\\n\\n        private boolean isInside(Interval other) {\\n            return other.left >= this.left && other.right <= this.right;\\n        }\\n\\n        private boolean isOutside(Interval other) {\\n            return this.left >= other.left && this.right <= other.right; \\n        }\\n\\n        private boolean isRightColliding(Interval other) {\\n            return this.right >= other.left - 1 && this.right <= other.right;\\n        }\\n\\n        private boolean isLeftColliding(Interval other) {\\n            return other.right >= this.left - 1 && other.right <= this.right;\\n        }\\n\\n    }\\n\\n    public class BooleanInteger {\\n        public boolean booleanVal;\\n        public int intVal;\\n\\n        public BooleanInteger(boolean b, int i) {\\n            this.booleanVal = b;\\n            this.intVal = i;\\n        }\\n\\n        public String toString() {\\n            return \"(\" + booleanVal + \",\" + intVal + \")\";\\n        }\\n\\n    }\\n\\n    private List<Interval> intervals;\\n    private int count;\\n\\n    public CountIntervals() {\\n        this.intervals = new ArrayList<>();\\n        this.count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Interval interval = new Interval(left, right);\\n        BooleanInteger place = findInsertionPlace(interval);\\n        /* Merge intervals which can be merged into interval, and \\n        delete them. */\\n        if (place.booleanVal) {\\n            int end = place.intVal - 1;\\n            for (int i = place.intVal; i < this.intervals.size(); i++) {\\n                Interval curr = this.intervals.get(i);\\n                if (!interval.mergeInto(curr)) break;\\n                end++;\\n                this.count -= curr.size(); \\n            }\\n            this.intervals.subList(place.intVal, end + 1).clear();\\n        }\\n        this.intervals.add(place.intVal, interval);\\n        this.count += interval.size();\\n    }\\n    \\n    public int count() {\\n        return this.count;\\n    }\\n\\n    private BooleanInteger findInsertionPlace(Interval interval) {\\n        if (this.intervals.isEmpty()) return new BooleanInteger(false, 0);\\n        return bFindInsertionPlace(interval);\\n    }\\n\\n    private BooleanInteger bFindInsertionPlace(Interval interval) {\\n        int start = 0;\\n        int end = this.intervals.size() - 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            Interval midInterval = this.intervals.get(mid);\\n            /* If interval is to the right of midInterval */\\n            if (interval.compareTo(midInterval) > 0) {\\n                start = mid + 1;\\n            /* Otherwise search left */\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        BooleanInteger result = new BooleanInteger(false, start);\\n        if (start >= 0 && start < this.intervals.size()) {\\n            /* If the interval ar start index can be merged into this interval,\\n            return true to signal that there are some intervals that need to be\\n            deleted. */\\n            result.booleanVal = interval.compareTo(this.intervals.get(start)) == 0;\\n        }\\n        return result;\\n    } \\n\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass CountIntervals {\\n\\n    public class Interval {\\n\\n        private int left;\\n        private int right;\\n\\n        public Interval(int left, int right) {\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        public int size() {\\n            return this.right - this.left + 1;\\n        }\\n\\n        public int compareTo(Interval other) {\\n            /* This and other intervals can be merged */ \\n            if (isInside(other) || isOutside(other) || isRightColliding(other) || \\n            isLeftColliding(other)) {\\n                return 0;\\n            /* If other is to the right of this, return negative number */\\n            } else if (this.left < other.left) {\\n                return this.right - other.left + 1;\\n            /* If other is to the left of this, return positive number */\\n            } else {\\n                return this.left - other.right - 1;\\n            }\\n        }\\n\\n        public boolean mergeInto(Interval other) {\\n            if (isInside(other)) return true;\\n            if (isOutside(other)) {\\n                this.left = other.left;\\n                this.right = other.right;\\n            } else if (isRightColliding(other)) {\\n                this.right = other.right;\\n            } else if (isLeftColliding(other)) {\\n                this.left = other.left;\\n            } else {\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        public String toString() {\\n            return \"[\" + this.left + \",\" + this.right + \"]\";\\n        }\\n\\n        private boolean isInside(Interval other) {\\n            return other.left >= this.left && other.right <= this.right;\\n        }\\n\\n        private boolean isOutside(Interval other) {\\n            return this.left >= other.left && this.right <= other.right; \\n        }\\n\\n        private boolean isRightColliding(Interval other) {\\n            return this.right >= other.left - 1 && this.right <= other.right;\\n        }\\n\\n        private boolean isLeftColliding(Interval other) {\\n            return other.right >= this.left - 1 && other.right <= this.right;\\n        }\\n\\n    }\\n\\n    public class BooleanInteger {\\n        public boolean booleanVal;\\n        public int intVal;\\n\\n        public BooleanInteger(boolean b, int i) {\\n            this.booleanVal = b;\\n            this.intVal = i;\\n        }\\n\\n        public String toString() {\\n            return \"(\" + booleanVal + \",\" + intVal + \")\";\\n        }\\n\\n    }\\n\\n    private List<Interval> intervals;\\n    private int count;\\n\\n    public CountIntervals() {\\n        this.intervals = new ArrayList<>();\\n        this.count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Interval interval = new Interval(left, right);\\n        BooleanInteger place = findInsertionPlace(interval);\\n        /* Merge intervals which can be merged into interval, and \\n        delete them. */\\n        if (place.booleanVal) {\\n            int end = place.intVal - 1;\\n            for (int i = place.intVal; i < this.intervals.size(); i++) {\\n                Interval curr = this.intervals.get(i);\\n                if (!interval.mergeInto(curr)) break;\\n                end++;\\n                this.count -= curr.size(); \\n            }\\n            this.intervals.subList(place.intVal, end + 1).clear();\\n        }\\n        this.intervals.add(place.intVal, interval);\\n        this.count += interval.size();\\n    }\\n    \\n    public int count() {\\n        return this.count;\\n    }\\n\\n    private BooleanInteger findInsertionPlace(Interval interval) {\\n        if (this.intervals.isEmpty()) return new BooleanInteger(false, 0);\\n        return bFindInsertionPlace(interval);\\n    }\\n\\n    private BooleanInteger bFindInsertionPlace(Interval interval) {\\n        int start = 0;\\n        int end = this.intervals.size() - 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            Interval midInterval = this.intervals.get(mid);\\n            /* If interval is to the right of midInterval */\\n            if (interval.compareTo(midInterval) > 0) {\\n                start = mid + 1;\\n            /* Otherwise search left */\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        BooleanInteger result = new BooleanInteger(false, start);\\n        if (start >= 0 && start < this.intervals.size()) {\\n            /* If the interval ar start index can be merged into this interval,\\n            return true to signal that there are some intervals that need to be\\n            deleted. */\\n            result.booleanVal = interval.compareTo(this.intervals.get(start)) == 0;\\n        }\\n        return result;\\n    } \\n\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157968,
                "title": "list-of-non-overlapping-intervals-c",
                "content": "# Intuition\\nAs there are 10^9 integers that could be in intervals, it is infeasible to count which integers are in intervals. \\nIntuitively, a List of intervals should be kept. The intervals should be ordered and non-overlapping to allow for quickly checking whether a new interval overlaps with any existing intervals.\\nCounting of integers can be avoided by updating a counter variable whenever a new interval is added.\\n\\n# Approach\\n`intervals` is a List of tuples containing the left and right bound of any interval. `k` stores the current number of integers in intervals.\\n\\n## Adding a new Interval\\n\\nThe position `index` to insert a (new interval `toAdd`) can be determined by a Binary Search in `intervals`. Before inserting the interval, a few things should be considered:\\n- If there are intervals completely within `toAdd`, those shall be removed from `intervals`. Those intervals may be found in `intervals` directly after `index`.\\n- If there is an interval partially overlapping with `toAdd`, that inverval may be removed after adjusting `toAdd` to contain all integers contained in that interval. There can be only two such intervals (one before and one after `toAdd`), as intervals in `intervals` are non-overlapping.\\n- If `toAdd` is completely within another interval, it must not be added to intervals. That interval could be found at `index - 1`.\\n\\n`k` needs to be adjusted whenever an interval is removed from or added to `intervals`.\\n\\n## Count\\nSimply return `k`.\\n\\n# Complexity\\n- Time complexity:\\nIn a worst case, $$O(n ^2)$$ for adding new intervals. The Binary Search takes $$O(\\\\log (n))$$ time. The removal of intervals takes $$O(n^2)$$ time in a worst case, as there may be $$n$$ fully overlapping intervals to be removed, and removing from an $$n$$ long List may take $$O(n)$$ time. However, it should be noted that the average case will be far better, as the removal of many intervals improves performance on future calls to `Add` by shortening the List of intervals.\\nIn average, there will be less than one removal of fully overlapping intervals (as only one interval is added per call to `Add`, no more than one can be removed in average), resulting in $$O(n)$$ time for removals. \\nTherefore, in an average case: \\n    - $$O(n)$$ for`Add`\\n    - $$O(1)$$ for `Count`\\n\\n- Space complexity:\\n$$O(n)$$, as there may be $$n$$ intervals that need to be stored in a List.\\n\\n# Code\\n```\\npublic class CountIntervals {\\n    List<(int start, int end)> intervals = new List<(int, int)>();\\n    int k = 0;\\n    public CountIntervals() {\\n        \\n    }    \\n    public void Add(int left, int right) {\\n        (int start, int end) toAdd = (left, right); //the interval we wish to insert\\n\\n        //find index of first interval starting at or after the interval to add\\n        var index = intervals.BinarySearch((left, right));\\n        if (index < 0) index = ~index;\\n\\n        //find overlapping intervals starting after toAdd\\n        for(int i = index; i < intervals.Count && intervals[i].start <= right; i++)\\n        {\\n            if(intervals[i].end <= right)\\n            {\\n                //intervals[i] is completely within toAdd, therefore it can be removed\\n                k -= intervals[i].end - intervals[i].start + 1; //adjust k for removed interval\\n                intervals.RemoveAt(i--);\\n            }\\n            else if(intervals[i].start <= right)\\n            {\\n                //intervals[i] partially overlaps with toAdd, therefore it can be removed                \\n                k -= intervals[i].end - intervals[i].start + 1; //adjust k for removed interval\\n                toAdd = (left, intervals[i].end);       //adjust to incorporate all of the removed interval\\n                intervals.RemoveAt(i--);\\n            }\\n        }\\n\\n        //if this interval is not the first interval, a previous interval may overlap\\n        if(index > 0)\\n        {\\n            if(intervals[index - 1].end >= toAdd.end)\\n            {\\n                //the previous interval completely contains toAdd, therefore do nothing\\n            }\\n            else\\n            {\\n                if(intervals[index - 1].end >= toAdd.start)\\n                {\\n                    //the previous interval overlaps partially with toAdd\\n                    //change previous interval to incorporate all of toAdd\\n                    k += toAdd.end - intervals[index - 1].end;\\n                    intervals[index - 1] = (intervals[index - 1].start, toAdd.end);\\n                }\\n                else\\n                {\\n                    //the previous interval does not overlap with toAdd\\n                    intervals.Insert(index, toAdd);\\n                    k += toAdd.end - toAdd.start + 1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            //no previous interval to overlap with toAdd\\n            intervals.Insert(index, toAdd);\\n            k += toAdd.end - toAdd.start + 1;\\n        }\\n    }\\n    \\n    public int Count() {\\n        return k;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.Add(left,right);\\n * int param_2 = obj.Count();\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class CountIntervals {\\n    List<(int start, int end)> intervals = new List<(int, int)>();\\n    int k = 0;\\n    public CountIntervals() {\\n        \\n    }    \\n    public void Add(int left, int right) {\\n        (int start, int end) toAdd = (left, right); //the interval we wish to insert\\n\\n        //find index of first interval starting at or after the interval to add\\n        var index = intervals.BinarySearch((left, right));\\n        if (index < 0) index = ~index;\\n\\n        //find overlapping intervals starting after toAdd\\n        for(int i = index; i < intervals.Count && intervals[i].start <= right; i++)\\n        {\\n            if(intervals[i].end <= right)\\n            {\\n                //intervals[i] is completely within toAdd, therefore it can be removed\\n                k -= intervals[i].end - intervals[i].start + 1; //adjust k for removed interval\\n                intervals.RemoveAt(i--);\\n            }\\n            else if(intervals[i].start <= right)\\n            {\\n                //intervals[i] partially overlaps with toAdd, therefore it can be removed                \\n                k -= intervals[i].end - intervals[i].start + 1; //adjust k for removed interval\\n                toAdd = (left, intervals[i].end);       //adjust to incorporate all of the removed interval\\n                intervals.RemoveAt(i--);\\n            }\\n        }\\n\\n        //if this interval is not the first interval, a previous interval may overlap\\n        if(index > 0)\\n        {\\n            if(intervals[index - 1].end >= toAdd.end)\\n            {\\n                //the previous interval completely contains toAdd, therefore do nothing\\n            }\\n            else\\n            {\\n                if(intervals[index - 1].end >= toAdd.start)\\n                {\\n                    //the previous interval overlaps partially with toAdd\\n                    //change previous interval to incorporate all of toAdd\\n                    k += toAdd.end - intervals[index - 1].end;\\n                    intervals[index - 1] = (intervals[index - 1].start, toAdd.end);\\n                }\\n                else\\n                {\\n                    //the previous interval does not overlap with toAdd\\n                    intervals.Insert(index, toAdd);\\n                    k += toAdd.end - toAdd.start + 1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            //no previous interval to overlap with toAdd\\n            intervals.Insert(index, toAdd);\\n            k += toAdd.end - toAdd.start + 1;\\n        }\\n    }\\n    \\n    public int Count() {\\n        return k;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.Add(left,right);\\n * int param_2 = obj.Count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135982,
                "title": "java-treemap",
                "content": "```\\nclass CountIntervals {\\n\\n    TreeMap<Integer, Integer> treeMap;\\n        int count;\\n        public CountIntervals() {\\n            treeMap = new TreeMap<>();\\n            count = 0;\\n        }\\n        \\n        public void add(int left, int right) {\\n            int temp = 0;\\n            var it = treeMap.floorEntry(left);\\n            if(it == null || (it.getValue() < left))\\n                it = treeMap.ceilingEntry(left);\\n            while (it != null && it.getKey() <= right){\\n                left = Math.min(left, it.getKey());\\n                right = Math.max(right, it.getValue());\\n                temp += (it.getValue() - it.getKey()+1);\\n                treeMap.remove(it.getKey());\\n                it = treeMap.ceilingEntry(left);\\n            }\\n            treeMap.put(left, right);\\n            System.out.println(left + \"   \" + right);\\n            count += (right-left+1);\\n            count -= temp;\\n        }\\n\\n        public int count() {\\n            return count;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\n\\n    TreeMap<Integer, Integer> treeMap;\\n        int count;\\n        public CountIntervals() {\\n            treeMap = new TreeMap<>();\\n            count = 0;\\n        }\\n        \\n        public void add(int left, int right) {\\n            int temp = 0;\\n            var it = treeMap.floorEntry(left);\\n            if(it == null || (it.getValue() < left))\\n                it = treeMap.ceilingEntry(left);\\n            while (it != null && it.getKey() <= right){\\n                left = Math.min(left, it.getKey());\\n                right = Math.max(right, it.getValue());\\n                temp += (it.getValue() - it.getKey()+1);\\n                treeMap.remove(it.getKey());\\n                it = treeMap.ceilingEntry(left);\\n            }\\n            treeMap.put(left, right);\\n            System.out.println(left + \"   \" + right);\\n            count += (right-left+1);\\n            count -= temp;\\n        }\\n\\n        public int count() {\\n            return count;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126541,
                "title": "elixir-with-genserver-gb-trees",
                "content": "# Complexity\\n- add(): Amortized O(log(n)). Multiple existing key-value pairs may be deleted in an add() operation, but the number of deleted keys is never more than the number of previous add() calls.\\n- count(): O(1).\\n- Space complexity: O(n).\\n\\nWhere n is number of calls of add() and count().\\n# Code\\n```elixir\\ndefmodule CountIntervals do\\n  use GenServer\\n\\n  @spec init_() :: any\\n  def init_() do\\n    GenServer.start_link(__MODULE__, nil, [name: __MODULE__])\\n    GenServer.call(__MODULE__, :reset)\\n  end\\n\\n  @spec add(left :: integer, right :: integer) :: any\\n  def add(left, right) do\\n    GenServer.call(__MODULE__, {:add, left, right})\\n  end\\n\\n  @spec count() :: integer\\n  def count() do\\n    GenServer.call(__MODULE__, :count)\\n  end\\n\\n  @impl true\\n  def init(_) do\\n    {:ok, nil}\\n  end\\n\\n  @impl true\\n  def handle_call(:reset, _, _) do\\n    {:reply, true, {:gb_trees.empty, 0}}\\n  end\\n\\n  def handle_call({:add, left, right}, _, {tree, count}) do\\n    iter = :gb_trees.iterator_from(left - 1, tree)\\n    {tree, count} = update_tree({tree, count}, left, right, iter)\\n    {:reply, true, {tree, count}}\\n  end\\n\\n  def handle_call(:count, _, {tree, count}) do\\n    {:reply, count, {tree, count}}\\n  end\\n\\n  defp update_tree({tree, count}, left, right, iter) do\\n    case :gb_trees.next(iter) do\\n      {hi, lo, iter} when lo <= right + 1 ->\\n        tree = :gb_trees.delete(hi, tree)\\n        count = count - hi + lo - 1\\n        left = min(left, lo)\\n        right = max(right, hi)\\n        update_tree({tree, count}, left, right, iter)\\n      _ ->\\n        tree = :gb_trees.insert(right, left, tree)\\n        count = count + right - left + 1\\n        {tree, count}\\n    end\\n  end\\nend\\n\\n# Your functions will be called as such:\\n# CountIntervals.init_()\\n# CountIntervals.add(left, right)\\n# param_2 = CountIntervals.count()\\n\\n# CountIntervals.init_ will be called before every test case, in which you can do some necessary initializations.\\n```",
                "solutionTags": [
                    "Elixir",
                    "Ordered Map"
                ],
                "code": "```elixir\\ndefmodule CountIntervals do\\n  use GenServer\\n\\n  @spec init_() :: any\\n  def init_() do\\n    GenServer.start_link(__MODULE__, nil, [name: __MODULE__])\\n    GenServer.call(__MODULE__, :reset)\\n  end\\n\\n  @spec add(left :: integer, right :: integer) :: any\\n  def add(left, right) do\\n    GenServer.call(__MODULE__, {:add, left, right})\\n  end\\n\\n  @spec count() :: integer\\n  def count() do\\n    GenServer.call(__MODULE__, :count)\\n  end\\n\\n  @impl true\\n  def init(_) do\\n    {:ok, nil}\\n  end\\n\\n  @impl true\\n  def handle_call(:reset, _, _) do\\n    {:reply, true, {:gb_trees.empty, 0}}\\n  end\\n\\n  def handle_call({:add, left, right}, _, {tree, count}) do\\n    iter = :gb_trees.iterator_from(left - 1, tree)\\n    {tree, count} = update_tree({tree, count}, left, right, iter)\\n    {:reply, true, {tree, count}}\\n  end\\n\\n  def handle_call(:count, _, {tree, count}) do\\n    {:reply, count, {tree, count}}\\n  end\\n\\n  defp update_tree({tree, count}, left, right, iter) do\\n    case :gb_trees.next(iter) do\\n      {hi, lo, iter} when lo <= right + 1 ->\\n        tree = :gb_trees.delete(hi, tree)\\n        count = count - hi + lo - 1\\n        left = min(left, lo)\\n        right = max(right, hi)\\n        update_tree({tree, count}, left, right, iter)\\n      _ ->\\n        tree = :gb_trees.insert(right, left, tree)\\n        count = count + right - left + 1\\n        {tree, count}\\n    end\\n  end\\nend\\n\\n# Your functions will be called as such:\\n# CountIntervals.init_()\\n# CountIntervals.add(left, right)\\n# param_2 = CountIntervals.count()\\n\\n# CountIntervals.init_ will be called before every test case, in which you can do some necessary initializations.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3126199,
                "title": "union-find-an-d-red-black-tree",
                "content": "\\n        **Maintain two red black tree (for left and right values)\\n        if a range exist between two nodes from left tree and right tree, both set representation should point to same ref.\\n        \\n        1) if [left, right] does not intersect with any existing range, insert the values in the respective trees and update the range value.\\n        2) else find the range in which left & right exists and union all the nodes in between left & right.\\n         Update the range value accordingly.**\\n\\t\\t\\n\\t\\t\\n\\t\\t`\\n\\t\\tclass LinkedListRep {\\n    constructor(public front: LinkedList, public tail: LinkedList, public liArr : LinkedList[]) {}\\n    }\\n    class LinkedList {\\n    public setRep: LinkedListRep;\\n    constructor(\\n      public key = 0,\\n      public color = \"B\",\\n      public left: LinkedList | null = null,\\n      public right: LinkedList | null = null,\\n      public p: LinkedList | null = null\\n    ) {\\n      this.setRep = new LinkedListRep(this, this, [this]);\\n    }\\n  }\\n\\n  class BST {\\n    constructor(private root: LinkedList | null = null) {}\\n\\n    private rotateLeft = function (x: LinkedList) {\\n      let y = x.right!;\\n      y.p = x.p;\\n\\n      if (x.p === null) this.root = y;\\n      else if (x.p.left === x) x.p.left = y;\\n      else x.p.right = y;\\n\\n      x.right = y.left;\\n      if (x.right !== null) x.right.p = x;\\n\\n      y.left = x;\\n      x.p = y;\\n    };\\n    private rotateRight = function (y: LinkedList) {\\n      let x = y.left!;\\n      x.p = y.p;\\n\\n      if (y.p === null) this.root = x;\\n      else if (y.p.left === y) y.p.left = x;\\n      else y.p.right = x;\\n\\n      y.left = x.right;\\n      if (y.left !== null) y.left.p = y;\\n\\n      x.right = y;\\n      y.p = x;\\n    };\\n    private insertFixUp = function (x: LinkedList) {\\n      while (x.p !== null && x.p.color === \"R\") {\\n        if (x.p === x.p.p!.left) {\\n          let y = x.p.p!.right;\\n          if (y !== null && y.color === \"R\") {\\n            x.p.color = \"B\";\\n            y.color = \"B\";\\n            x.p.p!.color = \"R\";\\n            x = x.p.p!;\\n          } else {\\n            if (x === x.p.right) {\\n              x = x.p;\\n              this.rotateLeft(x);\\n            }\\n\\n            x.p!.color = \"B\";\\n            x.p!.p!.color = \"R\";\\n            this.rotateRight(x.p!.p!);\\n          }\\n        } else {\\n          let y = x.p.p!.left;\\n          if (y !== null && y.color === \"R\") {\\n            x.p.color = \"B\";\\n            y.color = \"B\";\\n            x.p.p!.color = \"R\";\\n            x = x.p.p!;\\n          } else {\\n            if (x === x.p.left) {\\n              x = x.p;\\n              this.rotateRight(x);\\n            }\\n\\n            x.p!.color = \"B\";\\n            x.p!.p!.color = \"R\";\\n            this.rotateLeft(x.p!.p!);\\n          }\\n        }\\n      }\\n      this.root.color = \"B\";\\n    };\\n\\n    insertNode = function (key: number) {\\n      let t = this.root;\\n      let y = t;\\n      let node = new LinkedList(key, \"R\");\\n      while (t !== null) {\\n        y = t;\\n        if (key < t.key) t = t.left;\\n        else t = t.right;\\n      }\\n\\n      if (y === null) this.root = y = node;\\n      else {\\n        t = node;\\n        if (key < y.key) y.left = t;\\n        else y.right = t;\\n        t.p = y;\\n      }\\n      this.insertFixUp(node);\\n    };\\n\\n    searchImmMinNode = function (key: number): LinkedList | null {\\n      let t = this.root;\\n      let immediateSmaller: LinkedList | null = null;\\n      while (t !== null) {\\n        if (key === t.key) return t;\\n        else if (key < t.key) t = t.left;\\n        else {\\n          immediateSmaller = t;\\n          t = t.right;\\n        }\\n      }\\n\\n      return immediateSmaller;\\n    };\\n\\n    searchImmMaxNode = function (key: number): LinkedList | null {\\n      let t = this.root;\\n      let immediateGreater: LinkedList | null = null;\\n      while (t !== null) {\\n        if (key === t.key) return t;\\n        else if (key < t.key) {\\n          immediateGreater = t;\\n          t = t.left;\\n        } else t = t.right;\\n      }\\n\\n      return immediateGreater;\\n    };\\n    }\\n\\n    class CountIntervals {\\n    private Lbst: BST;\\n    private Rbst: BST;\\n    private range: number;\\n    constructor() {\\n      this.Lbst = new BST();\\n      this.Rbst = new BST();\\n      this.range = 0;\\n    }\\n\\n    add(left: number, right: number): void {\\n      \\n\\n      const immMax = this.Rbst.searchImmMaxNode(left);\\n      const immMin = this.Lbst.searchImmMinNode(right);\\n      if(!immMax || !immMin || (left < immMax.setRep.front.key && right < immMax.setRep.front.key)) {\\n        this.Lbst.insertNode(left);\\n        this.Rbst.insertNode(right);\\n        const rightNode = this.Rbst.searchImmMinNode(right)!;\\n        const leftNode = this.Lbst.searchImmMaxNode(left)!;\\n        leftNode.setRep.tail = rightNode.setRep.tail;\\n        rightNode.setRep = leftNode.setRep;\\n        leftNode.setRep.liArr.push(rightNode);\\n        this.range += (right - left + 1);\\n        return;\\n      }\\n      \\n      if(left >= immMax.setRep.front.key && right <= immMax.setRep.tail.key) return;\\n      if (left < immMax.setRep.front.key) this.Lbst.insertNode(left);\\n      if (right > immMin.setRep.tail.key) {\\n        this.Rbst.insertNode(right);\\n        this.range++;\\n      }\\n\\n      const refNode = this.Lbst.searchImmMinNode(left)!;\\n      let node = this.Rbst.searchImmMaxNode(left);\\n      while (!!node && node.setRep.front.key <= right) {\\n        this.range -= node.setRep.tail.key - node.setRep.front.key + 1;\\n        if (node.setRep.liArr.length > refNode.setRep.liArr.length) {\\n          let l1 = refNode.setRep.liArr;\\n          node.setRep.front = refNode.setRep.front;\\n          for (let i = 0; i < l1.length; i++) {\\n            l1[i].setRep = node.setRep;\\n            node.setRep.liArr.push(l1[i]);\\n          }\\n        } else if(node.setRep !== refNode.setRep) {\\n          let l1 = node.setRep.liArr;\\n          refNode.setRep.tail = node.setRep.tail;\\n          for (let i = 0; i < l1.length; i++) {\\n            l1[i].setRep = refNode.setRep;\\n            refNode.setRep.liArr.push(l1[i]);\\n          }\\n        }\\n        node = this.Rbst.searchImmMaxNode(node.setRep.tail.key + 1);\\n      }\\n      this.range += (refNode.setRep.tail.key - refNode.setRep.front.key + 1);\\n\\n    }\\n\\n    count(): number {\\n      return this.range;\\n    }\\n    }\\n\\t\\t`",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "\\n        **Maintain two red black tree (for left and right values)\\n        if a range exist between two nodes from left tree and right tree, both set representation should point to same ref.\\n        \\n        1) if [left, right] does not intersect with any existing range, insert the values in the respective trees and update the range value.\\n        2) else find the range in which left & right exists and union all the nodes in between left & right.\\n         Update the range value accordingly.**\\n\\t\\t\\n\\t\\t\\n\\t\\t`\\n\\t\\tclass LinkedListRep {\\n    constructor(public front: LinkedList, public tail: LinkedList, public liArr : LinkedList[]) {}\\n    }\\n    class LinkedList {\\n    public setRep: LinkedListRep;\\n    constructor(\\n      public key = 0,\\n      public color = \"B\",\\n      public left: LinkedList | null = null,\\n      public right: LinkedList | null = null,\\n      public p: LinkedList | null = null\\n    ) {\\n      this.setRep = new LinkedListRep(this, this, [this]);\\n    }\\n  }\\n\\n  class BST {\\n    constructor(private root: LinkedList | null = null) {}\\n\\n    private rotateLeft = function (x: LinkedList) {\\n      let y = x.right!;\\n      y.p = x.p;\\n\\n      if (x.p === null) this.root = y;\\n      else if (x.p.left === x) x.p.left = y;\\n      else x.p.right = y;\\n\\n      x.right = y.left;\\n      if (x.right !== null) x.right.p = x;\\n\\n      y.left = x;\\n      x.p = y;\\n    };\\n    private rotateRight = function (y: LinkedList) {\\n      let x = y.left!;\\n      x.p = y.p;\\n\\n      if (y.p === null) this.root = x;\\n      else if (y.p.left === y) y.p.left = x;\\n      else y.p.right = x;\\n\\n      y.left = x.right;\\n      if (y.left !== null) y.left.p = y;\\n\\n      x.right = y;\\n      y.p = x;\\n    };\\n    private insertFixUp = function (x: LinkedList) {\\n      while (x.p !== null && x.p.color === \"R\") {\\n        if (x.p === x.p.p!.left) {\\n          let y = x.p.p!.right;\\n          if (y !== null && y.color === \"R\") {\\n            x.p.color = \"B\";\\n            y.color = \"B\";\\n            x.p.p!.color = \"R\";\\n            x = x.p.p!;\\n          } else {\\n            if (x === x.p.right) {\\n              x = x.p;\\n              this.rotateLeft(x);\\n            }\\n\\n            x.p!.color = \"B\";\\n            x.p!.p!.color = \"R\";\\n            this.rotateRight(x.p!.p!);\\n          }\\n        } else {\\n          let y = x.p.p!.left;\\n          if (y !== null && y.color === \"R\") {\\n            x.p.color = \"B\";\\n            y.color = \"B\";\\n            x.p.p!.color = \"R\";\\n            x = x.p.p!;\\n          } else {\\n            if (x === x.p.left) {\\n              x = x.p;\\n              this.rotateRight(x);\\n            }\\n\\n            x.p!.color = \"B\";\\n            x.p!.p!.color = \"R\";\\n            this.rotateLeft(x.p!.p!);\\n          }\\n        }\\n      }\\n      this.root.color = \"B\";\\n    };\\n\\n    insertNode = function (key: number) {\\n      let t = this.root;\\n      let y = t;\\n      let node = new LinkedList(key, \"R\");\\n      while (t !== null) {\\n        y = t;\\n        if (key < t.key) t = t.left;\\n        else t = t.right;\\n      }\\n\\n      if (y === null) this.root = y = node;\\n      else {\\n        t = node;\\n        if (key < y.key) y.left = t;\\n        else y.right = t;\\n        t.p = y;\\n      }\\n      this.insertFixUp(node);\\n    };\\n\\n    searchImmMinNode = function (key: number): LinkedList | null {\\n      let t = this.root;\\n      let immediateSmaller: LinkedList | null = null;\\n      while (t !== null) {\\n        if (key === t.key) return t;\\n        else if (key < t.key) t = t.left;\\n        else {\\n          immediateSmaller = t;\\n          t = t.right;\\n        }\\n      }\\n\\n      return immediateSmaller;\\n    };\\n\\n    searchImmMaxNode = function (key: number): LinkedList | null {\\n      let t = this.root;\\n      let immediateGreater: LinkedList | null = null;\\n      while (t !== null) {\\n        if (key === t.key) return t;\\n        else if (key < t.key) {\\n          immediateGreater = t;\\n          t = t.left;\\n        } else t = t.right;\\n      }\\n\\n      return immediateGreater;\\n    };\\n    }\\n\\n    class CountIntervals {\\n    private Lbst: BST;\\n    private Rbst: BST;\\n    private range: number;\\n    constructor() {\\n      this.Lbst = new BST();\\n      this.Rbst = new BST();\\n      this.range = 0;\\n    }\\n\\n    add(left: number, right: number): void {\\n      \\n\\n      const immMax = this.Rbst.searchImmMaxNode(left);\\n      const immMin = this.Lbst.searchImmMinNode(right);\\n      if(!immMax || !immMin || (left < immMax.setRep.front.key && right < immMax.setRep.front.key)) {\\n        this.Lbst.insertNode(left);\\n        this.Rbst.insertNode(right);\\n        const rightNode = this.Rbst.searchImmMinNode(right)!;\\n        const leftNode = this.Lbst.searchImmMaxNode(left)!;\\n        leftNode.setRep.tail = rightNode.setRep.tail;\\n        rightNode.setRep = leftNode.setRep;\\n        leftNode.setRep.liArr.push(rightNode);\\n        this.range += (right - left + 1);\\n        return;\\n      }\\n      \\n      if(left >= immMax.setRep.front.key && right <= immMax.setRep.tail.key) return;\\n      if (left < immMax.setRep.front.key) this.Lbst.insertNode(left);\\n      if (right > immMin.setRep.tail.key) {\\n        this.Rbst.insertNode(right);\\n        this.range++;\\n      }\\n\\n      const refNode = this.Lbst.searchImmMinNode(left)!;\\n      let node = this.Rbst.searchImmMaxNode(left);\\n      while (!!node && node.setRep.front.key <= right) {\\n        this.range -= node.setRep.tail.key - node.setRep.front.key + 1;\\n        if (node.setRep.liArr.length > refNode.setRep.liArr.length) {\\n          let l1 = refNode.setRep.liArr;\\n          node.setRep.front = refNode.setRep.front;\\n          for (let i = 0; i < l1.length; i++) {\\n            l1[i].setRep = node.setRep;\\n            node.setRep.liArr.push(l1[i]);\\n          }\\n        } else if(node.setRep !== refNode.setRep) {\\n          let l1 = node.setRep.liArr;\\n          refNode.setRep.tail = node.setRep.tail;\\n          for (let i = 0; i < l1.length; i++) {\\n            l1[i].setRep = refNode.setRep;\\n            refNode.setRep.liArr.push(l1[i]);\\n          }\\n        }\\n        node = this.Rbst.searchImmMaxNode(node.setRep.tail.key + 1);\\n      }\\n      this.range += (refNode.setRep.tail.key - refNode.setRep.front.key + 1);\\n\\n    }\\n\\n    count(): number {\\n      return this.range;\\n    }\\n    }\\n\\t\\t`",
                "codeTag": "Java"
            },
            {
                "id": 3100903,
                "title": "segment-tree",
                "content": "public class CountIntervals {\\n    \\n    public class Node\\n    {\\n        int min,max;\\n        Node _left,_right;\\n        bool isFull = false;\\n        public int v=0;\\n        public Node(int min,int max)\\n        {\\n            this.min=min;\\n            this.max=max;\\n        }\\n        \\n        public void Add(int left, int right)\\n        {\\n\\n            if(left>max || right<min || isFull)\\n                return;\\n            if(max==min){\\n                v=1;\\n                return;\\n            }\\n            \\n            if(left<=min && max<=right){\\n                v=max-min+1;\\n                isFull=true;\\n                return;\\n            }\\n            GetLeft().Add(left,right);\\n            GetRight().Add(left,right);\\n\\n            v=GetLeft().v+GetRight().v;\\n\\n        }\\n        \\n        \\n        \\n        Node GetLeft()\\n        {\\n            if(_left==null)\\n                _left=new Node(min,(max+min)/2);\\n            return _left;\\n            \\n        }\\n        Node GetRight()\\n        {\\n            if(_right==null)\\n                _right=new Node((max+min)/2+1,max);\\n            return _right;\\n            \\n        }\\n        \\n    }\\n    \\n    Node root;\\n    public CountIntervals() {\\n        root=new Node(1,1_000_000_000);\\n        \\n\\n    }\\n    \\n    public void Add(int left, int right) {\\n            root.Add(left,right);\\n        \\n        \\n    }\\n    \\n    public int Count() {\\n        return root.v;\\n    }\\n    \\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.Add(left,right);\\n * int param_2 = obj.Count();\\n */",
                "solutionTags": [],
                "code": "public class CountIntervals {\\n    \\n    public class Node\\n    {\\n        int min,max;\\n        Node _left,_right;\\n        bool isFull = false;\\n        public int v=0;\\n        public Node(int min,int max)\\n        {\\n            this.min=min;\\n            this.max=max;\\n        }\\n        \\n        public void Add(int left, int right)\\n        {\\n\\n            if(left>max || right<min || isFull)\\n                return;\\n            if(max==min){\\n                v=1;\\n                return;\\n            }\\n            \\n            if(left<=min && max<=right){\\n                v=max-min+1;\\n                isFull=true;\\n                return;\\n            }\\n            GetLeft().Add(left,right);\\n            GetRight().Add(left,right);\\n\\n            v=GetLeft().v+GetRight().v;\\n\\n        }\\n        \\n        \\n        \\n        Node GetLeft()\\n        {\\n            if(_left==null)\\n                _left=new Node(min,(max+min)/2);\\n            return _left;\\n            \\n        }\\n        Node GetRight()\\n        {\\n            if(_right==null)\\n                _right=new Node((max+min)/2+1,max);\\n            return _right;\\n            \\n        }\\n        \\n    }\\n    \\n    Node root;\\n    public CountIntervals() {\\n        root=new Node(1,1_000_000_000);\\n        \\n\\n    }\\n    \\n    public void Add(int left, int right) {\\n            root.Add(left,right);\\n        \\n        \\n    }\\n    \\n    public int Count() {\\n        return root.v;\\n    }\\n    \\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.Add(left,right);\\n * int param_2 = obj.Count();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3038158,
                "title": "commented-python3-solution-beats-91-submissions",
                "content": "# Intuition\\nAt the end of the day, the count is just the length of each interval summed together, inclusive.\\n\\nWe would need to:\\n\\n1. Efficiently detect when an intersection exists\\n2. Keep a dynamic counter of the current count and update it each time we try to add an interval to our class. \\n\\n# Approach\\nFor efficiently detecting intersections, we can simply store the intervals using a BST (i.e. a TreeMap if you know Java). The key is the end of the interval, and the value is the start of the interval.\\n\\nTo detect an intersection with a new interval, we first check to see the smallest key that is higher than the  new interval\\'s start. \\n\\nIf there is not one, then there is no intersection, and we can simply add right - left + 1 to our dynamic counter.\\n\\nOtherwise, we check to see that the start of the interval corresponding to the that higher key is less than or equal to the end of the new interval\\'s end. \\n\\nIf this is the case, we have an intersection. We remove the higher interval, subtract off its length, and then try to recusively add the interval that would appear if we merged the new interval and this higher interval. This new interval would be (min of the starts, max of the ends). \\n\\nOtherwise, there is no intersection and we can add right - left + 1 to our dynamic counter.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\ncount is O(1)\\nWorst case for a single add is O(NLogN), where N is the number of intervals added so far.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N), where N is the number of intervals added so far.\\n\\n# Code\\n```\\nfrom typing import Optional\\n\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n    class TreeMap:\\n\\n        def __init__(self):\\n            self.keys = SortedList()\\n            self.map = {}\\n\\n        # get the smallest key greater than or equal to i\\n        def higher(self, i: int) -> Optional[int]:\\n            index  = self.keys.bisect_left(i)\\n\\n            if index < len(self.keys):\\n                return self.keys[index]\\n\\n            return None\\n\\n        def put(self, key: int, val: int) -> None:\\n            if key not in self.map:\\n                self.keys.add(key)\\n\\n            self.map[key] = val\\n\\n        def get(self, key: int) -> int:\\n            assert key in self.map\\n            return self.map[key]\\n\\n        def remove(self, key):\\n            assert key in self.map\\n            del self.map[key]\\n            self.keys.remove(key)\\n\\n\\n    def __init__(self):\\n        self.treemap = CountIntervals.TreeMap()\\n        self.amt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        # find intersection\\n\\n        currAmount = right - left + 1\\n        higherEnd = self.treemap.higher(left)\\n\\n        # base case, no possible intersection detected\\n        if higherEnd is None:\\n            self.treemap.put(right, left)\\n            self.amt += currAmount\\n\\n        # possible intersection\\n        else:\\n            higherStart = self.treemap.get(higherEnd)\\n\\n            # intersection detected\\n            if higherStart <= right:\\n                oldAmount = higherEnd - higherStart + 1\\n\\n                self.treemap.remove(higherEnd)\\n                self.amt -= oldAmount\\n\\n                # beast, just drop the old interval, subtract off its length, and recursively try to add the new combined interval in case it intersects with multiple future intervals\\n                self.add(min(left, higherStart), max(right, higherEnd))\\n\\n\\n            # base case 2, false positive in terms of an intersection\\n            else:\\n                self.treemap.put(right, left)\\n                self.amt += currAmount\\n\\n    def count(self) -> int:\\n        return self.amt\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import Optional\\n\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n    class TreeMap:\\n\\n        def __init__(self):\\n            self.keys = SortedList()\\n            self.map = {}\\n\\n        # get the smallest key greater than or equal to i\\n        def higher(self, i: int) -> Optional[int]:\\n            index  = self.keys.bisect_left(i)\\n\\n            if index < len(self.keys):\\n                return self.keys[index]\\n\\n            return None\\n\\n        def put(self, key: int, val: int) -> None:\\n            if key not in self.map:\\n                self.keys.add(key)\\n\\n            self.map[key] = val\\n\\n        def get(self, key: int) -> int:\\n            assert key in self.map\\n            return self.map[key]\\n\\n        def remove(self, key):\\n            assert key in self.map\\n            del self.map[key]\\n            self.keys.remove(key)\\n\\n\\n    def __init__(self):\\n        self.treemap = CountIntervals.TreeMap()\\n        self.amt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        # find intersection\\n\\n        currAmount = right - left + 1\\n        higherEnd = self.treemap.higher(left)\\n\\n        # base case, no possible intersection detected\\n        if higherEnd is None:\\n            self.treemap.put(right, left)\\n            self.amt += currAmount\\n\\n        # possible intersection\\n        else:\\n            higherStart = self.treemap.get(higherEnd)\\n\\n            # intersection detected\\n            if higherStart <= right:\\n                oldAmount = higherEnd - higherStart + 1\\n\\n                self.treemap.remove(higherEnd)\\n                self.amt -= oldAmount\\n\\n                # beast, just drop the old interval, subtract off its length, and recursively try to add the new combined interval in case it intersects with multiple future intervals\\n                self.add(min(left, higherStart), max(right, higherEnd))\\n\\n\\n            # base case 2, false positive in terms of an intersection\\n            else:\\n                self.treemap.put(right, left)\\n                self.amt += currAmount\\n\\n    def count(self) -> int:\\n        return self.amt\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010931,
                "title": "merge-intervals-in-treemap-start-end",
                "content": "# Intuition\\nWe can calculate count of integers (size of interval) during `add` operation. So, let\\'s keep all not overlapping intervals and merge it with new interval in the `add` operation.\\nFor proper `count`calculation duting `merger` interval we do the following:\\n`count -= size (existing interval)` and then `count += size(merged interval)`.\\n\\nThe most tricky part is to keep intevals in `TreeMap` for quick access by start interval and calculating overlaps because new interval may overlap from `0` to `n` interval from left, rigth and in the midle of `left` and `right` parameters of `add` method.\\n\\n# Approach\\nRemove all intevals from left for new inteval and merge.\\nRemove all interval from right for new interval and merge.\\n\\nPut merged inteval to the collection.\\n\\n# Complexity\\n- Time complexity: `avg O(logn)`, `O(nlogn)` in the worst case becase we have to remove all `n-1` intervals in case of adding inteval that overlap all existing.\\n- Space complexity: `O(n)` in the forst case\\n\\n# Code\\n```\\nclass CountIntervals {\\n    private int count;\\n    private final TreeMap<Integer, Integer> ranges = new TreeMap<>();\\n\\n    public CountIntervals() {}\\n    \\n    public void add(int left, int right) {\\n        if (isFullContains(left, right)) return;\\n\\n        var leftEntry = ranges.floorEntry(left);\\n        while (leftEntry != null && leftEntry.getValue() >= left) {\\n            removeByStart(leftEntry.getKey());\\n            \\n            left = Math.min(left, leftEntry.getKey());\\n            right = Math.max(right, leftEntry.getValue());\\n            \\n            leftEntry = ranges.floorEntry(left);\\n        }\\n        \\n        var rightEntry = ranges.ceilingEntry(left);\\n        while (rightEntry != null && rightEntry.getKey() <= right) {    \\n            removeByStart(rightEntry.getKey());\\n\\n            left = Math.min(left, rightEntry.getKey());\\n            right = Math.max(right, rightEntry.getValue());\\n\\n            rightEntry = ranges.ceilingEntry(left);\\n        }\\n\\n        ranges.put(left, right);\\n        count += size(left, right);\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n\\n    private boolean isFullContains(int left, int right) {\\n        var leftEntry = ranges.floorEntry(left);\\n        return leftEntry != null && right <= leftEntry.getValue();\\n    }\\n\\n    private void removeByStart(int start) {\\n        int end = ranges.remove(start);\\n        count -= size(start, end);\\n    }\\n\\n    private static int size(int a, int b) {\\n        return b - a + 1;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map"
                ],
                "code": "```\\nclass CountIntervals {\\n    private int count;\\n    private final TreeMap<Integer, Integer> ranges = new TreeMap<>();\\n\\n    public CountIntervals() {}\\n    \\n    public void add(int left, int right) {\\n        if (isFullContains(left, right)) return;\\n\\n        var leftEntry = ranges.floorEntry(left);\\n        while (leftEntry != null && leftEntry.getValue() >= left) {\\n            removeByStart(leftEntry.getKey());\\n            \\n            left = Math.min(left, leftEntry.getKey());\\n            right = Math.max(right, leftEntry.getValue());\\n            \\n            leftEntry = ranges.floorEntry(left);\\n        }\\n        \\n        var rightEntry = ranges.ceilingEntry(left);\\n        while (rightEntry != null && rightEntry.getKey() <= right) {    \\n            removeByStart(rightEntry.getKey());\\n\\n            left = Math.min(left, rightEntry.getKey());\\n            right = Math.max(right, rightEntry.getValue());\\n\\n            rightEntry = ranges.ceilingEntry(left);\\n        }\\n\\n        ranges.put(left, right);\\n        count += size(left, right);\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n\\n    private boolean isFullContains(int left, int right) {\\n        var leftEntry = ranges.floorEntry(left);\\n        return leftEntry != null && right <= leftEntry.getValue();\\n    }\\n\\n    private void removeByStart(int start) {\\n        int end = ranges.remove(start);\\n        count -= size(start, end);\\n    }\\n\\n    private static int size(int a, int b) {\\n        return b - a + 1;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000613,
                "title": "c-set-with-interval-merge",
                "content": "# Intuition\\nNeed to keep merging new intervals as they come in and also keep updating the count of integers.\\n\\n# Approach\\nMaintain a set to keep the intervals sorted and when a new interval comes in, merge it with the existing intervals.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass CountIntervals {\\nprivate:\\n    std::set<vector<int>> intervalsSet;\\n    int cnt;\\npublic:\\n    CountIntervals() : cnt(0) {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        vector<int> newInterval = {left, right};\\n        auto nextItr = intervalsSet.upper_bound(newInterval);\\n        auto prevItr = (nextItr != begin(intervalsSet)) ? prev(nextItr) : end(intervalsSet);\\n        while (nextItr != end(intervalsSet)) {\\n            vector<int> nextInterval = *(nextItr);\\n            if ((newInterval[0]<=nextInterval[1]) && (newInterval[1]>=nextInterval[0])) {\\n                newInterval[0] = min(nextInterval[0], newInterval[0]);\\n                newInterval[1] = max(nextInterval[1], newInterval[1]);\\n                cnt -= (nextInterval[1]-nextInterval[0]+1);\\n                nextItr = intervalsSet.erase(nextItr);\\n            } else {\\n                break;\\n            }\\n\\n        }\\n        if (prevItr != end(intervalsSet)) {\\n            vector<int> prevInterval = *(prevItr);\\n            if ((newInterval[0]<=prevInterval[1]) && (newInterval[1]>=prevInterval[0])) {\\n                newInterval[0] = min(prevInterval[0], newInterval[0]);\\n                newInterval[1] = max(prevInterval[1], newInterval[1]);\\n                cnt -= (prevInterval[1]-prevInterval[0]+1);\\n                intervalsSet.erase(prevItr);\\n            }\\n        }\\n        cnt += (newInterval[1]-newInterval[0]+1);\\n        intervalsSet.insert(newInterval);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CountIntervals {\\nprivate:\\n    std::set<vector<int>> intervalsSet;\\n    int cnt;\\npublic:\\n    CountIntervals() : cnt(0) {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        vector<int> newInterval = {left, right};\\n        auto nextItr = intervalsSet.upper_bound(newInterval);\\n        auto prevItr = (nextItr != begin(intervalsSet)) ? prev(nextItr) : end(intervalsSet);\\n        while (nextItr != end(intervalsSet)) {\\n            vector<int> nextInterval = *(nextItr);\\n            if ((newInterval[0]<=nextInterval[1]) && (newInterval[1]>=nextInterval[0])) {\\n                newInterval[0] = min(nextInterval[0], newInterval[0]);\\n                newInterval[1] = max(nextInterval[1], newInterval[1]);\\n                cnt -= (nextInterval[1]-nextInterval[0]+1);\\n                nextItr = intervalsSet.erase(nextItr);\\n            } else {\\n                break;\\n            }\\n\\n        }\\n        if (prevItr != end(intervalsSet)) {\\n            vector<int> prevInterval = *(prevItr);\\n            if ((newInterval[0]<=prevInterval[1]) && (newInterval[1]>=prevInterval[0])) {\\n                newInterval[0] = min(prevInterval[0], newInterval[0]);\\n                newInterval[1] = max(prevInterval[1], newInterval[1]);\\n                cnt -= (prevInterval[1]-prevInterval[0]+1);\\n                intervalsSet.erase(prevItr);\\n            }\\n        }\\n        cnt += (newInterval[1]-newInterval[0]+1);\\n        intervalsSet.insert(newInterval);\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000386,
                "title": "java-segment-tree-solution",
                "content": "# Code\\n[Submission Link](https://leetcode.com/problems/count-integers-in-intervals/submissions/871562416/)\\n```\\nclass CountIntervals {\\n\\n    private CountIntervals left, right;\\n    private int lb, ub, count;\\n\\n    public CountIntervals() {\\n        this(1, 1_000_000_000);\\n    }\\n    public CountIntervals(int lb, int ub) {\\n        this.lb = lb;\\n        this.ub = ub;\\n    }\\n    \\n    public void add(int l, int r) {\\n        // interval has already been fully covered before\\n        // no need to cover again\\n        if (count == ub - lb + 1) {\\n            return;\\n        }\\n        // interval has already been covered by [l, r]\\n        // no need to discover further\\n        if (l <= lb && ub <= r) {\\n            count = ub - lb + 1;\\n            return;\\n        }\\n\\n        int mid = lb + (ub - lb) / 2;\\n        /* push down */\\n        if (left == null) left = new CountIntervals(lb, mid);\\n        if (right == null) right = new CountIntervals(mid + 1, ub);\\n\\n        if (l <= mid) left.add(l, r);\\n        if (r > mid) right.add(l, r);\\n\\n        /* push up */\\n        count = left.count + right.count;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CountIntervals {\\n\\n    private CountIntervals left, right;\\n    private int lb, ub, count;\\n\\n    public CountIntervals() {\\n        this(1, 1_000_000_000);\\n    }\\n    public CountIntervals(int lb, int ub) {\\n        this.lb = lb;\\n        this.ub = ub;\\n    }\\n    \\n    public void add(int l, int r) {\\n        // interval has already been fully covered before\\n        // no need to cover again\\n        if (count == ub - lb + 1) {\\n            return;\\n        }\\n        // interval has already been covered by [l, r]\\n        // no need to discover further\\n        if (l <= lb && ub <= r) {\\n            count = ub - lb + 1;\\n            return;\\n        }\\n\\n        int mid = lb + (ub - lb) / 2;\\n        /* push down */\\n        if (left == null) left = new CountIntervals(lb, mid);\\n        if (right == null) right = new CountIntervals(mid + 1, ub);\\n\\n        if (l <= mid) left.add(l, r);\\n        if (r > mid) right.add(l, r);\\n\\n        /* push up */\\n        count = left.count + right.count;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997901,
                "title": "c-ordered-map-great-question-inspiration-from-range-module-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass CountIntervals {\\npublic:\\n    typedef long long int64;\\n    map<int, int> mp;\\n    int prevAddedCount;\\n    int currAddedCount;\\n    int prevCountAns;\\n\\n    CountIntervals() {\\n        prevAddedCount = 0;\\n        currAddedCount = 0;\\n        prevCountAns = -1;\\n    }\\n    \\n    void deleteRange(int left, int right) {\\n        if(mp.empty()) {\\n            return;\\n        }\\n        auto it = mp.lower_bound(left); // left <= it->first\\n        if(it != mp.begin()) {\\n            it--; // it->first < left\\n        }\\n        vector<int> v;\\n        while(it != mp.end() && it->first <= right) {\\n            if(it->first < left && it->second >= left) {\\n                int temp = it->second;\\n                it->second = left - 1;\\n                if(temp > right) {\\n                    mp[right + 1] = temp;\\n                }\\n            } else if(it->first >= left) {\\n                if(it->second > right) {\\n                    mp[right + 1] = it->second;\\n                }\\n                v.push_back(it->first);\\n            }\\n            it++;\\n        }\\n        for(int i : v) mp.erase(i);\\n    }\\n\\n    void add(int left, int right) {\\n        currAddedCount++;\\n        if(mp.count(left) != 0) {\\n            if(mp[left] == right) {\\n                return;\\n            }\\n        }\\n        deleteRange(left, right);\\n        mp[left] = right;\\n        auto it = mp.find(left);\\n        if(it != mp.begin() && prev(it)->second + 1 == left) {\\n            it--;\\n            it->second = right;\\n            mp.erase(left);\\n        }\\n        if(it != prev(mp.end()) && next(it)->first == right + 1) {\\n            it->second = next(it)->second;\\n            mp.erase(next(it));\\n        }\\n    }\\n    \\n    int count() {\\n        if(prevCountAns != -1 && prevAddedCount == currAddedCount) {\\n            return prevCountAns;\\n        }\\n        // cout << \"calling count\" << endl;\\n        int64 sum = 0;\\n        for(pair<int, int> p : mp) {\\n            int left = p.first;\\n            int right = p.second;\\n            // cout << left << \" , \" << right << endl;\\n            sum += (right - left + 1);\\n        }\\n        prevAddedCount = currAddedCount;\\n        return prevCountAns = sum;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    typedef long long int64;\\n    map<int, int> mp;\\n    int prevAddedCount;\\n    int currAddedCount;\\n    int prevCountAns;\\n\\n    CountIntervals() {\\n        prevAddedCount = 0;\\n        currAddedCount = 0;\\n        prevCountAns = -1;\\n    }\\n    \\n    void deleteRange(int left, int right) {\\n        if(mp.empty()) {\\n            return;\\n        }\\n        auto it = mp.lower_bound(left); // left <= it->first\\n        if(it != mp.begin()) {\\n            it--; // it->first < left\\n        }\\n        vector<int> v;\\n        while(it != mp.end() && it->first <= right) {\\n            if(it->first < left && it->second >= left) {\\n                int temp = it->second;\\n                it->second = left - 1;\\n                if(temp > right) {\\n                    mp[right + 1] = temp;\\n                }\\n            } else if(it->first >= left) {\\n                if(it->second > right) {\\n                    mp[right + 1] = it->second;\\n                }\\n                v.push_back(it->first);\\n            }\\n            it++;\\n        }\\n        for(int i : v) mp.erase(i);\\n    }\\n\\n    void add(int left, int right) {\\n        currAddedCount++;\\n        if(mp.count(left) != 0) {\\n            if(mp[left] == right) {\\n                return;\\n            }\\n        }\\n        deleteRange(left, right);\\n        mp[left] = right;\\n        auto it = mp.find(left);\\n        if(it != mp.begin() && prev(it)->second + 1 == left) {\\n            it--;\\n            it->second = right;\\n            mp.erase(left);\\n        }\\n        if(it != prev(mp.end()) && next(it)->first == right + 1) {\\n            it->second = next(it)->second;\\n            mp.erase(next(it));\\n        }\\n    }\\n    \\n    int count() {\\n        if(prevCountAns != -1 && prevAddedCount == currAddedCount) {\\n            return prevCountAns;\\n        }\\n        // cout << \"calling count\" << endl;\\n        int64 sum = 0;\\n        for(pair<int, int> p : mp) {\\n            int left = p.first;\\n            int right = p.second;\\n            // cout << left << \" , \" << right << endl;\\n            sum += (right - left + 1);\\n        }\\n        prevAddedCount = currAddedCount;\\n        return prevCountAns = sum;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2812293,
                "title": "average-amortized-time-complexity-of-the-method-using-binary-search",
                "content": "I\\'m tyring to understand the time complexity using the binary search method (bisect in python), and I\\'ve seen posts stating the average time complexity of n operations is O(log(n)) (instead of O(nlog(n))). Can someone please explain how it\\'s derived?",
                "solutionTags": [],
                "code": "I\\'m tyring to understand the time complexity using the binary search method (bisect in python), and I\\'ve seen posts stating the average time complexity of n operations is O(log(n)) (instead of O(nlog(n))). Can someone please explain how it\\'s derived?",
                "codeTag": "Unknown"
            },
            {
                "id": 2805920,
                "title": "c-using-set",
                "content": "\\tclass CountIntervals {\\n\\t\\tprivate:\\n\\t\\tstruct comp {\\n\\t\\t\\tbool operator()(const vector<int> &A, const vector<int> &B) const {return A[0] < B[0];}\\n\\t\\t};\\n\\t\\tset<vector<int>, comp> Set;\\n\\t\\tint ans;\\n\\t\\tpublic:\\n\\t\\tCountIntervals() {\\n\\t\\t\\tans = 0;\\n\\t\\t}\\n\\n\\t\\tvoid add(int left, int right) {\\n\\t\\t\\tauto iter = Set.lower_bound({left, right});\\n\\t\\t\\tif(iter != Set.begin() && (*prev(iter))[1] >= left) iter--;\\n\\t\\t\\twhile(iter != Set.end() && right >= (*iter)[0]) {\\n\\t\\t\\t\\tans -= (*iter)[1] - (*iter)[0] + 1;\\n\\t\\t\\t\\tleft = min(left, (*iter)[0]);\\n\\t\\t\\t\\tright = max(right, (*iter)[1]);\\n\\t\\t\\t\\titer = Set.erase(iter);\\n\\t\\t\\t}\\n\\t\\t\\tans += right - left + 1;\\n\\t\\t\\tSet.insert(iter, {left, right});\\n\\t\\t}\\n\\n\\t\\tint count() {\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your CountIntervals object will be instantiated and called as such:\\n\\t * CountIntervals* obj = new CountIntervals();\\n\\t * obj->add(left,right);\\n\\t * int param_2 = obj->count();\\n\\t */\\n",
                "solutionTags": [],
                "code": "\\tclass CountIntervals {\\n\\t\\tprivate:\\n\\t\\tstruct comp {\\n\\t\\t\\tbool operator()(const vector<int> &A, const vector<int> &B) const {return A[0] < B[0];}\\n\\t\\t};\\n\\t\\tset<vector<int>, comp> Set;\\n\\t\\tint ans;\\n\\t\\tpublic:\\n\\t\\tCountIntervals() {\\n\\t\\t\\tans = 0;\\n\\t\\t}\\n\\n\\t\\tvoid add(int left, int right) {\\n\\t\\t\\tauto iter = Set.lower_bound({left, right});\\n\\t\\t\\tif(iter != Set.begin() && (*prev(iter))[1] >= left) iter--;\\n\\t\\t\\twhile(iter != Set.end() && right >= (*iter)[0]) {\\n\\t\\t\\t\\tans -= (*iter)[1] - (*iter)[0] + 1;\\n\\t\\t\\t\\tleft = min(left, (*iter)[0]);\\n\\t\\t\\t\\tright = max(right, (*iter)[1]);\\n\\t\\t\\t\\titer = Set.erase(iter);\\n\\t\\t\\t}\\n\\t\\t\\tans += right - left + 1;\\n\\t\\t\\tSet.insert(iter, {left, right});\\n\\t\\t}\\n\\n\\t\\tint count() {\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your CountIntervals object will be instantiated and called as such:\\n\\t * CountIntervals* obj = new CountIntervals();\\n\\t * obj->add(left,right);\\n\\t * int param_2 = obj->count();\\n\\t */\\n",
                "codeTag": "Java"
            },
            {
                "id": 2804910,
                "title": "python3-using-sortedlist",
                "content": "from sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.sl = SortedList()\\n        self.total = 0\\n        self.inf = 10**10\\n\\n    def add(self, left: int, right: int) -> None:\\n        leftIdx = self.sl.bisect_right((left,self.inf)) - 1\\n        remove = []\\n        leftMost,rightMost = left,right\\n        \\n        if leftIdx>=0:\\n            L,R = self.sl[leftIdx]\\n            if L<=left<=right<=R:\\n                return\\n            \\n            if L<=left<=R<=right:\\n                leftMost = L\\n                remove.append((L,R))\\n                \\n        leftIdx+=1\\n        while leftIdx<len(self.sl):\\n            L,R = self.sl[leftIdx]\\n            \\n            if left<=L<=R<=right:\\n                remove.append((L,R))\\n                leftIdx+=1\\n            else:\\n                break\\n                \\n        if leftIdx<len(self.sl):\\n            L,R = self.sl[leftIdx]\\n            if left<=L<=right<=R:\\n                rightMost = R\\n                remove.append((L,R))\\n        \\n        for L,R in remove:\\n            self.total-= R-L+1\\n            self.sl.remove((L,R))\\n            \\n        self.sl.add((leftMost,rightMost))\\n        self.total+=rightMost-leftMost+1\\n        \\n    def count(self) -> int:\\n        return self.total",
                "solutionTags": [],
                "code": "from sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.sl = SortedList()\\n        self.total = 0\\n        self.inf = 10**10\\n\\n    def add(self, left: int, right: int) -> None:\\n        leftIdx = self.sl.bisect_right((left,self.inf)) - 1\\n        remove = []\\n        leftMost,rightMost = left,right\\n        \\n        if leftIdx>=0:\\n            L,R = self.sl[leftIdx]\\n            if L<=left<=right<=R:\\n                return\\n            \\n            if L<=left<=R<=right:\\n                leftMost = L\\n                remove.append((L,R))\\n                \\n        leftIdx+=1\\n        while leftIdx<len(self.sl):\\n            L,R = self.sl[leftIdx]\\n            \\n            if left<=L<=R<=right:\\n                remove.append((L,R))\\n                leftIdx+=1\\n            else:\\n                break\\n                \\n        if leftIdx<len(self.sl):\\n            L,R = self.sl[leftIdx]\\n            if left<=L<=right<=R:\\n                rightMost = R\\n                remove.append((L,R))\\n        \\n        for L,R in remove:\\n            self.total-= R-L+1\\n            self.sl.remove((L,R))\\n            \\n        self.sl.add((leftMost,rightMost))\\n        self.total+=rightMost-leftMost+1\\n        \\n    def count(self) -> int:\\n        return self.total",
                "codeTag": "Java"
            },
            {
                "id": 2757615,
                "title": "java-treemap",
                "content": "```\\n    TreeMap<Integer, Integer> map;\\n    int count;\\n    public CountIntervals() {\\n        map = new TreeMap<>();\\n        count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        while (map.size() > 0 && map.floorKey(right) != null && map.get(map.floorKey(right)) >= left) {\\n            int l = map.floorKey(right);\\n            int r = map.get(l);\\n            count -= (r - l + 1);\\n            left = Math.min(left, l);\\n            right = Math.max(right, r);\\n            map.remove(l);\\n        }\\n        count += (right - left + 1);\\n        map.put(left, right);\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    TreeMap<Integer, Integer> map;\\n    int count;\\n    public CountIntervals() {\\n        map = new TreeMap<>();\\n        count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        while (map.size() > 0 && map.floorKey(right) != null && map.get(map.floorKey(right)) >= left) {\\n            int l = map.floorKey(right);\\n            int r = map.get(l);\\n            count -= (r - l + 1);\\n            left = Math.min(left, l);\\n            right = Math.max(right, r);\\n            map.remove(l);\\n        }\\n        count += (right - left + 1);\\n        map.put(left, right);\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2747211,
                "title": "very-straightforward-merge-intervals-treemap",
                "content": "```\\nclass CountIntervals {\\n\\n    int count = 0;\\n    TreeMap<Integer, Integer> treemap;\\n    public CountIntervals() {\\n        treemap = new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n\\n        Integer fkey = treemap.floorKey(left);\\n        Integer ckey = treemap.higherKey(left);\\n        \\n        if (fkey == null && ckey == null) {\\n            treemap.put(left, right);\\n        } \\n        \\n        for (; fkey != null && treemap.get(fkey) >= left; fkey = treemap.floorKey(left)) {\\n\\n            left = Math.min(fkey, left);\\n            right = Math.max(treemap.get(fkey), right);\\n            \\n\\n            count -= (treemap.get(fkey) - fkey + 1);\\n            treemap.remove(fkey);\\n  \\n        } \\n\\n        for (; ckey != null && ckey <= right; ckey = treemap.higherKey(left)) {\\n\\n            left = Math.min(ckey, left);\\n            right = Math.max(treemap.get(ckey), right);\\n            \\n\\n            count -= (treemap.get(ckey) - ckey + 1);\\n            treemap.remove(ckey);\\n\\n        }\\n        \\n        treemap.put(left, right);\\n        count += (right - left + 1);\\n    }\\n    \\n    public int count() {\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CountIntervals {\\n\\n    int count = 0;\\n    TreeMap<Integer, Integer> treemap;\\n    public CountIntervals() {\\n        treemap = new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n\\n        Integer fkey = treemap.floorKey(left);\\n        Integer ckey = treemap.higherKey(left);\\n        \\n        if (fkey == null && ckey == null) {\\n            treemap.put(left, right);\\n        } \\n        \\n        for (; fkey != null && treemap.get(fkey) >= left; fkey = treemap.floorKey(left)) {\\n\\n            left = Math.min(fkey, left);\\n            right = Math.max(treemap.get(fkey), right);\\n            \\n\\n            count -= (treemap.get(fkey) - fkey + 1);\\n            treemap.remove(fkey);\\n  \\n        } \\n\\n        for (; ckey != null && ckey <= right; ckey = treemap.higherKey(left)) {\\n\\n            left = Math.min(ckey, left);\\n            right = Math.max(treemap.get(ckey), right);\\n            \\n\\n            count -= (treemap.get(ckey) - ckey + 1);\\n            treemap.remove(ckey);\\n\\n        }\\n        \\n        treemap.put(left, right);\\n        count += (right - left + 1);\\n    }\\n    \\n    public int count() {\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732677,
                "title": "tc-sc-100-normal-list-binary-search-python",
                "content": "![image.png](https://assets.leetcode.com/users/images/351895bf-44a1-4908-a4e7-5b7c96a8f252_1666450879.1208198.png)\\n\\n```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = [[-inf, -inf], [inf, inf]]\\n        self.nums = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        idx = bisect_right(self.intervals, [left, inf]) - 1\\n\\n        if self.intervals[idx][1] >= right:\\n            return\\n        \\n        toDelete = 0\\n        if self.intervals[idx][1] >= left:\\n            left = self.intervals[idx][0]\\n            start = idx\\n        else:\\n            idx += 1\\n            start = idx\\n\\n        while self.intervals[idx][0] <= right:\\n            toDelete += self.intervals[idx][1] - self.intervals[idx][0] + 1\\n            right = max(right, self.intervals[idx][1])\\n            idx += 1\\n        \\n        self.intervals[start:idx] = [[left, right]]\\n        self.nums += right - left + 1 - toDelete\\n        \\n\\n    def count(self) -> int:\\n        return self.nums\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = [[-inf, -inf], [inf, inf]]\\n        self.nums = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        idx = bisect_right(self.intervals, [left, inf]) - 1\\n\\n        if self.intervals[idx][1] >= right:\\n            return\\n        \\n        toDelete = 0\\n        if self.intervals[idx][1] >= left:\\n            left = self.intervals[idx][0]\\n            start = idx\\n        else:\\n            idx += 1\\n            start = idx\\n\\n        while self.intervals[idx][0] <= right:\\n            toDelete += self.intervals[idx][1] - self.intervals[idx][0] + 1\\n            right = max(right, self.intervals[idx][1])\\n            idx += 1\\n        \\n        self.intervals[start:idx] = [[left, right]]\\n        self.nums += right - left + 1 - toDelete\\n        \\n\\n    def count(self) -> int:\\n        return self.nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718261,
                "title": "java-python-100-00-faster-segment-tree",
                "content": "Runtime: 44 ms, faster than 100.00%\\nMemory Usage: 78.5 MB, less than 100.00%\\n\\n\\tclass BST\\n\\t{\\t\\n\\t\\tpublic int start, end;\\n\\t\\tpublic BST left = null;\\n\\t\\tpublic BST right = null;\\n\\n\\t\\tpublic BST(int start, int end) \\n\\t\\t{\\n\\t\\t\\tthis.start = start;\\n\\t\\t\\tthis.end = end;\\n\\t\\t}\\n\\t}\\n\\n\\tclass CountIntervals \\n\\t{\\n\\t\\tprotected BST bst = null;\\n\\t\\tprotected BST left_most = null;\\n\\t\\tprotected BST right_most = null;\\n\\t\\tprotected int counter = 0;\\n\\t\\tprotected boolean flag = true;\\n\\n\\t\\tpublic CountIntervals() {}\\n\\n\\t\\tprotected void update(BST node, int start, int end)\\n\\t\\t{        \\n\\t\\t\\twhile (true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (node.start >= end)\\n\\t\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode = node.left;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (node.start == end)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tnode.start = start;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode.left = new BST(start, end);\\n\\t\\t\\t\\t\\t\\tif (node == left_most) left_most = node.left;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (node.end <= start)\\n\\t\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tnode = node.right;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (node.end == start)\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode.end = end;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode.right = new BST(start, end);\\n\\t\\t\\t\\t\\t\\tif (node == right_most) right_most = node.right;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}  \\n\\n\\t\\t\\tif (start < node.start)\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tupdate(node.left, start, node.start);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcounter += node.start - start;\\n\\t\\t\\t\\t\\tnode.start = start;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (node.end < end)\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tupdate(node.right, node.end, end);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tcounter += end - node.end;\\n\\t\\t\\t\\t\\tnode.end = end;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\n\\t\\tpublic void add(int left, int right) \\n\\t\\t{\\n\\t\\t\\tright += 1;\\n\\n\\t\\t\\tif (flag)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\tbst = new BST(left, right);\\n\\t\\t\\t\\tleft_most = right_most = bst;\\n\\t\\t\\t\\tcounter = right - left;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tBST node;\\n\\t\\t\\tif (right <= left_most.start) \\n\\t\\t\\t\\tnode = left_most;\\n\\t\\t\\telse if (right_most.end <= left) \\n\\t\\t\\t\\tnode = right_most;\\n\\t\\t\\telse \\n\\t\\t\\t\\tnode = bst;\\n\\n\\t\\t\\tupdate(node, left, right);\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tpublic int count() \\n\\t\\t{\\n\\t\\t\\treturn counter;\\n\\t\\t}\\n\\t}\\n\\n\\nRuntime: 708 ms, faster than 100.00%\\nMemory Usage: 51.7 MB, less than 80.00%\\n\\n\\n\\tclass BST(object):\\n\\t\\tdef __init__(self, start, end):\\n\\t\\t\\tself.start = start\\n\\t\\t\\tself.end = end\\n\\t\\t\\tself.left = None\\n\\t\\t\\tself.right = None\\n\\n\\tclass CountIntervals(object):\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.bst = None\\n\\t\\t\\tself.left_most = None\\n\\t\\t\\tself.right_most = None\\n\\t\\t\\tself.counter = 0\\n\\t\\t\\tself.flag = True\\n\\n\\t\\tdef update(self, node, start, end):\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif node.start >= end:\\n\\t\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\t\\tnode = node.left\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif node.start == end:\\n\\t\\t\\t\\t\\t\\tnode.start = start\\n\\t\\t\\t\\t\\t\\tself.counter += end - start\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnode.left = BST(start, end)\\n\\t\\t\\t\\t\\t\\tif node is self.left_most: self.left_most = node.left\\n\\t\\t\\t\\t\\t\\tself.counter += end - start\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif node.end <= start:\\n\\t\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\t\\tnode = node.right\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif node.end == start:\\n\\t\\t\\t\\t\\t\\tnode.end = end\\n\\t\\t\\t\\t\\t\\tself.counter += end - start\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnode.right = BST(start, end)\\n\\t\\t\\t\\t\\t\\tif node is self.right_most: self.right_most = node.right\\n\\t\\t\\t\\t\\t\\tself.counter += end - start\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tbreak\\n\\n\\n\\t\\t\\tif start < node.start:\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tself.update(node.left, start, node.start)\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tself.counter += node.start - start\\n\\t\\t\\t\\t\\tnode.start = start\\n\\n\\t\\t\\tif node.end < end:\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tself.update(node.right, node.end, end)\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tself.counter += end - node.end\\n\\t\\t\\t\\t\\tnode.end = end\\n\\n\\n\\t\\tdef add(self, left, right):\\n\\t\\t\\tright += 1 # [left, right] => [left, right)\\n\\t\\t\\tif self.flag:\\n\\t\\t\\t\\tself.flag = False\\n\\t\\t\\t\\tself.bst = BST(left, right)\\n\\t\\t\\t\\tself.left_most = self.right_most = self.bst\\n\\t\\t\\t\\tself.counter = right - left\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif right <= self.left_most.start: node = self.left_most\\n\\t\\t\\telif self.right_most.end <= left: node = self.right_most\\n\\t\\t\\telse: node = self.bst\\n\\n\\t\\t\\tself.update(node, left, right)\\n\\n\\n\\t\\tdef count(self):\\n\\t\\t\\treturn self.counter\\n\\n\\nRuntime: 466 ms, faster than 99.46%\\nMemory Usage: 175.7 MB, less than 99.86%\\n\\n\\n\\tclass BST\\n\\t{\\t\\n\\tpublic:\\n\\t\\tint start, end;\\n\\t\\tBST* left = NULL;\\n\\t\\tBST* right = NULL;\\n\\n\\t\\tBST(int start, int end) \\n\\t\\t{\\n\\t\\t\\tthis->start = start;\\n\\t\\t\\tthis->end = end;\\n\\t\\t}\\n\\t};\\n\\n\\tclass CountIntervals \\n\\t{\\n\\tprotected:\\n\\t\\tBST* bst = NULL;\\n\\t\\tBST* left_most = NULL;\\n\\t\\tBST* right_most = NULL;\\n\\t\\tint counter = 0;\\n\\t\\tbool flag = true;\\n\\n\\tpublic:\\n\\t\\tCountIntervals() {}\\n\\n\\t\\tvoid update(BST* node, int start, int end)\\n\\t\\t{\\n\\t\\t\\twhile (true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (node->start >= end)\\n\\t\\t\\t\\t\\tif (node->left)\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode = node->left;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (node->start == end)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tnode->start = start;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode->left = new BST(start, end);\\n\\t\\t\\t\\t\\t\\tif (node == left_most) left_most = node->left;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (node->end <= start)\\n\\t\\t\\t\\t\\tif (node->right)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tnode = node->right;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (node->end == start)\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode->end = end;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode->right = new BST(start, end);\\n\\t\\t\\t\\t\\t\\tif (node == right_most) right_most = node->right;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}  \\n\\n\\t\\t\\tif (start < node->start)\\n\\t\\t\\t\\tif (node->left)\\n\\t\\t\\t\\t\\tupdate(node->left, start, node->start);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcounter += node->start - start;\\n\\t\\t\\t\\t\\tnode->start = start;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (node->end < end)\\n\\t\\t\\t\\tif (node->right)\\n\\t\\t\\t\\t\\tupdate(node->right, node->end, end);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tcounter += end - node->end;\\n\\t\\t\\t\\t\\tnode->end = end;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\n\\t\\tvoid add(int left, int right) \\n\\t\\t{\\n\\t\\t\\tright += 1;\\n\\n\\t\\t\\tif (flag)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\tbst = new BST(left, right);\\n\\t\\t\\t\\tleft_most = right_most = bst;\\n\\t\\t\\t\\tcounter = right - left;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tBST* node;\\n\\t\\t\\tif (right <= left_most->start) \\n\\t\\t\\t\\tnode = left_most;\\n\\t\\t\\telse if (right_most->end <= left) \\n\\t\\t\\t\\tnode = right_most;\\n\\t\\t\\telse \\n\\t\\t\\t\\tnode = bst;\\n\\n\\t\\t\\tupdate(node, left, right);\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint count() \\n\\t\\t{\\n\\t\\t\\treturn counter;\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Tree"
                ],
                "code": "Runtime: 44 ms, faster than 100.00%\\nMemory Usage: 78.5 MB, less than 100.00%\\n\\n\\tclass BST\\n\\t{\\t\\n\\t\\tpublic int start, end;\\n\\t\\tpublic BST left = null;\\n\\t\\tpublic BST right = null;\\n\\n\\t\\tpublic BST(int start, int end) \\n\\t\\t{\\n\\t\\t\\tthis.start = start;\\n\\t\\t\\tthis.end = end;\\n\\t\\t}\\n\\t}\\n\\n\\tclass CountIntervals \\n\\t{\\n\\t\\tprotected BST bst = null;\\n\\t\\tprotected BST left_most = null;\\n\\t\\tprotected BST right_most = null;\\n\\t\\tprotected int counter = 0;\\n\\t\\tprotected boolean flag = true;\\n\\n\\t\\tpublic CountIntervals() {}\\n\\n\\t\\tprotected void update(BST node, int start, int end)\\n\\t\\t{        \\n\\t\\t\\twhile (true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (node.start >= end)\\n\\t\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode = node.left;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (node.start == end)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tnode.start = start;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode.left = new BST(start, end);\\n\\t\\t\\t\\t\\t\\tif (node == left_most) left_most = node.left;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (node.end <= start)\\n\\t\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tnode = node.right;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (node.end == start)\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode.end = end;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode.right = new BST(start, end);\\n\\t\\t\\t\\t\\t\\tif (node == right_most) right_most = node.right;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}  \\n\\n\\t\\t\\tif (start < node.start)\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tupdate(node.left, start, node.start);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcounter += node.start - start;\\n\\t\\t\\t\\t\\tnode.start = start;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (node.end < end)\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tupdate(node.right, node.end, end);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tcounter += end - node.end;\\n\\t\\t\\t\\t\\tnode.end = end;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\n\\t\\tpublic void add(int left, int right) \\n\\t\\t{\\n\\t\\t\\tright += 1;\\n\\n\\t\\t\\tif (flag)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\tbst = new BST(left, right);\\n\\t\\t\\t\\tleft_most = right_most = bst;\\n\\t\\t\\t\\tcounter = right - left;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tBST node;\\n\\t\\t\\tif (right <= left_most.start) \\n\\t\\t\\t\\tnode = left_most;\\n\\t\\t\\telse if (right_most.end <= left) \\n\\t\\t\\t\\tnode = right_most;\\n\\t\\t\\telse \\n\\t\\t\\t\\tnode = bst;\\n\\n\\t\\t\\tupdate(node, left, right);\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tpublic int count() \\n\\t\\t{\\n\\t\\t\\treturn counter;\\n\\t\\t}\\n\\t}\\n\\n\\nRuntime: 708 ms, faster than 100.00%\\nMemory Usage: 51.7 MB, less than 80.00%\\n\\n\\n\\tclass BST(object):\\n\\t\\tdef __init__(self, start, end):\\n\\t\\t\\tself.start = start\\n\\t\\t\\tself.end = end\\n\\t\\t\\tself.left = None\\n\\t\\t\\tself.right = None\\n\\n\\tclass CountIntervals(object):\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.bst = None\\n\\t\\t\\tself.left_most = None\\n\\t\\t\\tself.right_most = None\\n\\t\\t\\tself.counter = 0\\n\\t\\t\\tself.flag = True\\n\\n\\t\\tdef update(self, node, start, end):\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif node.start >= end:\\n\\t\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\t\\tnode = node.left\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif node.start == end:\\n\\t\\t\\t\\t\\t\\tnode.start = start\\n\\t\\t\\t\\t\\t\\tself.counter += end - start\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnode.left = BST(start, end)\\n\\t\\t\\t\\t\\t\\tif node is self.left_most: self.left_most = node.left\\n\\t\\t\\t\\t\\t\\tself.counter += end - start\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif node.end <= start:\\n\\t\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\t\\tnode = node.right\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif node.end == start:\\n\\t\\t\\t\\t\\t\\tnode.end = end\\n\\t\\t\\t\\t\\t\\tself.counter += end - start\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnode.right = BST(start, end)\\n\\t\\t\\t\\t\\t\\tif node is self.right_most: self.right_most = node.right\\n\\t\\t\\t\\t\\t\\tself.counter += end - start\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tbreak\\n\\n\\n\\t\\t\\tif start < node.start:\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tself.update(node.left, start, node.start)\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tself.counter += node.start - start\\n\\t\\t\\t\\t\\tnode.start = start\\n\\n\\t\\t\\tif node.end < end:\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tself.update(node.right, node.end, end)\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tself.counter += end - node.end\\n\\t\\t\\t\\t\\tnode.end = end\\n\\n\\n\\t\\tdef add(self, left, right):\\n\\t\\t\\tright += 1 # [left, right] => [left, right)\\n\\t\\t\\tif self.flag:\\n\\t\\t\\t\\tself.flag = False\\n\\t\\t\\t\\tself.bst = BST(left, right)\\n\\t\\t\\t\\tself.left_most = self.right_most = self.bst\\n\\t\\t\\t\\tself.counter = right - left\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif right <= self.left_most.start: node = self.left_most\\n\\t\\t\\telif self.right_most.end <= left: node = self.right_most\\n\\t\\t\\telse: node = self.bst\\n\\n\\t\\t\\tself.update(node, left, right)\\n\\n\\n\\t\\tdef count(self):\\n\\t\\t\\treturn self.counter\\n\\n\\nRuntime: 466 ms, faster than 99.46%\\nMemory Usage: 175.7 MB, less than 99.86%\\n\\n\\n\\tclass BST\\n\\t{\\t\\n\\tpublic:\\n\\t\\tint start, end;\\n\\t\\tBST* left = NULL;\\n\\t\\tBST* right = NULL;\\n\\n\\t\\tBST(int start, int end) \\n\\t\\t{\\n\\t\\t\\tthis->start = start;\\n\\t\\t\\tthis->end = end;\\n\\t\\t}\\n\\t};\\n\\n\\tclass CountIntervals \\n\\t{\\n\\tprotected:\\n\\t\\tBST* bst = NULL;\\n\\t\\tBST* left_most = NULL;\\n\\t\\tBST* right_most = NULL;\\n\\t\\tint counter = 0;\\n\\t\\tbool flag = true;\\n\\n\\tpublic:\\n\\t\\tCountIntervals() {}\\n\\n\\t\\tvoid update(BST* node, int start, int end)\\n\\t\\t{\\n\\t\\t\\twhile (true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (node->start >= end)\\n\\t\\t\\t\\t\\tif (node->left)\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode = node->left;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (node->start == end)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tnode->start = start;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode->left = new BST(start, end);\\n\\t\\t\\t\\t\\t\\tif (node == left_most) left_most = node->left;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (node->end <= start)\\n\\t\\t\\t\\t\\tif (node->right)\\n\\t\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\t\\tnode = node->right;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (node->end == start)\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode->end = end;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\t\\tnode->right = new BST(start, end);\\n\\t\\t\\t\\t\\t\\tif (node == right_most) right_most = node->right;\\n\\t\\t\\t\\t\\t\\tcounter += end - start;\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}  \\n\\n\\t\\t\\tif (start < node->start)\\n\\t\\t\\t\\tif (node->left)\\n\\t\\t\\t\\t\\tupdate(node->left, start, node->start);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcounter += node->start - start;\\n\\t\\t\\t\\t\\tnode->start = start;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (node->end < end)\\n\\t\\t\\t\\tif (node->right)\\n\\t\\t\\t\\t\\tupdate(node->right, node->end, end);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{    \\n\\t\\t\\t\\t\\tcounter += end - node->end;\\n\\t\\t\\t\\t\\tnode->end = end;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\n\\t\\tvoid add(int left, int right) \\n\\t\\t{\\n\\t\\t\\tright += 1;\\n\\n\\t\\t\\tif (flag)\\n\\t\\t\\t{    \\n\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\tbst = new BST(left, right);\\n\\t\\t\\t\\tleft_most = right_most = bst;\\n\\t\\t\\t\\tcounter = right - left;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tBST* node;\\n\\t\\t\\tif (right <= left_most->start) \\n\\t\\t\\t\\tnode = left_most;\\n\\t\\t\\telse if (right_most->end <= left) \\n\\t\\t\\t\\tnode = right_most;\\n\\t\\t\\telse \\n\\t\\t\\t\\tnode = bst;\\n\\n\\t\\t\\tupdate(node, left, right);\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint count() \\n\\t\\t{\\n\\t\\t\\treturn counter;\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2716432,
                "title": "faster-than-70",
                "content": "#define ll long long\\n\\nclass Solution\\n{\\npublic:\\n    int totalStrength(vector<int>& stn)\\n    {\\n        ll mod=1000000007, ans=0;\\n        int n = stn.size() ;\\n        reverse( stn.begin(), stn.end() );\\n        stn.push_back(0);\\n        reverse( stn.begin(), stn.end() );\\n        vector<ll> pre(n+1), presum(n+1), suf( n+2 ), sufsum( n+2 ) ;\\n        for(int i=1;i<=n;i++) pre[i]=( pre[i-1]+stn[i] ) % mod ;\\n        for(int i=1;i<=n;i++) presum[i]=( presum[i-1]+pre[i] ) % mod ;\\n        for(int i=n;i>0;i--) suf[i]=suf[i+1]+stn[i];\\n        for(int i=n;i>0;i--) sufsum[i]=sufsum[i+1]+suf[i];\\n        vector<int> lftmn(n+1, 0), ritmn(n+1, n+1), aha;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            while( aha.size() && stn[aha.back()]>=stn[i] )\\n            {\\n                ritmn[ aha.back() ]=i;\\n                aha.pop_back();\\n            }\\n            aha.push_back( i );\\n        }\\n\\n        aha.clear();\\n\\n        for(int i=n;i>0;i--)\\n        {\\n            while( aha.size() && stn[ aha.back() ] > stn[i] )\\n            {\\n                lftmn[ aha.back() ]=i;\\n                aha.pop_back();\\n            }\\n            aha.push_back( i );\\n        }\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            // cout<<lftmn[i]<<S<<ritmn[i]<<D;\\n            // cout<<presum[i]<<S<<sufsum[i]<<D;\\n        }\\n\\n        ll yo=mod*1000000;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            ll rit = (presum[ ritmn[i]-1 ]-presum[i] + yo ) % mod;\\n            rit = (rit-(ritmn[i]-i-1)*pre[i] + yo )%mod ;\\n            rit = ( rit*( i-lftmn[i] ) )%mod;\\n            ll lft = ( sufsum[ lftmn[i]+1 ] - sufsum[i] + yo ) %mod;\\n            lft = ( lft - ( i-lftmn[i]-1 )*suf[i] + yo ) %mod;\\n            lft=( lft*( ritmn[i]-i ) )%mod;\\n            //cout<<lft<<S<<rit<<S;\\n            ll mid =( ( ritmn[i]-i ) * ( i-lftmn[i] ) ) % mod;\\n            mid=( mid * stn[i] )%mod;\\n            ans=( ans + (lft+rit+mid)*stn[i] )%mod;\\n            //cout<<ans<<D;\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Monotonic Stack",
                    "Counting"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int totalStrength(vector<int>& stn)\\n    {\\n        ll mod=1000000007, ans=0;\\n        int n = stn.size() ;\\n        reverse( stn.begin(), stn.end() );\\n        stn.push_back(0);\\n        reverse( stn.begin(), stn.end() );\\n        vector<ll> pre(n+1), presum(n+1), suf( n+2 ), sufsum( n+2 ) ;\\n        for(int i=1;i<=n;i++) pre[i]=( pre[i-1]+stn[i] ) % mod ;\\n        for(int i=1;i<=n;i++) presum[i]=( presum[i-1]+pre[i] ) % mod ;\\n        for(int i=n;i>0;i--) suf[i]=suf[i+1]+stn[i];\\n        for(int i=n;i>0;i--) sufsum[i]=sufsum[i+1]+suf[i];\\n        vector<int> lftmn(n+1, 0), ritmn(n+1, n+1), aha;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            while( aha.size() && stn[aha.back()]>=stn[i] )\\n            {\\n                ritmn[ aha.back() ]=i;\\n                aha.pop_back();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2709129,
                "title": "python-solution-using-sortedlist-commented",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals, self.countOfInts = SortedList(), 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        # Find the position of insertion\\n        posOfInsertion = bisect_right(self.intervals, left, key = lambda x: x[0])\\n        # If previous index could be merged, check that too.\\n        if posOfInsertion > 0 and self.intervals[posOfInsertion - 1][1] >= left:\\n            posOfInsertion -= 1\\n        # leftPos is the starting index for popping items from BST\\n        # leftVal and rightVal are the lower and upper bounds of the new interval\\n        leftVal, rightVal, leftPos = left, right, posOfInsertion\\n        while posOfInsertion < len(self.intervals) and self.intervals[posOfInsertion][0] <= right:\\n            self.countOfInts -= (self.intervals[posOfInsertion][1]- self.intervals[posOfInsertion][0] + 1)\\n            leftVal = min(self.intervals[posOfInsertion][0], leftVal)\\n            rightVal = max(self.intervals[posOfInsertion][1], rightVal)\\n            posOfInsertion += 1\\n        # Pop the items from BST since they will be merged.\\n        while leftPos < posOfInsertion:\\n            self.intervals.pop(index = leftPos)\\n            posOfInsertion -= 1\\n        # Add the new interval\\n        self.intervals.add([leftVal, rightVal])\\n        # update the count\\n        self.countOfInts += (rightVal - leftVal + 1)\\n\\n    def count(self) -> int:\\n        return self.countOfInts\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals, self.countOfInts = SortedList(), 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        # Find the position of insertion\\n        posOfInsertion = bisect_right(self.intervals, left, key = lambda x: x[0])\\n        # If previous index could be merged, check that too.\\n        if posOfInsertion > 0 and self.intervals[posOfInsertion - 1][1] >= left:\\n            posOfInsertion -= 1\\n        # leftPos is the starting index for popping items from BST\\n        # leftVal and rightVal are the lower and upper bounds of the new interval\\n        leftVal, rightVal, leftPos = left, right, posOfInsertion\\n        while posOfInsertion < len(self.intervals) and self.intervals[posOfInsertion][0] <= right:\\n            self.countOfInts -= (self.intervals[posOfInsertion][1]- self.intervals[posOfInsertion][0] + 1)\\n            leftVal = min(self.intervals[posOfInsertion][0], leftVal)\\n            rightVal = max(self.intervals[posOfInsertion][1], rightVal)\\n            posOfInsertion += 1\\n        # Pop the items from BST since they will be merged.\\n        while leftPos < posOfInsertion:\\n            self.intervals.pop(index = leftPos)\\n            posOfInsertion -= 1\\n        # Add the new interval\\n        self.intervals.add([leftVal, rightVal])\\n        # update the count\\n        self.countOfInts += (rightVal - leftVal + 1)\\n\\n    def count(self) -> int:\\n        return self.countOfInts\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676689,
                "title": "java-solution-3-approaches-discussed",
                "content": "**Approach:**\\n\\n1. Using merge intervals and sorted list. Here this will give TLE, since the TC is O(1e5 ^ 5)\\n2. Using Fenwick/Segmented Tree, but a huge memory would be required. MC: O(2 * 1e9 + 1).\\n3. Using TreeMap/BST. The following solution is based on this approach.\\n\\n\\n**Java Solution:**\\n\\n```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> map;\\n    int cnt;\\n\\n    public CountIntervals() {\\n        map = new TreeMap<Integer, Integer>();\\n        cnt=0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Map.Entry<Integer, Integer> m;\\n        while(!map.isEmpty() && (m = map.floorEntry(left)) != null && left <= m.getValue() && right >= m.getKey()) {\\n            cnt -= m.getValue() - m.getKey() + 1;\\n            left = Math.min(left, m.getKey());\\n            right = Math.max(right, m.getValue());\\n            map.remove(m.getKey());\\n        }\\n        while(!map.isEmpty() && (m = map.ceilingEntry(left)) != null && left <= m.getValue() && right >= m.getKey()) {\\n            cnt -= m.getValue() - m.getKey() + 1;\\n            left = Math.min(left, m.getKey());\\n            right = Math.max(right, m.getValue());\\n            map.remove(m.getKey());\\n        }\\n        map.put(left, right);\\n        cnt += right - left + 1;\\n    }\\n    \\n    public int count() {\\n        return cnt;\\n    }\\n}\\n```\\n\\n**Time Complexity**: O(n log n), where n=no.of add() calls\\n**Space Complexity**: O(n)\\n\\nUpvote if u have liked!",
                "solutionTags": [
                    "Java",
                    "Binary Indexed Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> map;\\n    int cnt;\\n\\n    public CountIntervals() {\\n        map = new TreeMap<Integer, Integer>();\\n        cnt=0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Map.Entry<Integer, Integer> m;\\n        while(!map.isEmpty() && (m = map.floorEntry(left)) != null && left <= m.getValue() && right >= m.getKey()) {\\n            cnt -= m.getValue() - m.getKey() + 1;\\n            left = Math.min(left, m.getKey());\\n            right = Math.max(right, m.getValue());\\n            map.remove(m.getKey());\\n        }\\n        while(!map.isEmpty() && (m = map.ceilingEntry(left)) != null && left <= m.getValue() && right >= m.getKey()) {\\n            cnt -= m.getValue() - m.getKey() + 1;\\n            left = Math.min(left, m.getKey());\\n            right = Math.max(right, m.getValue());\\n            map.remove(m.getKey());\\n        }\\n        map.put(left, right);\\n        cnt += right - left + 1;\\n    }\\n    \\n    public int count() {\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674842,
                "title": "kotlin-segmenttree-time-o-nlog-10-9-space-o-nlog-10-9",
                "content": "```\\nclass CountIntervals() {\\n\\n    private val tree = HashMap<Int, Int>()\\n    \\n    fun add(left: Int, right: Int) {\\n        update(1, 0, 1_000_000_000, left, right)\\n    }\\n    \\n    private fun update(treeIndex: Int, start: Int, end: Int, i: Int, j: Int) {\\n        if (start > j || end < i) {\\n            return\\n        }\\n        \\n        if (start >= i && end <= j) {\\n            tree[treeIndex] = end - start + 1\\n        } else {\\n            val middle = (start + end) / 2\\n            update(treeIndex * 2, start, middle, i, j)\\n            update(treeIndex * 2 + 1, middle + 1, end, i, j)\\n            tree[treeIndex] = Math.max(tree.getOrDefault(treeIndex, 0), tree.getOrDefault(treeIndex * 2, 0) + tree.getOrDefault(treeIndex * 2 + 1, 0))\\n        }\\n    }\\n    \\n    fun count(): Int {\\n        return tree.getOrDefault(1, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Tree"
                ],
                "code": "```\\nclass CountIntervals() {\\n\\n    private val tree = HashMap<Int, Int>()\\n    \\n    fun add(left: Int, right: Int) {\\n        update(1, 0, 1_000_000_000, left, right)\\n    }\\n    \\n    private fun update(treeIndex: Int, start: Int, end: Int, i: Int, j: Int) {\\n        if (start > j || end < i) {\\n            return\\n        }\\n        \\n        if (start >= i && end <= j) {\\n            tree[treeIndex] = end - start + 1\\n        } else {\\n            val middle = (start + end) / 2\\n            update(treeIndex * 2, start, middle, i, j)\\n            update(treeIndex * 2 + 1, middle + 1, end, i, j)\\n            tree[treeIndex] = Math.max(tree.getOrDefault(treeIndex, 0), tree.getOrDefault(treeIndex * 2, 0) + tree.getOrDefault(treeIndex * 2 + 1, 0))\\n        }\\n    }\\n    \\n    fun count(): Int {\\n        return tree.getOrDefault(1, 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666835,
                "title": "easy-understand-and-explanation",
                "content": "```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> st;\\n    int res = 0;\\n    public CountIntervals() \\n    {\\n       st = new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) \\n    {\\n        Integer l = st.floorKey(left);\\n        if(l != null)\\n        {\\n            if(st.get(l) >= left)\\n            {\\n                left = l;\\n                right = Math.max(st.get(l), right);\\n                res -= st.get(l) - l + 1;\\n                st.remove(l);\\n            }\\n        }\\n        Integer r = st.ceilingKey(left);\\n        while(r != null && right >= r)\\n        {\\n            res -= st.get(r) - r + 1;\\n            right = Math.max(right, st.get(r));\\n            st.remove(r);\\n            r = st.ceilingKey(left);\\n        }\\n        st.put(left,right);\\n        res += right - left + 1;\\n    }\\n    \\n    public int count() \\n    {\\n        return res;\\n    }\\n}\\n```\\nExplanaton:\\nThis problem can be departed as 3 parts:\\n1, deal with the number left. \\nIf the floor is null, we do nothing with left. So only consider the floor is not null. when floor != null but tree.get(floor) is smaller than left, there is no overlapping, we do not change left. (here , I put double if to make it clear).  Only floor is not null and tree.get(floor) > left, we need update left = floor, right = bigger one of ( tree.get(floor) and right). Remove this floor number in the tree and update result as substract the floor\\'s number ( because we removed it)\\n2, deal with the number right.\\nSame as step 1. Only the ceiling is not null and right is greater than ceiling, we run update. Because there may be multiple nodes in the tree are under this condition, So we use while loop( as multiple if condition). Reduce result by the number of node ceiling, update right to bigger of ( right and tree.get(ceiling), remove the node. update the ceiling to next one.\\n3, when we removed all the overlapping nodes in the tree( also substract all the numbers in these nodes) , then we add (left, right) to the tree and update result by the numbers between range of (left to right)\\n\\nAny question or comments, welcome to discuss!",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> st;\\n    int res = 0;\\n    public CountIntervals() \\n    {\\n       st = new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) \\n    {\\n        Integer l = st.floorKey(left);\\n        if(l != null)\\n        {\\n            if(st.get(l) >= left)\\n            {\\n                left = l;\\n                right = Math.max(st.get(l), right);\\n                res -= st.get(l) - l + 1;\\n                st.remove(l);\\n            }\\n        }\\n        Integer r = st.ceilingKey(left);\\n        while(r != null && right >= r)\\n        {\\n            res -= st.get(r) - r + 1;\\n            right = Math.max(right, st.get(r));\\n            st.remove(r);\\n            r = st.ceilingKey(left);\\n        }\\n        st.put(left,right);\\n        res += right - left + 1;\\n    }\\n    \\n    public int count() \\n    {\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652756,
                "title": "treemap-segment-tree-w-recursion-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI first used a segment tree to solve this problem. However, the test cases are not randomized and therefore the segment tree becomes unbalanced (i.e. every addition strictly decreases or increases). Therefore, an AVL type structure to automatically rotate the tree is required (or you can code your own rotation function if you want but that\\'s far too much work for me)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSave all intervals in a tree and keep a total sum count of all the interval lengths added. Ensure the tree adds intervals in proper order and decrease interval sizes as needed in case of overlaps. Try out My Calendar #1 (729) for an easier problem related to this.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(n)) addition, O(1) get\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) space\\n\\n# Code\\n```\\nclass CountIntervals {\\n    TreeMap<Integer,Integer> tm = new TreeMap<>();\\n    int c = 0;\\n\\n    public CountIntervals() {}\\n\\n    public void add(int start,int end){\\n        // nothing if not valid\\n        if(end < start)\\n            return;\\n        \\n        // check if out of the range of everything we have\\n        // condition 1: all intervals are greater than the new one\\n        // condition 2: if the next smallest interval ends before this one\\n        if(tm.floorKey(end) == null || tm.get(tm.floorKey(end)) < start){\\n            c += end-start+1;\\n            tm.put(start,end);\\n            return;\\n        }\\n\\n\\n        // If we\\'re here, there\\'s overlap\\n        int nS = tm.floorKey(end);\\n        int nE = tm.get(tm.floorKey(end));\\n\\n        // if we cant add anything in because this interval encapsulates it\\n        if(start >= nS && end <= nE)\\n            return;\\n        \\n        add(start,nS-1);\\n        add(nE+1,end);\\n    }\\n    \\n    public int count() {\\n        return c;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Segment Tree",
                    "Recursion"
                ],
                "code": "```\\nclass CountIntervals {\\n    TreeMap<Integer,Integer> tm = new TreeMap<>();\\n    int c = 0;\\n\\n    public CountIntervals() {}\\n\\n    public void add(int start,int end){\\n        // nothing if not valid\\n        if(end < start)\\n            return;\\n        \\n        // check if out of the range of everything we have\\n        // condition 1: all intervals are greater than the new one\\n        // condition 2: if the next smallest interval ends before this one\\n        if(tm.floorKey(end) == null || tm.get(tm.floorKey(end)) < start){\\n            c += end-start+1;\\n            tm.put(start,end);\\n            return;\\n        }\\n\\n\\n        // If we\\'re here, there\\'s overlap\\n        int nS = tm.floorKey(end);\\n        int nE = tm.get(tm.floorKey(end));\\n\\n        // if we cant add anything in because this interval encapsulates it\\n        if(start >= nS && end <= nE)\\n            return;\\n        \\n        add(start,nS-1);\\n        add(nE+1,end);\\n    }\\n    \\n    public int count() {\\n        return c;\\n    }\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644418,
                "title": "explained-python3-solution-beating-83",
                "content": "The idea is to maintain the intervals in the collection non-overlapped. \\nTo add a new interval (left, right), we try to merge it with existing overlapped intervals by considering following cases:\\n\\n1. (left, right) is fully covered by an existing interval, then we have nothing to do. \\n2. (left, right) overlaps with its left interval, then we merge the two.\\n3. (left, right) overlaps with its right interval, then we also merge the two. \\n4. (left, right) fully covers some existing intervals, then we discard all the covered, smaller intervals. \\n\\nDuring each merge, the total covered number will be updated at the same time. \\nTo faciliate the computation, the collection of intervals is implemented with an ordered list such as SortedList in python3. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n    def __init__(self):\\n        self.total = 0\\n        self.tree = SortedList()\\n        \\n    def add(self, left: int, right: int) -> None:\\n        overlaps = [(l, r) for l, r in self.tree.irange((left, -inf), (right, inf)) if r >= left]\\n        prev = self.tree.bisect_left((left, -inf)) - 1\\n        if prev >= 0:\\n            l, r = self.tree[prev]\\n\\t\\t\\t# Do nothing if the current interval is fully covered by an existing interval\\n            if r >= right:\\n                return \\n\\t\\t\\t# Merge the current interval with its left one if they are overlapped\\n            if r >= left:\\n                left = l\\n                self.total -= (r - l + 1)\\n                self.tree.remove((l, r))\\n        if overlaps:\\n            l, r = overlaps[-1]\\n\\t\\t\\t# Merge the current interval with its right one if they are overlapped\\n            if l <= right and r >= right:\\n                right = r\\n                self.total -= (r - l + 1)\\n                self.tree.remove((l, r))\\n                overlaps.pop()\\n\\t\\t\\t# Discard all the smaller intervals that are covered by the current interval\\n            for l, r in overlaps:\\n                self.total -= r - l + 1   \\n                self.tree.remove((l, r)) \\n\\t\\t# Finally, adding the merged, non-overlapped interval into the collection\\n        self.total += (right - left + 1)\\n        self.tree.add((left, right))    \\n            \\n    def count(self) -> int:\\n        return self.total",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "The idea is to maintain the intervals in the collection non-overlapped. \\nTo add a new interval (left, right), we try to merge it with existing overlapped intervals by considering following cases:\\n\\n1. (left, right) is fully covered by an existing interval, then we have nothing to do. \\n2. (left, right) overlaps with its left interval, then we merge the two.\\n3. (left, right) overlaps with its right interval, then we also merge the two. \\n4. (left, right) fully covers some existing intervals, then we discard all the covered, smaller intervals. \\n\\nDuring each merge, the total covered number will be updated at the same time. \\nTo faciliate the computation, the collection of intervals is implemented with an ordered list such as SortedList in python3. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n    def __init__(self):\\n        self.total = 0\\n        self.tree = SortedList()\\n        \\n    def add(self, left: int, right: int) -> None:\\n        overlaps = [(l, r) for l, r in self.tree.irange((left, -inf), (right, inf)) if r >= left]\\n        prev = self.tree.bisect_left((left, -inf)) - 1\\n        if prev >= 0:\\n            l, r = self.tree[prev]\\n\\t\\t\\t# Do nothing if the current interval is fully covered by an existing interval\\n            if r >= right:\\n                return \\n\\t\\t\\t# Merge the current interval with its left one if they are overlapped\\n            if r >= left:\\n                left = l\\n                self.total -= (r - l + 1)\\n                self.tree.remove((l, r))\\n        if overlaps:\\n            l, r = overlaps[-1]\\n\\t\\t\\t# Merge the current interval with its right one if they are overlapped\\n            if l <= right and r >= right:\\n                right = r\\n                self.total -= (r - l + 1)\\n                self.tree.remove((l, r))\\n                overlaps.pop()\\n\\t\\t\\t# Discard all the smaller intervals that are covered by the current interval\\n            for l, r in overlaps:\\n                self.total -= r - l + 1   \\n                self.tree.remove((l, r)) \\n\\t\\t# Finally, adding the merged, non-overlapped interval into the collection\\n        self.total += (right - left + 1)\\n        self.tree.add((left, right))    \\n            \\n    def count(self) -> int:\\n        return self.total",
                "codeTag": "Java"
            },
            {
                "id": 2642327,
                "title": "java-w-treemap",
                "content": "# Intuition\\nBasically we will need to merge intervals.\\n\\n# Approach\\n0. maintain a treemap to store all intervals, and a variable count to store the number of covered integers\\n1. for each new interval to be added, find out an overlapping interval with smallest start;\\n2.  remove the overlapping interval from the treemap, subtract this interval\\'s length from count;\\n3. merge the overlapping interval with the new interval, add it to the treemap, and add the length of the merged interval to count\\n4. repeat until there are no overlapping intervals\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) because of treemap, the while loop itself costs O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass CountIntervals {\\n\\n    int count;\\n    TreeMap<Integer, Integer> intervalMap;\\n    public CountIntervals() {\\n        this.count = 0;\\n        this.intervalMap = new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n        Integer floorStart = intervalMap.floorKey(left);\\n        if (floorStart == null) {\\n            floorStart = intervalMap.ceilingKey(left);\\n        } else if (floorStart != null && intervalMap.get(floorStart) < left) {\\n            floorStart = intervalMap.ceilingKey(left);\\n        }\\n        while (floorStart != null && (floorStart <= left && intervalMap.get(floorStart) >= left ||\\n                                      floorStart <= right && intervalMap.get(floorStart) >= right ||\\n                                      floorStart >= left && intervalMap.get(floorStart) <= right)) {\\n            int floorEnd = intervalMap.get(floorStart);\\n            intervalMap.remove(floorStart);\\n            count -= floorEnd - floorStart + 1;\\n            left = Math.min(floorStart, left);\\n            right = Math.max(floorEnd, right);\\n            floorStart = intervalMap.floorKey(left);\\n            if (floorStart == null) {\\n                floorStart = intervalMap.ceilingKey(left);\\n            } else if (floorStart != null && intervalMap.get(floorStart) < left) {\\n                floorStart = intervalMap.ceilingKey(left);\\n            }\\n        }\\n            \\n        intervalMap.put(left, right);\\n        count += right - left + 1;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CountIntervals {\\n\\n    int count;\\n    TreeMap<Integer, Integer> intervalMap;\\n    public CountIntervals() {\\n        this.count = 0;\\n        this.intervalMap = new TreeMap<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n        Integer floorStart = intervalMap.floorKey(left);\\n        if (floorStart == null) {\\n            floorStart = intervalMap.ceilingKey(left);\\n        } else if (floorStart != null && intervalMap.get(floorStart) < left) {\\n            floorStart = intervalMap.ceilingKey(left);\\n        }\\n        while (floorStart != null && (floorStart <= left && intervalMap.get(floorStart) >= left ||\\n                                      floorStart <= right && intervalMap.get(floorStart) >= right ||\\n                                      floorStart >= left && intervalMap.get(floorStart) <= right)) {\\n            int floorEnd = intervalMap.get(floorStart);\\n            intervalMap.remove(floorStart);\\n            count -= floorEnd - floorStart + 1;\\n            left = Math.min(floorStart, left);\\n            right = Math.max(floorEnd, right);\\n            floorStart = intervalMap.floorKey(left);\\n            if (floorStart == null) {\\n                floorStart = intervalMap.ceilingKey(left);\\n            } else if (floorStart != null && intervalMap.get(floorStart) < left) {\\n                floorStart = intervalMap.ceilingKey(left);\\n            }\\n        }\\n            \\n        intervalMap.put(left, right);\\n        count += right - left + 1;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624725,
                "title": "java-beat-20-treemap-solution-with-clear-explanation",
                "content": "1. If no overlapping, directly add into the range map;\\n2. otherwise, enlarge the range, remove overlapping old ranges in the treeMap and  add new range into map. In the mean time, change the count which is a global variable.\\n```\\n    TreeMap<Integer, Integer>map;\\n    int count;\\n    public CountIntervals() {\\n        //key will be the range start point, value will be the range end point\\n        map = new TreeMap<>();\\n        count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Integer start = map.floorKey(left);\\n        Integer end = map.floorKey(right);\\n\\n        //new interval can be added as a separate new one\\n        if(end != null && map.get(end) < left) {\\n            count += (right - left + 1);\\n            map.put(left, right);\\n        } else{\\n            //need delete overlapping range.\\n            //----  -----    ------- //orig\\n            //  ----------------   //new\\n            //to be removed\\n            //----  -----    ------- //all old that has overlapping with orig should be deleted.\\n            while(map.floorKey(right) != null && map.get(map.floorKey(right)) >= left) {\\n                int l = map.floorKey(right);\\n                int r = map.get(l);\\n                count -= (r - l + 1);\\n                map.remove(l);\\n                //enlarge the merged range, thus all overlapping (even partial ones) should be removed.\\n                left = Math.min(l, left);\\n                right = Math.max(r, right);\\n               }\\n        //replace start item with same range\\n        map.put(left, right);\\n        count += (right - left + 1);\\n        }\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n    TreeMap<Integer, Integer>map;\\n    int count;\\n    public CountIntervals() {\\n        //key will be the range start point, value will be the range end point\\n        map = new TreeMap<>();\\n        count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Integer start = map.floorKey(left);\\n        Integer end = map.floorKey(right);\\n\\n        //new interval can be added as a separate new one\\n        if(end != null && map.get(end) < left) {\\n            count += (right - left + 1);\\n            map.put(left, right);\\n        } else{\\n            //need delete overlapping range.\\n            //----  -----    ------- //orig\\n            //  ----------------   //new\\n            //to be removed\\n            //----  -----    ------- //all old that has overlapping with orig should be deleted.\\n            while(map.floorKey(right) != null && map.get(map.floorKey(right)) >= left) {\\n                int l = map.floorKey(right);\\n                int r = map.get(l);\\n                count -= (r - l + 1);\\n                map.remove(l);\\n                //enlarge the merged range, thus all overlapping (even partial ones) should be removed.\\n                left = Math.min(l, left);\\n                right = Math.max(r, right);\\n               }\\n        //replace start item with same range\\n        map.put(left, right);\\n        count += (right - left + 1);\\n        }\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574264,
                "title": "c-set-of-disjoint-intervals",
                "content": "```\\nclass CountIntervals {\\npublic:\\n    // set of disjoint intervals\\n    \\n    struct Interval {\\n        int left;\\n        int right;\\n        \\n        int size() { return right - left + 1; };\\n        \\n        bool _overlaps(const Interval& other) {\\n            if (other.left < left) {\\n                return left <= other.right;\\n            } else {\\n                return other.left <= right;\\n            }\\n        }\\n        \\n        bool overlaps(const Interval& other) {\\n            auto result = _overlaps(other);\\n            return result;\\n        }\\n    };\\n    \\n    std::map<int, Interval> begin;\\n    int _count;\\n    \\n    CountIntervals() : begin(), _count(0) {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        Interval i = { left, right};\\n        \\n        auto begin_it = begin.lower_bound(left);\\n        \\n        if (begin_it == begin.begin()) {\\n            if (begin_it != begin.end() && begin_it->second.left == left) {\\n                this->_count -= begin_it->second.size();\\n                begin_it->second.right = std::max(begin_it->second.right, right);\\n                this->_count += begin_it->second.size();\\n            } else {\\n                begin.emplace(left, i);\\n                this->_count += i.size();\\n            }\\n            begin_it = begin.begin();\\n        } else {\\n            if (begin_it->second.left != left) {\\n                begin_it--;\\n            }\\n            \\n            if (begin_it->second.overlaps(i)) {\\n                this->_count -= begin_it->second.size();\\n                begin_it->second.right = std::max(right, begin_it->second.right);\\n                this->_count += begin_it->second.size();\\n            } else {\\n                begin.emplace(left, i);\\n                this->_count += i.size();\\n            }\\n        }\\n        \\n        auto next_it = std::next(begin_it);\\n        if (next_it != begin.end() && !next_it->second.overlaps(begin_it->second)) {\\n            begin_it++;\\n            next_it++;\\n        }\\n        \\n        if (begin_it != begin.end()) {\\n            auto coalesce_it = std::next(begin_it);\\n            while (coalesce_it != begin.end() && coalesce_it->second.overlaps(begin_it->second)) {\\n                this->_count -= begin_it->second.size() + coalesce_it->second.size();\\n                begin_it->second.right = std::max(begin_it->second.right, coalesce_it->second.right);\\n                this->_count += begin_it->second.size();\\n                auto next = std::next(coalesce_it);\\n                begin.erase(coalesce_it);\\n                coalesce_it = next;\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return _count;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    // set of disjoint intervals\\n    \\n    struct Interval {\\n        int left;\\n        int right;\\n        \\n        int size() { return right - left + 1; };\\n        \\n        bool _overlaps(const Interval& other) {\\n            if (other.left < left) {\\n                return left <= other.right;\\n            } else {\\n                return other.left <= right;\\n            }\\n        }\\n        \\n        bool overlaps(const Interval& other) {\\n            auto result = _overlaps(other);\\n            return result;\\n        }\\n    };\\n    \\n    std::map<int, Interval> begin;\\n    int _count;\\n    \\n    CountIntervals() : begin(), _count(0) {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        Interval i = { left, right};\\n        \\n        auto begin_it = begin.lower_bound(left);\\n        \\n        if (begin_it == begin.begin()) {\\n            if (begin_it != begin.end() && begin_it->second.left == left) {\\n                this->_count -= begin_it->second.size();\\n                begin_it->second.right = std::max(begin_it->second.right, right);\\n                this->_count += begin_it->second.size();\\n            } else {\\n                begin.emplace(left, i);\\n                this->_count += i.size();\\n            }\\n            begin_it = begin.begin();\\n        } else {\\n            if (begin_it->second.left != left) {\\n                begin_it--;\\n            }\\n            \\n            if (begin_it->second.overlaps(i)) {\\n                this->_count -= begin_it->second.size();\\n                begin_it->second.right = std::max(right, begin_it->second.right);\\n                this->_count += begin_it->second.size();\\n            } else {\\n                begin.emplace(left, i);\\n                this->_count += i.size();\\n            }\\n        }\\n        \\n        auto next_it = std::next(begin_it);\\n        if (next_it != begin.end() && !next_it->second.overlaps(begin_it->second)) {\\n            begin_it++;\\n            next_it++;\\n        }\\n        \\n        if (begin_it != begin.end()) {\\n            auto coalesce_it = std::next(begin_it);\\n            while (coalesce_it != begin.end() && coalesce_it->second.overlaps(begin_it->second)) {\\n                this->_count -= begin_it->second.size() + coalesce_it->second.size();\\n                begin_it->second.right = std::max(begin_it->second.right, coalesce_it->second.right);\\n                this->_count += begin_it->second.size();\\n                auto next = std::next(coalesce_it);\\n                begin.erase(coalesce_it);\\n                coalesce_it = next;\\n            }\\n        }\\n    }\\n    \\n    int count() {\\n        return _count;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2554625,
                "title": "merge-interval-along-with-new-count-calculation",
                "content": "```\\nclass CountIntervals {\\n\\n    // TreeMap to store intervals {start : end}\\n    private TreeMap<Integer, Integer> treeMap;\\n    private int count;\\n    \\n    public CountIntervals() {\\n        treeMap = new TreeMap<>();\\n        count = 0;\\n    }\\n    // Time complexity: n*log(n), n - no of merged intervals\\n    public void add(int left, int right) {\\n        int start = left;\\n        int end = right;\\n        // Current count\\n        int currentCount = end - start;\\n        \\n        Map.Entry<Integer, Integer> floor = treeMap.floorEntry(left);\\n        if (floor != null) {\\n            if (floor.getValue() >= end) return;\\n            if (floor.getValue() >= start) {\\n                // Updating the current count as interval overlap\\n                // TreeMap: [6, 10] and current: [8, 15]\\n                currentCount -= floor.getValue() - start;\\n                treeMap.remove(floor.getKey());\\n                start = floor.getKey();\\n            }\\n        }\\n        \\n        Map.Entry<Integer, Integer> ceiling = treeMap.ceilingEntry(left);\\n        // Need a loop here. Example: TreeMap: [6,8], [10,15], [18,22] and current: [5,20]\\n        while (ceiling != null && ceiling.getKey() <= end) {\\n            treeMap.remove(ceiling.getKey());\\n            currentCount -= Math.min(ceiling.getValue(), end) - ceiling.getKey();\\n            end = Math.max(ceiling.getValue(), end);\\n            ceiling = treeMap.ceilingEntry(left);\\n        }\\n        \\n        count += currentCount;\\n        treeMap.put(start, end);\\n    }\\n    \\n\\t// Time complexity: O(1)\\n    public int count() {\\n        // Adding the size of the map as need to include interval bounderies\\n        return count + treeMap.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass CountIntervals {\\n\\n    // TreeMap to store intervals {start : end}\\n    private TreeMap<Integer, Integer> treeMap;\\n    private int count;\\n    \\n    public CountIntervals() {\\n        treeMap = new TreeMap<>();\\n        count = 0;\\n    }\\n    // Time complexity: n*log(n), n - no of merged intervals\\n    public void add(int left, int right) {\\n        int start = left;\\n        int end = right;\\n        // Current count\\n        int currentCount = end - start;\\n        \\n        Map.Entry<Integer, Integer> floor = treeMap.floorEntry(left);\\n        if (floor != null) {\\n            if (floor.getValue() >= end) return;\\n            if (floor.getValue() >= start) {\\n                // Updating the current count as interval overlap\\n                // TreeMap: [6, 10] and current: [8, 15]\\n                currentCount -= floor.getValue() - start;\\n                treeMap.remove(floor.getKey());\\n                start = floor.getKey();\\n            }\\n        }\\n        \\n        Map.Entry<Integer, Integer> ceiling = treeMap.ceilingEntry(left);\\n        // Need a loop here. Example: TreeMap: [6,8], [10,15], [18,22] and current: [5,20]\\n        while (ceiling != null && ceiling.getKey() <= end) {\\n            treeMap.remove(ceiling.getKey());\\n            currentCount -= Math.min(ceiling.getValue(), end) - ceiling.getKey();\\n            end = Math.max(ceiling.getValue(), end);\\n            ceiling = treeMap.ceilingEntry(left);\\n        }\\n        \\n        count += currentCount;\\n        treeMap.put(start, end);\\n    }\\n    \\n\\t// Time complexity: O(1)\\n    public int count() {\\n        // Adding the size of the map as need to include interval bounderies\\n        return count + treeMap.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420545,
                "title": "python-custom-binary-search-impl-very-simple-code",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.container = SortedList([])\\n        self.numbers = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        if len(self.container) == 0:\\n            self.container.add([left,right])\\n            self.numbers += (right-left+1)\\n            return\\n        #get first smallest to the right\\n        idx = self.find_idx(right)\\n        if idx == -1 or idx == len(self.container):\\n            self.container.add([left,right])\\n            self.numbers += (right-left+1)\\n            return\\n        ele = self.container[idx]\\n        if ele[1] >= left:\\n            l = left\\n            r = right\\n            #remove all overlapping intervals\\n            while idx >= 0 and l <= self.container[idx][1]:\\n                ele = self.container[idx]\\n                self.container.pop(idx)\\n                self.numbers -= (ele[1]-ele[0]+1)\\n                l,r = min(ele[0],l),max(ele[1],r)\\n                idx -= 1\\n            self.container.add([l,r])\\n            self.numbers += (r-l+1)\\n        else:\\n            self.container.add([left,right])\\n            self.numbers += (right-left+1)\\n        return\\n    def find_idx(self,num):\\n        low = 0\\n        high = len(self.container) - 1\\n        ans = len(self.container)\\n        while low <= high:\\n            mid = (low+high)//2\\n            if self.container[mid][0] <= num:\\n                ans = mid\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        if ans == 0:\\n            if self.container[0][0] > num:\\n                return -1\\n        return ans\\n    def count(self) -> int:\\n        return self.numbers\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.container = SortedList([])\\n        self.numbers = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        if len(self.container) == 0:\\n            self.container.add([left,right])\\n            self.numbers += (right-left+1)\\n            return\\n        #get first smallest to the right\\n        idx = self.find_idx(right)\\n        if idx == -1 or idx == len(self.container):\\n            self.container.add([left,right])\\n            self.numbers += (right-left+1)\\n            return\\n        ele = self.container[idx]\\n        if ele[1] >= left:\\n            l = left\\n            r = right\\n            #remove all overlapping intervals\\n            while idx >= 0 and l <= self.container[idx][1]:\\n                ele = self.container[idx]\\n                self.container.pop(idx)\\n                self.numbers -= (ele[1]-ele[0]+1)\\n                l,r = min(ele[0],l),max(ele[1],r)\\n                idx -= 1\\n            self.container.add([l,r])\\n            self.numbers += (r-l+1)\\n        else:\\n            self.container.add([left,right])\\n            self.numbers += (right-left+1)\\n        return\\n    def find_idx(self,num):\\n        low = 0\\n        high = len(self.container) - 1\\n        ans = len(self.container)\\n        while low <= high:\\n            mid = (low+high)//2\\n            if self.container[mid][0] <= num:\\n                ans = mid\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        if ans == 0:\\n            if self.container[0][0] > num:\\n                return -1\\n        return ans\\n    def count(self) -> int:\\n        return self.numbers\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2361449,
                "title": "java-submap-with-comments",
                "content": "```Java\\nclass CountIntervals {\\n\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n    int count = 0;\\n    public CountIntervals() {\\n\\n    }\\n\\n    public void add(int left, int right) {\\n        Integer l = map.floorKey(left);\\n        Integer r = map.floorKey(right);\\n        left = l == null || map.get(l) < left? left : l; // find the left bound (min)\\n        right = Math.max(right, r == null? 0 : map.get(r)); // find the right bound (max)\\n        Map<Integer, Integer> dup = map.subMap(left, true, right, true); // use submap\\n        for (int key : dup.keySet()){ // delete ALL that\\'s in the submap\\n            count -= (map.get(key)-key+1);\\n        }\\n        dup.clear(); // delete the map\\n        map.put(left, right); // THEN, we put it in.\\n        count += (right - left + 1);\\n    }\\n\\n    public int count() {\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass CountIntervals {\\n\\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n    int count = 0;\\n    public CountIntervals() {\\n\\n    }\\n\\n    public void add(int left, int right) {\\n        Integer l = map.floorKey(left);\\n        Integer r = map.floorKey(right);\\n        left = l == null || map.get(l) < left? left : l; // find the left bound (min)\\n        right = Math.max(right, r == null? 0 : map.get(r)); // find the right bound (max)\\n        Map<Integer, Integer> dup = map.subMap(left, true, right, true); // use submap\\n        for (int key : dup.keySet()){ // delete ALL that\\'s in the submap\\n            count -= (map.get(key)-key+1);\\n        }\\n        dup.clear(); // delete the map\\n        map.put(left, right); // THEN, we put it in.\\n        count += (right - left + 1);\\n    }\\n\\n    public int count() {\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183737,
                "title": "java-merge-intervals",
                "content": "```\\npublic class CountIntervals {\\n    private int count;\\n    private final TreeMap<Integer, Integer> intervals;\\n\\n    public CountIntervals() {\\n        this.intervals = new TreeMap<>();\\n    }\\n\\n    public void add(int left, int right) {\\n        while (true) {\\n            Integer floorKey = this.intervals.floorKey(right);\\n            int floorVal = floorKey == null ? 0 : this.intervals.get(floorKey);\\n            if (floorKey == null || floorVal < left) break; // no more intersections left\\n            left = Math.min(floorKey, left);\\n            right = Math.max(floorVal, right);\\n            this.intervals.remove(floorKey);\\n            this.count -= floorVal - floorKey + 1;\\n        }\\n        this.intervals.put(left, right);\\n        this.count += right - left + 1;\\n    }\\n\\n    public int count() {\\n        return this.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\npublic class CountIntervals {\\n    private int count;\\n    private final TreeMap<Integer, Integer> intervals;\\n\\n    public CountIntervals() {\\n        this.intervals = new TreeMap<>();\\n    }\\n\\n    public void add(int left, int right) {\\n        while (true) {\\n            Integer floorKey = this.intervals.floorKey(right);\\n            int floorVal = floorKey == null ? 0 : this.intervals.get(floorKey);\\n            if (floorKey == null || floorVal < left) break; // no more intersections left\\n            left = Math.min(floorKey, left);\\n            right = Math.max(floorVal, right);\\n            this.intervals.remove(floorKey);\\n            this.count -= floorVal - floorKey + 1;\\n        }\\n        this.intervals.put(left, right);\\n        this.count += right - left + 1;\\n    }\\n\\n    public int count() {\\n        return this.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152487,
                "title": "java-binary-search",
                "content": "```\\nclass CountIntervals {\\n    List<int[]> intervals;\\n    int total = 0;\\n    public CountIntervals() {\\n        intervals = new ArrayList();\\n    }\\n    \\n    public void add(int left, int right) {\\n        int index = binarySearch(left, right);\\n        int preSum = 0;\\n        int newSum = 0;\\n        if(index-1>=0 && intervals.get(index-1)[1]>=left) {\\n            index-=1;\\n            left = intervals.get(index)[0];\\n            right = Math.max(right, intervals.get(index)[1]);\\n            preSum+=(intervals.get(index)[1] - intervals.get(index)[0]+1);\\n            intervals.remove(index);\\n        }\\n        while(index<intervals.size() && right>=intervals.get(index)[0]) {\\n            preSum+=(intervals.get(index)[1] - intervals.get(index)[0]+1);\\n            right = Math.max(right, intervals.get(index)[1]);\\n            intervals.remove(index);\\n        }\\n        newSum = right-left+1;\\n        intervals.add(index, new int[]{left, right});\\n        total+=(newSum-preSum);\\n    }\\n    \\n    public int count() {\\n        return total;\\n    }\\n    \\n    private int binarySearch(int left, int right) {\\n        int start = 0;\\n        int end = intervals.size();\\n        while(start<end) {\\n            int mid = (start+end)/2;\\n            if(intervals.get(mid)[0]<left) {\\n                start = mid+1;\\n            }else if (intervals.get(mid)[0]>left) {\\n                end = mid;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\n    List<int[]> intervals;\\n    int total = 0;\\n    public CountIntervals() {\\n        intervals = new ArrayList();\\n    }\\n    \\n    public void add(int left, int right) {\\n        int index = binarySearch(left, right);\\n        int preSum = 0;\\n        int newSum = 0;\\n        if(index-1>=0 && intervals.get(index-1)[1]>=left) {\\n            index-=1;\\n            left = intervals.get(index)[0];\\n            right = Math.max(right, intervals.get(index)[1]);\\n            preSum+=(intervals.get(index)[1] - intervals.get(index)[0]+1);\\n            intervals.remove(index);\\n        }\\n        while(index<intervals.size() && right>=intervals.get(index)[0]) {\\n            preSum+=(intervals.get(index)[1] - intervals.get(index)[0]+1);\\n            right = Math.max(right, intervals.get(index)[1]);\\n            intervals.remove(index);\\n        }\\n        newSum = right-left+1;\\n        intervals.add(index, new int[]{left, right});\\n        total+=(newSum-preSum);\\n    }\\n    \\n    public int count() {\\n        return total;\\n    }\\n    \\n    private int binarySearch(int left, int right) {\\n        int start = 0;\\n        int end = intervals.size();\\n        while(start<end) {\\n            int mid = (start+end)/2;\\n            if(intervals.get(mid)[0]<left) {\\n                start = mid+1;\\n            }else if (intervals.get(mid)[0]>left) {\\n                end = mid;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131211,
                "title": "c-100-faster-no-map-just-a-list",
                "content": "All other solutions I saw here use a map, so I\\'m posting my solution using a regular list (which happens to be faster)\\n\\n##### How this could be made even faster:\\n - `Add` takes `O(logN)` time in average, but `O(N)` in worst case. __Can be modified to achieve `O(logN)` in the worst case__ also (a comment in the code suggests how this can be done), but that __might not be worth it__ for many test cases.\\n - In some cases we call `RemoveRange` and then `Insert` to the same place. Those inserts could be avoided by removing 1 interval less and just changing its values.\\n - Might be even faster with a `List<Range>` of structs (same memory footprint), to reduce number of calls to `Insert`.\\n - The built-in `BinarySearch` is probably slower than it could be.\\n - Some custom allocations strategy, with the goals of fast indexing/insertOne/removeRange. Most effort but also most theoretical performance gain, since 99% of *extra work* comes from moving memory around.\\n\\n\\n<small>note: the funky comments are just my visual aid, not meant to be explained</small>\\n\\n```\\npublic class CountIntervals {\\n    List<int> intervals = new List<int>(); // LR  LR  LR\\n    int count;\\n\\n    public void Add(int left, int right)\\n    {\\n      // l is index of the [left] of the range smaller than us (can be -2)\\n      int l = intervals.BinarySearch(left);\\n      //  L R L R\\n      //  *^^^\\n      if (l < 0)\\n        l = ~l - 1;\\n      l -= l & 1; // move from R to its L\\n\\n      // r is the index of the [left] of the range bigger than us (can be Length)\\n      int r = intervals.BinarySearch(right);\\n      //  L R L R\\n      //     ^*^^\\n      if (r < 0)\\n        r = ~r;\\n      r -= r & 1; // move from R to its L\\n\\n      // L  R\\n      //  <>\\n      if (l==r)\\n        return; // overlapping a single range\\n\\n      // L  R   L  R   L  R   L  R\\n      // l    < ****   **** > r\\n      for (int i = l + 2; i < r; i += 2)\\n        count -= intervals[i + 1] - intervals[i] + 1;\\n      // could avoid O(n) here, by saving an accumulatedCount per interval\\n      // but this O(n) operation is rare because it makes the N ranges collapse back into 1\\n      // so I\\'ll leave it be\\n\\n      bool mergeToLeft = l >= 0 && left <= intervals[l + 1] + 1;\\n      bool mergeToRight = r < intervals.Count && right >= intervals[r] - 1;\\n      if (mergeToLeft && mergeToRight)\\n      {\\n        // L  R   L  R   L  R   L  R\\n        //    x*<*x**x***x**x*>*x\\n        count += intervals[r] - intervals[l + 1] - 1;\\n        intervals.RemoveRange(l + 1, r - l);\\n        return;\\n      }\\n      if (mergeToLeft)\\n      {\\n        // L  R   L  R   L  R   L  R\\n        //  <  ***************>\\n        count += right - intervals[l + 1];\\n        intervals[l + 1] = right;\\n      }\\n      if (mergeToRight)\\n      {\\n        // L  R   L  R   L  R   L  R\\n        //      <***************  >\\n        count += intervals[r] - left;\\n        intervals[r] = left;\\n      }\\n      // L  R   L  R   L  R   L  R\\n      // l      x  x   x  x   r\\n      int del = r - l - 2;\\n      if (del > 0)\\n        intervals.RemoveRange(l + 2, del); // r is wrong now, dont use it any more\\n      if (!mergeToLeft && !mergeToRight)\\n      {\\n        intervals.Insert(l + 2, left);\\n        intervals.Insert(l + 3, right);\\n        count += right - left + 1;\\n      }\\n    }\\n\\n    public int Count()\\n    {\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic class CountIntervals {\\n    List<int> intervals = new List<int>(); // LR  LR  LR\\n    int count;\\n\\n    public void Add(int left, int right)\\n    {\\n      // l is index of the [left] of the range smaller than us (can be -2)\\n      int l = intervals.BinarySearch(left);\\n      //  L R L R\\n      //  *^^^\\n      if (l < 0)\\n        l = ~l - 1;\\n      l -= l & 1; // move from R to its L\\n\\n      // r is the index of the [left] of the range bigger than us (can be Length)\\n      int r = intervals.BinarySearch(right);\\n      //  L R L R\\n      //     ^*^^\\n      if (r < 0)\\n        r = ~r;\\n      r -= r & 1; // move from R to its L\\n\\n      // L  R\\n      //  <>\\n      if (l==r)\\n        return; // overlapping a single range\\n\\n      // L  R   L  R   L  R   L  R\\n      // l    < ****   **** > r\\n      for (int i = l + 2; i < r; i += 2)\\n        count -= intervals[i + 1] - intervals[i] + 1;\\n      // could avoid O(n) here, by saving an accumulatedCount per interval\\n      // but this O(n) operation is rare because it makes the N ranges collapse back into 1\\n      // so I\\'ll leave it be\\n\\n      bool mergeToLeft = l >= 0 && left <= intervals[l + 1] + 1;\\n      bool mergeToRight = r < intervals.Count && right >= intervals[r] - 1;\\n      if (mergeToLeft && mergeToRight)\\n      {\\n        // L  R   L  R   L  R   L  R\\n        //    x*<*x**x***x**x*>*x\\n        count += intervals[r] - intervals[l + 1] - 1;\\n        intervals.RemoveRange(l + 1, r - l);\\n        return;\\n      }\\n      if (mergeToLeft)\\n      {\\n        // L  R   L  R   L  R   L  R\\n        //  <  ***************>\\n        count += right - intervals[l + 1];\\n        intervals[l + 1] = right;\\n      }\\n      if (mergeToRight)\\n      {\\n        // L  R   L  R   L  R   L  R\\n        //      <***************  >\\n        count += intervals[r] - left;\\n        intervals[r] = left;\\n      }\\n      // L  R   L  R   L  R   L  R\\n      // l      x  x   x  x   r\\n      int del = r - l - 2;\\n      if (del > 0)\\n        intervals.RemoveRange(l + 2, del); // r is wrong now, dont use it any more\\n      if (!mergeToLeft && !mergeToRight)\\n      {\\n        intervals.Insert(l + 2, left);\\n        intervals.Insert(l + 3, right);\\n        count += right - left + 1;\\n      }\\n    }\\n\\n    public int Count()\\n    {\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120495,
                "title": "c-easy-understandable-solution",
                "content": "```\\n\\n```class CountIntervals {\\npublic:\\n//using a set for storing left and right\\n    set<pair<int,int>>s;\\n    int sum=0;//this will store my sum\\n    CountIntervals() {\\n        s.clear();\\n        sum=0;\\n    }\\n    void add(int left, int right) \\n    {\\n       //checking if set is empty   \\n        if(s.size()==0)\\n        {\\n         s.insert(make_pair(left,right));\\n            sum+=right-left+1;\\n            \\n        }\\n        else\\n        {\\n\\t\\t    \\n             auto it=s.upper_bound({right,INT_MAX});\\n\\t\\t\\t // if(it==s.begin()) that means we have to directly add this range\\n             if(it==s.begin())\\n             {\\n                // cout<<\"1\"<<\"\\\\n\";\\n                 s.insert(make_pair(left,right));\\n                 sum+=right-left+1;\\n             }\\n            else\\n            {\\n\\t\\t\\t//removing all the intersecting intervals\\n              it--;// as we are taking the upperbound so we have to decrement the iterator \\n             while((it->second)>=left)\\n             {\\n                sum=sum-(it->second-it->first+1);\\n                left=min(left,it->first);\\n                right=max(right,it->second);\\n                \\n                 if(it==s.begin())\\n                 {\\n                    s.erase(it);\\n                     break;\\n                 }\\n                 s.erase(it--);\\n               \\n             }\\n             \\n             s.insert(make_pair(left,right));\\n             sum+=(right-left+1);\\n            }\\n       }\\n       \\n    }\\n    int count() \\n    {\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112641,
                "title": "python-sortedlist-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.cov = 0 \\n        self.interv = SortedList([(-inf, -inf), (inf, inf)])\\n\\n    def add(self, left: int, right: int) -> None:\\n        li = self.interv.bisect_left((left - 1, -inf))\\n        if self.interv[li - 1][1] >= left - 1:\\n            li -= 1\\n        lval = min(self.interv[li][0], left)\\n        ri = self.interv.bisect_right((right + 1, inf))\\n        rval = max(self.interv[ri - 1][1], right)\\n        \\n        \\n        to_delete = 0\\n        for _ in range(li, ri):\\n            to_delete += self.interv[_][1] - self.interv[_][0] + 1\\n        self.cov += rval - lval + 1 - to_delete\\n        del self.interv[li: ri]\\n        self.interv.add((lval, rval))\\n\\n    def count(self) -> int:\\n        return self.cov\\n\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.cov = 0 \\n        self.interv = SortedList([(-inf, -inf), (inf, inf)])\\n\\n    def add(self, left: int, right: int) -> None:\\n        li = self.interv.bisect_left((left - 1, -inf))\\n        if self.interv[li - 1][1] >= left - 1:\\n            li -= 1\\n        lval = min(self.interv[li][0], left)\\n        ri = self.interv.bisect_right((right + 1, inf))\\n        rval = max(self.interv[ri - 1][1], right)\\n        \\n        \\n        to_delete = 0\\n        for _ in range(li, ri):\\n            to_delete += self.interv[_][1] - self.interv[_][0] + 1\\n        self.cov += rval - lval + 1 - to_delete\\n        del self.interv[li: ri]\\n        self.interv.add((lval, rval))\\n\\n    def count(self) -> int:\\n        return self.cov\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2084252,
                "title": "map",
                "content": "**using map in c++**\\n\\n\\n\\nclass CountIntervals {\\npublic:\\n    int cnt;\\n    map<int,int> intervals;\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) \\n    {\\n        \\n        int newIntervalFirst = left;\\n        int newIntervalSecond = right;\\n        \\n        auto it = intervals.upper_bound(right);\\n        \\n        // the size of the map is zero or the size of the start of the first element is greater than the right;\\n        // in that case we simply have to insert the element;\\n        \\n        if(intervals.size() == 0 || it == intervals.begin())\\n        {\\n            intervals[left] = right;\\n            cnt = cnt + (right - left) + 1;\\n            return;\\n        }\\n        \\n        it--;\\n        \\n        // condition for overlapping;\\n        while((it->second) >= newIntervalFirst)\\n        {\\n            int firstValue = it->first;\\n            int secondValue = it->second;\\n            \\n            // this interval get merged with the new interval\\n            // so we subtract  the element of this from the count , and also erase thet interval from the intervals map;\\n            \\n            intervals.erase(firstValue);\\n            cnt = cnt - (secondValue - firstValue + 1);\\n            \\n            newIntervalFirst = min(newIntervalFirst , firstValue);\\n            newIntervalSecond = max(newIntervalSecond , secondValue);\\n            \\n            it = intervals.upper_bound(newIntervalSecond);\\n            \\n            if(intervals.size() == 0 || it == intervals.begin())\\n            {\\n                break;\\n            }\\n            it--;\\n        }\\n        \\n        cnt = cnt + (newIntervalSecond - newIntervalFirst) + 1;\\n        \\n        intervals[newIntervalFirst] = newIntervalSecond;\\n        return;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */",
                "solutionTags": [],
                "code": "**using map in c++**\\n\\n\\n\\nclass CountIntervals {\\npublic:\\n    int cnt;\\n    map<int,int> intervals;\\n    CountIntervals() {\\n        cnt = 0;\\n    }\\n    \\n    void add(int left, int right) \\n    {\\n        \\n        int newIntervalFirst = left;\\n        int newIntervalSecond = right;\\n        \\n        auto it = intervals.upper_bound(right);\\n        \\n        // the size of the map is zero or the size of the start of the first element is greater than the right;\\n        // in that case we simply have to insert the element;\\n        \\n        if(intervals.size() == 0 || it == intervals.begin())\\n        {\\n            intervals[left] = right;\\n            cnt = cnt + (right - left) + 1;\\n            return;\\n        }\\n        \\n        it--;\\n        \\n        // condition for overlapping;\\n        while((it->second) >= newIntervalFirst)\\n        {\\n            int firstValue = it->first;\\n            int secondValue = it->second;\\n            \\n            // this interval get merged with the new interval\\n            // so we subtract  the element of this from the count , and also erase thet interval from the intervals map;\\n            \\n            intervals.erase(firstValue);\\n            cnt = cnt - (secondValue - firstValue + 1);\\n            \\n            newIntervalFirst = min(newIntervalFirst , firstValue);\\n            newIntervalSecond = max(newIntervalSecond , secondValue);\\n            \\n            it = intervals.upper_bound(newIntervalSecond);\\n            \\n            if(intervals.size() == 0 || it == intervals.begin())\\n            {\\n                break;\\n            }\\n            it--;\\n        }\\n        \\n        cnt = cnt + (newIntervalSecond - newIntervalFirst) + 1;\\n        \\n        intervals[newIntervalFirst] = newIntervalSecond;\\n        return;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2071522,
                "title": "golang-stuck-with-exceeding-time-limit",
                "content": "I\\'ve been hacking away at this problem for a few nights now, trying to solve this with GoLang.\\n\\nSeveral permutations of the solution that I have attempted keep ending up in a Time Limit Exceeded Error. I\\'m at a loss on how I can get around this. The code below is what I believe is an accurate solution and my best attempt at solving this in an optimal manner with Go:\\n\\n```go\\ntype Interval struct {\\n    left int\\n    right int\\n}\\n\\ntype CountIntervals struct {\\n    intervals []Interval\\n    count int\\n}\\n\\nfunc Constructor() CountIntervals {\\n    return CountIntervals{} \\n}\\n\\nfunc (this *CountIntervals) Add(left int, right int)  {\\n    // First, do a Binary Search for left.\\n    // Either find interval that contains it\\n    // or the one that is just ahead of it.\\n    lo := 0\\n    hi := len(this.intervals)\\n    var insertPos, rightPos int\\n    \\n    for {\\n        insertPos = (hi - lo) / 2 + lo\\n        rightPos = insertPos\\n        if lo >= hi { break }\\n        \\n        curInterval := this.intervals[insertPos]\\n        if curInterval.contains(left) {\\n            // Intersection with current interval.\\n            // Will be replaced with new interval.\\n            this.count -= curInterval.count()\\n            left = curInterval.left\\n            right = max(right, curInterval.right)\\n            rightPos++\\n            break\\n        }\\n        \\n        // Adjust binary search\\n        if curInterval.left > left {\\n            hi = insertPos\\n        } else {\\n            lo = insertPos + 1\\n        }\\n    }\\n    \\n    // Now keep searching to the right for intersecting intervals\\n    for ; rightPos < len(this.intervals); rightPos++ {\\n        rInterval := this.intervals[rightPos]\\n        if right < rInterval.left { break }\\n        \\n        this.count -= rInterval.count()\\n        right = max(right, rInterval.right)\\n    }\\n    \\n    interval := Interval{left, right}\\n    this.count += interval.count()\\n    this.intervals = createIntervals(\\n        this.intervals[:insertPos],\\n        interval,\\n        this.intervals[rightPos:],\\n        len(this.intervals) + 1,\\n    )\\n}\\n\\nfunc (this *CountIntervals) Count() int {\\n    return this.count\\n}\\n\\nfunc createIntervals(left []Interval, mid Interval, right []Interval, size int) []Interval {\\n    intervals := append(make([]Interval, 0, size), left...)\\n    intervals = append(intervals, mid)\\n    intervals = append(intervals, right...)\\n    return intervals\\n}\\n\\nfunc (this Interval) contains(num int) bool {\\n    return this.left <= num && this.right >= num\\n}\\n\\nfunc (this Interval) count() int {\\n    return this.right - this.left + 1\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(left,right);\\n * param_2 := obj.Count();\\n */\\n ```\\n \\n I have already taken a peek at solutions in other languages and am aware that a \"TreeMap\" solution is often employed. Unfortuantely, Go does not natively implement this data type (whereas a language like Java does). While I could implement my own in my solution, my belief was that I could simply use a list data structure and optimally search through it during `Add()` via a Binary Search. But if a native TreeMap is really necessary, then is a more optimal solution in Go even possible?\\n \\n For `Add()`, the best/average-case runtime would be `O(log N)`. But of course there is the sequential search for all intervals that are between `left` and `right`, which needs to be done in order to subtracted merged intervals from the `count` field. That does mean that `Add()` would have a worst-case runtime of `O(N)`. I\\'m not sure exactly how I could optimize this further. Maybe I could also binary-search for the position in the intervals list for `right`, but I\\'d still need to iterate through all intervals in-between.\\n \\n For `Count()`, the runtime is `O(1)` because the `count` is being computed on the fly. Perhaps if I did an approach where I did just a binary search for `left` and `right` and cleared out all intervals in-between without computing the count on the fly (for a pure `O(log N)` runtime on `Add()`), then my `Count()` implementation would have a worst-case runtime of `O(N)`, since we have to loop through all intervals to calculate. But then we could memoize this count so that all subsequent calls of `Count()` are `O(1)`, at least until the next `Add()` operation. This was just a passing thought. I fear that this alternate approach would fail the time limit.\\n \\n Anyhow, help and guidance is much appreciated. Thanks a lot.",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype Interval struct {\\n    left int\\n    right int\\n}\\n\\ntype CountIntervals struct {\\n    intervals []Interval\\n    count int\\n}\\n\\nfunc Constructor() CountIntervals {\\n    return CountIntervals{} \\n}\\n\\nfunc (this *CountIntervals) Add(left int, right int)  {\\n    // First, do a Binary Search for left.\\n    // Either find interval that contains it\\n    // or the one that is just ahead of it.\\n    lo := 0\\n    hi := len(this.intervals)\\n    var insertPos, rightPos int\\n    \\n    for {\\n        insertPos = (hi - lo) / 2 + lo\\n        rightPos = insertPos\\n        if lo >= hi { break }\\n        \\n        curInterval := this.intervals[insertPos]\\n        if curInterval.contains(left) {\\n            // Intersection with current interval.\\n            // Will be replaced with new interval.\\n            this.count -= curInterval.count()\\n            left = curInterval.left\\n            right = max(right, curInterval.right)\\n            rightPos++\\n            break\\n        }\\n        \\n        // Adjust binary search\\n        if curInterval.left > left {\\n            hi = insertPos\\n        } else {\\n            lo = insertPos + 1\\n        }\\n    }\\n    \\n    // Now keep searching to the right for intersecting intervals\\n    for ; rightPos < len(this.intervals); rightPos++ {\\n        rInterval := this.intervals[rightPos]\\n        if right < rInterval.left { break }\\n        \\n        this.count -= rInterval.count()\\n        right = max(right, rInterval.right)\\n    }\\n    \\n    interval := Interval{left, right}\\n    this.count += interval.count()\\n    this.intervals = createIntervals(\\n        this.intervals[:insertPos],\\n        interval,\\n        this.intervals[rightPos:],\\n        len(this.intervals) + 1,\\n    )\\n}\\n\\nfunc (this *CountIntervals) Count() int {\\n    return this.count\\n}\\n\\nfunc createIntervals(left []Interval, mid Interval, right []Interval, size int) []Interval {\\n    intervals := append(make([]Interval, 0, size), left...)\\n    intervals = append(intervals, mid)\\n    intervals = append(intervals, right...)\\n    return intervals\\n}\\n\\nfunc (this Interval) contains(num int) bool {\\n    return this.left <= num && this.right >= num\\n}\\n\\nfunc (this Interval) count() int {\\n    return this.right - this.left + 1\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(left,right);\\n * param_2 := obj.Count();\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065784,
                "title": "c-ordered-set-solution",
                "content": "```\\nclass CountIntervals {\\npublic:\\n  int tot = 0;\\n  set<pair<int, int>> all;\\n  \\n  CountIntervals() {\\n  }\\n\\n  void add(int left, int right) {\\n    if (all.empty()) {\\n      all.insert({left, right});\\n      tot += (1 + right - left);\\n      return;\\n    }\\n    \\n    auto begin = all.begin();\\n    auto end = all.end();\\n    int first = left, last = right;\\n    vector<pair<int, int>> overlapping;\\n    \\n    auto init = all.lower_bound(make_pair(left, right));\\n    auto it = init;\\n    while (it != begin) {\\n      --it;\\n      if (it->second >= first) {\\n        first = min(first, it->first);\\n        last = max(last, it->second);\\n        overlapping.push_back(*it);\\n      } else {\\n        break;\\n      }\\n    }\\n    \\n    auto jt = init;\\n    while (jt != end) {\\n      if (jt->first <= last) {\\n        last = max(last, jt->second);\\n        overlapping.push_back(*jt);\\n      } else {\\n        break;\\n      }\\n      jt++;\\n    }\\n    \\n    for (auto pr : overlapping) {\\n      tot -= (1 + pr.second - pr.first);\\n      all.erase(pr);\\n    }\\n    tot += (1 + last - first);\\n    all.insert({first, last});\\n  }\\n\\n  int count() {\\n    return tot;\\n  }\\n};\\n\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\npublic:\\n  int tot = 0;\\n  set<pair<int, int>> all;\\n  \\n  CountIntervals() {\\n  }\\n\\n  void add(int left, int right) {\\n    if (all.empty()) {\\n      all.insert({left, right});\\n      tot += (1 + right - left);\\n      return;\\n    }\\n    \\n    auto begin = all.begin();\\n    auto end = all.end();\\n    int first = left, last = right;\\n    vector<pair<int, int>> overlapping;\\n    \\n    auto init = all.lower_bound(make_pair(left, right));\\n    auto it = init;\\n    while (it != begin) {\\n      --it;\\n      if (it->second >= first) {\\n        first = min(first, it->first);\\n        last = max(last, it->second);\\n        overlapping.push_back(*it);\\n      } else {\\n        break;\\n      }\\n    }\\n    \\n    auto jt = init;\\n    while (jt != end) {\\n      if (jt->first <= last) {\\n        last = max(last, jt->second);\\n        overlapping.push_back(*jt);\\n      } else {\\n        break;\\n      }\\n      jt++;\\n    }\\n    \\n    for (auto pr : overlapping) {\\n      tot -= (1 + pr.second - pr.first);\\n      all.erase(pr);\\n    }\\n    tot += (1 + last - first);\\n    all.insert({first, last});\\n  }\\n\\n  int count() {\\n    return tot;\\n  }\\n};\\n\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065730,
                "title": "why-am-i-exceeding-time-limit",
                "content": "EDIT: The reason was that I was doing lower_bound(all.begin(), all.end(), target) instead of all.lower_bound(target) which is faster\\n```\\nclass CountIntervals {\\npublic:\\n  int tot = 0;\\n  set<pair<int, int>> all;\\n  \\n  CountIntervals() {\\n  }\\n\\n  void add(int left, int right) {\\n    if (all.empty()) {\\n      all.insert({left, right});\\n      tot += (1 + right - left);\\n      return;\\n    }\\n    \\n    auto begin = all.begin();\\n    auto end = all.end();\\n    int first = left, last = right;\\n    vector<pair<int, int>> overlapping;\\n    \\n    auto init = lower_bound(all.begin(), all.end(), make_pair(left, right));\\n    auto it = init;\\n    while (it != begin) {\\n      --it;\\n      if (it->second >= first) {\\n        first = min(first, it->first);\\n        last = max(last, it->second);\\n        tot -= (1 + it->second - it->first);\\n        overlapping.push_back(*it);\\n      } else {\\n        break;\\n      }\\n    }\\n    \\n    auto jt = init;\\n    while (jt != end) {\\n      if (jt->first <= last) {\\n        last = max(last, jt->second);\\n        tot -= (1 + jt->second - jt->first);\\n        overlapping.push_back(*jt);\\n      } else {\\n        break;\\n      }\\n      jt++;\\n    }\\n    \\n    for (auto pr : overlapping) {\\n      all.erase(pr);\\n    }\\n    tot += (1 + last - first);\\n    all.insert({first, last});\\n  }\\n\\n  int count() {\\n    return tot;\\n  }\\n};\\n\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\npublic:\\n  int tot = 0;\\n  set<pair<int, int>> all;\\n  \\n  CountIntervals() {\\n  }\\n\\n  void add(int left, int right) {\\n    if (all.empty()) {\\n      all.insert({left, right});\\n      tot += (1 + right - left);\\n      return;\\n    }\\n    \\n    auto begin = all.begin();\\n    auto end = all.end();\\n    int first = left, last = right;\\n    vector<pair<int, int>> overlapping;\\n    \\n    auto init = lower_bound(all.begin(), all.end(), make_pair(left, right));\\n    auto it = init;\\n    while (it != begin) {\\n      --it;\\n      if (it->second >= first) {\\n        first = min(first, it->first);\\n        last = max(last, it->second);\\n        tot -= (1 + it->second - it->first);\\n        overlapping.push_back(*it);\\n      } else {\\n        break;\\n      }\\n    }\\n    \\n    auto jt = init;\\n    while (jt != end) {\\n      if (jt->first <= last) {\\n        last = max(last, jt->second);\\n        tot -= (1 + jt->second - jt->first);\\n        overlapping.push_back(*jt);\\n      } else {\\n        break;\\n      }\\n      jt++;\\n    }\\n    \\n    for (auto pr : overlapping) {\\n      all.erase(pr);\\n    }\\n    tot += (1 + last - first);\\n    all.insert({first, last});\\n  }\\n\\n  int count() {\\n    return tot;\\n  }\\n};\\n\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061580,
                "title": "c-code",
                "content": "```\\nclass CountIntervals {\\npublic:\\n    map<int,int> m;\\n    int ans;\\n    CountIntervals() {\\n        m.clear();\\n        m[0] = 0;\\n        ans=0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = m.upper_bound(left);\\n        int start, end;\\n        \\n        it--;\\n        if(left > it->second)\\n        {\\n            start = left;\\n            end   = left;\\n            ans += 1;\\n            it++;\\n        }\\n        else\\n        {\\n            start = it->first;\\n            end = it->first-1;\\n        }\\n        \\n        while(true)\\n        {\\n            if(it==m.end() || right<it->first)\\n            {\\n                ans += right-end;\\n                end = right;\\n                break;\\n            }\\n            int temp = it->first;\\n            ans += it->first-end-1;\\n            if(it->second >= right)\\n            {\\n                end = it->second;\\n                m.erase(m.find(temp));\\n                break;\\n            }\\n            end = it->second;\\n            it++;\\n            m.erase(m.find(temp));\\n        }\\n        m[start] = end;\\n    }\\n    int count() {\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    map<int,int> m;\\n    int ans;\\n    CountIntervals() {\\n        m.clear();\\n        m[0] = 0;\\n        ans=0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = m.upper_bound(left);\\n        int start, end;\\n        \\n        it--;\\n        if(left > it->second)\\n        {\\n            start = left;\\n            end   = left;\\n            ans += 1;\\n            it++;\\n        }\\n        else\\n        {\\n            start = it->first;\\n            end = it->first-1;\\n        }\\n        \\n        while(true)\\n        {\\n            if(it==m.end() || right<it->first)\\n            {\\n                ans += right-end;\\n                end = right;\\n                break;\\n            }\\n            int temp = it->first;\\n            ans += it->first-end-1;\\n            if(it->second >= right)\\n            {\\n                end = it->second;\\n                m.erase(m.find(temp));\\n                break;\\n            }\\n            end = it->second;\\n            it++;\\n            m.erase(m.find(temp));\\n        }\\n        m[start] = end;\\n    }\\n    int count() {\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060927,
                "title": "scala-neat-treemap-solution",
                "content": "```scala\\n\\nclass CountIntervals() {\\n\\n  val iMap = scala.collection.mutable.TreeMap.empty[Int, Int]\\n\\n  var cnt = 0\\n\\n  def add(left: Int, right: Int) {\\n    val leftInterval = iMap.maxBefore(left).filter(_._2 >= left)\\n    val rightIntervals = iMap.range(left, right + 1)\\n    val nLeft = leftInterval.map(_._1).getOrElse(left)\\n    val nRight = List(Some(right), leftInterval.map(_._2), rightIntervals.lastOption.map(_._2)).flatten.max\\n    (leftInterval ++ rightIntervals).foreach { case(l, r) =>\\n      iMap.remove(l)\\n      cnt -= distance(l, r)\\n    }\\n    iMap(nLeft) = nRight\\n    cnt += distance(nLeft, nRight)\\n  }\\n\\n  def count(): Int = cnt\\n\\n  def distance(left: Int, right: Int) = right - left + 1\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Tree"
                ],
                "code": "```scala\\n\\nclass CountIntervals() {\\n\\n  val iMap = scala.collection.mutable.TreeMap.empty[Int, Int]\\n\\n  var cnt = 0\\n\\n  def add(left: Int, right: Int) {\\n    val leftInterval = iMap.maxBefore(left).filter(_._2 >= left)\\n    val rightIntervals = iMap.range(left, right + 1)\\n    val nLeft = leftInterval.map(_._1).getOrElse(left)\\n    val nRight = List(Some(right), leftInterval.map(_._2), rightIntervals.lastOption.map(_._2)).flatten.max\\n    (leftInterval ++ rightIntervals).foreach { case(l, r) =>\\n      iMap.remove(l)\\n      cnt -= distance(l, r)\\n    }\\n    iMap(nLeft) = nRight\\n    cnt += distance(nLeft, nRight)\\n  }\\n\\n  def count(): Int = cnt\\n\\n  def distance(left: Int, right: Int) = right - left + 1\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057657,
                "title": "c-map-merge-intervals",
                "content": "```\\nclass CountIntervals {\\npublic:\\n    map<int,int>Map;\\n    int ans=0;\\n    CountIntervals() \\n    {\\n        Map.clear();\\n        ans=0;\\n    }\\n    \\n    void add(int left, int right) \\n    {\\n        auto it=Map.lower_bound(left);\\n        if(it!=Map.begin())\\n        {\\n            it--;\\n            if((*it).first<=left&&left<=(*it).second)left=(*it).first;\\n            else it++;\\n        }\\n        if(it==Map.end())\\n        {\\n            Map[left]=right;\\n            ans+=right-left+1;\\n            return;\\n        }\\n        vector<int>record;\\n        while((*it).first<=right)\\n        {\\n            record.push_back((*it).first);\\n            ans-=(*it).second-(*it).first+1;\\n            if((*it).second<=right)it++;\\n            else\\n            {\\n                right=(*it).second;\\n                it++;\\n            }\\n            if(it==Map.end())break;\\n        }\\n        for(auto &x:record)Map.erase(x);\\n        Map[left]=right;\\n        ans+=right-left+1;\\n    }\\n    \\n    int count() \\n    {\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    map<int,int>Map;\\n    int ans=0;\\n    CountIntervals() \\n    {\\n        Map.clear();\\n        ans=0;\\n    }\\n    \\n    void add(int left, int right) \\n    {\\n        auto it=Map.lower_bound(left);\\n        if(it!=Map.begin())\\n        {\\n            it--;\\n            if((*it).first<=left&&left<=(*it).second)left=(*it).first;\\n            else it++;\\n        }\\n        if(it==Map.end())\\n        {\\n            Map[left]=right;\\n            ans+=right-left+1;\\n            return;\\n        }\\n        vector<int>record;\\n        while((*it).first<=right)\\n        {\\n            record.push_back((*it).first);\\n            ans-=(*it).second-(*it).first+1;\\n            if((*it).second<=right)it++;\\n            else\\n            {\\n                right=(*it).second;\\n                it++;\\n            }\\n            if(it==Map.end())break;\\n        }\\n        for(auto &x:record)Map.erase(x);\\n        Map[left]=right;\\n        ans+=right-left+1;\\n    }\\n    \\n    int count() \\n    {\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051474,
                "title": "java-treemap-solution",
                "content": "```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> map;\\n    int count = 0;\\n    public CountIntervals() {\\n        map = new TreeMap<>();\\n        map.put(-1, -1);\\n        map.put(1_000_000_001, 1_000_000_001);\\n        count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Map.Entry<Integer, Integer> item = map.floorEntry(left).getValue() < left ? map.ceilingEntry(left) : map.floorEntry(left);\\n        while(item.getKey() <= right) {\\n            left = Math.min(left, item.getKey());\\n            right = Math.max(right, item.getValue());\\n            count -= item.getValue() - item.getKey() + 1;\\n            map.remove(item.getKey());\\n            item = map.ceilingEntry(item.getKey());\\n        }\\n        \\n        map.put(left, right);\\n        count += right - left + 1;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> map;\\n    int count = 0;\\n    public CountIntervals() {\\n        map = new TreeMap<>();\\n        map.put(-1, -1);\\n        map.put(1_000_000_001, 1_000_000_001);\\n        count = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Map.Entry<Integer, Integer> item = map.floorEntry(left).getValue() < left ? map.ceilingEntry(left) : map.floorEntry(left);\\n        while(item.getKey() <= right) {\\n            left = Math.min(left, item.getKey());\\n            right = Math.max(right, item.getValue());\\n            count -= item.getValue() - item.getKey() + 1;\\n            map.remove(item.getKey());\\n            item = map.ceilingEntry(item.getKey());\\n        }\\n        \\n        map.put(left, right);\\n        count += right - left + 1;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049376,
                "title": "python-sortedlist-segment-tree",
                "content": "**Sorted List**\\n\\ntime: O(n*log(n))\\nspace: O(n)\\nRuntime: 1184 ms, 83.14% \\nMemory: 54.4 MB, 41.34%\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n    def __init__(self):\\n        self.s = SortedList()    \\n        self.cnt = 0\\n        \\n    def delete(self, idx, left, right, x, y):\\n        self.s.pop(idx)\\n        left = min(left, x)\\n        right = max(right, y)\\n        self.cnt -= (y-x+1)\\n        return left, right\\n    \\n    def add(self, left: int, right: int) -> None:\\n        l = self.s.bisect_left((left,right))\\n        while l-1 >= 0:\\n            x, y = self.s[l-1]\\n            if y < left: break\\n            left, right = self.delete(l-1, left, right, x, y)\\n            l -= 1\\n        while l < len(self.s):\\n            x, y = self.s[l]\\n            if right < x: break\\n            left, right = self.delete(l, left, right, x, y)\\n        self.s.add((left, right))\\n        self.cnt += (right-left+1)\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```\\n\\n\\n**Segment Tree**\\n\\nInspired by user8856S\\' [comment](https://leetcode.com/problems/count-integers-in-intervals/discuss/2040221/Python-Segment-Tree-got-TLE.-Why).\\ntime: O(n*log(n))\\nspace: O(n)\\nRuntime: 6015 ms, 10.70%\\nMemory: 138.7 MB, 9.57%\\n\\n```\\nclass Node:\\n    def __init__(self):\\n        self.res = self.left = self.right = None\\n        \\n    def add(self, node, x, y, s, e):\\n        if e<=x or y<=s or node and node.res == y-x: return node\\n        if not node: node = Node()\\n        if s<=x and y<=e:\\n            node.res = y-x\\n            return node\\n        mid = (x+y)//2\\n        node.left = self.add(node.left, x, mid, s, e)\\n        node.right = self.add(node.right, mid, y, s, e)\\n        node.res = 0\\n        if node.left: node.res += node.left.res\\n        if node.right: node.res += node.right.res\\n        return node\\n        \\nclass CountIntervals:\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def add(self, left: int, right: int) -> None:\\n        self.root.add(self.root, 1, 10**9+1, left, right+1)\\n        \\n    def count(self) -> int:\\n        return self.root.res or 0\\n```\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass CountIntervals:\\n    def __init__(self):\\n        self.s = SortedList()    \\n        self.cnt = 0\\n        \\n    def delete(self, idx, left, right, x, y):\\n        self.s.pop(idx)\\n        left = min(left, x)\\n        right = max(right, y)\\n        self.cnt -= (y-x+1)\\n        return left, right\\n    \\n    def add(self, left: int, right: int) -> None:\\n        l = self.s.bisect_left((left,right))\\n        while l-1 >= 0:\\n            x, y = self.s[l-1]\\n            if y < left: break\\n            left, right = self.delete(l-1, left, right, x, y)\\n            l -= 1\\n        while l < len(self.s):\\n            x, y = self.s[l]\\n            if right < x: break\\n            left, right = self.delete(l, left, right, x, y)\\n        self.s.add((left, right))\\n        self.cnt += (right-left+1)\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```\n```\\nclass Node:\\n    def __init__(self):\\n        self.res = self.left = self.right = None\\n        \\n    def add(self, node, x, y, s, e):\\n        if e<=x or y<=s or node and node.res == y-x: return node\\n        if not node: node = Node()\\n        if s<=x and y<=e:\\n            node.res = y-x\\n            return node\\n        mid = (x+y)//2\\n        node.left = self.add(node.left, x, mid, s, e)\\n        node.right = self.add(node.right, mid, y, s, e)\\n        node.res = 0\\n        if node.left: node.res += node.left.res\\n        if node.right: node.res += node.right.res\\n        return node\\n        \\nclass CountIntervals:\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def add(self, left: int, right: int) -> None:\\n        self.root.add(self.root, 1, 10**9+1, left, right+1)\\n        \\n    def count(self) -> int:\\n        return self.root.res or 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046153,
                "title": "solution-using-set-short-c",
                "content": "class CountIntervals {\\npublic:\\n    set<pair<int,int>> s;\\n    int total=0;\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        if(s.size()==0){\\n            s.insert({left,right});\\n            total+=right-left+1;\\n            \\n        }\\n        else{\\n            auto it=s.lower_bound({left,right});\\n            if(it!=s.begin()){\\n              auto x=it;\\n                auto y =*(--x);\\n                if((y.second)>=left-1){\\n                    it--;\\n                }\\n               \\n            }\\n           while(it!=s.end() && (*it).first<=right+1){\\n            total-=(*it).second-(*it).first+1;\\n            left=min((*it).first,left);\\n            right=max((*it).second,right);\\n            it=s.erase(it);//Note:erase return the iterator of the next element \\n            }\\n        s.insert({left,right});\\n        total+=right-left+1;\\n        }\\n    }\\n    \\n    int count() {\\n        return total;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */",
                "solutionTags": [],
                "code": "class CountIntervals {\\npublic:\\n    set<pair<int,int>> s;\\n    int total=0;\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        if(s.size()==0){\\n            s.insert({left,right});\\n            total+=right-left+1;\\n            \\n        }\\n        else{\\n            auto it=s.lower_bound({left,right});\\n            if(it!=s.begin()){\\n              auto x=it;\\n                auto y =*(--x);\\n                if((y.second)>=left-1){\\n                    it--;\\n                }\\n               \\n            }\\n           while(it!=s.end() && (*it).first<=right+1){\\n            total-=(*it).second-(*it).first+1;\\n            left=min((*it).first,left);\\n            right=max((*it).second,right);\\n            it=s.erase(it);//Note:erase return the iterator of the next element \\n            }\\n        s.insert({left,right});\\n        total+=right-left+1;\\n        }\\n    }\\n    \\n    int count() {\\n        return total;\\n    }\\n};\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals* obj = new CountIntervals();\\n * obj->add(left,right);\\n * int param_2 = obj->count();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2044323,
                "title": "python-merge-intervals-to-track-non-overlap-intervals-neat-code-beat-85",
                "content": "```\\nfrom bisect import bisect_left, insort\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.cnt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        if not self.intervals or self.intervals[0][0] > right or self.intervals[-1][1] < left:\\n            insort(self.intervals, (left, right))\\n            self.cnt += right - left + 1\\n            return\\n        idx = bisect_left(self.intervals, (left, left))\\n        if idx > 0 and self.intervals[idx - 1][1] >= left: idx -= 1\\n        if self.intervals[idx][0] > right:\\n            insort(self.intervals, (left, right))\\n            self.cnt += right - left + 1\\n            return\\n        i, left, cur_right = idx, min(left, self.intervals[idx][0]), right\\n        while i < len(self.intervals) and self.intervals[i][0] <= right:\\n            cur_right = max(cur_right, self.intervals[i][1])\\n            self.cnt -= min(right, self.intervals[i][1]) - self.intervals[i][0] + 1\\n            i += 1\\n        self.cnt += right - left + 1\\n        self.intervals[idx:i] = [(left, cur_right)]\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left, insort\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.cnt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        if not self.intervals or self.intervals[0][0] > right or self.intervals[-1][1] < left:\\n            insort(self.intervals, (left, right))\\n            self.cnt += right - left + 1\\n            return\\n        idx = bisect_left(self.intervals, (left, left))\\n        if idx > 0 and self.intervals[idx - 1][1] >= left: idx -= 1\\n        if self.intervals[idx][0] > right:\\n            insort(self.intervals, (left, right))\\n            self.cnt += right - left + 1\\n            return\\n        i, left, cur_right = idx, min(left, self.intervals[idx][0]), right\\n        while i < len(self.intervals) and self.intervals[i][0] <= right:\\n            cur_right = max(cur_right, self.intervals[i][1])\\n            self.cnt -= min(right, self.intervals[i][1]) - self.intervals[i][0] + 1\\n            i += 1\\n        self.cnt += right - left + 1\\n        self.intervals[idx:i] = [(left, cur_right)]\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044258,
                "title": "python3-single-built-in-list-968-ms-47-9-mb",
                "content": "As reported by LeetCode (on 16 May 2022), this solution **beats `most of` other Python implementations in both runtime and memory efficiency** (~968 ms, ~47.9 MB). Although LeetCode reported `100%` instead of `most of`, I know that number is not very true.\\n\\nPlease, share your idea if you can optimise the implementation below further.\\n\\nIn this implementation, both the `left` and the `right` values of the added intervals are stored in a single sorted list. When adding a new interval to the the list, we can tell whether the new interval overlaps existing ones based on the indices returned from the `bisect_left` and `bisect_right` functions (see the code below).\\n\\n```python\\nfrom bisect import bisect_left, bisect_right\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self._intervals = [0] * 20001  # pre-allocate the memory\\n        self._size = 0\\n        self._count = -1\\n\\n    def add(self, left: int, right: int) -> None:\\n        if left > right:\\n            tmp = left\\n            left = right\\n            right = tmp\\n\\n        if self._size == 0:\\n            self._size = 2\\n            self._intervals[:2] = [left, right]\\n        else:\\n            leftPos = bisect_left(self._intervals, left - 1, 0, self._size)\\n            rightPos = bisect_right(self._intervals, right + 1, leftPos, self._size)\\n\\n            if leftPos % 2 == 1:\\n\\t\\t\\t\\t# This means the new interval overlaps an existing one\\n                leftPos -= 1\\n                left = self._intervals[leftPos]\\n            elif leftPos < self._size and left > self._intervals[leftPos]:\\n                left = self._intervals[leftPos]\\n\\n            if rightPos % 2 == 1:\\n\\t\\t\\t\\t# This means the new interval overlaps an existing one\\n                right = self._intervals[rightPos]\\n                rightPos += 1\\n            elif rightPos > 0 and right < self._intervals[rightPos - 1]:\\n                right = self._intervals[rightPos - 1]\\n\\n\\t\\t\\t# Modify the interval list in place (for memory efficiency)\\n            oldSize = self._size\\n            self._size = leftPos + 2 + (self._size - rightPos)\\t\\t\\t\\n            self._intervals[leftPos + 2 : self._size] = self._intervals[rightPos : oldSize]\\n            self._intervals[leftPos : leftPos + 2] = [left, right]\\n\\n        self._count = -1  # invalidate self._count\\n\\n\\n    def count(self) -> int:\\n        if self._count < 0:\\n            self._count = 0\\n            for i in range(1, self._size, 2):\\n                self._count += self._intervals[i] - self._intervals[i-1] + 1\\n        return self._count\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```python\\nfrom bisect import bisect_left, bisect_right\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self._intervals = [0] * 20001  # pre-allocate the memory\\n        self._size = 0\\n        self._count = -1\\n\\n    def add(self, left: int, right: int) -> None:\\n        if left > right:\\n            tmp = left\\n            left = right\\n            right = tmp\\n\\n        if self._size == 0:\\n            self._size = 2\\n            self._intervals[:2] = [left, right]\\n        else:\\n            leftPos = bisect_left(self._intervals, left - 1, 0, self._size)\\n            rightPos = bisect_right(self._intervals, right + 1, leftPos, self._size)\\n\\n            if leftPos % 2 == 1:\\n\\t\\t\\t\\t# This means the new interval overlaps an existing one\\n                leftPos -= 1\\n                left = self._intervals[leftPos]\\n            elif leftPos < self._size and left > self._intervals[leftPos]:\\n                left = self._intervals[leftPos]\\n\\n            if rightPos % 2 == 1:\\n\\t\\t\\t\\t# This means the new interval overlaps an existing one\\n                right = self._intervals[rightPos]\\n                rightPos += 1\\n            elif rightPos > 0 and right < self._intervals[rightPos - 1]:\\n                right = self._intervals[rightPos - 1]\\n\\n\\t\\t\\t# Modify the interval list in place (for memory efficiency)\\n            oldSize = self._size\\n            self._size = leftPos + 2 + (self._size - rightPos)\\t\\t\\t\\n            self._intervals[leftPos + 2 : self._size] = self._intervals[rightPos : oldSize]\\n            self._intervals[leftPos : leftPos + 2] = [left, right]\\n\\n        self._count = -1  # invalidate self._count\\n\\n\\n    def count(self) -> int:\\n        if self._count < 0:\\n            self._count = 0\\n            for i in range(1, self._size, 2):\\n                self._count += self._intervals[i] - self._intervals[i-1] + 1\\n        return self._count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042923,
                "title": "python-no-sortedcontainer-with-thought-process-being-asked-during-interviews",
                "content": "### Binary Search\\nWe need to maintain the intervals for each `add` query and update the `count` for all of integers covered by intervals. We can use `TreeMap` in java or `ordered map` in C++ to implement `interval search tree`, which sorts the `left` as the key with `right` as value. \\nHowever, in python, we don\\'t have built-in library for sorted contianers. You might quickly figure it out using `SortedContainer` library, but I wasn\\'t familar with it, and used the standard list to implemente it.If you want to know how to do it, keep reading.\\n\\nThe idea using standard list is that we put the pair of `left` and `right` in the order, so each interger at even index is `left` and the one at odd index is `right`. We can tell whether the current integer is `left` or `right` by checking the index. So the length of the list is always even. \\nFor each `add`, we find the index for `left` and `right` to fall in the list using binary search. And sum up all of intervals covered by the `index of (left, right)` to update the count of integers being covered.\\nThe difficulty part is to deal with merging for different edge cases since there are 4 cases for combinations of index of `left` and `right`.\\n1. `left`: even, `right`: even.\\n   We have larger interval to insert, covering completely a couple of intervals. For example, `[2,5,8,10]` to insert `[1, 11]` or `[1, 6]`, or `[6, 7]`. So we just override the `[i:j]` with the new `(left, right)`.\\n\\t Since intervals are covered completely, we can simply sum up of length of intervals covered.\\n\\t ```\\n\\t tree[i: j] = [left, right]\\n\\t sum = query(tree[i: j])\\n\\t ```\\n\\t \\n2. `left`: odd, `right`: even.\\n   We have the `right` overlapping with other intevals, not for `left`.  For example, `[2,5,8,10]` to insert `[1, 9]` or `[1, 3]`, or `[6, 9]`. So we just override the `[i:j]` with the new `(left)` only since `left` is merged to intervals.\\n\\t Since intervals are covered partially, we have to sum up of length of intervals covered plus `right` because `right` overlapps with the last one of covered intervals.\\n\\t ```\\n\\t tree[i: j] = [left]\\n\\t sum = query(tree[i: j] + [right])\\n\\t ```\\n\\t\\n3. `left`: even, `right`: odd.\\n   Similarly with 2, we have the `left` overlapping with other intevals, not for `right`.  For example, `[2,5,8,10]` to insert `[3, 11]` or `[3, 6]`, or `[9, 11]`. So we just override the `[i:j]` with the new `(right)` only since `right` is merged to intervals.\\n\\t Since intervals are covered partially, we have to sum up of length of intervals covered plus `left` because `left` overlapps with the last one of covered intervals.\\n\\t ```\\n\\t tree[i: j] = [right]\\n\\t sum = query([left] + tree[i: j])\\n\\t ```\\n\\t\\n4. `left`: even, `right`: even.\\n      We have both of `left` and `right` overlapping with other intevals. For example, `[2,5,8,10]` to insert `[3, 4]` or `[3, 9]`. So we just override the `[i:j]` with the new `()`  since mergeing all of intervals covered.\\n\\t Since intervals are covered partially, we have to sum up of length of intervals covered plus  `left` and `right`.\\n\\t ```\\n\\t tree[i: j] = []\\n\\t sum = query([left] + tree[i: j] + [right])\\n\\t ```\\n\\t \\n```python\\nclass CountIntervals:\\n\\n\\tdef __init__(self):\\n\\t\\tself.st = []\\n        self.c = 0\\n        \\n    def add(self, left: int, right: int) -> None:\\n        i = bisect.bisect_left(self.st, left)\\n        j = bisect.bisect(self.st, right)\\n\\t\\tself.c += right - left + 1\\n        if not i % 2 and not j % 2: # even even\\n            self.c -= self.query(self.st[i: j])\\n            self.st[i:j] = [left, right]\\n        elif i % 2 and not j % 2:\\n            self.c -= self.query([left] + self.st[i: j])\\n            self.st[i: j] = [right]\\n        elif not i % 2 and j % 2:     \\n            self.c -= self.query(self.st[i: j] + [right])\\n            self.st[i: j] = [left]\\n        else:      \\n            self.c -= self.query([left] + self.st[i:j] + [right])\\n            self.st[i:j] = []\\n\\n    def query(self, nums):       \\n        return sum(nums[i + 1] - nums[i] + 1 for i in range(0, len(nums), 2))\\n        \\n    def count(self) -> int:\\n        return self.c\\n        \\n```\\n\\n\\n*Time Complexity*= **O(lgN + N)** for each `add` call, since `insert` in standard list is linear.\\n*Space Complexity* = **O(N)**\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\t tree[i: j] = [left, right]\\n\\t sum = query(tree[i: j])\\n\\t ```\n```\\n\\t tree[i: j] = [left]\\n\\t sum = query(tree[i: j] + [right])\\n\\t ```\n```\\n\\t tree[i: j] = [right]\\n\\t sum = query([left] + tree[i: j])\\n\\t ```\n```\\n\\t tree[i: j] = []\\n\\t sum = query([left] + tree[i: j] + [right])\\n\\t ```\n```python\\nclass CountIntervals:\\n\\n\\tdef __init__(self):\\n\\t\\tself.st = []\\n        self.c = 0\\n        \\n    def add(self, left: int, right: int) -> None:\\n        i = bisect.bisect_left(self.st, left)\\n        j = bisect.bisect(self.st, right)\\n\\t\\tself.c += right - left + 1\\n        if not i % 2 and not j % 2: # even even\\n            self.c -= self.query(self.st[i: j])\\n            self.st[i:j] = [left, right]\\n        elif i % 2 and not j % 2:\\n            self.c -= self.query([left] + self.st[i: j])\\n            self.st[i: j] = [right]\\n        elif not i % 2 and j % 2:     \\n            self.c -= self.query(self.st[i: j] + [right])\\n            self.st[i: j] = [left]\\n        else:      \\n            self.c -= self.query([left] + self.st[i:j] + [right])\\n            self.st[i:j] = []\\n\\n    def query(self, nums):       \\n        return sum(nums[i + 1] - nums[i] + 1 for i in range(0, len(nums), 2))\\n        \\n    def count(self) -> int:\\n        return self.c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042893,
                "title": "python-3-clean-binary-search-and-interval-merging-simple-and-optimized",
                "content": "The first pass at this should be something easy to read. I recommend this to start:\\n\\n```python\\nclass CountIntervals:\\n    def __init__(self):\\n        self.ct = 0\\n        self.a = []\\n        \\n    def add(self, left: int, right: int) -> None:\\n        i = bisect_left(self.a, [left, right])\\n        self.ct += self.total(left, right)\\n        self.a.insert(i, [left, right])\\n        self.merge(i)\\n        \\n    def total(self, left: int, right: int) -> int:\\n        return right - left + 1\\n        \\n    def merge(self, i: int) -> None:\\n        while not self.ok(i, i+1):\\n            self.merge_at(i)\\n        while not self.ok(i-1, i):\\n            self.merge_at(i-1)\\n            i -= 1\\n            \\n    def ok(self, i: int, j: int) -> bool:\\n        return i == -1 or j == len(self.a) or self.a[i][1] < self.a[j][0] - 1\\n    \\n    def merge_at(self, i: int) -> None:\\n        l1, r1 = self.a[i]\\n        l2, r2 = self.a[i+1]\\n        l, r = min(l1, l2), max(r1, r2)\\n        self.a[i][:] = [l, r]\\n        del self.a[i+1]\\n        self.ct += self.total(l, r) - self.total(l1, r1) - self.total(l2, r2)\\n        \\n    def count(self) -> int:\\n        return self.ct\\n```\\n\\nAfter that, we can consider optimizing the `add` function with the following in mind:\\n- The insertion step in the add function can be slow if it\\'s not adding to the end of the array due to the need for shifting other elements forward in memory.\\n- At best, we will be able to merge with one existing element. Any additional merge conflicts will still need to be resolved with an O(n) step. Therefore, we can just do a couple checks to see if the inserted range is compatible with either the entry `i` at the insertion point or the one before it, `i-1` and if so merge it in there instead.\\n\\nBelow, I\\'ve added the optional `proxy` parameter to the `merge_at` function which if passed will merge in the given range instead of the one following the provided index, and used a simple loop to do consider the indices `i-1` and `i` for merging in the add function.\\n\\n```python\\nclass CountIntervals:\\n    def __init__(self):\\n        self.ct = 0\\n        self.a = []\\n\\n    def add(self, left: int, right: int) -> None:\\n        i = bisect_left(self.a, [left, right])\\n        self.ct += self.total(left, right)\\n        for j in range(max(i-1, 0), min(i+1, len(self.a))):\\n            if range(max(left, self.a[j][0]), min(right, self.a[j][1])+1):\\n                self.merge_at(j, [left, right])\\n                self.merge(j)\\n                break\\n        else:\\n            self.a.insert(i, [left, right])\\n            self.merge(i)\\n        \\n    def total(self, left: int, right: int) -> int:\\n        return right - left + 1\\n        \\n    def merge(self, i: int) -> None:\\n        while not self.ok(i, i+1):\\n            self.merge_at(i)\\n        while not self.ok(i-1, i):\\n            self.merge_at(i-1)\\n            i -= 1\\n            \\n    def ok(self, i: int, j: int) -> bool:\\n        return i == -1 or j == len(self.a) or self.a[i][1] < self.a[j][0] - 1\\n    \\n    def merge_at(self, i: int, proxy: Optional[List[int]]=None) -> None:\\n        l1, r1 = self.a[i]\\n        l2, r2 = proxy or self.a[i+1]\\n        l, r = min(l1, l2), max(r1, r2)\\n        self.a[i][:] = [l, r]\\n        if not proxy:\\n            del self.a[i+1]\\n        self.ct += self.total(l, r) - self.total(l1, r1) - self.total(l2, r2)\\n        \\n    def count(self) -> int:\\n        return self.ct\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```python\\nclass CountIntervals:\\n    def __init__(self):\\n        self.ct = 0\\n        self.a = []\\n        \\n    def add(self, left: int, right: int) -> None:\\n        i = bisect_left(self.a, [left, right])\\n        self.ct += self.total(left, right)\\n        self.a.insert(i, [left, right])\\n        self.merge(i)\\n        \\n    def total(self, left: int, right: int) -> int:\\n        return right - left + 1\\n        \\n    def merge(self, i: int) -> None:\\n        while not self.ok(i, i+1):\\n            self.merge_at(i)\\n        while not self.ok(i-1, i):\\n            self.merge_at(i-1)\\n            i -= 1\\n            \\n    def ok(self, i: int, j: int) -> bool:\\n        return i == -1 or j == len(self.a) or self.a[i][1] < self.a[j][0] - 1\\n    \\n    def merge_at(self, i: int) -> None:\\n        l1, r1 = self.a[i]\\n        l2, r2 = self.a[i+1]\\n        l, r = min(l1, l2), max(r1, r2)\\n        self.a[i][:] = [l, r]\\n        del self.a[i+1]\\n        self.ct += self.total(l, r) - self.total(l1, r1) - self.total(l2, r2)\\n        \\n    def count(self) -> int:\\n        return self.ct\\n```\n```python\\nclass CountIntervals:\\n    def __init__(self):\\n        self.ct = 0\\n        self.a = []\\n\\n    def add(self, left: int, right: int) -> None:\\n        i = bisect_left(self.a, [left, right])\\n        self.ct += self.total(left, right)\\n        for j in range(max(i-1, 0), min(i+1, len(self.a))):\\n            if range(max(left, self.a[j][0]), min(right, self.a[j][1])+1):\\n                self.merge_at(j, [left, right])\\n                self.merge(j)\\n                break\\n        else:\\n            self.a.insert(i, [left, right])\\n            self.merge(i)\\n        \\n    def total(self, left: int, right: int) -> int:\\n        return right - left + 1\\n        \\n    def merge(self, i: int) -> None:\\n        while not self.ok(i, i+1):\\n            self.merge_at(i)\\n        while not self.ok(i-1, i):\\n            self.merge_at(i-1)\\n            i -= 1\\n            \\n    def ok(self, i: int, j: int) -> bool:\\n        return i == -1 or j == len(self.a) or self.a[i][1] < self.a[j][0] - 1\\n    \\n    def merge_at(self, i: int, proxy: Optional[List[int]]=None) -> None:\\n        l1, r1 = self.a[i]\\n        l2, r2 = proxy or self.a[i+1]\\n        l, r = min(l1, l2), max(r1, r2)\\n        self.a[i][:] = [l, r]\\n        if not proxy:\\n            del self.a[i+1]\\n        self.ct += self.total(l, r) - self.total(l1, r1) - self.total(l2, r2)\\n        \\n    def count(self) -> int:\\n        return self.ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042794,
                "title": "using-binary-search-interval-merging-in-java",
                "content": "```\\nclass CountIntervals {\\n    ArrayList<int[]> l;\\n    public int ans=0;\\n    public CountIntervals() {\\n        l=new ArrayList<>();\\n    }\\n    public int f(int e)\\n    {\\n        int low=0,high=l.size()-1,mid;\\n        while(low<=high)\\n        {\\n            mid=((high-low)/2)+low;\\n            if(l.get(mid)[0]==e) return mid;\\n            else if(e>l.get(mid)[0]) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return low;\\n    }\\n    public void add(int left, int right) {\\n        if(l.size()==0)\\n        {\\n            l.add(new int[]{left,right});\\n            ans+=(right-left+1);\\n        }\\n        else\\n        {\\n            int index=f(left);\\n            if(index-1>=0)\\n            {\\n                if(l.get(index-1)[1]>=left-1) \\n                {\\n                    ans-=(l.get(index-1)[1]-l.get(index-1)[0]+1);\\n                    l.get(index-1)[0]=Math.min(l.get(index-1)[0],left);\\n                    l.get(index-1)[1]=Math.max(l.get(index-1)[1],right);\\n                    ans+=(l.get(index-1)[1]-l.get(index-1)[0]+1);\\n                }\\n                else\\n                {\\n                   l.add(index,new int[]{left,right}); \\n                    ans+=(right-left+1);\\n                    index++;\\n                }\\n            }\\n            else\\n            {\\n                l.add(index,new int[]{left,right}); \\n                ans+=(right-left+1);\\n                    index++;\\n            }\\n            int size=l.size();\\n            \\n                while(index<size && l.get(index-1)[1]>=l.get(index)[0]-1)\\n                {\\n                    ans-=(l.get(index-1)[1]-l.get(index-1)[0]+1);\\n                    l.get(index-1)[0]=Math.min(l.get(index-1)[0],l.get(index)[0]);\\n                    l.get(index-1)[1]=Math.max(l.get(index-1)[1],l.get(index)[1]);\\n                    ans+=(l.get(index-1)[1]-l.get(index-1)[0]+1);\\n                    ans-=(l.get(index)[1]-l.get(index)[0]+1);\\n                        l.remove(index);\\n                        size--;\\n                }            \\n        }\\n    }\\n    \\n    public int count() {\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\n    ArrayList<int[]> l;\\n    public int ans=0;\\n    public CountIntervals() {\\n        l=new ArrayList<>();\\n    }\\n    public int f(int e)\\n    {\\n        int low=0,high=l.size()-1,mid;\\n        while(low<=high)\\n        {\\n            mid=((high-low)/2)+low;\\n            if(l.get(mid)[0]==e) return mid;\\n            else if(e>l.get(mid)[0]) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return low;\\n    }\\n    public void add(int left, int right) {\\n        if(l.size()==0)\\n        {\\n            l.add(new int[]{left,right});\\n            ans+=(right-left+1);\\n        }\\n        else\\n        {\\n            int index=f(left);\\n            if(index-1>=0)\\n            {\\n                if(l.get(index-1)[1]>=left-1) \\n                {\\n                    ans-=(l.get(index-1)[1]-l.get(index-1)[0]+1);\\n                    l.get(index-1)[0]=Math.min(l.get(index-1)[0],left);\\n                    l.get(index-1)[1]=Math.max(l.get(index-1)[1],right);\\n                    ans+=(l.get(index-1)[1]-l.get(index-1)[0]+1);\\n                }\\n                else\\n                {\\n                   l.add(index,new int[]{left,right}); \\n                    ans+=(right-left+1);\\n                    index++;\\n                }\\n            }\\n            else\\n            {\\n                l.add(index,new int[]{left,right}); \\n                ans+=(right-left+1);\\n                    index++;\\n            }\\n            int size=l.size();\\n            \\n                while(index<size && l.get(index-1)[1]>=l.get(index)[0]-1)\\n                {\\n                    ans-=(l.get(index-1)[1]-l.get(index-1)[0]+1);\\n                    l.get(index-1)[0]=Math.min(l.get(index-1)[0],l.get(index)[0]);\\n                    l.get(index-1)[1]=Math.max(l.get(index-1)[1],l.get(index)[1]);\\n                    ans+=(l.get(index-1)[1]-l.get(index-1)[0]+1);\\n                    ans-=(l.get(index)[1]-l.get(index)[0]+1);\\n                        l.remove(index);\\n                        size--;\\n                }            \\n        }\\n    }\\n    \\n    public int count() {\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042714,
                "title": "python3-100-speed-memory",
                "content": "Please ask any question if hard to follow.\\n\\n```\\n    def __init__(self):\\n        self.listL,self.listR = [],[]\\n        self.cnt = 0\\n\\n    def add(self, l: int, r: int) -> None:\\n        listL,listR = self.listL,self.listR\\n        if not listL:\\n            listL.append(l)\\n            listR.append(r)\\n            self.cnt = r-l+1\\n        else:\\n            i = bisect_left(listR, l-1)\\n            overlap = i<len(listL) and (listL[i]-1<=r)\\n            if not overlap:\\n                listL.insert(i,l)\\n                listR.insert(i,r)\\n                self.cnt += r-l+1\\n            else:\\n                lNew = min(l, listL[i])\\n                j = bisect_right(listL, r+1) - 1\\n                rNew = max(r, listR[j])\\n                self.cnt -= listR[i]-listL[i]+1\\n                listL[i],listR[i] = lNew,rNew\\n                self.cnt += rNew-lNew+1\\n                for ind in range(i+1,j+1):\\n                    self.cnt -= listR[i+1]-listL[i+1]+1\\n                    listL.pop(i+1)\\n                    listR.pop(i+1)\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```",
                "solutionTags": [],
                "code": "```\\n    def __init__(self):\\n        self.listL,self.listR = [],[]\\n        self.cnt = 0\\n\\n    def add(self, l: int, r: int) -> None:\\n        listL,listR = self.listL,self.listR\\n        if not listL:\\n            listL.append(l)\\n            listR.append(r)\\n            self.cnt = r-l+1\\n        else:\\n            i = bisect_left(listR, l-1)\\n            overlap = i<len(listL) and (listL[i]-1<=r)\\n            if not overlap:\\n                listL.insert(i,l)\\n                listR.insert(i,r)\\n                self.cnt += r-l+1\\n            else:\\n                lNew = min(l, listL[i])\\n                j = bisect_right(listL, r+1) - 1\\n                rNew = max(r, listR[j])\\n                self.cnt -= listR[i]-listL[i]+1\\n                listL[i],listR[i] = lNew,rNew\\n                self.cnt += rNew-lNew+1\\n                for ind in range(i+1,j+1):\\n                    self.cnt -= listR[i+1]-listL[i+1]+1\\n                    listL.pop(i+1)\\n                    listR.pop(i+1)\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2042557,
                "title": "scala-clean-solution-using-treemap",
                "content": "```\\nimport scala.annotation.tailrec\\nimport scala.collection.mutable\\n\\nclass CountIntervals {\\n  private val nonOverlapping = mutable.TreeMap.empty[Int, Int]\\n  private var integerCount   = 0\\n\\n  def add(left: Int, right: Int): Unit = {\\n    val (finalLeft, finalRight) = removeOverlap(left, right)\\n    nonOverlapping.put(finalLeft, finalRight)\\n    integerCount += finalRight - finalLeft + 1\\n  }\\n\\n  def count(): Int = integerCount\\n  \\n  @tailrec\\n  private def removeOverlap(left: Int, right: Int): (Int, Int) =\\n    nonOverlapping.maxBefore(right + 1) match {\\n      case None => (left, right)\\n      case Some((_, prevRight)) if prevRight < left => (left, right)\\n      case Some((prevLeft, prevRight)) =>\\n        integerCount -= prevRight - prevLeft + 1\\n        nonOverlapping.remove(prevLeft)\\n        removeOverlap(prevLeft.min(left), prevRight.max(right))\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.annotation.tailrec\\nimport scala.collection.mutable\\n\\nclass CountIntervals {\\n  private val nonOverlapping = mutable.TreeMap.empty[Int, Int]\\n  private var integerCount   = 0\\n\\n  def add(left: Int, right: Int): Unit = {\\n    val (finalLeft, finalRight) = removeOverlap(left, right)\\n    nonOverlapping.put(finalLeft, finalRight)\\n    integerCount += finalRight - finalLeft + 1\\n  }\\n\\n  def count(): Int = integerCount\\n  \\n  @tailrec\\n  private def removeOverlap(left: Int, right: Int): (Int, Int) =\\n    nonOverlapping.maxBefore(right + 1) match {\\n      case None => (left, right)\\n      case Some((_, prevRight)) if prevRight < left => (left, right)\\n      case Some((prevLeft, prevRight)) =>\\n        integerCount -= prevRight - prevLeft + 1\\n        nonOverlapping.remove(prevLeft)\\n        removeOverlap(prevLeft.min(left), prevRight.max(right))\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042391,
                "title": "solution-without-treemap-but-got-tle-and-passed-68-72",
                "content": "I tried to implement the code by applying the theory of merge interval in contest but manages to passed 68/72 solutions. Any way the TLE could be avoided without using TreeMap?\\n```\\n\\nclass CountIntervals {\\n\\n    List<int[]> intervals;\\n    List<int[]> result;\\n    public CountIntervals() {\\n        intervals = new ArrayList<>();\\n        result = new ArrayList<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n        result = new ArrayList<>();\\n        intervals.add(new int[]{left, right});\\n        Collections.sort(intervals, ((a,b) -> a[0] - b[0]));\\n        \\n        int start = intervals.get(0)[0];\\n        int end = intervals.get(0)[1];\\n        \\n        for (int[] interval: intervals){\\n            if (interval[0] <= end){\\n                end = Math.max(end, interval[1]);\\n            }else{\\n                result.add(new int[]{start, end});\\n                start = interval[0];\\n                end = interval[1];\\n            }\\n        }\\n        result.add(new int[]{start, end});\\n    }\\n    \\n    public int count() {\\n        int diff = 0;\\n        for (int[] temp : result){\\n            diff += temp[1] - temp[0] + 1;\\n        }\\n        return diff;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass CountIntervals {\\n\\n    List<int[]> intervals;\\n    List<int[]> result;\\n    public CountIntervals() {\\n        intervals = new ArrayList<>();\\n        result = new ArrayList<>();\\n    }\\n    \\n    public void add(int left, int right) {\\n        result = new ArrayList<>();\\n        intervals.add(new int[]{left, right});\\n        Collections.sort(intervals, ((a,b) -> a[0] - b[0]));\\n        \\n        int start = intervals.get(0)[0];\\n        int end = intervals.get(0)[1];\\n        \\n        for (int[] interval: intervals){\\n            if (interval[0] <= end){\\n                end = Math.max(end, interval[1]);\\n            }else{\\n                result.add(new int[]{start, end});\\n                start = interval[0];\\n                end = interval[1];\\n            }\\n        }\\n        result.add(new int[]{start, end});\\n    }\\n    \\n    public int count() {\\n        int diff = 0;\\n        for (int[] temp : result){\\n            diff += temp[1] - temp[0] + 1;\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042141,
                "title": "java-merge-intervals-with-treemap-o-nlogn",
                "content": "```\\nclass CountIntervals {\\n    TreeMap<Integer,Integer> intervals;\\n    int count;\\n    \\n    public CountIntervals() {\\n        intervals= new TreeMap<>();\\n        count= 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        //1. merge with *one* interval for which start<left and end>=left\\n        Map.Entry<Integer,Integer> pre= intervals.floorEntry(left-1);\\n        if(pre!=null){\\n            int preLeft= pre.getKey(), preRight= pre.getValue();\\n            if(preRight>=left){\\n                int preCount= preRight-preLeft+1;\\n                count-= preCount;\\n                intervals.remove(preLeft);\\n                left= preLeft;\\n                right= Math.max(right, preRight);\\n            }\\n        }\\n        //2. merge with *all* intervals for which start>=left and start<=right\\n        while(true){\\n            Map.Entry<Integer,Integer> suf= intervals.ceilingEntry(left);\\n            if(suf!=null){\\n                int sufLeft= suf.getKey(), sufRight= suf.getValue();\\n                if(sufLeft<=right){\\n                    int sufCount= sufRight-sufLeft+1;\\n                    count-= sufCount;\\n                    intervals.remove(sufLeft);\\n                    right= Math.max(right, sufRight);\\n                }else break;\\n            }else break;            \\n        }\\n        intervals.put(left, right);\\n        count+= right-left+1;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\n    TreeMap<Integer,Integer> intervals;\\n    int count;\\n    \\n    public CountIntervals() {\\n        intervals= new TreeMap<>();\\n        count= 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        //1. merge with *one* interval for which start<left and end>=left\\n        Map.Entry<Integer,Integer> pre= intervals.floorEntry(left-1);\\n        if(pre!=null){\\n            int preLeft= pre.getKey(), preRight= pre.getValue();\\n            if(preRight>=left){\\n                int preCount= preRight-preLeft+1;\\n                count-= preCount;\\n                intervals.remove(preLeft);\\n                left= preLeft;\\n                right= Math.max(right, preRight);\\n            }\\n        }\\n        //2. merge with *all* intervals for which start>=left and start<=right\\n        while(true){\\n            Map.Entry<Integer,Integer> suf= intervals.ceilingEntry(left);\\n            if(suf!=null){\\n                int sufLeft= suf.getKey(), sufRight= suf.getValue();\\n                if(sufLeft<=right){\\n                    int sufCount= sufRight-sufLeft+1;\\n                    count-= sufCount;\\n                    intervals.remove(sufLeft);\\n                    right= Math.max(right, sufRight);\\n                }else break;\\n            }else break;            \\n        }\\n        intervals.put(left, right);\\n        count+= right-left+1;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2041989,
                "title": "python-binary-search-and-interval-merge",
                "content": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.cnt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        ind = bisect_left(self.intervals, [left, right])\\n        maxdel = ind\\n\\t\\t# check the right side\\n        for i in range(ind, len(self.intervals)):\\n            if self.intervals[i][0] > right + 1:\\n                break\\n            right = max(right, self.intervals[i][1])\\n            maxdel = i+1\\n\\t\\t# check the left side\\n        for i in range(ind - 1, -1, -1):\\n            if self.intervals[i][1] < left - 1:\\n                break\\n            # if the new interval is entirely included in the existing one, then exit \\n            if self.intervals[i][0] <= left and self.intervals[i][1] >= right:\\n                return\\n            left = min(left, self.intervals[i][0])\\n            right = max(right, self.intervals[i][1])\\n            ind -= 1\\n        if ind == len(self.intervals):\\n            self.intervals.append([left, right])\\n            self.cnt += right - left + 1\\n        else:\\n            self.intervals[:] = self.intervals[:ind] + [[left, right]] + self.intervals[maxdel:]\\n            self.cnt = sum(r-l + 1 for l, r in self.intervals)\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        self.cnt = 0\\n\\n    def add(self, left: int, right: int) -> None:\\n        ind = bisect_left(self.intervals, [left, right])\\n        maxdel = ind\\n\\t\\t# check the right side\\n        for i in range(ind, len(self.intervals)):\\n            if self.intervals[i][0] > right + 1:\\n                break\\n            right = max(right, self.intervals[i][1])\\n            maxdel = i+1\\n\\t\\t# check the left side\\n        for i in range(ind - 1, -1, -1):\\n            if self.intervals[i][1] < left - 1:\\n                break\\n            # if the new interval is entirely included in the existing one, then exit \\n            if self.intervals[i][0] <= left and self.intervals[i][1] >= right:\\n                return\\n            left = min(left, self.intervals[i][0])\\n            right = max(right, self.intervals[i][1])\\n            ind -= 1\\n        if ind == len(self.intervals):\\n            self.intervals.append([left, right])\\n            self.cnt += right - left + 1\\n        else:\\n            self.intervals[:] = self.intervals[:ind] + [[left, right]] + self.intervals[maxdel:]\\n            self.cnt = sum(r-l + 1 for l, r in self.intervals)\\n\\n    def count(self) -> int:\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041984,
                "title": "python-3-sortedlist-binary-search-optimization-needed",
                "content": "\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.q = SortedList()\\n        self.cnt = 0\\n        \\n\\n    def add(self, left: int, right: int) -> None:\\n        if not self.q: \\n            self.q.add([left, right])\\n            self.cnt += right - left + 1\\n            return\\n        loc = bisect.bisect(self.q, [left, right])\\n        \\n        # calibrate left and right bound in case of nested intervals: add [2, 2] to [1, 3]\\n        # though left will be expanded to 1 but right will still be 2 if not calibrated\\n        left = min(left, self.q[loc][0]) if loc < len(self.q) else left\\n        right = max(right, self.q[loc-1][1]) if loc > 0 else right\\n        \\n        # expand right bound\\n        tmp = loc\\n        while tmp < len(self.q) and right >= self.q[tmp][0]:\\n            s, e= self.q.pop(tmp)\\n            self.cnt -= e - s + 1\\n            if right <= e:\\n                right = e\\n\\n        # expand left bound\\n        tmp = loc - 1\\n        while tmp >= 0 and left <= self.q[tmp][1]:\\n            s, e= self.q.pop(tmp)\\n            self.cnt -= e - s + 1\\n            if left >= s:\\n                left = s\\n            tmp -= 1\\n        self.q.add([left, right])\\n        self.cnt += right - left + 1\\n\\n    def count(self) -> int:\\n        return self.cnt",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.q = SortedList()\\n        self.cnt = 0\\n        \\n\\n    def add(self, left: int, right: int) -> None:\\n        if not self.q: \\n            self.q.add([left, right])\\n            self.cnt += right - left + 1\\n            return\\n        loc = bisect.bisect(self.q, [left, right])\\n        \\n        # calibrate left and right bound in case of nested intervals: add [2, 2] to [1, 3]\\n        # though left will be expanded to 1 but right will still be 2 if not calibrated\\n        left = min(left, self.q[loc][0]) if loc < len(self.q) else left\\n        right = max(right, self.q[loc-1][1]) if loc > 0 else right\\n        \\n        # expand right bound\\n        tmp = loc\\n        while tmp < len(self.q) and right >= self.q[tmp][0]:\\n            s, e= self.q.pop(tmp)\\n            self.cnt -= e - s + 1\\n            if right <= e:\\n                right = e\\n\\n        # expand left bound\\n        tmp = loc - 1\\n        while tmp >= 0 and left <= self.q[tmp][1]:\\n            s, e= self.q.pop(tmp)\\n            self.cnt -= e - s + 1\\n            if left >= s:\\n                left = s\\n            tmp -= 1\\n        self.q.add([left, right])\\n        self.cnt += right - left + 1\\n\\n    def count(self) -> int:\\n        return self.cnt",
                "codeTag": "Java"
            },
            {
                "id": 2041658,
                "title": "python-sorted-list-full-explanation-85-71-100",
                "content": "**Observations:**\\n1. We are counting instances where an added interval contributes to the total ranges of values. Basically this means that newly added intervals that overlap with the existing covered range of values will not fully contibute to the count of integers covered. There are two cases of overlap, partial overlap of intervals or full overlap.\\n2. By maintaining a sorted list and using binary search, we can find a position to slot in an interval in a list of intervals based on the start time of the interval in O(log(n)) time complexity with n being the total number of intervals in the collection of intervals.\\n3. By merging overlapping intervals we can reduce the memory required to store the intervals and also reduce the time required to insert a new interval into the lists of intervals.\\n4. Overlaps of an interval can occur in both the backward and forward direction and we need to account for both. However, by inserting the interval with a binary search based on start time, we essentially guarantee that we only need to look at one interval before the position of the inserted interval - assuming the list has been sorted and overlapping intervals have been merged beforehand.\\n\\n**Implementation for add()**\\n1. Initiate a (i) sorted list for storing intervals and (ii) a count for keeping track of the number of values covered by the intervals\\n2. Whenever the add() function is called, insert the interval using bisect_right \\n3. Pseudo-merge it with the interval before the insertion point if required, keeping track of integers contributed to the count and which index the interval merges up to\\n4. Continue pseudo-merging with the intervals after the insertion point as required, keeping track of integers contributed to the count and which index the interval merges up to\\n5. Replace the index range which has been merged with the newly generated merged interval.\\n6. Add the integer contribution from this newly added interval to the total count of the integers\\n\\n**Implementation for count()**\\n1. Simply call the total count of integers so far\\n\\n```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.sorted_list = []\\n        self.total_count = 0\\n   \\n    def add(self, left: int, right: int) -> None:\\n        len_list = len(self.sorted_list) #length of list of non-overlapping intervals\\n        insert_index = bisect_right(self.sorted_list, [left,right], lo=0, hi=len_list, key=None) #index where we intend to insert the new interval\\n        start_index = end_index = insert_index\\n        max_count = right - left + 1 #max number of integers which can be added by the new interval\\n\\n        if start_index-1 >= 0 and self.sorted_list[start_index-1][1] >= left: #if overlap with previous interval, subtract from max_count and track resulting start_index to be merged into the new interval\\n            earlier_left,earlier_right = self.sorted_list[start_index-1][0],self.sorted_list[start_index-1][1]\\n            if earlier_left >= left: #full overlap\\n                max_count -= earlier_right - earlier_left + 1\\n                start_index -= 1\\n            else: #partial overlap\\n                if right < earlier_right: #fully eaten up, no need to update total_count\\n                    return\\n                max_count -= earlier_right - left + 1\\n                left = earlier_left\\n                start_index -= 1\\n\\n        while end_index < len_list and self.sorted_list[end_index][0] <= right: #if overlap with subsequent intervals, subtract from max_count and track resulting end_index to be merged into the new interval\\n            next_left,next_right = self.sorted_list[end_index][0],self.sorted_list[end_index][1]\\n            if next_right <= right: \\n                max_count -= next_right - next_left + 1\\n                end_index += 1\\n            else: \\n                if left > next_left:\\n                    return\\n                max_count -= right - next_left + 1\\n                right = next_right\\n                end_index += 1\\n                break\\n\\n\\t\\t#update the overlapping intervals with the new interval\\n        new_interval = [left,right]\\n        self.sorted_list[start_index:end_index] = [new_interval] \\n\\t\\t#update the total_count with the new integer contributions from the new interval\\n        self.total_count += max_count\\n\\n        \\n    def count(self) -> int:\\n        return self.total_count\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass CountIntervals:\\n\\n    def __init__(self):\\n        self.sorted_list = []\\n        self.total_count = 0\\n   \\n    def add(self, left: int, right: int) -> None:\\n        len_list = len(self.sorted_list) #length of list of non-overlapping intervals\\n        insert_index = bisect_right(self.sorted_list, [left,right], lo=0, hi=len_list, key=None) #index where we intend to insert the new interval\\n        start_index = end_index = insert_index\\n        max_count = right - left + 1 #max number of integers which can be added by the new interval\\n\\n        if start_index-1 >= 0 and self.sorted_list[start_index-1][1] >= left: #if overlap with previous interval, subtract from max_count and track resulting start_index to be merged into the new interval\\n            earlier_left,earlier_right = self.sorted_list[start_index-1][0],self.sorted_list[start_index-1][1]\\n            if earlier_left >= left: #full overlap\\n                max_count -= earlier_right - earlier_left + 1\\n                start_index -= 1\\n            else: #partial overlap\\n                if right < earlier_right: #fully eaten up, no need to update total_count\\n                    return\\n                max_count -= earlier_right - left + 1\\n                left = earlier_left\\n                start_index -= 1\\n\\n        while end_index < len_list and self.sorted_list[end_index][0] <= right: #if overlap with subsequent intervals, subtract from max_count and track resulting end_index to be merged into the new interval\\n            next_left,next_right = self.sorted_list[end_index][0],self.sorted_list[end_index][1]\\n            if next_right <= right: \\n                max_count -= next_right - next_left + 1\\n                end_index += 1\\n            else: \\n                if left > next_left:\\n                    return\\n                max_count -= right - next_left + 1\\n                right = next_right\\n                end_index += 1\\n                break\\n\\n\\t\\t#update the overlapping intervals with the new interval\\n        new_interval = [left,right]\\n        self.sorted_list[start_index:end_index] = [new_interval] \\n\\t\\t#update the total_count with the new integer contributions from the new interval\\n        self.total_count += max_count\\n\\n        \\n    def count(self) -> int:\\n        return self.total_count\\n\\n# Your CountIntervals object will be instantiated and called as such:\\n# obj = CountIntervals()\\n# obj.add(left,right)\\n# param_2 = obj.count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041287,
                "title": "c-segment-tree",
                "content": "```\\npublic class Node {\\n\\tpublic int val;\\n\\tpublic int left;\\n\\tpublic int right;\\n\\tpublic Node ln;\\n\\tpublic Node rn;\\n\\n\\tpublic Node(int l, int r, int v) {\\n\\t\\tleft = l;\\n\\t\\tright = r;\\n\\t\\tval = v;\\n\\t}\\n\\n\\tpublic int Push(int l, int r) {\\n\\t\\tif (l <= left && right <= r) {\\n\\t\\t\\tln = null;\\n\\t\\t\\trn = null;\\n\\t\\t\\tval = right - left + 1;\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\t\\tif (right < l || r < left || left == right)\\n\\t\\t\\treturn val;\\n\\n\\t\\tint mid = (left + right) / 2;\\n\\t\\tif (ln == null)\\n\\t\\t\\tln = new Node(left, mid, val > 0 ? mid - left + 1 : 0);\\n\\n\\t\\tif (rn == null)\\n\\t\\t\\trn = new Node(mid+1, right, val > 0 ? right - mid : 0);\\n\\n\\t\\tval = ln.Push(l, r) + rn.Push(l, r);\\n\\t\\treturn val;\\n\\t}\\n}\\n\\npublic Node root;\\npublic CountIntervals() {\\n\\troot = new Node(0, 1000000000, 0);\\n}\\n\\npublic void Add(int l, int r) {\\n\\troot.Push(l, r);\\n}\\n\\npublic int Count() {\\n\\treturn this.root.val;\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\npublic class Node {\\n\\tpublic int val;\\n\\tpublic int left;\\n\\tpublic int right;\\n\\tpublic Node ln;\\n\\tpublic Node rn;\\n\\n\\tpublic Node(int l, int r, int v) {\\n\\t\\tleft = l;\\n\\t\\tright = r;\\n\\t\\tval = v;\\n\\t}\\n\\n\\tpublic int Push(int l, int r) {\\n\\t\\tif (l <= left && right <= r) {\\n\\t\\t\\tln = null;\\n\\t\\t\\trn = null;\\n\\t\\t\\tval = right - left + 1;\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\t\\tif (right < l || r < left || left == right)\\n\\t\\t\\treturn val;\\n\\n\\t\\tint mid = (left + right) / 2;\\n\\t\\tif (ln == null)\\n\\t\\t\\tln = new Node(left, mid, val > 0 ? mid - left + 1 : 0);\\n\\n\\t\\tif (rn == null)\\n\\t\\t\\trn = new Node(mid+1, right, val > 0 ? right - mid : 0);\\n\\n\\t\\tval = ln.Push(l, r) + rn.Push(l, r);\\n\\t\\treturn val;\\n\\t}\\n}\\n\\npublic Node root;\\npublic CountIntervals() {\\n\\troot = new Node(0, 1000000000, 0);\\n}\\n\\npublic void Add(int l, int r) {\\n\\troot.Push(l, r);\\n}\\n\\npublic int Count() {\\n\\treturn this.root.val;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041024,
                "title": "treemap-solution-easy-to-understand",
                "content": "```\\nclass CountIntervals {\\n\\t// all intervals not intersect\\n    map<int, int> intervals;\\n    int res = 0;\\npublic:\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = intervals.lower_bound(left); // [right, left]\\n        pair<int, int> new_interval = {right, left};\\n\\t\\t// erase all intervals intersecting with new_interval\\n        while (it != intervals.end() && it->second <= right) {\\n            new_interval.second = min(new_interval.second, it->second);\\n            new_interval.first = max(new_interval.first, it->first);\\n            res -= (it->first - it->second + 1);\\n            it = intervals.erase(it);\\n        }\\n        res += (new_interval.first - new_interval.second + 1);\\n        intervals.insert(new_interval);\\n    }\\n    \\n    int count() {\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\n\\t// all intervals not intersect\\n    map<int, int> intervals;\\n    int res = 0;\\npublic:\\n    CountIntervals() {\\n        \\n    }\\n    \\n    void add(int left, int right) {\\n        auto it = intervals.lower_bound(left); // [right, left]\\n        pair<int, int> new_interval = {right, left};\\n\\t\\t// erase all intervals intersecting with new_interval\\n        while (it != intervals.end() && it->second <= right) {\\n            new_interval.second = min(new_interval.second, it->second);\\n            new_interval.first = max(new_interval.first, it->first);\\n            res -= (it->first - it->second + 1);\\n            it = intervals.erase(it);\\n        }\\n        res += (new_interval.first - new_interval.second + 1);\\n        intervals.insert(new_interval);\\n    }\\n    \\n    int count() {\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040943,
                "title": "c-100-faster-easy-to-understand",
                "content": "```\\nclass CountIntervals {\\npublic:\\n    map<int, int> m;\\n    int cnt;\\n    CountIntervals() {\\n        m.clear();\\n        cnt=0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto ptr_l=m.upper_bound(left), ptr_r=m.upper_bound(right+1);\\n\\t\\t//if the (--ptr_l)->right is >=left, that means (--ptr_l) will also be erased\\n\\t\\t//\\u68C0\\u67E5\\u4E00\\u4E0B\\u524D\\u4E00\\u4E2Aptr\\u662F\\u4E0D\\u662F\\u6709\\u53EF\\u80FD\\u8981\\u88ABerase\\u6389\\n        if(ptr_l!=m.begin()){\\n            if((--ptr_l)->second<left)\\n                ptr_l++;\\n        }\\n\\t\\t//subtract count in the range that will be erased\\n\\t\\t//\\u51CF\\u53BB\\u9A6C\\u4E0A\\u5C31\\u8981\\u88ABerase\\u7684range\\n        for(auto ptr=ptr_l;ptr!=ptr_r;ptr++)\\n            cnt-=(ptr->second-ptr->first+1);\\n        \\n\\t\\t//check the new range, \\u68C0\\u67E5\\u65B0\\u7684\\u8303\\u56F4\\u503C\\n\\t\\t//ll is the new left bound, and rr is the new right bound\\n        int ll=left;\\n        if(ptr_l!=m.end())\\n            ll=min(ll, ptr_l->first);\\n        int rr=right;\\n        if(ptr_r!=m.begin()){\\n            ptr_r--;\\n            rr=max(rr, ptr_r->second);\\n            ptr_r++;\\n        }\\n\\t\\t\\n\\t\\t//erase keys, \\u64E6\\u53BB\\u91CD\\u5408\\u7684\\u8303\\u56F4\\n        m.erase(ptr_l, ptr_r);\\n\\t\\t//insert the new key, \\u6DFB\\u52A0\\u65B0\\u7684\\u8303\\u56F4\\n        m[ll]=rr;\\n        cnt+=(rr-ll+1);        \\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```\\nsuper easy to understand!",
                "solutionTags": [],
                "code": "```\\nclass CountIntervals {\\npublic:\\n    map<int, int> m;\\n    int cnt;\\n    CountIntervals() {\\n        m.clear();\\n        cnt=0;\\n    }\\n    \\n    void add(int left, int right) {\\n        auto ptr_l=m.upper_bound(left), ptr_r=m.upper_bound(right+1);\\n\\t\\t//if the (--ptr_l)->right is >=left, that means (--ptr_l) will also be erased\\n\\t\\t//\\u68C0\\u67E5\\u4E00\\u4E0B\\u524D\\u4E00\\u4E2Aptr\\u662F\\u4E0D\\u662F\\u6709\\u53EF\\u80FD\\u8981\\u88ABerase\\u6389\\n        if(ptr_l!=m.begin()){\\n            if((--ptr_l)->second<left)\\n                ptr_l++;\\n        }\\n\\t\\t//subtract count in the range that will be erased\\n\\t\\t//\\u51CF\\u53BB\\u9A6C\\u4E0A\\u5C31\\u8981\\u88ABerase\\u7684range\\n        for(auto ptr=ptr_l;ptr!=ptr_r;ptr++)\\n            cnt-=(ptr->second-ptr->first+1);\\n        \\n\\t\\t//check the new range, \\u68C0\\u67E5\\u65B0\\u7684\\u8303\\u56F4\\u503C\\n\\t\\t//ll is the new left bound, and rr is the new right bound\\n        int ll=left;\\n        if(ptr_l!=m.end())\\n            ll=min(ll, ptr_l->first);\\n        int rr=right;\\n        if(ptr_r!=m.begin()){\\n            ptr_r--;\\n            rr=max(rr, ptr_r->second);\\n            ptr_r++;\\n        }\\n\\t\\t\\n\\t\\t//erase keys, \\u64E6\\u53BB\\u91CD\\u5408\\u7684\\u8303\\u56F4\\n        m.erase(ptr_l, ptr_r);\\n\\t\\t//insert the new key, \\u6DFB\\u52A0\\u65B0\\u7684\\u8303\\u56F4\\n        m[ll]=rr;\\n        cnt+=(rr-ll+1);        \\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040894,
                "title": "java-treemap-clear-code",
                "content": "```\\nclass CountIntervals {\\n\\n    TreeMap<Integer, Integer> map1, map2;// map1 is left, map2 is right\\n    int size=0;\\n    public CountIntervals() {\\n        map1=new TreeMap<>();\\n        map2=new TreeMap<>();\\n        size=0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Integer leftSeg=map1.floorKey(left);\\n        Integer rightSeg=map2.ceilingKey(right);\\n        \\n        // System.out.println(leftSeg+\"      \"+rightSeg);\\n        if(leftSeg==null && rightSeg==null)\\n        {\\n            size=0;\\n            map1.clear();\\n            map2.clear();\\n            \\n            \\n            map1.put(left, right); map2.put(right, left); \\n            size+=(right-left+1);\\n        }\\n        else if(leftSeg!=null && rightSeg!=null)\\n        {\\n            int leftLimit= left, rightLimit = right;\\n            if(map1.get(leftSeg)>=left && map2.get(rightSeg)<=right)\\n            {\\n                // partial overlap bw 2 segments\\n                leftLimit = leftSeg;\\n                rightLimit = rightSeg;\\n                \\n                if(map1.get(leftSeg).equals(rightSeg))\\n                {\\n                    // single segment case\\n                    size-=(map1.get(leftSeg)-leftSeg+1);\\n                    \\n                    map2.remove(map1.get(leftSeg));\\n                    map1.remove(leftSeg);\\n                }\\n                else \\n                {\\n                    size-=(map1.get(leftSeg)-leftSeg+1);\\n                    size-=(rightSeg-map2.get(rightSeg)+1);\\n\\n                    map1.remove(map2.get(rightSeg));\\n                    map2.remove(map1.get(leftSeg));\\n                    map1.remove(leftSeg);\\n                    map2.remove(rightSeg);\\n                }\\n                \\n                \\n            }\\n            else if(map1.get(leftSeg)>=left)\\n            {\\n                // left overlap only\\n                leftLimit = leftSeg;\\n                \\n                size-=(map1.get(leftSeg)-leftSeg+1);\\n                \\n                map2.remove(map1.get(leftSeg));\\n                map1.remove(leftSeg);\\n                \\n            }\\n            else if(map2.get(rightSeg)<=right)\\n            {\\n                //right overlap only\\n                rightLimit = rightSeg;\\n                \\n                size-=(rightSeg-map2.get(rightSeg)+1);\\n                \\n                map1.remove(map2.get(rightSeg));\\n                map2.remove(rightSeg);\\n                \\n            }\\n            else \\n            {\\n                // no overlap but bw segments may exist\\n            }\\n            Integer start=map1.ceilingKey(leftLimit), end=map2.floorKey(rightLimit);\\n            while(start!=null && end!=null && map1.get(start).compareTo(end)<=0)\\n            {\\n                size-=(map1.get(start)-start+1);\\n                map2.remove(map1.get(start));\\n                map1.remove(start);\\n                \\n                start=map1.ceilingKey(start);\\n            }\\n            \\n            map1.put(leftLimit, rightLimit);\\n            map2.put(rightLimit, leftLimit);\\n            size+=(rightLimit-leftLimit+1);\\n            // remove bw segments (IMP)\\n            \\n        }\\n        else if(leftSeg==null) // right is not null\\n        {\\n            int leftLimit = left, rightLimit =right; \\n            if(map2.get(rightSeg)<=right) // right overlap\\n            {\\n                rightLimit = rightSeg;\\n                size-=(rightSeg-map2.get(rightSeg)+1);\\n                map1.remove(map2.get(rightSeg));\\n                map2.remove(rightSeg);\\n            }\\n            else // no overlap \\n            {\\n                \\n            }\\n            Integer start=map1.ceilingKey(leftLimit), end=map2.floorKey(rightLimit);\\n            while(start!=null && end!=null && map1.get(start).compareTo(end)<=0)\\n            {\\n                size-=(map1.get(start)-start+1);\\n                map2.remove(map1.get(start));\\n                map1.remove(start);\\n                start=map1.ceilingKey(start);\\n            }\\n            map1.put(leftLimit, rightLimit);\\n            map2.put(rightLimit, leftLimit);\\n            size+=(rightLimit-leftLimit+1);\\n        }\\n        else // left is not null\\n        {\\n            int leftLimit = left, rightLimit =right; \\n            if(map1.get(leftSeg)>=left) // left overlap\\n            {\\n                leftLimit = leftSeg;\\n                size-=(map1.get(leftSeg)-leftSeg+1);\\n                map2.remove(map1.get(leftSeg));\\n                map1.remove(leftSeg);\\n            }\\n            else // no overlap \\n            {\\n                \\n            }\\n            Integer start=map1.ceilingKey(leftLimit), end=map2.floorKey(rightLimit);\\n            while(start!=null && end!=null && map1.get(start).compareTo(end)<=0)\\n            {\\n                size-=(map1.get(start)-start+1);\\n                map2.remove(map1.get(start));\\n                map1.remove(start);\\n                start=map1.ceilingKey(start);\\n            }\\n            map1.put(leftLimit, rightLimit);\\n            map2.put(rightLimit, leftLimit);\\n            size+=(rightLimit-leftLimit+1);\\n        }\\n        \\n        \\n        // System.out.println(map1);\\n        // System.out.println(map2);\\n        // System.out.println(size);\\n    }\\n    \\n    public int count() {\\n        return size;\\n    }\\n}\\n\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass CountIntervals {\\n\\n    TreeMap<Integer, Integer> map1, map2;// map1 is left, map2 is right\\n    int size=0;\\n    public CountIntervals() {\\n        map1=new TreeMap<>();\\n        map2=new TreeMap<>();\\n        size=0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        Integer leftSeg=map1.floorKey(left);\\n        Integer rightSeg=map2.ceilingKey(right);\\n        \\n        // System.out.println(leftSeg+\"      \"+rightSeg);\\n        if(leftSeg==null && rightSeg==null)\\n        {\\n            size=0;\\n            map1.clear();\\n            map2.clear();\\n            \\n            \\n            map1.put(left, right); map2.put(right, left); \\n            size+=(right-left+1);\\n        }\\n        else if(leftSeg!=null && rightSeg!=null)\\n        {\\n            int leftLimit= left, rightLimit = right;\\n            if(map1.get(leftSeg)>=left && map2.get(rightSeg)<=right)\\n            {\\n                // partial overlap bw 2 segments\\n                leftLimit = leftSeg;\\n                rightLimit = rightSeg;\\n                \\n                if(map1.get(leftSeg).equals(rightSeg))\\n                {\\n                    // single segment case\\n                    size-=(map1.get(leftSeg)-leftSeg+1);\\n                    \\n                    map2.remove(map1.get(leftSeg));\\n                    map1.remove(leftSeg);\\n                }\\n                else \\n                {\\n                    size-=(map1.get(leftSeg)-leftSeg+1);\\n                    size-=(rightSeg-map2.get(rightSeg)+1);\\n\\n                    map1.remove(map2.get(rightSeg));\\n                    map2.remove(map1.get(leftSeg));\\n                    map1.remove(leftSeg);\\n                    map2.remove(rightSeg);\\n                }\\n                \\n                \\n            }\\n            else if(map1.get(leftSeg)>=left)\\n            {\\n                // left overlap only\\n                leftLimit = leftSeg;\\n                \\n                size-=(map1.get(leftSeg)-leftSeg+1);\\n                \\n                map2.remove(map1.get(leftSeg));\\n                map1.remove(leftSeg);\\n                \\n            }\\n            else if(map2.get(rightSeg)<=right)\\n            {\\n                //right overlap only\\n                rightLimit = rightSeg;\\n                \\n                size-=(rightSeg-map2.get(rightSeg)+1);\\n                \\n                map1.remove(map2.get(rightSeg));\\n                map2.remove(rightSeg);\\n                \\n            }\\n            else \\n            {\\n                // no overlap but bw segments may exist\\n            }\\n            Integer start=map1.ceilingKey(leftLimit), end=map2.floorKey(rightLimit);\\n            while(start!=null && end!=null && map1.get(start).compareTo(end)<=0)\\n            {\\n                size-=(map1.get(start)-start+1);\\n                map2.remove(map1.get(start));\\n                map1.remove(start);\\n                \\n                start=map1.ceilingKey(start);\\n            }\\n            \\n            map1.put(leftLimit, rightLimit);\\n            map2.put(rightLimit, leftLimit);\\n            size+=(rightLimit-leftLimit+1);\\n            // remove bw segments (IMP)\\n            \\n        }\\n        else if(leftSeg==null) // right is not null\\n        {\\n            int leftLimit = left, rightLimit =right; \\n            if(map2.get(rightSeg)<=right) // right overlap\\n            {\\n                rightLimit = rightSeg;\\n                size-=(rightSeg-map2.get(rightSeg)+1);\\n                map1.remove(map2.get(rightSeg));\\n                map2.remove(rightSeg);\\n            }\\n            else // no overlap \\n            {\\n                \\n            }\\n            Integer start=map1.ceilingKey(leftLimit), end=map2.floorKey(rightLimit);\\n            while(start!=null && end!=null && map1.get(start).compareTo(end)<=0)\\n            {\\n                size-=(map1.get(start)-start+1);\\n                map2.remove(map1.get(start));\\n                map1.remove(start);\\n                start=map1.ceilingKey(start);\\n            }\\n            map1.put(leftLimit, rightLimit);\\n            map2.put(rightLimit, leftLimit);\\n            size+=(rightLimit-leftLimit+1);\\n        }\\n        else // left is not null\\n        {\\n            int leftLimit = left, rightLimit =right; \\n            if(map1.get(leftSeg)>=left) // left overlap\\n            {\\n                leftLimit = leftSeg;\\n                size-=(map1.get(leftSeg)-leftSeg+1);\\n                map2.remove(map1.get(leftSeg));\\n                map1.remove(leftSeg);\\n            }\\n            else // no overlap \\n            {\\n                \\n            }\\n            Integer start=map1.ceilingKey(leftLimit), end=map2.floorKey(rightLimit);\\n            while(start!=null && end!=null && map1.get(start).compareTo(end)<=0)\\n            {\\n                size-=(map1.get(start)-start+1);\\n                map2.remove(map1.get(start));\\n                map1.remove(start);\\n                start=map1.ceilingKey(start);\\n            }\\n            map1.put(leftLimit, rightLimit);\\n            map2.put(rightLimit, leftLimit);\\n            size+=(rightLimit-leftLimit+1);\\n        }\\n        \\n        \\n        // System.out.println(map1);\\n        // System.out.println(map2);\\n        // System.out.println(size);\\n    }\\n    \\n    public int count() {\\n        return size;\\n    }\\n}\\n\\n\\n/**\\n * Your CountIntervals object will be instantiated and called as such:\\n * CountIntervals obj = new CountIntervals();\\n * obj.add(left,right);\\n * int param_2 = obj.count();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040833,
                "title": "video-explanation",
                "content": "[Video Link](https://www.youtube.com/watch?v=wjpAqxxdwf0)",
                "solutionTags": [
                    "Simulation",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "[Video Link](https://www.youtube.com/watch?v=wjpAqxxdwf0)",
                "codeTag": "Unknown"
            },
            {
                "id": 2040773,
                "title": "java-use-treemap-to-merge-overlap-intervals",
                "content": "We use a TreeMap to save non-overlapping intervals, and keep tracking of the count of integers in the TreeMap.\\nTreeMap enable us to find the closest intervals in the left and right hand side.\\nWe resolve the overlap issue in the ```add()```.\\n\\nie: \\nWhen adding [3, 11] into [2, 4], [5, 6], [7, 9], [9, 18]\\n1. in the left, [3, 11] overlaps with [2, 4]. We can remove [2, 4] (and adjust the ```cnt``` accordingly), and change the attempting one to [2, 11]\\n2. In the right, [2, 11] overlaps with [5, 6], [7, 9], [9, 18]. We can remove them all (and adjust the ```cnt``` accordingly) and and change the attempting one to [2, 18]\\n3. add [2, 18] and it\\'s cnt.\\n```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> tmap; // left, length\\n    int cnt;\\n\\n    public CountIntervals() {\\n        tmap = new TreeMap<>();\\n        cnt = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        // check the closest one in the left\\n        Integer floorKey = tmap.floorKey(left);\\n        if (floorKey != null) {\\n            // check if overlap\\n            int floorLength = tmap.get(floorKey);\\n            if (floorKey + floorLength - 1 >= right) {\\n                /*\\n\\t\\t\\t\\tcompletely covered by the existing one\\n\\t\\t\\t\\tie:  adding [3, 5] into [2, 6]\\n\\t\\t\\t\\tnot need to do anything \\n\\t\\t\\t\\t*/\\n                return;\\n            }\\n\\t\\n            if (floorKey + floorLength - 1 >= left) {\\n\\t\\t\\t/*\\n\\t\\t\\tie: adding [3, 6] to [2, 5]\\n\\t\\t\\tthen we remove existing [2, 5]\\n\\t\\t\\tand combine it into the attemping one \\n\\t\\t\\tso now we are attempting [2, 6] with no overlaping in the left side\\n\\t\\t\\t*/\\n                tmap.remove(floorKey);\\n                left = floorKey;\\n                cnt -= floorLength;\\n            }\\n        }\\n        \\n        // check the closet one in the right side\\n        Integer ceilingKey = tmap.ceilingKey(left);\\n        if (ceilingKey == null || ceilingKey > right) {\\n\\t\\t\\t/*\\n\\t\\t\\twe have not overlaping with the nearest right interval.\\n\\t\\t\\tJust add the attempted one and we are done\\n\\t\\t\\t*/\\n            tmap.put(left, right - left + 1);\\n            cnt += right - left + 1;\\n            return;\\n        }\\n        int ceilLength = tmap.get(ceilingKey);\\n        while(ceilingKey + ceilLength - 1 <= right) {\\n\\t\\t\\t/*\\n\\t\\t\\tthe closest one in the right side is completely covered by the attempted interval\\n\\t\\t\\tie: adding [3, 6] to [4, 5]\\n\\t\\t\\tthen we remove [4, 5]\\n\\t\\t\\tand check the next closest one\\n\\t\\t\\t*/\\n            tmap.remove(ceilingKey);\\n            cnt -= ceilLength;\\n            ceilingKey = tmap.ceilingKey(left);\\n            if (ceilingKey == null || ceilingKey > right) {\\n\\t\\t\\t// if no overlap, save and return\\n                tmap.put(left, right - left + 1);\\n                cnt += right - left + 1;\\n                return;\\n            }\\n            ceilLength = tmap.get(ceilingKey);\\n        }\\n\\t\\t/*\\n\\t\\twhen we reach this point, we have parcially overlap with the next one\\n\\t\\tie: adding [3, 6] into [5, 7]\\n\\t\\tthen we remove [5, 7]\\n\\t\\tand change to attampted one to [3, 7]\\n\\t\\t*/\\n        tmap.remove(ceilingKey);\\n        cnt -= ceilLength;\\n        tmap.put(left, ceilingKey + ceilLength - left);\\n        cnt += ceilingKey + ceilLength - left;\\n    }\\n    \\n    public int count() {\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```add()```\n```cnt```\n```cnt```\n```\\nclass CountIntervals {\\n    TreeMap<Integer, Integer> tmap; // left, length\\n    int cnt;\\n\\n    public CountIntervals() {\\n        tmap = new TreeMap<>();\\n        cnt = 0;\\n    }\\n    \\n    public void add(int left, int right) {\\n        // check the closest one in the left\\n        Integer floorKey = tmap.floorKey(left);\\n        if (floorKey != null) {\\n            // check if overlap\\n            int floorLength = tmap.get(floorKey);\\n            if (floorKey + floorLength - 1 >= right) {\\n                /*\\n\\t\\t\\t\\tcompletely covered by the existing one\\n\\t\\t\\t\\tie:  adding [3, 5] into [2, 6]\\n\\t\\t\\t\\tnot need to do anything \\n\\t\\t\\t\\t*/\\n                return;\\n            }\\n\\t\\n            if (floorKey + floorLength - 1 >= left) {\\n\\t\\t\\t/*\\n\\t\\t\\tie: adding [3, 6] to [2, 5]\\n\\t\\t\\tthen we remove existing [2, 5]\\n\\t\\t\\tand combine it into the attemping one \\n\\t\\t\\tso now we are attempting [2, 6] with no overlaping in the left side\\n\\t\\t\\t*/\\n                tmap.remove(floorKey);\\n                left = floorKey;\\n                cnt -= floorLength;\\n            }\\n        }\\n        \\n        // check the closet one in the right side\\n        Integer ceilingKey = tmap.ceilingKey(left);\\n        if (ceilingKey == null || ceilingKey > right) {\\n\\t\\t\\t/*\\n\\t\\t\\twe have not overlaping with the nearest right interval.\\n\\t\\t\\tJust add the attempted one and we are done\\n\\t\\t\\t*/\\n            tmap.put(left, right - left + 1);\\n            cnt += right - left + 1;\\n            return;\\n        }\\n        int ceilLength = tmap.get(ceilingKey);\\n        while(ceilingKey + ceilLength - 1 <= right) {\\n\\t\\t\\t/*\\n\\t\\t\\tthe closest one in the right side is completely covered by the attempted interval\\n\\t\\t\\tie: adding [3, 6] to [4, 5]\\n\\t\\t\\tthen we remove [4, 5]\\n\\t\\t\\tand check the next closest one\\n\\t\\t\\t*/\\n            tmap.remove(ceilingKey);\\n            cnt -= ceilLength;\\n            ceilingKey = tmap.ceilingKey(left);\\n            if (ceilingKey == null || ceilingKey > right) {\\n\\t\\t\\t// if no overlap, save and return\\n                tmap.put(left, right - left + 1);\\n                cnt += right - left + 1;\\n                return;\\n            }\\n            ceilLength = tmap.get(ceilingKey);\\n        }\\n\\t\\t/*\\n\\t\\twhen we reach this point, we have parcially overlap with the next one\\n\\t\\tie: adding [3, 6] into [5, 7]\\n\\t\\tthen we remove [5, 7]\\n\\t\\tand change to attampted one to [3, 7]\\n\\t\\t*/\\n        tmap.remove(ceilingKey);\\n        cnt -= ceilLength;\\n        tmap.put(left, ceilingKey + ceilLength - left);\\n        cnt += ceilingKey + ceilLength - left;\\n    }\\n    \\n    public int count() {\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2025961,
                "content": [
                    {
                        "username": "ashunitinholkar",
                        "content": "This question was there in Databricks OA. Please update problem list for Databricks"
                    }
                ]
            }
        ]
    },
    {
        "title": "Booking Concert Tickets in Groups",
        "question_content": "<p>A concert hall has <code>n</code> rows numbered from <code>0</code> to <code>n - 1</code>, each with <code>m</code> seats, numbered from <code>0</code> to <code>m - 1</code>. You need to design a ticketing system that can allocate seats in the following cases:</p>\n\n<ul>\n\t<li>If a group of <code>k</code> spectators can sit <strong>together</strong> in a row.</li>\n\t<li>If <strong>every</strong> member of a group of <code>k</code> spectators can get a seat. They may or <strong>may not</strong> sit together.</li>\n</ul>\n\n<p>Note that the spectators are very picky. Hence:</p>\n\n<ul>\n\t<li>They will book seats only if each member of their group can get a seat with row number <strong>less than or equal</strong> to <code>maxRow</code>. <code>maxRow</code> can <strong>vary</strong> from group to group.</li>\n\t<li>In case there are multiple rows to choose from, the row with the <strong>smallest</strong> number is chosen. If there are multiple seats to choose in the same row, the seat with the <strong>smallest</strong> number is chosen.</li>\n</ul>\n\n<p>Implement the <code>BookMyShow</code> class:</p>\n\n<ul>\n\t<li><code>BookMyShow(int n, int m)</code> Initializes the object with <code>n</code> as number of rows and <code>m</code> as number of seats per row.</li>\n\t<li><code>int[] gather(int k, int maxRow)</code> Returns an array of length <code>2</code> denoting the row and seat number (respectively) of the <strong>first seat</strong> being allocated to the <code>k</code> members of the group, who must sit <strong>together</strong>. In other words, it returns the smallest possible <code>r</code> and <code>c</code> such that all <code>[c, c + k - 1]</code> seats are valid and empty in row <code>r</code>, and <code>r &lt;= maxRow</code>. Returns <code>[]</code> in case it is <strong>not possible</strong> to allocate seats to the group.</li>\n\t<li><code>boolean scatter(int k, int maxRow)</code> Returns <code>true</code> if all <code>k</code> members of the group can be allocated seats in rows <code>0</code> to <code>maxRow</code>, who may or <strong>may not</strong> sit together. If the seats can be allocated, it allocates <code>k</code> seats to the group with the <strong>smallest</strong> row numbers, and the smallest possible seat numbers in each row. Otherwise, returns <code>false</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;BookMyShow&quot;, &quot;gather&quot;, &quot;gather&quot;, &quot;scatter&quot;, &quot;scatter&quot;]\n[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\n<strong>Output</strong>\n[null, [0, 0], [], true, false]\n\n<strong>Explanation</strong>\nBookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each \nbms.gather(4, 0); // return [0, 0]\n                  // The group books seats [0, 3] of row 0. \nbms.gather(2, 0); // return []\n                  // There is only 1 seat left in row 0,\n                  // so it is not possible to book 2 consecutive seats. \nbms.scatter(5, 1); // return True\n                   // The group books seat 4 of row 0 and seats [0, 3] of row 1. \nbms.scatter(5, 1); // return False\n                   // There is only one seat left in the hall.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m, k &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>\n\t<li>At most <code>5 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>gather</code> and <code>scatter</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2083802,
                "title": "c-segment-tree-max-sum-with-explanation",
                "content": "Gather: query & update minimum available row\\nScatter: query & update range of available rows\\n\\nGather() should find and update the maximum remaining seats of rows\\nScatter() should find and update total remaining seats of rows\\nTo do these efficiently, segment tree can be used\\nSetup a segment tree that tracks max and sum of remaining seats\\nThe query and update might be done simultaneously...\\nbut I did it separately because I was in hurry.\\n\\n```\\nclass BookMyShow {\\n    int n;\\n    int m;\\n    vector<array<long long, 2>> stree; // segment tree that tracks (max, sum) of each segment\\npublic:\\n    void build(int i, int p, int q) {\\n        if (p == q) {\\n            stree[i] = {m, m};\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i] = {m, (long long)(q-p+1)*m};\\n        build(2*i+1, p, r);\\n        build(2*i+2, r+1, q);\\n    }\\n\\n    vector<int> query_max(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return {};\\n        if (stree[i][0] < k)\\n            return {};\\n        if (p == q)\\n            return {p, (int)(m - stree[i][0])};\\n        int r = (p + q) / 2;\\n        vector<int> ret = query_max(2*i+1, p, r, k, maxRow);\\n        if (ret.size())\\n            return ret;\\n        return query_max(2*i+2, r+1, q, k, maxRow);\\n    }\\n\\n    void update_max(int i, int p, int q, int row, int k) {\\n        if (p > row || q < row)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        update_max(2*i+1, p, r, row, k);\\n        update_max(2*i+2, r+1, q, row, k);\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n    long long query_sum(int i, int p, int q, int maxRow) {\\n        if (p > maxRow)\\n            return 0;\\n        if (q <= maxRow)\\n            return stree[i][1];\\n        int r = (p + q) / 2;\\n        return query_sum(2*i+1, p, r, maxRow) + query_sum(2*i+2, r+1, q, maxRow);\\n    }\\n\\n    void update_sum(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        if (r+1 > maxRow || stree[2*i+1][1] >= k) {\\n            update_sum(2*i+1, p, r, k, maxRow);\\n        } else {\\n            k -= stree[2*i+1][1];\\n            update_sum(2*i+1, p, r, stree[2*i+1][1], maxRow);\\n            // Be aware: stree[2*i+1][1] updates while updating the left tree\\n            update_sum(2*i+2, r+1, q, k, maxRow);\\n        }\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n\\n    BookMyShow(int n_in, int m_in) {\\n        n = n_in;\\n        m = m_in;\\n\\n        int sz = 1;\\n        while (sz < n*2)\\n            sz <<= 1;\\n        stree.resize(sz);\\n\\n        build(0, 0, n-1);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        // cout << \"gather \" << k << \" \" << maxRow << endl;\\n        vector<int> ret = query_max(0, 0, n-1, k, maxRow);\\n        if (ret.size())\\n            update_max(0, 0, n-1, ret[0], k);\\n        return ret;\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        // cout << \"scatter \" << k << \" \" << maxRow << endl;\\n        long long cnt = query_sum(0, 0, n-1, maxRow);\\n        bool ret = cnt >= k;\\n        if (ret)\\n            update_sum(0, 0, n-1, k, maxRow);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass BookMyShow {\\n    int n;\\n    int m;\\n    vector<array<long long, 2>> stree; // segment tree that tracks (max, sum) of each segment\\npublic:\\n    void build(int i, int p, int q) {\\n        if (p == q) {\\n            stree[i] = {m, m};\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i] = {m, (long long)(q-p+1)*m};\\n        build(2*i+1, p, r);\\n        build(2*i+2, r+1, q);\\n    }\\n\\n    vector<int> query_max(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return {};\\n        if (stree[i][0] < k)\\n            return {};\\n        if (p == q)\\n            return {p, (int)(m - stree[i][0])};\\n        int r = (p + q) / 2;\\n        vector<int> ret = query_max(2*i+1, p, r, k, maxRow);\\n        if (ret.size())\\n            return ret;\\n        return query_max(2*i+2, r+1, q, k, maxRow);\\n    }\\n\\n    void update_max(int i, int p, int q, int row, int k) {\\n        if (p > row || q < row)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        update_max(2*i+1, p, r, row, k);\\n        update_max(2*i+2, r+1, q, row, k);\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n    long long query_sum(int i, int p, int q, int maxRow) {\\n        if (p > maxRow)\\n            return 0;\\n        if (q <= maxRow)\\n            return stree[i][1];\\n        int r = (p + q) / 2;\\n        return query_sum(2*i+1, p, r, maxRow) + query_sum(2*i+2, r+1, q, maxRow);\\n    }\\n\\n    void update_sum(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        if (r+1 > maxRow || stree[2*i+1][1] >= k) {\\n            update_sum(2*i+1, p, r, k, maxRow);\\n        } else {\\n            k -= stree[2*i+1][1];\\n            update_sum(2*i+1, p, r, stree[2*i+1][1], maxRow);\\n            // Be aware: stree[2*i+1][1] updates while updating the left tree\\n            update_sum(2*i+2, r+1, q, k, maxRow);\\n        }\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n\\n    BookMyShow(int n_in, int m_in) {\\n        n = n_in;\\n        m = m_in;\\n\\n        int sz = 1;\\n        while (sz < n*2)\\n            sz <<= 1;\\n        stree.resize(sz);\\n\\n        build(0, 0, n-1);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        // cout << \"gather \" << k << \" \" << maxRow << endl;\\n        vector<int> ret = query_max(0, 0, n-1, k, maxRow);\\n        if (ret.size())\\n            update_max(0, 0, n-1, ret[0], k);\\n        return ret;\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        // cout << \"scatter \" << k << \" \" << maxRow << endl;\\n        long long cnt = query_sum(0, 0, n-1, maxRow);\\n        bool ret = cnt >= k;\\n        if (ret)\\n            update_sum(0, 0, n-1, k, maxRow);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2083758,
                "title": "segment-tree-vs-bit",
                "content": "I misread the description (again), and tried to solve a more complex problem when we pack folks optimally to accommodate maximum guests. Ugh...\\n\\n**Scatter**\\nFor the `scatter` function, we need to pack rows one-by-one, starting from zero. As soons as a row is full, we increment `start`, so that we skip all full rows next time.\\n\\nBut first, we need to know if we have enough seats `[0,  maxRow]` rows. We can either use BIT or segment tree to query and update number of seats in O(log n).\\n\\nThe complexity of `k` operations would be O(k log n).\\n\\n**Gather**\\nWe need a way to quickly find the first row that can fit `k` people. We cannot use BIT for that. We can track prefix maximum using a segment tree, and find the first row with enough seats in O(log n).\\n\\n> Note that BIT solution (approach 2) is accepted but it\\'s slow - with some probability of TLE. Without segment tree, the complexity of each `gather` operation is O(n).\\n\\n#### Approach 1: Segment Tree\\n\\n**C++**\\n```cpp\\nclass BookMyShow {\\npublic:\\nvector<pair<long long, int>> st;\\nint g[50001] = {}, n = 0, m = 0, start = 0;\\nlong long query(int tl, int tr, int l, int r, int p = 1) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr)\\n        return st[p].first;\\n    int tm = (tl + tr) / 2;\\n    return query(tl, tm, l, min(r, tm), p * 2) + query(tm + 1, tr, max(l, tm + 1), r, p * 2 + 1);\\n}\\nint get_first_ge(int lv, int rv, int x, int p = 1) {\\n    if (st[p].second < x)\\n        return -1;\\n    while (lv != rv) {\\n        int mid = lv + (rv - lv) / 2;\\n        if (st[2 * p].second >= x) {\\n            p *= 2;\\n            rv = mid;\\n        } else {\\n            p =  2 * p + 1;\\n            lv = mid + 1;\\n        }\\n    }\\n    return lv;\\n}\\nvoid update(int tl, int tr, int pos, int new_val, int p = 1) {\\n    if (tl == tr)\\n        st[p] = {new_val, m - new_val};\\n    else {\\n        int tm = (tl + tr) / 2;\\n        if (pos <= tm)\\n            update(tl, tm, pos, new_val, p * 2);\\n        else\\n            update(tm + 1, tr, pos, new_val, p * 2 + 1);\\n        st[p] = {st[p * 2].first + st[p * 2 + 1].first, max(st[p * 2].second, st[p * 2 + 1].second)};\\n    }\\n}\\nBookMyShow(int n, int m) : n(n), m(m) {\\n    st = vector<pair<long long, int>>(n * 4, {0, m});\\n}\\nvector<int> gather(int k, int maxRow) {\\n    int i = get_first_ge(0, n - 1, k);\\n    if (i < 0 || i > maxRow)\\n        return {};\\n    g[i] += k;\\n    update(0, n - 1, i, g[i]);\\n    return {i, g[i] - k};\\n}\\nbool scatter(int k, int maxRow) {\\n    if (query(0, n - 1, 0, maxRow) + k > ((long long)maxRow + 1) * m)\\n        return false;\\n    for (int i = start; k && i <= maxRow; ++i) {\\n        if (m - g[i]) {\\n            int take = min(m - g[i], k);\\n            k -= take;\\n            g[i] += take;\\n            update(0, n - 1, i, g[i]);\\n        }\\n        else\\n           start = i + 1; \\n    }\\n    return true;\\n}\\n};\\n```\\n\\n#### Approach 2: BIT\\nSlow, but accepted. We go from `0` to `maxRow` one-by-one, trying to sit our guests. To speed this up, I am using BIT (mutable prefix sum) to quickly check if we have enough seats.\\n\\n**C++**\\n```cpp\\nconstexpr int static max_n = 50001;\\nlong long bt[max_n + 1] = {};\\nlong long prefix_sum(int i)\\n{\\n    long long sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= max_n; i += i & (-i))\\n        bt[i] += val;\\n}  \\nint g[50001] = {}, n = 0, m = 0, start = 0;\\nBookMyShow(int n, int m) : n(n), m(m) { }\\nvector<int> gather(int k, int maxRow) {\\n    long long total = prefix_sum(maxRow);\\n    if (total + k > ((long long)maxRow + 1) * m)\\n        return {};\\n    for (int i = start; i <= maxRow; ++i) {\\n        if (g[i] + k > m)\\n            continue;\\n        g[i] += k;\\n        add(i, k);\\n        return {i, g[i] - k};\\n    }\\n    return {};\\n}\\nbool scatter(int k, int maxRow) {\\n    long long total = prefix_sum(maxRow);\\n    if (total + k > ((long long)maxRow + 1) * m)\\n        return false;\\n    for (int i = start; k && i <= maxRow; ++i) {\\n        if (m - g[i]) {\\n            int take = min(m - g[i], k);\\n            k -= take;\\n            add(i, take);\\n            g[i] += take;\\n        }\\n        else\\n           start = i + 1; \\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass BookMyShow {\\npublic:\\nvector<pair<long long, int>> st;\\nint g[50001] = {}, n = 0, m = 0, start = 0;\\nlong long query(int tl, int tr, int l, int r, int p = 1) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr)\\n        return st[p].first;\\n    int tm = (tl + tr) / 2;\\n    return query(tl, tm, l, min(r, tm), p * 2) + query(tm + 1, tr, max(l, tm + 1), r, p * 2 + 1);\\n}\\nint get_first_ge(int lv, int rv, int x, int p = 1) {\\n    if (st[p].second < x)\\n        return -1;\\n    while (lv != rv) {\\n        int mid = lv + (rv - lv) / 2;\\n        if (st[2 * p].second >= x) {\\n            p *= 2;\\n            rv = mid;\\n        } else {\\n            p =  2 * p + 1;\\n            lv = mid + 1;\\n        }\\n    }\\n    return lv;\\n}\\nvoid update(int tl, int tr, int pos, int new_val, int p = 1) {\\n    if (tl == tr)\\n        st[p] = {new_val, m - new_val};\\n    else {\\n        int tm = (tl + tr) / 2;\\n        if (pos <= tm)\\n            update(tl, tm, pos, new_val, p * 2);\\n        else\\n            update(tm + 1, tr, pos, new_val, p * 2 + 1);\\n        st[p] = {st[p * 2].first + st[p * 2 + 1].first, max(st[p * 2].second, st[p * 2 + 1].second)};\\n    }\\n}\\nBookMyShow(int n, int m) : n(n), m(m) {\\n    st = vector<pair<long long, int>>(n * 4, {0, m});\\n}\\nvector<int> gather(int k, int maxRow) {\\n    int i = get_first_ge(0, n - 1, k);\\n    if (i < 0 || i > maxRow)\\n        return {};\\n    g[i] += k;\\n    update(0, n - 1, i, g[i]);\\n    return {i, g[i] - k};\\n}\\nbool scatter(int k, int maxRow) {\\n    if (query(0, n - 1, 0, maxRow) + k > ((long long)maxRow + 1) * m)\\n        return false;\\n    for (int i = start; k && i <= maxRow; ++i) {\\n        if (m - g[i]) {\\n            int take = min(m - g[i], k);\\n            k -= take;\\n            g[i] += take;\\n            update(0, n - 1, i, g[i]);\\n        }\\n        else\\n           start = i + 1; \\n    }\\n    return true;\\n}\\n};\\n```\n```cpp\\nconstexpr int static max_n = 50001;\\nlong long bt[max_n + 1] = {};\\nlong long prefix_sum(int i)\\n{\\n    long long sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= max_n; i += i & (-i))\\n        bt[i] += val;\\n}  \\nint g[50001] = {}, n = 0, m = 0, start = 0;\\nBookMyShow(int n, int m) : n(n), m(m) { }\\nvector<int> gather(int k, int maxRow) {\\n    long long total = prefix_sum(maxRow);\\n    if (total + k > ((long long)maxRow + 1) * m)\\n        return {};\\n    for (int i = start; i <= maxRow; ++i) {\\n        if (g[i] + k > m)\\n            continue;\\n        g[i] += k;\\n        add(i, k);\\n        return {i, g[i] - k};\\n    }\\n    return {};\\n}\\nbool scatter(int k, int maxRow) {\\n    long long total = prefix_sum(maxRow);\\n    if (total + k > ((long long)maxRow + 1) * m)\\n        return false;\\n    for (int i = start; k && i <= maxRow; ++i) {\\n        if (m - g[i]) {\\n            int take = min(m - g[i], k);\\n            k -= take;\\n            add(i, take);\\n            g[i] += take;\\n        }\\n        else\\n           start = i + 1; \\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085084,
                "title": "python-segment-tree-range-sum-max-with-explanation",
                "content": "**Explanation**\\nWe build a segment tree to maintain the range max and range sum info.\\n\\nThe range max info is used to implement the gather function and the range sum info is used to implement the scatter function.\\n\\nThe tricky part for this problem is to understand that ***Range Max Info*** can be use to find the smallest index of a certain node (num) whose value (remain seats) is >= k. \\n1. To find the smallest index, we try the left subtree whenever possible.\\n2. To satisfy the condition val >= k, we check if the Range Max >= k.\\n\\nFor the while loop in the scatter function, the reason why we can use a while loop there and still have a decent time complexity: **each row can only be used up once**. So overall the time complexity is O((n + number of queries) * log n) for the scatter function.\\n\\n```\\nclass Node:\\n    def __init__(self, start, end):\\n        self.s = start\\n        self.e = end\\n        self.left = None\\n        self.right = None\\n        self.total = 0 # for range sum query\\n        self.mx = 0 # for range max query\\n        \\nclass SegTree:\\n    def __init__(self, start, end, val):\\n        \\n        def build(l, r):\\n            if l > r:\\n                return None\\n            if l == r:\\n                node = Node(l, r)\\n                node.total = val\\n                node.mx = val\\n                return node\\n            node = Node(l, r)\\n            m = (l + r) // 2\\n            node.left = build(l, m)\\n            node.right = build(m+1, r)\\n            node.mx = max(node.left.mx, node.right.mx)\\n            node.total = node.left.total + node.right.total\\n            return node\\n        \\n        self.root = build(start, end)\\n    \\n\\t# update the total remain seats and the max remain seats for each node (range) in the segment tree\\n    def update(self, index, val):\\n        \\n        def updateHelper(node):\\n            if node.s == node.e == index:\\n                node.total -= val\\n                node.mx -= val\\n                return\\n            m = (node.s + node.e) // 2\\n            if index <= m:\\n                updateHelper(node.left)\\n            elif index > m:\\n                updateHelper(node.right)\\n            node.mx = max(node.left.mx, node.right.mx)\\n            node.total = node.left.total + node.right.total\\n            return\\n            \\n        updateHelper(self.root)\\n        \\n    def maxQuery(self, k, maxRow, seats):\\n        \\n        def queryHelper(node):\\n            if node.s == node.e:\\n\\t\\t\\t\\t# check if the row number is less than maxRow and the number of remains seats is greater or equal than k\\n                if node.e > maxRow or node.total < k:\\n                    return []\\n                if node.e <= maxRow and node.total >= k:\\n                    return [node.e, seats - node.total]\\n\\t\\t\\t# we want to greedily search the left subtree to get the smallest row which has enough remain seats\\n            if node.left.mx >= k:\\n                return queryHelper(node.left)\\n            return queryHelper(node.right)\\n        \\n        return queryHelper(self.root)\\n                \\n    def sumQuery(self, endRow):\\n        \\n        def queryHelper(node, left, right):\\n            if left <= node.s and node.e <= right:\\n                return node.total\\n            m = (node.s + node.e) // 2\\n            if right <= m:\\n                return queryHelper(node.left, left, right)\\n            elif left > m:\\n                return queryHelper(node.right, left, right)\\n            return queryHelper(node.left, left, m) + queryHelper(node.right, m+1, right)\\n        \\n        return queryHelper(self.root, 0, endRow)\\n    \\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m = m\\n        self.seg = SegTree(0, n-1, m)\\n\\t\\t# record the remain seats at each row\\n        self.seats = [m] * n\\n\\t\\t# record the index of the smallest row that has remain seats > 0\\n        self.startRow = 0\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        res = self.seg.maxQuery(k, maxRow, self.m)\\n        if res:\\n            row = res[0]\\n            self.seg.update(row, k)\\n            self.seats[row] -= k\\n        return res\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.seg.sumQuery(maxRow) < k:\\n            return False\\n        else:\\n            i = self.startRow\\n            total = 0\\n            while total < k:\\n                prevTotal = total\\n                total += self.seats[i]\\n                if total < k:\\n\\t\\t\\t\\t\\t# use up all the seats at ith row\\n                    self.seg.update(i, self.seats[i])\\n                    self.seats[i] = 0\\n                    i += 1\\n                    self.startRow = i\\n                elif total >= k:\\n\\t\\t\\t\\t\\t# occupy (k - prevTotal) seats at ith row\\n                    self.seg.update(i, k - prevTotal)\\n                    self.seats[i] -= k - prevTotal\\n            return True\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, start, end):\\n        self.s = start\\n        self.e = end\\n        self.left = None\\n        self.right = None\\n        self.total = 0 # for range sum query\\n        self.mx = 0 # for range max query\\n        \\nclass SegTree:\\n    def __init__(self, start, end, val):\\n        \\n        def build(l, r):\\n            if l > r:\\n                return None\\n            if l == r:\\n                node = Node(l, r)\\n                node.total = val\\n                node.mx = val\\n                return node\\n            node = Node(l, r)\\n            m = (l + r) // 2\\n            node.left = build(l, m)\\n            node.right = build(m+1, r)\\n            node.mx = max(node.left.mx, node.right.mx)\\n            node.total = node.left.total + node.right.total\\n            return node\\n        \\n        self.root = build(start, end)\\n    \\n\\t# update the total remain seats and the max remain seats for each node (range) in the segment tree\\n    def update(self, index, val):\\n        \\n        def updateHelper(node):\\n            if node.s == node.e == index:\\n                node.total -= val\\n                node.mx -= val\\n                return\\n            m = (node.s + node.e) // 2\\n            if index <= m:\\n                updateHelper(node.left)\\n            elif index > m:\\n                updateHelper(node.right)\\n            node.mx = max(node.left.mx, node.right.mx)\\n            node.total = node.left.total + node.right.total\\n            return\\n            \\n        updateHelper(self.root)\\n        \\n    def maxQuery(self, k, maxRow, seats):\\n        \\n        def queryHelper(node):\\n            if node.s == node.e:\\n\\t\\t\\t\\t# check if the row number is less than maxRow and the number of remains seats is greater or equal than k\\n                if node.e > maxRow or node.total < k:\\n                    return []\\n                if node.e <= maxRow and node.total >= k:\\n                    return [node.e, seats - node.total]\\n\\t\\t\\t# we want to greedily search the left subtree to get the smallest row which has enough remain seats\\n            if node.left.mx >= k:\\n                return queryHelper(node.left)\\n            return queryHelper(node.right)\\n        \\n        return queryHelper(self.root)\\n                \\n    def sumQuery(self, endRow):\\n        \\n        def queryHelper(node, left, right):\\n            if left <= node.s and node.e <= right:\\n                return node.total\\n            m = (node.s + node.e) // 2\\n            if right <= m:\\n                return queryHelper(node.left, left, right)\\n            elif left > m:\\n                return queryHelper(node.right, left, right)\\n            return queryHelper(node.left, left, m) + queryHelper(node.right, m+1, right)\\n        \\n        return queryHelper(self.root, 0, endRow)\\n    \\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m = m\\n        self.seg = SegTree(0, n-1, m)\\n\\t\\t# record the remain seats at each row\\n        self.seats = [m] * n\\n\\t\\t# record the index of the smallest row that has remain seats > 0\\n        self.startRow = 0\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        res = self.seg.maxQuery(k, maxRow, self.m)\\n        if res:\\n            row = res[0]\\n            self.seg.update(row, k)\\n            self.seats[row] -= k\\n        return res\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.seg.sumQuery(maxRow) < k:\\n            return False\\n        else:\\n            i = self.startRow\\n            total = 0\\n            while total < k:\\n                prevTotal = total\\n                total += self.seats[i]\\n                if total < k:\\n\\t\\t\\t\\t\\t# use up all the seats at ith row\\n                    self.seg.update(i, self.seats[i])\\n                    self.seats[i] = 0\\n                    i += 1\\n                    self.startRow = i\\n                elif total >= k:\\n\\t\\t\\t\\t\\t# occupy (k - prevTotal) seats at ith row\\n                    self.seg.update(i, k - prevTotal)\\n                    self.seats[i] -= k - prevTotal\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084271,
                "title": "c-real-solution-correct-amortized-analysis",
                "content": "I have seen many solutions with O(QN) complexity getting accepted. I also see many solutions claiming O(log N) when it\\'s actually O(log^2(N)). There is also a true O(log N) solution with similar approach, but here I\\'ll show you the most straightforward O(log^2(N)) solution:\\n\\nFirst of all, we will store the remaining seats at each row in an array of integers, `A`.\\n`A[i] = ` # of remaining seats at row i.\\n\\nFor `gather(k, maxRow)`, we need to find the minimum row in the range [0, maxRow] such that it\\'s remaining seats is >= k. We can query the prefix max of `A` using a Segment Tree. We can then binary search for the minimum valid row. Its complexity is O(log^2(N)), since the binary search predicate takes O(log(N)) time to evaluate.\\n\\nFor `scatter(k, maxRow)`, we need to determine if there are a total of k seats available in rows [0, maxRow]. To determine this, we just need a range sum query on [0, maxRow]. If the sum is <= k, we return false. This range sum query takes time O(log N). \\n\\nOtherwise, we use a **monotonic** pointer `j` to take up seats greedily. Since seats are never given back once they\\'re reserved, we don\\'t have to check any rows that have already filled up. This means, we can just keep a single pointer `j`, that represents the first row which still has available seats. Then, in the worst case, `j` will advance all the way to `N` across all the calls. This means that in the worst case, the total cost we incur from `scatter` is `N log N` no matter how many calls we make to it.\\n\\n```cpp\\nusing ll = int64_t;\\nconst ll inf = 1e18+5;\\n\\ntemplate <class X, X (*op)(X, X)>\\nstruct SegTree {\\n    int N;\\n    X BASE;\\n    vector<X> T;\\n    void build(int v, int tl, int tr, vector<X> &A) {\\n        // v: tree index, tl/tr: tree bounds\\n        if (tl == tr) T[v] = A[tl];\\n        else {\\n            int mid = (tl + tr) / 2;\\n            build(v*2, tl, mid, A);\\n            build(v*2+1, mid+1, tr, A);\\n            T[v] = op(T[v*2], T[v*2+1]);\\n        }\\n    }\\n    X query(int al, int ar) { return query(al, ar, 1, 0, N-1); }\\n    X query(int al, int ar, int v, int tl, int tr) {\\n        // al/ar: arr bounds\\n        if (al > ar) return BASE;\\n        if (al == tl && ar == tr) return T[v];\\n        int mid = (tl + tr) / 2;\\n        X ql = query(al, min(ar, mid), v*2, tl, mid);\\n        X qr = query(max(al, mid+1), ar, v*2+1, mid+1, tr);\\n        return op(ql, qr);\\n    }\\n    void update(int i, X val) { update(i, val, 1, 0, N-1); }\\n    void update(int i, X val, int v, int tl, int tr) {\\n        // i: arr index, val: new value\\n        if (tl == tr) T[v] = val;\\n        else {\\n            int mid = (tl + tr) / 2;\\n            if (i <= mid) update(i, val, v*2, tl, mid);\\n            else update(i, val, v*2+1, mid+1, tr);\\n            T[v] = op(T[v*2], T[v*2+1]);  // adjust\\n        }\\n    }\\n    void init(vector<X>& a, X base) {\\n        N = a.size();\\n        T.assign(4*N, base);\\n        BASE = base;\\n        build(1, 0, N-1, a);\\n    }\\n};\\n\\nll fmax(ll x, ll y) { return max(x,y); }\\nll fsum(ll x, ll y) { return   x + y;  }\\n\\nclass BookMyShow {\\npublic:\\n    int n, m;\\n    int j = 0;  // MONOTONIC pointer, only advances forward. \\n    vector<ll> A;\\n    SegTree<ll, fmax> mx;\\n    SegTree<ll, fsum> sum;\\n\\n    BookMyShow(int n, int m) : n(n), m(m) {\\n        A.assign(n, m);\\n        sum.init(A, 0);\\n        mx.init(A, -inf);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        int l = 0, r = maxRow+1;\\n        while (l < r) {\\n            int m = (l+r) >> 1;\\n            int mn = mx.query(0,m);\\n            if (mn >= k) r = m;\\n            else l = m+1;\\n        }\\n        if (l > maxRow) return {};\\n        r = m - A[l];\\n        A[l] -= k;\\n        sum.update(l, A[l]);\\n        mx.update(l, A[l]);\\n        return {l,r};\\n    }\\n\\n    bool scatter(ll k, int maxRow) {\\n        ll s = sum.query(0,maxRow);\\n        if (s < k) return false;\\n        while (j < n && k) {\\n            int dx = min(k, A[j]);\\n            A[j] -= dx;\\n            sum.update(j, A[j]);\\n            mx.update(j, A[j]);\\n            k -= dx;\\n            if (!A[j]) ++j;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```cpp\\nusing ll = int64_t;\\nconst ll inf = 1e18+5;\\n\\ntemplate <class X, X (*op)(X, X)>\\nstruct SegTree {\\n    int N;\\n    X BASE;\\n    vector<X> T;\\n    void build(int v, int tl, int tr, vector<X> &A) {\\n        // v: tree index, tl/tr: tree bounds\\n        if (tl == tr) T[v] = A[tl];\\n        else {\\n            int mid = (tl + tr) / 2;\\n            build(v*2, tl, mid, A);\\n            build(v*2+1, mid+1, tr, A);\\n            T[v] = op(T[v*2], T[v*2+1]);\\n        }\\n    }\\n    X query(int al, int ar) { return query(al, ar, 1, 0, N-1); }\\n    X query(int al, int ar, int v, int tl, int tr) {\\n        // al/ar: arr bounds\\n        if (al > ar) return BASE;\\n        if (al == tl && ar == tr) return T[v];\\n        int mid = (tl + tr) / 2;\\n        X ql = query(al, min(ar, mid), v*2, tl, mid);\\n        X qr = query(max(al, mid+1), ar, v*2+1, mid+1, tr);\\n        return op(ql, qr);\\n    }\\n    void update(int i, X val) { update(i, val, 1, 0, N-1); }\\n    void update(int i, X val, int v, int tl, int tr) {\\n        // i: arr index, val: new value\\n        if (tl == tr) T[v] = val;\\n        else {\\n            int mid = (tl + tr) / 2;\\n            if (i <= mid) update(i, val, v*2, tl, mid);\\n            else update(i, val, v*2+1, mid+1, tr);\\n            T[v] = op(T[v*2], T[v*2+1]);  // adjust\\n        }\\n    }\\n    void init(vector<X>& a, X base) {\\n        N = a.size();\\n        T.assign(4*N, base);\\n        BASE = base;\\n        build(1, 0, N-1, a);\\n    }\\n};\\n\\nll fmax(ll x, ll y) { return max(x,y); }\\nll fsum(ll x, ll y) { return   x + y;  }\\n\\nclass BookMyShow {\\npublic:\\n    int n, m;\\n    int j = 0;  // MONOTONIC pointer, only advances forward. \\n    vector<ll> A;\\n    SegTree<ll, fmax> mx;\\n    SegTree<ll, fsum> sum;\\n\\n    BookMyShow(int n, int m) : n(n), m(m) {\\n        A.assign(n, m);\\n        sum.init(A, 0);\\n        mx.init(A, -inf);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        int l = 0, r = maxRow+1;\\n        while (l < r) {\\n            int m = (l+r) >> 1;\\n            int mn = mx.query(0,m);\\n            if (mn >= k) r = m;\\n            else l = m+1;\\n        }\\n        if (l > maxRow) return {};\\n        r = m - A[l];\\n        A[l] -= k;\\n        sum.update(l, A[l]);\\n        mx.update(l, A[l]);\\n        return {l,r};\\n    }\\n\\n    bool scatter(ll k, int maxRow) {\\n        ll s = sum.query(0,maxRow);\\n        if (s < k) return false;\\n        while (j < n && k) {\\n            int dx = min(k, A[j]);\\n            A[j] -= dx;\\n            sum.update(j, A[j]);\\n            mx.update(j, A[j]);\\n            k -= dx;\\n            if (!A[j]) ++j;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084171,
                "title": "python-segment-tree-to-query-sum-and-lowest-index",
                "content": "it tooks me 1h to write the code and got accept by one submit.\\nwe need to prepare a  template for such question in contest.\\n```\\nclass SegmentTree():\\n    def __init__(self, l, r):\\n        self.val = 0\\n        self.mid = (l + r) // 2\\n        self.l = l\\n        self.r = r\\n        self.left, self.right = None, None\\n        self.max = 0\\n        self.sums = 0\\n        if l != r:\\n            self.left = SegmentTree(l, self.mid)\\n            self.right = SegmentTree(self.mid + 1, r)\\n\\n    def update(self, l, r, val=1):\\n        if self.l >= l and self.r <= r:\\n            self.val += val\\n            self.max += val\\n            self.sums += val*(self.r-self.l+1)\\n            return\\n        if self.l > r or self.r < l:\\n            return\\n\\n        self.left.update(l, r, val)\\n        self.right.update(l, r, val)\\n        self.max = self.val + max(self.left.max, self.right.max)\\n        self.sums = self.val*(self.r-self.l+1)+self.left.sums+self.right.sums\\n\\n    def query(self, i):\\n        if self.l == self.r and self.l == i:\\n            return self.val\\n        if i < self.l or i > self.r:\\n            return 0\\n        if i <= self.mid:\\n            return self.val + self.left.query(i)\\n        return self.val + self.right.query(i)\\n    \\n    def querySum(self,l,r):\\n        #return sum value in range [l,r]\\n        if self.l >= l and self.r <= r:\\n            return self.sums\\n        if self.l > r or self.r < l:\\n            return 0\\n        return self.val*(min(r,self.r)-max(l,self.l)+1)+self.left.querySum(l,r)+self.right.querySum(l,r)\\n\\n    def queryLowestGreater(self,v):\\n        #return the smallest row that remain seats greater than v\\n        if self.max<v:\\n            return -1\\n        if self.l == self.r:\\n            return -1 if self.max<v else self.l\\n        if self.left.max >= v-self.val:\\n            return self.left.queryLowestGreater(v-self.val)\\n        return self.right.queryLowestGreater(v-self.val)\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.st = SegmentTree(0,n-1)\\n        self.st.update(0,n-1,m)\\n        self.m = m\\n        self.k = 0\\n        self.n = n\\n\\n\\n    def gather(self, k: int, maxRow: int):\\n        i = self.st.queryLowestGreater(k)\\n        if i<0 or i>maxRow:\\n            return []\\n        v = self.st.query(i)\\n        self.st.update(i,i,-k)\\n        return [i,self.m-v]\\n\\n    def scatter(self, k: int, maxRow: int):\\n        # if sum 0_maxRow greater than k,it\\'s possible to book\\n        if self.st.querySum(0,maxRow)>=k:\\n            #book seats from lowest row\\n            while self.k<self.n and k>0:\\n                v = self.st.query(self.k)\\n                self.st.update(self.k,self.k,-min(v,k))\\n                if v>k:\\n                    break\\n                else:\\n                    k -= v\\n                    self.k += 1\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree():\\n    def __init__(self, l, r):\\n        self.val = 0\\n        self.mid = (l + r) // 2\\n        self.l = l\\n        self.r = r\\n        self.left, self.right = None, None\\n        self.max = 0\\n        self.sums = 0\\n        if l != r:\\n            self.left = SegmentTree(l, self.mid)\\n            self.right = SegmentTree(self.mid + 1, r)\\n\\n    def update(self, l, r, val=1):\\n        if self.l >= l and self.r <= r:\\n            self.val += val\\n            self.max += val\\n            self.sums += val*(self.r-self.l+1)\\n            return\\n        if self.l > r or self.r < l:\\n            return\\n\\n        self.left.update(l, r, val)\\n        self.right.update(l, r, val)\\n        self.max = self.val + max(self.left.max, self.right.max)\\n        self.sums = self.val*(self.r-self.l+1)+self.left.sums+self.right.sums\\n\\n    def query(self, i):\\n        if self.l == self.r and self.l == i:\\n            return self.val\\n        if i < self.l or i > self.r:\\n            return 0\\n        if i <= self.mid:\\n            return self.val + self.left.query(i)\\n        return self.val + self.right.query(i)\\n    \\n    def querySum(self,l,r):\\n        #return sum value in range [l,r]\\n        if self.l >= l and self.r <= r:\\n            return self.sums\\n        if self.l > r or self.r < l:\\n            return 0\\n        return self.val*(min(r,self.r)-max(l,self.l)+1)+self.left.querySum(l,r)+self.right.querySum(l,r)\\n\\n    def queryLowestGreater(self,v):\\n        #return the smallest row that remain seats greater than v\\n        if self.max<v:\\n            return -1\\n        if self.l == self.r:\\n            return -1 if self.max<v else self.l\\n        if self.left.max >= v-self.val:\\n            return self.left.queryLowestGreater(v-self.val)\\n        return self.right.queryLowestGreater(v-self.val)\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.st = SegmentTree(0,n-1)\\n        self.st.update(0,n-1,m)\\n        self.m = m\\n        self.k = 0\\n        self.n = n\\n\\n\\n    def gather(self, k: int, maxRow: int):\\n        i = self.st.queryLowestGreater(k)\\n        if i<0 or i>maxRow:\\n            return []\\n        v = self.st.query(i)\\n        self.st.update(i,i,-k)\\n        return [i,self.m-v]\\n\\n    def scatter(self, k: int, maxRow: int):\\n        # if sum 0_maxRow greater than k,it\\'s possible to book\\n        if self.st.querySum(0,maxRow)>=k:\\n            #book seats from lowest row\\n            while self.k<self.n and k>0:\\n                v = self.st.query(self.k)\\n                self.st.update(self.k,self.k,-min(v,k))\\n                if v>k:\\n                    break\\n                else:\\n                    k -= v\\n                    self.k += 1\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083844,
                "title": "segment-tree-o-nlog-n",
                "content": "Lets see each of the query and see what can we do currently at the beginning at all rows we have every of the M seats available. \\nSo we create a segment tree which initializes every index with the value M and calculate two things sum in every interval and maximum in every interval.\\n\\nNow during gather operation we need to find the minimum index in the range [0, maxRow] which is atleast K we do that in the indexQuery function and if no index is found we get -1 for which we return an empty array as the answer. But lets say we get an index **row** which has enough size to seat K people we place that much people in that row and update the value of that index. The **col** can be calculate by the diffrence of Original **m** and current left people. This operation works in O(log(n)) time\\n\\nFor the scatter function first we need to check whether we have K amount of seats available in the range [0, maxRow] for that we use the sumQuery function and if we do have enough seats we occupy those places and also update values in the tree correspondingly. This operation works in O(maxRow * log(n)) time.\\n\\n```\\n#define ll long long\\nstruct seg {\\n    vector<ll> seg;\\n    vector<ll> sum;\\n    int siz;\\n    \\n    void init(int n, long long m) {\\n        siz = 1;\\n        while(siz <= n) siz *= 2;\\n        seg.resize(2 * siz, 0);\\n        sum.resize(2 * siz, 0);\\n        build(0, siz - 1, 0, m, n);\\n    }\\n    \\n    void build(int l, int r, int x, long long val, int n) {\\n        if(l == r) {\\n            if(l < n) {\\n                seg[x] = val;\\n                sum[x] = val;\\n            }\\n            return;\\n        }\\n\\n        int mid = (l + r) / 2;\\n        build(l, mid, 2 * x + 1, val, n);\\n        build(mid + 1, r, 2 * x + 2, val, n);\\n\\n        seg[x] = max(seg[2 * x + 1], seg[2 * x + 2]);\\n        sum[x] = sum[2 * x + 1] + sum[2 * x + 2];\\n        \\n    }\\n    void upd(int i, int v, int x, int lx, int rx) {\\n        if(lx == rx) {\\n            seg[x] = v;\\n            sum[x] = v;\\n            return;\\n        }\\n\\n        int mid = (lx + rx) / 2;\\n\\n        if(i <= mid)\\n            upd(i, v, 2 * x + 1, lx, mid);\\n        else\\n            upd(i, v, 2 * x + 2, mid + 1, rx);\\n\\n        seg[x] = max(seg[2 * x + 1], seg[2 * x + 2]);\\n        sum[x] = sum[2 * x + 1] + sum[2 * x + 2];\\n    }\\n    int indexQuery(int k, int l, int x, int lx, int rx) {\\n        if(seg[x] < k or lx > l) return -1;\\n        if(lx == rx) return lx;\\n        \\n        int mid = (lx + rx) / 2;\\n        \\n        int res = indexQuery(k, l, 2 * x + 1, lx, mid);\\n        \\n        if(res == -1)\\n            res = indexQuery(k, l, 2 * x + 2, mid + 1, rx);\\n        \\n        return res;\\n    }\\n    \\n    ll sumQuery(int l, int r, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return 0;\\n        if(lx >= l and rx <= r) return sum[x];\\n        \\n        int mid = (lx + rx) / 2;\\n        return sumQuery(l, r, 2 * x + 1, lx, mid) + sumQuery(l, r, 2 * x + 2, mid + 1, rx);\\n    }\\n    \\n    void upd(int ind, int val) {\\n        upd(ind, val, 0, 0, siz - 1);\\n    }\\n    \\n    int indexQuery(int val, int l) {\\n        return indexQuery(val, l, 0, 0, siz - 1);\\n    }\\n    \\n    ll sumQuery(int l, int r) {\\n        return sumQuery(l, r, 0, 0, siz - 1);\\n    }\\n};\\n\\nclass BookMyShow {\\npublic:\\n    seg tree;\\n    vector<ll> cur;\\n    ll M;\\n    \\n    BookMyShow(int n, int m) {\\n        tree.init(n, m);\\n        cur.resize(n, m);\\n        M = m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int row = tree.indexQuery(k, maxRow);\\n        if(row == -1) return vector<int> {};\\n        \\n        int col = M - cur[row];\\n        cur[row] -= k;\\n        \\n        tree.upd(row, cur[row]);\\n        return {row, col};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        ll sum = tree.sumQuery(0, maxRow);\\n   \\n        if(sum < k) return 0;\\n        \\n        for(int i = 0; i <= maxRow and k; ++i) {\\n            if(cur[i] > 0) {\\n                ll mn = min(cur[i], 1LL * k);\\n                cur[i] -= mn;\\n                k -= mn;\\n                tree.upd(i, cur[i]);\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n#define ll long long\\nstruct seg {\\n    vector<ll> seg;\\n    vector<ll> sum;\\n    int siz;\\n    \\n    void init(int n, long long m) {\\n        siz = 1;\\n        while(siz <= n) siz *= 2;\\n        seg.resize(2 * siz, 0);\\n        sum.resize(2 * siz, 0);\\n        build(0, siz - 1, 0, m, n);\\n    }\\n    \\n    void build(int l, int r, int x, long long val, int n) {\\n        if(l == r) {\\n            if(l < n) {\\n                seg[x] = val;\\n                sum[x] = val;\\n            }\\n            return;\\n        }\\n\\n        int mid = (l + r) / 2;\\n        build(l, mid, 2 * x + 1, val, n);\\n        build(mid + 1, r, 2 * x + 2, val, n);\\n\\n        seg[x] = max(seg[2 * x + 1], seg[2 * x + 2]);\\n        sum[x] = sum[2 * x + 1] + sum[2 * x + 2];\\n        \\n    }\\n    void upd(int i, int v, int x, int lx, int rx) {\\n        if(lx == rx) {\\n            seg[x] = v;\\n            sum[x] = v;\\n            return;\\n        }\\n\\n        int mid = (lx + rx) / 2;\\n\\n        if(i <= mid)\\n            upd(i, v, 2 * x + 1, lx, mid);\\n        else\\n            upd(i, v, 2 * x + 2, mid + 1, rx);\\n\\n        seg[x] = max(seg[2 * x + 1], seg[2 * x + 2]);\\n        sum[x] = sum[2 * x + 1] + sum[2 * x + 2];\\n    }\\n    int indexQuery(int k, int l, int x, int lx, int rx) {\\n        if(seg[x] < k or lx > l) return -1;\\n        if(lx == rx) return lx;\\n        \\n        int mid = (lx + rx) / 2;\\n        \\n        int res = indexQuery(k, l, 2 * x + 1, lx, mid);\\n        \\n        if(res == -1)\\n            res = indexQuery(k, l, 2 * x + 2, mid + 1, rx);\\n        \\n        return res;\\n    }\\n    \\n    ll sumQuery(int l, int r, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return 0;\\n        if(lx >= l and rx <= r) return sum[x];\\n        \\n        int mid = (lx + rx) / 2;\\n        return sumQuery(l, r, 2 * x + 1, lx, mid) + sumQuery(l, r, 2 * x + 2, mid + 1, rx);\\n    }\\n    \\n    void upd(int ind, int val) {\\n        upd(ind, val, 0, 0, siz - 1);\\n    }\\n    \\n    int indexQuery(int val, int l) {\\n        return indexQuery(val, l, 0, 0, siz - 1);\\n    }\\n    \\n    ll sumQuery(int l, int r) {\\n        return sumQuery(l, r, 0, 0, siz - 1);\\n    }\\n};\\n\\nclass BookMyShow {\\npublic:\\n    seg tree;\\n    vector<ll> cur;\\n    ll M;\\n    \\n    BookMyShow(int n, int m) {\\n        tree.init(n, m);\\n        cur.resize(n, m);\\n        M = m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int row = tree.indexQuery(k, maxRow);\\n        if(row == -1) return vector<int> {};\\n        \\n        int col = M - cur[row];\\n        cur[row] -= k;\\n        \\n        tree.upd(row, cur[row]);\\n        return {row, col};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        ll sum = tree.sumQuery(0, maxRow);\\n   \\n        if(sum < k) return 0;\\n        \\n        for(int i = 0; i <= maxRow and k; ++i) {\\n            if(cur[i] > 0) {\\n                ll mn = min(cur[i], 1LL * k);\\n                cur[i] -= mn;\\n                k -= mn;\\n                tree.upd(i, cur[i]);\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083960,
                "title": "still-pass-without-using-any-tree",
                "content": "The solution looks as stupid as Winnie though. The trick is maintaining a `startRow` where all rows have been filled up befroe `startRow`\\n```\\nclass BookMyShow {\\n    private int m;\\n    private int startRow;\\n    private int[] left;\\n\\n    public BookMyShow(int n, int m) {\\n        this.m = m;\\n        left = new int[n];\\n        Arrays.fill(left, m);\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        for (int i = startRow; i <= maxRow; i++) {\\n            if (left[i] >= k) {\\n                left[i] -= k;\\n                return new int[] {i, m - left[i] - k};\\n            }\\n        }\\n        return new int[] {};\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        int i = startRow;\\n        for ( ; i <= maxRow; i++) {\\n            if (k - left[i] < 0) {\\n                break;\\n            }\\n            k -= left[i];\\n        }\\n        if (i >= maxRow + 1) {\\n            if (k == 0) {\\n                startRow = i;\\n                return true;\\n            }\\n            return false;\\n        }\\n        startRow = i;\\n        left[i] -= k;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\n    private int m;\\n    private int startRow;\\n    private int[] left;\\n\\n    public BookMyShow(int n, int m) {\\n        this.m = m;\\n        left = new int[n];\\n        Arrays.fill(left, m);\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        for (int i = startRow; i <= maxRow; i++) {\\n            if (left[i] >= k) {\\n                left[i] -= k;\\n                return new int[] {i, m - left[i] - k};\\n            }\\n        }\\n        return new int[] {};\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        int i = startRow;\\n        for ( ; i <= maxRow; i++) {\\n            if (k - left[i] < 0) {\\n                break;\\n            }\\n            k -= left[i];\\n        }\\n        if (i >= maxRow + 1) {\\n            if (k == 0) {\\n                startRow = i;\\n                return true;\\n            }\\n            return false;\\n        }\\n        startRow = i;\\n        left[i] -= k;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084924,
                "title": "segment-tree-java-solution-with-comments",
                "content": "```java\\nclass BookMyShow {\\n    /**\\n        Segment tree class to store sum of a range and maximum available seats in a row\\n    **/\\n    static class SegTree{\\n        long sum[]; // store sum of seats in a range\\n        long segTree[]; // store maximum seats in a range\\n        int m, n;\\n        public SegTree(int n, int m) {\\n            this.m = m; \\n            this.n = n;\\n            segTree = new long[4*n];\\n            sum = new long[4*n];\\n            build(0, 0, n-1, m);\\n        }\\n        \\n        private void build(int index, int lo, int hi, long val){\\n            if(lo == hi){\\n                segTree[index] = val; // initialize segement tree with initial seat capacity\\n                sum[index] = val; // initialize \"sum\" with initial seat capacity of a row\\n                return;\\n            }\\n            int mid = (lo + hi)/2;\\n            build(2*index +1, lo, mid, val); // build left sub tree\\n            build(2*index +2, mid+1, hi, val); // build right sub tree\\n            segTree[index] = Math.max(segTree[2*index + 1], segTree[2*index + 2]); // maximum seats in a row for subtrees\\n            sum[index] = sum[2*index + 1] + sum[2*index + 2]; // sum of seats in a range\\n        }\\n        \\n        private void update(int index, int lo, int hi, int pos, int val){\\n            /**\\n                Method to update segment tree based on the available seats in a row\\n            **/\\n            if(lo == hi){\\n                segTree[index] = val;\\n                sum[index] = val;\\n                return;\\n            }\\n            int mid = (lo + hi) / 2;\\n            if (pos <= mid) {  // position to update is in left\\n               update(2 * index + 1, lo, mid, pos, val); \\n            } else { // position to update is in right\\n                update(2 * index + 2,  mid+1, hi, pos, val); \\n            }\\n\\t\\t\\t// update segment tree and \"sum\" based on the update in \"pos\" index \\n            segTree[index] = Math.max(segTree[2*index + 1] , segTree[2*index + 2]);\\n            sum[index] = sum[2*index + 1] + sum[2*index + 2];\\n        }\\n        \\n        public void update(int pos, int val){\\n            update(0, 0, n - 1 , pos, val);\\n        }\\n        \\n        public int gatherQuery(int k, int maxRow){\\n            return gatherQuery(0, 0, n - 1 , k, maxRow);    \\n        }\\n        \\n        private int gatherQuery(int index, int lo, int hi, int k, int maxRow){\\n            /**\\n                Method to check if seats are available in a single row \\n            **/\\n            if(segTree[index] < k || lo > maxRow)\\n                return -1;\\n            if(lo == hi) return lo;\\n            int mid = (lo + hi) / 2;\\n            int c = gatherQuery(2*index + 1, lo, mid, k, maxRow);\\n            if(c == -1){\\n                c = gatherQuery(2*index + 2, mid +1, hi, k, maxRow);\\n            }\\n            return c;\\n        }\\n        \\n        public long sumQuery(int k, int maxRow){\\n            return sumQuery(0, 0, n-1, k, maxRow);\\n        }\\n        \\n        private long sumQuery(int index, int lo, int hi, int l, int r){\\n            if(lo > r || hi < l ) return 0;  // not in range\\n            if(lo >= l && hi <= r) return sum[index]; // in range\\n            int mid = (lo + hi)/2;\\n            return sumQuery(2*index+1, lo, mid, l, r) + sumQuery(2*index+2, mid+1, hi, l, r);\\n        }\\n    }\\n    \\n    SegTree segTree;\\n    int[] rowSeats; // stores avaiable seats in a row, helps to find the vacant seat in a row\\n    \\n    public BookMyShow(int n, int m) {\\n        segTree = new SegTree(n, m);\\n        rowSeats = new int[n];\\n        Arrays.fill(rowSeats, m);  // initialize vacant seats count to \"m\" for all the rows\\n    }\\n\\n    \\n    public int[] gather(int k, int maxRow) {\\n        int row = segTree.gatherQuery(k, maxRow); // find row which has k seats\\n        if(row == -1) return new int[]{}; // can\\'t find a row with k seats\\n        int col = segTree.m - rowSeats[row]; // find column in the row which has k seats\\n        rowSeats[row] -= k; // reduce the seats \\n        segTree.update(row, rowSeats[row]); // update the segment tree\\n        return new int[]{row, col};\\n        \\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        long sum = segTree.sumQuery(0, maxRow); // find the sum for the given range [0, maxRow]\\n        if(sum < k) return false; // can\\'t find k seats in [0, maxRow]\\n        \\n        for(int i=0; i<=maxRow && k !=0 ; i++){\\n            if(rowSeats[i] > 0){                       // if current row has seats then allocate those seats          \\n                long t = Math.min(rowSeats[i], k);  \\n                rowSeats[i] -= t;\\n                k -= t;\\n                segTree.update(i,rowSeats[i]);  // update the segment tree\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```java\\nclass BookMyShow {\\n    /**\\n        Segment tree class to store sum of a range and maximum available seats in a row\\n    **/\\n    static class SegTree{\\n        long sum[]; // store sum of seats in a range\\n        long segTree[]; // store maximum seats in a range\\n        int m, n;\\n        public SegTree(int n, int m) {\\n            this.m = m; \\n            this.n = n;\\n            segTree = new long[4*n];\\n            sum = new long[4*n];\\n            build(0, 0, n-1, m);\\n        }\\n        \\n        private void build(int index, int lo, int hi, long val){\\n            if(lo == hi){\\n                segTree[index] = val; // initialize segement tree with initial seat capacity\\n                sum[index] = val; // initialize \"sum\" with initial seat capacity of a row\\n                return;\\n            }\\n            int mid = (lo + hi)/2;\\n            build(2*index +1, lo, mid, val); // build left sub tree\\n            build(2*index +2, mid+1, hi, val); // build right sub tree\\n            segTree[index] = Math.max(segTree[2*index + 1], segTree[2*index + 2]); // maximum seats in a row for subtrees\\n            sum[index] = sum[2*index + 1] + sum[2*index + 2]; // sum of seats in a range\\n        }\\n        \\n        private void update(int index, int lo, int hi, int pos, int val){\\n            /**\\n                Method to update segment tree based on the available seats in a row\\n            **/\\n            if(lo == hi){\\n                segTree[index] = val;\\n                sum[index] = val;\\n                return;\\n            }\\n            int mid = (lo + hi) / 2;\\n            if (pos <= mid) {  // position to update is in left\\n               update(2 * index + 1, lo, mid, pos, val); \\n            } else { // position to update is in right\\n                update(2 * index + 2,  mid+1, hi, pos, val); \\n            }\\n\\t\\t\\t// update segment tree and \"sum\" based on the update in \"pos\" index \\n            segTree[index] = Math.max(segTree[2*index + 1] , segTree[2*index + 2]);\\n            sum[index] = sum[2*index + 1] + sum[2*index + 2];\\n        }\\n        \\n        public void update(int pos, int val){\\n            update(0, 0, n - 1 , pos, val);\\n        }\\n        \\n        public int gatherQuery(int k, int maxRow){\\n            return gatherQuery(0, 0, n - 1 , k, maxRow);    \\n        }\\n        \\n        private int gatherQuery(int index, int lo, int hi, int k, int maxRow){\\n            /**\\n                Method to check if seats are available in a single row \\n            **/\\n            if(segTree[index] < k || lo > maxRow)\\n                return -1;\\n            if(lo == hi) return lo;\\n            int mid = (lo + hi) / 2;\\n            int c = gatherQuery(2*index + 1, lo, mid, k, maxRow);\\n            if(c == -1){\\n                c = gatherQuery(2*index + 2, mid +1, hi, k, maxRow);\\n            }\\n            return c;\\n        }\\n        \\n        public long sumQuery(int k, int maxRow){\\n            return sumQuery(0, 0, n-1, k, maxRow);\\n        }\\n        \\n        private long sumQuery(int index, int lo, int hi, int l, int r){\\n            if(lo > r || hi < l ) return 0;  // not in range\\n            if(lo >= l && hi <= r) return sum[index]; // in range\\n            int mid = (lo + hi)/2;\\n            return sumQuery(2*index+1, lo, mid, l, r) + sumQuery(2*index+2, mid+1, hi, l, r);\\n        }\\n    }\\n    \\n    SegTree segTree;\\n    int[] rowSeats; // stores avaiable seats in a row, helps to find the vacant seat in a row\\n    \\n    public BookMyShow(int n, int m) {\\n        segTree = new SegTree(n, m);\\n        rowSeats = new int[n];\\n        Arrays.fill(rowSeats, m);  // initialize vacant seats count to \"m\" for all the rows\\n    }\\n\\n    \\n    public int[] gather(int k, int maxRow) {\\n        int row = segTree.gatherQuery(k, maxRow); // find row which has k seats\\n        if(row == -1) return new int[]{}; // can\\'t find a row with k seats\\n        int col = segTree.m - rowSeats[row]; // find column in the row which has k seats\\n        rowSeats[row] -= k; // reduce the seats \\n        segTree.update(row, rowSeats[row]); // update the segment tree\\n        return new int[]{row, col};\\n        \\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        long sum = segTree.sumQuery(0, maxRow); // find the sum for the given range [0, maxRow]\\n        if(sum < k) return false; // can\\'t find k seats in [0, maxRow]\\n        \\n        for(int i=0; i<=maxRow && k !=0 ; i++){\\n            if(rowSeats[i] > 0){                       // if current row has seats then allocate those seats          \\n                long t = Math.min(rowSeats[i], k);  \\n                rowSeats[i] -= t;\\n                k -= t;\\n                segTree.update(i,rowSeats[i]);  // update the segment tree\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084740,
                "title": "easy-to-understand-simple-readable-code",
                "content": "I think this problem is submitted just beacuse of \\'seatStartsFrom\\',\\nThis solution is definitely not an optimised one, but let\\'s understand though,\\nWe can start from row 0 all the way to maxRow,\\ngathering the seats is not difficult, we can iterate over the rows and return when we found the seats,\\nin same way iterate for scattered seats.\\n```\\nclass BookMyShow {\\n    private int[] seatsLeft;\\n    private int m, seatStartsFrom;\\n\\n    public BookMyShow(int n, int m) {\\n        this.m = m;\\n        seatStartsFrom = 0;\\n        seatsLeft = new int[n];\\n        Arrays.fill(seatsLeft, m);\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        for(int row= seatStartsFrom;row<=maxRow;row++){\\n            if(seatsLeft[row]>=k){\\n                seatsLeft[row] -= k;\\n                return new int[]{row, m- seatsLeft[row]-k};\\n            }\\n        }\\n        return new int[]{};\\n        \\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        int start = seatStartsFrom;\\n        while(start<=maxRow && k > seatsLeft[start])\\n            k = k - seatsLeft[start++];\\n        if(start>maxRow && k>0) return false;\\n        \\n        seatsLeft[start] -= k;\\n        seatStartsFrom = start;\\n        return true;\\n    }\\n}\\n```\\nHappy LeetCoding",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BookMyShow {\\n    private int[] seatsLeft;\\n    private int m, seatStartsFrom;\\n\\n    public BookMyShow(int n, int m) {\\n        this.m = m;\\n        seatStartsFrom = 0;\\n        seatsLeft = new int[n];\\n        Arrays.fill(seatsLeft, m);\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        for(int row= seatStartsFrom;row<=maxRow;row++){\\n            if(seatsLeft[row]>=k){\\n                seatsLeft[row] -= k;\\n                return new int[]{row, m- seatsLeft[row]-k};\\n            }\\n        }\\n        return new int[]{};\\n        \\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        int start = seatStartsFrom;\\n        while(start<=maxRow && k > seatsLeft[start])\\n            k = k - seatsLeft[start++];\\n        if(start>maxRow && k>0) return false;\\n        \\n        seatsLeft[start] -= k;\\n        seatStartsFrom = start;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084477,
                "title": "check-my-detailed-segment-tree-solution-with-explanation",
                "content": "**Idea?**\\n* For the **gather()** function, we need to find the least index i in range **[0,maxRow]** such that there are k seats remaining, If there is no such index return [].\\n* For the **scatter()** function, we need to check whether we have **at least k empty seats**, If yes fill those k seats starting from leftmost and *return true* otherwise *return false*.\\n* Maintain a **segment tree** that finds the **leftmost index i** in range [0,maxRow] such that seats[i] has atleast k empty seats, in **log(n) time** for **gather()** operation.\\n* Also, we need to update the ith row if we found it from the above operation.\\n* In **scatter()** function, find the number of unoccupied seats in range [i,maxRow]. If the count of such is strictly less than k, return false.\\n* Otherwise, iterate from [0,maxRow] and fill those seats and update the segment tree as well.\\n* **Time Complexity of gather() function: O(logn)**\\n* **Time Complexity of scatter function: O(maxRow * log(n))**\\n\\n```\\nclass BookMyShow {\\npublic:\\n    int n,m;\\n    vector<int> rows;\\n    vector<pair<long long,long long>> seg;\\n    \\n    BookMyShow(int N, int M) {\\n        n = N;m = M;\\n        rows.assign(n,m);\\n        seg.assign(4*n+2,{0,0});\\n        \\n        build(1,0,n-1);\\n    }\\n    \\n    void build(int v,int l,int r){\\n        if(l==r){\\n            seg[v].first = m;\\n            seg[v].second = m;\\n            return;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        build(v*2,l,mid);\\n        build(v*2+1,mid+1,r);\\n        \\n        seg[v].second = seg[v*2].second + seg[v*2+1].second;\\n        seg[v].first = max(seg[v*2].first,seg[v*2+1].first);\\n    }\\n    \\n    pair<int,long long> query_max(int v,int l,int r,int qlow,int qhigh,int k){\\n        if(qlow>qhigh){\\n            return {-1,LONG_LONG_MIN};\\n        }\\n        \\n        if(l==r){\\n            return {l,seg[v].first};\\n        }\\n        \\n        int mid = (l+r)/2;\\n        \\n        if((long long)k<=seg[v*2].first){\\n            return query_max(v*2,l,mid,qlow,min(qhigh,mid),k);\\n        }\\n        else{\\n            return query_max(v*2+1,mid+1,r,max(qlow,mid+1),qhigh,k);\\n        }\\n    }\\n    \\n    long long query_sum(int v,int l,int r,int qlow,int qhigh){\\n        if(qlow>qhigh){\\n            return 0;\\n        }\\n        if(l==qlow and r==qhigh){\\n            return seg[v].second;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        long long leftSum = query_sum(v*2,l,mid,qlow,min(qhigh,mid));\\n        long long rightSum = query_sum(v*2+1,mid+1,r,max(qlow,mid+1),qhigh);\\n        \\n        return leftSum + rightSum;\\n    }\\n    \\n    void update(int v,int l,int r,int pos,int val){\\n        if(l==r){\\n            seg[v].first -= val;\\n            seg[v].second -= val;\\n            return;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        if(pos<=mid){\\n            update(v*2,l,mid,pos,val);\\n        }\\n        else{\\n            update(v*2+1,mid+1,r,pos,val);\\n        }\\n        \\n        seg[v].second = seg[v*2].second + seg[v*2+1].second;\\n        seg[v].first = max(seg[v*2].first,seg[v*2+1].first);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        pair<int,long long> p = query_max(1,0,n-1,0,maxRow,k);\\n        \\n        if(p.second<(long long)k){\\n            return {};\\n        }\\n        \\n        rows[p.first] -= k;\\n        update(1,0,n-1,p.first,k);\\n        \\n        return {p.first,m-rows[p.first]-k};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long sum = query_sum(1,0,n-1,0,maxRow);\\n        if(sum<(long long)k){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<=maxRow and k>0;i++){\\n            int take = min(rows[i],k);\\n            rows[i] -= take;\\n            k -= take;\\n            \\n            update(1,0,n-1,i,take);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    int n,m;\\n    vector<int> rows;\\n    vector<pair<long long,long long>> seg;\\n    \\n    BookMyShow(int N, int M) {\\n        n = N;m = M;\\n        rows.assign(n,m);\\n        seg.assign(4*n+2,{0,0});\\n        \\n        build(1,0,n-1);\\n    }\\n    \\n    void build(int v,int l,int r){\\n        if(l==r){\\n            seg[v].first = m;\\n            seg[v].second = m;\\n            return;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        build(v*2,l,mid);\\n        build(v*2+1,mid+1,r);\\n        \\n        seg[v].second = seg[v*2].second + seg[v*2+1].second;\\n        seg[v].first = max(seg[v*2].first,seg[v*2+1].first);\\n    }\\n    \\n    pair<int,long long> query_max(int v,int l,int r,int qlow,int qhigh,int k){\\n        if(qlow>qhigh){\\n            return {-1,LONG_LONG_MIN};\\n        }\\n        \\n        if(l==r){\\n            return {l,seg[v].first};\\n        }\\n        \\n        int mid = (l+r)/2;\\n        \\n        if((long long)k<=seg[v*2].first){\\n            return query_max(v*2,l,mid,qlow,min(qhigh,mid),k);\\n        }\\n        else{\\n            return query_max(v*2+1,mid+1,r,max(qlow,mid+1),qhigh,k);\\n        }\\n    }\\n    \\n    long long query_sum(int v,int l,int r,int qlow,int qhigh){\\n        if(qlow>qhigh){\\n            return 0;\\n        }\\n        if(l==qlow and r==qhigh){\\n            return seg[v].second;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        long long leftSum = query_sum(v*2,l,mid,qlow,min(qhigh,mid));\\n        long long rightSum = query_sum(v*2+1,mid+1,r,max(qlow,mid+1),qhigh);\\n        \\n        return leftSum + rightSum;\\n    }\\n    \\n    void update(int v,int l,int r,int pos,int val){\\n        if(l==r){\\n            seg[v].first -= val;\\n            seg[v].second -= val;\\n            return;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        if(pos<=mid){\\n            update(v*2,l,mid,pos,val);\\n        }\\n        else{\\n            update(v*2+1,mid+1,r,pos,val);\\n        }\\n        \\n        seg[v].second = seg[v*2].second + seg[v*2+1].second;\\n        seg[v].first = max(seg[v*2].first,seg[v*2+1].first);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        pair<int,long long> p = query_max(1,0,n-1,0,maxRow,k);\\n        \\n        if(p.second<(long long)k){\\n            return {};\\n        }\\n        \\n        rows[p.first] -= k;\\n        update(1,0,n-1,p.first,k);\\n        \\n        return {p.first,m-rows[p.first]-k};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long sum = query_sum(1,0,n-1,0,maxRow);\\n        if(sum<(long long)k){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<=maxRow and k>0;i++){\\n            int take = min(rows[i],k);\\n            rows[i] -= take;\\n            k -= take;\\n            \\n            update(1,0,n-1,i,take);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084127,
                "title": "c-solution-segment-tree-max-range-query-prefix-sum-query-o-logn-for-per-query",
                "content": "```\\n\\ntemplate <class T>\\nclass SegmentTree\\n{\\nprivate:\\n    long long n;\\n    vector<vector<T>> segtree;\\npublic:\\n    void init(long long n)\\n    {\\n        this->n = n;\\n        segtree.resize(2, vector<T>(4 * n + 1));\\n    }\\n    T op(T x, T y, bool z)\\n    {\\n        return z ? (x + y) : max(x, y);\\n    }\\n    void updateVal(long long x, long long l, long long r, long long idx, T val)\\n    {\\n        if (l > idx or r < idx)\\n            return;\\n        if (l == r)\\n        {\\n            segtree[0][x] = val;\\n            segtree[1][x] = val;\\n            return;\\n        }\\n        long long mid = (l + r) / 2LL;\\n        updateVal(2 * x, l, mid, idx, val);\\n        updateVal(2 * x + 1, mid + 1, r, idx, val);\\n        segtree[0][x] = op(segtree[0][2 * x], segtree[0][2 * x + 1], 0);\\n        segtree[1][x] = op(segtree[1][2 * x], segtree[1][2 * x + 1], 1);\\n    }\\n    void update(long long idx, T val)\\n    {\\n        updateVal(1, 1, n, idx, val);\\n    }\\n    T cal(long long x, long long l, long long r, long long L, long long R)\\n    {\\n        if (L <= l and R >= r)\\n            return segtree[0][x];\\n        if (L > r or R < l)\\n            return 0;\\n        long long mid = (l + r) / 2LL;\\n        return op(cal(2 * x, l, mid, L, R), cal(2 * x + 1, mid + 1, r, L, R), 0);\\n    }\\n    T presum(long long x, long long l, long long r, long long L, long long R)\\n    {\\n        if (L <= l and R >= r)\\n            return segtree[1][x];\\n        if (L > r or R < l)\\n            return 0;\\n        long long mid = (l + r) / 2LL;\\n        return op(presum(2 * x, l, mid, L, R), presum(2 * x + 1, mid + 1, r, L, R), 1);\\n    }\\n    T query(long long l, long long r, long long z)\\n    {\\n        return l > r ? 0 : (z ? presum(1, 1, n, l, r) : cal(1, 1, n, l, r));\\n    }\\n};\\nclass BookMyShow {\\npublic:\\n    long long n, m, filled;\\n    SegmentTree<long long> stree;\\n    BookMyShow(long long n, long long m) {\\n        filled = 0;\\n        this->n = n;\\n        this->m = m;\\n        stree.init(n);\\n        for (long long i = 0; i < n; i++)\\n            stree.update(i + 1, m);\\n    }\\n    \\n    vector<long long> gather(long long k, long long maxRow) {\\n        long long lo = filled + 1, hi = maxRow + 1, ans = 0;\\n        while (lo <= hi)\\n        {\\n            long long mid = (lo + hi) >> 1LL;\\n            if (stree.query(filled + 1, mid, 0) >= k)\\n            {\\n                hi = mid - 1;\\n                ans = mid;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n        if (!ans)\\n            return {};\\n        long long col = m - stree.query(ans, ans, 1);\\n        long long x = stree.query(ans, ans, 0);\\n        stree.update(ans, x - k);\\n        return {ans - 1, col};\\n    }\\n    \\n    bool scatter(long long k, long long maxRow) {\\n        if (stree.query(filled + 1, maxRow + 1, 1) < k)\\n            return false;\\n        long long lo = filled + 1, hi = maxRow + 1, ans;\\n        while (lo <= hi)\\n        {\\n            long long mid = (lo + hi) >> 1LL;\\n            if (stree.query(filled + 1, mid, 1) >= k)\\n            {\\n                hi = mid - 1;\\n                ans = mid;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n        long long x = stree.query(filled + 1, ans, 1);\\n        filled = ans - 1;\\n        stree.update(ans, x - k);\\n        filled += (x == k);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<long long> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntemplate <class T>\\nclass SegmentTree\\n{\\nprivate:\\n    long long n;\\n    vector<vector<T>> segtree;\\npublic:\\n    void init(long long n)\\n    {\\n        this->n = n;\\n        segtree.resize(2, vector<T>(4 * n + 1));\\n    }\\n    T op(T x, T y, bool z)\\n    {\\n        return z ? (x + y) : max(x, y);\\n    }\\n    void updateVal(long long x, long long l, long long r, long long idx, T val)\\n    {\\n        if (l > idx or r < idx)\\n            return;\\n        if (l == r)\\n        {\\n            segtree[0][x] = val;\\n            segtree[1][x] = val;\\n            return;\\n        }\\n        long long mid = (l + r) / 2LL;\\n        updateVal(2 * x, l, mid, idx, val);\\n        updateVal(2 * x + 1, mid + 1, r, idx, val);\\n        segtree[0][x] = op(segtree[0][2 * x], segtree[0][2 * x + 1], 0);\\n        segtree[1][x] = op(segtree[1][2 * x], segtree[1][2 * x + 1], 1);\\n    }\\n    void update(long long idx, T val)\\n    {\\n        updateVal(1, 1, n, idx, val);\\n    }\\n    T cal(long long x, long long l, long long r, long long L, long long R)\\n    {\\n        if (L <= l and R >= r)\\n            return segtree[0][x];\\n        if (L > r or R < l)\\n            return 0;\\n        long long mid = (l + r) / 2LL;\\n        return op(cal(2 * x, l, mid, L, R), cal(2 * x + 1, mid + 1, r, L, R), 0);\\n    }\\n    T presum(long long x, long long l, long long r, long long L, long long R)\\n    {\\n        if (L <= l and R >= r)\\n            return segtree[1][x];\\n        if (L > r or R < l)\\n            return 0;\\n        long long mid = (l + r) / 2LL;\\n        return op(presum(2 * x, l, mid, L, R), presum(2 * x + 1, mid + 1, r, L, R), 1);\\n    }\\n    T query(long long l, long long r, long long z)\\n    {\\n        return l > r ? 0 : (z ? presum(1, 1, n, l, r) : cal(1, 1, n, l, r));\\n    }\\n};\\nclass BookMyShow {\\npublic:\\n    long long n, m, filled;\\n    SegmentTree<long long> stree;\\n    BookMyShow(long long n, long long m) {\\n        filled = 0;\\n        this->n = n;\\n        this->m = m;\\n        stree.init(n);\\n        for (long long i = 0; i < n; i++)\\n            stree.update(i + 1, m);\\n    }\\n    \\n    vector<long long> gather(long long k, long long maxRow) {\\n        long long lo = filled + 1, hi = maxRow + 1, ans = 0;\\n        while (lo <= hi)\\n        {\\n            long long mid = (lo + hi) >> 1LL;\\n            if (stree.query(filled + 1, mid, 0) >= k)\\n            {\\n                hi = mid - 1;\\n                ans = mid;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n        if (!ans)\\n            return {};\\n        long long col = m - stree.query(ans, ans, 1);\\n        long long x = stree.query(ans, ans, 0);\\n        stree.update(ans, x - k);\\n        return {ans - 1, col};\\n    }\\n    \\n    bool scatter(long long k, long long maxRow) {\\n        if (stree.query(filled + 1, maxRow + 1, 1) < k)\\n            return false;\\n        long long lo = filled + 1, hi = maxRow + 1, ans;\\n        while (lo <= hi)\\n        {\\n            long long mid = (lo + hi) >> 1LL;\\n            if (stree.query(filled + 1, mid, 1) >= k)\\n            {\\n                hi = mid - 1;\\n                ans = mid;\\n            }\\n            else\\n                lo = mid + 1;\\n        }\\n        long long x = stree.query(filled + 1, ans, 1);\\n        filled = ans - 1;\\n        stree.update(ans, x - k);\\n        filled += (x == k);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<long long> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309059,
                "title": "c-implementation-with-easy-explaination-segment-trees-binary-search",
                "content": "We would use two segment trees - sum and max query segment trees, the leaves of which would have the array storing the available seats for all the rows at any moment.\\n\\nAlong with that we would keep track of how many rows from beginning are occupied completely so that we do not include them in the range query. *Advantage: We would not need to update the sum and max segment trees completely in case a scatter query fills and thus alters a lot of rows (like some 100 rows).*\\n\\n* **scatter operation** - we would try to find the minimum subrange from the [minRow, maxRow] that is able to accomodate at least k people using binary search and rangeSum.\\n(Here `minRow = occupied_rows + 1`)\\nLet\\'s say we got the subrange [minRow, x] for some x having total seats `rangeSeats`. It means that all the rows from [minRow, x-1] would have been occupied and the row \\'x\\' would have been partially occupied. we could update the `occupied_rows` variable to `x-1` and update both the segment trees at index `x` with the surplus seats (`rangeSeats - k`).\\nTime complexity - O(logN)\\n\\n* **gather operation** - we would try to find the minimum index row in the range [minRow, maxRow] such that it has altleast `k` seats again using binary seach and rangeMax. (Since rangeMax is a non decreasing function). we would update that row in the max and sum segment trees by subtracting `k` from the current available seats.\\nTime complexity - O(logN)\\n\\nCode : -\\n```\\nclass BookMyShow {\\n    int occ = -1; // No row occupied initially\\n    vector<long long> sumTree, maxTree;\\n    int treeSize = 0, rowSeats = 0;\\n    \\npublic:\\n    \\n    BookMyShow(int n, int m) {\\n        // Seg tree size\\n        this->treeSize = (int) 2 * pow(2, ceil((double)log2(n))); \\n        sumTree.resize(treeSize);\\n        maxTree.resize(treeSize);\\n\\n        this->rowSeats = m;\\n        constructSumTree(m);\\n        constructMaxTree(m);\\n    }\\n    \\n    void constructSumTree(int m){\\n        int n = this->treeSize/ 2;\\n        \\n        // Filling the leaves\\n        for(int i=n; i<2*n;i++)\\n            this->sumTree[i] = (long long) m;\\n        \\n        // Forming the higher nodes\\n        for(int i=n-1;i>=1;i--)\\n            this->sumTree[i] = this->sumTree[2*i] + this->sumTree[2*i+1];\\n    }\\n    \\n    void constructMaxTree(int m){\\n        int n = this->treeSize/ 2;\\n        \\n        // Filling the leaves\\n        for(int i=n; i<2*n;i++)\\n            this->maxTree[i] = (long long) m;\\n        \\n        // Forming the higher nodes\\n        for(int i=n-1;i>=1;i--)\\n            this->maxTree[i] = max(this->maxTree[2*i], this->maxTree[2*i+1]);\\n    }\\n    \\n    long long rangeSum(int minRow, int maxRow){\\n        long long sum = 0;\\n        int n = treeSize / 2;\\n        minRow += n; maxRow += n;\\n        while(minRow <= maxRow){\\n            if(minRow % 2 == 1) sum += this->sumTree[minRow++]; // Right child\\n            if(maxRow % 2 == 0) sum += this->sumTree[maxRow--]; // Left child\\n            minRow /= 2; maxRow /= 2;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    void updateSumTree(int index, int newValue){\\n        int n = this->treeSize / 2;\\n        int temp = index;\\n        index += n;\\n        this->sumTree[index] = newValue; // Update leaf\\n        index /= 2;\\n        while(index > 0){\\n            this->sumTree[index] = this->sumTree[2*index] + this->sumTree[2*index + 1];\\n            index /= 2;\\n        }\\n    }\\n    \\n    long long rangeMax(int minRow, int maxRow){\\n        long long ans = 0;\\n        int n = this->treeSize / 2;\\n        minRow += n; maxRow += n;\\n        while(minRow <= maxRow){\\n            if(minRow % 2 == 1) ans = max(ans, this->maxTree[minRow++]); // Right child\\n            if(maxRow % 2 == 0) ans = max(ans, this->maxTree[maxRow--]); // Left child\\n            minRow /= 2; maxRow /= 2;\\n        }\\n        \\n        // cout<<\"range max over\"<<\\'\\\\n\\';\\n        return ans;\\n    }\\n    \\n    void updateMaxTree(int index, int newValue){\\n        int n = this->treeSize / 2;\\n        int temp = index;\\n        index += n;\\n        this->maxTree[index] = newValue; // Update leaf\\n        index /= 2;\\n        while(index > 0){\\n            this->maxTree[index] = max(this->maxTree[2*index], this->maxTree[2*index + 1]);\\n            index /= 2;\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int minRow = occ + 1;\\n        if(maxRow < minRow) return {};\\n        if(rangeMax(minRow, maxRow) < k) return {};\\n        \\n        int minIndex = maxRow;\\n        int seats = 0;\\n        int low = minRow, high = maxRow;\\n        while(low <= high){\\n            int midRow = (low + high)/2;\\n            int maxSeats = rangeMax(minRow, midRow);\\n            if(maxSeats >= k){\\n                high = midRow - 1;\\n                seats = maxSeats;\\n                minIndex = midRow;\\n            }\\n            else low = midRow + 1;\\n        }\\n        \\n        int r = minIndex, c = this->rowSeats - seats;\\n        \\n        // Updatng the segment trees\\n        this->updateMaxTree(minIndex, seats - k);\\n        this->updateSumTree(minIndex, seats - k);\\n        return {r,c};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int minRow = occ + 1;\\n        if(maxRow < minRow) return false;\\n        if(rangeSum(minRow, maxRow) < k) return false;\\n        \\n        int minIndex = maxRow;\\n        long long seats = 0;\\n        int low = minRow, high = maxRow;\\n        while(low <= high){\\n            int midRow = (low + high)/2;\\n            long long rangeSeats = rangeSum(minRow, midRow);\\n            if(rangeSeats >= k){\\n                high = midRow - 1;\\n                seats = rangeSeats;\\n                minIndex = midRow;\\n            }\\n            else low = midRow + 1;\\n        }\\n        \\n        // Updating the occupied rows\\n        occ = minIndex - 1;\\n        \\n        // Updating the segment trees\\n        this->updateSumTree(minIndex, seats - k); \\n        this->updateMaxTree(minIndex, seats - k);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass BookMyShow {\\n    int occ = -1; // No row occupied initially\\n    vector<long long> sumTree, maxTree;\\n    int treeSize = 0, rowSeats = 0;\\n    \\npublic:\\n    \\n    BookMyShow(int n, int m) {\\n        // Seg tree size\\n        this->treeSize = (int) 2 * pow(2, ceil((double)log2(n))); \\n        sumTree.resize(treeSize);\\n        maxTree.resize(treeSize);\\n\\n        this->rowSeats = m;\\n        constructSumTree(m);\\n        constructMaxTree(m);\\n    }\\n    \\n    void constructSumTree(int m){\\n        int n = this->treeSize/ 2;\\n        \\n        // Filling the leaves\\n        for(int i=n; i<2*n;i++)\\n            this->sumTree[i] = (long long) m;\\n        \\n        // Forming the higher nodes\\n        for(int i=n-1;i>=1;i--)\\n            this->sumTree[i] = this->sumTree[2*i] + this->sumTree[2*i+1];\\n    }\\n    \\n    void constructMaxTree(int m){\\n        int n = this->treeSize/ 2;\\n        \\n        // Filling the leaves\\n        for(int i=n; i<2*n;i++)\\n            this->maxTree[i] = (long long) m;\\n        \\n        // Forming the higher nodes\\n        for(int i=n-1;i>=1;i--)\\n            this->maxTree[i] = max(this->maxTree[2*i], this->maxTree[2*i+1]);\\n    }\\n    \\n    long long rangeSum(int minRow, int maxRow){\\n        long long sum = 0;\\n        int n = treeSize / 2;\\n        minRow += n; maxRow += n;\\n        while(minRow <= maxRow){\\n            if(minRow % 2 == 1) sum += this->sumTree[minRow++]; // Right child\\n            if(maxRow % 2 == 0) sum += this->sumTree[maxRow--]; // Left child\\n            minRow /= 2; maxRow /= 2;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    void updateSumTree(int index, int newValue){\\n        int n = this->treeSize / 2;\\n        int temp = index;\\n        index += n;\\n        this->sumTree[index] = newValue; // Update leaf\\n        index /= 2;\\n        while(index > 0){\\n            this->sumTree[index] = this->sumTree[2*index] + this->sumTree[2*index + 1];\\n            index /= 2;\\n        }\\n    }\\n    \\n    long long rangeMax(int minRow, int maxRow){\\n        long long ans = 0;\\n        int n = this->treeSize / 2;\\n        minRow += n; maxRow += n;\\n        while(minRow <= maxRow){\\n            if(minRow % 2 == 1) ans = max(ans, this->maxTree[minRow++]); // Right child\\n            if(maxRow % 2 == 0) ans = max(ans, this->maxTree[maxRow--]); // Left child\\n            minRow /= 2; maxRow /= 2;\\n        }\\n        \\n        // cout<<\"range max over\"<<\\'\\\\n\\';\\n        return ans;\\n    }\\n    \\n    void updateMaxTree(int index, int newValue){\\n        int n = this->treeSize / 2;\\n        int temp = index;\\n        index += n;\\n        this->maxTree[index] = newValue; // Update leaf\\n        index /= 2;\\n        while(index > 0){\\n            this->maxTree[index] = max(this->maxTree[2*index], this->maxTree[2*index + 1]);\\n            index /= 2;\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int minRow = occ + 1;\\n        if(maxRow < minRow) return {};\\n        if(rangeMax(minRow, maxRow) < k) return {};\\n        \\n        int minIndex = maxRow;\\n        int seats = 0;\\n        int low = minRow, high = maxRow;\\n        while(low <= high){\\n            int midRow = (low + high)/2;\\n            int maxSeats = rangeMax(minRow, midRow);\\n            if(maxSeats >= k){\\n                high = midRow - 1;\\n                seats = maxSeats;\\n                minIndex = midRow;\\n            }\\n            else low = midRow + 1;\\n        }\\n        \\n        int r = minIndex, c = this->rowSeats - seats;\\n        \\n        // Updatng the segment trees\\n        this->updateMaxTree(minIndex, seats - k);\\n        this->updateSumTree(minIndex, seats - k);\\n        return {r,c};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int minRow = occ + 1;\\n        if(maxRow < minRow) return false;\\n        if(rangeSum(minRow, maxRow) < k) return false;\\n        \\n        int minIndex = maxRow;\\n        long long seats = 0;\\n        int low = minRow, high = maxRow;\\n        while(low <= high){\\n            int midRow = (low + high)/2;\\n            long long rangeSeats = rangeSum(minRow, midRow);\\n            if(rangeSeats >= k){\\n                high = midRow - 1;\\n                seats = rangeSeats;\\n                minIndex = midRow;\\n            }\\n            else low = midRow + 1;\\n        }\\n        \\n        // Updating the occupied rows\\n        occ = minIndex - 1;\\n        \\n        // Updating the segment trees\\n        this->updateSumTree(minIndex, seats - k); \\n        this->updateMaxTree(minIndex, seats - k);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2133327,
                "title": "rust-segment-tree",
                "content": "```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::{BTreeMap, BinaryHeap, HashMap, VecDeque},\\n    rc::Rc, borrow::Borrow,\\n};\\n\\n\\n#[derive(Debug)]\\nstruct Node {\\n    // starting row index, inclusive\\n    l_index: usize,\\n    // ending row index, inclusive\\n    r_index: usize,\\n    // child node, left\\n    l_node: Option<Box<Node>>,\\n    // child node, right\\n    r_node: Option<Box<Node>>,\\n    // the total number of seat that can be allocated\\n    sum: usize,\\n    // the maximum amount of allocatable seat in a row\\n    max: usize,\\n    // the index of the first empty seat\\n    index: usize,\\n}\\n\\nimpl Node {\\n    fn build(l_index: usize, r_index: usize, max: usize) -> Node {\\n        let (l_node, r_node, sum) = if l_index == r_index {\\n            (None, None, max)\\n        } else {\\n            let m_index = (l_index + r_index) / 2;\\n            let l_node = Box::new(Node::build(l_index, m_index, max));\\n            let r_node = Box::new(Node::build(m_index + 1, r_index, max));\\n\\n            let sum = l_node.sum + r_node.sum;\\n            (Some(l_node), Some(r_node), sum)\\n        };\\n\\n        Node {\\n            l_index,\\n            r_index,\\n            l_node,\\n            r_node,\\n            sum,\\n            max,\\n            index: 0,\\n        }\\n    }\\n\\n    fn merge(&mut self) {\\n        if let (Some(l_node), Some(r_node)) = (self.l_node.as_ref(), self.r_node.as_ref()) {\\n            self.sum = l_node.sum + r_node.sum;\\n            self.max = std::cmp::max(l_node.max, r_node.max);\\n        }\\n    }\\n\\n    fn take_gather(&mut self, seats: usize, max_row: usize) -> Option<(usize, usize)> {\\n        if self.max < seats || self.l_index > max_row {\\n            return None;\\n        }\\n        let mut res = None;\\n\\n        match (self.l_node.as_mut(), self.r_node.as_mut()) {\\n            (None, None) => {\\n                self.max -= seats;\\n                self.sum -= seats;\\n                res = Some((self.l_index, self.index));\\n                self.index += seats;\\n            },\\n            (Some(l_node), Some(r_node)) => {\\n                if l_node.max >= seats {\\n                    res = l_node.as_mut().take_gather(seats, max_row);\\n                } else {\\n                    res = r_node.as_mut().take_gather(seats, max_row);\\n                }\\n            }\\n            _ => unreachable!(),\\n        };\\n\\n        self.merge();\\n\\n        res\\n    }\\n\\n    fn get_sum(&self, max_row: usize) -> usize {\\n        if self.r_index <= max_row {\\n            self.sum\\n        } else if self.l_index > max_row {\\n            0\\n        } else {\\n            self.l_node.as_ref().unwrap().get_sum(max_row) + self.r_node.as_ref().unwrap().get_sum(max_row)\\n        }\\n    }\\n\\n    fn take_scatter(&mut self, seats: usize) {\\n        match (self.l_node.as_mut(), self.r_node.as_mut()) {\\n            (None, None) => {\\n                self.max -= seats;\\n                self.sum -= seats;\\n                self.index += seats;\\n            },\\n            (Some(l_node), Some(r_node)) => {\\n                let l_take = std::cmp::min(l_node.sum, seats);\\n                let r_take = seats - l_take;\\n                l_node.take_scatter(l_take);\\n                r_node.take_scatter(r_take);\\n            }\\n            _ => unreachable!(),\\n        };\\n\\n        self.merge();\\n    }\\n}\\n\\n#[derive(Debug)]\\nstruct BookMyShow {\\n    segment_tree: Node\\n}\\n\\nimpl BookMyShow {\\n    fn new(n: i32, m: i32) -> Self {\\n        BookMyShow { segment_tree: Node::build(0, n as usize - 1, m as usize) }\\n    }\\n\\n    fn gather(&mut self, k: i32, max_row: i32) -> Vec<i32> {\\n        match self.segment_tree.take_gather(k as usize, max_row as usize) {\\n            Some((row, index)) => vec![row as i32, index as i32],\\n            None => vec![],\\n        }\\n    }\\n\\n    fn scatter(&mut self, k: i32, max_row: i32) -> bool {\\n        if self.segment_tree.get_sum(max_row as usize) < k as usize {\\n            false\\n        } else {\\n            self.segment_tree.take_scatter(k as usize);\\n            true\\n        }\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::{BTreeMap, BinaryHeap, HashMap, VecDeque},\\n    rc::Rc, borrow::Borrow,\\n};\\n\\n\\n#[derive(Debug)]\\nstruct Node {\\n    // starting row index, inclusive\\n    l_index: usize,\\n    // ending row index, inclusive\\n    r_index: usize,\\n    // child node, left\\n    l_node: Option<Box<Node>>,\\n    // child node, right\\n    r_node: Option<Box<Node>>,\\n    // the total number of seat that can be allocated\\n    sum: usize,\\n    // the maximum amount of allocatable seat in a row\\n    max: usize,\\n    // the index of the first empty seat\\n    index: usize,\\n}\\n\\nimpl Node {\\n    fn build(l_index: usize, r_index: usize, max: usize) -> Node {\\n        let (l_node, r_node, sum) = if l_index == r_index {\\n            (None, None, max)\\n        } else {\\n            let m_index = (l_index + r_index) / 2;\\n            let l_node = Box::new(Node::build(l_index, m_index, max));\\n            let r_node = Box::new(Node::build(m_index + 1, r_index, max));\\n\\n            let sum = l_node.sum + r_node.sum;\\n            (Some(l_node), Some(r_node), sum)\\n        };\\n\\n        Node {\\n            l_index,\\n            r_index,\\n            l_node,\\n            r_node,\\n            sum,\\n            max,\\n            index: 0,\\n        }\\n    }\\n\\n    fn merge(&mut self) {\\n        if let (Some(l_node), Some(r_node)) = (self.l_node.as_ref(), self.r_node.as_ref()) {\\n            self.sum = l_node.sum + r_node.sum;\\n            self.max = std::cmp::max(l_node.max, r_node.max);\\n        }\\n    }\\n\\n    fn take_gather(&mut self, seats: usize, max_row: usize) -> Option<(usize, usize)> {\\n        if self.max < seats || self.l_index > max_row {\\n            return None;\\n        }\\n        let mut res = None;\\n\\n        match (self.l_node.as_mut(), self.r_node.as_mut()) {\\n            (None, None) => {\\n                self.max -= seats;\\n                self.sum -= seats;\\n                res = Some((self.l_index, self.index));\\n                self.index += seats;\\n            },\\n            (Some(l_node), Some(r_node)) => {\\n                if l_node.max >= seats {\\n                    res = l_node.as_mut().take_gather(seats, max_row);\\n                } else {\\n                    res = r_node.as_mut().take_gather(seats, max_row);\\n                }\\n            }\\n            _ => unreachable!(),\\n        };\\n\\n        self.merge();\\n\\n        res\\n    }\\n\\n    fn get_sum(&self, max_row: usize) -> usize {\\n        if self.r_index <= max_row {\\n            self.sum\\n        } else if self.l_index > max_row {\\n            0\\n        } else {\\n            self.l_node.as_ref().unwrap().get_sum(max_row) + self.r_node.as_ref().unwrap().get_sum(max_row)\\n        }\\n    }\\n\\n    fn take_scatter(&mut self, seats: usize) {\\n        match (self.l_node.as_mut(), self.r_node.as_mut()) {\\n            (None, None) => {\\n                self.max -= seats;\\n                self.sum -= seats;\\n                self.index += seats;\\n            },\\n            (Some(l_node), Some(r_node)) => {\\n                let l_take = std::cmp::min(l_node.sum, seats);\\n                let r_take = seats - l_take;\\n                l_node.take_scatter(l_take);\\n                r_node.take_scatter(r_take);\\n            }\\n            _ => unreachable!(),\\n        };\\n\\n        self.merge();\\n    }\\n}\\n\\n#[derive(Debug)]\\nstruct BookMyShow {\\n    segment_tree: Node\\n}\\n\\nimpl BookMyShow {\\n    fn new(n: i32, m: i32) -> Self {\\n        BookMyShow { segment_tree: Node::build(0, n as usize - 1, m as usize) }\\n    }\\n\\n    fn gather(&mut self, k: i32, max_row: i32) -> Vec<i32> {\\n        match self.segment_tree.take_gather(k as usize, max_row as usize) {\\n            Some((row, index)) => vec![row as i32, index as i32],\\n            None => vec![],\\n        }\\n    }\\n\\n    fn scatter(&mut self, k: i32, max_row: i32) -> bool {\\n        if self.segment_tree.get_sum(max_row as usize) < k as usize {\\n            false\\n        } else {\\n            self.segment_tree.take_scatter(k as usize);\\n            true\\n        }\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105055,
                "title": "c-solution-with-partition",
                "content": "Initially I tried brutal force solution, but I got TLE. So to make the program faster, I partitioned 200 rows into a group. We can define 256 groups (256\\\\*200 > 50000)  , which is enough for n. \\n\\nWe can define `sum_200` and `max_200` and `valids` to keep track of each group and its rows. \\n`max_200` is the maximum number of available seats in a row in this group, which is initialized as m. It is used to get the idea if gather can work in this group. \\n`sum_200` is the sum of all the valid seats in the group. So it should be initialized as `m*200`\\n`valids` is used to keep track of each row\\'s available seats. We can initialize 50005 valids since we have 50000 at most. \\n\\n```\\nclass BookMyShow {\\npublic:\\n    \\n    int max_200[256] = {0};\\n    long long sum_200[256] = {0};\\n    int valids[50005] = {0};\\n    int n, m, g;\\n    \\n    BookMyShow(int nn, int mm) {\\n        \\n        n = nn, m = mm;\\n        \\n        for (int i = 0; i < n; ++i)\\n            valids[i] = m;\\n        \\n        g = (n+199)/200;\\n        \\n        for (int i = 0; i < g; ++i)\\n        {\\n            max_200[i] = m;\\n            for (int j = 200*i; j < 200*(i+1); ++j)\\n            {\\n                sum_200[i] += static_cast<long long>(m);\\n            }\\n        }\\n    }\\n    \\n    void update(int i)\\n    {\\n        max_200[i] = 0;\\n        sum_200[i] = 0;\\n        \\n        for (int j = 200*i; j < 200*(i+1); ++j)\\n        {\\n            sum_200[i] += valids[j];\\n            max_200[i] = std::max(max_200[i], valids[j]);\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        \\n        int row = -1;\\n        for (int i = 0; i < maxRow/200+1; ++i)\\n        {\\n            if (max_200[i] >= k)\\n            {\\n                row = i;\\n                break;\\n            }\\n        }\\n        if (row == -1)  return {};\\n        \\n        for (int i = 200*row; i <= maxRow; ++i)\\n        {\\n            if (valids[i] >= k)\\n            {\\n                valids[i] -= k;\\n                update(row);\\n                return { i, m-valids[i]-k };\\n            }\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        \\n        long long sum = 0;\\n        g = maxRow/200;\\n        \\n        for (int i = 0; i < g; ++i)\\n        {\\n            sum += sum_200[i];\\n        }\\n        for (int i = 200*g; i <= maxRow; ++i)\\n        {\\n            sum += valids[i];\\n        }\\n        if (sum < k)    return false;\\n        \\n        bool isEnd = false;\\n        for (int i = 0; i < maxRow/200+1; ++i )\\n        {\\n            if (sum_200[i] == 0)\\n            {\\n                // no-op\\n            }\\n            else if (sum_200[i] < k)\\n            {\\n                k -= sum_200[i];\\n                max_200[i] = 0;\\n                sum_200[i] = 0;\\n                for (int j = 200*i; j < 200*(i+1); ++j)\\n                {\\n                    valids[j] = 0;\\n                }\\n            }\\n            else\\n            {\\n                for (int j = 200*i; j < 200*(i+1); ++j)\\n                {\\n                    if (k > valids[j])\\n                    {\\n                        k -= valids[j];\\n                        valids[j] = 0;\\n                    }\\n                    else\\n                    {\\n                        valids[j] -= k;\\n                        k = 0;\\n                        isEnd = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n                update(i);\\n            }\\n            if (isEnd)  break;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    \\n    int max_200[256] = {0};\\n    long long sum_200[256] = {0};\\n    int valids[50005] = {0};\\n    int n, m, g;\\n    \\n    BookMyShow(int nn, int mm) {\\n        \\n        n = nn, m = mm;\\n        \\n        for (int i = 0; i < n; ++i)\\n            valids[i] = m;\\n        \\n        g = (n+199)/200;\\n        \\n        for (int i = 0; i < g; ++i)\\n        {\\n            max_200[i] = m;\\n            for (int j = 200*i; j < 200*(i+1); ++j)\\n            {\\n                sum_200[i] += static_cast<long long>(m);\\n            }\\n        }\\n    }\\n    \\n    void update(int i)\\n    {\\n        max_200[i] = 0;\\n        sum_200[i] = 0;\\n        \\n        for (int j = 200*i; j < 200*(i+1); ++j)\\n        {\\n            sum_200[i] += valids[j];\\n            max_200[i] = std::max(max_200[i], valids[j]);\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        \\n        int row = -1;\\n        for (int i = 0; i < maxRow/200+1; ++i)\\n        {\\n            if (max_200[i] >= k)\\n            {\\n                row = i;\\n                break;\\n            }\\n        }\\n        if (row == -1)  return {};\\n        \\n        for (int i = 200*row; i <= maxRow; ++i)\\n        {\\n            if (valids[i] >= k)\\n            {\\n                valids[i] -= k;\\n                update(row);\\n                return { i, m-valids[i]-k };\\n            }\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        \\n        long long sum = 0;\\n        g = maxRow/200;\\n        \\n        for (int i = 0; i < g; ++i)\\n        {\\n            sum += sum_200[i];\\n        }\\n        for (int i = 200*g; i <= maxRow; ++i)\\n        {\\n            sum += valids[i];\\n        }\\n        if (sum < k)    return false;\\n        \\n        bool isEnd = false;\\n        for (int i = 0; i < maxRow/200+1; ++i )\\n        {\\n            if (sum_200[i] == 0)\\n            {\\n                // no-op\\n            }\\n            else if (sum_200[i] < k)\\n            {\\n                k -= sum_200[i];\\n                max_200[i] = 0;\\n                sum_200[i] = 0;\\n                for (int j = 200*i; j < 200*(i+1); ++j)\\n                {\\n                    valids[j] = 0;\\n                }\\n            }\\n            else\\n            {\\n                for (int j = 200*i; j < 200*(i+1); ++j)\\n                {\\n                    if (k > valids[j])\\n                    {\\n                        k -= valids[j];\\n                        valids[j] = 0;\\n                    }\\n                    else\\n                    {\\n                        valids[j] -= k;\\n                        k = 0;\\n                        isEnd = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n                update(i);\\n            }\\n            if (isEnd)  break;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773511,
                "title": "segtree-solution-using-array",
                "content": "This is implementation of segment Tree with just using array by the power of full binary tree.\\nIf we represent a full binary tree as array then left child of jth node will be at j + 1 and right child will be at j + 2 and everything becomes easier arithmetic.\\nThose concerned with wasted nodes of full binary tree, well, the order complexity does not increses. If one needed x nodes for pointer based tree(for most compact segment tree) then maximum nodes here would be 2*x-1 in the worst case. But, there would be no overhead for pointers to the child and range of coverage of the node.(as those 2 are arithmetically simple task here).\\nSo, overall memory requirement might even be less than pointer based trees.\\n```\\nclass BookMyShow {\\npublic:\\n    int r;\\n    int len;\\n    int tot;\\n    vector<pair<int, long long int> > segTree;\\n    BookMyShow(int n, int m) {\\n        tot = m;\\n        int h = ceil(log2(n));\\n        h++;                    // levels for accomodating n nodes;\\n        len = pow(2, h) - 1; // total length of vector representing seg Tree\\n        int e = (len + 1)/2;    // total no of leaf nodes >= n;\\n        segTree = vector<pair<int, long long int> >(len, {0, 0}); // pair of max and sum of left and right nodes;\\n        r = e - 1;          //pos of zeroth row;\\n        for(int j = r; j < r + n; j++) segTree[j] = {m, m};\\n        for(int j = r - 1; j >= 0; j--){\\n            segTree[j].first = max(segTree[2*j + 1].first, segTree[2*j + 2].first);\\n            segTree[j].second = segTree[2*j + 1].second + segTree[2*j + 2].second;\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        //maxRow is at position r + maxRow;\\n        int j = 0;\\n        if(segTree[j].first < k) return {};\\n        while(2*j + 2 < len) {\\n            if(segTree[2*j + 1].first >= k) j = 2*j + 1;\\n            else j = 2*j + 2;\\n        }\\n        if(j - r > maxRow) return {};\\n        vector<int> ans = {j - r, tot - segTree[j].first};\\n        segTree[j].first -= k;\\n        segTree[j].second -= k;\\n        while(j > 0) {\\n            j = (j - 1)/2;\\n            segTree[j].second -= k;\\n            segTree[j].first = max(segTree[2*j + 1].first, segTree[2*j + 2].first);\\n        }\\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int j = 0;\\n        while(2*j + 2 < len) {\\n            if(segTree[j].second < k) return false;\\n            if(segTree[2*j + 1].second >= k) j = 2*j + 1;\\n            else{\\n                k -= segTree[2*j + 1].second;\\n                j = 2*j + 2;\\n            }\\n        }\\n        if(segTree[j].second < k) return false;\\n        if(j - r > maxRow) return false;\\n        segTree[j].first -= k;\\n        while(j > 0) {\\n            segTree[j].second -= k;\\n            if(j%2 == 0) {\\n                k += segTree[j - 1].second;\\n                segTree[j - 1].first = 0;\\n                segTree[j - 1].second = 0;\\n            }\\n            j = (j - 1)/2;\\n            segTree[j].first = max(segTree[2*j + 1].first, segTree[2*j + 2].first);\\n        }\\n        segTree[0].second -= k;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n//an insane long code would be written.\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    int r;\\n    int len;\\n    int tot;\\n    vector<pair<int, long long int> > segTree;\\n    BookMyShow(int n, int m) {\\n        tot = m;\\n        int h = ceil(log2(n));\\n        h++;                    // levels for accomodating n nodes;\\n        len = pow(2, h) - 1; // total length of vector representing seg Tree\\n        int e = (len + 1)/2;    // total no of leaf nodes >= n;\\n        segTree = vector<pair<int, long long int> >(len, {0, 0}); // pair of max and sum of left and right nodes;\\n        r = e - 1;          //pos of zeroth row;\\n        for(int j = r; j < r + n; j++) segTree[j] = {m, m};\\n        for(int j = r - 1; j >= 0; j--){\\n            segTree[j].first = max(segTree[2*j + 1].first, segTree[2*j + 2].first);\\n            segTree[j].second = segTree[2*j + 1].second + segTree[2*j + 2].second;\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        //maxRow is at position r + maxRow;\\n        int j = 0;\\n        if(segTree[j].first < k) return {};\\n        while(2*j + 2 < len) {\\n            if(segTree[2*j + 1].first >= k) j = 2*j + 1;\\n            else j = 2*j + 2;\\n        }\\n        if(j - r > maxRow) return {};\\n        vector<int> ans = {j - r, tot - segTree[j].first};\\n        segTree[j].first -= k;\\n        segTree[j].second -= k;\\n        while(j > 0) {\\n            j = (j - 1)/2;\\n            segTree[j].second -= k;\\n            segTree[j].first = max(segTree[2*j + 1].first, segTree[2*j + 2].first);\\n        }\\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int j = 0;\\n        while(2*j + 2 < len) {\\n            if(segTree[j].second < k) return false;\\n            if(segTree[2*j + 1].second >= k) j = 2*j + 1;\\n            else{\\n                k -= segTree[2*j + 1].second;\\n                j = 2*j + 2;\\n            }\\n        }\\n        if(segTree[j].second < k) return false;\\n        if(j - r > maxRow) return false;\\n        segTree[j].first -= k;\\n        while(j > 0) {\\n            segTree[j].second -= k;\\n            if(j%2 == 0) {\\n                k += segTree[j - 1].second;\\n                segTree[j - 1].first = 0;\\n                segTree[j - 1].second = 0;\\n            }\\n            j = (j - 1)/2;\\n            segTree[j].first = max(segTree[2*j + 1].first, segTree[2*j + 2].first);\\n        }\\n        segTree[0].second -= k;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n//an insane long code would be written.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084239,
                "title": "segment-tree-binary-search",
                "content": "**gather** : Find the least index with value >= k\\n**scatter**: Find the range {cur,r}  whose sum is >= k and r is least\\nHere, cur denotes index till which we have made all the elements 0.\\n```\\n#define ll long long\\n#define pb push_back \\nclass BookMyShow {\\npublic:\\n   \\n    int n;\\n    int m;\\n    int x;\\n    vector<ll> A;\\n    vector<ll> tree;\\n    vector<ll> lazy;\\n    int cur=0;//this will tell us the range till which we have already made elements 0\\n    void build(int node, int start, int end)\\n\\n    {\\n    if(start == end)\\n    {\\n        // Leaf node will have a single element\\n        tree[node] = A[start];\\n        lazy[node]=A[start];\\n    }\\n    else\\n    {\\n        int mid = (start + end) / 2;\\n   \\n        build(2*node, start, mid);\\n        build(2*node+1, mid+1, end);\\n      \\n        tree[node] = tree[2*node] + tree[2*node+1];\\n        lazy[node]=max(lazy[2*node],lazy[2*node+1]);\\n    }\\n}\\n\\nvoid update(int node, int start, int end, int idx, int val)\\n{\\n    if(start == end)\\n    {\\n        // Leaf node\\n        A[idx] = val;\\n        tree[node] = val;\\n        lazy[node]=val;\\n    }\\n    else\\n    {\\n        int mid = (start + end) / 2;\\n        if(start <= idx and idx <= mid)\\n        {\\n            // If idx is in the left child, recurse on the left child\\n            update(2*node, start, mid, idx, val);\\n        }\\n        else\\n        {\\n            // if idx is in the right child, recurse on the right child\\n            update(2*node+1, mid+1, end, idx, val);\\n        }\\n        // Internal node will have the sum of both of its children\\n        tree[node] = tree[2*node] + tree[2*node+1];\\n        lazy[node]=max(lazy[2*node],lazy[2*node+1]);\\n    }\\n}\\n\\nll query(int node, int start, int end, int l, int r)\\n{\\n    if(r < start or end < l)\\n    {\\n        // range represented by a node is completely outside the given range\\n        return 0;\\n    }\\n    if(l <= start and end <= r)\\n    {\\n        // range represented by a node is completely inside the given range\\n        return tree[node];\\n    }\\n    // range represented by a node is partially inside and partially outside the given range\\n    int mid = (start + end) / 2;\\n    ll p1 = query(2*node, start, mid, l, r);\\n    ll p2 = query(2*node+1, mid+1, end, l, r);\\n    return (p1 + p2);\\n}\\n\\nll query2(int node, int start, int end, int l, int r)\\n{\\n    if(r < start or end < l)\\n    {\\n        // range represented by a node is completely outside the given range\\n        return -1;\\n    }\\n    if(l <= start and end <= r)\\n    {\\n        // range represented by a node is completely inside the given range\\n        return lazy[node];\\n    }\\n    // range represented by a node is partially inside and partially outside the given range\\n    int mid = (start + end) / 2;\\n    ll p1 = query2(2*node, start, mid, l, r);\\n    ll p2 = query2(2*node+1, mid+1, end, l, r);\\n    if(p1==-1)return p2;\\n    if(p2==-1)return p1;\\n    return max(p1,p2);\\n}\\n    BookMyShow(int N, int M) {\\n        n=N;\\n        m=M;\\n        x=m;\\n        A.assign(N,M);\\n        tree.assign(4*N,0);\\n        lazy.assign(4*N,0);\\n        build(1,0,N-1);\\n        \\n        \\n        \\n    \\n        \\n    }\\n    \\n    \\nvector<int> gather(int k, int maxRow) {\\n    \\n        \\n        int l=0;\\n        int r=n;\\n        while(l+1<r){\\n            int mid=(l+r)/2;\\n            if(query2(1,0,n-1,cur,mid)<k){\\n                l=mid;\\n            }\\n            else{\\n                r=mid;\\n            }\\n        }\\n        //if(r==n)return {};\\n        if(query2(1,0,n-1,cur,r-1)>=k){\\n            r--;\\n        }\\n        if(r>maxRow)return {};\\n        int c=m-A[r];\\n        update(1,0,n-1,r,A[r]-k);\\n        return {r,c};\\n        \\n        \\n        \\n        \\n       \\n        \\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int l=0;\\n        int r=n;\\n        \\n        while(l+1<r){\\n            int mid=(l+r)/2;\\n            //cout<<mid<<endl;\\n            //cout<<cur<<endl;\\n            //cout<<query(1,0,n-1,cur,mid)<<endl;;\\n            if(query(1,0,n-1,cur,mid)<k){\\n                l=mid;\\n            }\\n            else{\\n                r=mid;\\n            }\\n        }\\n        //cout<<r<<endl;\\n        //if(r==n)return 0;\\n        l=r;\\n        //cout<<l<<endl;\\n        if(query(1,0,n-1,cur,l-1)>=k){\\n            l--;\\n        }\\n        if(l>maxRow)return 0;\\n        ll s=(l>0)?query(1,0,n-1,cur,l-1):0;\\n        ll rem=k-s;\\n        cur=l;\\n        update(1,0,n-1,l,A[l]-rem);\\n        \\n//         for(int i=0;i<=l;i++){\\n//             if(k>A[i]){\\n//                 k-=A[i];\\n//                 update(1,0,n-1,i,0);\\n//             }\\n//             else{\\n//                 A[i]-=k;\\n//                 update(1,0,n-1,i,A[i]);\\n//             }\\n            \\n//         }\\n        \\n        \\n        \\n        \\n        \\n        \\n        return 1;\\n        \\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long\\n#define pb push_back \\nclass BookMyShow {\\npublic:\\n   \\n    int n;\\n    int m;\\n    int x;\\n    vector<ll> A;\\n    vector<ll> tree;\\n    vector<ll> lazy;\\n    int cur=0;//this will tell us the range till which we have already made elements 0\\n    void build(int node, int start, int end)\\n\\n    {\\n    if(start == end)\\n    {\\n        // Leaf node will have a single element\\n        tree[node] = A[start];\\n        lazy[node]=A[start];\\n    }\\n    else\\n    {\\n        int mid = (start + end) / 2;\\n   \\n        build(2*node, start, mid);\\n        build(2*node+1, mid+1, end);\\n      \\n        tree[node] = tree[2*node] + tree[2*node+1];\\n        lazy[node]=max(lazy[2*node],lazy[2*node+1]);\\n    }\\n}\\n\\nvoid update(int node, int start, int end, int idx, int val)\\n{\\n    if(start == end)\\n    {\\n        // Leaf node\\n        A[idx] = val;\\n        tree[node] = val;\\n        lazy[node]=val;\\n    }\\n    else\\n    {\\n        int mid = (start + end) / 2;\\n        if(start <= idx and idx <= mid)\\n        {\\n            // If idx is in the left child, recurse on the left child\\n            update(2*node, start, mid, idx, val);\\n        }\\n        else\\n        {\\n            // if idx is in the right child, recurse on the right child\\n            update(2*node+1, mid+1, end, idx, val);\\n        }\\n        // Internal node will have the sum of both of its children\\n        tree[node] = tree[2*node] + tree[2*node+1];\\n        lazy[node]=max(lazy[2*node],lazy[2*node+1]);\\n    }\\n}\\n\\nll query(int node, int start, int end, int l, int r)\\n{\\n    if(r < start or end < l)\\n    {\\n        // range represented by a node is completely outside the given range\\n        return 0;\\n    }\\n    if(l <= start and end <= r)\\n    {\\n        // range represented by a node is completely inside the given range\\n        return tree[node];\\n    }\\n    // range represented by a node is partially inside and partially outside the given range\\n    int mid = (start + end) / 2;\\n    ll p1 = query(2*node, start, mid, l, r);\\n    ll p2 = query(2*node+1, mid+1, end, l, r);\\n    return (p1 + p2);\\n}\\n\\nll query2(int node, int start, int end, int l, int r)\\n{\\n    if(r < start or end < l)\\n    {\\n        // range represented by a node is completely outside the given range\\n        return -1;\\n    }\\n    if(l <= start and end <= r)\\n    {\\n        // range represented by a node is completely inside the given range\\n        return lazy[node];\\n    }\\n    // range represented by a node is partially inside and partially outside the given range\\n    int mid = (start + end) / 2;\\n    ll p1 = query2(2*node, start, mid, l, r);\\n    ll p2 = query2(2*node+1, mid+1, end, l, r);\\n    if(p1==-1)return p2;\\n    if(p2==-1)return p1;\\n    return max(p1,p2);\\n}\\n    BookMyShow(int N, int M) {\\n        n=N;\\n        m=M;\\n        x=m;\\n        A.assign(N,M);\\n        tree.assign(4*N,0);\\n        lazy.assign(4*N,0);\\n        build(1,0,N-1);\\n        \\n        \\n        \\n    \\n        \\n    }\\n    \\n    \\nvector<int> gather(int k, int maxRow) {\\n    \\n        \\n        int l=0;\\n        int r=n;\\n        while(l+1<r){\\n            int mid=(l+r)/2;\\n            if(query2(1,0,n-1,cur,mid)<k){\\n                l=mid;\\n            }\\n            else{\\n                r=mid;\\n            }\\n        }\\n        //if(r==n)return {};\\n        if(query2(1,0,n-1,cur,r-1)>=k){\\n            r--;\\n        }\\n        if(r>maxRow)return {};\\n        int c=m-A[r];\\n        update(1,0,n-1,r,A[r]-k);\\n        return {r,c};\\n        \\n        \\n        \\n        \\n       \\n        \\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int l=0;\\n        int r=n;\\n        \\n        while(l+1<r){\\n            int mid=(l+r)/2;\\n            //cout<<mid<<endl;\\n            //cout<<cur<<endl;\\n            //cout<<query(1,0,n-1,cur,mid)<<endl;;\\n            if(query(1,0,n-1,cur,mid)<k){\\n                l=mid;\\n            }\\n            else{\\n                r=mid;\\n            }\\n        }\\n        //cout<<r<<endl;\\n        //if(r==n)return 0;\\n        l=r;\\n        //cout<<l<<endl;\\n        if(query(1,0,n-1,cur,l-1)>=k){\\n            l--;\\n        }\\n        if(l>maxRow)return 0;\\n        ll s=(l>0)?query(1,0,n-1,cur,l-1):0;\\n        ll rem=k-s;\\n        cur=l;\\n        update(1,0,n-1,l,A[l]-rem);\\n        \\n//         for(int i=0;i<=l;i++){\\n//             if(k>A[i]){\\n//                 k-=A[i];\\n//                 update(1,0,n-1,i,0);\\n//             }\\n//             else{\\n//                 A[i]-=k;\\n//                 update(1,0,n-1,i,A[i]);\\n//             }\\n            \\n//         }\\n        \\n        \\n        \\n        \\n        \\n        \\n        return 1;\\n        \\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2084070,
                "title": "java-optimized-brute-force-accepted",
                "content": "The key idea:  use lazy estimations of the max gather / scatter for each row,  to speed up the answer when not possible.\\n\\n```\\n/*\\nE.g. if 5 rows with 5 seats each, with 4 people on the first row, 2 people on the second row, and 4 people on the third row\\nbookedByRow  maxGather  maxScatter\\n 4               1           1\\n 2               3           4\\n 4               3           5\\n 0               5          10\\n 0               5          15\\n*/\\nclass BookMyShow {\\n    private int m;\\n    private int[] bookedByRow;\\n    private int[] maxGather; // contains a lazy estimation of the max gather possible for each row\\n    private long[] maxScatter; // contains a lazy estimation of the max scatter possible for each row\\n\\n    public BookMyShow(int n, int m) {\\n        this.m = m;\\n        bookedByRow = new int[n];\\n        maxGather = new int[n];\\n        Arrays.fill(maxGather, m);\\n        \\n        maxScatter = new long[n];\\n        maxScatter[0] = m;\\n        for (int i = 1; i < n; i ++) {\\n            maxScatter[i] = maxScatter[i-1] + m;\\n        }\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        if (maxGather[maxRow] < k) { // saving a lot of time here\\n            return new int[]{};\\n        }\\n        \\n        for (int i = 0; i <= maxRow; i++) {\\n            if (k <= m - bookedByRow[i]) {\\n                int[] firstSeat = {i, bookedByRow[i]};\\n                bookedByRow[i] += k;\\n                return firstSeat;\\n            }\\n        }\\n        \\n        updateMaxGather(maxRow); // if failed to find seats, maxGather was not up to date\\n        return new int[]{};\\n    }\\n    \\n    private void updateMaxGather(int maxRow) {\\n        maxGather[0] = m - bookedByRow[0];\\n        for (int i = 1; i <= maxRow; i++) {\\n            maxGather[i] = Math.max(maxGather[i-1], m - bookedByRow[i]);\\n        }\\n\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        if (maxScatter[maxRow] < k) { // saving a lot of time here\\n            return false;\\n        }\\n        \\n        if (! updateMaxScatter(k, maxRow)) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i <= maxRow && k > 0; i++) {\\n            int toRemove = (int)Math.min(m - bookedByRow[i], (long)k);\\n            bookedByRow[i] += toRemove;\\n            k -= toRemove;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    // update maxScatter until reaching k (returns true) or reaching max row (return false)\\n    private boolean updateMaxScatter(int k, int maxRow) {\\n        long maxScatterTmp = 0;\\n        for (int i = 0; i <= maxRow; i++) {\\n            maxScatterTmp += m - bookedByRow[i];\\n            maxScatter[i] = maxScatterTmp;\\n            if (maxScatterTmp >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nE.g. if 5 rows with 5 seats each, with 4 people on the first row, 2 people on the second row, and 4 people on the third row\\nbookedByRow  maxGather  maxScatter\\n 4               1           1\\n 2               3           4\\n 4               3           5\\n 0               5          10\\n 0               5          15\\n*/\\nclass BookMyShow {\\n    private int m;\\n    private int[] bookedByRow;\\n    private int[] maxGather; // contains a lazy estimation of the max gather possible for each row\\n    private long[] maxScatter; // contains a lazy estimation of the max scatter possible for each row\\n\\n    public BookMyShow(int n, int m) {\\n        this.m = m;\\n        bookedByRow = new int[n];\\n        maxGather = new int[n];\\n        Arrays.fill(maxGather, m);\\n        \\n        maxScatter = new long[n];\\n        maxScatter[0] = m;\\n        for (int i = 1; i < n; i ++) {\\n            maxScatter[i] = maxScatter[i-1] + m;\\n        }\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        if (maxGather[maxRow] < k) { // saving a lot of time here\\n            return new int[]{};\\n        }\\n        \\n        for (int i = 0; i <= maxRow; i++) {\\n            if (k <= m - bookedByRow[i]) {\\n                int[] firstSeat = {i, bookedByRow[i]};\\n                bookedByRow[i] += k;\\n                return firstSeat;\\n            }\\n        }\\n        \\n        updateMaxGather(maxRow); // if failed to find seats, maxGather was not up to date\\n        return new int[]{};\\n    }\\n    \\n    private void updateMaxGather(int maxRow) {\\n        maxGather[0] = m - bookedByRow[0];\\n        for (int i = 1; i <= maxRow; i++) {\\n            maxGather[i] = Math.max(maxGather[i-1], m - bookedByRow[i]);\\n        }\\n\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        if (maxScatter[maxRow] < k) { // saving a lot of time here\\n            return false;\\n        }\\n        \\n        if (! updateMaxScatter(k, maxRow)) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i <= maxRow && k > 0; i++) {\\n            int toRemove = (int)Math.min(m - bookedByRow[i], (long)k);\\n            bookedByRow[i] += toRemove;\\n            k -= toRemove;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    // update maxScatter until reaching k (returns true) or reaching max row (return false)\\n    private boolean updateMaxScatter(int k, int maxRow) {\\n        long maxScatterTmp = 0;\\n        for (int i = 0; i <= maxRow; i++) {\\n            maxScatterTmp += m - bookedByRow[i];\\n            maxScatter[i] = maxScatterTmp;\\n            if (maxScatterTmp >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084016,
                "title": "accepted-c-segment-tree-binary-indexed-tree",
                "content": "```\\nclass BIT{\\npublic:\\n///1-indexed\\n    int sz; ///max size of array+1\\n    vector<long long> t;\\n    void init(int n){\\n        sz = n + 2;\\n        t.assign(sz,0);\\n    }\\n    long long query(int idx){\\n        long long ans = 0;\\n        for(; idx >= 1; idx -= (idx & -idx)) ans += t[idx];\\n        return ans;\\n    }\\n    void update(int idx, long long val){\\n        if(idx <= 0) return;\\n        for(; idx <sz; idx += (idx & -idx)) t[idx] += val;\\n    }\\n    long long query(int l, int r) { return query(r) - query(l - 1); }\\n};\\n\\nclass SegmentTree{\\npublic:\\n    int sz;\\n    vector<long long> tree;\\n\\n    void init(int _sz) {\\n        sz = _sz;\\n        tree.resize(4*sz+5,0);\\n    }\\n\\n    void update(int pos, int l, int r, int idx, long long value){\\n        if(l==r && l==idx){\\n            tree[pos]+=value;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(idx>=l && idx<=mid) update(pos*2,l,mid,idx,value);\\n        if(idx>=(mid+1) && idx<=r) update(pos*2+1,mid+1,r,idx,value);\\n        tree[pos]=min(tree[pos*2], tree[pos*2+1]);\\n    }\\n\\n    long long query(int pos, int l, int r, int L, int R){\\n        if(l>=L && r<=R) return tree[pos];\\n        if(r<L || l>R) return 1e10;\\n        int mid=(l+r)>>1;\\n        long long q1=query(pos*2,l,mid,L,R);\\n        long long q2=query(pos*2+1,mid+1,r,L,R);\\n        return min(q1, q2);\\n    }\\n};\\n\\nclass BookMyShow {\\npublic:\\n    int n, m;\\n    BIT bit;\\n    SegmentTree seg;\\n    vector<int> cnt;\\n    int idx;\\n    \\n    BookMyShow(int _n, int _m) {\\n        n = _n, m = _m;\\n        bit.init(n);\\n        seg.init(n);\\n        cnt = vector<int> (n, 0);\\n        idx = 0;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int lo = 0, hi = maxRow;\\n        int index = -1;\\n        int booked = 0;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            int curCnt = seg.query(1, 1, n, 1, mid + 1);\\n            //cout << mid << \" \" << curCnt << endl;\\n            if((m - curCnt) >= k) {\\n                index = mid;\\n                booked = curCnt;\\n                hi = mid - 1;\\n            }\\n            else lo = mid + 1;\\n        }\\n        //cout << index << \" \" << booked << endl;\\n        if(index == -1) return {};\\n        seg.update(1, 1, n, index + 1, k);\\n        bit.update(index + 1, k);\\n        cnt[index] += k;\\n        return {index, booked};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long rem = ((long long)m * (maxRow + 1)) - bit.query(maxRow + 1);\\n        //cout << k << \" \" << maxRow << \" \" << rem << endl;\\n        if(rem < k) return false;\\n        \\n        while(idx <= maxRow && k) {\\n            //cout << idx << \" \" << cnt[idx] << \" \" << k << endl;\\n            if(cnt[idx] == m) {\\n                idx++;\\n                continue;\\n            }\\n            \\n            int mn = min(k, m - cnt[idx]);\\n            cnt[idx] += mn;\\n            k -= mn;\\n            seg.update(1, 1, n, idx + 1, mn);\\n            bit.update(idx + 1, mn);\\n            //cout << k << endl;\\n            if(!k) break;\\n            idx++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass BIT{\\npublic:\\n///1-indexed\\n    int sz; ///max size of array+1\\n    vector<long long> t;\\n    void init(int n){\\n        sz = n + 2;\\n        t.assign(sz,0);\\n    }\\n    long long query(int idx){\\n        long long ans = 0;\\n        for(; idx >= 1; idx -= (idx & -idx)) ans += t[idx];\\n        return ans;\\n    }\\n    void update(int idx, long long val){\\n        if(idx <= 0) return;\\n        for(; idx <sz; idx += (idx & -idx)) t[idx] += val;\\n    }\\n    long long query(int l, int r) { return query(r) - query(l - 1); }\\n};\\n\\nclass SegmentTree{\\npublic:\\n    int sz;\\n    vector<long long> tree;\\n\\n    void init(int _sz) {\\n        sz = _sz;\\n        tree.resize(4*sz+5,0);\\n    }\\n\\n    void update(int pos, int l, int r, int idx, long long value){\\n        if(l==r && l==idx){\\n            tree[pos]+=value;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(idx>=l && idx<=mid) update(pos*2,l,mid,idx,value);\\n        if(idx>=(mid+1) && idx<=r) update(pos*2+1,mid+1,r,idx,value);\\n        tree[pos]=min(tree[pos*2], tree[pos*2+1]);\\n    }\\n\\n    long long query(int pos, int l, int r, int L, int R){\\n        if(l>=L && r<=R) return tree[pos];\\n        if(r<L || l>R) return 1e10;\\n        int mid=(l+r)>>1;\\n        long long q1=query(pos*2,l,mid,L,R);\\n        long long q2=query(pos*2+1,mid+1,r,L,R);\\n        return min(q1, q2);\\n    }\\n};\\n\\nclass BookMyShow {\\npublic:\\n    int n, m;\\n    BIT bit;\\n    SegmentTree seg;\\n    vector<int> cnt;\\n    int idx;\\n    \\n    BookMyShow(int _n, int _m) {\\n        n = _n, m = _m;\\n        bit.init(n);\\n        seg.init(n);\\n        cnt = vector<int> (n, 0);\\n        idx = 0;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int lo = 0, hi = maxRow;\\n        int index = -1;\\n        int booked = 0;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n            int curCnt = seg.query(1, 1, n, 1, mid + 1);\\n            //cout << mid << \" \" << curCnt << endl;\\n            if((m - curCnt) >= k) {\\n                index = mid;\\n                booked = curCnt;\\n                hi = mid - 1;\\n            }\\n            else lo = mid + 1;\\n        }\\n        //cout << index << \" \" << booked << endl;\\n        if(index == -1) return {};\\n        seg.update(1, 1, n, index + 1, k);\\n        bit.update(index + 1, k);\\n        cnt[index] += k;\\n        return {index, booked};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long rem = ((long long)m * (maxRow + 1)) - bit.query(maxRow + 1);\\n        //cout << k << \" \" << maxRow << \" \" << rem << endl;\\n        if(rem < k) return false;\\n        \\n        while(idx <= maxRow && k) {\\n            //cout << idx << \" \" << cnt[idx] << \" \" << k << endl;\\n            if(cnt[idx] == m) {\\n                idx++;\\n                continue;\\n            }\\n            \\n            int mn = min(k, m - cnt[idx]);\\n            cnt[idx] += mn;\\n            k -= mn;\\n            seg.update(1, 1, n, idx + 1, mn);\\n            bit.update(idx + 1, mn);\\n            //cout << k << endl;\\n            if(!k) break;\\n            idx++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2083981,
                "title": "got-it-can-t-figure-out-what-s-wrong",
                "content": "Using a set and vector to keep track of seats in rows, for gather I\\'m using set, and for scatter I\\'m using vector.\\nPassing 83/94\\n```\\n#define ll long long\\nclass BookMyShow {\\npublic:\\n    vector<ll> v;\\n    set<pair<ll,ll>> s;\\n    ll r,c,in=0;\\n    BookMyShow(int n, int m) {\\n        r=n;c=m;\\n        v.resize(n);\\n        for(int i=0;i<n;i++){\\n            v[i]=m;\\n            s.insert({m,i});\\n        }\\n    }\\n    vector<int> gather(int k, int maxRow) {\\n        auto it=s.lower_bound({k,-1});\\n        if(it==s.end())return {};\\n        int row=it->second,seats=it->first;\\n        if(row>maxRow)return {};\\n        s.erase(it);\\n        s.insert({seats-k,row});\\n        int x=v[row];\\n        v[row]-=k;\\n        return {row,(int)c-x};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        ll sum=0,f=0;\\n        for(int i=in;i<=maxRow;i++){\\n            sum+=v[i];\\n            if(sum>=k){\\n                f=1;\\n                break;\\n            }\\n        }\\n        if(f==0)return 0;\\n        int i;\\n        for(i=in;i<=maxRow;i++){\\n            if(k<=v[i]){\\n                s.erase(s.find({v[i],i}));\\n                v[i]-=k;\\n                k=0;\\n                s.insert({v[i],i});\\n            }\\n            else{\\n                s.erase(s.find({v[i],i}));\\n                k-=v[i];\\n                v[i]=0;\\n            }\\n            if(k==0)break;\\n        }\\n        in=min(i,maxRow);\\n        return 1;\\n    }\\n};\\n```\\n\\nA Testcase on which it fails:\\n```\\n[\"BookMyShow\",\"gather\",\"gather\",\"gather\",\"gather\",\"gather\",\"gather\",\"gather\",\"scatter\",\"scatter\",\"gather\",\"gather\",\"gather\",\"gather\",\"gather\",\"scatter\",\"gather\",\"gather\",\"scatter\",\"gather\",\"scatter\",\"scatter\",\"scatter\",\"gather\",\"scatter\"]\\n[[25,941],[34,1],[296,21],[927,18],[695,15],[830,22],[638,2],[169,15],[623,16],[268,6],[160,16],[342,5],[22,8],[187,11],[332,24],[589,14],[87,14],[581,4],[334,14],[322,0],[511,4],[1000,3],[938,9],[19,5],[672,5]]\\n```\\nThank You",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\n#define ll long long\\nclass BookMyShow {\\npublic:\\n    vector<ll> v;\\n    set<pair<ll,ll>> s;\\n    ll r,c,in=0;\\n    BookMyShow(int n, int m) {\\n        r=n;c=m;\\n        v.resize(n);\\n        for(int i=0;i<n;i++){\\n            v[i]=m;\\n            s.insert({m,i});\\n        }\\n    }\\n    vector<int> gather(int k, int maxRow) {\\n        auto it=s.lower_bound({k,-1});\\n        if(it==s.end())return {};\\n        int row=it->second,seats=it->first;\\n        if(row>maxRow)return {};\\n        s.erase(it);\\n        s.insert({seats-k,row});\\n        int x=v[row];\\n        v[row]-=k;\\n        return {row,(int)c-x};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        ll sum=0,f=0;\\n        for(int i=in;i<=maxRow;i++){\\n            sum+=v[i];\\n            if(sum>=k){\\n                f=1;\\n                break;\\n            }\\n        }\\n        if(f==0)return 0;\\n        int i;\\n        for(i=in;i<=maxRow;i++){\\n            if(k<=v[i]){\\n                s.erase(s.find({v[i],i}));\\n                v[i]-=k;\\n                k=0;\\n                s.insert({v[i],i});\\n            }\\n            else{\\n                s.erase(s.find({v[i],i}));\\n                k-=v[i];\\n                v[i]=0;\\n            }\\n            if(k==0)break;\\n        }\\n        in=min(i,maxRow);\\n        return 1;\\n    }\\n};\\n```\n```\\n[\"BookMyShow\",\"gather\",\"gather\",\"gather\",\"gather\",\"gather\",\"gather\",\"gather\",\"scatter\",\"scatter\",\"gather\",\"gather\",\"gather\",\"gather\",\"gather\",\"scatter\",\"gather\",\"gather\",\"scatter\",\"gather\",\"scatter\",\"scatter\",\"scatter\",\"gather\",\"scatter\"]\\n[[25,941],[34,1],[296,21],[927,18],[695,15],[830,22],[638,2],[169,15],[623,16],[268,6],[160,16],[342,5],[22,8],[187,11],[332,24],[589,14],[87,14],[581,4],[334,14],[322,0],[511,4],[1000,3],[938,9],[19,5],[672,5]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633411,
                "title": "python3-queues-binary-search-1452ms-96-59",
                "content": "Submission: https://leetcode.com/submissions/detail/810371231/\\n\\nGeneral idea was to keep a queue of partial rows, but that turned out to be too slow when there were a lot of fragments to search through while gathering, so I added another queue called \"maximums\" for binary searching for a more ideal starting position and jumping past areas where there could never be a candidate. These \"maximums\" aren\\'t updated, but in the worst case that just means n unnecessary checks. In the best case (and seemingly in the average case for our tests) you\\'ll jump right to something you can use in O(logn).\\n\\n```python\\nclass BookMyShow:\\n    def __init__(self, n: int, m: int):\\n        self.n, self.m = n, m\\n        self.free_row = 0\\n        self.partial_rows = deque()\\n        self.maximums = deque()\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.m:\\n            return []\\n        lowest = self.use_lowest_partial_row(k, maxRow)\\n        if not lowest:\\n            lowest = self.use_free_row(k, maxRow)\\n        return lowest\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        found = 0\\n        found_last = found_last_i = -1\\n        for i, (row, seats_remaining) in enumerate(self.partial_rows):\\n            if row > maxRow:\\n                break\\n            found += seats_remaining\\n            found_last = seats_remaining\\n            found_last_i = i\\n            if found >= k:\\n                break\\n        k_remaining = k - min(found, k)\\n        if not self.check_free_rows(k_remaining, maxRow):\\n            return False\\n        self.use_free_rows(k_remaining)\\n        if found_last != -1:\\n            used = k - k_remaining\\n            before_last = found - found_last\\n            used_last = used - before_last\\n            last_left = found_last - used_last\\n            if last_left:\\n                for _ in range(found_last_i):\\n                    self.pop()\\n                self.partial_rows[0][1] -= used_last\\n            else:\\n                for _ in range(found_last_i+1):\\n                    self.pop()\\n        return True\\n        \\n    def push(self, row: int, seats_remaining: int) -> None:\\n        if seats_remaining:\\n            self.partial_rows.append([row, seats_remaining])\\n            self.maximums.append(max(seats_remaining, self.maximums[-1] if self.maximums else 0))\\n    \\n    def pop(self) -> List[int]:\\n        self.maximums.popleft()\\n        return self.partial_rows.popleft()\\n\\n    def use_free_row(self, k: int, maxRow: int) -> List[int]:\\n        if self.free_row > maxRow:\\n            return []\\n        self.push(self.free_row, self.m-k)\\n        ans = [self.free_row, 0]\\n        self.free_row += 1\\n        return ans\\n    \\n    def check_free_rows(self, k: int, maxRow: int) -> bool:\\n        if k == 0:\\n            return True\\n        free_rows_between = maxRow - self.free_row + 1\\n        free_seats_between = free_rows_between * self.m\\n        return free_seats_between >= k\\n    \\n    def use_free_rows(self, k: int) -> None:\\n        entire_rows_used, partial_row_used = divmod(k, self.m)\\n        self.free_row += entire_rows_used + 1\\n        self.push(self.free_row-1, self.m - partial_row_used)\\n    \\n    def use_lowest_partial_row(self, k: int, maxRow: int) -> List[int]:\\n        if not self.partial_rows or k <= 0:\\n            return []\\n        for i in range(max(bisect_left(self.maximums, k)-1, 0), len(self.partial_rows)):\\n            row, seats_remaining = self.partial_rows[i]\\n            if row > maxRow:\\n                break\\n            if seats_remaining > k:\\n                self.partial_rows[i][1] -= k\\n                return [row, self.m-seats_remaining]\\n            elif seats_remaining == k:\\n                del self.partial_rows[i]\\n                return [row, self.m-seats_remaining]\\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```python\\nclass BookMyShow:\\n    def __init__(self, n: int, m: int):\\n        self.n, self.m = n, m\\n        self.free_row = 0\\n        self.partial_rows = deque()\\n        self.maximums = deque()\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.m:\\n            return []\\n        lowest = self.use_lowest_partial_row(k, maxRow)\\n        if not lowest:\\n            lowest = self.use_free_row(k, maxRow)\\n        return lowest\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        found = 0\\n        found_last = found_last_i = -1\\n        for i, (row, seats_remaining) in enumerate(self.partial_rows):\\n            if row > maxRow:\\n                break\\n            found += seats_remaining\\n            found_last = seats_remaining\\n            found_last_i = i\\n            if found >= k:\\n                break\\n        k_remaining = k - min(found, k)\\n        if not self.check_free_rows(k_remaining, maxRow):\\n            return False\\n        self.use_free_rows(k_remaining)\\n        if found_last != -1:\\n            used = k - k_remaining\\n            before_last = found - found_last\\n            used_last = used - before_last\\n            last_left = found_last - used_last\\n            if last_left:\\n                for _ in range(found_last_i):\\n                    self.pop()\\n                self.partial_rows[0][1] -= used_last\\n            else:\\n                for _ in range(found_last_i+1):\\n                    self.pop()\\n        return True\\n        \\n    def push(self, row: int, seats_remaining: int) -> None:\\n        if seats_remaining:\\n            self.partial_rows.append([row, seats_remaining])\\n            self.maximums.append(max(seats_remaining, self.maximums[-1] if self.maximums else 0))\\n    \\n    def pop(self) -> List[int]:\\n        self.maximums.popleft()\\n        return self.partial_rows.popleft()\\n\\n    def use_free_row(self, k: int, maxRow: int) -> List[int]:\\n        if self.free_row > maxRow:\\n            return []\\n        self.push(self.free_row, self.m-k)\\n        ans = [self.free_row, 0]\\n        self.free_row += 1\\n        return ans\\n    \\n    def check_free_rows(self, k: int, maxRow: int) -> bool:\\n        if k == 0:\\n            return True\\n        free_rows_between = maxRow - self.free_row + 1\\n        free_seats_between = free_rows_between * self.m\\n        return free_seats_between >= k\\n    \\n    def use_free_rows(self, k: int) -> None:\\n        entire_rows_used, partial_row_used = divmod(k, self.m)\\n        self.free_row += entire_rows_used + 1\\n        self.push(self.free_row-1, self.m - partial_row_used)\\n    \\n    def use_lowest_partial_row(self, k: int, maxRow: int) -> List[int]:\\n        if not self.partial_rows or k <= 0:\\n            return []\\n        for i in range(max(bisect_left(self.maximums, k)-1, 0), len(self.partial_rows)):\\n            row, seats_remaining = self.partial_rows[i]\\n            if row > maxRow:\\n                break\\n            if seats_remaining > k:\\n                self.partial_rows[i][1] -= k\\n                return [row, self.m-seats_remaining]\\n            elif seats_remaining == k:\\n                del self.partial_rows[i]\\n                return [row, self.m-seats_remaining]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346075,
                "title": "runtime-1968-ms-memory-usage-38-2-mb",
                "content": "![image](https://assets.leetcode.com/users/images/b762ec07-5e91-4313-9aea-34ba085f1809_1659015844.3176827.png)\\n```\\nclass BookMyShow:\\n    from collections import defaultdict\\n    \\n    def __init__(self, n: int, m: int):\\n        self.N, self.M = n, m\\n        self.first_row = 0\\n        self.first_row_table = defaultdict(int)\\n        self.first_seats = [0] * n\\n        self.unable_value_set = set()\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.M:\\n            return []\\n        if self.first_row_table[k] > maxRow:\\n            return []\\n        for row in range(max(self.first_row, self.first_row_table[k]), min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                result = [row, self.first_seats[row]]\\n                self.first_seats[row] += k\\n                while self.first_row < self.N and self.first_seats[self.first_row] == self.M:\\n                    self.first_row += 1\\n                self.first_row_table[k] = max(self.first_row, row)\\n                row = self.first_row_table[k]\\n                while row < self.N and self.M - self.first_seats[row] < k:\\n                    row += 1\\n                self.first_row_table[k] = row                    \\n                return result\\n        return []                \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (k, maxRow) in self.unable_value_set:\\n            return False\\n        \\n        k1 = k\\n        for row in range(self.first_row, min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] > k:\\n                self.first_seats[row] += k\\n                self.first_row = row                \\n                return True\\n            elif self.M - self.first_seats[row] == k:\\n                self.first_row = row + 1\\n                return True\\n            else:\\n                k -= self.M - self.first_seats[row]\\n                \\n        self.unable_value_set.add((k1, maxRow))\\n        return False\\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BookMyShow:\\n    from collections import defaultdict\\n    \\n    def __init__(self, n: int, m: int):\\n        self.N, self.M = n, m\\n        self.first_row = 0\\n        self.first_row_table = defaultdict(int)\\n        self.first_seats = [0] * n\\n        self.unable_value_set = set()\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.M:\\n            return []\\n        if self.first_row_table[k] > maxRow:\\n            return []\\n        for row in range(max(self.first_row, self.first_row_table[k]), min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                result = [row, self.first_seats[row]]\\n                self.first_seats[row] += k\\n                while self.first_row < self.N and self.first_seats[self.first_row] == self.M:\\n                    self.first_row += 1\\n                self.first_row_table[k] = max(self.first_row, row)\\n                row = self.first_row_table[k]\\n                while row < self.N and self.M - self.first_seats[row] < k:\\n                    row += 1\\n                self.first_row_table[k] = row                    \\n                return result\\n        return []                \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (k, maxRow) in self.unable_value_set:\\n            return False\\n        \\n        k1 = k\\n        for row in range(self.first_row, min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] > k:\\n                self.first_seats[row] += k\\n                self.first_row = row                \\n                return True\\n            elif self.M - self.first_seats[row] == k:\\n                self.first_row = row + 1\\n                return True\\n            else:\\n                k -= self.M - self.first_seats[row]\\n                \\n        self.unable_value_set.add((k1, maxRow))\\n        return False\\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346053,
                "title": "runtime-2116-ms-memory-usage-37-6-mb",
                "content": "![image](https://assets.leetcode.com/users/images/429f9a2d-dfed-4fc6-9514-e9d254481a19_1659015400.9258938.png)\\n```\\nclass BookMyShow:\\n    from collections import defaultdict\\n    \\n    def __init__(self, n: int, m: int):\\n        self.N, self.M = n, m\\n        self.first_row = 0\\n        self.first_row_table = defaultdict(int)\\n        self.first_seats = [0] * n\\n        self.unable_value_set = set()\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.M:\\n            return []\\n        if self.first_row_table[k] > maxRow:\\n            return []\\n        for row in range(max(self.first_row, self.first_row_table[k]), min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                result = [row, self.first_seats[row]]\\n                self.first_seats[row] += k\\n                while self.first_row < self.N and self.first_seats[self.first_row] == self.M:\\n                    self.first_row += 1\\n                self.first_row_table[k] = max(self.first_row, row)\\n                row = self.first_row_table[k]\\n                while row < self.N and self.M - self.first_seats[row] < k:\\n                    row += 1\\n                self.first_row_table[k] = row                    \\n                return result\\n        return []                \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (k, maxRow) in self.unable_value_set:\\n            return False\\n        \\n        k1 = k\\n        for row in range(self.first_row, min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] > k:\\n                self.first_seats[row] += k\\n                self.first_row = row                \\n                return True\\n            elif self.M - self.first_seats[row] == k:\\n                self.first_row = row + 1\\n                return True\\n            else:\\n                k -= self.M - self.first_seats[row]\\n                \\n        self.unable_value_set.add((k1, maxRow))\\n        return False\\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)class BookMyShow:\\n    from collections import defaultdict\\n    \\n    def __init__(self, n: int, m: int):\\n        self.N, self.M = n, m\\n        self.first_row = 0\\n        self.first_row_table = defaultdict(int)\\n        self.first_seats = [0] * n\\n        self.unable_value_set = set()\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.M:\\n            return []\\n        if self.first_row_table[k] > maxRow:\\n            return []\\n        for row in range(max(self.first_row, self.first_row_table[k]), min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                result = [row, self.first_seats[row]]\\n                self.first_seats[row] += k\\n                while self.first_row < self.N and self.first_seats[self.first_row] == self.M:\\n                    self.first_row += 1\\n                self.first_row_table[k] = max(self.first_row, row)\\n                row = self.first_row_table[k]\\n                while row < self.N and self.M - self.first_seats[row] < k:\\n                    row += 1\\n                self.first_row_table[k] = row                    \\n                return result\\n        return []                \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (k, maxRow) in self.unable_value_set:\\n            return False\\n        \\n        k1 = k\\n        for row in range(self.first_row, min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] > k:\\n                self.first_seats[row] += k\\n                self.first_row = row                \\n                return True\\n            elif self.M - self.first_seats[row] == k:\\n                self.first_row = row + 1\\n                return True\\n            else:\\n                k -= self.M - self.first_seats[row]\\n                \\n        self.unable_value_set.add((k1, maxRow))\\n        return False\\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BookMyShow:\\n    from collections import defaultdict\\n    \\n    def __init__(self, n: int, m: int):\\n        self.N, self.M = n, m\\n        self.first_row = 0\\n        self.first_row_table = defaultdict(int)\\n        self.first_seats = [0] * n\\n        self.unable_value_set = set()\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.M:\\n            return []\\n        if self.first_row_table[k] > maxRow:\\n            return []\\n        for row in range(max(self.first_row, self.first_row_table[k]), min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                result = [row, self.first_seats[row]]\\n                self.first_seats[row] += k\\n                while self.first_row < self.N and self.first_seats[self.first_row] == self.M:\\n                    self.first_row += 1\\n                self.first_row_table[k] = max(self.first_row, row)\\n                row = self.first_row_table[k]\\n                while row < self.N and self.M - self.first_seats[row] < k:\\n                    row += 1\\n                self.first_row_table[k] = row                    \\n                return result\\n        return []                \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (k, maxRow) in self.unable_value_set:\\n            return False\\n        \\n        k1 = k\\n        for row in range(self.first_row, min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] > k:\\n                self.first_seats[row] += k\\n                self.first_row = row                \\n                return True\\n            elif self.M - self.first_seats[row] == k:\\n                self.first_row = row + 1\\n                return True\\n            else:\\n                k -= self.M - self.first_seats[row]\\n                \\n        self.unable_value_set.add((k1, maxRow))\\n        return False\\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)class BookMyShow:\\n    from collections import defaultdict\\n    \\n    def __init__(self, n: int, m: int):\\n        self.N, self.M = n, m\\n        self.first_row = 0\\n        self.first_row_table = defaultdict(int)\\n        self.first_seats = [0] * n\\n        self.unable_value_set = set()\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.M:\\n            return []\\n        if self.first_row_table[k] > maxRow:\\n            return []\\n        for row in range(max(self.first_row, self.first_row_table[k]), min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                result = [row, self.first_seats[row]]\\n                self.first_seats[row] += k\\n                while self.first_row < self.N and self.first_seats[self.first_row] == self.M:\\n                    self.first_row += 1\\n                self.first_row_table[k] = max(self.first_row, row)\\n                row = self.first_row_table[k]\\n                while row < self.N and self.M - self.first_seats[row] < k:\\n                    row += 1\\n                self.first_row_table[k] = row                    \\n                return result\\n        return []                \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (k, maxRow) in self.unable_value_set:\\n            return False\\n        \\n        k1 = k\\n        for row in range(self.first_row, min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] > k:\\n                self.first_seats[row] += k\\n                self.first_row = row                \\n                return True\\n            elif self.M - self.first_seats[row] == k:\\n                self.first_row = row + 1\\n                return True\\n            else:\\n                k -= self.M - self.first_seats[row]\\n                \\n        self.unable_value_set.add((k1, maxRow))\\n        return False\\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161577,
                "title": "simple-python-solution-o-n-sqrt-n-sqrt-decomposition",
                "content": "```\\nclass BookMyShow:\\n    def __init__(self, n: int,m: int):\\n        self.first_row = 0\\n        self.n = n\\n        self.m = m\\n        self.first_block = 0\\n        self.block_size = 200\\n        self.arr = [m] * n\\n        self.num_blocks = (n + self.block_size -1)//self.block_size\\n        self.max_blocks = [m] * self.num_blocks\\n        self.sum_blocks = [0] * self.num_blocks\\n        for i in range(n):\\n            self.sum_blocks[i//self.block_size] += m\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        for b in range(self.first_block, self.num_blocks):\\n            if self.max_blocks[b] >= k:\\n                for j in range(max(self.block_size * b, self.first_row), min(self.block_size * (b+1), maxRow+1)):\\n                    if self.arr[j] >= k:\\n                        self.arr[j] -= k\\n                        self.sum_blocks[b] -= k\\n                        self.max_blocks[b] = max(self.arr[self.block_size * b:self.block_size * (b+1)])\\n                        return [j, self.m - (self.arr[j] + k) ]\\n        return []\\n    \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (sum(self.sum_blocks[self.first_block:maxRow//self.block_size])\\n          + sum(self.arr[maxRow//self.block_size*self.block_size:maxRow+1])) < k:\\n            return False\\n        i = self.first_row\\n        ttl = 0\\n        while ttl +self.arr[i] < k:\\n            ttl += self.arr[i]\\n            i += 1\\n        self.arr[self.first_row:i] = [0]*(i-self.first_row)\\n        self.first_row = i\\n        if self.first_row < self.n:\\n            self.arr[self.first_row] -= k - ttl\\n        self.first_block = self.first_row // self.block_size\\n        self.max_blocks[self.first_block] = max(\\n            self.arr[self.first_row: (self.first_block+1) * self.block_size])\\n        self.sum_blocks[self.first_block] = sum(\\n            self.arr[self.first_row: (self.first_block+1) * self.block_size])\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow:\\n    def __init__(self, n: int,m: int):\\n        self.first_row = 0\\n        self.n = n\\n        self.m = m\\n        self.first_block = 0\\n        self.block_size = 200\\n        self.arr = [m] * n\\n        self.num_blocks = (n + self.block_size -1)//self.block_size\\n        self.max_blocks = [m] * self.num_blocks\\n        self.sum_blocks = [0] * self.num_blocks\\n        for i in range(n):\\n            self.sum_blocks[i//self.block_size] += m\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        for b in range(self.first_block, self.num_blocks):\\n            if self.max_blocks[b] >= k:\\n                for j in range(max(self.block_size * b, self.first_row), min(self.block_size * (b+1), maxRow+1)):\\n                    if self.arr[j] >= k:\\n                        self.arr[j] -= k\\n                        self.sum_blocks[b] -= k\\n                        self.max_blocks[b] = max(self.arr[self.block_size * b:self.block_size * (b+1)])\\n                        return [j, self.m - (self.arr[j] + k) ]\\n        return []\\n    \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (sum(self.sum_blocks[self.first_block:maxRow//self.block_size])\\n          + sum(self.arr[maxRow//self.block_size*self.block_size:maxRow+1])) < k:\\n            return False\\n        i = self.first_row\\n        ttl = 0\\n        while ttl +self.arr[i] < k:\\n            ttl += self.arr[i]\\n            i += 1\\n        self.arr[self.first_row:i] = [0]*(i-self.first_row)\\n        self.first_row = i\\n        if self.first_row < self.n:\\n            self.arr[self.first_row] -= k - ttl\\n        self.first_block = self.first_row // self.block_size\\n        self.max_blocks[self.first_block] = max(\\n            self.arr[self.first_row: (self.first_block+1) * self.block_size])\\n        self.sum_blocks[self.first_block] = sum(\\n            self.arr[self.first_row: (self.first_block+1) * self.block_size])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146079,
                "title": "c-segment-tree-simple-and-concise-code-readable-code",
                "content": "class BookMyShow {\\npublic:\\n\\n    int m, n;\\n    vector< long long > maxTree, sumTree;\\n    vector< int > filled;\\n    vector< int > res;\\n    \\n    void build(int it, int left, int right){\\n\\n        if(left == right){\\n            maxTree[it] = m;\\n            sumTree[it] = m;\\n            return ;\\n        }\\n        int mid = (left + right) >> 1;\\n        \\n        build(2 * it, left, mid);\\n        build(2 * it + 1, mid + 1, right);\\n        maxTree[it] = max(maxTree[2 * it], maxTree[2 * it + 1]);\\n        sumTree[it] = sumTree[2 * it] + sumTree[2 * it + 1];\\n    }\\n    \\n    void queryMax(int it, int left, int right, int &k, int maxRow){\\n        if(left > maxRow || k == 0) return;\\n        if(maxTree[it] < k) return;\\n        if(left == right){\\n            res = {left, filled[left]};\\n            filled[left] += k;\\n            maxTree[it] -= k;\\n            sumTree[it] -= k;\\n            k = 0;\\n            return;\\n        }\\n        int mid = (left + right) >> 1;\\n        \\n        queryMax(2 * it, left, mid, k, maxRow);\\n        queryMax(2 * it + 1, mid + 1, right, k, maxRow);\\n        \\n        maxTree[it] = max(maxTree[2 * it], maxTree[2 * it + 1]);\\n        sumTree[it] = sumTree[2 * it] + sumTree[2 * it + 1];\\n    }\\n    \\n    void querySum(int it, int left, int right, int &k, int maxRow){\\n        if(left > maxRow || k == 0) return ;\\n        if(right <= maxRow){\\n            auto space = min(sumTree[it], (long long)k);\\n            k -= space;\\n            return ;\\n        }\\n        int mid = (left + right) >> 1;\\n        \\n        querySum(2 * it, left, mid, k, maxRow);\\n        querySum(2 * it + 1, mid + 1, right, k, maxRow);\\n    }\\n    \\n    void updateSum(int it, int left, int right, int &k, int maxRow){\\n        if(left > maxRow || k == 0) return ;\\n        if(left == right){\\n            auto space = min(sumTree[it], (long long)k);\\n            k -= space;\\n            filled[left] += space;\\n            maxTree[it] -= space;\\n            sumTree[it] -= space;\\n            return;\\n        }\\n        int mid = (left + right) >> 1;\\n        \\n        updateSum(2 * it, left, mid, k, maxRow);\\n        updateSum(2 * it + 1, mid + 1, right, k, maxRow);\\n        \\n        maxTree[it] = max(maxTree[2 * it], maxTree[2 * it + 1]);\\n        sumTree[it] = sumTree[2 * it] + sumTree[2 * it + 1];\\n    }\\n    \\n    \\n    \\n    BookMyShow(int n, int m) {\\n        this -> m = m;\\n        this -> n = n;\\n        maxTree.resize(4 * n + 1);\\n        sumTree.resize(4 * n + 1);\\n        filled.resize(n, 0);\\n        build(1, 0, n - 1);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        res.clear();\\n        queryMax(1, 0, n - 1, k, maxRow);\\n        return res;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        auto tmp = k;\\n        querySum(1, 0, n - 1, k, maxRow);\\n        if(k > 0) return 0;\\n        \\n        updateSum(1, 0, n - 1, tmp, maxRow);\\n        return 1;\\n        \\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class BookMyShow {\\npublic:\\n\\n    int m, n;\\n    vector< long long > maxTree, sumTree;\\n    vector< int > filled;\\n    vector< int > res;\\n    \\n    void build(int it, int left, int right){\\n\\n        if(left == right){\\n            maxTree[it] = m;\\n            sumTree[it] = m;\\n            return ;\\n        }\\n        int mid = (left + right) >> 1;\\n        \\n        build(2 * it, left, mid);\\n        build(2 * it + 1, mid + 1, right);\\n        maxTree[it] = max(maxTree[2 * it], maxTree[2 * it + 1]);\\n        sumTree[it] = sumTree[2 * it] + sumTree[2 * it + 1];\\n    }\\n    \\n    void queryMax(int it, int left, int right, int &k, int maxRow){\\n        if(left > maxRow || k == 0) return;\\n        if(maxTree[it] < k) return;\\n        if(left == right){\\n            res = {left, filled[left]};\\n            filled[left] += k;\\n            maxTree[it] -= k;\\n            sumTree[it] -= k;\\n            k = 0;\\n            return;\\n        }\\n        int mid = (left + right) >> 1;\\n        \\n        queryMax(2 * it, left, mid, k, maxRow);\\n        queryMax(2 * it + 1, mid + 1, right, k, maxRow);\\n        \\n        maxTree[it] = max(maxTree[2 * it], maxTree[2 * it + 1]);\\n        sumTree[it] = sumTree[2 * it] + sumTree[2 * it + 1];\\n    }\\n    \\n    void querySum(int it, int left, int right, int &k, int maxRow){\\n        if(left > maxRow || k == 0) return ;\\n        if(right <= maxRow){\\n            auto space = min(sumTree[it], (long long)k);\\n            k -= space;\\n            return ;\\n        }\\n        int mid = (left + right) >> 1;\\n        \\n        querySum(2 * it, left, mid, k, maxRow);\\n        querySum(2 * it + 1, mid + 1, right, k, maxRow);\\n    }\\n    \\n    void updateSum(int it, int left, int right, int &k, int maxRow){\\n        if(left > maxRow || k == 0) return ;\\n        if(left == right){\\n            auto space = min(sumTree[it], (long long)k);\\n            k -= space;\\n            filled[left] += space;\\n            maxTree[it] -= space;\\n            sumTree[it] -= space;\\n            return;\\n        }\\n        int mid = (left + right) >> 1;\\n        \\n        updateSum(2 * it, left, mid, k, maxRow);\\n        updateSum(2 * it + 1, mid + 1, right, k, maxRow);\\n        \\n        maxTree[it] = max(maxTree[2 * it], maxTree[2 * it + 1]);\\n        sumTree[it] = sumTree[2 * it] + sumTree[2 * it + 1];\\n    }\\n    \\n    \\n    \\n    BookMyShow(int n, int m) {\\n        this -> m = m;\\n        this -> n = n;\\n        maxTree.resize(4 * n + 1);\\n        sumTree.resize(4 * n + 1);\\n        filled.resize(n, 0);\\n        build(1, 0, n - 1);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        res.clear();\\n        queryMax(1, 0, n - 1, k, maxRow);\\n        return res;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        auto tmp = k;\\n        querySum(1, 0, n - 1, k, maxRow);\\n        if(k > 0) return 0;\\n        \\n        updateSum(1, 0, n - 1, tmp, maxRow);\\n        return 1;\\n        \\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2129628,
                "title": "python-segment-tree",
                "content": "```\\nimport math\\nclass SegmentTree:\\n    def __init__(self, vals):\\n        n =  len(vals)\\n        self.tree_max = [0] * n + vals\\n        self.tree_sum = [0] * n + vals\\n\\n        self.vals = vals\\n        for i in range(n-1,0,-1):\\n            self.tree_max[i] = max(self.tree_max[2*i:2*i+2])\\n            self.tree_sum[i] = self.tree_sum[2*i] + self.tree_sum[2*i+1]\\n        \\n    def queryMax(self, l, r):\\n        l += len(self.vals)\\n        r += len(self.vals)\\n        ans = -math.inf\\n        while l < r:\\n            if l % 2 == 1:\\n                ans = max(ans, self.tree_max[l])\\n                l += 1\\n            \\n            if r % 2 == 1:\\n                r -= 1\\n                ans = max(ans, self.tree_max[r])\\n            l //= 2\\n            r //= 2\\n        \\n        return ans\\n\\n    def update(self, idx, val):\\n        n = len(self.vals)\\n        self.tree_max[idx + n] = val\\n        self.tree_sum[idx + n] = val\\n\\n        idx += n\\n      \\n        while idx > 1 :\\n            self.tree_sum[idx >> 1] = self.tree_sum[idx] + self.tree_sum[idx ^ 1]\\n            self.tree_max[idx >> 1] = max(self.tree_max[idx] , self.tree_max[idx ^ 1])\\n            idx >>= 1\\n            \\n    def querySum(self, l, r):\\n        l += len(self.vals)\\n        r += len(self.vals)\\n        ans = 0\\n        while l < r:\\n            #print(l, r)\\n            if l % 2 == 1:\\n                ans += self.tree_sum[l]\\n                l += 1\\n            \\n            if r % 2 == 1:\\n                r -= 1\\n                ans += self.tree_sum[r]\\n                \\n            l //= 2\\n            r //= 2\\n        return ans\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m = m\\n        self.n = n\\n        self.seg = SegmentTree([m]*n)\\n        self.startRow = 0\\n        \\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        #print(self.seg.tree_sum)\\n        res = self.seg.queryMax(0, maxRow+1)\\n        if res >= k:\\n            l = 0 \\n            r = maxRow+1\\n            while l <= r:\\n                \\n                mid = (l+r)//2\\n                if self.seg.queryMax(l, mid+1) < k:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            c =  self.m - self.seg.tree_sum[l+len(self.seg.vals)]\\n            self.seg.update(l, self.seg.tree_sum[l+len(self.seg.vals)] - k)\\n            \\n            \\n            return [l, c]\\n        return []\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        \\n        res = self.seg.querySum(self.startRow, maxRow+1)\\n        if res < k:\\n            return False\\n        i = self.startRow\\n        cur = k\\n        while cur > 0:\\n            val = self.seg.tree_sum[i+len(self.seg.vals)]\\n            self.seg.update(i,  val - min(val, cur))\\n            cur -= min(val, cur)\\n            if cur == 0:\\n                self.startRow = i\\n            i += 1\\n        \\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass SegmentTree:\\n    def __init__(self, vals):\\n        n =  len(vals)\\n        self.tree_max = [0] * n + vals\\n        self.tree_sum = [0] * n + vals\\n\\n        self.vals = vals\\n        for i in range(n-1,0,-1):\\n            self.tree_max[i] = max(self.tree_max[2*i:2*i+2])\\n            self.tree_sum[i] = self.tree_sum[2*i] + self.tree_sum[2*i+1]\\n        \\n    def queryMax(self, l, r):\\n        l += len(self.vals)\\n        r += len(self.vals)\\n        ans = -math.inf\\n        while l < r:\\n            if l % 2 == 1:\\n                ans = max(ans, self.tree_max[l])\\n                l += 1\\n            \\n            if r % 2 == 1:\\n                r -= 1\\n                ans = max(ans, self.tree_max[r])\\n            l //= 2\\n            r //= 2\\n        \\n        return ans\\n\\n    def update(self, idx, val):\\n        n = len(self.vals)\\n        self.tree_max[idx + n] = val\\n        self.tree_sum[idx + n] = val\\n\\n        idx += n\\n      \\n        while idx > 1 :\\n            self.tree_sum[idx >> 1] = self.tree_sum[idx] + self.tree_sum[idx ^ 1]\\n            self.tree_max[idx >> 1] = max(self.tree_max[idx] , self.tree_max[idx ^ 1])\\n            idx >>= 1\\n            \\n    def querySum(self, l, r):\\n        l += len(self.vals)\\n        r += len(self.vals)\\n        ans = 0\\n        while l < r:\\n            #print(l, r)\\n            if l % 2 == 1:\\n                ans += self.tree_sum[l]\\n                l += 1\\n            \\n            if r % 2 == 1:\\n                r -= 1\\n                ans += self.tree_sum[r]\\n                \\n            l //= 2\\n            r //= 2\\n        return ans\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m = m\\n        self.n = n\\n        self.seg = SegmentTree([m]*n)\\n        self.startRow = 0\\n        \\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        #print(self.seg.tree_sum)\\n        res = self.seg.queryMax(0, maxRow+1)\\n        if res >= k:\\n            l = 0 \\n            r = maxRow+1\\n            while l <= r:\\n                \\n                mid = (l+r)//2\\n                if self.seg.queryMax(l, mid+1) < k:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            c =  self.m - self.seg.tree_sum[l+len(self.seg.vals)]\\n            self.seg.update(l, self.seg.tree_sum[l+len(self.seg.vals)] - k)\\n            \\n            \\n            return [l, c]\\n        return []\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        \\n        res = self.seg.querySum(self.startRow, maxRow+1)\\n        if res < k:\\n            return False\\n        i = self.startRow\\n        cur = k\\n        while cur > 0:\\n            val = self.seg.tree_sum[i+len(self.seg.vals)]\\n            self.seg.update(i,  val - min(val, cur))\\n            cur -= min(val, cur)\\n            if cur == 0:\\n                self.startRow = i\\n            i += 1\\n        \\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108533,
                "title": "segment-tree-based-solution-approach-c",
                "content": "The problem can be solved using a standard SEGMENT TREE implementation. \\n\\n* We treat the complete grid of n rows and m columns like an array of **size n** wherein each element has a value of m , denoting that each row has m seats initially . \\n* In our segment tree we need to store 2 fields , first is the maximum value of the seats for any row i where **s<=i<=e**  & the second is the **subarray sum** for all the rows between s and e , denoting the number of seats left in all the rows between s and e. \\n* Everytime for the gather function we need to do a **binary search** and find the node denoting the minimum row with atleast k seats . If we find one , we update the result array with the required values.\\n* For the scatter function we need to simply check first whether k seats are available between s and e rows . This is again a simple query problem for subarray sum in BIT.  If this comes out to be less than k then we can\\'t allocate the seats and return false.\\n* If true , then we need to again go through the same process but just update the node seats values accordingly to perform the allocation and then return true . \\n\\n*  This problem requires a decent understanding of the BIT data structure and it\\'s implementation. I would recommend to firstly go through that if new to the BIT data structure.  \\n\\n```\\nclass BookMyShow {\\npublic:\\n    \\n    vector<pair<long long,long long>>tree;\\n    int n,m;\\n    \\n    void build(int s,int e,int node,int m){\\n        if(s==e){\\n            tree[node] = {m,m};\\n            return;\\n        }\\n            int mid = s + (e-s)/2;\\n            build(s,mid,2*node,m);\\n            build(mid+1,e,2*node + 1,m);\\n            tree[node] = {max(tree[2*node].first,tree[2*node + 1].first),tree[2*node].second\\n                +tree[2*node + 1].second};\\n    }\\n    \\n    BookMyShow(int en, int em) {\\n        n = en;\\n        m = em;\\n        tree.resize(4*n + 1);\\n        build(0,n-1,1,m);\\n    }\\n    \\n    vector<int>res;\\n    void update(int s,int e,int node,int maxr,int k){\\n        if(s>maxr)return;\\n        if(s==e){\\n            if(tree[node].second>=k){\\n                res = {s,m-(int)tree[node].first};\\n                tree[node] = {tree[node].first-k,tree[node].second-k};\\n            }\\n            return;\\n        }\\n        \\n        int mid = s + (e-s)/2;\\n        if(tree[2*node].first>=k)update(s,mid,2*node,maxr,k);\\n        else if(tree[2*node + 1].first>=k)update(mid+1,e,2*node+1,maxr,k);\\n        tree[node] = {max(tree[2*node].first,tree[2*node + 1].first),tree[2*node].second\\n                +tree[2*node + 1].second};\\n    }\\n    \\n    \\n    vector<int> gather(int k, int maxRow) {\\n        res.clear();\\n        update(0,n-1,1,maxRow,k);\\n        return res;\\n    }\\n    \\n    long long canfill(int s,int e,int node,int maxr){\\n        if(s>maxr)return 0;\\n        if(e<=maxr)return tree[node].second;\\n        \\n        int mid = s + (e-s)/2;\\n         long long l = canfill(s,mid,2*node,maxr);\\n         long long r = canfill(mid+1,e,2*node+1,maxr);\\n        return l + r;\\n    }\\n    \\n    void updatescatter(int s,int e,int node,int maxr,int k){\\n        if(k<=0)return;\\n        if(s>maxr)return;\\n        if(s==e){\\n            tree[node].second -= k;\\n            tree[node].first = tree[node].second;\\n            return;\\n        }\\n        \\n        int mid = s + (e-s)/2;\\n        long long left =  min((long long)k,tree[2*node].second);\\n        long long right = max((long long)0,k-left);\\n        updatescatter(s,mid,2*node,maxr,left);\\n        updatescatter(mid+1,e,2*node + 1,maxr,right);\\n        tree[node] = {max(tree[2*node].first,tree[2*node + 1].first),tree[2*node].second\\n                +tree[2*node + 1].second};\\n    }\\n    \\n    \\n    bool scatter(int k, int maxRow) {\\n        if(k>canfill(0,n-1,1,maxRow))return false;\\n        updatescatter(0,n-1,1,maxRow,k);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    \\n    vector<pair<long long,long long>>tree;\\n    int n,m;\\n    \\n    void build(int s,int e,int node,int m){\\n        if(s==e){\\n            tree[node] = {m,m};\\n            return;\\n        }\\n            int mid = s + (e-s)/2;\\n            build(s,mid,2*node,m);\\n            build(mid+1,e,2*node + 1,m);\\n            tree[node] = {max(tree[2*node].first,tree[2*node + 1].first),tree[2*node].second\\n                +tree[2*node + 1].second};\\n    }\\n    \\n    BookMyShow(int en, int em) {\\n        n = en;\\n        m = em;\\n        tree.resize(4*n + 1);\\n        build(0,n-1,1,m);\\n    }\\n    \\n    vector<int>res;\\n    void update(int s,int e,int node,int maxr,int k){\\n        if(s>maxr)return;\\n        if(s==e){\\n            if(tree[node].second>=k){\\n                res = {s,m-(int)tree[node].first};\\n                tree[node] = {tree[node].first-k,tree[node].second-k};\\n            }\\n            return;\\n        }\\n        \\n        int mid = s + (e-s)/2;\\n        if(tree[2*node].first>=k)update(s,mid,2*node,maxr,k);\\n        else if(tree[2*node + 1].first>=k)update(mid+1,e,2*node+1,maxr,k);\\n        tree[node] = {max(tree[2*node].first,tree[2*node + 1].first),tree[2*node].second\\n                +tree[2*node + 1].second};\\n    }\\n    \\n    \\n    vector<int> gather(int k, int maxRow) {\\n        res.clear();\\n        update(0,n-1,1,maxRow,k);\\n        return res;\\n    }\\n    \\n    long long canfill(int s,int e,int node,int maxr){\\n        if(s>maxr)return 0;\\n        if(e<=maxr)return tree[node].second;\\n        \\n        int mid = s + (e-s)/2;\\n         long long l = canfill(s,mid,2*node,maxr);\\n         long long r = canfill(mid+1,e,2*node+1,maxr);\\n        return l + r;\\n    }\\n    \\n    void updatescatter(int s,int e,int node,int maxr,int k){\\n        if(k<=0)return;\\n        if(s>maxr)return;\\n        if(s==e){\\n            tree[node].second -= k;\\n            tree[node].first = tree[node].second;\\n            return;\\n        }\\n        \\n        int mid = s + (e-s)/2;\\n        long long left =  min((long long)k,tree[2*node].second);\\n        long long right = max((long long)0,k-left);\\n        updatescatter(s,mid,2*node,maxr,left);\\n        updatescatter(mid+1,e,2*node + 1,maxr,right);\\n        tree[node] = {max(tree[2*node].first,tree[2*node + 1].first),tree[2*node].second\\n                +tree[2*node + 1].second};\\n    }\\n    \\n    \\n    bool scatter(int k, int maxRow) {\\n        if(k>canfill(0,n-1,1,maxRow))return false;\\n        updatescatter(0,n-1,1,maxRow,k);\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106782,
                "title": "fairly-straightforward-segment-tree-solution-with-explanation",
                "content": "To solve this problem, we need to be able:\\n1. Quickly check if there is a single row with enough seats to \"gather\".\\n2. Quickly check if there are multiple consecutive rows with enough seats to \"scatter\".\\n3. Be able to reserve seats.\\n\\nAll these operations are supported by the segment tree. A segment tree is a binary tree where leaf nodes correspond to non-aggregated items (the input) while the parent nodes store aggregated data (`min()`, `max()`, `sum()` of leaf nodes). In our case we need `max()` and `sum()` aggregations:\\n* A segment tree that sums free row seats can answer whether we can \"scatter\". We always scatter from the first row that has at least 1 available seat, so we can maintain an index of such a row, and increment it when the row has been completely booked i.e. deleted.\\n* A segment tree that takes maximum of row seats can answer whether a subtree has at least one row with at least k available seats. We can run a binary search to get the row ID. If both subtrees have a row with enough seats, we prefer the left one because it has lower indices, which we should prefer according to the problem definition.\\n* Both segment trees support mutation of a single row in a O(log n) time. Update the leaf node first, then synchronize all dependent parent nodes.\\n\\n```rust\\nstruct BookMyShow {\\n    m: usize,\\n    // scatter() books seats from the beginning,\\n    // so the first row is the one that has > 0 seats\\n    // given the deleted rows count, we get the first non-deleted row to start scattering\\n    deleted: usize,\\n    tree: SegTree,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl BookMyShow {\\n\\n    fn new(n: i32, m: i32) -> Self {\\n        let n = n as usize; // rows\\n        let m = m as usize; // seats\\n        \\n        BookMyShow {\\n            m,\\n            deleted: 0, // no rows have been deleted (completely booked)\\n            tree: SegTree::new(n, m),\\n        }\\n    }\\n    \\n    // O(log n)\\n    fn gather(&mut self, k: i32, max_row: i32) -> Vec<i32> {\\n        let k = k as usize;\\n        let max_row = max_row as usize;\\n        \\n        if self.m < k {\\n            return vec![];\\n        }\\n\\n        if let Some(row) = self.tree.max(k, max_row) { // O(log n)\\n            let free = self.tree.get(row); // O(1)\\n            self.reserve_seats(row, free, k); // O(log n)\\n            vec![row as i32, (self.m - free) as i32]\\n        } else {\\n            vec![]\\n        }\\n    }\\n    \\n    // O(log n)\\n    // O(mn log n) in total if k = 1 because there will be m * n calls to this method\\n    // the higher k the better. If k = m, then the running time is O(n log n)\\n    fn scatter(&mut self, k: i32, max_row: i32) -> bool {\\n        let mut k = k as usize;\\n        let max_row = max_row as usize;\\n        \\n        if self.m * (max_row + 1) < k {\\n            return false;\\n        }\\n        \\n        // O(log n)\\n        let free = self.tree.sum(max_row);\\n        if free < k {\\n            return false;\\n        }\\n\\n        // O(log n)\\n        // if k <= free, there will be one tree update, so O(log n)\\n        // if k > free, a row is \"deleted\" and excluded from futher scatter() calls\\n        // there can be deleted at most n rows, after which this part of code can\\'t be reached\\n        while k > 0 {\\n            let free = self.tree.get(self.deleted); // O(1)\\n            let to_delete = k.min(free);\\n            self.reserve_seats(self.deleted, free, to_delete); // O(log n)\\n            k -= to_delete;\\n        }\\n        \\n        true\\n    }\\n\\n    // O(log n)\\n    fn reserve_seats(&mut self, row: usize, free: usize, seats: usize) {\\n        self.tree.set(row, free - seats); // O(log n)\\n        if free - seats == 0 {\\n            self.deleted += 1;\\n        }\\n    }\\n}\\n\\n#[derive(Debug)]\\nstruct SegTree {\\n    /// The number of input elements + zero padding. A power of two.\\n    n: usize,\\n    /// The first leaf index.\\n    offset: usize,\\n    sum_tree: Vec<usize>,\\n    max_tree: Vec<usize>,\\n}\\n\\nimpl SegTree {\\n    // O(n)\\n    fn new(n: usize, m: usize) -> SegTree {\\n        // the closest to n power of two to build up a binary tree\\n        let degree = (n as f64).log2().ceil() as u32;\\n        // the number of the leaves in the segment tree with zero padding\\n        // e.g. 3 -> 4, 6 -> 8, 11 -> 16\\n        let leaves = 2_usize.pow(degree);\\n        // tree nodes (excluding leaves) take up n - 1 space\\n        let tree_size = 2 * leaves - 1;\\n        // index of the first leaf\\n        let offset = leaves - 1;\\n\\n        let mut sum_tree = vec![0; tree_size];\\n        let mut max_tree = vec![0; tree_size];\\n        // fill leaves\\n        for i in offset..(offset + n) {\\n            sum_tree[i] = m;\\n            max_tree[i] = m;\\n        }\\n        // updates nodes\\n        for i in (0..offset).rev() {\\n            sum_tree[i] = sum_tree[i * 2 + 1] + sum_tree[i * 2 + 2];\\n            max_tree[i] = max_tree[i * 2 + 1].max(max_tree[i * 2 + 2]);\\n        }\\n\\n        SegTree {\\n            n: leaves,\\n            offset,\\n            sum_tree,\\n            max_tree,\\n        }\\n    }\\n    \\n    // O(log n)\\n    fn set(&mut self, mut i: usize, value: usize) {\\n        i += self.offset;\\n        \\n        self.sum_tree[i] = value;\\n        self.max_tree[i] = value;\\n\\n        // update dependent nodes\\n        while i > 0 {\\n            i = (i - 1) / 2;\\n            self.sum_tree[i] = self.sum_tree[i * 2 + 1] + self.sum_tree[i * 2 + 2];\\n            self.max_tree[i] = self.max_tree[i * 2 + 1].max(self.max_tree[i * 2 + 2]);\\n        }\\n    }\\n    \\n    // O(1)\\n    fn get(&self, i: usize) -> usize {\\n        self.sum_tree[self.offset + i]\\n    }\\n\\n    // O(log n)\\n    fn sum(&self, max_row: usize) -> usize {\\n        fn recurse(tree: &[usize], node: usize, i: usize, j: usize, rng_i: usize, rng_j: usize) -> usize {\\n            if j - i == rng_j - rng_i {\\n                return tree[node];\\n            }\\n\\n            let half = (i + j) / 2;\\n            let left = if rng_i < half {\\n                recurse(tree, node * 2 + 1, i, half, rng_i, rng_j.min(half))\\n            } else {\\n                0\\n            };\\n            let right = if rng_j > half {\\n                recurse(tree, node * 2 + 2, half, j, rng_i.max(half), rng_j)\\n            } else {\\n                0\\n            };\\n\\n            left + right\\n        }\\n\\n        recurse(&self.sum_tree, 0, 0, self.n, 0, max_row + 1)\\n    }\\n\\n    // O(log n)\\n    /// Find an index of the least free row that can accomodate [k] more seats.\\n    /// Recursively:\\n    /// 1. Pick either left or right subtree based on max free seats count. If the left subtree has enough seats, we don\\'t need to check the right one because the left one has lower rows, which we should prefer. Otherwise, we skip the left one and check the right subtree. This test is done in O(1) time.\\n    /// 2. Continue picking subtrees O(log n) times until a node with the lowest index is found.\\n    fn max(&self, k: usize, max_row: usize) -> Option<usize> {\\n        fn recurse(tree: &[usize], offset: usize, k: usize, node: usize, i: usize, j: usize, rng_i: usize, rng_j: usize) -> Option<usize> {\\n            if tree[node] < k {\\n                return None;\\n            }\\n            if node >= offset {\\n                return Some(node);\\n            }\\n\\n            let half = (i + j) / 2;\\n            \\n            let left = if rng_i < half {\\n                recurse(tree, offset, k, node * 2 + 1, i, half, rng_i, rng_j.min(half))\\n            } else {\\n                None\\n            };\\n            if left.is_some() {\\n                return left;\\n            }\\n\\n            let right = if rng_j > half {\\n                recurse(tree, offset, k, node * 2 + 2, half, j, rng_i.max(half), rng_j)\\n            } else {\\n                None\\n            };\\n\\n            right\\n        }\\n\\n        recurse(&self.max_tree, self.offset, k, 0, 0, self.n, 0, max_row + 1)\\n            .map(|i| i - self.offset) // convert to external non-tree index\\n    }\\n}\\n```\\n\\nThe segment tree is stored as an array where the `k`th parent node corresponds to `2 * k + 1` and `2 * k + 2` children. The root is at the index `0`.",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nstruct BookMyShow {\\n    m: usize,\\n    // scatter() books seats from the beginning,\\n    // so the first row is the one that has > 0 seats\\n    // given the deleted rows count, we get the first non-deleted row to start scattering\\n    deleted: usize,\\n    tree: SegTree,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl BookMyShow {\\n\\n    fn new(n: i32, m: i32) -> Self {\\n        let n = n as usize; // rows\\n        let m = m as usize; // seats\\n        \\n        BookMyShow {\\n            m,\\n            deleted: 0, // no rows have been deleted (completely booked)\\n            tree: SegTree::new(n, m),\\n        }\\n    }\\n    \\n    // O(log n)\\n    fn gather(&mut self, k: i32, max_row: i32) -> Vec<i32> {\\n        let k = k as usize;\\n        let max_row = max_row as usize;\\n        \\n        if self.m < k {\\n            return vec![];\\n        }\\n\\n        if let Some(row) = self.tree.max(k, max_row) { // O(log n)\\n            let free = self.tree.get(row); // O(1)\\n            self.reserve_seats(row, free, k); // O(log n)\\n            vec![row as i32, (self.m - free) as i32]\\n        } else {\\n            vec![]\\n        }\\n    }\\n    \\n    // O(log n)\\n    // O(mn log n) in total if k = 1 because there will be m * n calls to this method\\n    // the higher k the better. If k = m, then the running time is O(n log n)\\n    fn scatter(&mut self, k: i32, max_row: i32) -> bool {\\n        let mut k = k as usize;\\n        let max_row = max_row as usize;\\n        \\n        if self.m * (max_row + 1) < k {\\n            return false;\\n        }\\n        \\n        // O(log n)\\n        let free = self.tree.sum(max_row);\\n        if free < k {\\n            return false;\\n        }\\n\\n        // O(log n)\\n        // if k <= free, there will be one tree update, so O(log n)\\n        // if k > free, a row is \"deleted\" and excluded from futher scatter() calls\\n        // there can be deleted at most n rows, after which this part of code can\\'t be reached\\n        while k > 0 {\\n            let free = self.tree.get(self.deleted); // O(1)\\n            let to_delete = k.min(free);\\n            self.reserve_seats(self.deleted, free, to_delete); // O(log n)\\n            k -= to_delete;\\n        }\\n        \\n        true\\n    }\\n\\n    // O(log n)\\n    fn reserve_seats(&mut self, row: usize, free: usize, seats: usize) {\\n        self.tree.set(row, free - seats); // O(log n)\\n        if free - seats == 0 {\\n            self.deleted += 1;\\n        }\\n    }\\n}\\n\\n#[derive(Debug)]\\nstruct SegTree {\\n    /// The number of input elements + zero padding. A power of two.\\n    n: usize,\\n    /// The first leaf index.\\n    offset: usize,\\n    sum_tree: Vec<usize>,\\n    max_tree: Vec<usize>,\\n}\\n\\nimpl SegTree {\\n    // O(n)\\n    fn new(n: usize, m: usize) -> SegTree {\\n        // the closest to n power of two to build up a binary tree\\n        let degree = (n as f64).log2().ceil() as u32;\\n        // the number of the leaves in the segment tree with zero padding\\n        // e.g. 3 -> 4, 6 -> 8, 11 -> 16\\n        let leaves = 2_usize.pow(degree);\\n        // tree nodes (excluding leaves) take up n - 1 space\\n        let tree_size = 2 * leaves - 1;\\n        // index of the first leaf\\n        let offset = leaves - 1;\\n\\n        let mut sum_tree = vec![0; tree_size];\\n        let mut max_tree = vec![0; tree_size];\\n        // fill leaves\\n        for i in offset..(offset + n) {\\n            sum_tree[i] = m;\\n            max_tree[i] = m;\\n        }\\n        // updates nodes\\n        for i in (0..offset).rev() {\\n            sum_tree[i] = sum_tree[i * 2 + 1] + sum_tree[i * 2 + 2];\\n            max_tree[i] = max_tree[i * 2 + 1].max(max_tree[i * 2 + 2]);\\n        }\\n\\n        SegTree {\\n            n: leaves,\\n            offset,\\n            sum_tree,\\n            max_tree,\\n        }\\n    }\\n    \\n    // O(log n)\\n    fn set(&mut self, mut i: usize, value: usize) {\\n        i += self.offset;\\n        \\n        self.sum_tree[i] = value;\\n        self.max_tree[i] = value;\\n\\n        // update dependent nodes\\n        while i > 0 {\\n            i = (i - 1) / 2;\\n            self.sum_tree[i] = self.sum_tree[i * 2 + 1] + self.sum_tree[i * 2 + 2];\\n            self.max_tree[i] = self.max_tree[i * 2 + 1].max(self.max_tree[i * 2 + 2]);\\n        }\\n    }\\n    \\n    // O(1)\\n    fn get(&self, i: usize) -> usize {\\n        self.sum_tree[self.offset + i]\\n    }\\n\\n    // O(log n)\\n    fn sum(&self, max_row: usize) -> usize {\\n        fn recurse(tree: &[usize], node: usize, i: usize, j: usize, rng_i: usize, rng_j: usize) -> usize {\\n            if j - i == rng_j - rng_i {\\n                return tree[node];\\n            }\\n\\n            let half = (i + j) / 2;\\n            let left = if rng_i < half {\\n                recurse(tree, node * 2 + 1, i, half, rng_i, rng_j.min(half))\\n            } else {\\n                0\\n            };\\n            let right = if rng_j > half {\\n                recurse(tree, node * 2 + 2, half, j, rng_i.max(half), rng_j)\\n            } else {\\n                0\\n            };\\n\\n            left + right\\n        }\\n\\n        recurse(&self.sum_tree, 0, 0, self.n, 0, max_row + 1)\\n    }\\n\\n    // O(log n)\\n    /// Find an index of the least free row that can accomodate [k] more seats.\\n    /// Recursively:\\n    /// 1. Pick either left or right subtree based on max free seats count. If the left subtree has enough seats, we don\\'t need to check the right one because the left one has lower rows, which we should prefer. Otherwise, we skip the left one and check the right subtree. This test is done in O(1) time.\\n    /// 2. Continue picking subtrees O(log n) times until a node with the lowest index is found.\\n    fn max(&self, k: usize, max_row: usize) -> Option<usize> {\\n        fn recurse(tree: &[usize], offset: usize, k: usize, node: usize, i: usize, j: usize, rng_i: usize, rng_j: usize) -> Option<usize> {\\n            if tree[node] < k {\\n                return None;\\n            }\\n            if node >= offset {\\n                return Some(node);\\n            }\\n\\n            let half = (i + j) / 2;\\n            \\n            let left = if rng_i < half {\\n                recurse(tree, offset, k, node * 2 + 1, i, half, rng_i, rng_j.min(half))\\n            } else {\\n                None\\n            };\\n            if left.is_some() {\\n                return left;\\n            }\\n\\n            let right = if rng_j > half {\\n                recurse(tree, offset, k, node * 2 + 2, half, j, rng_i.max(half), rng_j)\\n            } else {\\n                None\\n            };\\n\\n            right\\n        }\\n\\n        recurse(&self.max_tree, self.offset, k, 0, 0, self.n, 0, max_row + 1)\\n            .map(|i| i - self.offset) // convert to external non-tree index\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2100371,
                "title": "python-o-nlogn-segment-tree",
                "content": "We use a segment tree to store how many seats are available in each row, use *maxv* and *s* to record max value and sum in range.\\n```\\nclass SegmentTree(object):\\n\\n    def __init__(self, arr):\\n        super().__init__()\\n        self.n = len(arr)\\n        self.maxv, self.s = [0] * (4 * self.n), [0] * (4 * self.n)\\n        self.build(arr, 1, 0, self.n - 1)\\n\\n    def build(self, arr, v, tl, tr):\\n        if tl == tr: self.maxv[v] = self.s[v] = arr[tl]\\n        else:\\n            tm = (tl + tr) // 2\\n            self.build(arr, v << 1, tl, tm)\\n            self.build(arr, v << 1 | 1, tm + 1, tr)\\n            self.maxv[v] = max(self.maxv[v << 1], self.maxv[v << 1 | 1])\\n            self.s[v] = self.s[v << 1] + self.s[v << 1 | 1]\\n\\n    def update(self, v, tl, tr, pos, val):\\n        if tl == tr: self.maxv[v] = self.s[v] = val\\n        else:\\n            tm = (tl + tr) // 2\\n            if pos <= tm: self.update(v << 1, tl, tm, pos, val)\\n            else: self.update(v << 1 | 1, tm + 1, tr, pos, val)\\n            self.maxv[v] = max(self.maxv[v << 1], self.maxv[v << 1 | 1])\\n            self.s[v] = self.s[v << 1] + self.s[v << 1 | 1]\\n\\n    def query_left(self, v, tl, tr, l, r, x):\\n        if tl > r or tr < l: return -1\\n        if l <= tl and tr <= r:\\n            if self.maxv[v] < x: return -1\\n            while tl != tr:\\n                tm = (tl + tr) // 2\\n                if self.maxv[v << 1] >= x:\\n                    v <<= 1\\n                    tr = tm\\n                else:\\n                    v = v << 1 | 1\\n                    tl = tm + 1\\n            return tl\\n        tm = (tl + tr) // 2\\n        rs = self.query_left(v << 1, tl, tm, l, r, x)\\n        if rs != -1: return rs\\n        return self.query_left(v << 1 | 1, tm + 1, tr, l, r, x)\\n    \\n    def query_sum(self, v, tl, tr, l, r):\\n        if l > r: return 0\\n        if l == tl and r == tr: return self.s[v]\\n        tm = (tl + tr) // 2\\n        return self.query_sum(v << 1, tl, tm, l, min(r, tm)) + self.query_sum(v << 1 | 1, tm + 1, tr, max(l, tm + 1), r)\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m, self.n, self.cur = m, n, 0\\n        self.left = [m] * n\\n        self.seg = SegmentTree(self.left)\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        idx = self.seg.query_left(1, 0, self.n - 1, 0, maxRow, k)\\n        if idx == -1: return []\\n        seats = self.m - self.left[idx]\\n        self.left[idx] -= k\\n        self.seg.update(1, 0, self.n - 1, idx, self.left[idx])\\n        return [idx, seats]\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        s = self.seg.query_sum(1, 0, self.n - 1, 0, maxRow)\\n        if self.seg.query_sum(1, 0, self.n - 1, 0, maxRow) < k: return False\\n        while k > 0:\\n            ocp = min(k, self.left[self.cur])\\n            self.left[self.cur] -= ocp\\n            k -= ocp\\n            self.seg.update(1, 0, self.n - 1, self.cur, self.left[self.cur])\\n            if self.left[self.cur] == 0: self.cur += 1\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree(object):\\n\\n    def __init__(self, arr):\\n        super().__init__()\\n        self.n = len(arr)\\n        self.maxv, self.s = [0] * (4 * self.n), [0] * (4 * self.n)\\n        self.build(arr, 1, 0, self.n - 1)\\n\\n    def build(self, arr, v, tl, tr):\\n        if tl == tr: self.maxv[v] = self.s[v] = arr[tl]\\n        else:\\n            tm = (tl + tr) // 2\\n            self.build(arr, v << 1, tl, tm)\\n            self.build(arr, v << 1 | 1, tm + 1, tr)\\n            self.maxv[v] = max(self.maxv[v << 1], self.maxv[v << 1 | 1])\\n            self.s[v] = self.s[v << 1] + self.s[v << 1 | 1]\\n\\n    def update(self, v, tl, tr, pos, val):\\n        if tl == tr: self.maxv[v] = self.s[v] = val\\n        else:\\n            tm = (tl + tr) // 2\\n            if pos <= tm: self.update(v << 1, tl, tm, pos, val)\\n            else: self.update(v << 1 | 1, tm + 1, tr, pos, val)\\n            self.maxv[v] = max(self.maxv[v << 1], self.maxv[v << 1 | 1])\\n            self.s[v] = self.s[v << 1] + self.s[v << 1 | 1]\\n\\n    def query_left(self, v, tl, tr, l, r, x):\\n        if tl > r or tr < l: return -1\\n        if l <= tl and tr <= r:\\n            if self.maxv[v] < x: return -1\\n            while tl != tr:\\n                tm = (tl + tr) // 2\\n                if self.maxv[v << 1] >= x:\\n                    v <<= 1\\n                    tr = tm\\n                else:\\n                    v = v << 1 | 1\\n                    tl = tm + 1\\n            return tl\\n        tm = (tl + tr) // 2\\n        rs = self.query_left(v << 1, tl, tm, l, r, x)\\n        if rs != -1: return rs\\n        return self.query_left(v << 1 | 1, tm + 1, tr, l, r, x)\\n    \\n    def query_sum(self, v, tl, tr, l, r):\\n        if l > r: return 0\\n        if l == tl and r == tr: return self.s[v]\\n        tm = (tl + tr) // 2\\n        return self.query_sum(v << 1, tl, tm, l, min(r, tm)) + self.query_sum(v << 1 | 1, tm + 1, tr, max(l, tm + 1), r)\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m, self.n, self.cur = m, n, 0\\n        self.left = [m] * n\\n        self.seg = SegmentTree(self.left)\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        idx = self.seg.query_left(1, 0, self.n - 1, 0, maxRow, k)\\n        if idx == -1: return []\\n        seats = self.m - self.left[idx]\\n        self.left[idx] -= k\\n        self.seg.update(1, 0, self.n - 1, idx, self.left[idx])\\n        return [idx, seats]\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        s = self.seg.query_sum(1, 0, self.n - 1, 0, maxRow)\\n        if self.seg.query_sum(1, 0, self.n - 1, 0, maxRow) < k: return False\\n        while k > 0:\\n            ocp = min(k, self.left[self.cur])\\n            self.left[self.cur] -= ocp\\n            k -= ocp\\n            self.seg.update(1, 0, self.n - 1, self.cur, self.left[self.cur])\\n            if self.left[self.cur] == 0: self.cur += 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088914,
                "title": "go-segment-tree-with-comments",
                "content": "Full credit to: [stilleholz](https://leetcode.com/stilleholz)\\'s solution here - [[Python] Segment tree, beats 100 % with explanation](https://leetcode.com/problems/booking-concert-tickets-in-groups/discuss/2085084/Python-Segment-tree-beats-100-with-explanation)\\n\\nI ported this code from Python and made a few modifications to make the Segment Tree a little bit more generic for universal use. I moved some of the functionality of the original code outside the Segment Tree, so that the Segment Tree itself is very basic.\\n\\nThis is my first time implementing Segment Tree in Go, comments are welcome\\n\\n```\\n// node of the segment tree\\ntype Node struct {\\n    left   *Node    // lower segments ie < right    \\n    right  *Node    // upper segments ie > left\\n    start  int      // segment boundary\\n    end    int      // segment boundary\\n    total  int      // total # of seats in this segment\\n    max    int      // max # of open seats in this segment\\n}\\n\\nfunc NewNode(start, end int) *Node {\\n    return &Node{nil, nil, start, end, -1, math.MinInt32}\\n}\\n\\n// build returns a Node for the given range and builds up the segment ranges\\n// start    - start of range\\n// end      - end of range\\n// value    - seats per row \\nfunc build(start, end, value int) *Node {\\n    if start > end {\\n        return nil\\n    }\\n    // only 1 node\\n    if start == end {\\n        node := NewNode(start, end)\\n        node.total, node.max = value, value\\n        return node\\n    }\\n    // split the range in half\\n    node := NewNode(start, end)\\n    mid := (start + end) / 2\\n    \\n    // recursively build the range of the tree\\n    node.left = build(start, mid, value)\\n    node.right = build(mid+1,end, value)\\n    \\n    // update the total and max for each range\\n    node.total = node.left.total + node.right.total\\n    node.max = max(node.left.max, node.right.max)\\n    \\n    return node\\n}\\n\\nfunc updateNode(node *Node, index, value int) {\\n    if node.start == index && node.end == index {\\n        node.total = value\\n        node.max = value\\n        return\\n    }\\n    // binary search\\n    mid := node.start + (node.end - node.start)/2\\n    if index <= mid {\\n        updateNode(node.left, index, value)\\n    } else {\\n        updateNode(node.right, index, value)\\n    }\\n    // update the max and the total\\n    node.max = max(node.left.max, node.right.max)\\n    node.total = node.left.total + node.right.total\\n}\\n\\nfunc maxQuery(node *Node, limit int) *Node {\\n    if node.start == node.end {\\n        return node\\n    }\\n    \\n    if limit <= node.left.max {\\n        return maxQuery(node.left, limit)\\n    }\\n    \\n    return maxQuery(node.right, limit)\\n}\\n\\nfunc sumQuery(node *Node, start int, end int) int {\\n    \\n    // if our window is in the node\\'s segment\\n    if start == node.start && end == node.end {\\n        return node.total\\n    }\\n    // otherwise binary search\\n    mid := (node.start + node.end) / 2\\n    if end <= mid {\\n        return sumQuery(node.left, start, end)\\n    } else if start > mid {\\n        return sumQuery(node.right, start, end)\\n    } \\n    \\n    return sumQuery(node.left, start, mid) + sumQuery(node.right, mid+1, end)     \\n}\\n\\n// SegTree represents a segment tree API\\ntype SegTree struct {\\n    Update      func(index, value int)\\n    MaxQuery    func(limit int)  *Node    // find an entry in the tree that\\'s < limit\\n    SumQuery    func(row int) int         // return sum in a range from [0...row]\\n}\\n\\nfunc NewSegmentTree(start, end, value int) *SegTree {\\n    root := build(start, end, value)\\n    return &SegTree{\\n        Update: func(index, value int) {\\n            updateNode(root, index, value)  \\n        },\\n        MaxQuery: func(limit int) *Node {\\n            return maxQuery(root, limit)\\n        },\\n        SumQuery: func(row int) int {\\n            return sumQuery(root, 0, row)  \\n        },\\n    }\\n}\\n\\n// ***** END OF SEGMENT TREE DS ***********\\n\\ntype BookMyShow struct {\\n    seats          []int         // keep track remaining seats indexed by row\\n    startRow       int\\n    seatsPerRow    int           \\n\\n    segTree *SegTree\\n}\\n\\n\\nfunc Constructor(n int, m int) BookMyShow {\\n    // n = number of rows, m = number of seats per row\\n    seats := make([]int, n)\\n    for row := range seats {\\n        seats[row] = m\\n    }\\n    return BookMyShow{ seats, 0, m,  NewSegmentTree(0, n-1, m) }\\n}\\n\\n\\nfunc (this *BookMyShow) Gather(k int, maxRow int) []int {\\n    // find a row where we can fit a block of k-seats together\\n    candidateRow := this.segTree.MaxQuery(k)\\n    // make sure possible row is <= maxRow and it\\'s max available seats is >= k\\n    if candidateRow.end > maxRow || candidateRow.max < k {\\n        return []int{}\\n    }\\n    // we can fit a block of k-seats in this row (extract last row and remaning seats in this row)\\n    row, remainingSeats := candidateRow.end, this.seatsPerRow - candidateRow.total\\n    // subtract seats count from this row and update this rows new value\\n    this.seats[row] -= k \\n    this.segTree.Update(row, this.seats[row])\\n    \\n    return []int{ row, remainingSeats }\\n}\\n\\n\\nfunc (this *BookMyShow) Scatter(k int, maxRow int) bool {\\n    // there are no k seats available up to maxRow\\n    if this.segTree.SumQuery(maxRow) < k {\\n        return false\\n    } else {\\n        row, total := this.startRow, 0\\n        // pick seats by how many are available in each row until we get up to k seats\\n        for total < k {\\n            prevTotal := total\\n            total += this.seats[row]\\n            if total < k {\\n                // use up all of the seats at row\\n                this.seats[row] = 0\\n                this.segTree.Update(row, this.seats[row])\\n                row = row + 1\\n                this.startRow = row\\n            } else {\\n                // overbooked a bit\\n                this.seats[row] -= k - prevTotal\\n                this.segTree.Update(row, this.seats[row])\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * obj := Constructor(n, m);\\n * param_1 := obj.Gather(k,maxRow);\\n * param_2 := obj.Scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Tree"
                ],
                "code": "```\\n// node of the segment tree\\ntype Node struct {\\n    left   *Node    // lower segments ie < right    \\n    right  *Node    // upper segments ie > left\\n    start  int      // segment boundary\\n    end    int      // segment boundary\\n    total  int      // total # of seats in this segment\\n    max    int      // max # of open seats in this segment\\n}\\n\\nfunc NewNode(start, end int) *Node {\\n    return &Node{nil, nil, start, end, -1, math.MinInt32}\\n}\\n\\n// build returns a Node for the given range and builds up the segment ranges\\n// start    - start of range\\n// end      - end of range\\n// value    - seats per row \\nfunc build(start, end, value int) *Node {\\n    if start > end {\\n        return nil\\n    }\\n    // only 1 node\\n    if start == end {\\n        node := NewNode(start, end)\\n        node.total, node.max = value, value\\n        return node\\n    }\\n    // split the range in half\\n    node := NewNode(start, end)\\n    mid := (start + end) / 2\\n    \\n    // recursively build the range of the tree\\n    node.left = build(start, mid, value)\\n    node.right = build(mid+1,end, value)\\n    \\n    // update the total and max for each range\\n    node.total = node.left.total + node.right.total\\n    node.max = max(node.left.max, node.right.max)\\n    \\n    return node\\n}\\n\\nfunc updateNode(node *Node, index, value int) {\\n    if node.start == index && node.end == index {\\n        node.total = value\\n        node.max = value\\n        return\\n    }\\n    // binary search\\n    mid := node.start + (node.end - node.start)/2\\n    if index <= mid {\\n        updateNode(node.left, index, value)\\n    } else {\\n        updateNode(node.right, index, value)\\n    }\\n    // update the max and the total\\n    node.max = max(node.left.max, node.right.max)\\n    node.total = node.left.total + node.right.total\\n}\\n\\nfunc maxQuery(node *Node, limit int) *Node {\\n    if node.start == node.end {\\n        return node\\n    }\\n    \\n    if limit <= node.left.max {\\n        return maxQuery(node.left, limit)\\n    }\\n    \\n    return maxQuery(node.right, limit)\\n}\\n\\nfunc sumQuery(node *Node, start int, end int) int {\\n    \\n    // if our window is in the node\\'s segment\\n    if start == node.start && end == node.end {\\n        return node.total\\n    }\\n    // otherwise binary search\\n    mid := (node.start + node.end) / 2\\n    if end <= mid {\\n        return sumQuery(node.left, start, end)\\n    } else if start > mid {\\n        return sumQuery(node.right, start, end)\\n    } \\n    \\n    return sumQuery(node.left, start, mid) + sumQuery(node.right, mid+1, end)     \\n}\\n\\n// SegTree represents a segment tree API\\ntype SegTree struct {\\n    Update      func(index, value int)\\n    MaxQuery    func(limit int)  *Node    // find an entry in the tree that\\'s < limit\\n    SumQuery    func(row int) int         // return sum in a range from [0...row]\\n}\\n\\nfunc NewSegmentTree(start, end, value int) *SegTree {\\n    root := build(start, end, value)\\n    return &SegTree{\\n        Update: func(index, value int) {\\n            updateNode(root, index, value)  \\n        },\\n        MaxQuery: func(limit int) *Node {\\n            return maxQuery(root, limit)\\n        },\\n        SumQuery: func(row int) int {\\n            return sumQuery(root, 0, row)  \\n        },\\n    }\\n}\\n\\n// ***** END OF SEGMENT TREE DS ***********\\n\\ntype BookMyShow struct {\\n    seats          []int         // keep track remaining seats indexed by row\\n    startRow       int\\n    seatsPerRow    int           \\n\\n    segTree *SegTree\\n}\\n\\n\\nfunc Constructor(n int, m int) BookMyShow {\\n    // n = number of rows, m = number of seats per row\\n    seats := make([]int, n)\\n    for row := range seats {\\n        seats[row] = m\\n    }\\n    return BookMyShow{ seats, 0, m,  NewSegmentTree(0, n-1, m) }\\n}\\n\\n\\nfunc (this *BookMyShow) Gather(k int, maxRow int) []int {\\n    // find a row where we can fit a block of k-seats together\\n    candidateRow := this.segTree.MaxQuery(k)\\n    // make sure possible row is <= maxRow and it\\'s max available seats is >= k\\n    if candidateRow.end > maxRow || candidateRow.max < k {\\n        return []int{}\\n    }\\n    // we can fit a block of k-seats in this row (extract last row and remaning seats in this row)\\n    row, remainingSeats := candidateRow.end, this.seatsPerRow - candidateRow.total\\n    // subtract seats count from this row and update this rows new value\\n    this.seats[row] -= k \\n    this.segTree.Update(row, this.seats[row])\\n    \\n    return []int{ row, remainingSeats }\\n}\\n\\n\\nfunc (this *BookMyShow) Scatter(k int, maxRow int) bool {\\n    // there are no k seats available up to maxRow\\n    if this.segTree.SumQuery(maxRow) < k {\\n        return false\\n    } else {\\n        row, total := this.startRow, 0\\n        // pick seats by how many are available in each row until we get up to k seats\\n        for total < k {\\n            prevTotal := total\\n            total += this.seats[row]\\n            if total < k {\\n                // use up all of the seats at row\\n                this.seats[row] = 0\\n                this.segTree.Update(row, this.seats[row])\\n                row = row + 1\\n                this.startRow = row\\n            } else {\\n                // overbooked a bit\\n                this.seats[row] -= k - prevTotal\\n                this.segTree.Update(row, this.seats[row])\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * obj := Constructor(n, m);\\n * param_1 := obj.Gather(k,maxRow);\\n * param_2 := obj.Scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086817,
                "title": "python-segment-tree-with-comments",
                "content": "```\\nclass SegTree:\\n    def __init__(self, n, m):\\n        # make the size even so we have a balance binary tree\\n        # even idx is left child, odd idx is right child\\n        self.size = 2 ** ceil(log(n, 2))\\n        # copy initial data\\n        self.maxar = [0] * self.size + [m] * n + [0] * (self.size-n)\\n        self.sumar = [0] * self.size + [m] * n + [0] * (self.size-n)\\n    \\n        # build the 2 segment trees\\n        for i in range(self.size-1, 0, -1):\\n            self.maxar[i] = max(self.maxar[i*2], self.maxar[i*2+1])\\n            self.sumar[i] = self.sumar[i*2] + self.sumar[i*2+1]\\n        \\n        self.minRow = self.size # starting from 2nd half, the actual data\\n        \\n    def gather(self, req, maxRow):\\n        # check the max segtree to see if it\\'s possible to get the required seats\\n        # start from the root of the max tree, index 1\\n        if self.maxar[1] < req:\\n            return []\\n        \\n        idx = 1\\n        N = len(self.maxar)\\n        while idx * 2 < N:\\n            left, right = idx * 2, idx * 2 + 1\\n            if left < N and self.maxar[left] >= req: # can find on the left\\n                idx = left\\n                continue\\n            \\n            if right < N and self.maxar[right] >= req:\\n                idx = right\\n                continue\\n        \\n        if idx - self.size <= maxRow: # left most index satisfy the boundary\\n            v = self.maxar[idx]\\n            self.updateMax(idx, v - req)\\n            self.updateSum(idx, v - req)\\n            return [idx - self.size, self.m - v]\\n        \\n        return []\\n    \\n    def sumq(self, maxRow):\\n        \"\"\"\\n        Return the sum from 0 to maxRow\\n        \"\"\"\\n        l, r = self.size, maxRow + self.size\\n        result = 0\\n        while l < r:\\n            # l is even => left child, can use the value of parent instead\\n            if l % 2 == 1:\\n                result += self.sumar[l]\\n                l += 1\\n            # r is odd => right child, can use the value of parent instead \\n            if r % 2 == 0:\\n                result += self.sumar[r]\\n                r -= 1\\n            l //= 2\\n            r //= 2\\n            \\n        if l == r: # only add once\\n            result += self.sumar[l]\\n        \\n        return result\\n    \\n    def update(self, k):\\n        for row in range(self.minRow, self.size * 2):\\n            v = self.maxar[row] # original value\\n            if k > v: # take all\\n                k -= v\\n                self.updateMax(row, 0)\\n                self.updateSum(row, 0)\\n            else:\\n                self.updateMax(row, v - k)\\n                self.updateSum(row, v - k)\\n                self.minRow = row\\n                break         \\n        \\n        \\n    def updateMax(self, idx, value):\\n        self.maxar[idx] = value\\n        while idx > 1: # root is 1\\n            idx //= 2\\n            cur = self.maxar[idx]\\n            self.maxar[idx] = max(self.maxar[idx*2], self.maxar[idx*2+1])\\n            if cur == self.maxar[idx]: # no change\\n                break\\n            \\n    def updateSum(self, idx, value):\\n        self.sumar[idx] = value\\n        while idx > 1: # root is 1\\n            idx //= 2\\n            self.sumar[idx] = self.sumar[idx*2] + self.sumar[idx*2+1]\\n\\nclass BookMyShow:\\n    def __init__(self, n: int, m: int):\\n        self.tree = SegTree(n, m)\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        return self.tree.gather(k, maxRow)\\n        \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        total = self.tree.sumq(maxRow)\\n        if total >= k: # possible\\n            self.tree.update(k)\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegTree:\\n    def __init__(self, n, m):\\n        # make the size even so we have a balance binary tree\\n        # even idx is left child, odd idx is right child\\n        self.size = 2 ** ceil(log(n, 2))\\n        # copy initial data\\n        self.maxar = [0] * self.size + [m] * n + [0] * (self.size-n)\\n        self.sumar = [0] * self.size + [m] * n + [0] * (self.size-n)\\n    \\n        # build the 2 segment trees\\n        for i in range(self.size-1, 0, -1):\\n            self.maxar[i] = max(self.maxar[i*2], self.maxar[i*2+1])\\n            self.sumar[i] = self.sumar[i*2] + self.sumar[i*2+1]\\n        \\n        self.minRow = self.size # starting from 2nd half, the actual data\\n        \\n    def gather(self, req, maxRow):\\n        # check the max segtree to see if it\\'s possible to get the required seats\\n        # start from the root of the max tree, index 1\\n        if self.maxar[1] < req:\\n            return []\\n        \\n        idx = 1\\n        N = len(self.maxar)\\n        while idx * 2 < N:\\n            left, right = idx * 2, idx * 2 + 1\\n            if left < N and self.maxar[left] >= req: # can find on the left\\n                idx = left\\n                continue\\n            \\n            if right < N and self.maxar[right] >= req:\\n                idx = right\\n                continue\\n        \\n        if idx - self.size <= maxRow: # left most index satisfy the boundary\\n            v = self.maxar[idx]\\n            self.updateMax(idx, v - req)\\n            self.updateSum(idx, v - req)\\n            return [idx - self.size, self.m - v]\\n        \\n        return []\\n    \\n    def sumq(self, maxRow):\\n        \"\"\"\\n        Return the sum from 0 to maxRow\\n        \"\"\"\\n        l, r = self.size, maxRow + self.size\\n        result = 0\\n        while l < r:\\n            # l is even => left child, can use the value of parent instead\\n            if l % 2 == 1:\\n                result += self.sumar[l]\\n                l += 1\\n            # r is odd => right child, can use the value of parent instead \\n            if r % 2 == 0:\\n                result += self.sumar[r]\\n                r -= 1\\n            l //= 2\\n            r //= 2\\n            \\n        if l == r: # only add once\\n            result += self.sumar[l]\\n        \\n        return result\\n    \\n    def update(self, k):\\n        for row in range(self.minRow, self.size * 2):\\n            v = self.maxar[row] # original value\\n            if k > v: # take all\\n                k -= v\\n                self.updateMax(row, 0)\\n                self.updateSum(row, 0)\\n            else:\\n                self.updateMax(row, v - k)\\n                self.updateSum(row, v - k)\\n                self.minRow = row\\n                break         \\n        \\n        \\n    def updateMax(self, idx, value):\\n        self.maxar[idx] = value\\n        while idx > 1: # root is 1\\n            idx //= 2\\n            cur = self.maxar[idx]\\n            self.maxar[idx] = max(self.maxar[idx*2], self.maxar[idx*2+1])\\n            if cur == self.maxar[idx]: # no change\\n                break\\n            \\n    def updateSum(self, idx, value):\\n        self.sumar[idx] = value\\n        while idx > 1: # root is 1\\n            idx //= 2\\n            self.sumar[idx] = self.sumar[idx*2] + self.sumar[idx*2+1]\\n\\nclass BookMyShow:\\n    def __init__(self, n: int, m: int):\\n        self.tree = SegTree(n, m)\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        return self.tree.gather(k, maxRow)\\n        \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        total = self.tree.sumq(maxRow)\\n        if total >= k: # possible\\n            self.tree.update(k)\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084835,
                "title": "python-3-sum-and-max-segment-trees-binary-search",
                "content": "The key is to update the search lower bound after each `scatter` call. So we don\\'t need to update and query any rows beyond that.\\n\\n```\\nclass TreeNode:\\n    def __init__(self, val=0, start=None, end=None, left=None, right=None):\\n        self.val = val\\n        self.start = start\\n        self.end = end\\n        self.left = left\\n        self.right = right\\n\\nclass SegmentTree:\\n    def __init__(self, start, end, vals, mode=\\'sum\\'):\\n        def build(start, end, vals):\\n            if start == end:\\n                return TreeNode(vals[start], start, end)\\n            mid = (start + end) // 2\\n            l, r = build(start, mid, vals), build(mid+1, end, vals)\\n            return TreeNode(l.val+r.val, start, end, l, r) if mode == \\'sum\\' else TreeNode(max(l.val, r.val), start, end, l, r)\\n        self.t = build(start, end, vals)\\n        self.mode = mode\\n    \\n    def update(self, root, index, value):\\n        if index == root.start == root.end:\\n            root.val = value\\n            return\\n        mid = (root.start + root.end) // 2\\n        if index <= mid:\\n            self.update(root.left, index, value)\\n        else:\\n            self.update(root.right, index, value)\\n        root.val = root.left.val + root.right.val if self.mode == \\'sum\\' else max(root.left.val, root.right.val)\\n\\n    def query(self, root, i, j):\\n        if root.start == i and root.end == j:\\n            return root.val\\n        mid = (root.start + root.end) // 2\\n        if j <= mid:\\n            return self.query(root.left, i, j)\\n        elif i > mid:\\n            return self.query(root.right, i, j)\\n        else:\\n            return self.query(root.left, i, mid) + self.query(root.right, mid+1, j) if self.mode == \\'sum\\' else max(self.query(root.left, i, mid), self.query(root.right, mid+1, j))\\n        \\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.st_sum = SegmentTree(0, n - 1, [m] * n)\\n        self.st_max = SegmentTree(0, n - 1, [m] * n, mode=\\'max\\')\\n        self.m, self.n = m, n\\n        self.low = 0 # this is the search lower bound (any row beyond this has no seat)\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        st_max = self.st_max\\n        st_sum = self.st_sum\\n        low = self.low\\n        if low > maxRow or st_max.query(st_max.t, low, maxRow) < k: return []\\n        # find smallest row between search lower bound and maxRow with seat >= k\\n        l, h = low, maxRow\\n        while l < h:\\n            mid = l + (h - l) // 2\\n            if st_max.query(st_max.t, low, mid) >= k:\\n                h = mid\\n            else:\\n                l = mid + 1\\n        # update seat for both trees \\n        rest = st_max.query(st_max.t, l, l)\\n        st_max.update(st_max.t, l, rest - k)\\n        st_sum.update(st_sum.t, l, rest - k)\\n        return [l, self.m - rest]\\n        \\n    \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        st_max = self.st_max\\n        st_sum = self.st_sum\\n        low = self.low\\n        \\n        if low > maxRow or st_sum.query(st_sum.t, low, maxRow) < k: return False\\n        # find smallest row between search lower bound and maxRow with sum seat >= k\\n        l, h = low, maxRow\\n        while l < h:\\n            mid = l + (h - l) // 2\\n            if st_sum.query(st_sum.t, low, mid) >= k:\\n                h = mid\\n            else:\\n                l = mid + 1\\n        \\n        tot = st_sum.query(st_sum.t, low, l)\\n        rest = tot - k\\n        if not rest:\\n            self.low = l + 1 # if no remaining seat, then current row has no seat and go to next row\\n        else:\\n            self.low = l # otherwise the current row still has seat and need to update the number\\n            st_sum.update(st_sum.t, l, rest)\\n            st_max.update(st_max.t, l, rest)\\n            \\n        return True\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "The key is to update the search lower bound after each `scatter` call. So we don\\'t need to update and query any rows beyond that.\\n\\n```\\nclass TreeNode:\\n    def __init__(self, val=0, start=None, end=None, left=None, right=None):\\n        self.val = val\\n        self.start = start\\n        self.end = end\\n        self.left = left\\n        self.right = right\\n\\nclass SegmentTree:\\n    def __init__(self, start, end, vals, mode=\\'sum\\'):\\n        def build(start, end, vals):\\n            if start == end:\\n                return TreeNode(vals[start], start, end)\\n            mid = (start + end) // 2\\n            l, r = build(start, mid, vals), build(mid+1, end, vals)\\n            return TreeNode(l.val+r.val, start, end, l, r) if mode == \\'sum\\' else TreeNode(max(l.val, r.val), start, end, l, r)\\n        self.t = build(start, end, vals)\\n        self.mode = mode\\n    \\n    def update(self, root, index, value):\\n        if index == root.start == root.end:\\n            root.val = value\\n            return\\n        mid = (root.start + root.end) // 2\\n        if index <= mid:\\n            self.update(root.left, index, value)\\n        else:\\n            self.update(root.right, index, value)\\n        root.val = root.left.val + root.right.val if self.mode == \\'sum\\' else max(root.left.val, root.right.val)\\n\\n    def query(self, root, i, j):\\n        if root.start == i and root.end == j:\\n            return root.val\\n        mid = (root.start + root.end) // 2\\n        if j <= mid:\\n            return self.query(root.left, i, j)\\n        elif i > mid:\\n            return self.query(root.right, i, j)\\n        else:\\n            return self.query(root.left, i, mid) + self.query(root.right, mid+1, j) if self.mode == \\'sum\\' else max(self.query(root.left, i, mid), self.query(root.right, mid+1, j))\\n        \\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.st_sum = SegmentTree(0, n - 1, [m] * n)\\n        self.st_max = SegmentTree(0, n - 1, [m] * n, mode=\\'max\\')\\n        self.m, self.n = m, n\\n        self.low = 0 # this is the search lower bound (any row beyond this has no seat)\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        st_max = self.st_max\\n        st_sum = self.st_sum\\n        low = self.low\\n        if low > maxRow or st_max.query(st_max.t, low, maxRow) < k: return []\\n        # find smallest row between search lower bound and maxRow with seat >= k\\n        l, h = low, maxRow\\n        while l < h:\\n            mid = l + (h - l) // 2\\n            if st_max.query(st_max.t, low, mid) >= k:\\n                h = mid\\n            else:\\n                l = mid + 1\\n        # update seat for both trees \\n        rest = st_max.query(st_max.t, l, l)\\n        st_max.update(st_max.t, l, rest - k)\\n        st_sum.update(st_sum.t, l, rest - k)\\n        return [l, self.m - rest]\\n        \\n    \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        st_max = self.st_max\\n        st_sum = self.st_sum\\n        low = self.low\\n        \\n        if low > maxRow or st_sum.query(st_sum.t, low, maxRow) < k: return False\\n        # find smallest row between search lower bound and maxRow with sum seat >= k\\n        l, h = low, maxRow\\n        while l < h:\\n            mid = l + (h - l) // 2\\n            if st_sum.query(st_sum.t, low, mid) >= k:\\n                h = mid\\n            else:\\n                l = mid + 1\\n        \\n        tot = st_sum.query(st_sum.t, low, l)\\n        rest = tot - k\\n        if not rest:\\n            self.low = l + 1 # if no remaining seat, then current row has no seat and go to next row\\n        else:\\n            self.low = l # otherwise the current row still has seat and need to update the number\\n            st_sum.update(st_sum.t, l, rest)\\n            st_max.update(st_max.t, l, rest)\\n            \\n        return True\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2084318,
                "title": "easier-to-implement-square-root-decomposition",
                "content": "Basic algorithm \\n\\n(I find it easier to implement compared to BIT and segment tree)\\n\\n1. Divide N rows into sqrt(N) sized buckets.\\n2. Keep track of max and sum of all the buckets. \\n3. For each operation, we need to operate on sqrt(N) buckets and sqrt(N) rows, (left over elements in one bucket)\\n\\n```\\nclass BookMyShow {\\npublic:\\n    vector<long long> rows;\\n    long long bucketSize;\\n    vector<long long> bucketsSum;\\n    vector<long long> bucketsMax;\\n    long long totalBuckets;\\n    int M;\\n    int N;\\n    \\n    BookMyShow(int n, int m) {\\n        N = n;\\n        M = m;\\n        rows.resize(n, 0);\\n        bucketSize = sqrt(n);\\n        totalBuckets = n / bucketSize;\\n        if(n%bucketSize != 0){\\n            totalBuckets++;\\n        }\\n        bucketsSum.resize(totalBuckets, m*bucketSize);\\n        if(n%bucketSize != 0){\\n            bucketsSum[totalBuckets-1] = m * (n%bucketSize);\\n        }\\n        \\n        bucketsMax.resize(totalBuckets, m);\\n    }\\n    \\n    long long min(long long a, long long b){\\n        if(a >= b){\\n            return b;\\n        }else{\\n            return a;\\n        }\\n    }\\n    \\n    vector<int> gatherInBucket(int bucketNumber, int k, int maxRow){\\n        vector<int> ans;\\n        int start = bucketNumber * bucketSize;\\n        int end = min(N, start + bucketSize);\\n        for(int i=start;i<=maxRow;i++){\\n            if((M - rows[i]) >= k){\\n                ans.resize(2, 0);\\n                ans[0] = i;\\n                ans[1] = rows[i];\\n                rows[i] += k;\\n                bucketsSum[bucketNumber] = 0;\\n                bucketsMax[bucketNumber] = 0;\\n                for(int j=start;j<end;j++){\\n                    bucketsMax[bucketNumber] = max(bucketsMax[bucketNumber], (M-rows[j]));\\n                    bucketsSum[bucketNumber] +=  (M-rows[j]);\\n                }\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        vector<int> ans;\\n        if(k > M){\\n            return ans;\\n        }\\n        for(int i=0;i<totalBuckets;i++){\\n            if(bucketsMax[i] >= k){\\n                \\n                 ans = gatherInBucket(i, k, maxRow);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long getSumInBucket(int bucketNumber, int maxRow){\\n        if(bucketsSum[bucketNumber] == 0){\\n            return 0;\\n        }\\n        int start = bucketNumber * bucketSize;\\n        int end = min(N, start + bucketSize);\\n        long long sumX = 0;\\n        for(int i=start;i<=maxRow;i++){\\n            sumX += (M - rows[i]);\\n        }\\n        return sumX;\\n    }\\n    \\n    bool scatter(int bucketNumber, int k, int maxRow){\\n        int start = bucketNumber * bucketSize;\\n        int end = min(N, start + bucketSize);\\n        for(int i=0;i<bucketNumber; i++){\\n            k -= bucketsSum[i];\\n            bucketsSum[i] = 0;\\n            bucketsMax[i] = 0;\\n        }\\n        for(int i=start;i<=maxRow && k > 0;i++){\\n            if(k >= (M - rows[i])){\\n                k -= (M - rows[i]);\\n                rows[i] = M;\\n            }else{\\n                rows[i] += k;\\n                k = 0;\\n            }\\n        }\\n        bucketsSum[bucketNumber] = 0;\\n        bucketsMax[bucketNumber] = 0;\\n        for(int j=start;j<end;j++){\\n            bucketsMax[bucketNumber] = max(bucketsMax[bucketNumber], (M-rows[j]));\\n            bucketsSum[bucketNumber] +=  (M-rows[j]);\\n        }\\n        return true;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long sumX = 0;\\n        int bucketNumber;\\n        bool isPossible = false;\\n        for(int i=0;i<totalBuckets;i++){\\n            int end = min((i+1)*bucketSize, N);\\n            if(end > maxRow){\\n                bucketNumber = i;\\n                break;\\n            }\\n            sumX += bucketsSum[i];\\n            if(sumX >= k){\\n                bucketNumber = (i);\\n                isPossible = true;\\n                break;\\n            }\\n        }\\n        \\n        if(!isPossible && bucketNumber < totalBuckets){\\n            sumX += getSumInBucket(bucketNumber, maxRow);\\n        }\\n        if(sumX >= k){\\n            isPossible = true;\\n        }\\n        \\n        if(isPossible){\\n            scatter(bucketNumber, k, maxRow);\\n        }\\n        return isPossible;\\n        \\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    vector<long long> rows;\\n    long long bucketSize;\\n    vector<long long> bucketsSum;\\n    vector<long long> bucketsMax;\\n    long long totalBuckets;\\n    int M;\\n    int N;\\n    \\n    BookMyShow(int n, int m) {\\n        N = n;\\n        M = m;\\n        rows.resize(n, 0);\\n        bucketSize = sqrt(n);\\n        totalBuckets = n / bucketSize;\\n        if(n%bucketSize != 0){\\n            totalBuckets++;\\n        }\\n        bucketsSum.resize(totalBuckets, m*bucketSize);\\n        if(n%bucketSize != 0){\\n            bucketsSum[totalBuckets-1] = m * (n%bucketSize);\\n        }\\n        \\n        bucketsMax.resize(totalBuckets, m);\\n    }\\n    \\n    long long min(long long a, long long b){\\n        if(a >= b){\\n            return b;\\n        }else{\\n            return a;\\n        }\\n    }\\n    \\n    vector<int> gatherInBucket(int bucketNumber, int k, int maxRow){\\n        vector<int> ans;\\n        int start = bucketNumber * bucketSize;\\n        int end = min(N, start + bucketSize);\\n        for(int i=start;i<=maxRow;i++){\\n            if((M - rows[i]) >= k){\\n                ans.resize(2, 0);\\n                ans[0] = i;\\n                ans[1] = rows[i];\\n                rows[i] += k;\\n                bucketsSum[bucketNumber] = 0;\\n                bucketsMax[bucketNumber] = 0;\\n                for(int j=start;j<end;j++){\\n                    bucketsMax[bucketNumber] = max(bucketsMax[bucketNumber], (M-rows[j]));\\n                    bucketsSum[bucketNumber] +=  (M-rows[j]);\\n                }\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        vector<int> ans;\\n        if(k > M){\\n            return ans;\\n        }\\n        for(int i=0;i<totalBuckets;i++){\\n            if(bucketsMax[i] >= k){\\n                \\n                 ans = gatherInBucket(i, k, maxRow);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long getSumInBucket(int bucketNumber, int maxRow){\\n        if(bucketsSum[bucketNumber] == 0){\\n            return 0;\\n        }\\n        int start = bucketNumber * bucketSize;\\n        int end = min(N, start + bucketSize);\\n        long long sumX = 0;\\n        for(int i=start;i<=maxRow;i++){\\n            sumX += (M - rows[i]);\\n        }\\n        return sumX;\\n    }\\n    \\n    bool scatter(int bucketNumber, int k, int maxRow){\\n        int start = bucketNumber * bucketSize;\\n        int end = min(N, start + bucketSize);\\n        for(int i=0;i<bucketNumber; i++){\\n            k -= bucketsSum[i];\\n            bucketsSum[i] = 0;\\n            bucketsMax[i] = 0;\\n        }\\n        for(int i=start;i<=maxRow && k > 0;i++){\\n            if(k >= (M - rows[i])){\\n                k -= (M - rows[i]);\\n                rows[i] = M;\\n            }else{\\n                rows[i] += k;\\n                k = 0;\\n            }\\n        }\\n        bucketsSum[bucketNumber] = 0;\\n        bucketsMax[bucketNumber] = 0;\\n        for(int j=start;j<end;j++){\\n            bucketsMax[bucketNumber] = max(bucketsMax[bucketNumber], (M-rows[j]));\\n            bucketsSum[bucketNumber] +=  (M-rows[j]);\\n        }\\n        return true;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long sumX = 0;\\n        int bucketNumber;\\n        bool isPossible = false;\\n        for(int i=0;i<totalBuckets;i++){\\n            int end = min((i+1)*bucketSize, N);\\n            if(end > maxRow){\\n                bucketNumber = i;\\n                break;\\n            }\\n            sumX += bucketsSum[i];\\n            if(sumX >= k){\\n                bucketNumber = (i);\\n                isPossible = true;\\n                break;\\n            }\\n        }\\n        \\n        if(!isPossible && bucketNumber < totalBuckets){\\n            sumX += getSumInBucket(bucketNumber, maxRow);\\n        }\\n        if(sumX >= k){\\n            isPossible = true;\\n        }\\n        \\n        if(isPossible){\\n            scatter(bucketNumber, k, maxRow);\\n        }\\n        return isPossible;\\n        \\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2084289,
                "title": "python-accepted-sum-max-segment-tree",
                "content": "Main idea:\\nFor gather request we need to find minimum row that has >= k seats. This is implemented via Max Seg Tree\\n\\nFor scatter request we need to first check if there are enough seats. If yes -> we allocate them. Imlemeted via Sum Seg Tree\\n\\nBoth gather and scatter requests should update both Max and Sum Seg Trees during allocation\\n\\nSumq method checks if there are enought seats for scatter request. If it is True -> We then allocate them using decr method\\n\\n\\n```\\nclass SegTree:\\n    def __init__(self, n, m):\\n        q = int(math.log(n, 2))\\n        \\n        self.first = [0] * n\\n        \\n        if 2 ** q < n:\\n            q += 1\\n        \\n        self.size = 2 ** q\\n        \\n        self.maxar = [0] * (2 * self.size)\\n        self.sumar = [0] * (2 * self.size)\\n        \\n        self.build(1, 0, self.size-1, n, m)\\n    \\n    def build(self, i, l, r, n, m):\\n        if l == r:\\n            if l < n:\\n                self.maxar[i] = m\\n                self.sumar[i] = m\\n            else:\\n                self.maxar[i] = 0\\n                self.sumar[i] = 0\\n            \\n            return self.maxar[i], self.sumar[i]\\n        \\n        else:\\n            mid = (l + r) // 2\\n            \\n            left = self.build(2*i, l, mid, n, m)\\n            right = self.build(2*i+1, mid+1, r, n, m)\\n            \\n            self.maxar[i] = max(left[0], right[0])\\n            self.sumar[i] = left[1] + right[1]\\n            \\n            return self.maxar[i], self.sumar[i]\\n    \\n    def gather(self, i, l, r, req, maxRow):\\n        if self.maxar[i] < req:\\n            return False, []\\n        \\n        \\n        if l == r:\\n            if l > maxRow:\\n                return False, []\\n            \\n            self.maxar[i] -= req\\n            self.sumar[i] -= req\\n            \\n            prev = self.first[l]\\n            self.first[l] += req\\n            \\n            return True, [l, prev]\\n        \\n        \\n        mid = (l + r) // 2\\n        \\n        left = self.maxar[2*i]\\n        right = self.maxar[2*i+1]\\n        \\n        if left >= req:\\n            q = self.gather(2*i, l, mid, req, maxRow)\\n            if q[0]:\\n                self.maxar[i] = max(self.maxar[2*i], self.maxar[2*i+1])\\n                self.sumar[i] = self.sumar[2*i] + self.sumar[2*i+1]\\n                return True, q[1]\\n        \\n        if right >= req:\\n            q = self.gather(2*i+1, mid+1, r, req, maxRow)\\n            if q[0]:\\n                self.maxar[i] = max(self.maxar[2*i], self.maxar[2*i+1])\\n                self.sumar[i] = self.sumar[2*i] + self.sumar[2*i+1]\\n                return True, q[1]\\n        \\n        return False, []\\n        \\n        \\n    \\n    \\n    def sumq(self, i, l, r, maxRow):\\n        if l > maxRow:\\n            return 0\\n        \\n        if r <= maxRow:\\n            return self.sumar[i]\\n        \\n        mid = (l + r) // 2\\n        \\n        return self.sumq(2*i, l, mid, maxRow) + self.sumq(2*i+1, mid+1, r, maxRow)\\n    \\n    \\n    def decr(self, i, l, r, req):\\n        if self.sumar[i] == 0:\\n            return 0\\n        \\n        if l == r:\\n            cur = min(req, self.sumar[i])\\n            self.sumar[i] -= cur\\n            self.maxar[i] -= cur\\n            \\n            self.first[l] += cur\\n            \\n            return cur\\n        \\n        mid = (l + r) // 2\\n        \\n        left = self.decr(2*i, l, mid, req)  \\n        right = 0\\n        \\n        if req-left:\\n            right = self.decr(2*i+1, mid+1, r, req-left)\\n        \\n        self.sumar[i] -= (left + right)\\n        self.maxar[i] = max(self.maxar[2*i], self.maxar[2*i+1])\\n        \\n        return left + right\\n            \\n        \\n        \\n        \\n        \\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.kek = SegTree(n, m)\\n        print(self.kek.sumar)\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        q = self.kek.gather(1, 0, self.kek.size-1, k, maxRow)\\n        return q[1]\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        f = self.kek.sumq(1, 0, self.kek.size-1, maxRow)\\n        if f >= k:\\n            self.kek.decr(1, 0, self.kek.size-1, k)\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass SegTree:\\n    def __init__(self, n, m):\\n        q = int(math.log(n, 2))\\n        \\n        self.first = [0] * n\\n        \\n        if 2 ** q < n:\\n            q += 1\\n        \\n        self.size = 2 ** q\\n        \\n        self.maxar = [0] * (2 * self.size)\\n        self.sumar = [0] * (2 * self.size)\\n        \\n        self.build(1, 0, self.size-1, n, m)\\n    \\n    def build(self, i, l, r, n, m):\\n        if l == r:\\n            if l < n:\\n                self.maxar[i] = m\\n                self.sumar[i] = m\\n            else:\\n                self.maxar[i] = 0\\n                self.sumar[i] = 0\\n            \\n            return self.maxar[i], self.sumar[i]\\n        \\n        else:\\n            mid = (l + r) // 2\\n            \\n            left = self.build(2*i, l, mid, n, m)\\n            right = self.build(2*i+1, mid+1, r, n, m)\\n            \\n            self.maxar[i] = max(left[0], right[0])\\n            self.sumar[i] = left[1] + right[1]\\n            \\n            return self.maxar[i], self.sumar[i]\\n    \\n    def gather(self, i, l, r, req, maxRow):\\n        if self.maxar[i] < req:\\n            return False, []\\n        \\n        \\n        if l == r:\\n            if l > maxRow:\\n                return False, []\\n            \\n            self.maxar[i] -= req\\n            self.sumar[i] -= req\\n            \\n            prev = self.first[l]\\n            self.first[l] += req\\n            \\n            return True, [l, prev]\\n        \\n        \\n        mid = (l + r) // 2\\n        \\n        left = self.maxar[2*i]\\n        right = self.maxar[2*i+1]\\n        \\n        if left >= req:\\n            q = self.gather(2*i, l, mid, req, maxRow)\\n            if q[0]:\\n                self.maxar[i] = max(self.maxar[2*i], self.maxar[2*i+1])\\n                self.sumar[i] = self.sumar[2*i] + self.sumar[2*i+1]\\n                return True, q[1]\\n        \\n        if right >= req:\\n            q = self.gather(2*i+1, mid+1, r, req, maxRow)\\n            if q[0]:\\n                self.maxar[i] = max(self.maxar[2*i], self.maxar[2*i+1])\\n                self.sumar[i] = self.sumar[2*i] + self.sumar[2*i+1]\\n                return True, q[1]\\n        \\n        return False, []\\n        \\n        \\n    \\n    \\n    def sumq(self, i, l, r, maxRow):\\n        if l > maxRow:\\n            return 0\\n        \\n        if r <= maxRow:\\n            return self.sumar[i]\\n        \\n        mid = (l + r) // 2\\n        \\n        return self.sumq(2*i, l, mid, maxRow) + self.sumq(2*i+1, mid+1, r, maxRow)\\n    \\n    \\n    def decr(self, i, l, r, req):\\n        if self.sumar[i] == 0:\\n            return 0\\n        \\n        if l == r:\\n            cur = min(req, self.sumar[i])\\n            self.sumar[i] -= cur\\n            self.maxar[i] -= cur\\n            \\n            self.first[l] += cur\\n            \\n            return cur\\n        \\n        mid = (l + r) // 2\\n        \\n        left = self.decr(2*i, l, mid, req)  \\n        right = 0\\n        \\n        if req-left:\\n            right = self.decr(2*i+1, mid+1, r, req-left)\\n        \\n        self.sumar[i] -= (left + right)\\n        self.maxar[i] = max(self.maxar[2*i], self.maxar[2*i+1])\\n        \\n        return left + right\\n            \\n        \\n        \\n        \\n        \\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.kek = SegTree(n, m)\\n        print(self.kek.sumar)\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        q = self.kek.gather(1, 0, self.kek.size-1, k, maxRow)\\n        return q[1]\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        f = self.kek.sumq(1, 0, self.kek.size-1, maxRow)\\n        if f >= k:\\n            self.kek.decr(1, 0, self.kek.size-1, k)\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084218,
                "title": "accepted-c-segment-tree-tle-93-94-testcase-passed-explained",
                "content": "We will maintain a segment tree for finding the seats remaining.\\n\\nGather: In the gather part we have to find the min index at which we can get atleast k seats continuously. So we will find this using binary search from seat number 0 to maxRow.\\n\\nScatter: Firstly we will find that there are k seats available or not from 0 to maxRow using segment tree. We will maintain a variable \"li\" which contains the index of the last row having some seats empty. So if there are k seats left, then we will start from li index and start filling the seats and updating the segment tree. \\nMaintaing this \"li\" variable is important else starting everytime from 0th index will cause TLE( :( 3 times in contest ).\\n\\n```\\n#pragma GCC optimize(\"O3,unroll-loops\")\\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\\nclass BookMyShow\\n{\\npublic:\\n    struct tree\\n    {\\n        constexpr int static N = 1e5;\\n        long long t[4 * N + 5], tsum[4 * N + 5];\\n\\n        // Dont use build tree better use point update\\n\\n        void update(int v, int tl, int tr, int pos, int val)\\n        {\\n            if (tl == tr)\\n            {\\n                t[v] = val;\\n                return;\\n            }\\n            int mid = (tl + tr) / 2;\\n            if (pos <= mid)\\n                update(2 * v, tl, mid, pos, val);\\n            else\\n                update(2 * v + 1, mid + 1, tr, pos, val);\\n            t[v] = min(t[2 * v], t[2 * v + 1]);\\n        }\\n\\n        int query(int v, int tl, int tr, int l, int r)\\n        {\\n            if (tr < l || tl > r)\\n                return INT_MAX;\\n            if (l <= tl && tr <= r)\\n                return t[v];\\n            int mid = (tl + tr) / 2;\\n            return min(query(2 * v, tl, mid, l, r), query(2 * v + 1, mid + 1, tr, l, r));\\n        }\\n        long long querysum(int v, int tl, int tr, int l, int r)\\n        {\\n            if (tr < l || tl > r)\\n                return 0ll;\\n            if (l <= tl && tr <= r)\\n                return tsum[v];\\n            int mid = (tl + tr) / 2;\\n            long long x = querysum(2 * v, tl, mid, l, r);\\n            x += querysum(2 * v + 1, mid + 1, tr, l, r);\\n            return x;\\n        }\\n        void updatesum(int v, int tl, int tr, int pos, int val)\\n        {\\n            if (tl == tr)\\n            {\\n                tsum[v] = val;\\n                return;\\n            }\\n            int mid = (tl + tr) / 2;\\n            if (pos <= mid)\\n                updatesum(2 * v, tl, mid, pos, val);\\n            else\\n                updatesum(2 * v + 1, mid + 1, tr, pos, val);\\n            tsum[v] = (tsum[2 * v] + tsum[2 * v + 1]);\\n        }\\n        void clr(int n)\\n        {\\n            for (int i = 0; i < 4 * n + 5; i++)\\n                t[i] = 0, tsum[i] = 0;\\n        }\\n    };\\n    int tr, ts, li = 1;\\n    tree seg;\\n    BookMyShow(int n, int m)\\n    {\\n        tr = n, ts = m;\\n        seg.clr(n + 1);\\n    }\\n\\n    vector<int> gather(int k, int maxRow)\\n    {\\n        vector<int> v;\\n        int mn = seg.query(1, 1, tr, 1, maxRow + 1);\\n        if (ts - mn < k)\\n            return v;\\n        int l = li, r = maxRow + 1;\\n        int ar = 0, sn = 0;\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            int q = seg.query(1, 1, tr, l, mid);\\n            q = ts - q;\\n            if (q >= k)\\n            {\\n                ar = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        sn = seg.query(1, 1, tr, ar, ar);\\n        seg.update(1, 1, tr, ar, sn + k);\\n        seg.updatesum(1, 1, tr, ar, sn + k);\\n        v.push_back(ar - 1), v.push_back(sn);\\n        return v;\\n    }\\n\\n    bool scatter(int k, int maxRow)\\n    {\\n        long long tot = seg.querysum(1, 1, tr, 1, maxRow + 1);\\n        long long yy = ts;\\n        yy *= (maxRow + 1);\\n        yy -= tot;\\n        if (yy < k)\\n            return false;\\n        while (li <= maxRow + 1 && k > 0)\\n        {\\n            int y = seg.query(1, 1, tr, li, li);\\n            int x = min(k, ts - y);\\n            seg.update(1, 1, tr, li, x + y);\\n            seg.updatesum(1, 1, tr, li, x + y);\\n            if (y + x == ts)\\n                li++;\\n            k -= x;\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#pragma GCC optimize(\"O3,unroll-loops\")\\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\\nclass BookMyShow\\n{\\npublic:\\n    struct tree\\n    {\\n        constexpr int static N = 1e5;\\n        long long t[4 * N + 5], tsum[4 * N + 5];\\n\\n        // Dont use build tree better use point update\\n\\n        void update(int v, int tl, int tr, int pos, int val)\\n        {\\n            if (tl == tr)\\n            {\\n                t[v] = val;\\n                return;\\n            }\\n            int mid = (tl + tr) / 2;\\n            if (pos <= mid)\\n                update(2 * v, tl, mid, pos, val);\\n            else\\n                update(2 * v + 1, mid + 1, tr, pos, val);\\n            t[v] = min(t[2 * v], t[2 * v + 1]);\\n        }\\n\\n        int query(int v, int tl, int tr, int l, int r)\\n        {\\n            if (tr < l || tl > r)\\n                return INT_MAX;\\n            if (l <= tl && tr <= r)\\n                return t[v];\\n            int mid = (tl + tr) / 2;\\n            return min(query(2 * v, tl, mid, l, r), query(2 * v + 1, mid + 1, tr, l, r));\\n        }\\n        long long querysum(int v, int tl, int tr, int l, int r)\\n        {\\n            if (tr < l || tl > r)\\n                return 0ll;\\n            if (l <= tl && tr <= r)\\n                return tsum[v];\\n            int mid = (tl + tr) / 2;\\n            long long x = querysum(2 * v, tl, mid, l, r);\\n            x += querysum(2 * v + 1, mid + 1, tr, l, r);\\n            return x;\\n        }\\n        void updatesum(int v, int tl, int tr, int pos, int val)\\n        {\\n            if (tl == tr)\\n            {\\n                tsum[v] = val;\\n                return;\\n            }\\n            int mid = (tl + tr) / 2;\\n            if (pos <= mid)\\n                updatesum(2 * v, tl, mid, pos, val);\\n            else\\n                updatesum(2 * v + 1, mid + 1, tr, pos, val);\\n            tsum[v] = (tsum[2 * v] + tsum[2 * v + 1]);\\n        }\\n        void clr(int n)\\n        {\\n            for (int i = 0; i < 4 * n + 5; i++)\\n                t[i] = 0, tsum[i] = 0;\\n        }\\n    };\\n    int tr, ts, li = 1;\\n    tree seg;\\n    BookMyShow(int n, int m)\\n    {\\n        tr = n, ts = m;\\n        seg.clr(n + 1);\\n    }\\n\\n    vector<int> gather(int k, int maxRow)\\n    {\\n        vector<int> v;\\n        int mn = seg.query(1, 1, tr, 1, maxRow + 1);\\n        if (ts - mn < k)\\n            return v;\\n        int l = li, r = maxRow + 1;\\n        int ar = 0, sn = 0;\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            int q = seg.query(1, 1, tr, l, mid);\\n            q = ts - q;\\n            if (q >= k)\\n            {\\n                ar = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        sn = seg.query(1, 1, tr, ar, ar);\\n        seg.update(1, 1, tr, ar, sn + k);\\n        seg.updatesum(1, 1, tr, ar, sn + k);\\n        v.push_back(ar - 1), v.push_back(sn);\\n        return v;\\n    }\\n\\n    bool scatter(int k, int maxRow)\\n    {\\n        long long tot = seg.querysum(1, 1, tr, 1, maxRow + 1);\\n        long long yy = ts;\\n        yy *= (maxRow + 1);\\n        yy -= tot;\\n        if (yy < k)\\n            return false;\\n        while (li <= maxRow + 1 && k > 0)\\n        {\\n            int y = seg.query(1, 1, tr, li, li);\\n            int x = min(k, ts - y);\\n            seg.update(1, 1, tr, li, x + y);\\n            seg.updatesum(1, 1, tr, li, x + y);\\n            if (y + x == ts)\\n                li++;\\n            k -= x;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083867,
                "title": "python3-tle-92-94-there-are-only-2-seats-left-in-the-hall",
                "content": "Just for fun, there is problem in TC description? `there are only 2 seats left in the hall` it should be `1` ?\\n\\n+ My TLE solution within few optimizations. (92 of 94 test cases are passed)\\n\\n```python\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.n = n\\n        self.m = m\\n        self.free = [0 for _ in range(n)]\\n        self.left = n*m\\n        self.last = 0\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if self.left < k:\\n            return []\\n\\n        for r in range(self.last, maxRow + 1):\\n            if self.m - self.free[r] < k:\\n                continue\\n\\n            # reserve\\n            c = self.free[r]\\n            self.free[r] += k\\n            \\n            self.left -= k\\n            return [r, c]\\n\\n        return []\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.left < k:\\n            return False\\n        \\n        rest = k\\n        for r in range(self.last, maxRow + 1):\\n            rest -= self.m - self.free[r]\\n            if rest <= 0:\\n                break\\n        else:\\n            return False\\n        \\n        # reserve\\n        rest = k\\n        for r in range(self.last, maxRow + 1):\\n            d = self.m - self.free[r]\\n            \\n            self.free[r] += min(d, rest)\\n            rest -= d\\n\\n            if rest <= 0:\\n                self.last = r  # update start point, all upper are reserved\\n                break\\n\\n        self.left -= k\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.n = n\\n        self.m = m\\n        self.free = [0 for _ in range(n)]\\n        self.left = n*m\\n        self.last = 0\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if self.left < k:\\n            return []\\n\\n        for r in range(self.last, maxRow + 1):\\n            if self.m - self.free[r] < k:\\n                continue\\n\\n            # reserve\\n            c = self.free[r]\\n            self.free[r] += k\\n            \\n            self.left -= k\\n            return [r, c]\\n\\n        return []\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.left < k:\\n            return False\\n        \\n        rest = k\\n        for r in range(self.last, maxRow + 1):\\n            rest -= self.m - self.free[r]\\n            if rest <= 0:\\n                break\\n        else:\\n            return False\\n        \\n        # reserve\\n        rest = k\\n        for r in range(self.last, maxRow + 1):\\n            d = self.m - self.free[r]\\n            \\n            self.free[r] += min(d, rest)\\n            rest -= d\\n\\n            if rest <= 0:\\n                self.last = r  # update start point, all upper are reserved\\n                break\\n\\n        self.left -= k\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068303,
                "title": "c-readable-segment-tree",
                "content": "# Intuition\\nSegmet tree, where each node represents a range of rows.\\nOther creative solutions were not fast enough.\\n\\n# Approach\\nMy segment tree aims to be simple and readable.\\nThe segment tree is implemented as a vector, for locality. Each node holds the range of rows (it can also be calculated on the fly, rather than held, but i was really going for readability), as well as the maximum number of seats that can be found in a single row in the range, and the total number of available seats in the range. Overflow awareness is required.\\n\\n# Complexity\\n- Time complexity:\\nBuild the segment tree: O(n). but this happens just once per test case.\\nThen, each gather/scatter query, takes O(log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass BookMyShow {\\npublic:\\n    BookMyShow(int n, int m): row_len(m) {\\n        int mask = 1;\\n        while (mask < n) mask <<= 1; // next power of 2 of n\\n        seg.resize(mask * 2 - 1); // for a \\'perfect\\' bst\\n        build(0, 0, n - 1);\\n    }\\n    \\n    vector<int> gather(int k, int max_row) {\\n        return gather(k, max_row, 0);\\n    }\\n    \\n    bool scatter(int k, int max_row) {\\n        long k_copy = k;\\n        scatterQuery(k_copy, max_row, 0);\\n        if (k_copy > 0) return false;\\n        scatterCommit(k_copy = k, 0);\\n        return true;\\n    }\\n    \\nprivate:\\n    \\n    void build(int seg_idx, int row_l, int row_r) {\\n        if (row_l == row_r) {\\n            seg[seg_idx] = { row_l, row_r, row_len, row_len };\\n            return;\\n        }\\n        seg[seg_idx] = { row_l, row_r, row_len, (row_r - row_l + 1) * row_len };\\n        auto mid = row_l + ((row_r - row_l) / 2);\\n        build(seg_idx * 2 + 1, row_l, mid);\\n        build(seg_idx * 2 + 2, mid + 1, row_r);\\n    }\\n\\n    vector<int> gather(int k, int max_row, int seg_idx) {\\n        auto& node = seg[seg_idx];\\n        if ((node.from > max_row) || (node.max < k)) return { };\\n        if (node.from == node.to) {\\n            auto res = { node.from, static_cast<int>(row_len - node.total) };\\n            node.max = node.total -= k;\\n            return res;\\n        }\\n        auto res = gather(k, max_row, seg_idx * 2 + 1);\\n        if (res.empty()) {\\n            res = gather(k, max_row, seg_idx * 2 + 2);\\n        }\\n        if (!res.empty()) {\\n            node.max = max(seg[seg_idx * 2 + 1].max, seg[seg_idx * 2 + 2].max);\\n            node.total -= k;\\n        }\\n        return res;\\n    }\\n    \\n    void scatterQuery(long& k, int max_row, int seg_idx) const {\\n        const auto& node = seg[seg_idx];\\n        if ((k <= 0) || (node.from > max_row) || (node.total == 0)) return;\\n        if (node.to <= max_row) {\\n            k -= node.total;\\n            return;\\n        }\\n        scatterQuery(k, max_row, seg_idx * 2 + 1);\\n        scatterQuery(k, max_row, seg_idx * 2 + 2);\\n    }\\n    \\n    long scatterCommit(long& k, int seg_idx) {\\n        auto& node = seg[seg_idx];\\n        if ((k <= 0) || (node.total == 0)) return node.max;\\n        if (node.from == node.to) {\\n            auto take = min(k, node.total);\\n            k -= take;\\n            node.max = node.total -= take;\\n            return node.max;\\n        }\\n        auto save_k = k;\\n        auto max1 = scatterCommit(k, seg_idx * 2 + 1);\\n        auto max2 = scatterCommit(k, seg_idx * 2 + 2);\\n        node.max = max(max1, max2);\\n        node.total -= save_k - k;\\n        return node.max;\\n    }\\n    \\nprivate:\\n    long row_len;\\n    struct node {\\n        int from, to;\\n        long max;\\n        long total;\\n    };\\n    vector<node> seg;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    BookMyShow(int n, int m): row_len(m) {\\n        int mask = 1;\\n        while (mask < n) mask <<= 1; // next power of 2 of n\\n        seg.resize(mask * 2 - 1); // for a \\'perfect\\' bst\\n        build(0, 0, n - 1);\\n    }\\n    \\n    vector<int> gather(int k, int max_row) {\\n        return gather(k, max_row, 0);\\n    }\\n    \\n    bool scatter(int k, int max_row) {\\n        long k_copy = k;\\n        scatterQuery(k_copy, max_row, 0);\\n        if (k_copy > 0) return false;\\n        scatterCommit(k_copy = k, 0);\\n        return true;\\n    }\\n    \\nprivate:\\n    \\n    void build(int seg_idx, int row_l, int row_r) {\\n        if (row_l == row_r) {\\n            seg[seg_idx] = { row_l, row_r, row_len, row_len };\\n            return;\\n        }\\n        seg[seg_idx] = { row_l, row_r, row_len, (row_r - row_l + 1) * row_len };\\n        auto mid = row_l + ((row_r - row_l) / 2);\\n        build(seg_idx * 2 + 1, row_l, mid);\\n        build(seg_idx * 2 + 2, mid + 1, row_r);\\n    }\\n\\n    vector<int> gather(int k, int max_row, int seg_idx) {\\n        auto& node = seg[seg_idx];\\n        if ((node.from > max_row) || (node.max < k)) return { };\\n        if (node.from == node.to) {\\n            auto res = { node.from, static_cast<int>(row_len - node.total) };\\n            node.max = node.total -= k;\\n            return res;\\n        }\\n        auto res = gather(k, max_row, seg_idx * 2 + 1);\\n        if (res.empty()) {\\n            res = gather(k, max_row, seg_idx * 2 + 2);\\n        }\\n        if (!res.empty()) {\\n            node.max = max(seg[seg_idx * 2 + 1].max, seg[seg_idx * 2 + 2].max);\\n            node.total -= k;\\n        }\\n        return res;\\n    }\\n    \\n    void scatterQuery(long& k, int max_row, int seg_idx) const {\\n        const auto& node = seg[seg_idx];\\n        if ((k <= 0) || (node.from > max_row) || (node.total == 0)) return;\\n        if (node.to <= max_row) {\\n            k -= node.total;\\n            return;\\n        }\\n        scatterQuery(k, max_row, seg_idx * 2 + 1);\\n        scatterQuery(k, max_row, seg_idx * 2 + 2);\\n    }\\n    \\n    long scatterCommit(long& k, int seg_idx) {\\n        auto& node = seg[seg_idx];\\n        if ((k <= 0) || (node.total == 0)) return node.max;\\n        if (node.from == node.to) {\\n            auto take = min(k, node.total);\\n            k -= take;\\n            node.max = node.total -= take;\\n            return node.max;\\n        }\\n        auto save_k = k;\\n        auto max1 = scatterCommit(k, seg_idx * 2 + 1);\\n        auto max2 = scatterCommit(k, seg_idx * 2 + 2);\\n        node.max = max(max1, max2);\\n        node.total -= save_k - k;\\n        return node.max;\\n    }\\n    \\nprivate:\\n    long row_len;\\n    struct node {\\n        int from, to;\\n        long max;\\n        long total;\\n    };\\n    vector<node> seg;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017243,
                "title": "100-c-segment-tree-based-solution",
                "content": "# Intuition\\nThe problem is about efficiently allocating seats in a concert hall with ***n*** rows and ***m*** seats per row. We have two types of seat allocations to handle:\\n\\n- **Gather**: Allocate ***k*** contiguous seats in a row for a group, within a given ***maxRow***.\\n- **Scatter**: Allocate ***k*** seats (not necessarily contiguous or in the same row) for a group, within a given ***maxRow***.\\n\\nWe\\'re looking for an efficient way to handle these seat allocations.\\n\\n# Approach\\nWe use a segment tree to keep track of the maximum available contiguous seats and the total available seats for each segment (or range of rows). The segment tree allows us to efficiently query and update these values.\\n\\nThe Gather operation queries the segment tree to find the first row with enough contiguous seats. If found, it then updates the segment tree to reflect the booked seats.\\n\\nThe Scatter operation queries the segment tree to find if there are enough total seats available. If yes, it then updates the segment tree to reflect the booked seats.\\n\\n# Complexity\\n- Time complexity:\\n    - Building the segment tree takes ***O(nlog\\u2061n)***\\n    - Each query and update operation takes ***O(log\\u2061n)***\\n- Space complexity:\\n    - The segment tree takes ***O(n)*** space\\n\\n# Code\\n```\\npublic class BookMyShow\\n{\\n    private int rowCount;\\n    private int seatCount;\\n    private Tuple<long, long>[] treeData;\\n\\n    public BookMyShow(int n, int m)\\n    {\\n        rowCount = n;\\n        seatCount = m;\\n\\n        int treeSize = 1;\\n        while (treeSize < 2 * n)\\n            treeSize *= 2;\\n\\n        treeData = new Tuple<long, long>[treeSize];\\n        BuildTree(0, 0, n - 1);\\n    }\\n\\n    private void BuildTree(int node, int start, int end)\\n    {\\n        if (start == end)\\n        {\\n            treeData[node] = Tuple.Create((long)seatCount, (long)seatCount);\\n            return;\\n        }\\n        int mid = (start + end) / 2;\\n        BuildTree(2 * node + 1, start, mid);\\n        BuildTree(2 * node + 2, mid + 1, end);\\n        treeData[node] = Tuple.Create((long)seatCount, (long)(end - start + 1) * seatCount);\\n    }\\n\\n    public int[] Gather(int k, int maxRow)\\n    {\\n        var result = QueryMax(0, 0, rowCount - 1, k, maxRow);\\n        if (result != null)\\n        {\\n            UpdateMax(0, 0, rowCount - 1, result[0], k);\\n            return result;\\n        }\\n        return new int[0];\\n    }\\n\\n    private int[] QueryMax(int node, int start, int end, int k, int maxRow)\\n    {\\n        if (start > maxRow || treeData[node].Item1 < k)\\n            return null;\\n        if (start == end)\\n            return new int[] { start, seatCount - (int)treeData[node].Item1 };\\n\\n        int mid = (start + end) / 2;\\n        var leftResult = QueryMax(2 * node + 1, start, mid, k, maxRow);\\n        if (leftResult != null)\\n            return leftResult;\\n\\n        return QueryMax(2 * node + 2, mid + 1, end, k, maxRow);\\n    }\\n\\n    private void UpdateMax(int node, int start, int end, int row, int k)\\n    {\\n        if (start > row || end < row)\\n            return;\\n        if (start == end)\\n        {\\n            treeData[node] = Tuple.Create(treeData[node].Item1 - k, treeData[node].Item2 - k);\\n            return;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        UpdateMax(2 * node + 1, start, mid, row, k);\\n        UpdateMax(2 * node + 2, mid + 1, end, row, k);\\n        treeData[node] = Tuple.Create(Math.Max(treeData[2 * node + 1].Item1, treeData[2 * node + 2].Item1), treeData[node].Item2 - k);\\n    }\\n\\n    public bool Scatter(int k, int maxRow)\\n    {\\n        long totalSeats = QuerySum(0, 0, rowCount - 1, maxRow);\\n        if (totalSeats < k)\\n            return false;\\n        UpdateSum(0, 0, rowCount - 1, k, maxRow);\\n        return true;\\n    }\\n\\n    private long QuerySum(int node, int start, int end, int maxRow)\\n    {\\n        if (start > maxRow)\\n            return 0;\\n        if (end <= maxRow)\\n            return treeData[node].Item2;\\n\\n        int mid = (start + end) / 2;\\n        return QuerySum(2 * node + 1, start, mid, maxRow) + QuerySum(2 * node + 2, mid + 1, end, maxRow);\\n    }\\n\\n    private void UpdateSum(int node, int start, int end, int k, int maxRow)\\n    {\\n        if (start > maxRow)\\n            return;\\n\\n        if (start == end)\\n        {\\n            treeData[node] = Tuple.Create(treeData[node].Item1 - k, treeData[node].Item2 - k);\\n            return;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        treeData[node] = Tuple.Create(treeData[node].Item1, treeData[node].Item2 - k);\\n\\n        if (treeData[2 * node + 1].Item2 >= k)\\n        {\\n            UpdateSum(2 * node + 1, start, mid, k, maxRow);\\n        }\\n        else\\n        {\\n            int remaining = k - (int)treeData[2 * node + 1].Item2;\\n            UpdateSum(2 * node + 1, start, mid, (int)treeData[2 * node + 1].Item2, maxRow);\\n            UpdateSum(2 * node + 2, mid + 1, end, remaining, maxRow);\\n        }\\n\\n        treeData[node] = Tuple.Create(Math.Max(treeData[2 * node + 1].Item1, treeData[2 * node + 2].Item1), treeData[node].Item2);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class BookMyShow\\n{\\n    private int rowCount;\\n    private int seatCount;\\n    private Tuple<long, long>[] treeData;\\n\\n    public BookMyShow(int n, int m)\\n    {\\n        rowCount = n;\\n        seatCount = m;\\n\\n        int treeSize = 1;\\n        while (treeSize < 2 * n)\\n            treeSize *= 2;\\n\\n        treeData = new Tuple<long, long>[treeSize];\\n        BuildTree(0, 0, n - 1);\\n    }\\n\\n    private void BuildTree(int node, int start, int end)\\n    {\\n        if (start == end)\\n        {\\n            treeData[node] = Tuple.Create((long)seatCount, (long)seatCount);\\n            return;\\n        }\\n        int mid = (start + end) / 2;\\n        BuildTree(2 * node + 1, start, mid);\\n        BuildTree(2 * node + 2, mid + 1, end);\\n        treeData[node] = Tuple.Create((long)seatCount, (long)(end - start + 1) * seatCount);\\n    }\\n\\n    public int[] Gather(int k, int maxRow)\\n    {\\n        var result = QueryMax(0, 0, rowCount - 1, k, maxRow);\\n        if (result != null)\\n        {\\n            UpdateMax(0, 0, rowCount - 1, result[0], k);\\n            return result;\\n        }\\n        return new int[0];\\n    }\\n\\n    private int[] QueryMax(int node, int start, int end, int k, int maxRow)\\n    {\\n        if (start > maxRow || treeData[node].Item1 < k)\\n            return null;\\n        if (start == end)\\n            return new int[] { start, seatCount - (int)treeData[node].Item1 };\\n\\n        int mid = (start + end) / 2;\\n        var leftResult = QueryMax(2 * node + 1, start, mid, k, maxRow);\\n        if (leftResult != null)\\n            return leftResult;\\n\\n        return QueryMax(2 * node + 2, mid + 1, end, k, maxRow);\\n    }\\n\\n    private void UpdateMax(int node, int start, int end, int row, int k)\\n    {\\n        if (start > row || end < row)\\n            return;\\n        if (start == end)\\n        {\\n            treeData[node] = Tuple.Create(treeData[node].Item1 - k, treeData[node].Item2 - k);\\n            return;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        UpdateMax(2 * node + 1, start, mid, row, k);\\n        UpdateMax(2 * node + 2, mid + 1, end, row, k);\\n        treeData[node] = Tuple.Create(Math.Max(treeData[2 * node + 1].Item1, treeData[2 * node + 2].Item1), treeData[node].Item2 - k);\\n    }\\n\\n    public bool Scatter(int k, int maxRow)\\n    {\\n        long totalSeats = QuerySum(0, 0, rowCount - 1, maxRow);\\n        if (totalSeats < k)\\n            return false;\\n        UpdateSum(0, 0, rowCount - 1, k, maxRow);\\n        return true;\\n    }\\n\\n    private long QuerySum(int node, int start, int end, int maxRow)\\n    {\\n        if (start > maxRow)\\n            return 0;\\n        if (end <= maxRow)\\n            return treeData[node].Item2;\\n\\n        int mid = (start + end) / 2;\\n        return QuerySum(2 * node + 1, start, mid, maxRow) + QuerySum(2 * node + 2, mid + 1, end, maxRow);\\n    }\\n\\n    private void UpdateSum(int node, int start, int end, int k, int maxRow)\\n    {\\n        if (start > maxRow)\\n            return;\\n\\n        if (start == end)\\n        {\\n            treeData[node] = Tuple.Create(treeData[node].Item1 - k, treeData[node].Item2 - k);\\n            return;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        treeData[node] = Tuple.Create(treeData[node].Item1, treeData[node].Item2 - k);\\n\\n        if (treeData[2 * node + 1].Item2 >= k)\\n        {\\n            UpdateSum(2 * node + 1, start, mid, k, maxRow);\\n        }\\n        else\\n        {\\n            int remaining = k - (int)treeData[2 * node + 1].Item2;\\n            UpdateSum(2 * node + 1, start, mid, (int)treeData[2 * node + 1].Item2, maxRow);\\n            UpdateSum(2 * node + 2, mid + 1, end, remaining, maxRow);\\n        }\\n\\n        treeData[node] = Tuple.Create(Math.Max(treeData[2 * node + 1].Item1, treeData[2 * node + 2].Item1), treeData[node].Item2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989343,
                "title": "typescript-solution-with-code-comments",
                "content": "# Intuition\\nKeep a tab on how many seats are available in each row after each operation\\nDo not update any seat availability until we know the whole group can be seated\\n\\n# Approach\\nFirst, add member variables for the number of total seats in each row `this.seatsPerRow` plus an object to record seat availability on a given row `this.rows`.\\n\\n`gather`: Simple enough: go through each row until you find one with enough seats for the whole group at once. If found, subtract the seats from the row in `this.rows`, then return the first used seat. If no row is found, return an empty array.\\n\\n`scatter` A little tricky, but still not too bad once you break it down. First, go through each row, subtracting members of the group each row based on available seats. On the last row, if the group fits, note how many seats are used there, then subtract it from that row in `this.rows`; fill all previous rows (set each prior row in `this.rows` to `0`). If the group doesn\\'t fit by the time you get through `maxRow`, return `false`.\\n\\nIt is very important to not prematurely mark seats used before knowing the whole group fits! Please comment if anything is unclear :)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BookMyShow {\\n    rows: Record<number, number> = {};\\n    seatsPerRow;\\n\\n    constructor(n: number, m: number) {\\n        // How many seats per row\\n        this.seatsPerRow = m;\\n\\n        for (let i = 0; i < n; i++) {\\n            // Keep track of how many seats are available for a given row\\n            this.rows[i] = m;\\n        }\\n    }\\n\\n    gather(k: number, maxRow: number): number[] {\\n        for (let i = 0; i <= maxRow; i++) {\\n            const seatsLeft = this.rows[i];\\n\\n            // Find the first row with enough seats for the whole group\\n            if (k <= seatsLeft) {\\n                // When found, subtract the number needed for the group from the row\\n                this.rows[i] -= k;\\n                // Return the first seat used by this group\\n                // from the end of the row, go back how many were available initially\\n                // group seated :)\\n                return [i, this.seatsPerRow - seatsLeft];\\n            }\\n        }\\n\\n        // Return an empty array if no row with enough seats found\\n        return [];\\n    }\\n\\n    scatter(k: number, maxRow: number): boolean {\\n        // We decalre i out here to later find the last row used by the group\\n        let i;\\n        let seatsOnLastRow = 0;\\n\\n        // Go through each row until all seats needed are gone\\n        // do NOT edit the seats count yet\\n        // we don\\'t know yet if the group will end up using them\\n        for (i = 0; i <= maxRow; i++) {\\n            const seatsLeft = this.rows[i];\\n\\n            if (k > seatsLeft) {\\n                // Return false if there are more people than seats on maxRow\\n                // we can\\'t fulfill their request\\n                if (i === maxRow) return false;\\n                // Subtract the number of available seats in the row from the group\\n                k -= seatsLeft;\\n            } else {\\n                // Make a note of how many seats needed in the last row for the group\\n                seatsOnLastRow = k;\\n                break;\\n            }\\n        }\\n\\n        // Fill all rows before the last\\n        for (let j = 0; j < i; j++) this.rows[j] = 0;\\n        // Subtract the needed number of seats on the last row\\n        this.rows[i] -= seatsOnLastRow;\\n\\n        // Group seated :)\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass BookMyShow {\\n    rows: Record<number, number> = {};\\n    seatsPerRow;\\n\\n    constructor(n: number, m: number) {\\n        // How many seats per row\\n        this.seatsPerRow = m;\\n\\n        for (let i = 0; i < n; i++) {\\n            // Keep track of how many seats are available for a given row\\n            this.rows[i] = m;\\n        }\\n    }\\n\\n    gather(k: number, maxRow: number): number[] {\\n        for (let i = 0; i <= maxRow; i++) {\\n            const seatsLeft = this.rows[i];\\n\\n            // Find the first row with enough seats for the whole group\\n            if (k <= seatsLeft) {\\n                // When found, subtract the number needed for the group from the row\\n                this.rows[i] -= k;\\n                // Return the first seat used by this group\\n                // from the end of the row, go back how many were available initially\\n                // group seated :)\\n                return [i, this.seatsPerRow - seatsLeft];\\n            }\\n        }\\n\\n        // Return an empty array if no row with enough seats found\\n        return [];\\n    }\\n\\n    scatter(k: number, maxRow: number): boolean {\\n        // We decalre i out here to later find the last row used by the group\\n        let i;\\n        let seatsOnLastRow = 0;\\n\\n        // Go through each row until all seats needed are gone\\n        // do NOT edit the seats count yet\\n        // we don\\'t know yet if the group will end up using them\\n        for (i = 0; i <= maxRow; i++) {\\n            const seatsLeft = this.rows[i];\\n\\n            if (k > seatsLeft) {\\n                // Return false if there are more people than seats on maxRow\\n                // we can\\'t fulfill their request\\n                if (i === maxRow) return false;\\n                // Subtract the number of available seats in the row from the group\\n                k -= seatsLeft;\\n            } else {\\n                // Make a note of how many seats needed in the last row for the group\\n                seatsOnLastRow = k;\\n                break;\\n            }\\n        }\\n\\n        // Fill all rows before the last\\n        for (let j = 0; j < i; j++) this.rows[j] = 0;\\n        // Subtract the needed number of seats on the last row\\n        this.rows[i] -= seatsOnLastRow;\\n\\n        // Group seated :)\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960144,
                "title": "python-research-upgrade",
                "content": "# Intuition\\n<!-- When dealing with seat booking for shows, two primary operations are required:\\n\\nGather: Book a specific number of contiguous seats in a row.\\nScatter: Attempt to book a certain number of seats across potentially multiple rows.\\nThe solution tries to find the best row for a particular group\\'s booking and fills up available seats. Given the constraints, it\\'s crucial to manage the seats efficiently to minimize runtime and memory usage. -->\\n\\n# Approach\\n<!-- Initialization:\\ncalls_remaining: Limit the number of API calls for testing purposes.\\nn and m: Size constraints for the rows and seats in each row.\\nrows: A dictionary representing each row and the available seats in that row.\\nlast_row_f: Keeps track of the last row filled.\\ndbook: A dictionary that serves as a cache for the number of seats booked to quickly fetch which row can serve a similar booking.\\nplaces_rem: Total seats remaining.\\ncache: Cache for scatter to keep track of the maximum row that a particular number of seats was last searched. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Gather: In the worst-case scenario, the function will iterate over all rows, making it O(n), where n is the number of rows.\\nScatter: This function also might iterate over all rows in the worst-case scenario, making it O(n) as well. -->\\n\\n- Space complexity:\\n<!-- Initialization: The space taken by the rows dictionary is O(n), as it stores available seats for each row.\\ndbook and cache: They dynamically grow as more distinct k values are processed. In the worst case, each distinct k value will be stored, and both dictionaries will have a size of the maximum number of distinct k values possible in the provided test cases. Hence, these dictionaries also contribute O(n) to the space complexity.\\nIn total, the space complexity is O(n). -->\\n\\n# Code\\n```\\nclass BookMyShow(object):\\n\\n    def __init__(self, n, m):\\n        self.calls_remaining = int(5 * 10e4)\\n        n = min(n, self.calls_remaining)\\n        m = min(m, 10e9)\\n        \\n        self.n, self.m = n, m\\n        self.rows = {i: m for i in range(n)}\\n        self.last_row_f = 0\\n        self.dbook = {m: 0}\\n        self.places_rem = m * n\\n        self.cache = {}\\n\\n    def gather(self, k, maxRow):\\n        if not self.calls_remaining or k > self.m or k > self.places_rem: \\n            return []\\n        self.calls_remaining -= 1\\n        maxRow = maxRow if maxRow < self.n else self.n - 1\\n\\n        i = self.dbook.get(k, self.last_row_f)\\n        while i <= maxRow:\\n            if self.rows.get(i, 0) >= k:\\n                seat = self.m - self.rows[i]\\n                self.rows[i] -= k\\n                if self.rows[i] == self.m:\\n                    self.last_row_f = i\\n                self.dbook[k] = i\\n                self.places_rem -= k\\n                return [i, seat]\\n            i += 1\\n\\n        self.dbook[k] = maxRow\\n        return []\\n\\n    def scatter(self, k, maxRow):\\n        if not self.calls_remaining or k > self.places_rem: \\n            return False\\n        self.calls_remaining -= 1\\n        k = k if k < 10e9 else int(10e9)\\n        maxRow = maxRow if maxRow < self.n else self.n - 1\\n\\n        if self.cache.get(maxRow, float(\\'inf\\')) <= k: \\n            return False\\n\\n        free_space_taken = 0\\n        i = self.last_row_f\\n        while i <= maxRow:\\n            nb_free = self.rows.get(i, 0)\\n            if nb_free:\\n                if nb_free >= k:\\n                    self.rows[i] -= k\\n                    self.places_rem -= k\\n                    j = self.last_row_f\\n                    while j < i:\\n                        self.places_rem -= self.rows.pop(j, 0)\\n                        j += 1\\n                    self.last_row_f = j\\n                    return True\\n                k -= nb_free\\n            free_space_taken += 1\\n            i += 1\\n\\n        self.cache[maxRow] = k\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BookMyShow(object):\\n\\n    def __init__(self, n, m):\\n        self.calls_remaining = int(5 * 10e4)\\n        n = min(n, self.calls_remaining)\\n        m = min(m, 10e9)\\n        \\n        self.n, self.m = n, m\\n        self.rows = {i: m for i in range(n)}\\n        self.last_row_f = 0\\n        self.dbook = {m: 0}\\n        self.places_rem = m * n\\n        self.cache = {}\\n\\n    def gather(self, k, maxRow):\\n        if not self.calls_remaining or k > self.m or k > self.places_rem: \\n            return []\\n        self.calls_remaining -= 1\\n        maxRow = maxRow if maxRow < self.n else self.n - 1\\n\\n        i = self.dbook.get(k, self.last_row_f)\\n        while i <= maxRow:\\n            if self.rows.get(i, 0) >= k:\\n                seat = self.m - self.rows[i]\\n                self.rows[i] -= k\\n                if self.rows[i] == self.m:\\n                    self.last_row_f = i\\n                self.dbook[k] = i\\n                self.places_rem -= k\\n                return [i, seat]\\n            i += 1\\n\\n        self.dbook[k] = maxRow\\n        return []\\n\\n    def scatter(self, k, maxRow):\\n        if not self.calls_remaining or k > self.places_rem: \\n            return False\\n        self.calls_remaining -= 1\\n        k = k if k < 10e9 else int(10e9)\\n        maxRow = maxRow if maxRow < self.n else self.n - 1\\n\\n        if self.cache.get(maxRow, float(\\'inf\\')) <= k: \\n            return False\\n\\n        free_space_taken = 0\\n        i = self.last_row_f\\n        while i <= maxRow:\\n            nb_free = self.rows.get(i, 0)\\n            if nb_free:\\n                if nb_free >= k:\\n                    self.rows[i] -= k\\n                    self.places_rem -= k\\n                    j = self.last_row_f\\n                    while j < i:\\n                        self.places_rem -= self.rows.pop(j, 0)\\n                        j += 1\\n                    self.last_row_f = j\\n                    return True\\n                k -= nb_free\\n            free_space_taken += 1\\n            i += 1\\n\\n        self.cache[maxRow] = k\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950112,
                "title": "optimized-seat-allocation-clean-code-explained",
                "content": "# Intuition\\nThe problem requires efficiently handling seat reservations for large numbers of rows and seats. Two main functionalities are provided: gathering (where a group of k spectators must sit together) and scattering (where a group of k spectators may or may not sit together). The approach is to keep track of available seats using smart data structures to minimize both time and space complexity.\\n\\n# Approach\\n- Initialize variables to keep track of the first available seat in each row and the first available row for k consecutive seats.\\n- In the `gather` method, iterate through the rows to find the first available consecutive seats of k size. Update the available seats accordingly.\\n- In the `scatter` method, iterate through the rows to allocate k seats, which may or may not be consecutive. Use a set to remember combinations that cannot be scattered.\\n- Use dictionaries and sets to avoid storing the entire seating arrangement, making the approach memory efficient.\\n\\n# Complexity\\n- Time complexity:\\n  - The `gather` method takes $$O(n \\\\cdot m)$$ in the worst case, where n is the number of rows and m is the number of seats per row.\\n  - The `scatter` method takes $$O(n)$$, where n is the number of rows.\\n- Space complexity:\\n  - $$O(n)$$, where n is the number of rows, as we are only keeping track of the first available seat in each row and some additional information.\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass BookMyShow:    \\n    def __init__(self, n: int, m: int):\\n        self.N, self.M = n, m\\n        self.first_row = 0\\n        self.first_row_table = defaultdict(int) # Tracks the first available row for k consecutive seats\\n        self.first_seats = [0] * n              # Tracks the first available seat in each row\\n        self.unable_value_set = set()           # Tracks combinations of k and maxRow that cannot be scattered\\n\\n    def update_first_row(self, row, k):\\n        # Update the first available row for k consecutive seats\\n        while self.first_row < self.N and self.first_seats[self.first_row] == self.M:\\n            self.first_row += 1\\n        self.first_row_table[k] = max(self.first_row, row)\\n        row = self.first_row_table[k]\\n        while row < self.N and self.M - self.first_seats[row] < k:\\n            row += 1\\n        self.first_row_table[k] = row\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.M or self.first_row_table[k] > maxRow:\\n            return []\\n        for row in range(max(self.first_row, self.first_row_table[k]), min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                result = [row, self.first_seats[row]]\\n                self.first_seats[row] += k\\n                self.update_first_row(row, k)\\n                return result\\n        return []                \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        # Return false if previously determined to be unable\\n        if (k, maxRow) in self.unable_value_set:\\n            return False\\n        \\n        k1 = k\\n        for row in range(self.first_row, min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                self.first_seats[row] += k\\n                self.first_row = row                \\n                return True\\n            elif self.M - self.first_seats[row] == k:\\n                self.first_row = row + 1\\n                return True\\n            else:\\n                k -= self.M - self.first_seats[row]\\n                \\n        # Mark as unable and return false\\n        self.unable_value_set.add((k1, maxRow))\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass BookMyShow:    \\n    def __init__(self, n: int, m: int):\\n        self.N, self.M = n, m\\n        self.first_row = 0\\n        self.first_row_table = defaultdict(int) # Tracks the first available row for k consecutive seats\\n        self.first_seats = [0] * n              # Tracks the first available seat in each row\\n        self.unable_value_set = set()           # Tracks combinations of k and maxRow that cannot be scattered\\n\\n    def update_first_row(self, row, k):\\n        # Update the first available row for k consecutive seats\\n        while self.first_row < self.N and self.first_seats[self.first_row] == self.M:\\n            self.first_row += 1\\n        self.first_row_table[k] = max(self.first_row, row)\\n        row = self.first_row_table[k]\\n        while row < self.N and self.M - self.first_seats[row] < k:\\n            row += 1\\n        self.first_row_table[k] = row\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if k > self.M or self.first_row_table[k] > maxRow:\\n            return []\\n        for row in range(max(self.first_row, self.first_row_table[k]), min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                result = [row, self.first_seats[row]]\\n                self.first_seats[row] += k\\n                self.update_first_row(row, k)\\n                return result\\n        return []                \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        # Return false if previously determined to be unable\\n        if (k, maxRow) in self.unable_value_set:\\n            return False\\n        \\n        k1 = k\\n        for row in range(self.first_row, min(self.N, maxRow + 1)):\\n            if self.M - self.first_seats[row] >= k:\\n                self.first_seats[row] += k\\n                self.first_row = row                \\n                return True\\n            elif self.M - self.first_seats[row] == k:\\n                self.first_row = row + 1\\n                return True\\n            else:\\n                k -= self.M - self.first_seats[row]\\n                \\n        # Mark as unable and return false\\n        self.unable_value_set.add((k1, maxRow))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935984,
                "title": "segment-tree-solution",
                "content": "\\n\\n# Code\\n```\\nclass SegTree {\\n    vector<int>mx;\\n    vector<long long>sum;\\n    int cnt;\\n\\n    public:\\n    SegTree(){}\\n\\n    SegTree(int n) {\\n        mx.resize(4*n);\\n        sum.resize(4*n);\\n    }\\n\\n    void update(int pos,int val,int st,int en,int node) {\\n        if(st > pos or en < pos) return;\\n        if(st == en) {\\n            mx[node] = val;\\n            sum[node] = val;\\n            return;\\n        }\\n\\n        int mid = (st+en)>>1;\\n\\n        update(pos,val,st,mid,2*node);\\n        update(pos,val,mid+1,en,2*node+1);\\n        mx[node] = max(mx[2*node],mx[2*node+1]);\\n        sum[node] = sum[2*node]+sum[2*node+1];\\n    }\\n\\n    long long query(int l,int r,int st,int en,int node) {\\n        if(st > r or en < l) return 0;\\n        if(st >= l and en <= r) return sum[node];\\n        int mid = (st+en)>>1;\\n        return query(l,r,st,mid,2*node)+query(l,r,mid+1,en,2*node+1);\\n    }\\n\\n    void nge(int val,int st,int en,int node) {\\n        if(st > cnt) return;\\n        if(mx[node] < val) {\\n            cnt += en-st+1;\\n            return;\\n        }\\n\\n        if(st == en) return;\\n\\n        int mid = (st+en)>>1;\\n        nge(val,st,mid,2*node);\\n        nge(val,mid+1,en,2*node+1);\\n    }\\n\\n    int find_nge(int val,int n) {\\n        this->cnt = 0;\\n        nge(val,0,n-1,1);\\n\\n        return cnt;\\n    }\\n};\\n\\nclass BookMyShow {\\n    int n,m;\\n    vector<int>col;\\n    SegTree tr;\\n    int start_idx;\\npublic:\\n    BookMyShow(int n, int m) {\\n        start_idx = 0;\\n        tr = SegTree(n);\\n        this->n = n;\\n        this->m = m;\\n        col.assign(n,0);\\n        \\n        for(int i=0;i<n;i++) tr.update(i,m,0,n-1,1);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        vector<int>ret;\\n        int r = tr.find_nge(k,n);\\n       \\n        if(r > maxRow) return ret;\\n\\n        ret = {r,col[r]};\\n\\n        col[r] += k;\\n\\n        tr.update(r,m-col[r],0,n-1,1);\\n\\n        return ret;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if(tr.query(0,maxRow,0,n-1,1) < k) return false;\\n\\n        for(int i=start_idx;k > 0;i++) {\\n            if(m-col[i] <= k) {\\n                k -= m-col[i];\\n                col[i] = m;\\n                tr.update(i,0,0,n-1,1);\\n                start_idx = i;\\n            }\\n            else {\\n                col[i] += k;\\n                tr.update(i,m-col[i],0,n-1,1);\\n                k = 0;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SegTree {\\n    vector<int>mx;\\n    vector<long long>sum;\\n    int cnt;\\n\\n    public:\\n    SegTree(){}\\n\\n    SegTree(int n) {\\n        mx.resize(4*n);\\n        sum.resize(4*n);\\n    }\\n\\n    void update(int pos,int val,int st,int en,int node) {\\n        if(st > pos or en < pos) return;\\n        if(st == en) {\\n            mx[node] = val;\\n            sum[node] = val;\\n            return;\\n        }\\n\\n        int mid = (st+en)>>1;\\n\\n        update(pos,val,st,mid,2*node);\\n        update(pos,val,mid+1,en,2*node+1);\\n        mx[node] = max(mx[2*node],mx[2*node+1]);\\n        sum[node] = sum[2*node]+sum[2*node+1];\\n    }\\n\\n    long long query(int l,int r,int st,int en,int node) {\\n        if(st > r or en < l) return 0;\\n        if(st >= l and en <= r) return sum[node];\\n        int mid = (st+en)>>1;\\n        return query(l,r,st,mid,2*node)+query(l,r,mid+1,en,2*node+1);\\n    }\\n\\n    void nge(int val,int st,int en,int node) {\\n        if(st > cnt) return;\\n        if(mx[node] < val) {\\n            cnt += en-st+1;\\n            return;\\n        }\\n\\n        if(st == en) return;\\n\\n        int mid = (st+en)>>1;\\n        nge(val,st,mid,2*node);\\n        nge(val,mid+1,en,2*node+1);\\n    }\\n\\n    int find_nge(int val,int n) {\\n        this->cnt = 0;\\n        nge(val,0,n-1,1);\\n\\n        return cnt;\\n    }\\n};\\n\\nclass BookMyShow {\\n    int n,m;\\n    vector<int>col;\\n    SegTree tr;\\n    int start_idx;\\npublic:\\n    BookMyShow(int n, int m) {\\n        start_idx = 0;\\n        tr = SegTree(n);\\n        this->n = n;\\n        this->m = m;\\n        col.assign(n,0);\\n        \\n        for(int i=0;i<n;i++) tr.update(i,m,0,n-1,1);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        vector<int>ret;\\n        int r = tr.find_nge(k,n);\\n       \\n        if(r > maxRow) return ret;\\n\\n        ret = {r,col[r]};\\n\\n        col[r] += k;\\n\\n        tr.update(r,m-col[r],0,n-1,1);\\n\\n        return ret;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if(tr.query(0,maxRow,0,n-1,1) < k) return false;\\n\\n        for(int i=start_idx;k > 0;i++) {\\n            if(m-col[i] <= k) {\\n                k -= m-col[i];\\n                col[i] = m;\\n                tr.update(i,0,0,n-1,1);\\n                start_idx = i;\\n            }\\n            else {\\n                col[i] += k;\\n                tr.update(i,m-col[i],0,n-1,1);\\n                k = 0;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933777,
                "title": "my-second-time-ever-implementation-of-segment-tree-ugly-code-but-works-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node:\\n    def __init__(self, i, j, left = None, right = None, sum_val=0, max_val = 0) -> None:\\n        self.sum_val = sum_val\\n        self.max_val = max_val\\n        self.i, self.j, self.left, self.right = i, j, left, right\\n        \\nclass BookMyShow:\\n\\n    def constructTree(self, i, j, nums):\\n        if i > j:\\n            return None\\n        if i == j:\\n            root = Node(i, i, sum_val = nums[i], max_val=nums[i])\\n            return root\\n        if i < j : \\n            mid = int((j+i)/2)\\n            root = Node(i,j)\\n            left_node = self.constructTree(i,mid,nums)\\n            right_node = self.constructTree(mid+1, j, nums)\\n            root.left = left_node\\n            root.right = right_node\\n            root.sum_val = left_node.sum_val + right_node.sum_val\\n            root.max_val = max(left_node.max_val, right_node.max_val)\\n\\n            return root\\n\\n    def updateTree(self, index, val, root):\\n        # null\\n        if not (root and root.i<=index and root.j>=index):\\n            return\\n        # leaf\\n        if not root.left and not root.right:\\n            root.sum_val = val\\n            root.max_val = val\\n            return \\n        self.updateTree(index, val, root.left)\\n        self.updateTree(index, val, root.right)\\n        root.sum_val = 0\\n        root.max_val = float(\"-inf\")\\n        if root.left: \\n            root.sum_val += root.left.sum_val\\n            root.max_val = max(root.max_val, root.left.max_val)\\n        if root.right:\\n            root.sum_val += root.right.sum_val\\n            root.max_val = max(root.max_val, root.right.max_val)\\n\\n    def sumQueryTree(self, left,right, root):\\n        mid = int((root.i+root.j)/2)\\n        if left == root.i and right==root.j:\\n            return root.sum_val\\n\\n        if left > mid:\\n            res1 = self.sumQueryTree(left, right, \\n            root.right)\\n            return res1 \\n        elif mid >= right:\\n            res2 = self.sumQueryTree(left, right, root.left)\\n            return res2\\n        else:\\n            res3 = self.sumQueryTree(left, mid, root.left) + self.sumQueryTree(mid+1, right, root.right)\\n            return res3\\n    \\n    def firstMaxQueryTree(self, left, right, root, k):\\n        if not root or root.max_val< k:\\n            return -1\\n        if not root.left and not root.right and root.i>=left and root.i<=right:\\n            return root.i \\n        mid = int((root.i+root.j)/2)\\n        if left > mid:\\n            res1 = self.firstMaxQueryTree(left, right, root.right, k)\\n            return res1\\n        elif right <= mid:\\n            res2 = self.firstMaxQueryTree(left, right, root.left, k)\\n            return res2\\n        else:\\n            res31 = self.firstMaxQueryTree(left, mid, root.left, k)\\n            if res31 != -1:\\n                return res31\\n            res32 = self.firstMaxQueryTree(mid+1, right, root.right, k)\\n            \\n            return res32\\n\\n\\n    def __init__(self, n: int, m: int):\\n        self.m = m\\n        self.n = n\\n        self.nums = [m for _ in range(n)]\\n        self.sit_num = [0 for _ in range(n)]\\n        self.current_ind = 0\\n        self.root = self.constructTree(0, n-1, self.nums)\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        res = self.firstMaxQueryTree(0, maxRow, self.root, k)\\n        if res == -1:\\n            return []\\n        self.updateTree(res, self.m-(self.sit_num[res]+k) , self.root)\\n        cur_sitnum = self.sit_num[res]\\n        self.sit_num[res] += k\\n        return [res, cur_sitnum] \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.sumQueryTree(0, maxRow, self.root)>=k:\\n            rem_value = k\\n            while self.current_ind<len(self.nums):\\n\\n                if rem_value>self.m-(self.sit_num[self.current_ind]):\\n                    self.updateTree(self.current_ind, 0, self.root)\\n                    rem_value -= self.m-self.sit_num[self.current_ind]\\n                    self.current_ind +=1 \\n                elif rem_value < self.m-(self.sit_num[self.current_ind]):\\n                    self.updateTree(self.current_ind, self.m-(self.sit_num[self.current_ind])-rem_value, self.root)\\n                    self.sit_num[self.current_ind] += rem_value\\n                    break\\n                else:\\n                    self.updateTree(self.current_ind, 0, self.root)\\n                    self.current_ind += 1\\n                    break\\n            return True\\n        else:\\n            return False\\n                \\n                \\n\\n        \\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, i, j, left = None, right = None, sum_val=0, max_val = 0) -> None:\\n        self.sum_val = sum_val\\n        self.max_val = max_val\\n        self.i, self.j, self.left, self.right = i, j, left, right\\n        \\nclass BookMyShow:\\n\\n    def constructTree(self, i, j, nums):\\n        if i > j:\\n            return None\\n        if i == j:\\n            root = Node(i, i, sum_val = nums[i], max_val=nums[i])\\n            return root\\n        if i < j : \\n            mid = int((j+i)/2)\\n            root = Node(i,j)\\n            left_node = self.constructTree(i,mid,nums)\\n            right_node = self.constructTree(mid+1, j, nums)\\n            root.left = left_node\\n            root.right = right_node\\n            root.sum_val = left_node.sum_val + right_node.sum_val\\n            root.max_val = max(left_node.max_val, right_node.max_val)\\n\\n            return root\\n\\n    def updateTree(self, index, val, root):\\n        # null\\n        if not (root and root.i<=index and root.j>=index):\\n            return\\n        # leaf\\n        if not root.left and not root.right:\\n            root.sum_val = val\\n            root.max_val = val\\n            return \\n        self.updateTree(index, val, root.left)\\n        self.updateTree(index, val, root.right)\\n        root.sum_val = 0\\n        root.max_val = float(\"-inf\")\\n        if root.left: \\n            root.sum_val += root.left.sum_val\\n            root.max_val = max(root.max_val, root.left.max_val)\\n        if root.right:\\n            root.sum_val += root.right.sum_val\\n            root.max_val = max(root.max_val, root.right.max_val)\\n\\n    def sumQueryTree(self, left,right, root):\\n        mid = int((root.i+root.j)/2)\\n        if left == root.i and right==root.j:\\n            return root.sum_val\\n\\n        if left > mid:\\n            res1 = self.sumQueryTree(left, right, \\n            root.right)\\n            return res1 \\n        elif mid >= right:\\n            res2 = self.sumQueryTree(left, right, root.left)\\n            return res2\\n        else:\\n            res3 = self.sumQueryTree(left, mid, root.left) + self.sumQueryTree(mid+1, right, root.right)\\n            return res3\\n    \\n    def firstMaxQueryTree(self, left, right, root, k):\\n        if not root or root.max_val< k:\\n            return -1\\n        if not root.left and not root.right and root.i>=left and root.i<=right:\\n            return root.i \\n        mid = int((root.i+root.j)/2)\\n        if left > mid:\\n            res1 = self.firstMaxQueryTree(left, right, root.right, k)\\n            return res1\\n        elif right <= mid:\\n            res2 = self.firstMaxQueryTree(left, right, root.left, k)\\n            return res2\\n        else:\\n            res31 = self.firstMaxQueryTree(left, mid, root.left, k)\\n            if res31 != -1:\\n                return res31\\n            res32 = self.firstMaxQueryTree(mid+1, right, root.right, k)\\n            \\n            return res32\\n\\n\\n    def __init__(self, n: int, m: int):\\n        self.m = m\\n        self.n = n\\n        self.nums = [m for _ in range(n)]\\n        self.sit_num = [0 for _ in range(n)]\\n        self.current_ind = 0\\n        self.root = self.constructTree(0, n-1, self.nums)\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        res = self.firstMaxQueryTree(0, maxRow, self.root, k)\\n        if res == -1:\\n            return []\\n        self.updateTree(res, self.m-(self.sit_num[res]+k) , self.root)\\n        cur_sitnum = self.sit_num[res]\\n        self.sit_num[res] += k\\n        return [res, cur_sitnum] \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.sumQueryTree(0, maxRow, self.root)>=k:\\n            rem_value = k\\n            while self.current_ind<len(self.nums):\\n\\n                if rem_value>self.m-(self.sit_num[self.current_ind]):\\n                    self.updateTree(self.current_ind, 0, self.root)\\n                    rem_value -= self.m-self.sit_num[self.current_ind]\\n                    self.current_ind +=1 \\n                elif rem_value < self.m-(self.sit_num[self.current_ind]):\\n                    self.updateTree(self.current_ind, self.m-(self.sit_num[self.current_ind])-rem_value, self.root)\\n                    self.sit_num[self.current_ind] += rem_value\\n                    break\\n                else:\\n                    self.updateTree(self.current_ind, 0, self.root)\\n                    self.current_ind += 1\\n                    break\\n            return True\\n        else:\\n            return False\\n                \\n                \\n\\n        \\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929064,
                "title": "java-o-n-memory-solution",
                "content": "- Space complexity: O(N)\\n\\n# Code\\n```\\nclass BookMyShow {\\n\\n    int seatsInARow, arr[];\\n    long overallSeatsLeft;\\n    public BookMyShow(int n, int m) {\\n        arr = new int[n];\\n        seatsInARow = m;\\n        overallSeatsLeft = (long) m * n;\\n    }\\n\\n    public int[] gather(int k, int maxRow) {\\n        if (k > seatsInARow) return new int[]{};\\n        for (int r = 0; r <= maxRow; r++) {\\n            if (seatsInARow - arr[r] >= k) {\\n                int[] res = new int[]{r, arr[r]};\\n                arr[r] += k;\\n                overallSeatsLeft -= k;\\n                return res;\\n            }\\n        }\\n        return new int[]{};\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n        if (overallSeatsLeft >= k) {\\n            int sum = 0;\\n            for (int r = 0; r <= maxRow; r++) {\\n                sum += seatsInARow - arr[r];\\n                if (sum >= k) break;\\n            }\\n            if (sum >= k) {\\n                overallSeatsLeft -= k;\\n                for (int r = 0; r <= maxRow; r++) {\\n                    if (k == 0) break;\\n                    int left = seatsInARow - arr[r];\\n                    if (k >= left) {\\n                        k -= left;\\n                        arr[r] = seatsInARow;\\n                    } else {\\n                        arr[r] += k;\\n                        k = 0;\\n                    }\\n                }\\n                return true;\\n            } else {\\n                return false;\\n            }\\n            \\n        } else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BookMyShow {\\n\\n    int seatsInARow, arr[];\\n    long overallSeatsLeft;\\n    public BookMyShow(int n, int m) {\\n        arr = new int[n];\\n        seatsInARow = m;\\n        overallSeatsLeft = (long) m * n;\\n    }\\n\\n    public int[] gather(int k, int maxRow) {\\n        if (k > seatsInARow) return new int[]{};\\n        for (int r = 0; r <= maxRow; r++) {\\n            if (seatsInARow - arr[r] >= k) {\\n                int[] res = new int[]{r, arr[r]};\\n                arr[r] += k;\\n                overallSeatsLeft -= k;\\n                return res;\\n            }\\n        }\\n        return new int[]{};\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n        if (overallSeatsLeft >= k) {\\n            int sum = 0;\\n            for (int r = 0; r <= maxRow; r++) {\\n                sum += seatsInARow - arr[r];\\n                if (sum >= k) break;\\n            }\\n            if (sum >= k) {\\n                overallSeatsLeft -= k;\\n                for (int r = 0; r <= maxRow; r++) {\\n                    if (k == 0) break;\\n                    int left = seatsInARow - arr[r];\\n                    if (k >= left) {\\n                        k -= left;\\n                        arr[r] = seatsInARow;\\n                    } else {\\n                        arr[r] += k;\\n                        k = 0;\\n                    }\\n                }\\n                return true;\\n            } else {\\n                return false;\\n            }\\n            \\n        } else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732383,
                "title": "segment-tree-store-range-min-and-sum-clean-implementation",
                "content": "# Complexity\\n* Time complexity:\\n    * Scatter = $$O(log(n))$$\\n    * Gather = $$O(log(n))$$\\n    \\n# Code\\n```cpp\\nclass BookMyShow {\\npublic:\\n    using ll = long long;\\n\\n    struct Node {\\n        ll sum;\\n        int mi, lazy;\\n    };\\n\\n    int left(int i) {\\n        return 2*i + 1;\\n    }\\n\\n    int right(int i) {\\n        return 2*i + 2;\\n    }\\n\\n    vector<Node> tree;\\n\\n    void pull(int si) {\\n        tree[si].sum = tree[left(si)].sum + tree[right(si)].sum;\\n        tree[si].mi = min(tree[left(si)].mi, tree[right(si)].mi);\\n    }\\n\\n    void push(int ss, int se, int si) {\\n        if(tree[si].lazy == 0) return;\\n\\n        tree[si].sum = tree[si].lazy * (ll)(se - ss + 1);\\n        tree[si].mi = tree[si].lazy;\\n\\n        if(ss != se) {\\n            tree[left(si)].lazy = tree[si].lazy;\\n            tree[right(si)].lazy = tree[si].lazy;\\n        }\\n\\n        tree[si].lazy = 0;  \\n    }\\n\\n    pair<int,int> gather_update(int ss, int se, int si, int val, int r, int m) {\\n        push(ss, se, si);\\n\\n        if(ss == se) {\\n            if(tree[si].sum + val <= m) {\\n                pair<int,int> ans = {ss, tree[si].sum};\\n                tree[si].sum += val;\\n                tree[si].mi += val;\\n                return ans;\\n            }\\n\\n            return {-1, -1};\\n        }\\n\\n        int mid = (ss + se) / 2;\\n\\n        if(tree[left(si)].mi + val <= m) {\\n            pair<int,int> ans = gather_update(ss, mid, left(si), val, r, m);\\n\\n            if(ans.first != -1) {\\n                pull(si);\\n            }\\n\\n            return ans;\\n        }\\n\\n        if(mid+1 <= r and tree[right(si)].mi + val <= m) {\\n            pair<int,int> ans = gather_update(mid+1, se, right(si), val, r, m);\\n\\n            if(ans.first != -1) {\\n                pull(si);\\n            }\\n\\n            return ans;\\n        }\\n\\n        return {-1,-1};\\n    }\\n\\n    void range_assign(int ss, int se, int si, int val, int r) {\\n        push(ss, se, si);\\n        \\n        if(ss > r) return;\\n\\n        if(se <= r) {\\n            tree[si].lazy = val;\\n            push(ss, se, si);\\n            return;\\n        }\\n\\n        int mid = (ss + se) / 2;\\n\\n        range_assign(ss, mid, left(si), val, r);\\n        range_assign(mid+1, se, right(si), val, r);\\n\\n        pull(si);\\n    }\\n\\n    int scatter_update(int ss, int se, int si, int val, int r, int m) {\\n        push(ss, se, si);\\n\\n        if(ss == se) {\\n            if(tree[si].sum + val <= m) {\\n                tree[si].sum += val;\\n                tree[si].mi += val;\\n                return ss;\\n            }\\n\\n            return -1;\\n        }\\n\\n        int mid = (ss + se) / 2;\\n\\n        if(tree[left(si)].sum + val < (ll)(mid-ss+1) * m) {\\n            int ind = scatter_update(ss, mid, left(si), val, r, m);\\n\\n            if(ind != -1) {\\n                pull(si);\\n            }\\n\\n            return ind;\\n        }\\n\\n        if(mid+1 <= r) {\\n            int ind = scatter_update(mid+1, se, right(si), val - ((ll)(mid-ss+1)*m - tree[left(si)].sum), r, m);\\n\\n            if(ind != -1) {\\n                pull(si);\\n            }\\n\\n            return ind;\\n        }\\n\\n        return -1;\\n    }\\n\\n    int n, m;\\n\\n    // we should store both sum and minimum of range in the segment tree node\\n    // we have to support the following operations\\n    // 1. Point update\\n    // 2. Binary search to find the index of the minimum value within range\\n    // 3. Binary search to find the smallest prefix with given sum\\n    // 4. Range assignment to a value\\n    BookMyShow(int n, int m) {\\n        this->n = n;\\n        this->m = m;\\n        tree = move(vector<Node>(4*n));\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        pair<int,int> ans = gather_update(0, n-1, 0, k, maxRow, m);\\n\\n        if(ans.first != -1) return vector<int>{ans.first, ans.second};\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int ind = scatter_update(0, n-1, 0, k, maxRow, m);\\n\\n        if(ind == -1) return false;\\n\\n        range_assign(0, n-1, 0, m, ind-1);\\n\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "# Complexity\\n* Time complexity:\\n    * Scatter = $$O(log(n))$$\\n    * Gather = $$O(log(n))$$\\n    \\n# Code\\n```cpp\\nclass BookMyShow {\\npublic:\\n    using ll = long long;\\n\\n    struct Node {\\n        ll sum;\\n        int mi, lazy;\\n    };\\n\\n    int left(int i) {\\n        return 2*i + 1;\\n    }\\n\\n    int right(int i) {\\n        return 2*i + 2;\\n    }\\n\\n    vector<Node> tree;\\n\\n    void pull(int si) {\\n        tree[si].sum = tree[left(si)].sum + tree[right(si)].sum;\\n        tree[si].mi = min(tree[left(si)].mi, tree[right(si)].mi);\\n    }\\n\\n    void push(int ss, int se, int si) {\\n        if(tree[si].lazy == 0) return;\\n\\n        tree[si].sum = tree[si].lazy * (ll)(se - ss + 1);\\n        tree[si].mi = tree[si].lazy;\\n\\n        if(ss != se) {\\n            tree[left(si)].lazy = tree[si].lazy;\\n            tree[right(si)].lazy = tree[si].lazy;\\n        }\\n\\n        tree[si].lazy = 0;  \\n    }\\n\\n    pair<int,int> gather_update(int ss, int se, int si, int val, int r, int m) {\\n        push(ss, se, si);\\n\\n        if(ss == se) {\\n            if(tree[si].sum + val <= m) {\\n                pair<int,int> ans = {ss, tree[si].sum};\\n                tree[si].sum += val;\\n                tree[si].mi += val;\\n                return ans;\\n            }\\n\\n            return {-1, -1};\\n        }\\n\\n        int mid = (ss + se) / 2;\\n\\n        if(tree[left(si)].mi + val <= m) {\\n            pair<int,int> ans = gather_update(ss, mid, left(si), val, r, m);\\n\\n            if(ans.first != -1) {\\n                pull(si);\\n            }\\n\\n            return ans;\\n        }\\n\\n        if(mid+1 <= r and tree[right(si)].mi + val <= m) {\\n            pair<int,int> ans = gather_update(mid+1, se, right(si), val, r, m);\\n\\n            if(ans.first != -1) {\\n                pull(si);\\n            }\\n\\n            return ans;\\n        }\\n\\n        return {-1,-1};\\n    }\\n\\n    void range_assign(int ss, int se, int si, int val, int r) {\\n        push(ss, se, si);\\n        \\n        if(ss > r) return;\\n\\n        if(se <= r) {\\n            tree[si].lazy = val;\\n            push(ss, se, si);\\n            return;\\n        }\\n\\n        int mid = (ss + se) / 2;\\n\\n        range_assign(ss, mid, left(si), val, r);\\n        range_assign(mid+1, se, right(si), val, r);\\n\\n        pull(si);\\n    }\\n\\n    int scatter_update(int ss, int se, int si, int val, int r, int m) {\\n        push(ss, se, si);\\n\\n        if(ss == se) {\\n            if(tree[si].sum + val <= m) {\\n                tree[si].sum += val;\\n                tree[si].mi += val;\\n                return ss;\\n            }\\n\\n            return -1;\\n        }\\n\\n        int mid = (ss + se) / 2;\\n\\n        if(tree[left(si)].sum + val < (ll)(mid-ss+1) * m) {\\n            int ind = scatter_update(ss, mid, left(si), val, r, m);\\n\\n            if(ind != -1) {\\n                pull(si);\\n            }\\n\\n            return ind;\\n        }\\n\\n        if(mid+1 <= r) {\\n            int ind = scatter_update(mid+1, se, right(si), val - ((ll)(mid-ss+1)*m - tree[left(si)].sum), r, m);\\n\\n            if(ind != -1) {\\n                pull(si);\\n            }\\n\\n            return ind;\\n        }\\n\\n        return -1;\\n    }\\n\\n    int n, m;\\n\\n    // we should store both sum and minimum of range in the segment tree node\\n    // we have to support the following operations\\n    // 1. Point update\\n    // 2. Binary search to find the index of the minimum value within range\\n    // 3. Binary search to find the smallest prefix with given sum\\n    // 4. Range assignment to a value\\n    BookMyShow(int n, int m) {\\n        this->n = n;\\n        this->m = m;\\n        tree = move(vector<Node>(4*n));\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        pair<int,int> ans = gather_update(0, n-1, 0, k, maxRow, m);\\n\\n        if(ans.first != -1) return vector<int>{ans.first, ans.second};\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int ind = scatter_update(0, n-1, 0, k, maxRow, m);\\n\\n        if(ind == -1) return false;\\n\\n        range_assign(0, n-1, 0, m, ind-1);\\n\\n        return true;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3586857,
                "title": "c-soln-beats-100",
                "content": "Adding this to my list of least favorite problems. Accepted soln then TLE \\n``` \\n\\ntypedef struct node { \\n    int max;  \\n    long long sum;\\n    int range[2]; \\n    struct node *left; \\n    struct node *right;\\n} Node;   \\n\\n\\ntypedef struct { \\n    Node *root;\\n} BookMyShow; \\n\\nint p; /*num of rows*/ \\nlong long q; /*num of seats*/\\n \\n\\nvoid build(Node *root, int start, int end); \\nint *max_query(Node *root, int k, int maxRow); \\nint max_update(Node *root, int k, int row); \\nvoid sum_aux(Node *root, int k, int maxRow); \\nlong long sum_query(Node *root, int maxRow);\\nNode *create_node(int start, int end); \\n\\n\\nBookMyShow* bookMyShowCreate(int n, int m) {  \\n    int i;\\n    if(n<0 || m<0) \\n        return NULL; \\n    p = n; \\n    q = m;\\n    BookMyShow *stadium = malloc(sizeof(BookMyShow)); \\n    stadium->root = create_node(0,p); \\n    build(stadium->root,0,p);\\n    \\n    return stadium;\\n}\\n\\nint* bookMyShowGather(BookMyShow* obj, int k, int maxRow, int* retSize) { \\n    if(obj == NULL) \\n        return NULL; \\n    Node *root = obj->root; \\n    if(root->max < k) \\n        return NULL;  \\n    printf(\"%d \\\\n\",root->max);\\n    printf(\"%d \\\\n\", root->sum);\\n    int *res = max_query(root, k, maxRow); \\n    if(res){ \\n        *retSize = 2; \\n        max_update(root,k, res[0]);\\n    } \\n    else \\n        *retSize = 0; \\n    return res;\\n}\\n\\nbool bookMyShowScatter(BookMyShow* obj, int k, int maxRow) { \\n    if(!obj) \\n        return false; \\n    Node *root = obj->root; \\n    if(root->sum < k) \\n        return false; \\n    \\n    long long res = sum_query(root,maxRow); \\n    bool ret = res >=k;\\n    if(ret)  \\n        sum_aux(root, k, maxRow) ; \\n    \\n    return ret;\\n}\\n\\nvoid bookMyShowFree(BookMyShow* obj) {\\n    \\n}  \\n\\nint *max_query(Node *root, int k, int maxRow) {  \\n    if(!root || root->max < k || (root->range)[0] > maxRow) \\n        return NULL; \\n    else if(!root->left && !root->right) { \\n        int *result = malloc(sizeof(int)*2); \\n        (result)[0] = (root->range)[0]; \\n        (result)[1] = (q - root->max);  \\n        return result; \\n    } \\n    \\n    int *l = max_query(root->left, k, maxRow); \\n    if(l) \\n        return l;\\n    else \\n        return max_query(root->right, k, maxRow); \\n}  \\n\\nint max_update(Node *root, int k, int row) { /*try to recombine later*/\\n    if(!root) \\n        return 0;  \\n    if((root->range)[0] > row || (root->range)[1] < row) \\n        return root->max; \\n    \\n    if(!root->left && !root->right) { \\n        root->max -= k; \\n        root->sum -= k; \\n        return root->max;\\n    } \\n    \\n    int l = max_update(root->left, k, row); \\n    int r = max_update(root->right, k, row); \\n    \\n    root->sum -= k; \\n    root->max = l > r ? l : r;  \\n    \\n    return root->max;\\n} \\n\\nvoid sum_aux(Node *root, int k, int maxRow) { \\n    if(!root) \\n        return ; \\n    if((root->range)[0] > maxRow) \\n        return;  \\n    \\n    if(!root->left && !root->right) {\\n        root->max -= k; \\n        root->sum -= k; \\n        return ;\\n    }  \\n    \\n    root->sum -= k;\\n    if((root->right && (root->right->range)[0] > maxRow) ||  \\n           (root->left && root->left->sum >= k) ) \\n        { \\n            sum_aux(root->left, k, maxRow);\\n        } \\n    else { \\n        k -= root->left->sum; \\n        sum_aux(root->left, root->left->sum, maxRow); \\n        sum_aux(root->right, k, maxRow);\\n    }  \\n    \\n    root->max = root->left->max > root->right->max ?  \\n        root->left->max :  \\n        root->right->max; \\n    return;\\n} \\n\\nlong long sum_query(Node *root, int maxRow) { \\n    if((root->range)[0] > maxRow) \\n        return 0;  \\n    if((root->range)[1] <= maxRow) \\n        return root->sum;  \\n    return sum_query(root->left, maxRow) + sum_query(root->right, maxRow);\\n}\\n\\nvoid build(Node *root, int start, int end) { \\n    if(root == NULL || start >= end) \\n        return;  \\n    \\n    int split = (start+end)/2;\\n    root->left = create_node(start,split); \\n    root->right = create_node(split+1,end);  \\n    \\n    build(root->left,start,split); \\n    build(root->right,split+1,end); \\n\\n    return;\\n}\\n\\nNode *create_node(int start, int end) { \\n    Node *node = malloc(sizeof(Node));  \\n    node->max = q;\\n    node->sum = start == end ? q : q*((end-start)+1); \\n    (node->range)[0] = start; \\n    (node->range)[1] = end;  \\n    node->left = NULL; \\n    node->right = NULL;\\n    return node;\\n}\\n\\n/**\\n * Your BookMyShow struct will be instantiated and called as such:\\n * BookMyShow* obj = bookMyShowCreate(n, m);\\n * int* param_1 = bookMyShowGather(obj, k, maxRow, retSize);\\n \\n * bool param_2 = bookMyShowScatter(obj, k, maxRow);\\n \\n * bookMyShowFree(obj);\\n*/ \\n``` \\n\\n\\nTLE: \\n``` \\n\\n\\ntypedef struct node { \\n    int seats; \\n    int range[2]; \\n    struct node *left; \\n    struct node *right;\\n} Node;   \\n\\ntypedef struct vertex { \\n    Node *root; \\n    struct vertex *left; \\n    struct vertex *right;\\n} Vertex;\\n\\ntypedef struct { \\n    int start;\\n    Node **rows;\\n} BookMyShow;\\n \\nint search_row(Node *root, int *group, Node **fo); \\nvoid create_row(Node *root, int start, int end); \\nNode *create_node(int start, int end); \\nint *gather_aux(Node **arr, int i, int end, int *k) ;\\n\\nBookMyShow* bookMyShowCreate(int n, int m) {  \\n    int i;\\n    if(n<0 || m<0) \\n        return NULL; \\n    BookMyShow *stadium = malloc(sizeof(BookMyShow)); \\n    stadium->rows = malloc(sizeof(Node *)*n); \\n\\n    \\n    for(i = 0; i<n ; i++) {   \\n        Node *root = create_node(0,m-1); \\n        create_row(root,0,m-1); \\n        (stadium->rows)[i] = root;\\n    }   \\n    \\n    return stadium;\\n}\\n\\nint* bookMyShowGather(BookMyShow* obj, int k, int maxRow, int* retSize) { \\n    int i; \\n    int *ret = NULL; \\n    Node **stadium = NULL; \\n    if(obj == NULL) \\n        return NULL;  \\n         \\n    stadium = obj->rows; \\n    int start = obj->start;\\n\\n    for(i = 0; i<=maxRow; i++) { \\n        Node *root = stadium[i];\\n        if(root && root->seats >= k) {  \\n            Node *first_occ = NULL; \\n            int group = k;  \\n            Node *root = stadium[i];\\n            search_row(root, &group, &first_occ);  \\n            if(root->seats == 0) \\n                stadium[i] = NULL;\\n            ret = malloc(sizeof(int)*2);\\n            ret[0] = i; \\n            ret[1] = (first_occ->range)[0]; \\n            *retSize = 2; \\n            return ret;\\n        }\\n    }  \\n    *retSize = 0;  \\n    return ret;\\n}\\n\\nbool bookMyShowScatter(BookMyShow* obj, int k, int maxRow) { \\n    if(!obj) \\n        return false; \\n    Node **stadium = obj->rows;  \\n    int i,total = 0; \\n    for(i = 0; i<=maxRow; i++) {  \\n        Node *root = stadium[i];  \\n        if(root) \\n            total += root->seats; \\n        if(total>=k) \\n            break;\\n    }   \\n    if(total >= k) { \\n        for(i = 0; k > 0 && i<= maxRow; i++) { \\n            Node *root = stadium[i]; \\n            if(root && root->seats) { \\n                int group = root->seats < k ? root->seats : k; \\n                Node *dummy = NULL; \\n                int alloc = search_row(root, &group, &dummy); \\n                k-= alloc;  \\n            }\\n        }\\n        return k <= 0;\\n    }\\n    return false;\\n}\\n\\nvoid bookMyShowFree(BookMyShow* obj) {\\n    \\n}   \\n\\nint *gather_aux(Node **arr, int i, int end, int *k) { \\n    if(arr == NULL || i>end) \\n        return NULL;  \\n    Node *root = arr[i];   \\n    if(root->seats<*k) \\n        return NULL;\\n    \\n    if(root && root->seats >= *k) { \\n        int group = *k; \\n        Node *first_occ = NULL; \\n        search_row(root, &group, &first_occ);  \\n        int *ret = malloc(sizeof(int) * 2); \\n        ret[0] = i; \\n        ret[1] = (first_occ->range)[0];\\n        return ret;\\n    } \\n    \\n    int *l = gather_aux(arr, 2*i+1, end,k);  \\n    int *r = gather_aux(arr, 2*i+2, end,k); \\n     \\n    if(l && r) \\n        return l[0] < r[0] ? l : r; \\n    return l ? l : r;\\n}\\n\\nint search_row(Node *root, int *group, Node **fo) { \\n    if(!root || !(root->seats) || (*group) <= 0) \\n        return 0; \\n    else if(!(root->left) && !(root->right)) { \\n        (*group)--; \\n        if(*fo == NULL) \\n            *fo = root; \\n        root->seats = 0;\\n        return 1;\\n    } \\n    else {  \\n        int l = search_row(root->left, group, fo); \\n        int r = search_row(root->right, group, fo); \\n         \\n        root->seats -= l + r;\\n\\n        return l + r;\\n    }\\n}\\n\\nvoid create_row(Node *root, int start, int end) { \\n    if(root == NULL || start >= end) \\n        return;  \\n    \\n    int split = (start+end)/2;\\n    root->left = create_node(start,split); \\n    root->right = create_node(split+1,end);  \\n    \\n    create_row(root->left,start,split); \\n    create_row(root->right,split+1,end); \\n\\n    return;\\n}\\n\\nNode *create_node(int start, int end) { \\n    Node *node = malloc(sizeof(Node)); \\n    node->seats = (end-start)+1; \\n    (node->range)[0] = start; \\n    (node->range)[1] = end;  \\n    node->left = NULL; \\n    node->right = NULL;\\n    return node;\\n}\\n\\n/**\\n * Your BookMyShow struct will be instantiated and called as such:\\n * BookMyShow* obj = bookMyShowCreate(n, m);\\n * int* param_1 = bookMyShowGather(obj, k, maxRow, retSize);\\n \\n * bool param_2 = bookMyShowScatter(obj, k, maxRow);\\n \\n * bookMyShowFree(obj);\\n*/",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\n\\ntypedef struct node { \\n    int max;  \\n    long long sum;\\n    int range[2]; \\n    struct node *left; \\n    struct node *right;\\n} Node;   \\n\\n\\ntypedef struct { \\n    Node *root;\\n} BookMyShow; \\n\\nint p; /*num of rows*/ \\nlong long q; /*num of seats*/\\n \\n\\nvoid build(Node *root, int start, int end); \\nint *max_query(Node *root, int k, int maxRow); \\nint max_update(Node *root, int k, int row); \\nvoid sum_aux(Node *root, int k, int maxRow); \\nlong long sum_query(Node *root, int maxRow);\\nNode *create_node(int start, int end); \\n\\n\\nBookMyShow* bookMyShowCreate(int n, int m) {  \\n    int i;\\n    if(n<0 || m<0) \\n        return NULL; \\n    p = n; \\n    q = m;\\n    BookMyShow *stadium = malloc(sizeof(BookMyShow)); \\n    stadium->root = create_node(0,p); \\n    build(stadium->root,0,p);\\n    \\n    return stadium;\\n}\\n\\nint* bookMyShowGather(BookMyShow* obj, int k, int maxRow, int* retSize) { \\n    if(obj == NULL) \\n        return NULL; \\n    Node *root = obj->root; \\n    if(root->max < k) \\n        return NULL;  \\n    printf(\"%d \\\\n\",root->max);\\n    printf(\"%d \\\\n\", root->sum);\\n    int *res = max_query(root, k, maxRow); \\n    if(res){ \\n        *retSize = 2; \\n        max_update(root,k, res[0]);\\n    } \\n    else \\n        *retSize = 0; \\n    return res;\\n}\\n\\nbool bookMyShowScatter(BookMyShow* obj, int k, int maxRow) { \\n    if(!obj) \\n        return false; \\n    Node *root = obj->root; \\n    if(root->sum < k) \\n        return false; \\n    \\n    long long res = sum_query(root,maxRow); \\n    bool ret = res >=k;\\n    if(ret)  \\n        sum_aux(root, k, maxRow) ; \\n    \\n    return ret;\\n}\\n\\nvoid bookMyShowFree(BookMyShow* obj) {\\n    \\n}  \\n\\nint *max_query(Node *root, int k, int maxRow) {  \\n    if(!root || root->max < k || (root->range)[0] > maxRow) \\n        return NULL; \\n    else if(!root->left && !root->right) { \\n        int *result = malloc(sizeof(int)*2); \\n        (result)[0] = (root->range)[0]; \\n        (result)[1] = (q - root->max);  \\n        return result; \\n    } \\n    \\n    int *l = max_query(root->left, k, maxRow); \\n    if(l) \\n        return l;\\n    else \\n        return max_query(root->right, k, maxRow); \\n}  \\n\\nint max_update(Node *root, int k, int row) { /*try to recombine later*/\\n    if(!root) \\n        return 0;  \\n    if((root->range)[0] > row || (root->range)[1] < row) \\n        return root->max; \\n    \\n    if(!root->left && !root->right) { \\n        root->max -= k; \\n        root->sum -= k; \\n        return root->max;\\n    } \\n    \\n    int l = max_update(root->left, k, row); \\n    int r = max_update(root->right, k, row); \\n    \\n    root->sum -= k; \\n    root->max = l > r ? l : r;  \\n    \\n    return root->max;\\n} \\n\\nvoid sum_aux(Node *root, int k, int maxRow) { \\n    if(!root) \\n        return ; \\n    if((root->range)[0] > maxRow) \\n        return;  \\n    \\n    if(!root->left && !root->right) {\\n        root->max -= k; \\n        root->sum -= k; \\n        return ;\\n    }  \\n    \\n    root->sum -= k;\\n    if((root->right && (root->right->range)[0] > maxRow) ||  \\n           (root->left && root->left->sum >= k) ) \\n        { \\n            sum_aux(root->left, k, maxRow);\\n        } \\n    else { \\n        k -= root->left->sum; \\n        sum_aux(root->left, root->left->sum, maxRow); \\n        sum_aux(root->right, k, maxRow);\\n    }  \\n    \\n    root->max = root->left->max > root->right->max ?  \\n        root->left->max :  \\n        root->right->max; \\n    return;\\n} \\n\\nlong long sum_query(Node *root, int maxRow) { \\n    if((root->range)[0] > maxRow) \\n        return 0;  \\n    if((root->range)[1] <= maxRow) \\n        return root->sum;  \\n    return sum_query(root->left, maxRow) + sum_query(root->right, maxRow);\\n}\\n\\nvoid build(Node *root, int start, int end) { \\n    if(root == NULL || start >= end) \\n        return;  \\n    \\n    int split = (start+end)/2;\\n    root->left = create_node(start,split); \\n    root->right = create_node(split+1,end);  \\n    \\n    build(root->left,start,split); \\n    build(root->right,split+1,end); \\n\\n    return;\\n}\\n\\nNode *create_node(int start, int end) { \\n    Node *node = malloc(sizeof(Node));  \\n    node->max = q;\\n    node->sum = start == end ? q : q*((end-start)+1); \\n    (node->range)[0] = start; \\n    (node->range)[1] = end;  \\n    node->left = NULL; \\n    node->right = NULL;\\n    return node;\\n}\\n\\n/**\\n * Your BookMyShow struct will be instantiated and called as such:\\n * BookMyShow* obj = bookMyShowCreate(n, m);\\n * int* param_1 = bookMyShowGather(obj, k, maxRow, retSize);\\n \\n * bool param_2 = bookMyShowScatter(obj, k, maxRow);\\n \\n * bookMyShowFree(obj);\\n*/ \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3574808,
                "title": "555-ms",
                "content": "```c++\\nclass BookMyShow {\\n\\n    int n, m, tz, *t;\\n    uint64_t *b;\\n\\n    int get_r(int k) {\\n        int i = 1;\\n        if (t[i] < k) return n;\\n        while ((i *= 2) < tz * 2)\\n            if (t[i] < k) i++;\\n        return i / 2 - tz;\\n    }\\n    \\n    void update(const int _i, const int d) {\\n        int i = _i + tz;\\n        t[i] -= d;\\n        while ((i /= 2) > 0)\\n            t[i] = max(t[i * 2], t[i * 2 + 1]);\\n        b[i = _i] -= d;\\n        while ((i |= i + 1) < n)\\n            b[i] -= d;\\n    }\\n\\n    uint64_t pref_sum(int i) {\\n        uint64_t r = b[i];\\n        while ((i &= i + 1) > 0)\\n            r += b[--i];\\n        return r;\\n    }\\n\\npublic:\\n\\n    BookMyShow(int _n, int _m) {\\n        uint64_t s = 0;\\n        n = _n, m = _m, tz = 1;\\n        while (tz < n) tz <<= 1;\\n        t = new int[tz * 2], b = new uint64_t[n];\\n        for (int i = 0; i < n; i++)\\n            b[i] = s += t[i + tz] = m;\\n        memset(t + tz + n, 0, 4 * (tz - n));\\n        for (int i = tz - 1; i >= 1; --i)\\n            t[i] = max(t[i * 2], t[i * 2 + 1]);\\n        for (int i, j = n - 1; j >= 0; --j)\\n            b[j] -= (i = j & (j + 1)) > 0 ? b[i - 1] : 0;\\n    }\\n\\n    ~BookMyShow() { delete[] t; delete[] b; }\\n\\n    vector<int> gather(int k, int mr) {\\n        int r = get_r(k), c;\\n        if (r > mr) return {};\\n        c = m - t[r + tz];\\n        update(r, k);\\n        return {r, c};\\n    }\\n    \\n    bool scatter(int k, int mr) {\\n        if (pref_sum(mr) < k) return false;\\n        int i = get_r(1), x, d;\\n        while (k > 0) {\\n            if ((x = t[i + tz]) > 0) {\\n                k -= d = min(x, k);\\n                update(i, d);\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```c++\\nclass BookMyShow {\\n\\n    int n, m, tz, *t;\\n    uint64_t *b;\\n\\n    int get_r(int k) {\\n        int i = 1;\\n        if (t[i] < k) return n;\\n        while ((i *= 2) < tz * 2)\\n            if (t[i] < k) i++;\\n        return i / 2 - tz;\\n    }\\n    \\n    void update(const int _i, const int d) {\\n        int i = _i + tz;\\n        t[i] -= d;\\n        while ((i /= 2) > 0)\\n            t[i] = max(t[i * 2], t[i * 2 + 1]);\\n        b[i = _i] -= d;\\n        while ((i |= i + 1) < n)\\n            b[i] -= d;\\n    }\\n\\n    uint64_t pref_sum(int i) {\\n        uint64_t r = b[i];\\n        while ((i &= i + 1) > 0)\\n            r += b[--i];\\n        return r;\\n    }\\n\\npublic:\\n\\n    BookMyShow(int _n, int _m) {\\n        uint64_t s = 0;\\n        n = _n, m = _m, tz = 1;\\n        while (tz < n) tz <<= 1;\\n        t = new int[tz * 2], b = new uint64_t[n];\\n        for (int i = 0; i < n; i++)\\n            b[i] = s += t[i + tz] = m;\\n        memset(t + tz + n, 0, 4 * (tz - n));\\n        for (int i = tz - 1; i >= 1; --i)\\n            t[i] = max(t[i * 2], t[i * 2 + 1]);\\n        for (int i, j = n - 1; j >= 0; --j)\\n            b[j] -= (i = j & (j + 1)) > 0 ? b[i - 1] : 0;\\n    }\\n\\n    ~BookMyShow() { delete[] t; delete[] b; }\\n\\n    vector<int> gather(int k, int mr) {\\n        int r = get_r(k), c;\\n        if (r > mr) return {};\\n        c = m - t[r + tz];\\n        update(r, k);\\n        return {r, c};\\n    }\\n    \\n    bool scatter(int k, int mr) {\\n        if (pref_sum(mr) < k) return false;\\n        int i = get_r(1), x, d;\\n        while (k > 0) {\\n            if ((x = t[i + tz]) > 0) {\\n                k -= d = min(x, k);\\n                update(i, d);\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574227,
                "title": "simple-c-solution-using-hashing-not-with-segtree",
                "content": "**Can anyone explain is this test case is valid because my code is failing for this test case? I read the description 4-5 times but didn\\'t get how this test case works.**\\n\\n```\\nclass BookMyShow {\\npublic:\\n    vector<int> f;\\n    int m;\\n    int n;   \\n    BookMyShow(int n, int m) {\\n        f.resize(n,0);\\n        this->m=m;\\n        this->n=n;\\n    }\\n    \\n    vector<int> gather(int k, int mr) {\\n            for(int i=0;i<min(n,mr+1);i++){\\n                    if(f[i]+k-1<m) {\\n                            int j=f[i];\\n                            f[i]=f[i]+k;\\n                          \\n                            return {i,j};\\n                    }\\n                            \\n            }\\n            return {};\\n        \\n    }\\n    \\n    bool scatter(int k, int mr) {\\n            \\n            for(int i=0;i<min(n,mr+1);i++){\\n                    if(f[i]+k-1<m) {\\n                            int j=f[i];\\n                            f[i]=f[i]+k;\\n                            return true;\\n                    }\\n            }\\n            return false;\\n        \\n    }\\n};\\n\\n```\\n\\n\\n* ***Input:*** [\"BookMyShow\",\"scatter\",\"gather\",\"scatter\"]  [[4,5],[6,2],[6,3],[9,1]]\\n* ***Output:*** [null,false,[],false]\\n* ***Expected:*** [null,true,[],false]\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    vector<int> f;\\n    int m;\\n    int n;   \\n    BookMyShow(int n, int m) {\\n        f.resize(n,0);\\n        this->m=m;\\n        this->n=n;\\n    }\\n    \\n    vector<int> gather(int k, int mr) {\\n            for(int i=0;i<min(n,mr+1);i++){\\n                    if(f[i]+k-1<m) {\\n                            int j=f[i];\\n                            f[i]=f[i]+k;\\n                          \\n                            return {i,j};\\n                    }\\n                            \\n            }\\n            return {};\\n        \\n    }\\n    \\n    bool scatter(int k, int mr) {\\n            \\n            for(int i=0;i<min(n,mr+1);i++){\\n                    if(f[i]+k-1<m) {\\n                            int j=f[i];\\n                            f[i]=f[i]+k;\\n                            return true;\\n                    }\\n            }\\n            return false;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573149,
                "title": "969-ms",
                "content": "```ruby\\nclass BookMyShow\\n\\n    def initialize n, m\\n        @m, s, tz = m, 0, 1\\n        tz <<= 1 while tz < n\\n        @t = t = Array.new(tz * 2, 0)\\n        t[tz, n] = [m] * n\\n        (1...tz).reverse_each do\\n            t[_1] = t[_1 << 1, 2].max\\n        end\\n        @b = b = n.times.map { s += m }\\n        n.times.reverse_each do\\n            b[_1] -= (i = _1 &_1.succ) > 0 ? b[i.pred] : 0\\n        end\\n        @tz = tz\\n    end\\n\\n    def get_r k\\n        return @t.size if @t[i = 1] < k\\n        while (i <<= 1) < @t.size\\n            i += 1 if @t[i] < k\\n        end\\n        (i >> 1) - @tz\\n    end\\n\\n    def update _i, d\\n        @t[i = _i + @tz] -= d\\n        while (i >>= 1) > 0\\n            @t[i] = @t[i << 1, 2].max\\n        end\\n        @b[i = _i] -= d\\n        @b[i] -= d while (i |= i.succ) < @b.size\\n    end\\n\\n    def pref_sum i\\n        r = @b[i]\\n        while (i &= i.succ) > 0\\n            r += @b[i -= 1]\\n        end\\n        r\\n    end\\n\\n    private :get_r, :update, :pref_sum\\n\\n    def gather k, mr\\n        return [] if (r = get_r k) > mr\\n        c = @m - @t[r + @tz]\\n        update r, k\\n        [r, c]\\n    end\\n\\n    def scatter k, mr\\n        return false if pref_sum(mr) < k\\n        i = get_r 1\\n        while k > 0\\n            next i += 1 if (x = @t[i + @tz]) == 0\\n            k -= d = [x, k].min\\n            update i, d\\n            i += 1\\n        end\\n        true\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```ruby\\nclass BookMyShow\\n\\n    def initialize n, m\\n        @m, s, tz = m, 0, 1\\n        tz <<= 1 while tz < n\\n        @t = t = Array.new(tz * 2, 0)\\n        t[tz, n] = [m] * n\\n        (1...tz).reverse_each do\\n            t[_1] = t[_1 << 1, 2].max\\n        end\\n        @b = b = n.times.map { s += m }\\n        n.times.reverse_each do\\n            b[_1] -= (i = _1 &_1.succ) > 0 ? b[i.pred] : 0\\n        end\\n        @tz = tz\\n    end\\n\\n    def get_r k\\n        return @t.size if @t[i = 1] < k\\n        while (i <<= 1) < @t.size\\n            i += 1 if @t[i] < k\\n        end\\n        (i >> 1) - @tz\\n    end\\n\\n    def update _i, d\\n        @t[i = _i + @tz] -= d\\n        while (i >>= 1) > 0\\n            @t[i] = @t[i << 1, 2].max\\n        end\\n        @b[i = _i] -= d\\n        @b[i] -= d while (i |= i.succ) < @b.size\\n    end\\n\\n    def pref_sum i\\n        r = @b[i]\\n        while (i &= i.succ) > 0\\n            r += @b[i -= 1]\\n        end\\n        r\\n    end\\n\\n    private :get_r, :update, :pref_sum\\n\\n    def gather k, mr\\n        return [] if (r = get_r k) > mr\\n        c = @m - @t[r + @tz]\\n        update r, k\\n        [r, c]\\n    end\\n\\n    def scatter k, mr\\n        return false if pref_sum(mr) < k\\n        i = get_r 1\\n        while k > 0\\n            next i += 1 if (x = @t[i + @tz]) == 0\\n            k -= d = [x, k].min\\n            update i, d\\n            i += 1\\n        end\\n        true\\n    end\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548297,
                "title": "square-root-decomposition-in-python-simpler-to-implement-and-faster-than-88",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSegment tree is perhaps the standard solution to this problem. However, this problem can also be solved in an alternative approach due to the relatively smaller value of `n`, which is bounded by $$5\\\\times 10^4$$.\\nIn my approach, the rows are grouped into $$\\\\sqrt{n}$$ blocks. Each block records the maximum number of available seats in a row belonging to the block. By using the blocks, the two operations can be made by brute force scanning. Each operation costs $$O(\\\\sqrt{n})$$ of time. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ for initialization, and $$O(\\\\sqrt{n})$$ for `gather()` and `scatter()`. As $$n \\\\le 5 \\\\times 10^4$$ and the total number of calls is also up to $$5 \\\\times 10^4$$, this solution performs well thanks to its lighter overhead. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BookMyShow:\\n    def __init__(self, n: int, m: int):\\n        self.n, self.m = n, m\\n        self.width = int(n ** 0.5)\\n        self.blocks = [m] * ((n+self.width-1) // self.width)\\n        self.rows = [m] * n\\n        self.total = n * m \\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if self.total < k or self.m * (maxRow + 1) < k:\\n            return []\\n        for i in range(len(self.blocks)):\\n            if self.blocks[i] >= k:\\n                for j in range(i*self.width, (i+1)*self.width):\\n                    if j > maxRow:\\n                        return []\\n                    if self.rows[j] >= k:\\n                        ans = [j, self.m-self.rows[j]]\\n                        self.rows[j] -= k\\n                        self.blocks[i] = max(self.rows[i*self.width:(i+1)*self.width])\\n                        self.total -= k\\n                        return ans\\n        return []\\n        \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.total < k or self.m * (maxRow + 1) < k:\\n            return False\\n        remaining = k\\n        for i in range(len(self.blocks)):\\n            if self.blocks[i] > 0:\\n                for j in range(i*self.width, (i+1)*self.width):\\n                    if j > maxRow:\\n                        return False\\n                    remaining -= self.rows[j]\\n                    if remaining <= 0:\\n                        break\\n                if remaining <= 0:\\n                    break\\n        if remaining > 0:\\n            return False\\n        self.total -= k\\n        remaining = k\\n        for i in range(len(self.blocks)):\\n            if self.blocks[i] > 0:\\n                for j in range(i*self.width, (i+1)*self.width):\\n                    d = min(remaining, self.rows[j])\\n                    remaining -= d\\n                    self.rows[j] -= d\\n                    if remaining <= 0:\\n                        break\\n                self.blocks[i] = max(self.rows[i*self.width:(i+1)*self.width])\\n                if remaining <= 0:\\n                    break\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BookMyShow:\\n    def __init__(self, n: int, m: int):\\n        self.n, self.m = n, m\\n        self.width = int(n ** 0.5)\\n        self.blocks = [m] * ((n+self.width-1) // self.width)\\n        self.rows = [m] * n\\n        self.total = n * m \\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if self.total < k or self.m * (maxRow + 1) < k:\\n            return []\\n        for i in range(len(self.blocks)):\\n            if self.blocks[i] >= k:\\n                for j in range(i*self.width, (i+1)*self.width):\\n                    if j > maxRow:\\n                        return []\\n                    if self.rows[j] >= k:\\n                        ans = [j, self.m-self.rows[j]]\\n                        self.rows[j] -= k\\n                        self.blocks[i] = max(self.rows[i*self.width:(i+1)*self.width])\\n                        self.total -= k\\n                        return ans\\n        return []\\n        \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.total < k or self.m * (maxRow + 1) < k:\\n            return False\\n        remaining = k\\n        for i in range(len(self.blocks)):\\n            if self.blocks[i] > 0:\\n                for j in range(i*self.width, (i+1)*self.width):\\n                    if j > maxRow:\\n                        return False\\n                    remaining -= self.rows[j]\\n                    if remaining <= 0:\\n                        break\\n                if remaining <= 0:\\n                    break\\n        if remaining > 0:\\n            return False\\n        self.total -= k\\n        remaining = k\\n        for i in range(len(self.blocks)):\\n            if self.blocks[i] > 0:\\n                for j in range(i*self.width, (i+1)*self.width):\\n                    d = min(remaining, self.rows[j])\\n                    remaining -= d\\n                    self.rows[j] -= d\\n                    if remaining <= 0:\\n                        break\\n                self.blocks[i] = max(self.rows[i*self.width:(i+1)*self.width])\\n                if remaining <= 0:\\n                    break\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536127,
                "title": "save-occupied-by-rows",
                "content": "# Code\\n```\\nclass BookMyShow {\\n  rowsOccupiedCount: number[]=[];\\n  maxOccupied: number;\\n  constructor(n: number, m: number) {\\n      this.fillFullRows(n, m);\\n      this.maxOccupied = m;\\n  }\\n\\n  fillFullRows(n: number, m: number) {\\n    this.rowsOccupiedCount = [];\\n    for (let i = 0; i < n; i++) {\\n        this.rowsOccupiedCount.push(0);\\n    }\\n  }\\n\\n  gather(k: number, maxRow: number): number[] {\\n    if (k > this.maxOccupied) {\\n        return [];\\n    }\\n    for (let i = 0; i < this.rowsOccupiedCount.length; i++) {\\n        const occupied = this.rowsOccupiedCount[i];\\n        if (i > maxRow) {\\n            break;\\n        }\\n        if (occupied + k > this.maxOccupied) {\\n            continue;\\n        }\\n\\n        this.rowsOccupiedCount[i] += k;\\n\\n        return [i, occupied];\\n    }\\n    return [];\\n  }\\n\\n  scatter(k: number, maxRow: number): boolean {\\n    const occupiedSum = this.rowsOccupiedCount.reduce((acc, row, i) => {\\n        if (i <= maxRow) {\\n            return acc + row;\\n        }\\n        return acc;\\n    }, 0);\\n    const allFree = this.maxOccupied * (maxRow + 1) - occupiedSum;\\n    \\n    if (allFree < k) {\\n        return false;\\n    }\\n\\n    for (let i = 0; i < this.rowsOccupiedCount.length; i++) {\\n        const free = this.maxOccupied - this.rowsOccupiedCount[i]; \\n        if (k > free) {\\n            k -= this.maxOccupied - this.rowsOccupiedCount[i];\\n            this.rowsOccupiedCount[i] = this.maxOccupied;\\n            continue;\\n        }\\n\\n        this.rowsOccupiedCount[i] += k;\\n        return true;        \\n    }\\n    return true;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass BookMyShow {\\n  rowsOccupiedCount: number[]=[];\\n  maxOccupied: number;\\n  constructor(n: number, m: number) {\\n      this.fillFullRows(n, m);\\n      this.maxOccupied = m;\\n  }\\n\\n  fillFullRows(n: number, m: number) {\\n    this.rowsOccupiedCount = [];\\n    for (let i = 0; i < n; i++) {\\n        this.rowsOccupiedCount.push(0);\\n    }\\n  }\\n\\n  gather(k: number, maxRow: number): number[] {\\n    if (k > this.maxOccupied) {\\n        return [];\\n    }\\n    for (let i = 0; i < this.rowsOccupiedCount.length; i++) {\\n        const occupied = this.rowsOccupiedCount[i];\\n        if (i > maxRow) {\\n            break;\\n        }\\n        if (occupied + k > this.maxOccupied) {\\n            continue;\\n        }\\n\\n        this.rowsOccupiedCount[i] += k;\\n\\n        return [i, occupied];\\n    }\\n    return [];\\n  }\\n\\n  scatter(k: number, maxRow: number): boolean {\\n    const occupiedSum = this.rowsOccupiedCount.reduce((acc, row, i) => {\\n        if (i <= maxRow) {\\n            return acc + row;\\n        }\\n        return acc;\\n    }, 0);\\n    const allFree = this.maxOccupied * (maxRow + 1) - occupiedSum;\\n    \\n    if (allFree < k) {\\n        return false;\\n    }\\n\\n    for (let i = 0; i < this.rowsOccupiedCount.length; i++) {\\n        const free = this.maxOccupied - this.rowsOccupiedCount[i]; \\n        if (k > free) {\\n            k -= this.maxOccupied - this.rowsOccupiedCount[i];\\n            this.rowsOccupiedCount[i] = this.maxOccupied;\\n            continue;\\n        }\\n\\n        this.rowsOccupiedCount[i] += k;\\n        return true;        \\n    }\\n    return true;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436691,
                "title": "segment-tree-based-solution",
                "content": "# Intuition\\nThis code implements a class BookMyShow which simulates the booking process of a movie theater with n rows and m seats per row. The main idea is to keep track of the availability of seats and to be able to book them or check if a certain number of seats are available in a specific row.\\n\\n# Approach\\nThe class uses a segment tree to keep track of the availability of seats in each row. Each node of the tree represents a segment of the rows and stores two values: the maximum number of consecutive available seats and the total number of available seats in the segment.\\n\\nThe build() function initializes the tree by setting the values of the leaf nodes to (m, m), which means that all seats are available in those rows, and then recursively computing the values of the parent nodes based on the values of their children.\\n\\nThe query_max() function searches the tree for a segment with at least k consecutive available seats in a row up to the maxRow row. It returns the row number and the number of seats available in that row.\\n\\nThe update_max() function updates the tree after booking k consecutive seats in a row by subtracting k from the values of the corresponding nodes.\\n\\nThe query_sum() function computes the total number of available seats in the first maxRow rows of the theater.\\n\\nThe update_sum() function updates the tree after booking k seats in the first maxRow rows by subtracting k from the values of the corresponding nodes, starting from the top of the tree and recursively descending to the leaf nodes, booking as many consecutive seats as possible in each segment.\\n\\nThe gather() function combines the query_max() and update_max() functions to find and book k consecutive available seats in a row up to the maxRow row.\\n\\nThe scatter() function combines the query_sum() and update_sum() functions to check if k consecutive seats are available in the first maxRow rows of the theater and to book them if they are.\\n\\n# Complexity\\n- Time complexity:\\nThe build() function takes O(n log n) time because it performs a bottom-up traversal of the segment tree, visiting each node once.\\n\\nThe query_max() and query_sum() functions take O(log n) time because they perform a top-down traversal of the segment tree, visiting at most 2 log n nodes.\\n\\nThe update_max() and update_sum() functions take O(log n) time because they perform a bottom-up traversal of the segment tree, visiting at most 2 log n nodes.\\n\\nThe gather() and scatter() functions call query_max() or query_sum() and update_max() or update_sum() once each, so they take O(log n) time.\\n\\nTherefore, the overall time complexity of the class is O(n log n).\\n\\n- Space complexity:\\nThe segment tree requires O(n log n) space because it has 2n-1 nodes. The class also stores n and m, which require O(1) space. Therefore, the overall space complexity of the class is O(n log n).\\n\\nNote: This analysis assumes that the vector of arrays is implemented as a contiguous block of memory, which is usually the case in modern C++ implementations. If this is not the case, the space complexity could be higher due to fragmentation.\\n\\n# Code\\n```\\n\\nclass BookMyShow {\\n    int n;\\n    int m;\\n    vector<array<long long, 2>> stree; // segment tree that tracks (max, sum) of each segment\\npublic:\\n    void build(int i, int p, int q) {\\n        if (p == q) {\\n            stree[i] = {m, m};\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i] = {m, (long long)(q-p+1)*m};\\n        build(2*i+1, p, r);\\n        build(2*i+2, r+1, q);\\n    }\\n\\n    vector<int> query_max(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return {};\\n        if (stree[i][0] < k)\\n            return {};\\n        if (p == q)\\n            return {p, (int)(m - stree[i][0])};\\n        int r = (p + q) / 2;\\n        vector<int> ret = query_max(2*i+1, p, r, k, maxRow);\\n        if (ret.size())\\n            return ret;\\n        return query_max(2*i+2, r+1, q, k, maxRow);\\n    }\\n\\n    void update_max(int i, int p, int q, int row, int k) {\\n        if (p > row || q < row)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        update_max(2*i+1, p, r, row, k);\\n        update_max(2*i+2, r+1, q, row, k);\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n    long long query_sum(int i, int p, int q, int maxRow) {\\n        if (p > maxRow)\\n            return 0;\\n        if (q <= maxRow)\\n            return stree[i][1];\\n        int r = (p + q) / 2;\\n        return query_sum(2*i+1, p, r, maxRow) + query_sum(2*i+2, r+1, q, maxRow);\\n    }\\n\\n    void update_sum(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        if (r+1 > maxRow || stree[2*i+1][1] >= k) {\\n            update_sum(2*i+1, p, r, k, maxRow);\\n        } else {\\n            k -= stree[2*i+1][1];\\n            update_sum(2*i+1, p, r, stree[2*i+1][1], maxRow);\\n            // Be aware: stree[2*i+1][1] updates while updating the left tree\\n            update_sum(2*i+2, r+1, q, k, maxRow);\\n        }\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n\\n    BookMyShow(int n_in, int m_in) {\\n        n = n_in;\\n        m = m_in;\\n\\n        int sz = 1;\\n        while (sz < n*2)\\n            sz <<= 1;\\n        stree.resize(sz);\\n\\n        build(0, 0, n-1);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        // cout << \"gather \" << k << \" \" << maxRow << endl;\\n        vector<int> ret = query_max(0, 0, n-1, k, maxRow);\\n        if (ret.size())\\n            update_max(0, 0, n-1, ret[0], k);\\n        return ret;\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        // cout << \"scatter \" << k << \" \" << maxRow << endl;\\n        long long cnt = query_sum(0, 0, n-1, maxRow);\\n        bool ret = cnt >= k;\\n        if (ret)\\n            update_sum(0, 0, n-1, k, maxRow);\\n        return ret;\\n    }\\n};\\n\\n\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass BookMyShow {\\n    int n;\\n    int m;\\n    vector<array<long long, 2>> stree; // segment tree that tracks (max, sum) of each segment\\npublic:\\n    void build(int i, int p, int q) {\\n        if (p == q) {\\n            stree[i] = {m, m};\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i] = {m, (long long)(q-p+1)*m};\\n        build(2*i+1, p, r);\\n        build(2*i+2, r+1, q);\\n    }\\n\\n    vector<int> query_max(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return {};\\n        if (stree[i][0] < k)\\n            return {};\\n        if (p == q)\\n            return {p, (int)(m - stree[i][0])};\\n        int r = (p + q) / 2;\\n        vector<int> ret = query_max(2*i+1, p, r, k, maxRow);\\n        if (ret.size())\\n            return ret;\\n        return query_max(2*i+2, r+1, q, k, maxRow);\\n    }\\n\\n    void update_max(int i, int p, int q, int row, int k) {\\n        if (p > row || q < row)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        update_max(2*i+1, p, r, row, k);\\n        update_max(2*i+2, r+1, q, row, k);\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n    long long query_sum(int i, int p, int q, int maxRow) {\\n        if (p > maxRow)\\n            return 0;\\n        if (q <= maxRow)\\n            return stree[i][1];\\n        int r = (p + q) / 2;\\n        return query_sum(2*i+1, p, r, maxRow) + query_sum(2*i+2, r+1, q, maxRow);\\n    }\\n\\n    void update_sum(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        if (r+1 > maxRow || stree[2*i+1][1] >= k) {\\n            update_sum(2*i+1, p, r, k, maxRow);\\n        } else {\\n            k -= stree[2*i+1][1];\\n            update_sum(2*i+1, p, r, stree[2*i+1][1], maxRow);\\n            // Be aware: stree[2*i+1][1] updates while updating the left tree\\n            update_sum(2*i+2, r+1, q, k, maxRow);\\n        }\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n\\n    BookMyShow(int n_in, int m_in) {\\n        n = n_in;\\n        m = m_in;\\n\\n        int sz = 1;\\n        while (sz < n*2)\\n            sz <<= 1;\\n        stree.resize(sz);\\n\\n        build(0, 0, n-1);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        // cout << \"gather \" << k << \" \" << maxRow << endl;\\n        vector<int> ret = query_max(0, 0, n-1, k, maxRow);\\n        if (ret.size())\\n            update_max(0, 0, n-1, ret[0], k);\\n        return ret;\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        // cout << \"scatter \" << k << \" \" << maxRow << endl;\\n        long long cnt = query_sum(0, 0, n-1, maxRow);\\n        bool ret = cnt >= k;\\n        if (ret)\\n            update_sum(0, 0, n-1, k, maxRow);\\n        return ret;\\n    }\\n};\\n\\n\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3341419,
                "title": "java-segment-tree-beats-100",
                "content": "# Intuition\\nI had this on the contest and was disqualified for linear solution, though accepted. From dicussions I learnt segment tree exists. Now just carefully implemented it. I\\'m new to java, but it turned out to be beating 100% time solution\\n\\n# Approach\\nJust Segment Tree with two parameters in node:\\n- Max number of adjucent seats\\n- Total number of seats in the segment\\n\\nMay be one can implement Scatter() without two passes or with lazy initialization of left / right nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(log(N))\\n\\n- Space complexity:\\nO(log(N))\\n\\n# Code\\n```\\nclass BookMyShow {\\n    private IntervalTree tree;\\n\\n\\n    public BookMyShow(int n, int m) {\\n        tree = new IntervalTree(n - 1, m);\\n    }\\n\\n    public int[] gather(int k, int maxRow) {\\n        return tree.BookGather(k, maxRow);\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n       return tree.BookScatter(k, maxRow);\\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */\\n\\nclass IntervalTreeNode {\\n    private int start;\\n    private int end;\\n    private int mid;\\n    private int capacity;\\n    private int max;\\n    private long total;\\n    private IntervalTreeNode left;\\n    private IntervalTreeNode right;\\n\\n    public IntervalTreeNode(int start, int end, int capacity) {\\n        this.start = start;\\n        this.end = end;\\n        this.mid = (start + end) / 2;\\n        this.capacity = capacity;\\n        this.max = capacity;\\n        this.total = (end - start + 1) * (long)capacity;\\n\\n        if (start != end) {\\n            this.left = new IntervalTreeNode(start, mid, capacity);\\n            this.right = new IntervalTreeNode(mid + 1, end, capacity);\\n        }\\n    }\\n\\n    public int[] BookGather(int number, int maxRow) {\\n        if (start != end) {\\n            var res = new int[0];\\n\\n            if (this.left.max >= number) {\\n                res = this.left.BookGather(number, maxRow);\\n            } else if (maxRow >= mid + 1 && this.right.max >= number) {\\n                res = this.right.BookGather(number, maxRow);\\n            }\\n\\n            if (res.length > 0) {\\n                this.total = left.total + right.total;\\n                this.max = Math.max(this.left.max, this.right.max);\\n            }\\n\\n            return res;\\n        } else {\\n            if (this.total >= number) {\\n                final var booking = new int[] { start, capacity - max };\\n                this.max -= number;\\n                this.total -= number;\\n                return booking;\\n            } else {\\n                return new int[0];\\n            }\\n        }\\n    }\\n\\n    public long CheckScatter(int maxRow) {\\n        if (start == end || maxRow == end) {\\n            return total;\\n        } else {\\n            if (maxRow <= mid) {\\n                return left.CheckScatter(maxRow);\\n            }\\n\\n            return left.total + right.CheckScatter(maxRow);\\n        }\\n    }\\n\\n    public void BookScatter(long number) {\\n        if (start != end) {\\n            if (this.left.total < number) {\\n                this.right.BookScatter(number - this.left.total);\\n            }\\n\\n            this.left.BookScatter(this.left.total < number ? this.left.total : number);\\n\\n            this.max = Math.max(left.max, right.max);\\n            this.total = left.total + right.total;\\n        } else {\\n            this.total -= number;\\n            this.max -= number;\\n        }\\n    }\\n}\\n\\nclass IntervalTree {\\n    private IntervalTreeNode root;\\n\\n    public IntervalTree(int end, int capacity) {\\n        root = new IntervalTreeNode(0, end, capacity);\\n    }\\n\\n    public int[] BookGather(int number, int maxRow) {\\n        return root.BookGather(number, maxRow);\\n    }\\n\\n    public boolean BookScatter(int number, int maxRow) {\\n        if (root.CheckScatter(maxRow) >= number) {\\n            root.BookScatter(number);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree"
                ],
                "code": "```\\nclass BookMyShow {\\n    private IntervalTree tree;\\n\\n\\n    public BookMyShow(int n, int m) {\\n        tree = new IntervalTree(n - 1, m);\\n    }\\n\\n    public int[] gather(int k, int maxRow) {\\n        return tree.BookGather(k, maxRow);\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n       return tree.BookScatter(k, maxRow);\\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */\\n\\nclass IntervalTreeNode {\\n    private int start;\\n    private int end;\\n    private int mid;\\n    private int capacity;\\n    private int max;\\n    private long total;\\n    private IntervalTreeNode left;\\n    private IntervalTreeNode right;\\n\\n    public IntervalTreeNode(int start, int end, int capacity) {\\n        this.start = start;\\n        this.end = end;\\n        this.mid = (start + end) / 2;\\n        this.capacity = capacity;\\n        this.max = capacity;\\n        this.total = (end - start + 1) * (long)capacity;\\n\\n        if (start != end) {\\n            this.left = new IntervalTreeNode(start, mid, capacity);\\n            this.right = new IntervalTreeNode(mid + 1, end, capacity);\\n        }\\n    }\\n\\n    public int[] BookGather(int number, int maxRow) {\\n        if (start != end) {\\n            var res = new int[0];\\n\\n            if (this.left.max >= number) {\\n                res = this.left.BookGather(number, maxRow);\\n            } else if (maxRow >= mid + 1 && this.right.max >= number) {\\n                res = this.right.BookGather(number, maxRow);\\n            }\\n\\n            if (res.length > 0) {\\n                this.total = left.total + right.total;\\n                this.max = Math.max(this.left.max, this.right.max);\\n            }\\n\\n            return res;\\n        } else {\\n            if (this.total >= number) {\\n                final var booking = new int[] { start, capacity - max };\\n                this.max -= number;\\n                this.total -= number;\\n                return booking;\\n            } else {\\n                return new int[0];\\n            }\\n        }\\n    }\\n\\n    public long CheckScatter(int maxRow) {\\n        if (start == end || maxRow == end) {\\n            return total;\\n        } else {\\n            if (maxRow <= mid) {\\n                return left.CheckScatter(maxRow);\\n            }\\n\\n            return left.total + right.CheckScatter(maxRow);\\n        }\\n    }\\n\\n    public void BookScatter(long number) {\\n        if (start != end) {\\n            if (this.left.total < number) {\\n                this.right.BookScatter(number - this.left.total);\\n            }\\n\\n            this.left.BookScatter(this.left.total < number ? this.left.total : number);\\n\\n            this.max = Math.max(left.max, right.max);\\n            this.total = left.total + right.total;\\n        } else {\\n            this.total -= number;\\n            this.max -= number;\\n        }\\n    }\\n}\\n\\nclass IntervalTree {\\n    private IntervalTreeNode root;\\n\\n    public IntervalTree(int end, int capacity) {\\n        root = new IntervalTreeNode(0, end, capacity);\\n    }\\n\\n    public int[] BookGather(int number, int maxRow) {\\n        return root.BookGather(number, maxRow);\\n    }\\n\\n    public boolean BookScatter(int number, int maxRow) {\\n        if (root.CheckScatter(maxRow) >= number) {\\n            root.BookScatter(number);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332115,
                "title": "modelling-the-sequential-multi-row-gaps-between-filled-seats",
                "content": "# Intuition\\nBecause of the way the seats are populated, it makes sense to model this as a list of \"gaps\" in the seats, where each gap is a sequence of empty seats that span over an arbitrary number of rows. A gap could start on any seat within the starting row, but would always end on the last seat in the end row.\\n\\n# Approach\\nA class was implemented to represent a gap, with methods to fill the gap, and split into two where required.\\n\\nSince the collection of gaps is always accessed and modified sequentially, it made sense to use a LinkedList of gaps.\\n\\nThe scatter method then iterates over the collection of gaps and fills in from the bottom. This never requires splitting a gap into two.\\n\\nThe gather method iterates over the collection of gaps until it finds one that can accommodate the required number of seats. Depending on the current state of the gaps, this may require splitting a gap into two.\\n\\n# Complexity\\ng = number of gaps, where 1 <= g <= n\\n(where n is the number of rows)\\n- Time complexity: $$O(g)$$\\n\\n- Space complexity: $$O(g)$$\\n\\n# Code\\n```\\npublic class BookMyShow\\n    {\\n        /// <summary>\\n        /// A \"gap\" represents a sequence of empty seats over an arbitrary number of rows.\\n        /// A gap can start on any seat, but will always end on the final seat of a row.\\n        /// Where a gap is spread over multiple rows, all rows other than the starting row will be empty\\n        /// </summary>\\n        public class Gap\\n        {\\n            /// <summary>\\n            /// The number of empty seats in this gap\\n            /// </summary>\\n            public long GapSize { get; private set; }\\n\\n            /// <summary>\\n            /// The index of seat on which the gap starts.\\n            /// This will be equal to the row index * seatsPerRow + the seat number in that row\\n            /// </summary>\\n            public long StartingSeatNumber { get; private set; }\\n\\n            /// <summary>\\n            /// The index of the row that the StartingSeatNumber is situated on\\n            /// </summary>\\n            public int StartRowIndex { get; private set; }\\n\\n            /// <summary>\\n            /// The index of the last row in the gap\\n            /// </summary>\\n            public int EndRowIndex { get; private set; }\\n\\n            public Gap(long gapSize, long startingSeatNumber, int startRowIndex, int endRowIndex)\\n            {\\n                GapSize = gapSize;\\n                StartingSeatNumber = startingSeatNumber;\\n                StartRowIndex = startRowIndex;\\n                EndRowIndex = endRowIndex;\\n            }\\n\\n            /// <summary>\\n            /// Fills in seats in the gap starting from the StartingSeatNumber. This may fill more than one row\\n            /// </summary>\\n            /// <param name=\"spacesToFill\">The number of spaces to fill</param>\\n            /// <param name=\"seatsPerRow\">Number of seats per row</param>\\n            public void FillFromStart(long spacesToFill, int seatsPerRow)\\n            {\\n                GapSize -= spacesToFill;\\n                StartingSeatNumber += spacesToFill;\\n                StartRowIndex = GetRowIndexFromSeat(StartingSeatNumber, seatsPerRow);\\n            }\\n\\n            /// <summary>\\n            /// Completely fill in the last row in this gap\\n            /// </summary>\\n            /// <param name=\"seatsPerRow\">Number of seats per row</param>\\n            public void FillLastRow(int seatsPerRow)\\n            {\\n                GapSize -= seatsPerRow;\\n                EndRowIndex--;\\n            }\\n\\n            /// <summary>\\n            /// Split this gap into 2, where this gap will now terminate at the end of its current row, and the new gap will start on the next row, and go up to this gap\\'s former end row index\\n            /// </summary>\\n            /// <param name=\"seatsPerRow\">Number of seats per row</param>\\n            /// <param name=\"spacesToFill\">Number of spaces to fill in the new gap</param>\\n            /// <param name=\"newGap\">The new gap object</param>\\n            public void Split(int seatsPerRow, int spacesToFill, out Gap newGap)\\n            {\\n                long seatsLeftInStartRow = GetSeatsLeftInStartRow(seatsPerRow);\\n                long nextRowNumber = StartRowIndex + 1;\\n                long newGapSize = GapSize - seatsLeftInStartRow - spacesToFill;\\n                long newGapStartingSeatNumber = (long)nextRowNumber * seatsPerRow + spacesToFill;\\n                newGap = new Gap(newGapSize, newGapStartingSeatNumber, GetRowIndexFromSeat(newGapStartingSeatNumber, seatsPerRow), EndRowIndex);\\n                GapSize = seatsLeftInStartRow;\\n                EndRowIndex = GetRowIndexFromSeat(StartingSeatNumber + GapSize - 1, seatsPerRow);\\n            }\\n\\n            private long GetSeatsLeftInStartRow(int seatsPerRow)\\n            {\\n                return seatsPerRow - (StartingSeatNumber % seatsPerRow);\\n            }\\n\\n            /// <summary>\\n            /// Calculates whether there\\'s enough space in the starting row in this gap to fill the first row during a gather\\n            /// </summary>\\n            /// <param name=\"seatsPerRow\">Number of seats per row</param>\\n            /// <param name=\"peopleCount\">Number of spaces required</param>\\n            /// <returns>true if there is enough space</returns>\\n            public bool CanGatherInStartRow(int seatsPerRow, long peopleCount)\\n            {\\n                return GetSeatsLeftInStartRow(seatsPerRow) >= peopleCount;\\n            }\\n        }\\n\\n        private static readonly int[] invalidGatherResult = new int[0];\\n\\n        private readonly LinkedList<Gap> gaps;\\n        private readonly int rowCount;\\n        private readonly int seatsPerRow;\\n        private long totalSeatsAvailable;\\n        private (int, LinkedListNode<Gap>?) lastGatherResult;\\n\\n        public BookMyShow(int rowCount, int seatsPerRow)\\n        {\\n            this.rowCount = rowCount;\\n            this.seatsPerRow = seatsPerRow;\\n            totalSeatsAvailable = ((long)rowCount) * seatsPerRow;\\n            gaps = new LinkedList<Gap>();\\n            gaps.AddLast(new Gap(totalSeatsAvailable, 0, 0, rowCount - 1));\\n            lastGatherResult = (-1, default);\\n        }\\n\\n        public int[] Gather(int peopleCount, int maxRow)\\n        {\\n            if (peopleCount > seatsPerRow)\\n            {\\n                return invalidGatherResult;\\n            }\\n            if (!EnoughSeatsAvailable(peopleCount, maxRow))\\n            {\\n                return invalidGatherResult;\\n            }\\n            LinkedListNode<Gap>? currentGap = GetStartingGatherNode(peopleCount);\\n            while (currentGap != null)\\n            {\\n                Gap gap = currentGap.Value;\\n                if (gap.GapSize >= peopleCount)\\n                {\\n                    int startRowNumber = gap.StartRowIndex;\\n\\n                    if (startRowNumber > maxRow)\\n                    {\\n                        return invalidGatherResult;\\n                    }\\n                    if (gap.CanGatherInStartRow(seatsPerRow, peopleCount))\\n                    {\\n                        int[] result = new[] { startRowNumber, (int)(gap.StartingSeatNumber % seatsPerRow) };\\n                        gap.FillFromStart(peopleCount, seatsPerRow);\\n                        totalSeatsAvailable -= peopleCount;\\n                        lastGatherResult = (peopleCount, currentGap);\\n                        return result;\\n                    }\\n                    // if there\\'s a next row, it\\'s guaranteed to be empty\\n                    if (startRowNumber != gap.EndRowIndex)\\n                    {\\n                        int nextRowNumber = startRowNumber + 1;\\n                        if (nextRowNumber > maxRow)\\n                        {\\n                            return invalidGatherResult;\\n                        }\\n                        if (peopleCount == seatsPerRow\\n                            && nextRowNumber == gap.EndRowIndex)\\n                        {\\n                            gap.FillLastRow(seatsPerRow);\\n                        }\\n                        else\\n                        {\\n                            gap.Split(seatsPerRow, peopleCount, out Gap newGap);\\n                            currentGap = gaps.AddAfter(currentGap, newGap);\\n                        }\\n                        totalSeatsAvailable -= peopleCount;\\n                        lastGatherResult = (peopleCount, currentGap);\\n                        return new[] { nextRowNumber, 0 };\\n                    }\\n                }\\n                currentGap = currentGap.Next;\\n            }\\n            return invalidGatherResult;\\n        }\\n\\n        public bool Scatter(int peopleCount, int maxRow)\\n        {\\n            if (!EnoughSeatsAvailable(peopleCount, maxRow))\\n            {\\n                return false;\\n            }\\n            long peopleCountL = peopleCount;\\n            lastGatherResult = (-1, default);\\n            LinkedListNode<Gap>? currentGap = gaps.First;\\n            while (currentGap != null\\n                && peopleCountL > 0)\\n            {\\n                Gap gap = currentGap.Value;\\n                long seatsInGapToRemove = Math.Min(peopleCountL, gap.GapSize);\\n                gap.FillFromStart(seatsInGapToRemove, seatsPerRow);\\n                peopleCountL -= seatsInGapToRemove;\\n                if (gap.GapSize == 0)\\n                {\\n                    // Due to the way the gaps are populated, if a gap has been filled it will always be the first gap\\n                    gaps.RemoveFirst();\\n                    currentGap = gaps.First;\\n                }\\n                else\\n                {\\n                    currentGap = currentGap.Next;\\n                }\\n            }\\n            totalSeatsAvailable -= peopleCount;\\n            return true;\\n        }\\n\\n        private bool EnoughSeatsAvailable(int requiredSeats, long maxRow)\\n        {\\n            if (totalSeatsAvailable < requiredSeats)\\n            {\\n                return false;\\n            }\\n            if (maxRow >= rowCount - 1)\\n            {\\n                return true;\\n            }\\n            if (gaps.Last.Value.StartRowIndex < maxRow)\\n            {\\n                long invalidSeats = (rowCount - maxRow - 1) * seatsPerRow;\\n                return totalSeatsAvailable - invalidSeats >= requiredSeats;\\n            }\\n            long availableSeats = 0;\\n            foreach (Gap gap in gaps)\\n            {\\n                if (gap.StartRowIndex > maxRow)\\n                {\\n                    // all subsequent gaps will be the same, so abort the loop\\n                    break;\\n                }\\n                availableSeats += seatsPerRow - (gap.StartingSeatNumber % seatsPerRow);\\n                availableSeats += seatsPerRow * (Math.Min(maxRow, gap.EndRowIndex) - (gap.StartRowIndex));\\n                if (availableSeats >= requiredSeats)\\n                {\\n                    return true;\\n                }\\n            }\\n            return availableSeats >= requiredSeats;\\n        }\\n\\n        private LinkedListNode<Gap>? GetStartingGatherNode(int peopleCount)\\n        {\\n            if (lastGatherResult.Item1 != -1\\n                && lastGatherResult.Item1 <= peopleCount)\\n            {\\n                return lastGatherResult.Item2;\\n            }\\n            return gaps.First;\\n        }\\n\\n        private static int GetRowIndexFromSeat(long seatNumber, long seatsPerRow)\\n        {\\n            return (int)(seatNumber / seatsPerRow);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class BookMyShow\\n    {\\n        /// <summary>\\n        /// A \"gap\" represents a sequence of empty seats over an arbitrary number of rows.\\n        /// A gap can start on any seat, but will always end on the final seat of a row.\\n        /// Where a gap is spread over multiple rows, all rows other than the starting row will be empty\\n        /// </summary>\\n        public class Gap\\n        {\\n            /// <summary>\\n            /// The number of empty seats in this gap\\n            /// </summary>\\n            public long GapSize { get; private set; }\\n\\n            /// <summary>\\n            /// The index of seat on which the gap starts.\\n            /// This will be equal to the row index * seatsPerRow + the seat number in that row\\n            /// </summary>\\n            public long StartingSeatNumber { get; private set; }\\n\\n            /// <summary>\\n            /// The index of the row that the StartingSeatNumber is situated on\\n            /// </summary>\\n            public int StartRowIndex { get; private set; }\\n\\n            /// <summary>\\n            /// The index of the last row in the gap\\n            /// </summary>\\n            public int EndRowIndex { get; private set; }\\n\\n            public Gap(long gapSize, long startingSeatNumber, int startRowIndex, int endRowIndex)\\n            {\\n                GapSize = gapSize;\\n                StartingSeatNumber = startingSeatNumber;\\n                StartRowIndex = startRowIndex;\\n                EndRowIndex = endRowIndex;\\n            }\\n\\n            /// <summary>\\n            /// Fills in seats in the gap starting from the StartingSeatNumber. This may fill more than one row\\n            /// </summary>\\n            /// <param name=\"spacesToFill\">The number of spaces to fill</param>\\n            /// <param name=\"seatsPerRow\">Number of seats per row</param>\\n            public void FillFromStart(long spacesToFill, int seatsPerRow)\\n            {\\n                GapSize -= spacesToFill;\\n                StartingSeatNumber += spacesToFill;\\n                StartRowIndex = GetRowIndexFromSeat(StartingSeatNumber, seatsPerRow);\\n            }\\n\\n            /// <summary>\\n            /// Completely fill in the last row in this gap\\n            /// </summary>\\n            /// <param name=\"seatsPerRow\">Number of seats per row</param>\\n            public void FillLastRow(int seatsPerRow)\\n            {\\n                GapSize -= seatsPerRow;\\n                EndRowIndex--;\\n            }\\n\\n            /// <summary>\\n            /// Split this gap into 2, where this gap will now terminate at the end of its current row, and the new gap will start on the next row, and go up to this gap\\'s former end row index\\n            /// </summary>\\n            /// <param name=\"seatsPerRow\">Number of seats per row</param>\\n            /// <param name=\"spacesToFill\">Number of spaces to fill in the new gap</param>\\n            /// <param name=\"newGap\">The new gap object</param>\\n            public void Split(int seatsPerRow, int spacesToFill, out Gap newGap)\\n            {\\n                long seatsLeftInStartRow = GetSeatsLeftInStartRow(seatsPerRow);\\n                long nextRowNumber = StartRowIndex + 1;\\n                long newGapSize = GapSize - seatsLeftInStartRow - spacesToFill;\\n                long newGapStartingSeatNumber = (long)nextRowNumber * seatsPerRow + spacesToFill;\\n                newGap = new Gap(newGapSize, newGapStartingSeatNumber, GetRowIndexFromSeat(newGapStartingSeatNumber, seatsPerRow), EndRowIndex);\\n                GapSize = seatsLeftInStartRow;\\n                EndRowIndex = GetRowIndexFromSeat(StartingSeatNumber + GapSize - 1, seatsPerRow);\\n            }\\n\\n            private long GetSeatsLeftInStartRow(int seatsPerRow)\\n            {\\n                return seatsPerRow - (StartingSeatNumber % seatsPerRow);\\n            }\\n\\n            /// <summary>\\n            /// Calculates whether there\\'s enough space in the starting row in this gap to fill the first row during a gather\\n            /// </summary>\\n            /// <param name=\"seatsPerRow\">Number of seats per row</param>\\n            /// <param name=\"peopleCount\">Number of spaces required</param>\\n            /// <returns>true if there is enough space</returns>\\n            public bool CanGatherInStartRow(int seatsPerRow, long peopleCount)\\n            {\\n                return GetSeatsLeftInStartRow(seatsPerRow) >= peopleCount;\\n            }\\n        }\\n\\n        private static readonly int[] invalidGatherResult = new int[0];\\n\\n        private readonly LinkedList<Gap> gaps;\\n        private readonly int rowCount;\\n        private readonly int seatsPerRow;\\n        private long totalSeatsAvailable;\\n        private (int, LinkedListNode<Gap>?) lastGatherResult;\\n\\n        public BookMyShow(int rowCount, int seatsPerRow)\\n        {\\n            this.rowCount = rowCount;\\n            this.seatsPerRow = seatsPerRow;\\n            totalSeatsAvailable = ((long)rowCount) * seatsPerRow;\\n            gaps = new LinkedList<Gap>();\\n            gaps.AddLast(new Gap(totalSeatsAvailable, 0, 0, rowCount - 1));\\n            lastGatherResult = (-1, default);\\n        }\\n\\n        public int[] Gather(int peopleCount, int maxRow)\\n        {\\n            if (peopleCount > seatsPerRow)\\n            {\\n                return invalidGatherResult;\\n            }\\n            if (!EnoughSeatsAvailable(peopleCount, maxRow))\\n            {\\n                return invalidGatherResult;\\n            }\\n            LinkedListNode<Gap>? currentGap = GetStartingGatherNode(peopleCount);\\n            while (currentGap != null)\\n            {\\n                Gap gap = currentGap.Value;\\n                if (gap.GapSize >= peopleCount)\\n                {\\n                    int startRowNumber = gap.StartRowIndex;\\n\\n                    if (startRowNumber > maxRow)\\n                    {\\n                        return invalidGatherResult;\\n                    }\\n                    if (gap.CanGatherInStartRow(seatsPerRow, peopleCount))\\n                    {\\n                        int[] result = new[] { startRowNumber, (int)(gap.StartingSeatNumber % seatsPerRow) };\\n                        gap.FillFromStart(peopleCount, seatsPerRow);\\n                        totalSeatsAvailable -= peopleCount;\\n                        lastGatherResult = (peopleCount, currentGap);\\n                        return result;\\n                    }\\n                    // if there\\'s a next row, it\\'s guaranteed to be empty\\n                    if (startRowNumber != gap.EndRowIndex)\\n                    {\\n                        int nextRowNumber = startRowNumber + 1;\\n                        if (nextRowNumber > maxRow)\\n                        {\\n                            return invalidGatherResult;\\n                        }\\n                        if (peopleCount == seatsPerRow\\n                            && nextRowNumber == gap.EndRowIndex)\\n                        {\\n                            gap.FillLastRow(seatsPerRow);\\n                        }\\n                        else\\n                        {\\n                            gap.Split(seatsPerRow, peopleCount, out Gap newGap);\\n                            currentGap = gaps.AddAfter(currentGap, newGap);\\n                        }\\n                        totalSeatsAvailable -= peopleCount;\\n                        lastGatherResult = (peopleCount, currentGap);\\n                        return new[] { nextRowNumber, 0 };\\n                    }\\n                }\\n                currentGap = currentGap.Next;\\n            }\\n            return invalidGatherResult;\\n        }\\n\\n        public bool Scatter(int peopleCount, int maxRow)\\n        {\\n            if (!EnoughSeatsAvailable(peopleCount, maxRow))\\n            {\\n                return false;\\n            }\\n            long peopleCountL = peopleCount;\\n            lastGatherResult = (-1, default);\\n            LinkedListNode<Gap>? currentGap = gaps.First;\\n            while (currentGap != null\\n                && peopleCountL > 0)\\n            {\\n                Gap gap = currentGap.Value;\\n                long seatsInGapToRemove = Math.Min(peopleCountL, gap.GapSize);\\n                gap.FillFromStart(seatsInGapToRemove, seatsPerRow);\\n                peopleCountL -= seatsInGapToRemove;\\n                if (gap.GapSize == 0)\\n                {\\n                    // Due to the way the gaps are populated, if a gap has been filled it will always be the first gap\\n                    gaps.RemoveFirst();\\n                    currentGap = gaps.First;\\n                }\\n                else\\n                {\\n                    currentGap = currentGap.Next;\\n                }\\n            }\\n            totalSeatsAvailable -= peopleCount;\\n            return true;\\n        }\\n\\n        private bool EnoughSeatsAvailable(int requiredSeats, long maxRow)\\n        {\\n            if (totalSeatsAvailable < requiredSeats)\\n            {\\n                return false;\\n            }\\n            if (maxRow >= rowCount - 1)\\n            {\\n                return true;\\n            }\\n            if (gaps.Last.Value.StartRowIndex < maxRow)\\n            {\\n                long invalidSeats = (rowCount - maxRow - 1) * seatsPerRow;\\n                return totalSeatsAvailable - invalidSeats >= requiredSeats;\\n            }\\n            long availableSeats = 0;\\n            foreach (Gap gap in gaps)\\n            {\\n                if (gap.StartRowIndex > maxRow)\\n                {\\n                    // all subsequent gaps will be the same, so abort the loop\\n                    break;\\n                }\\n                availableSeats += seatsPerRow - (gap.StartingSeatNumber % seatsPerRow);\\n                availableSeats += seatsPerRow * (Math.Min(maxRow, gap.EndRowIndex) - (gap.StartRowIndex));\\n                if (availableSeats >= requiredSeats)\\n                {\\n                    return true;\\n                }\\n            }\\n            return availableSeats >= requiredSeats;\\n        }\\n\\n        private LinkedListNode<Gap>? GetStartingGatherNode(int peopleCount)\\n        {\\n            if (lastGatherResult.Item1 != -1\\n                && lastGatherResult.Item1 <= peopleCount)\\n            {\\n                return lastGatherResult.Item2;\\n            }\\n            return gaps.First;\\n        }\\n\\n        private static int GetRowIndexFromSeat(long seatNumber, long seatsPerRow)\\n        {\\n            return (int)(seatNumber / seatsPerRow);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289485,
                "title": "beats-90",
                "content": "Use a dictionary to keep track of no. of seats taken per row, and another for the minimum row to insert k people. Use memoization to save time when the same input and state of the concert hall reoccur. For \"scatter\", first try whether we have sufficient space. This is somewhat inefficient and the fact that we only need to answer \"True\" if the \"scatter\" is possible could be taken as a hint that a buffer for sequential \"scatters\" could be implemented, but I tried it, it was a hassle, and it was ultimately not needed here.\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.row_seats = defaultdict(lambda: 0)\\n        self.min_row = defaultdict(lambda: 0)\\n        self.m = m\\n        self.total_remaining = m * n\\n        self.seen = set()\\n\\n    def min_row_seats(self, k, maxRow): # minimum row with at least k seats\\n        mr = self.min_row[k]\\n        for i in range(mr, maxRow + 1):\\n            if self.row_seats[i] <= self.m - k:\\n                self.min_row[k] = i\\n                return i\\n        return -1\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if (k, self.total_remaining, \"g\") in self.seen or self.total_remaining < k:\\n            return []\\n        row = self.min_row_seats(k, maxRow)\\n        if row == -1:\\n            self.seen.add((k, self.total_remaining, \"g\"))\\n            return []\\n        out = [row, self.row_seats[row]]\\n        self.row_seats[row] += k\\n        self.total_remaining -= k\\n        return out\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (k, self.total_remaining, \"s\") in self.seen or self.total_remaining < k:\\n            return False\\n        row = self.min_row_seats(1, maxRow)\\n        ko = k\\n        ro = row\\n        if row == -1:\\n            self.seen.add((k, self.total_remaining, \"s\"))\\n            return False\\n        while k:\\n            if row > maxRow:\\n                self.seen.add((ko, self.total_remaining, \"s\"))\\n                return False\\n            if self.row_seats[row] > self.m - k:\\n                k -= self.m - self.row_seats[row]\\n                row += 1\\n            else:\\n                break\\n                \\n        k = ko\\n        row = ro\\n        while k:\\n            if row > maxRow:\\n                return False\\n            if self.row_seats[row] > self.m - k:\\n                k -= self.m - self.row_seats[row]\\n                self.row_seats[row] = self.m\\n                row += 1\\n            else:\\n                self.row_seats[row] += k\\n                break\\n        self.total_remaining -= ko\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.row_seats = defaultdict(lambda: 0)\\n        self.min_row = defaultdict(lambda: 0)\\n        self.m = m\\n        self.total_remaining = m * n\\n        self.seen = set()\\n\\n    def min_row_seats(self, k, maxRow): # minimum row with at least k seats\\n        mr = self.min_row[k]\\n        for i in range(mr, maxRow + 1):\\n            if self.row_seats[i] <= self.m - k:\\n                self.min_row[k] = i\\n                return i\\n        return -1\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if (k, self.total_remaining, \"g\") in self.seen or self.total_remaining < k:\\n            return []\\n        row = self.min_row_seats(k, maxRow)\\n        if row == -1:\\n            self.seen.add((k, self.total_remaining, \"g\"))\\n            return []\\n        out = [row, self.row_seats[row]]\\n        self.row_seats[row] += k\\n        self.total_remaining -= k\\n        return out\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if (k, self.total_remaining, \"s\") in self.seen or self.total_remaining < k:\\n            return False\\n        row = self.min_row_seats(1, maxRow)\\n        ko = k\\n        ro = row\\n        if row == -1:\\n            self.seen.add((k, self.total_remaining, \"s\"))\\n            return False\\n        while k:\\n            if row > maxRow:\\n                self.seen.add((ko, self.total_remaining, \"s\"))\\n                return False\\n            if self.row_seats[row] > self.m - k:\\n                k -= self.m - self.row_seats[row]\\n                row += 1\\n            else:\\n                break\\n                \\n        k = ko\\n        row = ro\\n        while k:\\n            if row > maxRow:\\n                return False\\n            if self.row_seats[row] > self.m - k:\\n                k -= self.m - self.row_seats[row]\\n                self.row_seats[row] = self.m\\n                row += 1\\n            else:\\n                self.row_seats[row] += k\\n                break\\n        self.total_remaining -= ko\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237634,
                "title": "java-code-with-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BookMyShow {\\n    /**\\n        Segment tree class to store sum of a range and maximum available seats in a row\\n    **/\\n    static class SegTree{\\n        long sum[]; // store sum of seats in a range\\n        long segTree[]; // store maximum seats in a range\\n        int m, n;\\n        public SegTree(int n, int m) {\\n            this.m = m; \\n            this.n = n;\\n            segTree = new long[4*n];\\n            sum = new long[4*n];\\n            build(0, 0, n-1, m);\\n        }\\n        \\n        private void build(int index, int lo, int hi, long val){\\n            if(lo == hi){\\n                segTree[index] = val; // initialize segement tree with initial seat capacity\\n                sum[index] = val; // initialize \"sum\" with initial seat capacity of a row\\n                return;\\n            }\\n            int mid = (lo + hi)/2;\\n            build(2*index +1, lo, mid, val); // build left sub tree\\n            build(2*index +2, mid+1, hi, val); // build right sub tree\\n            segTree[index] = Math.max(segTree[2*index + 1], segTree[2*index + 2]); // maximum seats in a row for subtrees\\n            sum[index] = sum[2*index + 1] + sum[2*index + 2]; // sum of seats in a range\\n        }\\n        \\n        private void update(int index, int lo, int hi, int pos, int val){\\n            /**\\n                Method to update segment tree based on the available seats in a row\\n            **/\\n            if(lo == hi){\\n                segTree[index] = val;\\n                sum[index] = val;\\n                return;\\n            }\\n            int mid = (lo + hi) / 2;\\n            if (pos <= mid) {  // position to update is in left\\n               update(2 * index + 1, lo, mid, pos, val); \\n            } else { // position to update is in right\\n                update(2 * index + 2,  mid+1, hi, pos, val); \\n            }\\n\\t\\t\\t// update segment tree and \"sum\" based on the update in \"pos\" index \\n            segTree[index] = Math.max(segTree[2*index + 1] , segTree[2*index + 2]);\\n            sum[index] = sum[2*index + 1] + sum[2*index + 2];\\n        }\\n        \\n        public void update(int pos, int val){\\n            update(0, 0, n - 1 , pos, val);\\n        }\\n        \\n        public int gatherQuery(int k, int maxRow){\\n            return gatherQuery(0, 0, n - 1 , k, maxRow);    \\n        }\\n        \\n        private int gatherQuery(int index, int lo, int hi, int k, int maxRow){\\n            /**\\n                Method to check if seats are available in a single row \\n            **/\\n            if(segTree[index] < k || lo > maxRow)\\n                return -1;\\n            if(lo == hi) return lo;\\n            int mid = (lo + hi) / 2;\\n            int c = gatherQuery(2*index + 1, lo, mid, k, maxRow);\\n            if(c == -1){\\n                c = gatherQuery(2*index + 2, mid +1, hi, k, maxRow);\\n            }\\n            return c;\\n        }\\n        \\n        public long sumQuery(int k, int maxRow){\\n            return sumQuery(0, 0, n-1, k, maxRow);\\n        }\\n        \\n        private long sumQuery(int index, int lo, int hi, int l, int r){\\n            if(lo > r || hi < l ) return 0;  // not in range\\n            if(lo >= l && hi <= r) return sum[index]; // in range\\n            int mid = (lo + hi)/2;\\n            return sumQuery(2*index+1, lo, mid, l, r) + sumQuery(2*index+2, mid+1, hi, l, r);\\n        }\\n    }\\n    \\n    SegTree segTree;\\n    int[] rowSeats; // stores avaiable seats in a row, helps to find the vacant seat in a row\\n    \\n    public BookMyShow(int n, int m) {\\n        segTree = new SegTree(n, m);\\n        rowSeats = new int[n];\\n        Arrays.fill(rowSeats, m);  // initialize vacant seats count to \"m\" for all the rows\\n    }\\n\\n    \\n    public int[] gather(int k, int maxRow) {\\n        int row = segTree.gatherQuery(k, maxRow); // find row which has k seats\\n        if(row == -1) return new int[]{}; // can\\'t find a row with k seats\\n        int col = segTree.m - rowSeats[row]; // find column in the row which has k seats\\n        rowSeats[row] -= k; // reduce the seats \\n        segTree.update(row, rowSeats[row]); // update the segment tree\\n        return new int[]{row, col};\\n        \\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        long sum = segTree.sumQuery(0, maxRow); // find the sum for the given range [0, maxRow]\\n        if(sum < k) return false; // can\\'t find k seats in [0, maxRow]\\n        \\n        for(int i=0; i<=maxRow && k !=0 ; i++){\\n            if(rowSeats[i] > 0){                       // if current row has seats then allocate those seats          \\n                long t = Math.min(rowSeats[i], k);  \\n                rowSeats[i] -= t;\\n                k -= t;\\n                segTree.update(i,rowSeats[i]);  // update the segment tree\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BookMyShow {\\n    /**\\n        Segment tree class to store sum of a range and maximum available seats in a row\\n    **/\\n    static class SegTree{\\n        long sum[]; // store sum of seats in a range\\n        long segTree[]; // store maximum seats in a range\\n        int m, n;\\n        public SegTree(int n, int m) {\\n            this.m = m; \\n            this.n = n;\\n            segTree = new long[4*n];\\n            sum = new long[4*n];\\n            build(0, 0, n-1, m);\\n        }\\n        \\n        private void build(int index, int lo, int hi, long val){\\n            if(lo == hi){\\n                segTree[index] = val; // initialize segement tree with initial seat capacity\\n                sum[index] = val; // initialize \"sum\" with initial seat capacity of a row\\n                return;\\n            }\\n            int mid = (lo + hi)/2;\\n            build(2*index +1, lo, mid, val); // build left sub tree\\n            build(2*index +2, mid+1, hi, val); // build right sub tree\\n            segTree[index] = Math.max(segTree[2*index + 1], segTree[2*index + 2]); // maximum seats in a row for subtrees\\n            sum[index] = sum[2*index + 1] + sum[2*index + 2]; // sum of seats in a range\\n        }\\n        \\n        private void update(int index, int lo, int hi, int pos, int val){\\n            /**\\n                Method to update segment tree based on the available seats in a row\\n            **/\\n            if(lo == hi){\\n                segTree[index] = val;\\n                sum[index] = val;\\n                return;\\n            }\\n            int mid = (lo + hi) / 2;\\n            if (pos <= mid) {  // position to update is in left\\n               update(2 * index + 1, lo, mid, pos, val); \\n            } else { // position to update is in right\\n                update(2 * index + 2,  mid+1, hi, pos, val); \\n            }\\n\\t\\t\\t// update segment tree and \"sum\" based on the update in \"pos\" index \\n            segTree[index] = Math.max(segTree[2*index + 1] , segTree[2*index + 2]);\\n            sum[index] = sum[2*index + 1] + sum[2*index + 2];\\n        }\\n        \\n        public void update(int pos, int val){\\n            update(0, 0, n - 1 , pos, val);\\n        }\\n        \\n        public int gatherQuery(int k, int maxRow){\\n            return gatherQuery(0, 0, n - 1 , k, maxRow);    \\n        }\\n        \\n        private int gatherQuery(int index, int lo, int hi, int k, int maxRow){\\n            /**\\n                Method to check if seats are available in a single row \\n            **/\\n            if(segTree[index] < k || lo > maxRow)\\n                return -1;\\n            if(lo == hi) return lo;\\n            int mid = (lo + hi) / 2;\\n            int c = gatherQuery(2*index + 1, lo, mid, k, maxRow);\\n            if(c == -1){\\n                c = gatherQuery(2*index + 2, mid +1, hi, k, maxRow);\\n            }\\n            return c;\\n        }\\n        \\n        public long sumQuery(int k, int maxRow){\\n            return sumQuery(0, 0, n-1, k, maxRow);\\n        }\\n        \\n        private long sumQuery(int index, int lo, int hi, int l, int r){\\n            if(lo > r || hi < l ) return 0;  // not in range\\n            if(lo >= l && hi <= r) return sum[index]; // in range\\n            int mid = (lo + hi)/2;\\n            return sumQuery(2*index+1, lo, mid, l, r) + sumQuery(2*index+2, mid+1, hi, l, r);\\n        }\\n    }\\n    \\n    SegTree segTree;\\n    int[] rowSeats; // stores avaiable seats in a row, helps to find the vacant seat in a row\\n    \\n    public BookMyShow(int n, int m) {\\n        segTree = new SegTree(n, m);\\n        rowSeats = new int[n];\\n        Arrays.fill(rowSeats, m);  // initialize vacant seats count to \"m\" for all the rows\\n    }\\n\\n    \\n    public int[] gather(int k, int maxRow) {\\n        int row = segTree.gatherQuery(k, maxRow); // find row which has k seats\\n        if(row == -1) return new int[]{}; // can\\'t find a row with k seats\\n        int col = segTree.m - rowSeats[row]; // find column in the row which has k seats\\n        rowSeats[row] -= k; // reduce the seats \\n        segTree.update(row, rowSeats[row]); // update the segment tree\\n        return new int[]{row, col};\\n        \\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        long sum = segTree.sumQuery(0, maxRow); // find the sum for the given range [0, maxRow]\\n        if(sum < k) return false; // can\\'t find k seats in [0, maxRow]\\n        \\n        for(int i=0; i<=maxRow && k !=0 ; i++){\\n            if(rowSeats[i] > 0){                       // if current row has seats then allocate those seats          \\n                long t = Math.min(rowSeats[i], k);  \\n                rowSeats[i] -= t;\\n                k -= t;\\n                segTree.update(i,rowSeats[i]);  // update the segment tree\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154229,
                "title": "simple-solution-using-square-root-decomposition",
                "content": "# Intuition\\nQuite obvious fact is that we always need to find smallest row that has >= k seats available (as we will always place people in the first available seats) or check whether first maxRows has more than K seats in total. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLets group rows into $$O(N^{0.5})$$ equal batches, except the last one (which may be shorter). For each batch we need two values: length of the longest available seat sequence and total number of seats in the batch. \\nNow to find a max on the prefix rows we simply check full batches that fully fit and $$O(N^{0.5})$$ single rows that are not forming full batch. This will take $$O(N^{0.5})$$.\\nWhen changing one element we simply recalculate the entire batch. Again, time is $$O(N^{0.5})$$.\\nTo find the sum we can follow the same approach. \\nOne important note is that we will not change more than $$O(N)$$ elements in total when seating in any available seats queries.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N^{1.5})$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class BookMyShow\\n{\\n\\n    int[] seatsLeft;\\n    long[] gMax;\\n    long[] gSum;\\n\\n    int N;\\n    int M;\\n    int gIt;\\n\\n    const int gSize = 250;\\n    \\n    public BookMyShow(int n, int m)\\n    {\\n        N = n;\\n        M = m;\\n        seatsLeft = new int[n];\\n        gMax = new long[n / gSize + 1];\\n        gSum = new long[n / gSize + 1];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            seatsLeft[i] = m;\\n\\n            gMax[i / gSize] = Math.Max(gMax[i / gSize], m);\\n            gSum[i / gSize] += m;\\n        }                \\n    }\\n    \\n    public int[] Gather(int k, int maxRow)\\n    {\\n        for (int g = 0; g <= (N - 1) / gSize; g++)\\n        {\\n            if (g * gSize > maxRow)\\n            {\\n                continue;\\n            }\\n\\n            if (g * gSize + gSize - 1 <= maxRow)\\n            {\\n                if (gMax[g] >= k)\\n                {\\n                    return GatherInterval(k, g * gSize, g * gSize + gSize - 1);\\n                }\\n            }\\n            else\\n            {\\n                return GatherInterval(k, g * gSize, maxRow);\\n            }\\n        }\\n        return new int[0];\\n    }\\n\\n    int[] GatherInterval(int k, int l, int r)\\n    {\\n        int ans = -1;\\n        for (int i = l; i <= r; i++)\\n        {\\n            if (seatsLeft[i] >= k)\\n            {\\n                ans = i;\\n                break;\\n            }\\n        }\\n        if (ans == -1)\\n        {\\n            return new int[0];\\n        }\\n        var ret = new int[] { ans, M - seatsLeft[ans] };\\n        seatsLeft[ans] -= k;\\n        int g = ans / gSize;\\n        gSum[g] -= k;\\n        gMax[g] = 0;        \\n        for (int i = g * gSize; i <= g * gSize + gSize - 1 && i < N; i++)\\n        {\\n            gMax[g] = Math.Max(gMax[g], seatsLeft[i]);\\n        }\\n        return ret;\\n    }\\n    \\n    public bool Scatter(int k, int maxRow)\\n    {\\n        long sum = 0;\\n        int it;\\n        for (it = 0; it + gSize < maxRow; it += gSize)\\n        {\\n            sum += gSum[it / gSize];\\n        }\\n        while (it <= maxRow)\\n        {\\n            sum += seatsLeft[it];\\n            it++;\\n        }\\n        if (sum < k)\\n        {\\n            return false;\\n        }       \\n        int iGIt = gIt; \\n        while (k > 0)\\n        {\\n            if (seatsLeft[gIt] < k)\\n            {\\n                k -= seatsLeft[gIt];\\n                gSum[gIt / gSize] -= seatsLeft[gIt];\\n                seatsLeft[gIt] = 0;\\n                gIt++;\\n            }\\n            else\\n            {\\n                seatsLeft[gIt] -= k;\\n                gSum[gIt / gSize] -= k;\\n                k = 0;\\n            }\\n        }\\n        int g1 = iGIt / gSize;\\n        int g2 = gIt / gSize;\\n        for (int g = g1; g <= g2; g++)\\n        {\\n            gMax[g] = 0;\\n            for (int i = g * gSize; i <= g * gSize + gSize - 1 && i < N; i++)\\n            {\\n                gMax[g] = Math.Max(gMax[g], seatsLeft[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.Gather(k,maxRow);\\n * bool param_2 = obj.Scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class BookMyShow\\n{\\n\\n    int[] seatsLeft;\\n    long[] gMax;\\n    long[] gSum;\\n\\n    int N;\\n    int M;\\n    int gIt;\\n\\n    const int gSize = 250;\\n    \\n    public BookMyShow(int n, int m)\\n    {\\n        N = n;\\n        M = m;\\n        seatsLeft = new int[n];\\n        gMax = new long[n / gSize + 1];\\n        gSum = new long[n / gSize + 1];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            seatsLeft[i] = m;\\n\\n            gMax[i / gSize] = Math.Max(gMax[i / gSize], m);\\n            gSum[i / gSize] += m;\\n        }                \\n    }\\n    \\n    public int[] Gather(int k, int maxRow)\\n    {\\n        for (int g = 0; g <= (N - 1) / gSize; g++)\\n        {\\n            if (g * gSize > maxRow)\\n            {\\n                continue;\\n            }\\n\\n            if (g * gSize + gSize - 1 <= maxRow)\\n            {\\n                if (gMax[g] >= k)\\n                {\\n                    return GatherInterval(k, g * gSize, g * gSize + gSize - 1);\\n                }\\n            }\\n            else\\n            {\\n                return GatherInterval(k, g * gSize, maxRow);\\n            }\\n        }\\n        return new int[0];\\n    }\\n\\n    int[] GatherInterval(int k, int l, int r)\\n    {\\n        int ans = -1;\\n        for (int i = l; i <= r; i++)\\n        {\\n            if (seatsLeft[i] >= k)\\n            {\\n                ans = i;\\n                break;\\n            }\\n        }\\n        if (ans == -1)\\n        {\\n            return new int[0];\\n        }\\n        var ret = new int[] { ans, M - seatsLeft[ans] };\\n        seatsLeft[ans] -= k;\\n        int g = ans / gSize;\\n        gSum[g] -= k;\\n        gMax[g] = 0;        \\n        for (int i = g * gSize; i <= g * gSize + gSize - 1 && i < N; i++)\\n        {\\n            gMax[g] = Math.Max(gMax[g], seatsLeft[i]);\\n        }\\n        return ret;\\n    }\\n    \\n    public bool Scatter(int k, int maxRow)\\n    {\\n        long sum = 0;\\n        int it;\\n        for (it = 0; it + gSize < maxRow; it += gSize)\\n        {\\n            sum += gSum[it / gSize];\\n        }\\n        while (it <= maxRow)\\n        {\\n            sum += seatsLeft[it];\\n            it++;\\n        }\\n        if (sum < k)\\n        {\\n            return false;\\n        }       \\n        int iGIt = gIt; \\n        while (k > 0)\\n        {\\n            if (seatsLeft[gIt] < k)\\n            {\\n                k -= seatsLeft[gIt];\\n                gSum[gIt / gSize] -= seatsLeft[gIt];\\n                seatsLeft[gIt] = 0;\\n                gIt++;\\n            }\\n            else\\n            {\\n                seatsLeft[gIt] -= k;\\n                gSum[gIt / gSize] -= k;\\n                k = 0;\\n            }\\n        }\\n        int g1 = iGIt / gSize;\\n        int g2 = gIt / gSize;\\n        for (int g = g1; g <= g2; g++)\\n        {\\n            gMax[g] = 0;\\n            for (int i = g * gSize; i <= g * gSize + gSize - 1 && i < N; i++)\\n            {\\n                gMax[g] = Math.Max(gMax[g], seatsLeft[i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.Gather(k,maxRow);\\n * bool param_2 = obj.Scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129304,
                "title": "c-using-segment-tree",
                "content": "```\\npublic class BookMyShow {\\n    (long max, long sum)[] st;\\n    int m,n;\\n    int N;\\n    int size;\\n    public BookMyShow(int n, int m) {\\n        this.m=m;\\n        this.n=n;\\n        N=1;\\n        while(N<n)\\n            N=N<<1;\\n        size=2*N-1;\\n        st=new (long max, long sum)[size];\\n        \\n        InitializeTree();\\n        \\n        \\n        \\n    }\\n    \\n    public int[] Gather(int k, int maxRow) {\\n        int[] result= new int[2];\\n        int[] r;\\n        if(!AllocateGather(0,k,maxRow, 0, N-1,  result))\\n            return new int[]{};\\n        return result;\\n    }\\n    \\n    \\n    public bool Scatter(int k, int maxRow) {\\n        int a=k;\\n        CheckAvailability(0, ref a,  maxRow, 0,N-1);\\n        if(a>0)\\n            return false;\\n        long allocated=AllocateScatter( 0, k,  maxRow, 0,N-1);\\n\\n        return true;\\n        \\n    }\\n    \\n    \\n    public bool AllocateGather(int idx, int k, int maxRow, int low, int high, int[] result)\\n    {\\n        if(low>maxRow || st[idx].max<k)\\n            return false;\\n\\n        if(idx>=N-1){ //IsLeaf\\n            result[0]=idx-(N-1);\\n            result[1]=(int)((long)m -st[idx].max);\\n            st[idx].max -=k;\\n            st[idx].sum-=k;\\n            \\n            return true;\\n        }\\n        \\n        if(AllocateGather(2*idx+1,k,maxRow, low, (low+high)/2,result))\\n        {\\n            st[idx].max=Math.Max(st[2*idx+1].max,st[2*idx+2].max);\\n            st[idx].sum=st[2*idx+1].sum+st[2*idx+2].sum;\\n        }\\n        else if(AllocateGather(2*idx+2,k,maxRow, (low+high)/2+1, high,result)){\\n            st[idx].max=Math.Max(st[2*idx+1].max,st[2*idx+2].max);\\n            st[idx].sum=st[2*idx+1].sum+st[2*idx+2].sum;\\n\\n        }\\n        else \\n            return false;\\n        \\n        return true;\\n        \\n    }\\n    \\n    public long AllocateScatter(int idx, int k, int maxRow, int low, int high){\\n        if(low>maxRow || st[idx].sum==0 || k<=0)\\n            return 0;\\n        long allocated=0;\\n        \\n        if(idx>=N-1){ //IsLeaf\\n            allocated= Math.Min(k,st[idx].sum); \\n            st[idx].max -=allocated;\\n            st[idx].sum-=allocated;\\n            \\n            return allocated;\\n        }\\n        \\n        allocated+=AllocateScatter(2*idx+1,k-(int)allocated,maxRow, low, (low+high)/2);\\n        allocated+=AllocateScatter(2*idx+2,k-(int)allocated,maxRow, (low+high)/2+1, high);\\n        st[idx].max=Math.Max(st[2*idx+1].max,st[2*idx+2].max);\\n        st[idx].sum=st[2*idx+1].sum+st[2*idx+2].sum;\\n\\n        return allocated;\\n    }\\n\\n    \\n    public void CheckAvailability(int idx, ref int k, int maxRow, int low, int high)\\n    {\\n\\n        if(low>maxRow )\\n            return ;\\n        \\n        if(high <= maxRow ){\\n            k=k-(int)Math.Min(k,st[idx].sum);\\n            return;\\n        }\\n        if(idx>=N-1){ //IsLeaf\\n            k=k-(int)Math.Min(k,st[idx].sum);\\n            return;\\n        }\\n\\n        CheckAvailability(2*idx+1,ref k,maxRow, low, (low+high)/2);\\n        CheckAvailability(2*idx+2,ref k,maxRow, (low+high)/2+1, high);\\n\\n        \\n    }\\n    \\n    public void InitializeTree()\\n    {\\n        for(int b=N-1;b<Math.Min(2*N-1,n+N-1);b++)\\n            st[b]=(m,m);\\n        int l=N-1;\\n        while(l>0){\\n            l=(l-1)/2;\\n            for(int b=l;b<2*l+1;b++)\\n            {\\n                st[b]=(m, st[2*b+1].sum+st[2*b+2].sum);\\n            }\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.Gather(k,maxRow);\\n * bool param_2 = obj.Scatter(k,maxRow);\\n */\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\npublic class BookMyShow {\\n    (long max, long sum)[] st;\\n    int m,n;\\n    int N;\\n    int size;\\n    public BookMyShow(int n, int m) {\\n        this.m=m;\\n        this.n=n;\\n        N=1;\\n        while(N<n)\\n            N=N<<1;\\n        size=2*N-1;\\n        st=new (long max, long sum)[size];\\n        \\n        InitializeTree();\\n        \\n        \\n        \\n    }\\n    \\n    public int[] Gather(int k, int maxRow) {\\n        int[] result= new int[2];\\n        int[] r;\\n        if(!AllocateGather(0,k,maxRow, 0, N-1,  result))\\n            return new int[]{};\\n        return result;\\n    }\\n    \\n    \\n    public bool Scatter(int k, int maxRow) {\\n        int a=k;\\n        CheckAvailability(0, ref a,  maxRow, 0,N-1);\\n        if(a>0)\\n            return false;\\n        long allocated=AllocateScatter( 0, k,  maxRow, 0,N-1);\\n\\n        return true;\\n        \\n    }\\n    \\n    \\n    public bool AllocateGather(int idx, int k, int maxRow, int low, int high, int[] result)\\n    {\\n        if(low>maxRow || st[idx].max<k)\\n            return false;\\n\\n        if(idx>=N-1){ //IsLeaf\\n            result[0]=idx-(N-1);\\n            result[1]=(int)((long)m -st[idx].max);\\n            st[idx].max -=k;\\n            st[idx].sum-=k;\\n            \\n            return true;\\n        }\\n        \\n        if(AllocateGather(2*idx+1,k,maxRow, low, (low+high)/2,result))\\n        {\\n            st[idx].max=Math.Max(st[2*idx+1].max,st[2*idx+2].max);\\n            st[idx].sum=st[2*idx+1].sum+st[2*idx+2].sum;\\n        }\\n        else if(AllocateGather(2*idx+2,k,maxRow, (low+high)/2+1, high,result)){\\n            st[idx].max=Math.Max(st[2*idx+1].max,st[2*idx+2].max);\\n            st[idx].sum=st[2*idx+1].sum+st[2*idx+2].sum;\\n\\n        }\\n        else \\n            return false;\\n        \\n        return true;\\n        \\n    }\\n    \\n    public long AllocateScatter(int idx, int k, int maxRow, int low, int high){\\n        if(low>maxRow || st[idx].sum==0 || k<=0)\\n            return 0;\\n        long allocated=0;\\n        \\n        if(idx>=N-1){ //IsLeaf\\n            allocated= Math.Min(k,st[idx].sum); \\n            st[idx].max -=allocated;\\n            st[idx].sum-=allocated;\\n            \\n            return allocated;\\n        }\\n        \\n        allocated+=AllocateScatter(2*idx+1,k-(int)allocated,maxRow, low, (low+high)/2);\\n        allocated+=AllocateScatter(2*idx+2,k-(int)allocated,maxRow, (low+high)/2+1, high);\\n        st[idx].max=Math.Max(st[2*idx+1].max,st[2*idx+2].max);\\n        st[idx].sum=st[2*idx+1].sum+st[2*idx+2].sum;\\n\\n        return allocated;\\n    }\\n\\n    \\n    public void CheckAvailability(int idx, ref int k, int maxRow, int low, int high)\\n    {\\n\\n        if(low>maxRow )\\n            return ;\\n        \\n        if(high <= maxRow ){\\n            k=k-(int)Math.Min(k,st[idx].sum);\\n            return;\\n        }\\n        if(idx>=N-1){ //IsLeaf\\n            k=k-(int)Math.Min(k,st[idx].sum);\\n            return;\\n        }\\n\\n        CheckAvailability(2*idx+1,ref k,maxRow, low, (low+high)/2);\\n        CheckAvailability(2*idx+2,ref k,maxRow, (low+high)/2+1, high);\\n\\n        \\n    }\\n    \\n    public void InitializeTree()\\n    {\\n        for(int b=N-1;b<Math.Min(2*N-1,n+N-1);b++)\\n            st[b]=(m,m);\\n        int l=N-1;\\n        while(l>0){\\n            l=(l-1)/2;\\n            for(int b=l;b<2*l+1;b++)\\n            {\\n                st[b]=(m, st[2*b+1].sum+st[2*b+2].sum);\\n            }\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.Gather(k,maxRow);\\n * bool param_2 = obj.Scatter(k,maxRow);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046738,
                "title": "java-solution-beats-86-36",
                "content": "# Code\\n```\\nclass BookMyShow {\\n    int n;\\n    int m;\\n    long[][] stree; \\n    public void build(int i, int p, int q) {\\n        if (p == q) {\\n            stree[i][0] = m;\\n            stree[i][1] = m;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][0] = m;\\n        stree[i][1] = (long)(q-p+1)*m;\\n        build(2*i+1, p, r);\\n        build(2*i+2, r+1, q);\\n    }\\n\\n    public int[] query_max(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return new int[0];\\n        if (stree[i][0] < k)\\n            return new int[0];\\n        if (p == q)\\n            return new int[]{p, (int)(m - stree[i][0])};\\n        int r = (p + q) / 2;\\n        int[] ret = query_max(2*i+1, p, r, k, maxRow);\\n        if (ret.length > 0)\\n            return ret;\\n        return query_max(2*i+2, r+1, q, k, maxRow);\\n    }\\n\\n    public void update_max(int i, int p, int q, int row, int k) {\\n        if (p > row || q < row)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            \\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        update_max(2*i+1, p, r, row, k);\\n        update_max(2*i+2, r+1, q, row, k);\\n        stree[i][0] = Math.max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n    public long query_sum(int i, int p, int q, int maxRow) {\\n        if (p > maxRow)\\n            return 0;\\n        if (q <= maxRow)\\n            return stree[i][1];\\n        int r = (p + q) / 2;\\n        return query_sum(2*i+1, p, r, maxRow) + query_sum(2*i+2, r+1, q, maxRow);\\n    }\\n\\n    public void update_sum(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            \\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        if (r+1 > maxRow || stree[2*i+1][1] >= k) {\\n            update_sum(2*i+1, p, r, k, maxRow);\\n        } else {\\n            k -= stree[2*i+1][1];\\n            update_sum(2*i+1, p, r, (int)stree[2*i+1][1], maxRow);\\n           \\n            update_sum(2*i+2, r+1, q, k, maxRow);\\n        }\\n        stree[i][0] = Math.max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n\\n    public BookMyShow(int n_in, int m_in) {\\n        n = n_in;\\n        m = m_in;\\n\\n        int sz = 1;\\n        while (sz < n*2)\\n            sz <<= 1;\\n        stree = new long[sz][2];\\n\\n        build(0, 0, n-1);\\n    }\\n\\n    public int[] gather(int k, int maxRow) {\\n        \\n        int[] ret = query_max(0, 0, n-1, k, maxRow);\\n        if (ret.length > 0)\\n            update_max(0, 0, n-1, ret[0], k);\\n        return ret;\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n       \\n        long cnt = query_sum(0, 0, n-1, maxRow);\\n        boolean ret = cnt >= k;\\n        if (ret)\\n            update_sum(0, 0, n-1, k, maxRow);\\n        return ret;\\n    }\\n};\\n\\nclass Solution {\\n    public static void main (String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        int t = sc.nextInt();\\n        while (t-- > 0) {\\n            int n = sc.nextInt();\\n            int m = sc.nextInt();\\n            BookMyShow bms = new BookMyShow(n, m);\\n            int q = sc.nextInt();\\n            while (q-- > 0) {\\n                String op = sc.next();\\n                int k = sc.nextInt();\\n                int maxRow = sc.nextInt();\\n                if (op.equals(\"gather\")) {\\n                    int[] ret = bms.gather(k, maxRow);\\n                    if (ret.length > 0)\\n                        System.out.println(ret[0] + \" \" + ret[1]);\\n                    else\\n                        System.out.println(\"-1\");\\n                } else {\\n                    boolean ret = bms.scatter(k, maxRow);\\n                    if (ret)\\n                        System.out.println(\"1\");\\n                    else\\n                        System.out.println(\"0\");\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BookMyShow {\\n    int n;\\n    int m;\\n    long[][] stree; \\n    public void build(int i, int p, int q) {\\n        if (p == q) {\\n            stree[i][0] = m;\\n            stree[i][1] = m;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][0] = m;\\n        stree[i][1] = (long)(q-p+1)*m;\\n        build(2*i+1, p, r);\\n        build(2*i+2, r+1, q);\\n    }\\n\\n    public int[] query_max(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return new int[0];\\n        if (stree[i][0] < k)\\n            return new int[0];\\n        if (p == q)\\n            return new int[]{p, (int)(m - stree[i][0])};\\n        int r = (p + q) / 2;\\n        int[] ret = query_max(2*i+1, p, r, k, maxRow);\\n        if (ret.length > 0)\\n            return ret;\\n        return query_max(2*i+2, r+1, q, k, maxRow);\\n    }\\n\\n    public void update_max(int i, int p, int q, int row, int k) {\\n        if (p > row || q < row)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            \\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        update_max(2*i+1, p, r, row, k);\\n        update_max(2*i+2, r+1, q, row, k);\\n        stree[i][0] = Math.max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n    public long query_sum(int i, int p, int q, int maxRow) {\\n        if (p > maxRow)\\n            return 0;\\n        if (q <= maxRow)\\n            return stree[i][1];\\n        int r = (p + q) / 2;\\n        return query_sum(2*i+1, p, r, maxRow) + query_sum(2*i+2, r+1, q, maxRow);\\n    }\\n\\n    public void update_sum(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            \\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        if (r+1 > maxRow || stree[2*i+1][1] >= k) {\\n            update_sum(2*i+1, p, r, k, maxRow);\\n        } else {\\n            k -= stree[2*i+1][1];\\n            update_sum(2*i+1, p, r, (int)stree[2*i+1][1], maxRow);\\n           \\n            update_sum(2*i+2, r+1, q, k, maxRow);\\n        }\\n        stree[i][0] = Math.max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n\\n    public BookMyShow(int n_in, int m_in) {\\n        n = n_in;\\n        m = m_in;\\n\\n        int sz = 1;\\n        while (sz < n*2)\\n            sz <<= 1;\\n        stree = new long[sz][2];\\n\\n        build(0, 0, n-1);\\n    }\\n\\n    public int[] gather(int k, int maxRow) {\\n        \\n        int[] ret = query_max(0, 0, n-1, k, maxRow);\\n        if (ret.length > 0)\\n            update_max(0, 0, n-1, ret[0], k);\\n        return ret;\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n       \\n        long cnt = query_sum(0, 0, n-1, maxRow);\\n        boolean ret = cnt >= k;\\n        if (ret)\\n            update_sum(0, 0, n-1, k, maxRow);\\n        return ret;\\n    }\\n};\\n\\nclass Solution {\\n    public static void main (String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        int t = sc.nextInt();\\n        while (t-- > 0) {\\n            int n = sc.nextInt();\\n            int m = sc.nextInt();\\n            BookMyShow bms = new BookMyShow(n, m);\\n            int q = sc.nextInt();\\n            while (q-- > 0) {\\n                String op = sc.next();\\n                int k = sc.nextInt();\\n                int maxRow = sc.nextInt();\\n                if (op.equals(\"gather\")) {\\n                    int[] ret = bms.gather(k, maxRow);\\n                    if (ret.length > 0)\\n                        System.out.println(ret[0] + \" \" + ret[1]);\\n                    else\\n                        System.out.println(\"-1\");\\n                } else {\\n                    boolean ret = bms.scatter(k, maxRow);\\n                    if (ret)\\n                        System.out.println(\"1\");\\n                    else\\n                        System.out.println(\"0\");\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916958,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long int ll;\\nclass SegTree{\\n    vector<ll> seg, sum;\\npublic:\\n    SegTree(ll n){\\n        seg.resize(4*n + 1);\\n        sum.resize(4*n + 1);\\n    }\\n    void build(ll ind, ll low, ll high, vector<ll> &arr){\\n        if(low == high){\\n            seg[ind] = arr[low];\\n            sum[ind] = arr[low];\\n            return;\\n        }\\n        ll mid = (low + high) >> 1;\\n        build(2*ind + 1, low, mid, arr);\\n        build(2*ind + 2, mid + 1, high, arr);\\n        seg[ind] = max(seg[2*ind + 1], seg[2*ind + 2]);\\n        sum[ind] = sum[2*ind + 1] + sum[2*ind + 2];\\n        \\n    }\\n    void update(ll ind, ll low, ll high, ll i, ll val, vector<ll> &arr){\\n        if(low == high){\\n            sum[ind] = val;\\n            seg[ind] = val;\\n            arr[low] = val;\\n            return;\\n        }\\n        ll mid = (low + high) >> 1;\\n        if(i <= mid){\\n            update(2*ind + 1, low, mid, i, val, arr);\\n        }else{\\n            update(2*ind + 2, mid + 1, high, i, val, arr);\\n        }\\n        seg[ind] = max(seg[2*ind + 1], seg[2*ind + 2]);\\n        sum[ind] = sum[2*ind + 1] + sum[2*ind + 2];\\n    }\\n    ll atleastx(ll ind, ll low, ll high, ll x, ll n){\\n        if(seg[ind] < x){\\n            return n;\\n        }\\n        if(low == high){\\n            return low;\\n        }\\n        ll mid = (low + high) >> 1;\\n        if(seg[2*ind+1] >= x){\\n            return atleastx(2*ind + 1, low, mid, x, n);\\n        }\\n        return atleastx(2*ind + 2, mid + 1, high, x, n);\\n    }\\n    ll getsum(ll ind, ll low, ll high, ll l, ll r){\\n        if(high < l || low > r){\\n            return 0;\\n        }\\n        if(low >= l && r >= high){\\n            return sum[ind];\\n        }\\n        ll mid = (low + high) >> 1;\\n        return getsum(2*ind + 1, low, mid, l, r) + getsum(2*ind + 2, mid + 1, high, l, r);\\n    }\\n};\\n\\nclass BookMyShow {\\n    vector<ll> arr;\\n    SegTree* st;\\n    ll rows;\\n    ll cols;\\n    ll zero;\\npublic:\\n    BookMyShow(ll n, ll m) {\\n        arr.resize(n, m);\\n        st = new SegTree(n);\\n        st->build(0, 0, n-1, arr);\\n        rows = n;\\n        cols = m;\\n        zero = 0;\\n    }\\n    \\n    vector<ll> gather(ll k, ll maxRow) {\\n        vector<ll> result;\\n        ll index = st->atleastx(0, 0, rows-1, k, rows);\\n        if(index > maxRow){\\n            return result;\\n        }\\n        result.push_back(index);\\n        result.push_back(cols - arr[index]);\\n        st->update(0, 0, rows-1, index, arr[index] - k, arr);\\n        return result;\\n    }\\n    \\n    bool scatter(ll k, ll maxRow) {\\n        ll sum = st->getsum(0, 0, rows-1, 0, maxRow);\\n        if(sum < k){\\n            return false;\\n        }\\n        while(k != 0){\\n            ll mini = min(k, arr[zero]);\\n            k -= mini;\\n            st->update(0, 0, rows-1, zero, arr[zero] - mini, arr);\\n            if(arr[zero] == 0){\\n                zero++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\nclass SegTree{\\n    vector<ll> seg, sum;\\npublic:\\n    SegTree(ll n){\\n        seg.resize(4*n + 1);\\n        sum.resize(4*n + 1);\\n    }\\n    void build(ll ind, ll low, ll high, vector<ll> &arr){\\n        if(low == high){\\n            seg[ind] = arr[low];\\n            sum[ind] = arr[low];\\n            return;\\n        }\\n        ll mid = (low + high) >> 1;\\n        build(2*ind + 1, low, mid, arr);\\n        build(2*ind + 2, mid + 1, high, arr);\\n        seg[ind] = max(seg[2*ind + 1], seg[2*ind + 2]);\\n        sum[ind] = sum[2*ind + 1] + sum[2*ind + 2];\\n        \\n    }\\n    void update(ll ind, ll low, ll high, ll i, ll val, vector<ll> &arr){\\n        if(low == high){\\n            sum[ind] = val;\\n            seg[ind] = val;\\n            arr[low] = val;\\n            return;\\n        }\\n        ll mid = (low + high) >> 1;\\n        if(i <= mid){\\n            update(2*ind + 1, low, mid, i, val, arr);\\n        }else{\\n            update(2*ind + 2, mid + 1, high, i, val, arr);\\n        }\\n        seg[ind] = max(seg[2*ind + 1], seg[2*ind + 2]);\\n        sum[ind] = sum[2*ind + 1] + sum[2*ind + 2];\\n    }\\n    ll atleastx(ll ind, ll low, ll high, ll x, ll n){\\n        if(seg[ind] < x){\\n            return n;\\n        }\\n        if(low == high){\\n            return low;\\n        }\\n        ll mid = (low + high) >> 1;\\n        if(seg[2*ind+1] >= x){\\n            return atleastx(2*ind + 1, low, mid, x, n);\\n        }\\n        return atleastx(2*ind + 2, mid + 1, high, x, n);\\n    }\\n    ll getsum(ll ind, ll low, ll high, ll l, ll r){\\n        if(high < l || low > r){\\n            return 0;\\n        }\\n        if(low >= l && r >= high){\\n            return sum[ind];\\n        }\\n        ll mid = (low + high) >> 1;\\n        return getsum(2*ind + 1, low, mid, l, r) + getsum(2*ind + 2, mid + 1, high, l, r);\\n    }\\n};\\n\\nclass BookMyShow {\\n    vector<ll> arr;\\n    SegTree* st;\\n    ll rows;\\n    ll cols;\\n    ll zero;\\npublic:\\n    BookMyShow(ll n, ll m) {\\n        arr.resize(n, m);\\n        st = new SegTree(n);\\n        st->build(0, 0, n-1, arr);\\n        rows = n;\\n        cols = m;\\n        zero = 0;\\n    }\\n    \\n    vector<ll> gather(ll k, ll maxRow) {\\n        vector<ll> result;\\n        ll index = st->atleastx(0, 0, rows-1, k, rows);\\n        if(index > maxRow){\\n            return result;\\n        }\\n        result.push_back(index);\\n        result.push_back(cols - arr[index]);\\n        st->update(0, 0, rows-1, index, arr[index] - k, arr);\\n        return result;\\n    }\\n    \\n    bool scatter(ll k, ll maxRow) {\\n        ll sum = st->getsum(0, 0, rows-1, 0, maxRow);\\n        if(sum < k){\\n            return false;\\n        }\\n        while(k != 0){\\n            ll mini = min(k, arr[zero]);\\n            k -= mini;\\n            st->update(0, 0, rows-1, zero, arr[zero] - mini, arr);\\n            if(arr[zero] == 0){\\n                zero++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897890,
                "title": "python3-book-my-show-best-of-luck",
                "content": ">\\n\\n# Code\\n```\\nfrom bisect import bisect_left\\nfrom collections import deque\\n\\n\\nclass BookMyShow:\\n    def __init__(self, n, m):\\n        self.n, self.m = n, m\\n        self.free_row = 0\\n        self.partial_rows = deque()\\n        self.maximums = deque()\\n\\n    def gather(self, k, maxRow):\\n        if k > self.m:\\n            return []\\n        lowest = self.use_lowest_partial_row(k, maxRow)\\n        if not lowest:\\n            lowest = self.use_free_row(k, maxRow)\\n        return lowest\\n\\n    def scatter(self, k, maxRow):\\n        found = 0\\n        found_last = found_last_i = -1\\n        for i, (row, seats_remaining) in enumerate(self.partial_rows):\\n            if row > maxRow:\\n                break\\n            found += seats_remaining\\n            found_last = seats_remaining\\n            found_last_i = i\\n            if found >= k:\\n                break\\n        k_remaining = k - min(found, k)\\n        if not self.check_free_rows(k_remaining, maxRow):\\n            return False\\n        self.use_free_rows(k_remaining)\\n        if found_last != -1:\\n            used = k - k_remaining\\n            before_last = found - found_last\\n            used_last = used - before_last\\n            last_left = found_last - used_last\\n            if last_left:\\n                for _ in range(found_last_i):\\n                    self.pop()\\n                self.partial_rows[0][1] -= used_last\\n            else:\\n                for _ in range(found_last_i+1):\\n                    self.pop()\\n        return True\\n\\n    def push(self, row, seats_remaining):\\n        if seats_remaining:\\n            self.partial_rows.append([row, seats_remaining])\\n            self.maximums.append(\\n                max(seats_remaining, self.maximums[-1] if self.maximums else 0))\\n\\n    def pop(self):\\n        self.maximums.popleft()\\n        return self.partial_rows.popleft()\\n\\n    def use_free_row(self, k, maxRow):\\n        if self.free_row > maxRow:\\n            return []\\n        self.push(self.free_row, self.m-k)\\n        ans = [self.free_row, 0]\\n        self.free_row += 1\\n        return ans\\n\\n    def check_free_rows(self, k, maxRow):\\n        if k == 0:\\n            return True\\n        free_rows_between = maxRow - self.free_row + 1\\n        free_seats_between = free_rows_between * self.m\\n        return free_seats_between >= k\\n\\n    def use_free_rows(self, k):\\n        entire_rows_used, partial_row_used = divmod(k, self.m)\\n        self.free_row += entire_rows_used + 1\\n        self.push(self.free_row-1, self.m - partial_row_used)\\n\\n    def use_lowest_partial_row(self, k, maxRow):\\n        if not self.partial_rows or k <= 0:\\n            return []\\n        for i in range(max(bisect_left(self.maximums, k)-1, 0), len(self.partial_rows)):\\n            row, seats_remaining = self.partial_rows[i]\\n            if row > maxRow:\\n                break\\n            if seats_remaining > k:\\n                self.partial_rows[i][1] -= k\\n                return [row, self.m-seats_remaining]\\n            elif seats_remaining == k:\\n                del self.partial_rows[i]\\n                return [row, self.m-seats_remaining]\\n        return []\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_left\\nfrom collections import deque\\n\\n\\nclass BookMyShow:\\n    def __init__(self, n, m):\\n        self.n, self.m = n, m\\n        self.free_row = 0\\n        self.partial_rows = deque()\\n        self.maximums = deque()\\n\\n    def gather(self, k, maxRow):\\n        if k > self.m:\\n            return []\\n        lowest = self.use_lowest_partial_row(k, maxRow)\\n        if not lowest:\\n            lowest = self.use_free_row(k, maxRow)\\n        return lowest\\n\\n    def scatter(self, k, maxRow):\\n        found = 0\\n        found_last = found_last_i = -1\\n        for i, (row, seats_remaining) in enumerate(self.partial_rows):\\n            if row > maxRow:\\n                break\\n            found += seats_remaining\\n            found_last = seats_remaining\\n            found_last_i = i\\n            if found >= k:\\n                break\\n        k_remaining = k - min(found, k)\\n        if not self.check_free_rows(k_remaining, maxRow):\\n            return False\\n        self.use_free_rows(k_remaining)\\n        if found_last != -1:\\n            used = k - k_remaining\\n            before_last = found - found_last\\n            used_last = used - before_last\\n            last_left = found_last - used_last\\n            if last_left:\\n                for _ in range(found_last_i):\\n                    self.pop()\\n                self.partial_rows[0][1] -= used_last\\n            else:\\n                for _ in range(found_last_i+1):\\n                    self.pop()\\n        return True\\n\\n    def push(self, row, seats_remaining):\\n        if seats_remaining:\\n            self.partial_rows.append([row, seats_remaining])\\n            self.maximums.append(\\n                max(seats_remaining, self.maximums[-1] if self.maximums else 0))\\n\\n    def pop(self):\\n        self.maximums.popleft()\\n        return self.partial_rows.popleft()\\n\\n    def use_free_row(self, k, maxRow):\\n        if self.free_row > maxRow:\\n            return []\\n        self.push(self.free_row, self.m-k)\\n        ans = [self.free_row, 0]\\n        self.free_row += 1\\n        return ans\\n\\n    def check_free_rows(self, k, maxRow):\\n        if k == 0:\\n            return True\\n        free_rows_between = maxRow - self.free_row + 1\\n        free_seats_between = free_rows_between * self.m\\n        return free_seats_between >= k\\n\\n    def use_free_rows(self, k):\\n        entire_rows_used, partial_row_used = divmod(k, self.m)\\n        self.free_row += entire_rows_used + 1\\n        self.push(self.free_row-1, self.m - partial_row_used)\\n\\n    def use_lowest_partial_row(self, k, maxRow):\\n        if not self.partial_rows or k <= 0:\\n            return []\\n        for i in range(max(bisect_left(self.maximums, k)-1, 0), len(self.partial_rows)):\\n            row, seats_remaining = self.partial_rows[i]\\n            if row > maxRow:\\n                break\\n            if seats_remaining > k:\\n                self.partial_rows[i][1] -= k\\n                return [row, self.m-seats_remaining]\\n            elif seats_remaining == k:\\n                del self.partial_rows[i]\\n                return [row, self.m-seats_remaining]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865643,
                "title": "memory-beats-99-7-using-a-few-optimizations-on-the-unordered-searching-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have used the property that, for any two rows which are not totally empty, the total number of available seats  in those rows must be less than the total number of seats in a row. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe above intuition implies:\\n- In *gather*, if in any occupied row, the number of filled seats is less than the number of seats required to  be reserved, then we can skip the search to the first empty row. This helps reduce the time required by the search.\\n- In *scatter*, the max possible available seats in $\\\\mathcal{L}$ seats which are neither completely empty, nor completely full is $ m*\\\\lceil\\\\frac{\\\\mathcal{L}}{2}\\\\rceil$.\\n\\nUsing above two optimizations, unordered search is used for each row, after the one that has been marked completely filled.\\n\\n# Complexity\\n- Time complexity: $\\\\mathcal{O}(n)$ (worst case)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $\\\\mathcal{O}(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass BookMyShow {\\n    int* A_occupancy;\\n    int numRows, numCols;\\n    int first_A_row;\\n    int first_unused_row;\\npublic:\\n    BookMyShow(int n, int m) {\\n        A_occupancy = new int[n];\\n        std::fill_n(A_occupancy,n,m);\\n        first_A_row=first_unused_row=0;\\n        numRows=n;\\n        numCols=m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        if(k>numCols) {return{};}\\n        for(int i=first_A_row;i<=maxRow;i++){\\n                \\n            if(A_occupancy[i]>=k){\\n                A_occupancy[i]-=k;\\n                if(i==first_A_row){\\n                    while(A_occupancy[first_A_row]==0 && first_A_row<(numRows-1) ){first_A_row++;}\\n                }\\n                if(i>=first_unused_row) first_unused_row=i+1;\\n                return vector<int>{i,numCols-A_occupancy[i]-k};\\n            }\\n            else{\\n                if(i<first_unused_row && numCols-A_occupancy[i]<=k) {\\n                    i = first_unused_row-1;//as after for 1 will be added\\n                }\\n\\n            }\\n        }\\n        return vector<int>{};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long int max_tot_a1 =0;\\n        long int rem_a2 = 0;\\n        if(first_unused_row<=maxRow){\\n             max_tot_a1 = (long int)(first_unused_row - first_A_row + 1/*for ceil*/ )/2 * numCols;\\n             rem_a2 = (long int)(maxRow - first_unused_row+1 ) * numCols;\\n        }\\n        else{\\n            max_tot_a1 = (long int)(maxRow+1 - first_A_row + 1/*for ceil*/ )/2 * numCols;\\n            if(max_tot_a1<0){\\n                cerr<<\"in scatter... unexpected...\"<<endl;\\n                max_tot_a1 = 0;\\n            }\\n        }\\n        if (max_tot_a1+rem_a2<k) return false; \\n\\n\\n        \\n        int a_seats=0;\\n        for(int i=first_A_row;i<=maxRow;i++){\\n            a_seats+=A_occupancy[i];\\n            if(a_seats>=k) {\\n                A_occupancy[i]=a_seats-k;\\n                first_A_row=i;\\n                while(A_occupancy[first_A_row]==0 && first_A_row<(numRows-1) ){first_A_row++;}\\n                if(i>=first_unused_row) first_unused_row=i+1;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass BookMyShow {\\n    int* A_occupancy;\\n    int numRows, numCols;\\n    int first_A_row;\\n    int first_unused_row;\\npublic:\\n    BookMyShow(int n, int m) {\\n        A_occupancy = new int[n];\\n        std::fill_n(A_occupancy,n,m);\\n        first_A_row=first_unused_row=0;\\n        numRows=n;\\n        numCols=m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        if(k>numCols) {return{};}\\n        for(int i=first_A_row;i<=maxRow;i++){\\n                \\n            if(A_occupancy[i]>=k){\\n                A_occupancy[i]-=k;\\n                if(i==first_A_row){\\n                    while(A_occupancy[first_A_row]==0 && first_A_row<(numRows-1) ){first_A_row++;}\\n                }\\n                if(i>=first_unused_row) first_unused_row=i+1;\\n                return vector<int>{i,numCols-A_occupancy[i]-k};\\n            }\\n            else{\\n                if(i<first_unused_row && numCols-A_occupancy[i]<=k) {\\n                    i = first_unused_row-1;//as after for 1 will be added\\n                }\\n\\n            }\\n        }\\n        return vector<int>{};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long int max_tot_a1 =0;\\n        long int rem_a2 = 0;\\n        if(first_unused_row<=maxRow){\\n             max_tot_a1 = (long int)(first_unused_row - first_A_row + 1/*for ceil*/ )/2 * numCols;\\n             rem_a2 = (long int)(maxRow - first_unused_row+1 ) * numCols;\\n        }\\n        else{\\n            max_tot_a1 = (long int)(maxRow+1 - first_A_row + 1/*for ceil*/ )/2 * numCols;\\n            if(max_tot_a1<0){\\n                cerr<<\"in scatter... unexpected...\"<<endl;\\n                max_tot_a1 = 0;\\n            }\\n        }\\n        if (max_tot_a1+rem_a2<k) return false; \\n\\n\\n        \\n        int a_seats=0;\\n        for(int i=first_A_row;i<=maxRow;i++){\\n            a_seats+=A_occupancy[i];\\n            if(a_seats>=k) {\\n                A_occupancy[i]=a_seats-k;\\n                first_A_row=i;\\n                while(A_occupancy[first_A_row]==0 && first_A_row<(numRows-1) ){first_A_row++;}\\n                if(i>=first_unused_row) first_unused_row=i+1;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845167,
                "title": "golang-segmented-tree",
                "content": "```\\ntype BookMyShow struct {\\n\\trows, seats int\\n\\tstree       []segNode2286\\n}\\n\\ntype segNode2286 struct {\\n\\tmax int\\n\\tsum int\\n}\\n\\nfunc Constructor(rows int, seats int) BookMyShow {\\n\\tsize := 1\\n\\tfor size < rows*2 {\\n\\t\\tsize = size * 2\\n\\t}\\n\\n\\tobj := BookMyShow{rows, seats, make([]segNode2286, size)}\\n\\n\\tobj.build(0, 0, rows-1)\\n\\n\\treturn obj\\n}\\n\\nfunc (this *BookMyShow) build(idx, ldx, rdx int) {\\n\\tif ldx == rdx {\\n\\t\\tthis.stree[idx] = segNode2286{this.seats, this.seats}\\n\\t\\treturn\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\tthis.stree[idx] = segNode2286{this.seats, (rdx - ldx + 1) * this.seats}\\n\\n\\tthis.build(2*idx+1, ldx, mdx)\\n\\tthis.build(2*idx+2, mdx+1, rdx)\\n}\\n\\nfunc (this *BookMyShow) queryMax(idx, ldx, rdx, k, maxRow int) []int {\\n\\tif ldx > maxRow {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tif this.stree[idx].max < k {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tif ldx == rdx {\\n\\t\\treturn []int{ldx, this.seats - this.stree[idx].max}\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\tresult := this.queryMax(2*idx+1, ldx, mdx, k, maxRow)\\n\\tif 0 != len(result) {\\n\\t\\treturn result\\n\\t}\\n\\n\\treturn this.queryMax(2*idx+2, mdx+1, rdx, k, maxRow)\\n}\\n\\nfunc (this *BookMyShow) decreaseMax(idx, ldx, rdx, row, diff int) {\\n\\tif ldx > row || rdx < row {\\n\\t\\treturn\\n\\t}\\n\\n\\tif ldx == rdx {\\n\\t\\tthis.stree[idx].max -= diff\\n\\t\\tthis.stree[idx].sum -= diff\\n\\n\\t\\treturn\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\tthis.stree[idx].sum -= diff\\n\\n\\tthis.decreaseMax(2*idx+1, ldx, mdx, row, diff)\\n\\tthis.decreaseMax(2*idx+2, mdx+1, rdx, row, diff)\\n\\n\\tthis.stree[idx].max = max2286(this.stree[2*idx+1].max, this.stree[2*idx+2].max)\\n}\\n\\nfunc (this *BookMyShow) querySum(idx, ldx, rdx, maxRow int) int {\\n\\tif ldx > maxRow {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif rdx <= maxRow {\\n\\t\\treturn this.stree[idx].sum\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\treturn this.querySum(2*idx+1, ldx, mdx, maxRow) + this.querySum(2*idx+2, mdx+1, rdx, maxRow)\\n}\\n\\nfunc (this *BookMyShow) decreaseSum(idx, ldx, rdx, diff, maxRow int) {\\n\\tif ldx > maxRow {\\n\\t\\treturn\\n\\t}\\n\\n\\tif ldx == rdx {\\n\\t\\tthis.stree[idx].max -= diff\\n\\t\\tthis.stree[idx].sum -= diff\\n\\n\\t\\treturn\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\tthis.stree[idx].sum -= diff\\n\\tif mdx+1 > maxRow || this.stree[2*idx+1].sum >= diff {\\n\\t\\tthis.decreaseSum(2*idx+1, ldx, mdx, diff, maxRow)\\n\\t} else {\\n\\t\\tdiff -= this.stree[2*idx+1].sum\\n\\n\\t\\tthis.decreaseSum(2*idx+1, ldx, mdx, this.stree[2*idx+1].sum, maxRow)\\n\\t\\tthis.decreaseSum(2*idx+2, mdx+1, rdx, diff, maxRow)\\n\\t}\\n\\n\\tthis.stree[idx].max = max2286(this.stree[2*idx+1].max, this.stree[2*idx+2].max)\\n}\\n\\nfunc (this *BookMyShow) Gather(k int, maxRow int) []int {\\n\\tresult := this.queryMax(0, 0, this.rows-1, k, maxRow)\\n\\n\\tif 0 != len(result) {\\n\\t\\tthis.decreaseMax(0, 0, this.rows-1, result[0], k)\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc (this *BookMyShow) Scatter(k int, maxRow int) bool {\\n\\tcnt := this.querySum(0, 0, this.rows-1, maxRow)\\n\\n\\tresult := cnt >= k\\n\\tif result {\\n\\t\\tthis.decreaseSum(0, 0, this.rows-1, k, maxRow)\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc max2286(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype BookMyShow struct {\\n\\trows, seats int\\n\\tstree       []segNode2286\\n}\\n\\ntype segNode2286 struct {\\n\\tmax int\\n\\tsum int\\n}\\n\\nfunc Constructor(rows int, seats int) BookMyShow {\\n\\tsize := 1\\n\\tfor size < rows*2 {\\n\\t\\tsize = size * 2\\n\\t}\\n\\n\\tobj := BookMyShow{rows, seats, make([]segNode2286, size)}\\n\\n\\tobj.build(0, 0, rows-1)\\n\\n\\treturn obj\\n}\\n\\nfunc (this *BookMyShow) build(idx, ldx, rdx int) {\\n\\tif ldx == rdx {\\n\\t\\tthis.stree[idx] = segNode2286{this.seats, this.seats}\\n\\t\\treturn\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\tthis.stree[idx] = segNode2286{this.seats, (rdx - ldx + 1) * this.seats}\\n\\n\\tthis.build(2*idx+1, ldx, mdx)\\n\\tthis.build(2*idx+2, mdx+1, rdx)\\n}\\n\\nfunc (this *BookMyShow) queryMax(idx, ldx, rdx, k, maxRow int) []int {\\n\\tif ldx > maxRow {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tif this.stree[idx].max < k {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tif ldx == rdx {\\n\\t\\treturn []int{ldx, this.seats - this.stree[idx].max}\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\tresult := this.queryMax(2*idx+1, ldx, mdx, k, maxRow)\\n\\tif 0 != len(result) {\\n\\t\\treturn result\\n\\t}\\n\\n\\treturn this.queryMax(2*idx+2, mdx+1, rdx, k, maxRow)\\n}\\n\\nfunc (this *BookMyShow) decreaseMax(idx, ldx, rdx, row, diff int) {\\n\\tif ldx > row || rdx < row {\\n\\t\\treturn\\n\\t}\\n\\n\\tif ldx == rdx {\\n\\t\\tthis.stree[idx].max -= diff\\n\\t\\tthis.stree[idx].sum -= diff\\n\\n\\t\\treturn\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\tthis.stree[idx].sum -= diff\\n\\n\\tthis.decreaseMax(2*idx+1, ldx, mdx, row, diff)\\n\\tthis.decreaseMax(2*idx+2, mdx+1, rdx, row, diff)\\n\\n\\tthis.stree[idx].max = max2286(this.stree[2*idx+1].max, this.stree[2*idx+2].max)\\n}\\n\\nfunc (this *BookMyShow) querySum(idx, ldx, rdx, maxRow int) int {\\n\\tif ldx > maxRow {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif rdx <= maxRow {\\n\\t\\treturn this.stree[idx].sum\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\treturn this.querySum(2*idx+1, ldx, mdx, maxRow) + this.querySum(2*idx+2, mdx+1, rdx, maxRow)\\n}\\n\\nfunc (this *BookMyShow) decreaseSum(idx, ldx, rdx, diff, maxRow int) {\\n\\tif ldx > maxRow {\\n\\t\\treturn\\n\\t}\\n\\n\\tif ldx == rdx {\\n\\t\\tthis.stree[idx].max -= diff\\n\\t\\tthis.stree[idx].sum -= diff\\n\\n\\t\\treturn\\n\\t}\\n\\n\\tmdx := (ldx + rdx) / 2\\n\\tthis.stree[idx].sum -= diff\\n\\tif mdx+1 > maxRow || this.stree[2*idx+1].sum >= diff {\\n\\t\\tthis.decreaseSum(2*idx+1, ldx, mdx, diff, maxRow)\\n\\t} else {\\n\\t\\tdiff -= this.stree[2*idx+1].sum\\n\\n\\t\\tthis.decreaseSum(2*idx+1, ldx, mdx, this.stree[2*idx+1].sum, maxRow)\\n\\t\\tthis.decreaseSum(2*idx+2, mdx+1, rdx, diff, maxRow)\\n\\t}\\n\\n\\tthis.stree[idx].max = max2286(this.stree[2*idx+1].max, this.stree[2*idx+2].max)\\n}\\n\\nfunc (this *BookMyShow) Gather(k int, maxRow int) []int {\\n\\tresult := this.queryMax(0, 0, this.rows-1, k, maxRow)\\n\\n\\tif 0 != len(result) {\\n\\t\\tthis.decreaseMax(0, 0, this.rows-1, result[0], k)\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc (this *BookMyShow) Scatter(k int, maxRow int) bool {\\n\\tcnt := this.querySum(0, 0, this.rows-1, maxRow)\\n\\n\\tresult := cnt >= k\\n\\tif result {\\n\\t\\tthis.decreaseSum(0, 0, this.rows-1, k, maxRow)\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc max2286(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2534133,
                "title": "python-segment-tree",
                "content": "```\\nclass BookMyShow:\\n    def __init__(self, n: int, m: int):\\n        self.x=defaultdict(int)\\n        self.mi=defaultdict(int)\\n        self.n=n\\n        self.m=m\\n    def gather(self, k: int, r: int) -> List[int]:\\n        ans=[]\\n        n,mm=self.n,self.m\\n        def f(i=0,j=n-1):\\n            if r<i:return\\n            if mm-self.mi[i,j]<k:return\\n            if i==j:\\n                nonlocal ans\\n                ans=[i,self.x[i,j]]\\n                self.x[i,j]+=k\\n                self.mi[i,j]=self.x[i,j]\\n                return\\n            m=(i+j)//2\\n            if mm-self.mi[i,m]>=k:\\n                f(i,m)\\n            else:\\n                f(m+1,j)\\n            if ans!=[]:\\n                self.x[i,j]+=k\\n            self.mi[i,j]=min(self.mi[i,m],self.mi[m+1,j])\\n        f()\\n        return ans\\n    def scatter(self, k: int, r: int) -> bool:\\n        z=0\\n        n,mm=self.n,self.m\\n        def check(i=0,j=n-1):\\n            nonlocal z\\n            if r<i:return\\n            if z>=k:return\\n            if j<=r:\\n                z+=(mm*(j-i+1)-self.x[i,j])\\n                return\\n            m=(i+j)//2\\n            check(i,m)\\n            check(m+1,j)\\n        check()\\n        if z<k:return False\\n        def f(k,i=0,j=n-1):\\n            if r<i:return\\n            if k==0:return\\n            if i==j:\\n                self.x[i,j]+=k\\n                self.mi[i,j]=self.x[i,j]\\n                return\\n            m=(i+j)//2\\n            a=mm*(m-i+1)-self.x[i,m]\\n            self.x[i,j]+=k\\n            f(min(k,a),i,m)\\n            f(k-min(k,a),m+1,j)\\n            self.mi[i,j]=min(self.mi[i,m],self.mi[m+1,j])\\n        f(k)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow:\\n    def __init__(self, n: int, m: int):\\n        self.x=defaultdict(int)\\n        self.mi=defaultdict(int)\\n        self.n=n\\n        self.m=m\\n    def gather(self, k: int, r: int) -> List[int]:\\n        ans=[]\\n        n,mm=self.n,self.m\\n        def f(i=0,j=n-1):\\n            if r<i:return\\n            if mm-self.mi[i,j]<k:return\\n            if i==j:\\n                nonlocal ans\\n                ans=[i,self.x[i,j]]\\n                self.x[i,j]+=k\\n                self.mi[i,j]=self.x[i,j]\\n                return\\n            m=(i+j)//2\\n            if mm-self.mi[i,m]>=k:\\n                f(i,m)\\n            else:\\n                f(m+1,j)\\n            if ans!=[]:\\n                self.x[i,j]+=k\\n            self.mi[i,j]=min(self.mi[i,m],self.mi[m+1,j])\\n        f()\\n        return ans\\n    def scatter(self, k: int, r: int) -> bool:\\n        z=0\\n        n,mm=self.n,self.m\\n        def check(i=0,j=n-1):\\n            nonlocal z\\n            if r<i:return\\n            if z>=k:return\\n            if j<=r:\\n                z+=(mm*(j-i+1)-self.x[i,j])\\n                return\\n            m=(i+j)//2\\n            check(i,m)\\n            check(m+1,j)\\n        check()\\n        if z<k:return False\\n        def f(k,i=0,j=n-1):\\n            if r<i:return\\n            if k==0:return\\n            if i==j:\\n                self.x[i,j]+=k\\n                self.mi[i,j]=self.x[i,j]\\n                return\\n            m=(i+j)//2\\n            a=mm*(m-i+1)-self.x[i,m]\\n            self.x[i,j]+=k\\n            f(min(k,a),i,m)\\n            f(k-min(k,a),m+1,j)\\n            self.mi[i,j]=min(self.mi[i,m],self.mi[m+1,j])\\n        f(k)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509570,
                "title": "square-root-decomposition-based-solution",
                "content": "To calculate for gather function we need to find the first index where we have space for k people. We can keep this count blockwise first, and then search within each block. Similarly for scatter function, we need to find if the sum of spaces until maxRow is sufficient for k people. Sample implementation below:\\n\\n```\\nclass BookMyShow {\\nprivate:\\n    static const int lim = 5e4+5;\\n    static const int blok = 225;\\n    int n, m;\\n    int seats[lim], fastmax[blok], hasanyseat; \\n    long long fastsum[blok];\\npublic:\\n    BookMyShow(int n, int m) {\\n        this->n = n;\\n        this->m = m;\\n        fill(seats, seats+lim, m);\\n        fill(fastmax, fastmax+blok, m);\\n        for(int i=0;i<n;i++) {\\n            fastsum[i/blok] += m;\\n        }\\n        hasanyseat = 0;\\n    }\\n    \\n    void recompute(int blkid) {\\n        fastmax[blkid] = 0;\\n        fastsum[blkid] = 0;\\n        for(int i=blkid*blok;i<min((blkid+1)*blok, n);i++) {\\n            fastmax[blkid] = max(fastmax[blkid], seats[i]);\\n            fastsum[blkid] += seats[i];\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int flim = maxRow/blok;\\n        int row = -1;\\n        for(int i=0;i<=flim;i++) {\\n            if(fastmax[i]>=k) {\\n                for(int j=i*blok;j<min((i+1)*blok, maxRow+1);j++) {\\n                    if(seats[j]>=k) {\\n                        row = j;\\n                        seats[j] -= k;\\n                        recompute(i);\\n                        break;\\n                    }\\n                }\\n                if(row!=-1) {\\n                    break;\\n                }\\n            }\\n        }\\n        if(row==-1) {\\n            return vector<int>();\\n        }\\n        return vector<int>{row, m-seats[row]-k};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long avail = 0;\\n        for(int i=0;i<maxRow/blok;i++) {\\n            avail += fastsum[i];\\n        }\\n        for(int i=maxRow/blok*blok;i<=maxRow;i++) {\\n            avail += seats[i];\\n        }\\n        if(avail<k) {\\n            return false;\\n        }\\n        \\n        unordered_set<int> bloks_impacted;\\n        while(k>0) {\\n            int alloc = min(k, seats[hasanyseat]);\\n            seats[hasanyseat] -= alloc;\\n            k -= alloc;\\n            bloks_impacted.insert(hasanyseat/blok);\\n            if(seats[hasanyseat]==0) {\\n                hasanyseat++;\\n            }\\n        }\\n        for(int blok:bloks_impacted) {\\n            recompute(blok);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\nprivate:\\n    static const int lim = 5e4+5;\\n    static const int blok = 225;\\n    int n, m;\\n    int seats[lim], fastmax[blok], hasanyseat; \\n    long long fastsum[blok];\\npublic:\\n    BookMyShow(int n, int m) {\\n        this->n = n;\\n        this->m = m;\\n        fill(seats, seats+lim, m);\\n        fill(fastmax, fastmax+blok, m);\\n        for(int i=0;i<n;i++) {\\n            fastsum[i/blok] += m;\\n        }\\n        hasanyseat = 0;\\n    }\\n    \\n    void recompute(int blkid) {\\n        fastmax[blkid] = 0;\\n        fastsum[blkid] = 0;\\n        for(int i=blkid*blok;i<min((blkid+1)*blok, n);i++) {\\n            fastmax[blkid] = max(fastmax[blkid], seats[i]);\\n            fastsum[blkid] += seats[i];\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int flim = maxRow/blok;\\n        int row = -1;\\n        for(int i=0;i<=flim;i++) {\\n            if(fastmax[i]>=k) {\\n                for(int j=i*blok;j<min((i+1)*blok, maxRow+1);j++) {\\n                    if(seats[j]>=k) {\\n                        row = j;\\n                        seats[j] -= k;\\n                        recompute(i);\\n                        break;\\n                    }\\n                }\\n                if(row!=-1) {\\n                    break;\\n                }\\n            }\\n        }\\n        if(row==-1) {\\n            return vector<int>();\\n        }\\n        return vector<int>{row, m-seats[row]-k};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long avail = 0;\\n        for(int i=0;i<maxRow/blok;i++) {\\n            avail += fastsum[i];\\n        }\\n        for(int i=maxRow/blok*blok;i<=maxRow;i++) {\\n            avail += seats[i];\\n        }\\n        if(avail<k) {\\n            return false;\\n        }\\n        \\n        unordered_set<int> bloks_impacted;\\n        while(k>0) {\\n            int alloc = min(k, seats[hasanyseat]);\\n            seats[hasanyseat] -= alloc;\\n            k -= alloc;\\n            bloks_impacted.insert(hasanyseat/blok);\\n            if(seats[hasanyseat]==0) {\\n                hasanyseat++;\\n            }\\n        }\\n        for(int blok:bloks_impacted) {\\n            recompute(blok);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446362,
                "title": "python3-segment-tree",
                "content": "\\n```\\nclass SegTree: \\n\\n    def __init__(self, arr: List[int]): \\n        \"\"\"Build the segmentation tree.\"\"\"\\n        self.n = n = len(arr)\\n        self.mtree = [0]*(4*n) # for max \\n        self.stree = [0]*(4*n) # for sum \\n        self._build(arr, 0, 0, n)\\n\\n    def _build(self, arr: List[int], k: int, lo: int, hi: int) -> None: \\n        \"\"\"Build segment tree from array.\"\"\"\\n        if lo+1 == hi: \\n            self.mtree[k] = self.stree[k] = arr[lo]\\n            return \\n        mid = lo + hi >> 1\\n        self._build(arr, 2*k+1, lo, mid)\\n        self._build(arr, 2*k+2, mid, hi)\\n        self.mtree[k] = max(self.mtree[2*k+1], self.mtree[2*k+2])\\n        self.stree[k] = self.stree[2*k+1] + self.stree[2*k+2]\\n\\n    def update(self, i: int, delta: int, k: int = 0, lo: int = 0, hi: int = 0) -> None:\\n        \"\"\"Update segment tree when array value at i is incresed by delta.\"\"\"\\n        if lo+1 == hi: # leaf node\\n            self.mtree[k] += delta\\n            self.stree[k] += delta\\n            return \\n        mid = lo + hi >> 1\\n        if i < mid: self.update(i, delta, 2*k+1, lo, mid) \\n        else: self.update(i, delta, 2*k+2, mid, hi)\\n        self.mtree[k] = max(self.mtree[2*k+1], self.mtree[2*k+2])\\n        self.stree[k] = self.stree[2*k+1] + self.stree[2*k+2]\\n\\n    def query_max(self, qlo: int, qhi: int, k, lo, hi, val) -> int: \\n        \"\"\"Query max value from qlo (inclusive) and qhi (exclusive).\"\"\"\\n        if qhi <= lo or  hi <= qlo: return -1\\n        if qlo <= lo and hi <= qhi: \\n            if self.mtree[k] < val: return -1 \\n            while lo+1 < hi: \\n                mid = lo + hi >> 1\\n                if self.mtree[2*k+1] >= val: \\n                    k = 2*k+1\\n                    hi = mid\\n                else: \\n                    k = 2*k+2\\n                    lo = mid\\n            return lo\\n        mid = lo + hi >> 1\\n        ans = self.query_max(qlo, qhi, 2*k+1, lo, mid, val)\\n        if ans != -1: return ans \\n        return self.query_max(qlo, qhi, 2*k+2, mid, hi, val)\\n    \\n    def query_sum(self, qlo: int, qhi: int, k: int = 0, lo: int = 0, hi: int = 0, val = 0) -> int: \\n        \"\"\"Query sum value from qlo (inclusive) and qhi (exclusive).\"\"\"\\n        if qhi <= lo or  hi <= qlo: return 0\\n        if qlo <= lo and hi <= qhi: return self.stree[k]\\n        mid = lo + hi >> 1\\n        return self.query_sum(qlo, qhi, 2*k+1, lo, mid) + self.query_sum(qlo, qhi, 2*k+2, mid, hi)\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.i = 0 \\n        self.n = n\\n        self.m = m\\n        self.seats = [m]*n\\n        self.tree = SegTree(self.seats)\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        lo = self.tree.query_max(self.i, maxRow+1, 0, 0, self.n, k)\\n        if lo == -1: return []\\n        ans = [lo, self.m - self.seats[lo]]\\n        self.seats[lo] -= k \\n        self.tree.update(lo, -k, 0, 0, self.n)\\n        if lo == self.i and self.seats[lo] == 0: self.i += 1\\n        return ans \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        avail = self.tree.query_sum(self.i, maxRow+1, 0, 0, self.n)\\n        if avail < k: return False \\n        lo, hi = self.i, maxRow\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            y = self.tree.query_sum(self.i, mid+1, 0, 0, self.n)\\n            if y < k: lo = mid + 1\\n            else: hi = mid \\n        k -= self.tree.query_sum(self.i, lo, 0, 0, self.n)\\n        self.seats[lo] -= k \\n        self.tree.update(lo, -k, 0, 0, self.n)\\n        self.i = lo\\n        if not self.seats[lo]: self.i += 1\\n        return True \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SegTree: \\n\\n    def __init__(self, arr: List[int]): \\n        \"\"\"Build the segmentation tree.\"\"\"\\n        self.n = n = len(arr)\\n        self.mtree = [0]*(4*n) # for max \\n        self.stree = [0]*(4*n) # for sum \\n        self._build(arr, 0, 0, n)\\n\\n    def _build(self, arr: List[int], k: int, lo: int, hi: int) -> None: \\n        \"\"\"Build segment tree from array.\"\"\"\\n        if lo+1 == hi: \\n            self.mtree[k] = self.stree[k] = arr[lo]\\n            return \\n        mid = lo + hi >> 1\\n        self._build(arr, 2*k+1, lo, mid)\\n        self._build(arr, 2*k+2, mid, hi)\\n        self.mtree[k] = max(self.mtree[2*k+1], self.mtree[2*k+2])\\n        self.stree[k] = self.stree[2*k+1] + self.stree[2*k+2]\\n\\n    def update(self, i: int, delta: int, k: int = 0, lo: int = 0, hi: int = 0) -> None:\\n        \"\"\"Update segment tree when array value at i is incresed by delta.\"\"\"\\n        if lo+1 == hi: # leaf node\\n            self.mtree[k] += delta\\n            self.stree[k] += delta\\n            return \\n        mid = lo + hi >> 1\\n        if i < mid: self.update(i, delta, 2*k+1, lo, mid) \\n        else: self.update(i, delta, 2*k+2, mid, hi)\\n        self.mtree[k] = max(self.mtree[2*k+1], self.mtree[2*k+2])\\n        self.stree[k] = self.stree[2*k+1] + self.stree[2*k+2]\\n\\n    def query_max(self, qlo: int, qhi: int, k, lo, hi, val) -> int: \\n        \"\"\"Query max value from qlo (inclusive) and qhi (exclusive).\"\"\"\\n        if qhi <= lo or  hi <= qlo: return -1\\n        if qlo <= lo and hi <= qhi: \\n            if self.mtree[k] < val: return -1 \\n            while lo+1 < hi: \\n                mid = lo + hi >> 1\\n                if self.mtree[2*k+1] >= val: \\n                    k = 2*k+1\\n                    hi = mid\\n                else: \\n                    k = 2*k+2\\n                    lo = mid\\n            return lo\\n        mid = lo + hi >> 1\\n        ans = self.query_max(qlo, qhi, 2*k+1, lo, mid, val)\\n        if ans != -1: return ans \\n        return self.query_max(qlo, qhi, 2*k+2, mid, hi, val)\\n    \\n    def query_sum(self, qlo: int, qhi: int, k: int = 0, lo: int = 0, hi: int = 0, val = 0) -> int: \\n        \"\"\"Query sum value from qlo (inclusive) and qhi (exclusive).\"\"\"\\n        if qhi <= lo or  hi <= qlo: return 0\\n        if qlo <= lo and hi <= qhi: return self.stree[k]\\n        mid = lo + hi >> 1\\n        return self.query_sum(qlo, qhi, 2*k+1, lo, mid) + self.query_sum(qlo, qhi, 2*k+2, mid, hi)\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.i = 0 \\n        self.n = n\\n        self.m = m\\n        self.seats = [m]*n\\n        self.tree = SegTree(self.seats)\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        lo = self.tree.query_max(self.i, maxRow+1, 0, 0, self.n, k)\\n        if lo == -1: return []\\n        ans = [lo, self.m - self.seats[lo]]\\n        self.seats[lo] -= k \\n        self.tree.update(lo, -k, 0, 0, self.n)\\n        if lo == self.i and self.seats[lo] == 0: self.i += 1\\n        return ans \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        avail = self.tree.query_sum(self.i, maxRow+1, 0, 0, self.n)\\n        if avail < k: return False \\n        lo, hi = self.i, maxRow\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            y = self.tree.query_sum(self.i, mid+1, 0, 0, self.n)\\n            if y < k: lo = mid + 1\\n            else: hi = mid \\n        k -= self.tree.query_sum(self.i, lo, 0, 0, self.n)\\n        self.seats[lo] -= k \\n        self.tree.update(lo, -k, 0, 0, self.n)\\n        self.i = lo\\n        if not self.seats[lo]: self.i += 1\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369706,
                "title": "runtime-5699-ms-it-is-not-quick-but-it-use-segment-tree",
                "content": "```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m=m\\n        self.n=n\\n        cur_list=[m for _ in range(n)]\\n        dim_sum=[[] for _ in range(n*4)]\\n        self.cur=0\\n        \\n        def build(ids,l,r):\\n            if l==r:\\n                dim_sum[ids]=[cur_list[l],cur_list[l]]\\n                return\\n            m=(l+r)//2\\n            build(ids*2,l,m)\\n            build(ids*2+1,m+1,r)\\n            dim_sum[ids]=[dim_sum[ids*2][0]+dim_sum[ids*2+1][0],max(dim_sum[ids*2][1],dim_sum[ids*2+1][1])]\\n        build(1,0,n-1)\\n        self.dim_sum=dim_sum\\n        \\n    def update_sum1(self,ids,l,r,u,v,val):\\n        if v<l or r<u or u>v:\\n            return\\n        if l==r:\\n            self.dim_sum[ids]=[val,val]\\n            return\\n        m=(l+r)//2\\n        self.update_sum1(ids*2,l,m,u,v,val)\\n        self.update_sum1(ids*2+1,m+1,r,u,v,val) \\n        self.dim_sum[ids]=[self.dim_sum[ids*2][0]+self.dim_sum[ids*2+1][0],max(self.dim_sum[ids*2][1],self.dim_sum[ids*2+1][1])]\\n    \\n        \\n        \\n    def query_sum(self, ids,l,r,kk):\\n        if l==r:\\n            return l,self.dim_sum[ids][0]-kk\\n        m=(l+r)//2\\n        if self.dim_sum[ids*2][0]>=kk:\\n            return self.query_sum(ids*2,l,m,kk)\\n        else:\\n            kk-=self.dim_sum[ids*2][0]\\n            return self.query_sum(ids*2+1,m+1,r,kk)\\n        \\n    \\n    def query_max(self, ids,l,r,kk):\\n        if l==r:\\n            return l,self.dim_sum[ids][1]-kk\\n        m=(l+r)//2\\n        if self.dim_sum[ids*2][1]>=kk:\\n            return self.query_max(ids*2,l,m,kk)\\n        else:\\n            return self.query_max(ids*2+1,m+1,r,kk)\\n    \\n    \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        a,b=self.query_max(1,0,self.n-1,k)\\n        if a<=maxRow and b>=0:\\n            self.update_sum1(1,0,self.n-1,a,a,b)\\n            return [a,self.m-b-k]\\n        return []\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        a,b=self.query_sum(1,0,self.n-1,k)\\n        if a<=maxRow and b>=0:\\n            self.update_sum1(1,0,self.n-1,a,a,b)\\n            self.update_sum1(1,0,self.n-1,self.cur,a-1,0)\\n            if a-1>self.cur:\\n                self.cur=a-1\\n            return True\\n        return False\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m=m\\n        self.n=n\\n        cur_list=[m for _ in range(n)]\\n        dim_sum=[[] for _ in range(n*4)]\\n        self.cur=0\\n        \\n        def build(ids,l,r):\\n            if l==r:\\n                dim_sum[ids]=[cur_list[l],cur_list[l]]\\n                return\\n            m=(l+r)//2\\n            build(ids*2,l,m)\\n            build(ids*2+1,m+1,r)\\n            dim_sum[ids]=[dim_sum[ids*2][0]+dim_sum[ids*2+1][0],max(dim_sum[ids*2][1],dim_sum[ids*2+1][1])]\\n        build(1,0,n-1)\\n        self.dim_sum=dim_sum\\n        \\n    def update_sum1(self,ids,l,r,u,v,val):\\n        if v<l or r<u or u>v:\\n            return\\n        if l==r:\\n            self.dim_sum[ids]=[val,val]\\n            return\\n        m=(l+r)//2\\n        self.update_sum1(ids*2,l,m,u,v,val)\\n        self.update_sum1(ids*2+1,m+1,r,u,v,val) \\n        self.dim_sum[ids]=[self.dim_sum[ids*2][0]+self.dim_sum[ids*2+1][0],max(self.dim_sum[ids*2][1],self.dim_sum[ids*2+1][1])]\\n    \\n        \\n        \\n    def query_sum(self, ids,l,r,kk):\\n        if l==r:\\n            return l,self.dim_sum[ids][0]-kk\\n        m=(l+r)//2\\n        if self.dim_sum[ids*2][0]>=kk:\\n            return self.query_sum(ids*2,l,m,kk)\\n        else:\\n            kk-=self.dim_sum[ids*2][0]\\n            return self.query_sum(ids*2+1,m+1,r,kk)\\n        \\n    \\n    def query_max(self, ids,l,r,kk):\\n        if l==r:\\n            return l,self.dim_sum[ids][1]-kk\\n        m=(l+r)//2\\n        if self.dim_sum[ids*2][1]>=kk:\\n            return self.query_max(ids*2,l,m,kk)\\n        else:\\n            return self.query_max(ids*2+1,m+1,r,kk)\\n    \\n    \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        a,b=self.query_max(1,0,self.n-1,k)\\n        if a<=maxRow and b>=0:\\n            self.update_sum1(1,0,self.n-1,a,a,b)\\n            return [a,self.m-b-k]\\n        return []\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        a,b=self.query_sum(1,0,self.n-1,k)\\n        if a<=maxRow and b>=0:\\n            self.update_sum1(1,0,self.n-1,a,a,b)\\n            self.update_sum1(1,0,self.n-1,self.cur,a-1,0)\\n            if a-1>self.cur:\\n                self.cur=a-1\\n            return True\\n        return False\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347047,
                "title": "rust-segment-tree-with-vector-implementation",
                "content": "~~~\\nstruct BookMyShow {\\n    // (maxLength, total)\\n    tree: Vec<(i32, i64)>,\\n    m: usize,\\n    n: usize,\\n}\\n\\nimpl BookMyShow {\\n\\n    fn new(n: i32, m: i32) -> Self {\\n        let mut temp: Vec<(i32, i64)> = vec![(0, 0); 4 * n as usize];\\n        Self::build(1, 0, n as usize - 1, &mut temp, m as usize);\\n        BookMyShow {tree: temp, m: m as usize, n: n as usize}\\n    }\\n    \\n    fn gather(&mut self, k: i32, max_row: i32) -> Vec<i32> {\\n        self.gather_detail(1, 0, self.n - 1, k, max_row as usize)\\n    }\\n    \\n    fn gather_detail(&mut self, u: usize, left: usize, right: usize, k: i32, max_row: usize) -> Vec<i32> {\\n        if left > max_row || self.tree[u].0 < k { return vec![] }\\n        \\n        if left == right {\\n            self.tree[u].0 -= k;\\n            self.tree[u].1 -= k as i64;\\n            return vec![left as i32, self.m as i32 - self.tree[u].0 - k]\\n        }\\n        \\n        let ret: Vec<i32>; \\n        let mid = left + (right - left) / 2;\\n        if self.tree[2 * u].0 >= k {\\n            ret = self.gather_detail(2 * u, left, mid, k, max_row);\\n        } else {\\n            ret = self.gather_detail(2 * u + 1, mid + 1, right, k, max_row);\\n        }\\n        \\n        self.tree[u].0 = self.tree[2 * u].0.max(self.tree[2 * u + 1].0);\\n        self.tree[u].1 = self.tree[2 * u].1 + self.tree[2 * u + 1].1;\\n        ret\\n    }\\n    \\n    fn scatter(&mut self, k: i32, max_row: i32) -> bool {\\n        if self.check(1, 0, self.n - 1, k, max_row as usize) == false { return false }\\n        self.scatter_detail(1, 0, self.n - 1, k);\\n        true\\n    }\\n    \\n    fn check(&self, u: usize, left: usize, right: usize, k: i32, max_row: usize) -> bool {\\n        if left > max_row || self.tree[u].1 < k as i64 { return false }\\n        if left == right { return true }\\n        \\n        let mid = left + (right - left) / 2;\\n        if mid + 1 > max_row { return self.check(2 * u, left, mid, k, max_row) }\\n        \\n        if k as i64 <= self.tree[2 * u].1 { return true }\\n        self.check(2 * u + 1, mid + 1, right, k - self.tree[2 * u].1 as i32, max_row)\\n    }\\n    \\n    fn scatter_detail(&mut self, u: usize, left: usize, right: usize, k: i32) {\\n        if left == right {\\n            self.tree[u].0 -= k;\\n            self.tree[u].1 -= k as i64;\\n            return\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n        let remaining = k as i64 - self.tree[2 * u].1;\\n        self.scatter_detail(2 * u, left, mid, self.tree[2 * u].1.min(k as i64) as i32);\\n        if remaining > 0 { self.scatter_detail(2 * u + 1, mid + 1, right, remaining as i32); }\\n        \\n        self.tree[u].0 = i32::max(self.tree[2 * u].0, self.tree[2 * u + 1].0);\\n        self.tree[u].1 = self.tree[2 * u].1 + self.tree[2 * u + 1].1;\\n    }\\n    \\n    fn build(u: usize, left: usize, right: usize, v: &mut Vec<(i32, i64)>, m: usize) {\\n        if left == right {\\n            v[u] = (m as i32, m as i64);\\n            return\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n        Self::build(2 * u, left, mid, v, m);\\n        Self::build(2 * u + 1, mid + 1, right, v, m);\\n        \\n        let a = v[2 * u].0.max(v[2 * u + 1].0);\\n        let b = v[2 * u].1 + v[2 * u + 1].1;\\n        v[u] = (a, b);\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Tree"
                ],
                "code": "~~~\\nstruct BookMyShow {\\n    // (maxLength, total)\\n    tree: Vec<(i32, i64)>,\\n    m: usize,\\n    n: usize,\\n}\\n\\nimpl BookMyShow {\\n\\n    fn new(n: i32, m: i32) -> Self {\\n        let mut temp: Vec<(i32, i64)> = vec![(0, 0); 4 * n as usize];\\n        Self::build(1, 0, n as usize - 1, &mut temp, m as usize);\\n        BookMyShow {tree: temp, m: m as usize, n: n as usize}\\n    }\\n    \\n    fn gather(&mut self, k: i32, max_row: i32) -> Vec<i32> {\\n        self.gather_detail(1, 0, self.n - 1, k, max_row as usize)\\n    }\\n    \\n    fn gather_detail(&mut self, u: usize, left: usize, right: usize, k: i32, max_row: usize) -> Vec<i32> {\\n        if left > max_row || self.tree[u].0 < k { return vec![] }\\n        \\n        if left == right {\\n            self.tree[u].0 -= k;\\n            self.tree[u].1 -= k as i64;\\n            return vec![left as i32, self.m as i32 - self.tree[u].0 - k]\\n        }\\n        \\n        let ret: Vec<i32>; \\n        let mid = left + (right - left) / 2;\\n        if self.tree[2 * u].0 >= k {\\n            ret = self.gather_detail(2 * u, left, mid, k, max_row);\\n        } else {\\n            ret = self.gather_detail(2 * u + 1, mid + 1, right, k, max_row);\\n        }\\n        \\n        self.tree[u].0 = self.tree[2 * u].0.max(self.tree[2 * u + 1].0);\\n        self.tree[u].1 = self.tree[2 * u].1 + self.tree[2 * u + 1].1;\\n        ret\\n    }\\n    \\n    fn scatter(&mut self, k: i32, max_row: i32) -> bool {\\n        if self.check(1, 0, self.n - 1, k, max_row as usize) == false { return false }\\n        self.scatter_detail(1, 0, self.n - 1, k);\\n        true\\n    }\\n    \\n    fn check(&self, u: usize, left: usize, right: usize, k: i32, max_row: usize) -> bool {\\n        if left > max_row || self.tree[u].1 < k as i64 { return false }\\n        if left == right { return true }\\n        \\n        let mid = left + (right - left) / 2;\\n        if mid + 1 > max_row { return self.check(2 * u, left, mid, k, max_row) }\\n        \\n        if k as i64 <= self.tree[2 * u].1 { return true }\\n        self.check(2 * u + 1, mid + 1, right, k - self.tree[2 * u].1 as i32, max_row)\\n    }\\n    \\n    fn scatter_detail(&mut self, u: usize, left: usize, right: usize, k: i32) {\\n        if left == right {\\n            self.tree[u].0 -= k;\\n            self.tree[u].1 -= k as i64;\\n            return\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n        let remaining = k as i64 - self.tree[2 * u].1;\\n        self.scatter_detail(2 * u, left, mid, self.tree[2 * u].1.min(k as i64) as i32);\\n        if remaining > 0 { self.scatter_detail(2 * u + 1, mid + 1, right, remaining as i32); }\\n        \\n        self.tree[u].0 = i32::max(self.tree[2 * u].0, self.tree[2 * u + 1].0);\\n        self.tree[u].1 = self.tree[2 * u].1 + self.tree[2 * u + 1].1;\\n    }\\n    \\n    fn build(u: usize, left: usize, right: usize, v: &mut Vec<(i32, i64)>, m: usize) {\\n        if left == right {\\n            v[u] = (m as i32, m as i64);\\n            return\\n        }\\n        \\n        let mid = left + (right - left) / 2;\\n        Self::build(2 * u, left, mid, v, m);\\n        Self::build(2 * u + 1, mid + 1, right, v, m);\\n        \\n        let a = v[2 * u].0.max(v[2 * u + 1].0);\\n        let b = v[2 * u].1 + v[2 * u + 1].1;\\n        v[u] = (a, b);\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2330910,
                "title": "c-segment-tree-explained",
                "content": "Tips:\\n\\n1.First, we build a segment tree with empty arr[n], n is rows, m is seats; SegmentTree should support SumRange(), MinRange() APIs, so SegmentNode should contains sum, min fields. \\n2.Gather(k, maxRow) - we should find the min of arr[i] in range [0,maxRow], if min + k > seats, we cannot gather.\\n   If we can gather, find the minimal index of arr[i] that arr[i]+k<=seats, then update the value.\\n3.Scatter(k, maxRow), - we should get the sum in range [0,maxRow], if sum+k >(maxRow+1)* seats, return false.\\n   If we can scatter, do recursion scatter and always try scatter on leftNode first as many as possible , then right node if still not enough.\\n4.Gather() and Scatte() should both call in [0,n-1] due to we need update the whole segment tree; \\n\\n```\\n    public class BookMyShow\\n    {\\n        private readonly SegmentTree root;\\n        private readonly int seats;\\n        private readonly int rows;\\n        public BookMyShow(int n, int m)\\n        {\\n            rows = n;\\n            seats = m;\\n            int[] arr = new int[n];\\n            root = new SegmentTree(arr);\\n        }\\n        public int[] Gather(int k, int maxRow)\\n        {\\n            if (root.MinRange(0, maxRow) + k > seats) return new int[] { };//no possible\\n            else return root.Gather(0, rows-1, k, seats);\\n        }\\n        public bool Scatter(int k, int maxRow)\\n        {\\n            long total = root.SumRange(0, maxRow);\\n            if (total + k > (maxRow + 1) * (long)seats) return false;//no possible\\n            root.Scatter(0, rows - 1, k, seats);\\n            return true;\\n        }\\n    }\\n    public class SegmentNode\\n    {\\n        public int start,end;\\n        public SegmentNode left;\\n        public SegmentNode right;\\n        public long sum;\\n        public int max,min;\\n        public SegmentNode(int start, int end)\\n        {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    public class SegmentTree\\n    {\\n        public SegmentNode root=null;\\n        public SegmentTree(int[] nums)\\n        {\\n            Build(nums, 0, nums.Length - 1);\\n        }\\n        public void Build(int[] nums,int start,int end)\\n        {\\n            this.root = buildInternal(nums, start, end);\\n        }\\n        private SegmentNode buildInternal(int[] nums, int start, int end)\\n        {\\n            if (start > end) return null;\\n            var node = new SegmentNode(start, end);\\n            if(start == end)\\n            {\\n                node.sum = nums[start];\\n                node.min = nums[start];\\n            }\\n            else\\n            {\\n                int mid = start + (end - start)/2;\\n                node.left = buildInternal(nums, start, mid);\\n                node.right = buildInternal(nums, mid+1, end);\\n                node.sum = node.left.sum + node.right.sum;\\n                node.min = Math.Min(node.left.min, node.right.min);\\n            }\\n            return node;\\n        }\\n        public void Update(int index,int val)\\n        {\\n            updateInternal(root, index, val);\\n        }\\n        private void updateInternal(SegmentNode node, int index ,int val)\\n        {\\n            if (node == null) return;\\n            if(index>=node.start && index <= node.end)\\n            {\\n                if(node.start == node.end)\\n                {\\n                    node.sum = val;\\n                    node.min = val;\\n                }\\n                else\\n                {\\n                    int mid = node.start + ( node.end - node.start) / 2;\\n                    if (index <= mid) updateInternal(node.left, index, val);\\n                    else  updateInternal(node.right, index, val);\\n                    node.sum = node.left.sum + node.right.sum;\\n                    node.min = Math.Min(node.left.min, node.right.min);\\n                }\\n            }\\n        }\\n        public long SumRange(int left,int right)\\n        {\\n            return sumRangeInternal(root, left, right);\\n        }\\n        private long sumRangeInternal(SegmentNode node, int left,int right)\\n        {\\n            if (node == null) return 0;\\n            if (node.start > right || node.end < left) return 0;\\n            if(node.start == left && node.end == right)\\n            {\\n                return node.sum;\\n            }\\n            else\\n            {\\n                int mid = node.start + (node.end - node.start) / 2;\\n                if (mid < left) return sumRangeInternal(node.right, left, right);\\n                else if(mid>= right) return sumRangeInternal(node.left, left, right);\\n                else\\n                    return sumRangeInternal(node.left, left, mid) + sumRangeInternal(node.right, mid+1, right);\\n            }\\n        }\\n        public int MinRange(int left, int right)\\n        {\\n            return minRangeInternal(root, left, right);\\n        }\\n        private int minRangeInternal(SegmentNode node, int left, int right)\\n        {\\n            if (node == null) return int.MaxValue;\\n            if (node.start > right || node.end < left) return int.MaxValue;\\n            if (node.start == left && node.end == right)\\n            {\\n                return node.min;\\n            }\\n            else\\n            {\\n                int mid = node.start + (node.end - node.start) / 2;\\n                if (mid < left) return minRangeInternal(node.right, left, right);\\n                else if (mid >= right) return minRangeInternal(node.left, left, right);\\n                else\\n                    return Math.Min(minRangeInternal(node.left, left, mid), minRangeInternal(node.right, mid + 1, right));\\n            }\\n        }\\n        public int[] Gather(int left, int right, int val, int m)\\n        {\\n            return gatherInternal(root, left, right, val, m);\\n        }\\n        private int[] gatherInternal(SegmentNode node, int left, int right, int val, int m)\\n        {\\n            if (node == null) return new int[] { };\\n            if (node.start > right || node.end < left) return new int[] { };\\n            if (node.min + val > m) return new int[] { };\\n            if (node.start == node.end)\\n            {\\n                int[] res = new int[] { node.start, (int)node.sum };\\n                node.sum = node.sum + val;\\n                node.min = (int)node.sum;\\n                return res;\\n            }\\n            else\\n            {\\n                int[] res = new int[] { };\\n                if (node.left != null && node.left.min + val <= m)\\n                    res = gatherInternal(node.left, left, right, val, m);\\n                else if (node.right != null && node.right.min + val <= m)\\n                    res = gatherInternal(node.right, left, right, val, m);\\n                node.sum = node.left.sum + node.right.sum;\\n                node.min = Math.Min(node.left.min, node.right.min);\\n                return res;\\n            }\\n        }\\n        public void Scatter(int left, int right, int k, int m)\\n        {\\n            scatterInternal(root, left, right, k, m);\\n        }\\n        private void scatterInternal(SegmentNode node, int left, int right, int k, int m)\\n        {\\n            if (node == null) return;\\n            if (node.start > right || node.end < left) return;\\n            if (node.start == node.end)\\n            {\\n                int diff = Math.Min(k, m - (int)node.sum);\\n                node.sum = node.sum + diff;\\n                node.min = (int)node.sum;\\n            }\\n            else\\n            {\\n                long leftSum = node.left.sum;\\n                long leftDiff = (long)m * (node.left.end - node.left.start + 1) - leftSum;\\n                if (leftDiff >= k)\\n                {\\n                    scatterInternal(node.left, left, right, k, m);\\n                }\\n                else\\n                {\\n                    if (leftDiff > 0)\\n                        scatterInternal(node.left, left, right, (int)leftDiff, m);\\n                    scatterInternal(node.right, left, right, k - (int)leftDiff, m);\\n                }\\n                node.sum = node.left.sum + node.right.sum;\\n                node.min = Math.Min(node.left.min, node.right.min);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class BookMyShow\\n    {\\n        private readonly SegmentTree root;\\n        private readonly int seats;\\n        private readonly int rows;\\n        public BookMyShow(int n, int m)\\n        {\\n            rows = n;\\n            seats = m;\\n            int[] arr = new int[n];\\n            root = new SegmentTree(arr);\\n        }\\n        public int[] Gather(int k, int maxRow)\\n        {\\n            if (root.MinRange(0, maxRow) + k > seats) return new int[] { };//no possible\\n            else return root.Gather(0, rows-1, k, seats);\\n        }\\n        public bool Scatter(int k, int maxRow)\\n        {\\n            long total = root.SumRange(0, maxRow);\\n            if (total + k > (maxRow + 1) * (long)seats) return false;//no possible\\n            root.Scatter(0, rows - 1, k, seats);\\n            return true;\\n        }\\n    }\\n    public class SegmentNode\\n    {\\n        public int start,end;\\n        public SegmentNode left;\\n        public SegmentNode right;\\n        public long sum;\\n        public int max,min;\\n        public SegmentNode(int start, int end)\\n        {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    public class SegmentTree\\n    {\\n        public SegmentNode root=null;\\n        public SegmentTree(int[] nums)\\n        {\\n            Build(nums, 0, nums.Length - 1);\\n        }\\n        public void Build(int[] nums,int start,int end)\\n        {\\n            this.root = buildInternal(nums, start, end);\\n        }\\n        private SegmentNode buildInternal(int[] nums, int start, int end)\\n        {\\n            if (start > end) return null;\\n            var node = new SegmentNode(start, end);\\n            if(start == end)\\n            {\\n                node.sum = nums[start];\\n                node.min = nums[start];\\n            }\\n            else\\n            {\\n                int mid = start + (end - start)/2;\\n                node.left = buildInternal(nums, start, mid);\\n                node.right = buildInternal(nums, mid+1, end);\\n                node.sum = node.left.sum + node.right.sum;\\n                node.min = Math.Min(node.left.min, node.right.min);\\n            }\\n            return node;\\n        }\\n        public void Update(int index,int val)\\n        {\\n            updateInternal(root, index, val);\\n        }\\n        private void updateInternal(SegmentNode node, int index ,int val)\\n        {\\n            if (node == null) return;\\n            if(index>=node.start && index <= node.end)\\n            {\\n                if(node.start == node.end)\\n                {\\n                    node.sum = val;\\n                    node.min = val;\\n                }\\n                else\\n                {\\n                    int mid = node.start + ( node.end - node.start) / 2;\\n                    if (index <= mid) updateInternal(node.left, index, val);\\n                    else  updateInternal(node.right, index, val);\\n                    node.sum = node.left.sum + node.right.sum;\\n                    node.min = Math.Min(node.left.min, node.right.min);\\n                }\\n            }\\n        }\\n        public long SumRange(int left,int right)\\n        {\\n            return sumRangeInternal(root, left, right);\\n        }\\n        private long sumRangeInternal(SegmentNode node, int left,int right)\\n        {\\n            if (node == null) return 0;\\n            if (node.start > right || node.end < left) return 0;\\n            if(node.start == left && node.end == right)\\n            {\\n                return node.sum;\\n            }\\n            else\\n            {\\n                int mid = node.start + (node.end - node.start) / 2;\\n                if (mid < left) return sumRangeInternal(node.right, left, right);\\n                else if(mid>= right) return sumRangeInternal(node.left, left, right);\\n                else\\n                    return sumRangeInternal(node.left, left, mid) + sumRangeInternal(node.right, mid+1, right);\\n            }\\n        }\\n        public int MinRange(int left, int right)\\n        {\\n            return minRangeInternal(root, left, right);\\n        }\\n        private int minRangeInternal(SegmentNode node, int left, int right)\\n        {\\n            if (node == null) return int.MaxValue;\\n            if (node.start > right || node.end < left) return int.MaxValue;\\n            if (node.start == left && node.end == right)\\n            {\\n                return node.min;\\n            }\\n            else\\n            {\\n                int mid = node.start + (node.end - node.start) / 2;\\n                if (mid < left) return minRangeInternal(node.right, left, right);\\n                else if (mid >= right) return minRangeInternal(node.left, left, right);\\n                else\\n                    return Math.Min(minRangeInternal(node.left, left, mid), minRangeInternal(node.right, mid + 1, right));\\n            }\\n        }\\n        public int[] Gather(int left, int right, int val, int m)\\n        {\\n            return gatherInternal(root, left, right, val, m);\\n        }\\n        private int[] gatherInternal(SegmentNode node, int left, int right, int val, int m)\\n        {\\n            if (node == null) return new int[] { };\\n            if (node.start > right || node.end < left) return new int[] { };\\n            if (node.min + val > m) return new int[] { };\\n            if (node.start == node.end)\\n            {\\n                int[] res = new int[] { node.start, (int)node.sum };\\n                node.sum = node.sum + val;\\n                node.min = (int)node.sum;\\n                return res;\\n            }\\n            else\\n            {\\n                int[] res = new int[] { };\\n                if (node.left != null && node.left.min + val <= m)\\n                    res = gatherInternal(node.left, left, right, val, m);\\n                else if (node.right != null && node.right.min + val <= m)\\n                    res = gatherInternal(node.right, left, right, val, m);\\n                node.sum = node.left.sum + node.right.sum;\\n                node.min = Math.Min(node.left.min, node.right.min);\\n                return res;\\n            }\\n        }\\n        public void Scatter(int left, int right, int k, int m)\\n        {\\n            scatterInternal(root, left, right, k, m);\\n        }\\n        private void scatterInternal(SegmentNode node, int left, int right, int k, int m)\\n        {\\n            if (node == null) return;\\n            if (node.start > right || node.end < left) return;\\n            if (node.start == node.end)\\n            {\\n                int diff = Math.Min(k, m - (int)node.sum);\\n                node.sum = node.sum + diff;\\n                node.min = (int)node.sum;\\n            }\\n            else\\n            {\\n                long leftSum = node.left.sum;\\n                long leftDiff = (long)m * (node.left.end - node.left.start + 1) - leftSum;\\n                if (leftDiff >= k)\\n                {\\n                    scatterInternal(node.left, left, right, k, m);\\n                }\\n                else\\n                {\\n                    if (leftDiff > 0)\\n                        scatterInternal(node.left, left, right, (int)leftDiff, m);\\n                    scatterInternal(node.right, left, right, k - (int)leftDiff, m);\\n                }\\n                node.sum = node.left.sum + node.right.sum;\\n                node.min = Math.Min(node.left.min, node.right.min);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309292,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n\\n```\\n\\nclass BookMyShow {\\n    int n;\\n    int m;\\n    vector<array<long long, 2>> stree; // segment tree that tracks (max, sum) of each segment\\npublic:\\n    void build(int i, int p, int q) {\\n        if (p == q) {\\n            stree[i] = {m, m};\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i] = {m, (long long)(q-p+1)*m};\\n        build(2*i+1, p, r);\\n        build(2*i+2, r+1, q);\\n    }\\n\\n    vector<int> query_max(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return {};\\n        if (stree[i][0] < k)\\n            return {};\\n        if (p == q)\\n            return {p, (int)(m - stree[i][0])};\\n        int r = (p + q) / 2;\\n        vector<int> ret = query_max(2*i+1, p, r, k, maxRow);\\n        if (ret.size())\\n            return ret;\\n        return query_max(2*i+2, r+1, q, k, maxRow);\\n    }\\n\\n    void update_max(int i, int p, int q, int row, int k) {\\n        if (p > row || q < row)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        update_max(2*i+1, p, r, row, k);\\n        update_max(2*i+2, r+1, q, row, k);\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n    long long query_sum(int i, int p, int q, int maxRow) {\\n        if (p > maxRow)\\n            return 0;\\n        if (q <= maxRow)\\n            return stree[i][1];\\n        int r = (p + q) / 2;\\n        return query_sum(2*i+1, p, r, maxRow) + query_sum(2*i+2, r+1, q, maxRow);\\n    }\\n\\n    void update_sum(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        if (r+1 > maxRow || stree[2*i+1][1] >= k) {\\n            update_sum(2*i+1, p, r, k, maxRow);\\n        } else {\\n            k -= stree[2*i+1][1];\\n            update_sum(2*i+1, p, r, stree[2*i+1][1], maxRow);\\n            // Be aware: stree[2*i+1][1] updates while updating the left tree\\n            update_sum(2*i+2, r+1, q, k, maxRow);\\n        }\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n\\n    BookMyShow(int n_in, int m_in) {\\n        n = n_in;\\n        m = m_in;\\n\\n        int sz = 1;\\n        while (sz < n*2)\\n            sz <<= 1;\\n        stree.resize(sz);\\n\\n        build(0, 0, n-1);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        // cout << \"gather \" << k << \" \" << maxRow << endl;\\n        vector<int> ret = query_max(0, 0, n-1, k, maxRow);\\n        if (ret.size())\\n            update_max(0, 0, n-1, ret[0], k);\\n        return ret;\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        // cout << \"scatter \" << k << \" \" << maxRow << endl;\\n        long long cnt = query_sum(0, 0, n-1, maxRow);\\n        bool ret = cnt >= k;\\n        if (ret)\\n            update_sum(0, 0, n-1, k, maxRow);\\n        return ret;\\n    }\\n};\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\nclass BookMyShow {\\n    int n;\\n    int m;\\n    vector<array<long long, 2>> stree; // segment tree that tracks (max, sum) of each segment\\npublic:\\n    void build(int i, int p, int q) {\\n        if (p == q) {\\n            stree[i] = {m, m};\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i] = {m, (long long)(q-p+1)*m};\\n        build(2*i+1, p, r);\\n        build(2*i+2, r+1, q);\\n    }\\n\\n    vector<int> query_max(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return {};\\n        if (stree[i][0] < k)\\n            return {};\\n        if (p == q)\\n            return {p, (int)(m - stree[i][0])};\\n        int r = (p + q) / 2;\\n        vector<int> ret = query_max(2*i+1, p, r, k, maxRow);\\n        if (ret.size())\\n            return ret;\\n        return query_max(2*i+2, r+1, q, k, maxRow);\\n    }\\n\\n    void update_max(int i, int p, int q, int row, int k) {\\n        if (p > row || q < row)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        update_max(2*i+1, p, r, row, k);\\n        update_max(2*i+2, r+1, q, row, k);\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n    long long query_sum(int i, int p, int q, int maxRow) {\\n        if (p > maxRow)\\n            return 0;\\n        if (q <= maxRow)\\n            return stree[i][1];\\n        int r = (p + q) / 2;\\n        return query_sum(2*i+1, p, r, maxRow) + query_sum(2*i+2, r+1, q, maxRow);\\n    }\\n\\n    void update_sum(int i, int p, int q, int k, int maxRow) {\\n        if (p > maxRow)\\n            return;\\n        if (p == q) {\\n            stree[i][0] -= k;\\n            stree[i][1] -= k;\\n            // cout << p << \" \" << stree[i][0] << endl;\\n            return;\\n        }\\n        int r = (p + q) / 2;\\n        stree[i][1] -= k;\\n        if (r+1 > maxRow || stree[2*i+1][1] >= k) {\\n            update_sum(2*i+1, p, r, k, maxRow);\\n        } else {\\n            k -= stree[2*i+1][1];\\n            update_sum(2*i+1, p, r, stree[2*i+1][1], maxRow);\\n            // Be aware: stree[2*i+1][1] updates while updating the left tree\\n            update_sum(2*i+2, r+1, q, k, maxRow);\\n        }\\n        stree[i][0] = max(stree[2*i+1][0], stree[2*i+2][0]);\\n    }\\n\\n\\n    BookMyShow(int n_in, int m_in) {\\n        n = n_in;\\n        m = m_in;\\n\\n        int sz = 1;\\n        while (sz < n*2)\\n            sz <<= 1;\\n        stree.resize(sz);\\n\\n        build(0, 0, n-1);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        // cout << \"gather \" << k << \" \" << maxRow << endl;\\n        vector<int> ret = query_max(0, 0, n-1, k, maxRow);\\n        if (ret.size())\\n            update_max(0, 0, n-1, ret[0], k);\\n        return ret;\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        // cout << \"scatter \" << k << \" \" << maxRow << endl;\\n        long long cnt = query_sum(0, 0, n-1, maxRow);\\n        bool ret = cnt >= k;\\n        if (ret)\\n            update_sum(0, 0, n-1, k, maxRow);\\n        return ret;\\n    }\\n};\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2287885,
                "title": "segment-tree-binary-search-o-n-logn-scatter-logn-log-2n-gather",
                "content": "Similar to the current top post\\n\\nComplexity in scatter is amortized in ```N*LogN``` with each call costing ```LogN```\\nComplexity in gather for each call is bin search * segment_tree search = ```log^2 N```\\n\\n```cpp\\n# define ll long long\\n\\nstruct segment_tree {\\n    struct node{ll max_avail; ll total_avail; }; \\n    ll levels = 1; \\n    ll alloc = 1;\\n    vector<node> st; \\n    segment_tree(ll n) {\\n        while (alloc < n) {\\n            levels ++;\\n            alloc <<= 1;\\n        };\\n        st.resize(alloc * 2 - 1);\\n    }\\n    \\n    ll GO_UP(ll x) { return (x - 1) / 2; }\\n    ll GO_LEFT(ll x) { return (x * 2) + 1; }\\n    ll GO_RIGHT(ll x) { return (x + 1) * 2; }\\n    \\n    bool segment_A_consumes_B(ll Al, ll Ar, ll Bl, ll Br) { return (Al <= Bl && Ar >= Br);}\\n    bool segment_A_nooverlap_B(ll Al, ll Ar, ll Bl, ll Br) {return (Al > Br || Ar < Bl || Bl > Ar || Br < Al);}\\n    \\n    node reduce(node a, node b) {\\n        return {max(a.max_avail, b.max_avail), a.total_avail + b.total_avail};\\n    }   \\n    \\n    void update(ll index, node val) {\\n        ll ref = (alloc - 1) + (index - 1); \\n        st[ref] = val;\\n        while (ref != 0) {\\n            ll parent = GO_UP(ref);\\n            st[parent] = reduce(st[GO_LEFT(parent)], st[GO_RIGHT(parent)]);\\n            ref = parent;\\n        }\\n    }\\n    \\n    node query(ll lft, ll rht) {return query(lft, rht, 1, alloc, 0);}\\n    node query(ll lft, ll rht, ll plft, ll prht, ll n) {\\n        if (segment_A_consumes_B(lft, rht, plft, prht)) {\\n            return st[n];\\n        }\\n        else if (segment_A_nooverlap_B(lft, rht, plft, prht)) {\\n            return {0, 0};\\n        }\\n        else {\\n            node lsol = query(lft, rht, plft, ((prht - plft) / 2) + plft, GO_LEFT(n));\\n            node rsol = query(lft, rht, ((prht - plft) / 2) + plft + 1, prht, GO_RIGHT(n));\\n            return reduce(lsol, rsol);\\n        }\\n    }\\n};\\n\\n\\nclass BookMyShow {\\npublic:\\n    ll last_row = 1;\\n    ll M; ll N;\\n    segment_tree t = segment_tree(1);\\n    BookMyShow(ll n, ll m) {\\n        M = m; N = n;\\n        t = segment_tree(n + 1);\\n        for (ll i = 1; i <= n + 1; i ++) {\\n            t.update(i, {m, m});\\n        }\\n    }\\n    \\n    vector<int> gather(ll k, ll maxRow) {\\n        ll low = 1; \\n        ll high = maxRow + 1;\\n        while (low < high) {\\n            ll mid = (low + high) / 2;\\n            if (t.query(1, mid).max_avail >= k) {\\n                high = mid;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        if (t.query(1, low).max_avail >= k) {\\n            ll row = low; \\n            ll totalAvail = t.query(low, low).total_avail;\\n            t.update(low, {totalAvail - k, totalAvail - k});\\n            return {(int)low - 1, (int)(M - totalAvail)};\\n        }\\n        else {\\n            return {};\\n        }\\n    }\\n    \\n    bool scatter(ll k, ll maxRow) {\\n        if (t.query(1, maxRow + 1).total_avail >= k) {\\n            while (k != 0) {\\n                ll avail = t.query(last_row, last_row).total_avail;\\n                if (avail > 0) {\\n                    ll new_allocation = min(k, avail);\\n                    k -= new_allocation; \\n                    t.update(last_row, {avail - new_allocation, avail - new_allocation});\\n                }\\n                else {\\n                    last_row ++;\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```N*LogN```\n```LogN```\n```log^2 N```\n```cpp\\n# define ll long long\\n\\nstruct segment_tree {\\n    struct node{ll max_avail; ll total_avail; }; \\n    ll levels = 1; \\n    ll alloc = 1;\\n    vector<node> st; \\n    segment_tree(ll n) {\\n        while (alloc < n) {\\n            levels ++;\\n            alloc <<= 1;\\n        };\\n        st.resize(alloc * 2 - 1);\\n    }\\n    \\n    ll GO_UP(ll x) { return (x - 1) / 2; }\\n    ll GO_LEFT(ll x) { return (x * 2) + 1; }\\n    ll GO_RIGHT(ll x) { return (x + 1) * 2; }\\n    \\n    bool segment_A_consumes_B(ll Al, ll Ar, ll Bl, ll Br) { return (Al <= Bl && Ar >= Br);}\\n    bool segment_A_nooverlap_B(ll Al, ll Ar, ll Bl, ll Br) {return (Al > Br || Ar < Bl || Bl > Ar || Br < Al);}\\n    \\n    node reduce(node a, node b) {\\n        return {max(a.max_avail, b.max_avail), a.total_avail + b.total_avail};\\n    }   \\n    \\n    void update(ll index, node val) {\\n        ll ref = (alloc - 1) + (index - 1); \\n        st[ref] = val;\\n        while (ref != 0) {\\n            ll parent = GO_UP(ref);\\n            st[parent] = reduce(st[GO_LEFT(parent)], st[GO_RIGHT(parent)]);\\n            ref = parent;\\n        }\\n    }\\n    \\n    node query(ll lft, ll rht) {return query(lft, rht, 1, alloc, 0);}\\n    node query(ll lft, ll rht, ll plft, ll prht, ll n) {\\n        if (segment_A_consumes_B(lft, rht, plft, prht)) {\\n            return st[n];\\n        }\\n        else if (segment_A_nooverlap_B(lft, rht, plft, prht)) {\\n            return {0, 0};\\n        }\\n        else {\\n            node lsol = query(lft, rht, plft, ((prht - plft) / 2) + plft, GO_LEFT(n));\\n            node rsol = query(lft, rht, ((prht - plft) / 2) + plft + 1, prht, GO_RIGHT(n));\\n            return reduce(lsol, rsol);\\n        }\\n    }\\n};\\n\\n\\nclass BookMyShow {\\npublic:\\n    ll last_row = 1;\\n    ll M; ll N;\\n    segment_tree t = segment_tree(1);\\n    BookMyShow(ll n, ll m) {\\n        M = m; N = n;\\n        t = segment_tree(n + 1);\\n        for (ll i = 1; i <= n + 1; i ++) {\\n            t.update(i, {m, m});\\n        }\\n    }\\n    \\n    vector<int> gather(ll k, ll maxRow) {\\n        ll low = 1; \\n        ll high = maxRow + 1;\\n        while (low < high) {\\n            ll mid = (low + high) / 2;\\n            if (t.query(1, mid).max_avail >= k) {\\n                high = mid;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        if (t.query(1, low).max_avail >= k) {\\n            ll row = low; \\n            ll totalAvail = t.query(low, low).total_avail;\\n            t.update(low, {totalAvail - k, totalAvail - k});\\n            return {(int)low - 1, (int)(M - totalAvail)};\\n        }\\n        else {\\n            return {};\\n        }\\n    }\\n    \\n    bool scatter(ll k, ll maxRow) {\\n        if (t.query(1, maxRow + 1).total_avail >= k) {\\n            while (k != 0) {\\n                ll avail = t.query(last_row, last_row).total_avail;\\n                if (avail > 0) {\\n                    ll new_allocation = min(k, avail);\\n                    k -= new_allocation; \\n                    t.update(last_row, {avail - new_allocation, avail - new_allocation});\\n                }\\n                else {\\n                    last_row ++;\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220333,
                "title": "simple-binary-tree-not-segment-tree-o-q-log-n-for-q-queries",
                "content": "In other words, start with a list of `n` elements, each equal to `m`.\\n* gather(k,R) returns minimum i<=R such that L[i] >= k.\\n* scatter(k,R) returns minimum i<=R such that sum(L[:i+1]) >= k\\n\\nConsider two binary trees with `n` leaves where each leaf is initialized to `m`.\\n* Tree X (\"max\") internal nodes satisfy X[node] = max(X[node.left], X[node.right]).\\n* Tree K (\"count\") is K[node] = K[node.left] + K[node.right]\\n\\ngather traverses X, starting at the root, preferring left branches, following nodes with X[node] >= k.\\nSimilarly, scatter traverse K, following nodes with K[node] >= k.\\n\\nIf either operation succeeds (reaches a leaf), it retraces the path updating X and K along the way. The maxRow condition could be used to early abort the tree traversal, but it\\'s easier to handle it only when we reach a leaf. I doubt it would make a noticable impact in runtime.\\n\\nscatter is slightly trickier in that if it takes a right branch, it decrements k by X[node.left]. On the way back up, coming up a right branch means K[node.left] needs to be zerod out, which means X[node.left] also needs to be zerod out. This puts the tree in a somewhat inconsistent state (in the interest of speed, zeroizing a node does not recursively zeroize the nodes below it), but that\\'s ok because zeroized nodes will not be entered in future operations.\\n\\n```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.n = n\\n        self.m = m\\n        N = 1<<(n.bit_length() + bool(n&(n-1)))\\n        K = self.K = N*[0]\\n        X = self.X=N*[0]\\n        self.base=N>>1 # indices higher than base are leaves\\n        K[self.base:self.base+n]=n*[m]\\n        X[self.base:self.base+n]=n*[m]\\n        for i in range(self.base-1,0,0):\\n            K[i] = K[2*i] + K[2*i+1]\\n            X[i] = max(X[2*i], X[2*i+1])\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        K = self.K\\n        X=self.X\\n        n=self.base\\n        i=1\\n        if X[1]<k:\\n            return []\\n        while i<n:\\n            if X[2*i] >= k:\\n                i = 2*i\\n            else:\\n                i = 2*i+1\\n        row = i-n\\n        if row > maxRow:\\n            return []\\n        col = self.m - K[i]\\n        X[i] -= k\\n        while i:\\n            K[i] -= k\\n            i >>= 1\\n            X[i] = max(X[2*i], X[2*i+1])\\n        X[0] = 0\\n        return [row, col]\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        K = self.K\\n        X=self.X\\n        n=self.base\\n        i=1\\n        if K[1]<k:\\n            return False\\n        while i<n:\\n            if K[2*i] >= k:\\n                i = 2*i\\n            else:\\n                k -= K[2*i]\\n                i = 2*i+1\\n        row = i-n\\n        if row > maxRow:\\n            return False\\n        K[i] -= k\\n        X[i] = K[i]\\n        while i:\\n            from_right = i & 1\\n            i >>= 1\\n            if not i:\\n                break\\n            if from_right:\\n                K[2*i] = X[2*i] = 0\\n            K[i] = K[2*i] + K[2*i+1]\\n            X[i] = max(X[2*i], X[2*i+1])\\n        X[0] = 0\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.n = n\\n        self.m = m\\n        N = 1<<(n.bit_length() + bool(n&(n-1)))\\n        K = self.K = N*[0]\\n        X = self.X=N*[0]\\n        self.base=N>>1 # indices higher than base are leaves\\n        K[self.base:self.base+n]=n*[m]\\n        X[self.base:self.base+n]=n*[m]\\n        for i in range(self.base-1,0,0):\\n            K[i] = K[2*i] + K[2*i+1]\\n            X[i] = max(X[2*i], X[2*i+1])\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        K = self.K\\n        X=self.X\\n        n=self.base\\n        i=1\\n        if X[1]<k:\\n            return []\\n        while i<n:\\n            if X[2*i] >= k:\\n                i = 2*i\\n            else:\\n                i = 2*i+1\\n        row = i-n\\n        if row > maxRow:\\n            return []\\n        col = self.m - K[i]\\n        X[i] -= k\\n        while i:\\n            K[i] -= k\\n            i >>= 1\\n            X[i] = max(X[2*i], X[2*i+1])\\n        X[0] = 0\\n        return [row, col]\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        K = self.K\\n        X=self.X\\n        n=self.base\\n        i=1\\n        if K[1]<k:\\n            return False\\n        while i<n:\\n            if K[2*i] >= k:\\n                i = 2*i\\n            else:\\n                k -= K[2*i]\\n                i = 2*i+1\\n        row = i-n\\n        if row > maxRow:\\n            return False\\n        K[i] -= k\\n        X[i] = K[i]\\n        while i:\\n            from_right = i & 1\\n            i >>= 1\\n            if not i:\\n                break\\n            if from_right:\\n                K[2*i] = X[2*i] = 0\\n            K[i] = K[2*i] + K[2*i+1]\\n            X[i] = max(X[2*i], X[2*i+1])\\n        X[0] = 0\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160734,
                "title": "python3-max-segment-tree-fenwick-tree-bit",
                "content": "Standard solution except using Fenwick Tree for Range Sum\\nInitialization is O(n) Time\\ngroup is O(lg(n)) Time\\nscater is O(k*lg(n)) Time\\nO(n) Space\\n```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.fwtree = FwTree(n,m)\\n        self.sgt = SegTree(n,m)\\n        self.m = m\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        ff = self.sgt.firstFit(k)\\n        if ff and ff[0] <= maxRow:\\n            (row, available) = ff\\n            self.fwtree.update(row, available-k)\\n            self.sgt.update(row, available-k)\\n            return [row, self.m-available]\\n        else:\\n            return []\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.fwtree.getSum(maxRow) >= k:\\n            while k > 0:\\n                row, available = self.sgt.firstFit(1)\\n                fit = min(available, k)\\n                self.fwtree.update(row,available-fit)\\n                self.sgt.update(row,available-fit)\\n                k -= fit\\n                \\n            return True\\n        else:\\n            return False\\n\\nclass FwTree:\\n    def __init__(self,n,m):\\n        self.t = [0]*(n+1)\\n        for i in range(1,len(self.t)):\\n            self.t[i]+=m\\n            if (j:=FwTree.__getNext(i)) < len(self.t):\\n                self.t[j] += self.t[i]\\n            \\n    def update(self,i,val):\\n        i+=1\\n        delta = val - self.t[i]\\n        while i < len(self.t):\\n            self.t[i] += delta\\n            i = FwTree.__getNext(i)\\n            \\n    @classmethod\\n    def __getNext(cls,b):\\n        return (b & -b) + b\\n    \\n    @classmethod\\n    def __getPrev(cls,b):\\n        return b - (b & -b)\\n        \\n    def getSum(self,i):\\n        i+=1\\n        res = 0\\n        while i > 0:\\n            res += self.t[i]\\n            i = FwTree.__getPrev(i)\\n        return res\\n    \\nclass SegTree:\\n    def __init__(self, n, m):\\n        self.m = m\\n        self.np2 = 1\\n        while self.np2 < n:\\n            self.np2 <<= 1\\n        self.np2 -= 1\\n        self.t = [m]*(self.np2+n)\\n        \\n    def update(self,i,val):\\n        i += self.np2\\n        self.t[i] = val\\n        while (i := (i-1)//2) >= 0:\\n            l = self.t[2*i+1]\\n            j = 2*i+2\\n            r = self.t[j] if j < len(self.t) else 0\\n            self.t[i] = max(l,r)\\n            \\n    def firstFit(self,k):\\n        if self.t[0] >= k:\\n            i = 0\\n            while True:\\n                if i >= self.np2:\\n                    return [i-self.np2, self.t[i]]\\n                else:\\n                    n = 2*i+1\\n                    i = n if self.t[n] >= k else n+1\\n        else:\\n            return None\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.fwtree = FwTree(n,m)\\n        self.sgt = SegTree(n,m)\\n        self.m = m\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        ff = self.sgt.firstFit(k)\\n        if ff and ff[0] <= maxRow:\\n            (row, available) = ff\\n            self.fwtree.update(row, available-k)\\n            self.sgt.update(row, available-k)\\n            return [row, self.m-available]\\n        else:\\n            return []\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.fwtree.getSum(maxRow) >= k:\\n            while k > 0:\\n                row, available = self.sgt.firstFit(1)\\n                fit = min(available, k)\\n                self.fwtree.update(row,available-fit)\\n                self.sgt.update(row,available-fit)\\n                k -= fit\\n                \\n            return True\\n        else:\\n            return False\\n\\nclass FwTree:\\n    def __init__(self,n,m):\\n        self.t = [0]*(n+1)\\n        for i in range(1,len(self.t)):\\n            self.t[i]+=m\\n            if (j:=FwTree.__getNext(i)) < len(self.t):\\n                self.t[j] += self.t[i]\\n            \\n    def update(self,i,val):\\n        i+=1\\n        delta = val - self.t[i]\\n        while i < len(self.t):\\n            self.t[i] += delta\\n            i = FwTree.__getNext(i)\\n            \\n    @classmethod\\n    def __getNext(cls,b):\\n        return (b & -b) + b\\n    \\n    @classmethod\\n    def __getPrev(cls,b):\\n        return b - (b & -b)\\n        \\n    def getSum(self,i):\\n        i+=1\\n        res = 0\\n        while i > 0:\\n            res += self.t[i]\\n            i = FwTree.__getPrev(i)\\n        return res\\n    \\nclass SegTree:\\n    def __init__(self, n, m):\\n        self.m = m\\n        self.np2 = 1\\n        while self.np2 < n:\\n            self.np2 <<= 1\\n        self.np2 -= 1\\n        self.t = [m]*(self.np2+n)\\n        \\n    def update(self,i,val):\\n        i += self.np2\\n        self.t[i] = val\\n        while (i := (i-1)//2) >= 0:\\n            l = self.t[2*i+1]\\n            j = 2*i+2\\n            r = self.t[j] if j < len(self.t) else 0\\n            self.t[i] = max(l,r)\\n            \\n    def firstFit(self,k):\\n        if self.t[0] >= k:\\n            i = 0\\n            while True:\\n                if i >= self.np2:\\n                    return [i-self.np2, self.t[i]]\\n                else:\\n                    n = 2*i+1\\n                    i = n if self.t[n] >= k else n+1\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139440,
                "title": "java-memory-limit-exceeded-problem-for-basic-solution",
                "content": "```\\nclass BookMyShow {\\n    int seats[][];\\n    int noOfSeats;\\n\\n    public BookMyShow(int n, int m) {\\n        seats = new int[n][m];\\n        noOfSeats = m;\\n    }\\n\\n   \\n\\n    public int[] gather(int k, int maxRow) {\\n\\n        for (int i = 0; i <= maxRow; i++) {\\n            if (seats[i].length >= k) {\\n                int ar[] = new int[2];\\n                ar[0] = i;\\n                ar[1] = noOfSeats - seats[i].length;\\n                int size = seats[i].length - k;\\n                seats[i] = new int[size];\\n                return ar;\\n            }\\n        }\\n        int ar[] = new int[0];\\n        return ar;\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n        int availSeats = 0;\\n        for (int i = 0; i <= maxRow; i++) {\\n            availSeats += seats[i].length;\\n        }\\n   \\n        if (availSeats >= k) {\\n            for (int i = 0; i < seats.length; i++) {\\n                if (k == 0)\\n                    return true;\\n                if (seats[i].length >= k) {\\n                    seats[i] = new int[seats[i].length - k];\\n                    return true;\\n                } else {\\n                    k -= seats[i].length;\\n                    seats[i] = new int[0];\\n                }\\n            }\\n            return true;\\n\\n        } else\\n            return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BookMyShow {\\n    int seats[][];\\n    int noOfSeats;\\n\\n    public BookMyShow(int n, int m) {\\n        seats = new int[n][m];\\n        noOfSeats = m;\\n    }\\n\\n   \\n\\n    public int[] gather(int k, int maxRow) {\\n\\n        for (int i = 0; i <= maxRow; i++) {\\n            if (seats[i].length >= k) {\\n                int ar[] = new int[2];\\n                ar[0] = i;\\n                ar[1] = noOfSeats - seats[i].length;\\n                int size = seats[i].length - k;\\n                seats[i] = new int[size];\\n                return ar;\\n            }\\n        }\\n        int ar[] = new int[0];\\n        return ar;\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n        int availSeats = 0;\\n        for (int i = 0; i <= maxRow; i++) {\\n            availSeats += seats[i].length;\\n        }\\n   \\n        if (availSeats >= k) {\\n            for (int i = 0; i < seats.length; i++) {\\n                if (k == 0)\\n                    return true;\\n                if (seats[i].length >= k) {\\n                    seats[i] = new int[seats[i].length - k];\\n                    return true;\\n                } else {\\n                    k -= seats[i].length;\\n                    seats[i] = new int[0];\\n                }\\n            }\\n            return true;\\n\\n        } else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121013,
                "title": "swift-segment-tree",
                "content": "```swift\\n// https://leetcode.com/problems/booking-concert-tickets-in-groups/\\n\\n    // let debug = false\\nclass BookMyShow {\\n\\n\\n    private class SegmentTreeNode: CustomStringConvertible {\\n        var description: String {\\n            return \"Node(\\\\(leftBound),\\\\(rightBound),\\\\(maxAdjSeats),\\\\(remainSeats))\"\\n        }\\n\\n        var leftBound: Int\\n        var rightBound: Int\\n        var maxAdjSeats = 0\\n        var remainSeats = 0\\n        var leftChild: SegmentTreeNode?\\n        var rightChild: SegmentTreeNode?\\n        var lazy: Bool = false\\n\\n        init(_ l: Int, _ r: Int, _ val: Int) {\\n            self.leftBound = l\\n            self.rightBound = r\\n            self.maxAdjSeats = val\\n            self.remainSeats = val\\n            if l != r {\\n                let mid = (l + r) >> 1\\n                self.leftChild = SegmentTreeNode(l, mid, val)\\n                self.rightChild = SegmentTreeNode(mid + 1, r, val)\\n                pushUp()\\n            }\\n\\n        }\\n\\n        func pushUp() {\\n            self.maxAdjSeats = max(leftChild?.maxAdjSeats ?? 0, rightChild?.maxAdjSeats ?? 0)\\n            self.remainSeats = (leftChild?.remainSeats ?? 0) + (rightChild?.remainSeats ?? 0)\\n        }\\n\\n\\n        func  pushDown() {\\n            guard lazy else {return}\\n            self.leftChild?.maxAdjSeats = 0\\n            self.rightChild?.maxAdjSeats = 0\\n            self.leftChild?.remainSeats = 0\\n            self.rightChild?.remainSeats = 0\\n            self.leftChild?.lazy = true\\n            self.rightChild?.lazy = true\\n            lazy = false\\n\\n        }\\n\\n        func queryRemainSeats(_ left: Int , _ right: Int) -> Int {\\n            if leftBound == left && rightBound == right {\\n                return remainSeats\\n            }\\n            pushDown()\\n            let mid = (leftBound + rightBound) >> 1\\n            if right <= mid {\\n                return leftChild!.queryRemainSeats(left, right)\\n            } else if left > mid {\\n                return rightChild!.queryRemainSeats(left, right)\\n            }\\n            return leftChild!.queryRemainSeats(left, mid) + rightChild!.queryRemainSeats(mid + 1, right)\\n        }\\n\\n\\n\\n        func queryMaxAdjSeats(_ left: Int, _ right: Int) -> Int {\\n            if leftBound == left && rightBound == right {\\n                return maxAdjSeats\\n            }\\n            pushDown()\\n            let mid = (leftBound + rightBound) >> 1\\n            if right <= mid {\\n                return leftChild!.queryMaxAdjSeats(left, right)\\n            } else if left > mid {\\n                return rightChild!.queryMaxAdjSeats(left, right)\\n            }\\n            return max(leftChild!.queryMaxAdjSeats(left, mid), rightChild!.queryMaxAdjSeats(mid + 1, right))\\n        }\\n\\n\\n        func updateWhenGather(_ row: Int, _ k: Int,_ maxSeats: Int,_ startC: inout Int) {\\n            if leftBound == row && rightBound == row {\\n                startC = maxSeats - remainSeats\\n                remainSeats -= k\\n                maxAdjSeats -= k\\n                return\\n            }\\n            let mid = (leftBound + rightBound) >> 1\\n            if row <= mid {\\n                leftChild?.updateWhenGather(row, k, maxSeats, &startC)\\n            } else {\\n                rightChild?.updateWhenGather(row, k, maxSeats, &startC)\\n            }\\n            pushUp()\\n        }\\n\\n\\n        func updateWhenScatterSetZero(_ left: Int, _ right: Int) {\\n            if leftBound == left && rightBound == right {\\n                self.remainSeats = 0\\n                self.maxAdjSeats = 0\\n                lazy = true\\n                return\\n            }\\n            let mid = (leftBound + rightBound) >> 1\\n            if right <= mid {\\n                leftChild?.updateWhenScatterSetZero(left, right)\\n            } else if left > mid {\\n                rightChild?.updateWhenScatterSetZero(left, right)\\n            } else {\\n                leftChild?.updateWhenScatterSetZero(left, mid)\\n                rightChild?.updateWhenScatterSetZero(mid + 1, right)\\n            }\\n            pushUp()\\n        }\\n\\n        func updateTheLastRowWhenScatter(_ row: Int,_ maxSeats: Int, _ k: Int) {\\n            var c = 0\\n            updateWhenGather(row, k, maxSeats, &c)\\n        }\\n        func display() {\\n            if let l = leftChild {\\n                l.display()\\n            }\\n            if(leftBound == rightBound) {\\n                print(self)\\n            }\\n            if let r = rightChild {\\n                r.display()\\n            }\\n        }\\n    }\\n\\n    private let segmentTree: SegmentTreeNode\\n    private let N: Int\\n    private let M: Int\\n    init(_ n: Int, _ m: Int) {\\n        segmentTree = SegmentTreeNode(0, n - 1, m)\\n        N = n\\n        M = m\\n            // if debug {\\n            //     segmentTree.display()\\n            // }\\n    }\\n\\n    func gather(_ k: Int, _ maxRow: Int) -> [Int] {\\n\\n        guard segmentTree.queryMaxAdjSeats(0, maxRow) >= k else {\\n\\n            return []\\n        }\\n            //        print(\"  \\\\(k)   \\\\( maxRow) \\\\(segmentTree.queryMaxAdjSeats(0, maxRow))\")\\n        var left = 0\\n        var right = min(maxRow, N - 1)\\n        while left < right {\\n            let mid = (left + right) >> 1\\n            if segmentTree.queryMaxAdjSeats(0, mid) >= k {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        var c = 0\\n        segmentTree.updateWhenGather(left, k,M,&c)\\n            // if debug {\\n            //     print(\"--------gather  \\\\(left)---------\")\\n            //     segmentTree.display()\\n            // }\\n        return [left,c]\\n    }\\n\\n    func scatter(_ k: Int, _ maxRow: Int) -> Bool {\\n        guard segmentTree.queryRemainSeats(0, maxRow) >= k else {\\n            return false\\n        }\\n        var left = 0\\n        var right = min(maxRow, N - 1)\\n        while left < right {\\n            let mid = (left + right) >> 1\\n            if segmentTree.queryRemainSeats(0, mid) >= k {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        var remain = k\\n        if left >= 1 {\\n            remain -= segmentTree.queryRemainSeats(0, left - 1)\\n            segmentTree.updateWhenScatterSetZero(0, left - 1)\\n\\n        }\\n        segmentTree.updateTheLastRowWhenScatter(left, M, remain)\\n            // if debug {\\n            //     print(\"--------scatter  \\\\(left)  ---------\")\\n            //     segmentTree.display()\\n\\n            // }\\n        return true\\n    }\\n}\\n\\n\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * let obj = BookMyShow(n, m)\\n * let ret_1: [Int] = obj.gather(k, maxRow)\\n * let ret_2: Bool = obj.scatter(k, maxRow)\\n */\\n```",
                "solutionTags": [
                    "Swift",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```swift\\n// https://leetcode.com/problems/booking-concert-tickets-in-groups/\\n\\n    // let debug = false\\nclass BookMyShow {\\n\\n\\n    private class SegmentTreeNode: CustomStringConvertible {\\n        var description: String {\\n            return \"Node(\\\\(leftBound),\\\\(rightBound),\\\\(maxAdjSeats),\\\\(remainSeats))\"\\n        }\\n\\n        var leftBound: Int\\n        var rightBound: Int\\n        var maxAdjSeats = 0\\n        var remainSeats = 0\\n        var leftChild: SegmentTreeNode?\\n        var rightChild: SegmentTreeNode?\\n        var lazy: Bool = false\\n\\n        init(_ l: Int, _ r: Int, _ val: Int) {\\n            self.leftBound = l\\n            self.rightBound = r\\n            self.maxAdjSeats = val\\n            self.remainSeats = val\\n            if l != r {\\n                let mid = (l + r) >> 1\\n                self.leftChild = SegmentTreeNode(l, mid, val)\\n                self.rightChild = SegmentTreeNode(mid + 1, r, val)\\n                pushUp()\\n            }\\n\\n        }\\n\\n        func pushUp() {\\n            self.maxAdjSeats = max(leftChild?.maxAdjSeats ?? 0, rightChild?.maxAdjSeats ?? 0)\\n            self.remainSeats = (leftChild?.remainSeats ?? 0) + (rightChild?.remainSeats ?? 0)\\n        }\\n\\n\\n        func  pushDown() {\\n            guard lazy else {return}\\n            self.leftChild?.maxAdjSeats = 0\\n            self.rightChild?.maxAdjSeats = 0\\n            self.leftChild?.remainSeats = 0\\n            self.rightChild?.remainSeats = 0\\n            self.leftChild?.lazy = true\\n            self.rightChild?.lazy = true\\n            lazy = false\\n\\n        }\\n\\n        func queryRemainSeats(_ left: Int , _ right: Int) -> Int {\\n            if leftBound == left && rightBound == right {\\n                return remainSeats\\n            }\\n            pushDown()\\n            let mid = (leftBound + rightBound) >> 1\\n            if right <= mid {\\n                return leftChild!.queryRemainSeats(left, right)\\n            } else if left > mid {\\n                return rightChild!.queryRemainSeats(left, right)\\n            }\\n            return leftChild!.queryRemainSeats(left, mid) + rightChild!.queryRemainSeats(mid + 1, right)\\n        }\\n\\n\\n\\n        func queryMaxAdjSeats(_ left: Int, _ right: Int) -> Int {\\n            if leftBound == left && rightBound == right {\\n                return maxAdjSeats\\n            }\\n            pushDown()\\n            let mid = (leftBound + rightBound) >> 1\\n            if right <= mid {\\n                return leftChild!.queryMaxAdjSeats(left, right)\\n            } else if left > mid {\\n                return rightChild!.queryMaxAdjSeats(left, right)\\n            }\\n            return max(leftChild!.queryMaxAdjSeats(left, mid), rightChild!.queryMaxAdjSeats(mid + 1, right))\\n        }\\n\\n\\n        func updateWhenGather(_ row: Int, _ k: Int,_ maxSeats: Int,_ startC: inout Int) {\\n            if leftBound == row && rightBound == row {\\n                startC = maxSeats - remainSeats\\n                remainSeats -= k\\n                maxAdjSeats -= k\\n                return\\n            }\\n            let mid = (leftBound + rightBound) >> 1\\n            if row <= mid {\\n                leftChild?.updateWhenGather(row, k, maxSeats, &startC)\\n            } else {\\n                rightChild?.updateWhenGather(row, k, maxSeats, &startC)\\n            }\\n            pushUp()\\n        }\\n\\n\\n        func updateWhenScatterSetZero(_ left: Int, _ right: Int) {\\n            if leftBound == left && rightBound == right {\\n                self.remainSeats = 0\\n                self.maxAdjSeats = 0\\n                lazy = true\\n                return\\n            }\\n            let mid = (leftBound + rightBound) >> 1\\n            if right <= mid {\\n                leftChild?.updateWhenScatterSetZero(left, right)\\n            } else if left > mid {\\n                rightChild?.updateWhenScatterSetZero(left, right)\\n            } else {\\n                leftChild?.updateWhenScatterSetZero(left, mid)\\n                rightChild?.updateWhenScatterSetZero(mid + 1, right)\\n            }\\n            pushUp()\\n        }\\n\\n        func updateTheLastRowWhenScatter(_ row: Int,_ maxSeats: Int, _ k: Int) {\\n            var c = 0\\n            updateWhenGather(row, k, maxSeats, &c)\\n        }\\n        func display() {\\n            if let l = leftChild {\\n                l.display()\\n            }\\n            if(leftBound == rightBound) {\\n                print(self)\\n            }\\n            if let r = rightChild {\\n                r.display()\\n            }\\n        }\\n    }\\n\\n    private let segmentTree: SegmentTreeNode\\n    private let N: Int\\n    private let M: Int\\n    init(_ n: Int, _ m: Int) {\\n        segmentTree = SegmentTreeNode(0, n - 1, m)\\n        N = n\\n        M = m\\n            // if debug {\\n            //     segmentTree.display()\\n            // }\\n    }\\n\\n    func gather(_ k: Int, _ maxRow: Int) -> [Int] {\\n\\n        guard segmentTree.queryMaxAdjSeats(0, maxRow) >= k else {\\n\\n            return []\\n        }\\n            //        print(\"  \\\\(k)   \\\\( maxRow) \\\\(segmentTree.queryMaxAdjSeats(0, maxRow))\")\\n        var left = 0\\n        var right = min(maxRow, N - 1)\\n        while left < right {\\n            let mid = (left + right) >> 1\\n            if segmentTree.queryMaxAdjSeats(0, mid) >= k {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        var c = 0\\n        segmentTree.updateWhenGather(left, k,M,&c)\\n            // if debug {\\n            //     print(\"--------gather  \\\\(left)---------\")\\n            //     segmentTree.display()\\n            // }\\n        return [left,c]\\n    }\\n\\n    func scatter(_ k: Int, _ maxRow: Int) -> Bool {\\n        guard segmentTree.queryRemainSeats(0, maxRow) >= k else {\\n            return false\\n        }\\n        var left = 0\\n        var right = min(maxRow, N - 1)\\n        while left < right {\\n            let mid = (left + right) >> 1\\n            if segmentTree.queryRemainSeats(0, mid) >= k {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        var remain = k\\n        if left >= 1 {\\n            remain -= segmentTree.queryRemainSeats(0, left - 1)\\n            segmentTree.updateWhenScatterSetZero(0, left - 1)\\n\\n        }\\n        segmentTree.updateTheLastRowWhenScatter(left, M, remain)\\n            // if debug {\\n            //     print(\"--------scatter  \\\\(left)  ---------\")\\n            //     segmentTree.display()\\n\\n            // }\\n        return true\\n    }\\n}\\n\\n\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * let obj = BookMyShow(n, m)\\n * let ret_1: [Int] = obj.gather(k, maxRow)\\n * let ret_2: Bool = obj.scatter(k, maxRow)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118049,
                "title": "swift-solution-test-cases",
                "content": "```\\nfinal class BookMyShow {\\n    private var emptySeatCount: [Int]\\n    private var seatCount: Int\\n    private var totalCount: Int\\n    init(_ n: Int, _ m: Int) {\\n        emptySeatCount = [Int](repeating: m, count: n)\\n        seatCount = m\\n        totalCount = m*n\\n    }\\n\\n    func gather(_ k: Int, _ maxRow: Int) -> [Int] {\\n        guard k<=totalCount && k<=seatCount else { return [] }\\n        let maxRow = maxRow > emptySeatCount.count-1 ? emptySeatCount.count-1 : maxRow\\n        for idx in 0...maxRow {\\n            if emptySeatCount[idx] >= k {\\n                let startingSeat = seatCount-emptySeatCount[idx]\\n                emptySeatCount[idx] -= k\\n                totalCount -= k\\n                return [idx,startingSeat]\\n            }\\n        }\\n        return []\\n    }\\n\\n    func scatter(_ k: Int, _ maxRow: Int) -> Bool {\\n        guard k<=totalCount else { return false }\\n        if totalCount == k {\\n            if maxRow >= emptySeatCount.count-1 {\\n                totalCount = 0\\n                return true\\n            } else {\\n                return false\\n            }\\n        }\\n        let maxRow = maxRow > emptySeatCount.count-1 ? emptySeatCount.count-1 : maxRow\\n        var totalSeat = 0\\n        for idx in 0...maxRow {\\n            totalSeat += emptySeatCount[idx]\\n            if totalSeat >= k {\\n                updateEmptySeatCount(k)\\n                totalCount -= k\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n\\n    private func updateEmptySeatCount(_ k: Int) {\\n        var remainingSeatCount = k\\n        for idx in 0..<emptySeatCount.count {\\n            if remainingSeatCount>emptySeatCount[idx] {\\n                remainingSeatCount -= emptySeatCount[idx]\\n                emptySeatCount[idx] = 0\\n            } else {\\n                emptySeatCount[idx] = emptySeatCount[idx]-remainingSeatCount\\n                return\\n            }\\n        }\\n    }\\n}\\n```\\n\\nTest Cases\\n\\n```\\nimport XCTest\\n\\nfinal class Tests: XCTestCase {\\n    func test0() {\\n        let bms = BookMyShow(1, 2)\\n        XCTAssertTrue(bms.scatter(2, 0))\\n    }\\n\\n    func test1() {\\n        let bms = BookMyShow(2, 5) // There are 2 rows with 5 seats each\\n        XCTAssertEqual(bms.gather(4, 0), [0,0])\\n        XCTAssertEqual(bms.gather(2, 0), [])\\n        XCTAssertTrue(bms.scatter(5, 1))\\n        XCTAssertFalse(bms.scatter(5, 1))\\n    }\\n\\n    func test2() {\\n        let bm = BookMyShow(3, 999999999)\\n        XCTAssertTrue(bm.scatter(1000000000, 2))\\n        XCTAssertEqual(bm.gather(999999999, 2), [2, 0])\\n        XCTAssertEqual(bm.gather(999999999, 2), [])\\n        XCTAssertEqual(bm.gather(999999999, 2), [])\\n    }\\n\\n    func test3() {\\n        let bm = BookMyShow(5, 9)\\n        XCTAssertEqual(bm.gather(10, 1), [])\\n        XCTAssertTrue(bm.scatter(3, 3))\\n        XCTAssertEqual(bm.gather(9, 1), [1, 0])\\n        XCTAssertEqual(bm.gather(10, 2), [])\\n        XCTAssertEqual(bm.gather(2, 0), [0, 3])\\n    }\\n\\n    func test4() {\\n        let bm = BookMyShow(5, 3)\\n        XCTAssertTrue(bm.scatter(3, 2))\\n        XCTAssertEqual(bm.gather(10, 2), [])\\n        XCTAssertEqual(bm.gather(1, 1), [1, 0])\\n        XCTAssertEqual(bm.gather(9, 4), [])\\n    }\\n\\n    func test5() {\\n        let bm = BookMyShow(19, 9)\\n        XCTAssertEqual(bm.gather(38, 8), [])\\n        XCTAssertEqual(bm.gather(27, 3), [])\\n        XCTAssertTrue(bm.scatter(36, 14))\\n        XCTAssertFalse(bm.scatter(46, 2))\\n        XCTAssertEqual(bm.gather(12, 5), [])\\n        XCTAssertTrue(bm.scatter(12, 12))\\n        XCTAssertTrue(bm.scatter(43, 12))\\n        XCTAssertEqual(bm.gather(30, 5), [])\\n        XCTAssertFalse(bm.scatter(29, 6))\\n        XCTAssertTrue(bm.scatter(37, 18))\\n        XCTAssertEqual(bm.gather(6, 16), [14, 2])\\n        XCTAssertFalse(bm.scatter(27, 4))\\n        XCTAssertEqual(bm.gather(4, 17), [15, 0])\\n        XCTAssertFalse(bm.scatter(11, 5))\\n        XCTAssertEqual(bm.gather(22, 8), [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class BookMyShow {\\n    private var emptySeatCount: [Int]\\n    private var seatCount: Int\\n    private var totalCount: Int\\n    init(_ n: Int, _ m: Int) {\\n        emptySeatCount = [Int](repeating: m, count: n)\\n        seatCount = m\\n        totalCount = m*n\\n    }\\n\\n    func gather(_ k: Int, _ maxRow: Int) -> [Int] {\\n        guard k<=totalCount && k<=seatCount else { return [] }\\n        let maxRow = maxRow > emptySeatCount.count-1 ? emptySeatCount.count-1 : maxRow\\n        for idx in 0...maxRow {\\n            if emptySeatCount[idx] >= k {\\n                let startingSeat = seatCount-emptySeatCount[idx]\\n                emptySeatCount[idx] -= k\\n                totalCount -= k\\n                return [idx,startingSeat]\\n            }\\n        }\\n        return []\\n    }\\n\\n    func scatter(_ k: Int, _ maxRow: Int) -> Bool {\\n        guard k<=totalCount else { return false }\\n        if totalCount == k {\\n            if maxRow >= emptySeatCount.count-1 {\\n                totalCount = 0\\n                return true\\n            } else {\\n                return false\\n            }\\n        }\\n        let maxRow = maxRow > emptySeatCount.count-1 ? emptySeatCount.count-1 : maxRow\\n        var totalSeat = 0\\n        for idx in 0...maxRow {\\n            totalSeat += emptySeatCount[idx]\\n            if totalSeat >= k {\\n                updateEmptySeatCount(k)\\n                totalCount -= k\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n\\n    private func updateEmptySeatCount(_ k: Int) {\\n        var remainingSeatCount = k\\n        for idx in 0..<emptySeatCount.count {\\n            if remainingSeatCount>emptySeatCount[idx] {\\n                remainingSeatCount -= emptySeatCount[idx]\\n                emptySeatCount[idx] = 0\\n            } else {\\n                emptySeatCount[idx] = emptySeatCount[idx]-remainingSeatCount\\n                return\\n            }\\n        }\\n    }\\n}\\n```\n```\\nimport XCTest\\n\\nfinal class Tests: XCTestCase {\\n    func test0() {\\n        let bms = BookMyShow(1, 2)\\n        XCTAssertTrue(bms.scatter(2, 0))\\n    }\\n\\n    func test1() {\\n        let bms = BookMyShow(2, 5) // There are 2 rows with 5 seats each\\n        XCTAssertEqual(bms.gather(4, 0), [0,0])\\n        XCTAssertEqual(bms.gather(2, 0), [])\\n        XCTAssertTrue(bms.scatter(5, 1))\\n        XCTAssertFalse(bms.scatter(5, 1))\\n    }\\n\\n    func test2() {\\n        let bm = BookMyShow(3, 999999999)\\n        XCTAssertTrue(bm.scatter(1000000000, 2))\\n        XCTAssertEqual(bm.gather(999999999, 2), [2, 0])\\n        XCTAssertEqual(bm.gather(999999999, 2), [])\\n        XCTAssertEqual(bm.gather(999999999, 2), [])\\n    }\\n\\n    func test3() {\\n        let bm = BookMyShow(5, 9)\\n        XCTAssertEqual(bm.gather(10, 1), [])\\n        XCTAssertTrue(bm.scatter(3, 3))\\n        XCTAssertEqual(bm.gather(9, 1), [1, 0])\\n        XCTAssertEqual(bm.gather(10, 2), [])\\n        XCTAssertEqual(bm.gather(2, 0), [0, 3])\\n    }\\n\\n    func test4() {\\n        let bm = BookMyShow(5, 3)\\n        XCTAssertTrue(bm.scatter(3, 2))\\n        XCTAssertEqual(bm.gather(10, 2), [])\\n        XCTAssertEqual(bm.gather(1, 1), [1, 0])\\n        XCTAssertEqual(bm.gather(9, 4), [])\\n    }\\n\\n    func test5() {\\n        let bm = BookMyShow(19, 9)\\n        XCTAssertEqual(bm.gather(38, 8), [])\\n        XCTAssertEqual(bm.gather(27, 3), [])\\n        XCTAssertTrue(bm.scatter(36, 14))\\n        XCTAssertFalse(bm.scatter(46, 2))\\n        XCTAssertEqual(bm.gather(12, 5), [])\\n        XCTAssertTrue(bm.scatter(12, 12))\\n        XCTAssertTrue(bm.scatter(43, 12))\\n        XCTAssertEqual(bm.gather(30, 5), [])\\n        XCTAssertFalse(bm.scatter(29, 6))\\n        XCTAssertTrue(bm.scatter(37, 18))\\n        XCTAssertEqual(bm.gather(6, 16), [14, 2])\\n        XCTAssertFalse(bm.scatter(27, 4))\\n        XCTAssertEqual(bm.gather(4, 17), [15, 0])\\n        XCTAssertFalse(bm.scatter(11, 5))\\n        XCTAssertEqual(bm.gather(22, 8), [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107970,
                "title": "python-binary-index-array",
                "content": "```\\nclass BiaSum:\\n    def __init__(self, n, m):\\n        self.n = n\\n        self.arr = [0]*(n+1)\\n        for i in range(n):\\n            self.update(i+1, m)\\n    def update(self, idx, val):\\n        while idx<=self.n:\\n            self.arr[idx]+=val\\n            idx+=-idx&idx\\n    def query(self, idx):\\n        res = 0\\n        while idx>0:\\n            res+=self.arr[idx]\\n            idx-=-idx&idx\\n        return res\\nclass BiaMax:\\n    def __init__(self, n, m):\\n        self.n = n\\n        self.arr, self.orig = [m]*(n+1), [m]*(n+1)\\n        self.arr[0] = self.orig[0] = 0\\n    def update(self, idx, val):\\n        self.orig[idx] += val\\n        while idx<=self.n:\\n            self.arr[idx] = self.orig[idx]\\n            lowbit, start = -idx&idx, 1\\n            while start<lowbit:\\n                self.arr[idx] = max(self.arr[idx], self.arr[idx-start])\\n                start<<=1\\n            idx+=lowbit\\n    def query(self, idx):\\n        res = -inf\\n        while idx>0:\\n            res = max(res, self.arr[idx])\\n            idx-=-idx&idx\\n        return res\\n        \\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.biasum, self.biamax = BiaSum(n, m), BiaMax(n, m)\\n        self.m, self.cur = m, 0\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if self.biamax.query(maxRow+1)<k: \\n            return []\\n        l, r = 1, maxRow+1\\n        while l<r:\\n            mid = l+(r-l)//2\\n            if self.biamax.query(mid)>=k:\\n                r = mid\\n            else:\\n                l = mid+1\\n        res = [l-1, self.m-self.biamax.orig[l]]\\n        self.biamax.update(l, -k)\\n        self.biasum.update(l, -k)\\n        return res\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.biasum.query(maxRow+1)<k: return False\\n        l, r = 0, maxRow+1\\n        while l<r:\\n            mid = l+(r-l)//2\\n            if self.biasum.query(mid)>=k:\\n                r = mid\\n            else:\\n                l = mid+1\\n        cnt = 0\\n        while self.cur<l-1:\\n            cur_avail = self.biamax.orig[self.cur+1]\\n            cnt += cur_avail\\n            self.biamax.update(self.cur+1, -cur_avail)\\n            self.biasum.update(self.cur+1, -cur_avail)\\n            self.cur += 1\\n        self.biamax.update(l, cnt-k)\\n        self.biasum.update(l, cnt-k)\\n        return True\\n",
                "solutionTags": [],
                "code": "```\\nclass BiaSum:\\n    def __init__(self, n, m):\\n        self.n = n\\n        self.arr = [0]*(n+1)\\n        for i in range(n):\\n            self.update(i+1, m)\\n    def update(self, idx, val):\\n        while idx<=self.n:\\n            self.arr[idx]+=val\\n            idx+=-idx&idx\\n    def query(self, idx):\\n        res = 0\\n        while idx>0:\\n            res+=self.arr[idx]\\n            idx-=-idx&idx\\n        return res\\nclass BiaMax:\\n    def __init__(self, n, m):\\n        self.n = n\\n        self.arr, self.orig = [m]*(n+1), [m]*(n+1)\\n        self.arr[0] = self.orig[0] = 0\\n    def update(self, idx, val):\\n        self.orig[idx] += val\\n        while idx<=self.n:\\n            self.arr[idx] = self.orig[idx]\\n            lowbit, start = -idx&idx, 1\\n            while start<lowbit:\\n                self.arr[idx] = max(self.arr[idx], self.arr[idx-start])\\n                start<<=1\\n            idx+=lowbit\\n    def query(self, idx):\\n        res = -inf\\n        while idx>0:\\n            res = max(res, self.arr[idx])\\n            idx-=-idx&idx\\n        return res\\n        \\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.biasum, self.biamax = BiaSum(n, m), BiaMax(n, m)\\n        self.m, self.cur = m, 0\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if self.biamax.query(maxRow+1)<k: \\n            return []\\n        l, r = 1, maxRow+1\\n        while l<r:\\n            mid = l+(r-l)//2\\n            if self.biamax.query(mid)>=k:\\n                r = mid\\n            else:\\n                l = mid+1\\n        res = [l-1, self.m-self.biamax.orig[l]]\\n        self.biamax.update(l, -k)\\n        self.biasum.update(l, -k)\\n        return res\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.biasum.query(maxRow+1)<k: return False\\n        l, r = 0, maxRow+1\\n        while l<r:\\n            mid = l+(r-l)//2\\n            if self.biasum.query(mid)>=k:\\n                r = mid\\n            else:\\n                l = mid+1\\n        cnt = 0\\n        while self.cur<l-1:\\n            cur_avail = self.biamax.orig[self.cur+1]\\n            cnt += cur_avail\\n            self.biamax.update(self.cur+1, -cur_avail)\\n            self.biasum.update(self.cur+1, -cur_avail)\\n            self.cur += 1\\n        self.biamax.update(l, cnt-k)\\n        self.biasum.update(l, cnt-k)\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 2103840,
                "title": "my-solution",
                "content": "The solution employs the `Segment Tree`.\\nThis question is so hard, I\\'ve tried a lot of times to pass all test cases.\\n```\\nclass BookMyShow {\\nprivate:\\n    class SegmentTree {\\n    public:\\n        SegmentTree(const int rows, const int cols)\\n            : segment_tree_((1 << static_cast<int>(ceil(log2(rows)) + 1)) - 1, make_pair(0LL, 0)), rows_(rows), cols_(cols) {\\n            build(0, 0, rows);\\n        }\\n        \\n        pair<int, int> query_max(const int k, const int max_row) {\\n            return query_max_impl(0, 0, rows_, k, max_row);\\n        }\\n        \\n        void update_max(const int row, const int delta) {\\n            update_max_impl(0, 0, rows_, row, delta);\\n        }\\n        \\n        long long query_sum(const int max_row) {\\n            return query_sum_impl(0, 0, rows_, max_row);\\n        }\\n        \\n        void update_sum(const int max_row, int k) {\\n            update_sum_impl(0, 0, rows_, max_row, k);\\n        }\\n        \\n    private:\\n        void build(const int node, const int start, const int end) {\\n            if (end - start == 1) {\\n                segment_tree_[node] = make_pair(static_cast<long long>(cols_), cols_);\\n                return;\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            build(left_node, start, mid);\\n            build(right_node, mid, end);\\n            segment_tree_[node].first = segment_tree_[left_node].first + segment_tree_[right_node].first;\\n            segment_tree_[node].second = max(segment_tree_[left_node].second, segment_tree_[right_node].second);\\n        }\\n        \\n        pair<int, int> query_max_impl(const int node, const int start, const int end, const int k, const int max_row) {\\n            if (start > max_row) {\\n                return make_pair(-1, -1);\\n            }\\n            \\n            if (segment_tree_[node].second < k) {\\n                return make_pair(-1, -1);\\n            }\\n            \\n            if (end - start == 1) {\\n                return make_pair(start, cols_ - segment_tree_[node].second);\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            const pair<int, int> result_left = query_max_impl(left_node, start, mid, k, max_row);\\n            if (result_left.first != -1) {\\n                return result_left;\\n            }\\n            return query_max_impl(right_node, mid, end, k, max_row);\\n        }\\n        \\n        void update_max_impl(const int node, const int start, const int end, const int row, const int delta) {\\n            if (row < start || row >= end) {\\n                return;\\n            }\\n            \\n            if (end - start == 1) {\\n                segment_tree_[node].first -= delta;\\n                segment_tree_[node].second -= delta;\\n                return;\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            update_max_impl(left_node, start, mid, row, delta);\\n            update_max_impl(right_node, mid, end, row, delta);\\n            segment_tree_[node].first = segment_tree_[left_node].first + segment_tree_[right_node].first;\\n            segment_tree_[node].second = max(segment_tree_[left_node].second, segment_tree_[right_node].second);\\n        }\\n        \\n        long long query_sum_impl(const int node, const int start, const int end, const int max_row) {\\n            if (start > max_row) {\\n                return 0LL;\\n            }\\n            \\n            if (end <= max_row + 1) {\\n                return segment_tree_[node].first;\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            return query_sum_impl(left_node, start, mid, max_row) + query_sum_impl(right_node, mid, end, max_row);\\n        }\\n        \\n        void update_sum_impl(const int node, const int start, const int end, const int max_row, int &k) {\\n            if (start > max_row) {\\n                return;\\n            }\\n            \\n            if (k <= 0) {\\n                return;\\n            }\\n            \\n            if (end - start == 1) {\\n                if (segment_tree_[node].first >= k) {\\n                    segment_tree_[node].first -= k;\\n                    segment_tree_[node].second -= k;\\n                    k = 0;\\n                } else {\\n                    k -= segment_tree_[node].first;\\n                    segment_tree_[node].first = 0;\\n                    segment_tree_[node].second = 0;\\n                }\\n                return;\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            update_sum_impl(left_node, start, mid, max_row, k);\\n            update_sum_impl(right_node, mid, end, max_row, k);\\n            segment_tree_[node].first = segment_tree_[left_node].first + segment_tree_[right_node].first;\\n            segment_tree_[node].second = max(segment_tree_[left_node].second, segment_tree_[right_node].second);\\n        }\\n        \\n        vector<pair<long long, int>> segment_tree_;   // {{sum of the available cells, max available cells}, ...}\\n        const int rows_;\\n        const int cols_;\\n    };\\n    \\npublic:\\n    BookMyShow(const int n, const int m) : segment_tree_(n, m) {\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        const pair<int, int> ret = segment_tree_.query_max(k, maxRow);\\n        if (ret.first == -1) {\\n            return {};\\n        }\\n        \\n        segment_tree_.update_max(ret.first, k);\\n        return {ret.first, ret.second};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if (segment_tree_.query_sum(maxRow) >= k) {\\n            segment_tree_.update_sum(maxRow, k);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    SegmentTree segment_tree_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\nprivate:\\n    class SegmentTree {\\n    public:\\n        SegmentTree(const int rows, const int cols)\\n            : segment_tree_((1 << static_cast<int>(ceil(log2(rows)) + 1)) - 1, make_pair(0LL, 0)), rows_(rows), cols_(cols) {\\n            build(0, 0, rows);\\n        }\\n        \\n        pair<int, int> query_max(const int k, const int max_row) {\\n            return query_max_impl(0, 0, rows_, k, max_row);\\n        }\\n        \\n        void update_max(const int row, const int delta) {\\n            update_max_impl(0, 0, rows_, row, delta);\\n        }\\n        \\n        long long query_sum(const int max_row) {\\n            return query_sum_impl(0, 0, rows_, max_row);\\n        }\\n        \\n        void update_sum(const int max_row, int k) {\\n            update_sum_impl(0, 0, rows_, max_row, k);\\n        }\\n        \\n    private:\\n        void build(const int node, const int start, const int end) {\\n            if (end - start == 1) {\\n                segment_tree_[node] = make_pair(static_cast<long long>(cols_), cols_);\\n                return;\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            build(left_node, start, mid);\\n            build(right_node, mid, end);\\n            segment_tree_[node].first = segment_tree_[left_node].first + segment_tree_[right_node].first;\\n            segment_tree_[node].second = max(segment_tree_[left_node].second, segment_tree_[right_node].second);\\n        }\\n        \\n        pair<int, int> query_max_impl(const int node, const int start, const int end, const int k, const int max_row) {\\n            if (start > max_row) {\\n                return make_pair(-1, -1);\\n            }\\n            \\n            if (segment_tree_[node].second < k) {\\n                return make_pair(-1, -1);\\n            }\\n            \\n            if (end - start == 1) {\\n                return make_pair(start, cols_ - segment_tree_[node].second);\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            const pair<int, int> result_left = query_max_impl(left_node, start, mid, k, max_row);\\n            if (result_left.first != -1) {\\n                return result_left;\\n            }\\n            return query_max_impl(right_node, mid, end, k, max_row);\\n        }\\n        \\n        void update_max_impl(const int node, const int start, const int end, const int row, const int delta) {\\n            if (row < start || row >= end) {\\n                return;\\n            }\\n            \\n            if (end - start == 1) {\\n                segment_tree_[node].first -= delta;\\n                segment_tree_[node].second -= delta;\\n                return;\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            update_max_impl(left_node, start, mid, row, delta);\\n            update_max_impl(right_node, mid, end, row, delta);\\n            segment_tree_[node].first = segment_tree_[left_node].first + segment_tree_[right_node].first;\\n            segment_tree_[node].second = max(segment_tree_[left_node].second, segment_tree_[right_node].second);\\n        }\\n        \\n        long long query_sum_impl(const int node, const int start, const int end, const int max_row) {\\n            if (start > max_row) {\\n                return 0LL;\\n            }\\n            \\n            if (end <= max_row + 1) {\\n                return segment_tree_[node].first;\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            return query_sum_impl(left_node, start, mid, max_row) + query_sum_impl(right_node, mid, end, max_row);\\n        }\\n        \\n        void update_sum_impl(const int node, const int start, const int end, const int max_row, int &k) {\\n            if (start > max_row) {\\n                return;\\n            }\\n            \\n            if (k <= 0) {\\n                return;\\n            }\\n            \\n            if (end - start == 1) {\\n                if (segment_tree_[node].first >= k) {\\n                    segment_tree_[node].first -= k;\\n                    segment_tree_[node].second -= k;\\n                    k = 0;\\n                } else {\\n                    k -= segment_tree_[node].first;\\n                    segment_tree_[node].first = 0;\\n                    segment_tree_[node].second = 0;\\n                }\\n                return;\\n            }\\n            \\n            const int left_node = 2 * node + 1;\\n            const int right_node = 2 * node + 2;\\n            const int mid = start + (end - start) / 2;\\n            update_sum_impl(left_node, start, mid, max_row, k);\\n            update_sum_impl(right_node, mid, end, max_row, k);\\n            segment_tree_[node].first = segment_tree_[left_node].first + segment_tree_[right_node].first;\\n            segment_tree_[node].second = max(segment_tree_[left_node].second, segment_tree_[right_node].second);\\n        }\\n        \\n        vector<pair<long long, int>> segment_tree_;   // {{sum of the available cells, max available cells}, ...}\\n        const int rows_;\\n        const int cols_;\\n    };\\n    \\npublic:\\n    BookMyShow(const int n, const int m) : segment_tree_(n, m) {\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        const pair<int, int> ret = segment_tree_.query_max(k, maxRow);\\n        if (ret.first == -1) {\\n            return {};\\n        }\\n        \\n        segment_tree_.update_max(ret.first, k);\\n        return {ret.first, ret.second};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if (segment_tree_.query_sum(maxRow) >= k) {\\n            segment_tree_.update_sum(maxRow, k);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    SegmentTree segment_tree_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103165,
                "title": "c-segment-tree",
                "content": "```\\ntypedef long long ll;\\nclass BookMyShow {\\npublic:\\n    const static int maxn=1e5+10;\\n    ll seg[maxn<<2],mx[maxn<<2],lzy[maxn<<2],len[maxn<<2];\\n    int n,m;\\n    void init(int cur,int l,int r,int val)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=val;\\n            mx[cur]=val;\\n            len[cur]=1;\\n            return;\\n        }\\n        len[cur]=r-l;\\n        int mid=(l+r)>>1;\\n        init(cur<<1,l,mid,val);\\n        init(cur<<1|1,mid,r,val);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n        mx[cur]=max(mx[cur<<1],mx[cur<<1|1]);\\n        return;\\n    }\\n    void pushdown(int cur)\\n    {\\n        if(lzy[cur])\\n        {\\n            int l=cur<<1,r=cur<<1|1;\\n            if(lzy[cur]==1)\\n            {\\n                seg[l]=seg[r]=mx[l]=mx[r]=0;\\n                lzy[l]=lzy[r]=1;\\n            }else\\n            {\\n                seg[l]-=lzy[l]*len[l];\\n                mx[l]-=lzy[l];\\n                seg[r]-=lzy[r]*len[r];\\n                mx[r]-=lzy[r];\\n                lzy[l]=lzy[cur];\\n                lzy[r]=lzy[cur];\\n            }\\n            lzy[cur]=0;\\n        }\\n        return;\\n    }\\n    pair<int,int> query_mx(int cur,int l,int r,int target)\\n    {\\n        if(l+1==r)\\n            return {l,mx[cur]};\\n        int mid=(l+r)>>1;\\n        pushdown(cur);\\n        if(mx[cur<<1]>=target)return query_mx(cur<<1,l,mid,target);\\n        return query_mx(cur<<1|1,mid,r,target);\\n    }\\n    void update(int cur,int l,int r,int ql,int qr,int val)\\n    {\\n        if(ql<=l&&r<=qr)\\n        {\\n            if(val==1)\\n            {\\n                seg[cur]=0;\\n                lzy[cur]=1;\\n                mx[cur]=0;\\n            }else\\n            {\\n                seg[cur]+=val*len[cur];\\n                lzy[cur]+=val;\\n                mx[cur]+=val;\\n            }\\n            return;\\n        }\\n        if(ql>=r||qr<=l)return;\\n        int mid=(l+r)>>1;\\n        pushdown(cur);\\n        update(cur<<1,l,mid,ql,qr,val);\\n        update(cur<<1|1,mid,r,ql,qr,val);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n        mx[cur]=max(mx[cur<<1],mx[cur<<1|1]);\\n        return;\\n    }\\n    int query_tot(int cur,int l,int r,int target)\\n    {\\n        if(l+1==r)return l;\\n        int mid=(l+r)>>1;\\n        if(seg[cur<<1]>=target)return query_tot(cur<<1,l,mid,target);\\n        return query_tot(cur<<1|1,mid,r,target-seg[cur<<1]);\\n    }\\n    ll get_tot(int cur,int l,int r,int ql,int qr)\\n    {\\n        if(ql<=l&&r<=qr)return seg[cur];\\n        if(l>=qr||r<=ql)return 0;\\n        int mid=(l+r)>>1;\\n        return get_tot(cur<<1,l,mid,ql,qr)+get_tot(cur<<1|1,mid,r,ql,qr);\\n    }\\n    BookMyShow(int n, int m) {\\n        this->n=n;\\n        this->m=m;\\n        init(1,1,n+1,m);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        maxRow+=1;\\n        if(mx[1]<k)return {};\\n        pair<int,int>res=query_mx(1,1,n+1,k);\\n        if(res.first>maxRow)return {};\\n        update(1,1,n+1,res.first,res.first+1,-k);\\n        return {res.first-1,m-res.second};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if(seg[1]<k)return false;\\n        maxRow+=1;\\n        int layer=query_tot(1,1,n+1,k);\\n        ll total=get_tot(1,1,n+1,1,layer);\\n        k-=total;\\n        if(layer>maxRow)return false;\\n        update(1,1,n+1,1,layer,1);\\n        update(1,1,n+1,layer,layer+1,-k);\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass BookMyShow {\\npublic:\\n    const static int maxn=1e5+10;\\n    ll seg[maxn<<2],mx[maxn<<2],lzy[maxn<<2],len[maxn<<2];\\n    int n,m;\\n    void init(int cur,int l,int r,int val)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=val;\\n            mx[cur]=val;\\n            len[cur]=1;\\n            return;\\n        }\\n        len[cur]=r-l;\\n        int mid=(l+r)>>1;\\n        init(cur<<1,l,mid,val);\\n        init(cur<<1|1,mid,r,val);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n        mx[cur]=max(mx[cur<<1],mx[cur<<1|1]);\\n        return;\\n    }\\n    void pushdown(int cur)\\n    {\\n        if(lzy[cur])\\n        {\\n            int l=cur<<1,r=cur<<1|1;\\n            if(lzy[cur]==1)\\n            {\\n                seg[l]=seg[r]=mx[l]=mx[r]=0;\\n                lzy[l]=lzy[r]=1;\\n            }else\\n            {\\n                seg[l]-=lzy[l]*len[l];\\n                mx[l]-=lzy[l];\\n                seg[r]-=lzy[r]*len[r];\\n                mx[r]-=lzy[r];\\n                lzy[l]=lzy[cur];\\n                lzy[r]=lzy[cur];\\n            }\\n            lzy[cur]=0;\\n        }\\n        return;\\n    }\\n    pair<int,int> query_mx(int cur,int l,int r,int target)\\n    {\\n        if(l+1==r)\\n            return {l,mx[cur]};\\n        int mid=(l+r)>>1;\\n        pushdown(cur);\\n        if(mx[cur<<1]>=target)return query_mx(cur<<1,l,mid,target);\\n        return query_mx(cur<<1|1,mid,r,target);\\n    }\\n    void update(int cur,int l,int r,int ql,int qr,int val)\\n    {\\n        if(ql<=l&&r<=qr)\\n        {\\n            if(val==1)\\n            {\\n                seg[cur]=0;\\n                lzy[cur]=1;\\n                mx[cur]=0;\\n            }else\\n            {\\n                seg[cur]+=val*len[cur];\\n                lzy[cur]+=val;\\n                mx[cur]+=val;\\n            }\\n            return;\\n        }\\n        if(ql>=r||qr<=l)return;\\n        int mid=(l+r)>>1;\\n        pushdown(cur);\\n        update(cur<<1,l,mid,ql,qr,val);\\n        update(cur<<1|1,mid,r,ql,qr,val);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n        mx[cur]=max(mx[cur<<1],mx[cur<<1|1]);\\n        return;\\n    }\\n    int query_tot(int cur,int l,int r,int target)\\n    {\\n        if(l+1==r)return l;\\n        int mid=(l+r)>>1;\\n        if(seg[cur<<1]>=target)return query_tot(cur<<1,l,mid,target);\\n        return query_tot(cur<<1|1,mid,r,target-seg[cur<<1]);\\n    }\\n    ll get_tot(int cur,int l,int r,int ql,int qr)\\n    {\\n        if(ql<=l&&r<=qr)return seg[cur];\\n        if(l>=qr||r<=ql)return 0;\\n        int mid=(l+r)>>1;\\n        return get_tot(cur<<1,l,mid,ql,qr)+get_tot(cur<<1|1,mid,r,ql,qr);\\n    }\\n    BookMyShow(int n, int m) {\\n        this->n=n;\\n        this->m=m;\\n        init(1,1,n+1,m);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        maxRow+=1;\\n        if(mx[1]<k)return {};\\n        pair<int,int>res=query_mx(1,1,n+1,k);\\n        if(res.first>maxRow)return {};\\n        update(1,1,n+1,res.first,res.first+1,-k);\\n        return {res.first-1,m-res.second};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if(seg[1]<k)return false;\\n        maxRow+=1;\\n        int layer=query_tot(1,1,n+1,k);\\n        ll total=get_tot(1,1,n+1,1,layer);\\n        k-=total;\\n        if(layer>maxRow)return false;\\n        update(1,1,n+1,1,layer,1);\\n        update(1,1,n+1,layer,layer+1,-k);\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100197,
                "title": "java-segment-tree-max-sum-linkedlist",
                "content": "1. We need Segment Trees to avoid linear probing. So we would be able to find out the first row with enough free seats. Also we would be able to find out is there enough free seats in rows from 0 to maxRow. All these actions we can do in O(logN)\\n2.  For gather request we can easily update only one node and all it\\'s parents. This would take O(logN).\\n3. For scatter we firstly should find at most k nodes. Using linear scanning it can costs us O(N). To reduce time complexity we can use doubly-linked lists and remove nodes for rows with no empty seats. \\n4. After finding out these rows we should update segment tree nodes for them and all their parents. If we make it separately for each node then overall complexity will be O(k\\\\*logN). We can avoid it by updating all parent nodes exactly once. And complexity will be O(min(k*logN,N)).\\n\\n```\\nimport java.util.ArrayDeque;\\nimport java.util.Arrays;\\nimport java.util.Deque;\\n\\npublic class BookMyShow {\\n    private final int n, m;\\n\\n    // max number of seats in a row for some segment of the rows\\n    private final int[] max;\\n\\n    // total number of seats for some segment of the rows\\n    private final long[] total;\\n\\n    // number of rows with zero free places on the left and on the right\\n    // using this to quickly skip already zero rows\\n    // actual nodes are placed in [1,this.n], the first and last element only shows there the first non-zero row\\n    private final int[] numZerosRight, numZerosLeft;\\n\\n    public BookMyShow(int n, int m) {\\n        this.n = nextPow2(n); // make n to be a power of 2 (for simplicity)\\n        this.m = m;\\n        this.max = new int[this.n * 2 - 1]; // segment tree for max number of seats in a row\\n        this.total = new long[this.n * 2 - 1]; // total number of seats for a segment of the rows\\n        this.numZerosRight = new int[this.n + 2];\\n        this.numZerosLeft = new int[this.n + 2];\\n\\n        // initialize max and total, for max we firstly set values to m\\n        // segments of size 1 are placed starting from this.n - 1\\n        Arrays.fill(max, this.n - 1, this.n + n - 1, m);\\n        Arrays.fill(total, this.n - 1, this.n + n - 1, m);\\n\\n        // calculate values of max and total for segments based on values of their children\\n        for (int i = this.n - 2, i1 = i * 2 + 1, i2 = i * 2 + 2; i >= 0; i--, i1 -= 2, i2 -= 2) {\\n            max[i] = Math.max(max[i1], max[i2]);\\n            total[i] = total[i1] + total[i2];\\n        }\\n    }\\n\\n    public int[] gather(int k, int maxRow) {\\n        //find most left row with enough free places\\n        int mostLeft = mostLeft(0, 0, n, k, maxRow + 1);\\n        if (mostLeft == -1) return new int[0];\\n\\n        // get corresponding segment tree node\\n        int v = n - 1 + mostLeft;\\n        int[] ans = {mostLeft, m - max[v]};\\n\\n        // update max and total for this node\\n        max[v] -= k;\\n        total[v] -= k;\\n\\n        //until this is a root of segment tree we update its parent\\n        while (v != 0) {\\n            v = (v - 1) / 2;\\n            max[v] = Math.max(max[v * 2 + 1], max[v * 2 + 2]);\\n            total[v] = total[v * 2 + 1] + total[v * 2 + 2];\\n        }\\n        return ans;\\n    }\\n\\n    private int mostLeft(int v, int l, int r, int k, int qr) {\\n        if (l >= qr || max[v] < k) return -1;\\n        if (l == r - 1) return l;\\n        int mid = (l + r) / 2;\\n        int left = mostLeft(v * 2 + 1, l, mid, k, qr);\\n        if (left != -1) return left;\\n        return mostLeft(v * 2 + 2, mid, r, k, qr);\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n        // find total number of free places in the rows [0; maxRow+1)\\n        long sum = total(0, 0, n, maxRow + 1);\\n        if (sum < k) return false;\\n        int i = 0;\\n\\n        //to don\\'t update parent for both of its children we use a queue\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        while (k != 0) {\\n            i = i + numZerosRight[i] + 1;\\n            int v = n - 1 + i - 1;\\n            int spent = Math.min(k, max[v]);\\n            k -= spent;\\n            max[v] -= spent;\\n            total[v] -= spent;\\n            if (max[v] == 0) {\\n                // update numZerosRight and numZerosLeft\\n                numZerosRight[i - numZerosLeft[i] - 1] += numZerosRight[i] + 1;\\n                numZerosLeft[i + numZerosRight[i] + 1] += numZerosLeft[i] + 1;\\n            }\\n            if (v != 0) {\\n                v = (v - 1) / 2;\\n                // if we already have the parent node in the queue we don\\'t need to update it\\n                if (deque.isEmpty() || deque.peekLast() != v) deque.addLast(v);\\n            }\\n        }\\n\\n        // update max and total\\n        while (!deque.isEmpty()) {\\n            int v = deque.pollFirst();\\n            max[v] = Math.max(max[v * 2 + 1], max[v * 2 + 2]);\\n            total[v] = total[v * 2 + 1] + total[v * 2 + 2];\\n            if (v != 0) {\\n                v = (v - 1) / 2;\\n                // if we already have the parent node in the queue we don\\'t need to update it\\n                if (deque.isEmpty() || deque.peekLast() != v) deque.addLast(v);\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // find sum of [ql, qr)\\n    private long total(int v, int l, int r, int qr) {\\n        if (l >= qr) return 0;\\n        if (r <= qr) return total[v];\\n        int mid = (l + r) / 2;\\n        return total(v * 2 + 1, l, mid, qr) + total(v * 2 + 2, mid, r, qr);\\n    }\\n\\n    private static int nextPow2(int n) {\\n        if ((n & (n - 1)) == 0) return n;\\n        else return Integer.highestOneBit(n) << 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\nimport java.util.ArrayDeque;\\nimport java.util.Arrays;\\nimport java.util.Deque;\\n\\npublic class BookMyShow {\\n    private final int n, m;\\n\\n    // max number of seats in a row for some segment of the rows\\n    private final int[] max;\\n\\n    // total number of seats for some segment of the rows\\n    private final long[] total;\\n\\n    // number of rows with zero free places on the left and on the right\\n    // using this to quickly skip already zero rows\\n    // actual nodes are placed in [1,this.n], the first and last element only shows there the first non-zero row\\n    private final int[] numZerosRight, numZerosLeft;\\n\\n    public BookMyShow(int n, int m) {\\n        this.n = nextPow2(n); // make n to be a power of 2 (for simplicity)\\n        this.m = m;\\n        this.max = new int[this.n * 2 - 1]; // segment tree for max number of seats in a row\\n        this.total = new long[this.n * 2 - 1]; // total number of seats for a segment of the rows\\n        this.numZerosRight = new int[this.n + 2];\\n        this.numZerosLeft = new int[this.n + 2];\\n\\n        // initialize max and total, for max we firstly set values to m\\n        // segments of size 1 are placed starting from this.n - 1\\n        Arrays.fill(max, this.n - 1, this.n + n - 1, m);\\n        Arrays.fill(total, this.n - 1, this.n + n - 1, m);\\n\\n        // calculate values of max and total for segments based on values of their children\\n        for (int i = this.n - 2, i1 = i * 2 + 1, i2 = i * 2 + 2; i >= 0; i--, i1 -= 2, i2 -= 2) {\\n            max[i] = Math.max(max[i1], max[i2]);\\n            total[i] = total[i1] + total[i2];\\n        }\\n    }\\n\\n    public int[] gather(int k, int maxRow) {\\n        //find most left row with enough free places\\n        int mostLeft = mostLeft(0, 0, n, k, maxRow + 1);\\n        if (mostLeft == -1) return new int[0];\\n\\n        // get corresponding segment tree node\\n        int v = n - 1 + mostLeft;\\n        int[] ans = {mostLeft, m - max[v]};\\n\\n        // update max and total for this node\\n        max[v] -= k;\\n        total[v] -= k;\\n\\n        //until this is a root of segment tree we update its parent\\n        while (v != 0) {\\n            v = (v - 1) / 2;\\n            max[v] = Math.max(max[v * 2 + 1], max[v * 2 + 2]);\\n            total[v] = total[v * 2 + 1] + total[v * 2 + 2];\\n        }\\n        return ans;\\n    }\\n\\n    private int mostLeft(int v, int l, int r, int k, int qr) {\\n        if (l >= qr || max[v] < k) return -1;\\n        if (l == r - 1) return l;\\n        int mid = (l + r) / 2;\\n        int left = mostLeft(v * 2 + 1, l, mid, k, qr);\\n        if (left != -1) return left;\\n        return mostLeft(v * 2 + 2, mid, r, k, qr);\\n    }\\n\\n    public boolean scatter(int k, int maxRow) {\\n        // find total number of free places in the rows [0; maxRow+1)\\n        long sum = total(0, 0, n, maxRow + 1);\\n        if (sum < k) return false;\\n        int i = 0;\\n\\n        //to don\\'t update parent for both of its children we use a queue\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        while (k != 0) {\\n            i = i + numZerosRight[i] + 1;\\n            int v = n - 1 + i - 1;\\n            int spent = Math.min(k, max[v]);\\n            k -= spent;\\n            max[v] -= spent;\\n            total[v] -= spent;\\n            if (max[v] == 0) {\\n                // update numZerosRight and numZerosLeft\\n                numZerosRight[i - numZerosLeft[i] - 1] += numZerosRight[i] + 1;\\n                numZerosLeft[i + numZerosRight[i] + 1] += numZerosLeft[i] + 1;\\n            }\\n            if (v != 0) {\\n                v = (v - 1) / 2;\\n                // if we already have the parent node in the queue we don\\'t need to update it\\n                if (deque.isEmpty() || deque.peekLast() != v) deque.addLast(v);\\n            }\\n        }\\n\\n        // update max and total\\n        while (!deque.isEmpty()) {\\n            int v = deque.pollFirst();\\n            max[v] = Math.max(max[v * 2 + 1], max[v * 2 + 2]);\\n            total[v] = total[v * 2 + 1] + total[v * 2 + 2];\\n            if (v != 0) {\\n                v = (v - 1) / 2;\\n                // if we already have the parent node in the queue we don\\'t need to update it\\n                if (deque.isEmpty() || deque.peekLast() != v) deque.addLast(v);\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // find sum of [ql, qr)\\n    private long total(int v, int l, int r, int qr) {\\n        if (l >= qr) return 0;\\n        if (r <= qr) return total[v];\\n        int mid = (l + r) / 2;\\n        return total(v * 2 + 1, l, mid, qr) + total(v * 2 + 2, mid, r, qr);\\n    }\\n\\n    private static int nextPow2(int n) {\\n        if ((n & (n - 1)) == 0) return n;\\n        else return Integer.highestOneBit(n) << 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098570,
                "title": "java-fenwick-tree-segment-tree",
                "content": "```\\nclass BookMyShow {\\n    long[] bit;\\n    SegmentTree st;\\n    int m;\\n    public BookMyShow(int n, int m) {\\n        bit=new long[n+1];\\n        int[] a=new int[n];\\n        st=new SegmentTree(a);\\n        this.m=m;\\n        for(int i=0;i<n;i++)\\n        {\\n            add(bit,i,m);\\n        }\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        \\n        int f=st.helper(m-k);\\n        if(f==-1 || f>maxRow)\\n            return new int[0];\\n        int v=st.min(f);\\n        //update fenwick and segment trees accordingly\\n        add(bit,f,-k);\\n        st.update(f,v+k);\\n        return new int[]{f,v};\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        //fenwick tree used to sum the remaining capacity\\n        if(sum(bit,maxRow)<k)\\n            return false;\\n        \\n        while(k>0)\\n        {\\n            //Segment tree is used to get the first free spot\\n            int f=st.helper(m-1);\\n            if(f==-1 || f>maxRow)\\n                return false;\\n            int v=st.min(f);\\n            int val=Math.min(k,m-v);\\n            k-=val;\\n            st.update(f,v+val);\\n            add(bit,f,-val);\\n        }\\n        return true;\\n    }\\n    \\n    public long sum(long[] arr, int i)\\n    {\\n        long sum=0;\\n        for(++i;i>0;i-=(i&-i))\\n        {\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    public void add(long[] arr, int i, long v)\\n    {\\n        int n=arr.length;\\n        for(i++;i<n;i+=(i&-i))\\n        {\\n            arr[i]+=v;\\n        }\\n    }\\n    \\n    \\n    class SegmentTree\\n    {\\n        int H;\\n        int[] vals;\\n        public SegmentTree(int[] a)\\n        {\\n            int n=Integer.highestOneBit(Math.max(a.length-1,1))<<2;\\n            H=n>>1;\\n            vals=new int[n];\\n            Arrays.fill(vals,Integer.MAX_VALUE);\\n            \\n            for(int i=0;i<a.length;i++)\\n            {\\n                vals[i+H]=a[i];\\n            }\\n            \\n            for(int i=H-1;i>0;i--)\\n            {\\n                propogate(i);\\n            }\\n        }\\n        \\n        public void propogate(int i)\\n        {\\n            vals[i]=Math.min(vals[2*i], vals[(2*i)+1]);\\n        }\\n        \\n        public int min(int l)\\n        {\\n            l+=H;\\n            return vals[l];\\n        }\\n        public void update(int pos, int v)\\n        {\\n            vals[H+pos]=v;\\n            \\n            for(int i=(H+pos)>>1;i>=1;i>>=1)\\n            {\\n                propogate(i);\\n            }\\n            \\n        }\\n        public int helper(int l)\\n        {\\n            int cur=H;\\n            \\n            while(true)\\n            {\\n                if(vals[cur]<=l)\\n                {\\n                    if(cur>=H)\\n                    {\\n                        return cur-H;\\n                    }\\n                    cur=cur*2;\\n                }\\n                else {\\n                    cur++;\\n                    if((cur&(cur-1))==0)\\n                        return -1;\\n                    if((cur&1)==0)\\n                        cur>>=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\n    long[] bit;\\n    SegmentTree st;\\n    int m;\\n    public BookMyShow(int n, int m) {\\n        bit=new long[n+1];\\n        int[] a=new int[n];\\n        st=new SegmentTree(a);\\n        this.m=m;\\n        for(int i=0;i<n;i++)\\n        {\\n            add(bit,i,m);\\n        }\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        \\n        int f=st.helper(m-k);\\n        if(f==-1 || f>maxRow)\\n            return new int[0];\\n        int v=st.min(f);\\n        //update fenwick and segment trees accordingly\\n        add(bit,f,-k);\\n        st.update(f,v+k);\\n        return new int[]{f,v};\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        //fenwick tree used to sum the remaining capacity\\n        if(sum(bit,maxRow)<k)\\n            return false;\\n        \\n        while(k>0)\\n        {\\n            //Segment tree is used to get the first free spot\\n            int f=st.helper(m-1);\\n            if(f==-1 || f>maxRow)\\n                return false;\\n            int v=st.min(f);\\n            int val=Math.min(k,m-v);\\n            k-=val;\\n            st.update(f,v+val);\\n            add(bit,f,-val);\\n        }\\n        return true;\\n    }\\n    \\n    public long sum(long[] arr, int i)\\n    {\\n        long sum=0;\\n        for(++i;i>0;i-=(i&-i))\\n        {\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    public void add(long[] arr, int i, long v)\\n    {\\n        int n=arr.length;\\n        for(i++;i<n;i+=(i&-i))\\n        {\\n            arr[i]+=v;\\n        }\\n    }\\n    \\n    \\n    class SegmentTree\\n    {\\n        int H;\\n        int[] vals;\\n        public SegmentTree(int[] a)\\n        {\\n            int n=Integer.highestOneBit(Math.max(a.length-1,1))<<2;\\n            H=n>>1;\\n            vals=new int[n];\\n            Arrays.fill(vals,Integer.MAX_VALUE);\\n            \\n            for(int i=0;i<a.length;i++)\\n            {\\n                vals[i+H]=a[i];\\n            }\\n            \\n            for(int i=H-1;i>0;i--)\\n            {\\n                propogate(i);\\n            }\\n        }\\n        \\n        public void propogate(int i)\\n        {\\n            vals[i]=Math.min(vals[2*i], vals[(2*i)+1]);\\n        }\\n        \\n        public int min(int l)\\n        {\\n            l+=H;\\n            return vals[l];\\n        }\\n        public void update(int pos, int v)\\n        {\\n            vals[H+pos]=v;\\n            \\n            for(int i=(H+pos)>>1;i>=1;i>>=1)\\n            {\\n                propogate(i);\\n            }\\n            \\n        }\\n        public int helper(int l)\\n        {\\n            int cur=H;\\n            \\n            while(true)\\n            {\\n                if(vals[cur]<=l)\\n                {\\n                    if(cur>=H)\\n                    {\\n                        return cur-H;\\n                    }\\n                    cur=cur*2;\\n                }\\n                else {\\n                    cur++;\\n                    if((cur&(cur-1))==0)\\n                        return -1;\\n                    if((cur&1)==0)\\n                        cur>>=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097631,
                "title": "segment-tree-with-binary-search",
                "content": "```\\n\\n#define ll long long  \\nclass BookMyShow {\\npublic:\\n//Segment tree for gather\\nll t[50005*4];\\n\\nvoid build(vector<ll>&a, ll v, ll tl, ll tr) {\\n    if (tl == tr) {\\n        t[v] = a[tl];\\n    } else {\\n        ll tm = (tl + tr) / 2;\\n        build(a, v*2, tl, tm);\\n        build(a, v*2+1, tm+1, tr);\\n        t[v] = max(t[v*2],t[v*2+1]);\\n    }\\n}\\n\\nll ma(ll v, ll tl, ll tr, ll l, ll r) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr) {\\n        return t[v];\\n    }\\n    ll tm = (tl + tr) / 2;\\n    return max(ma(v*2, tl, tm, l, min(r, tm)),ma(v*2+1, tm+1, tr, max(l, tm+1), r));\\n}\\n\\nvoid update(ll v, ll tl, ll tr, ll pos, ll new_val) {\\n    if (tl == tr) {\\n        t[v] = new_val;\\n    } else {\\n        ll tm = (tl + tr) / 2;\\n        if (pos <= tm)\\n            update(v*2, tl, tm, pos, new_val);\\n        else\\n            update(v*2+1, tm+1, tr, pos, new_val);\\n        t[v] = max(t[v*2],t[v*2+1]);\\n    }\\n}\\n    \\n\\n    \\n    \\n //Segment Tree for scatter\\nll t1[50005*4];\\n\\nvoid build1(vector<ll>&a, ll v, ll tl, ll tr) {\\n    if (tl == tr) {\\n        t1[v] = a[tl];\\n    } else {\\n        int tm = (tl + tr) / 2;\\n        build1(a, v*2, tl, tm);\\n        build1(a, v*2+1, tm+1, tr);\\n        t1[v] = t1[v*2]+t1[v*2+1];\\n    }\\n}\\n\\nll sum(ll v, ll tl, ll tr, ll l, ll r) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr) {\\n        return t1[v];\\n    }\\n    ll tm = (tl + tr) / 2;\\n    return sum(v*2, tl, tm, l, min(r, tm))+sum(v*2+1, tm+1, tr, max(l, tm+1), r);\\n}\\n\\nvoid update1(ll v, ll tl, ll tr, ll pos, ll new_val) {\\n    if (tl == tr) {\\n        t1[v] = new_val;\\n    } else {\\n        ll tm = (tl + tr) / 2;\\n        if (pos <= tm)\\n            update1(v*2, tl, tm, pos, new_val);\\n        else\\n            update1(v*2+1, tm+1, tr, pos, new_val);\\n        t1[v] = t1[v*2]+t1[v*2+1];\\n    }\\n}\\n\\n    \\n  \\n    vector<ll>v;\\n    ll ind,m1;\\n    BookMyShow(int n, int m) {\\n        v.resize(n);\\n        for(int i=0;i<n;i++)\\n            v[i]=m;\\n        build(v,1,0,n-1);\\n        build1(v,1,0,n-1);\\n        ind=0;\\n        m1=m;\\n      //  sum=1LL*m*n;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int hi=maxRow,lo=0;\\n        int n=v.size();\\n        vector<int>ans;\\n        if(ma(1,0,n-1,0,maxRow)<k)\\n            return ans;\\n        //binary search to find the first row.\\n        while(1)\\n        {\\n            if(hi-lo<2)\\n            {\\n                ll y=v[lo];\\n                if(y>=k)\\n                {\\n                    if(lo<=maxRow)\\n                    {\\n                        ans.push_back(lo);\\n                        ans.push_back(m1-y);\\n                        v[lo]=y-k;\\n                        update(1,0,n-1,lo,y-k);\\n                        update1(1,0,n-1,lo,y-k);\\n                        \\n                    }\\n                    else\\n                        return ans;\\n                }\\n                else\\n                {\\n                    if(hi<=maxRow)\\n                    {\\n                        y=v[hi];\\n                        ans.push_back(hi);\\n                        ans.push_back(m1-y);\\n                        v[hi]=y-k;\\n                        update(1,0,n-1,hi,y-k);\\n                        update1(1,0,n-1,hi,y-k);\\n                    }\\n                }\\n                return ans;\\n            }\\n            ll mid=(hi+lo)/2;\\n            if(ma(1,0,n-1,lo,mid)>=k)\\n                hi=mid;\\n            else\\n                lo=mid;\\n        }\\n    }\\n    bool scatter(int k, int maxRow) {\\n        ll j=ind,k1=k;\\n        int n=v.size();\\n        if(sum(1,0,n-1,0,maxRow)<k)\\n            return 0;\\n            int j1=ind;\\n            k1=k;\\n            while(k1)\\n            {\\n                int x=min(v[j1],k1);\\n                k1-=x;\\n                update(1,0,n-1,j1,v[j1]-x);\\n                update1(1,0,n-1,j1,v[j1]-x);\\n                v[j1]-=x;\\n                if(v[j1]==0)\\n                    j1++;\\n            }\\n            ind=j1;\\n            return true;\\n\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n\\n#define ll long long  \\nclass BookMyShow {\\npublic:\\n//Segment tree for gather\\nll t[50005*4];\\n\\nvoid build(vector<ll>&a, ll v, ll tl, ll tr) {\\n    if (tl == tr) {\\n        t[v] = a[tl];\\n    } else {\\n        ll tm = (tl + tr) / 2;\\n        build(a, v*2, tl, tm);\\n        build(a, v*2+1, tm+1, tr);\\n        t[v] = max(t[v*2],t[v*2+1]);\\n    }\\n}\\n\\nll ma(ll v, ll tl, ll tr, ll l, ll r) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr) {\\n        return t[v];\\n    }\\n    ll tm = (tl + tr) / 2;\\n    return max(ma(v*2, tl, tm, l, min(r, tm)),ma(v*2+1, tm+1, tr, max(l, tm+1), r));\\n}\\n\\nvoid update(ll v, ll tl, ll tr, ll pos, ll new_val) {\\n    if (tl == tr) {\\n        t[v] = new_val;\\n    } else {\\n        ll tm = (tl + tr) / 2;\\n        if (pos <= tm)\\n            update(v*2, tl, tm, pos, new_val);\\n        else\\n            update(v*2+1, tm+1, tr, pos, new_val);\\n        t[v] = max(t[v*2],t[v*2+1]);\\n    }\\n}\\n    \\n\\n    \\n    \\n //Segment Tree for scatter\\nll t1[50005*4];\\n\\nvoid build1(vector<ll>&a, ll v, ll tl, ll tr) {\\n    if (tl == tr) {\\n        t1[v] = a[tl];\\n    } else {\\n        int tm = (tl + tr) / 2;\\n        build1(a, v*2, tl, tm);\\n        build1(a, v*2+1, tm+1, tr);\\n        t1[v] = t1[v*2]+t1[v*2+1];\\n    }\\n}\\n\\nll sum(ll v, ll tl, ll tr, ll l, ll r) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr) {\\n        return t1[v];\\n    }\\n    ll tm = (tl + tr) / 2;\\n    return sum(v*2, tl, tm, l, min(r, tm))+sum(v*2+1, tm+1, tr, max(l, tm+1), r);\\n}\\n\\nvoid update1(ll v, ll tl, ll tr, ll pos, ll new_val) {\\n    if (tl == tr) {\\n        t1[v] = new_val;\\n    } else {\\n        ll tm = (tl + tr) / 2;\\n        if (pos <= tm)\\n            update1(v*2, tl, tm, pos, new_val);\\n        else\\n            update1(v*2+1, tm+1, tr, pos, new_val);\\n        t1[v] = t1[v*2]+t1[v*2+1];\\n    }\\n}\\n\\n    \\n  \\n    vector<ll>v;\\n    ll ind,m1;\\n    BookMyShow(int n, int m) {\\n        v.resize(n);\\n        for(int i=0;i<n;i++)\\n            v[i]=m;\\n        build(v,1,0,n-1);\\n        build1(v,1,0,n-1);\\n        ind=0;\\n        m1=m;\\n      //  sum=1LL*m*n;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int hi=maxRow,lo=0;\\n        int n=v.size();\\n        vector<int>ans;\\n        if(ma(1,0,n-1,0,maxRow)<k)\\n            return ans;\\n        //binary search to find the first row.\\n        while(1)\\n        {\\n            if(hi-lo<2)\\n            {\\n                ll y=v[lo];\\n                if(y>=k)\\n                {\\n                    if(lo<=maxRow)\\n                    {\\n                        ans.push_back(lo);\\n                        ans.push_back(m1-y);\\n                        v[lo]=y-k;\\n                        update(1,0,n-1,lo,y-k);\\n                        update1(1,0,n-1,lo,y-k);\\n                        \\n                    }\\n                    else\\n                        return ans;\\n                }\\n                else\\n                {\\n                    if(hi<=maxRow)\\n                    {\\n                        y=v[hi];\\n                        ans.push_back(hi);\\n                        ans.push_back(m1-y);\\n                        v[hi]=y-k;\\n                        update(1,0,n-1,hi,y-k);\\n                        update1(1,0,n-1,hi,y-k);\\n                    }\\n                }\\n                return ans;\\n            }\\n            ll mid=(hi+lo)/2;\\n            if(ma(1,0,n-1,lo,mid)>=k)\\n                hi=mid;\\n            else\\n                lo=mid;\\n        }\\n    }\\n    bool scatter(int k, int maxRow) {\\n        ll j=ind,k1=k;\\n        int n=v.size();\\n        if(sum(1,0,n-1,0,maxRow)<k)\\n            return 0;\\n            int j1=ind;\\n            k1=k;\\n            while(k1)\\n            {\\n                int x=min(v[j1],k1);\\n                k1-=x;\\n                update(1,0,n-1,j1,v[j1]-x);\\n                update1(1,0,n-1,j1,v[j1]-x);\\n                v[j1]-=x;\\n                if(v[j1]==0)\\n                    j1++;\\n            }\\n            ind=j1;\\n            return true;\\n\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2095413,
                "title": "java-segment-tree-with-thought-process",
                "content": "```\\n// note to self: \\n// generally range updates are done when multiple leaf nodes are to be changed in a segment tree\\n// and this range update problem by itself is not very optimal\\n// this is where concept of lazy propogation helps and makes range update query logarithmic\\n// but in order to do lazy propogation, one needs to be able to efficiently recompute the current node using the lazy attribute\\n// in the push method, which sadly cannot be done for attributes maxi of this problem as we cant know what will be the new maxi value after lazy propogation \\n// adjustment using the lazy attribute.\\n\\n// so here we have to manually do point by point updates in case of a scatter operation, and to be able to do that with some degree of efficiency\\n// we keep an extra array tracking current available seats in each row apart from the segment tree array to formulate our commands properly to be given \\n// to segment tree for point update\\n\\n// also we can use a more easy to process update, instead of asking tree to reduce values of maxi and total itself by smartly recursing, we adopted\\n// a very similar point update query which just sets value in given row to provided value\\n\\nclass BookMyShow {\\n\\n    class STNode{\\n        long maxi,total;    \\n        public STNode(long seatCount){\\n            maxi = seatCount;\\n            total = seatCount;\\n        }\\n\\n        public STNode(long maxi,long total){\\n            this.maxi = maxi;\\n            this.total = total;\\n        }\\n\\n        public STNode(){\\n            maxi = 0;\\n            total = 0;\\n        }\\n    }\\n\\n    int n,m;\\n    STNode[] segTree;\\n    int[] availableSeats;\\n    \\n    \\n    public BookMyShow(int n, int m) {\\n        this.n = n;\\n        this.m = m;\\n        this.segTree = new STNode[4*n];\\n        this.buildSegTree(1,0,n-1);\\n        this.availableSeats = new int[n];\\n        Arrays.fill(this.availableSeats,m);\\n    }\\n    \\n    public STNode merge(STNode a, STNode b){\\n        return new STNode((long)Math.max(a.maxi,b.maxi),(long)(a.total+b.total));    \\n    }\\n    \\n    public void buildSegTree(int id,int l,int r){\\n            if(l>r) return;\\n            if(l==r){\\n                segTree[id] = new STNode(m);\\n            }\\n            else{\\n                var mid = l+(r-l)/2;\\n                buildSegTree(id*2,l,mid);\\n                buildSegTree(1+id*2,mid+1,r);\\n                segTree[id] = merge(segTree[id*2],segTree[2*id+1]);\\n            }\\n    }\\n    \\n    public int[] gatherQuery(int id, int l, int r, int seatsNeeded, int maxRow){\\n//         this first bit of if check is not something i have seen before, generally we are able to do early return \\n//         in conditions like l<=lq<=rq<=r , but here max of segment is used to do early return (that too only in less than seatsNeeded case)\\n//         for maxi>=seatsNeeded case, you still need to query further \\uD83D\\uDE35\\n        if(segTree[id].maxi<seatsNeeded || maxRow<l){\\n            return new int[0];\\n        }\\n        \\n        if(l==r){\\n            if (this.segTree[id].total>=seatsNeeded){\\n                var res = new int[2];\\n                res[0] = l;\\n                res[1] = m-(int)this.segTree[id].total;\\n                return res;\\n            }\\n            else{\\n                return new int[0];\\n            }\\n        }\\n        int mid = l+(r-l)/2;\\n        var temp = gatherQuery(2*id,l,mid,seatsNeeded,maxRow);\\n        if (temp.length==0){\\n            return gatherQuery(2*id+1,mid+1,r,seatsNeeded,maxRow);\\n        }\\n        else{\\n            return temp;\\n        }\\n    }\\n    \\n    public long totalQuery(int id, int l, int r,int maxRow){\\n        if(maxRow<l){\\n            return 0;\\n        }\\n        if(r<=maxRow){\\n            return (long)segTree[id].total;\\n        }\\n        int mid = l+(r-l)/2;\\n        return totalQuery(2*id,l,mid,maxRow)+totalQuery(2*id+1,mid+1,r,maxRow);\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        var coords = gatherQuery(1,0,n-1,k,maxRow);\\n        if (coords.length==2){\\n            update(1,0,n-1,coords[0],this.availableSeats[coords[0]]-k);\\n        }\\n        return coords;\\n    }\\n        \\n    public void update(int id, int l, int r, int targetRow, int newVal){\\n        if (targetRow<l || targetRow>r) return;\\n        if(l==r){\\n            if (l==targetRow){\\n                this.segTree[id].maxi = newVal;\\n                this.segTree[id].total = newVal;\\n                this.availableSeats[l]=newVal;\\n            }\\n        }\\n        else{\\n            int mid = l+(r-l)/2;\\n            update(2*id,l,mid,targetRow,newVal);\\n            update(2*id+1,mid+1,r,targetRow,newVal);\\n            this.segTree[id] = merge(this.segTree[2*id],this.segTree[2*id+1]);\\n        }\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        long totalAvailable = totalQuery(1,0,n-1,maxRow);\\n        if (totalAvailable<k){\\n            return false;\\n        }\\n        for(int row=0;row<=maxRow && k!=0;row++){\\n            var maxCanGet = Math.min(k,this.availableSeats[row]);\\n            if (maxCanGet>0){   \\n                update(1,0,n-1,row,this.availableSeats[row]-maxCanGet);\\n                k-=maxCanGet;\\n            }\\n        }        \\n        return true;\\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n// note to self: \\n// generally range updates are done when multiple leaf nodes are to be changed in a segment tree\\n// and this range update problem by itself is not very optimal\\n// this is where concept of lazy propogation helps and makes range update query logarithmic\\n// but in order to do lazy propogation, one needs to be able to efficiently recompute the current node using the lazy attribute\\n// in the push method, which sadly cannot be done for attributes maxi of this problem as we cant know what will be the new maxi value after lazy propogation \\n// adjustment using the lazy attribute.\\n\\n// so here we have to manually do point by point updates in case of a scatter operation, and to be able to do that with some degree of efficiency\\n// we keep an extra array tracking current available seats in each row apart from the segment tree array to formulate our commands properly to be given \\n// to segment tree for point update\\n\\n// also we can use a more easy to process update, instead of asking tree to reduce values of maxi and total itself by smartly recursing, we adopted\\n// a very similar point update query which just sets value in given row to provided value\\n\\nclass BookMyShow {\\n\\n    class STNode{\\n        long maxi,total;    \\n        public STNode(long seatCount){\\n            maxi = seatCount;\\n            total = seatCount;\\n        }\\n\\n        public STNode(long maxi,long total){\\n            this.maxi = maxi;\\n            this.total = total;\\n        }\\n\\n        public STNode(){\\n            maxi = 0;\\n            total = 0;\\n        }\\n    }\\n\\n    int n,m;\\n    STNode[] segTree;\\n    int[] availableSeats;\\n    \\n    \\n    public BookMyShow(int n, int m) {\\n        this.n = n;\\n        this.m = m;\\n        this.segTree = new STNode[4*n];\\n        this.buildSegTree(1,0,n-1);\\n        this.availableSeats = new int[n];\\n        Arrays.fill(this.availableSeats,m);\\n    }\\n    \\n    public STNode merge(STNode a, STNode b){\\n        return new STNode((long)Math.max(a.maxi,b.maxi),(long)(a.total+b.total));    \\n    }\\n    \\n    public void buildSegTree(int id,int l,int r){\\n            if(l>r) return;\\n            if(l==r){\\n                segTree[id] = new STNode(m);\\n            }\\n            else{\\n                var mid = l+(r-l)/2;\\n                buildSegTree(id*2,l,mid);\\n                buildSegTree(1+id*2,mid+1,r);\\n                segTree[id] = merge(segTree[id*2],segTree[2*id+1]);\\n            }\\n    }\\n    \\n    public int[] gatherQuery(int id, int l, int r, int seatsNeeded, int maxRow){\\n//         this first bit of if check is not something i have seen before, generally we are able to do early return \\n//         in conditions like l<=lq<=rq<=r , but here max of segment is used to do early return (that too only in less than seatsNeeded case)\\n//         for maxi>=seatsNeeded case, you still need to query further \\uD83D\\uDE35\\n        if(segTree[id].maxi<seatsNeeded || maxRow<l){\\n            return new int[0];\\n        }\\n        \\n        if(l==r){\\n            if (this.segTree[id].total>=seatsNeeded){\\n                var res = new int[2];\\n                res[0] = l;\\n                res[1] = m-(int)this.segTree[id].total;\\n                return res;\\n            }\\n            else{\\n                return new int[0];\\n            }\\n        }\\n        int mid = l+(r-l)/2;\\n        var temp = gatherQuery(2*id,l,mid,seatsNeeded,maxRow);\\n        if (temp.length==0){\\n            return gatherQuery(2*id+1,mid+1,r,seatsNeeded,maxRow);\\n        }\\n        else{\\n            return temp;\\n        }\\n    }\\n    \\n    public long totalQuery(int id, int l, int r,int maxRow){\\n        if(maxRow<l){\\n            return 0;\\n        }\\n        if(r<=maxRow){\\n            return (long)segTree[id].total;\\n        }\\n        int mid = l+(r-l)/2;\\n        return totalQuery(2*id,l,mid,maxRow)+totalQuery(2*id+1,mid+1,r,maxRow);\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        var coords = gatherQuery(1,0,n-1,k,maxRow);\\n        if (coords.length==2){\\n            update(1,0,n-1,coords[0],this.availableSeats[coords[0]]-k);\\n        }\\n        return coords;\\n    }\\n        \\n    public void update(int id, int l, int r, int targetRow, int newVal){\\n        if (targetRow<l || targetRow>r) return;\\n        if(l==r){\\n            if (l==targetRow){\\n                this.segTree[id].maxi = newVal;\\n                this.segTree[id].total = newVal;\\n                this.availableSeats[l]=newVal;\\n            }\\n        }\\n        else{\\n            int mid = l+(r-l)/2;\\n            update(2*id,l,mid,targetRow,newVal);\\n            update(2*id+1,mid+1,r,targetRow,newVal);\\n            this.segTree[id] = merge(this.segTree[2*id],this.segTree[2*id+1]);\\n        }\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        long totalAvailable = totalQuery(1,0,n-1,maxRow);\\n        if (totalAvailable<k){\\n            return false;\\n        }\\n        for(int row=0;row<=maxRow && k!=0;row++){\\n            var maxCanGet = Math.min(k,this.availableSeats[row]);\\n            if (maxCanGet>0){   \\n                update(1,0,n-1,row,this.availableSeats[row]-maxCanGet);\\n                k-=maxCanGet;\\n            }\\n        }        \\n        return true;\\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094747,
                "title": "java-segment-tree-lazy-propogation-strict-o-log-n-time-for-both-gather-and-scatter",
                "content": "```\\nclass BookMyShow {\\n    \\n    long[] lazy;\\n    long[] max;\\n    long[] sum;\\n    long n,m;\\n    int leaves;\\n\\n    public BookMyShow(int n, int m) {\\n        this.n=n;\\n        this.m=m;\\n        leaves = (Integer.highestOneBit(n)==n) ? n : (Integer.highestOneBit(n)<<1); //next power of two\\n        int tnodes = leaves*2-1;\\n        lazy = new long[tnodes];\\n        Arrays.fill(lazy,-1);\\n        max = new long[tnodes];\\n        sum = new long[tnodes];\\n        update(0,0,leaves-1,0,n-1,m);\\n    }\\n    \\n    void set(int idx, int l, int r, long v){\\n        lazy[idx]=v;\\n        max[idx]=v;\\n        sum[idx]=v*(r-l+1);\\n    }\\n    \\n    void lazyProp(int idx, int l, int r){\\n        int mid = (l+r)/2;\\n        if(lazy[idx]!=-1){\\n            set(idx*2+1,l,mid,lazy[idx]);\\n            set(idx*2+2,mid+1,r,lazy[idx]);\\n            lazy[idx]=-1;\\n        }\\n    }\\n    \\n    void update(int idx, int l, int r, int ql, int qr, long v){\\n        if(ql<=l && qr>=r){\\n            set(idx,l,r,v);\\n            return ;\\n        }\\n        int mid = (l+r)/2;\\n        lazyProp(idx,l,r);\\n        if(ql<=mid){\\n            update(idx*2+1,l,mid,ql,qr,v);\\n        }\\n        if(qr>mid){\\n            update(idx*2+2,mid+1,r,ql,qr,v);\\n        }\\n        max[idx]=Math.max(max[idx*2+1],max[idx*2+2]);\\n        sum[idx]=sum[idx*2+1]+sum[idx*2+2];\\n    }\\n    \\n    int[] queryGather(int idx, int l, int r, int maxRow, int k){\\n        if(max[idx]<k){\\n            return new int[]{-1,-1};\\n        }\\n        if(l==r){\\n            return new int[]{l,idx};\\n        }\\n        lazyProp(idx,l,r);\\n        int mid = (l+r)/2;\\n        if(max[idx*2+1]>=k){\\n            return queryGather(idx*2+1,l,mid,maxRow, k);\\n        }\\n        if(maxRow>mid && max[idx*2+2]>=k){\\n            return queryGather(idx*2+2,mid+1,r,maxRow,k);\\n        }\\n        return new int[]{-1,-1};\\n    }\\n    \\n    int[] queryScatter(int idx, int l, int r, int maxRow, int k){\\n        if(sum[idx]<k){\\n            return new int[]{-1,-1,-1};\\n        }\\n        if(l==r){\\n            return new int[]{l,idx,k};\\n        }\\n        lazyProp(idx,l,r);\\n        int mid = (l+r)/2;\\n        if(sum[idx*2+1]>=k){\\n            return queryScatter(idx*2+1, l, mid, maxRow, k);\\n        }\\n        k-=sum[idx*2+1];\\n        if(maxRow>mid && sum[idx*2+2]>=k){\\n            return queryScatter(idx*2+2,mid+1,r,maxRow,k);\\n        }\\n        return new int[]{-1,-1,-1};\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        int[] index = queryGather(0,0,leaves-1,maxRow,k);\\n        if(index[0]==-1) return new int[]{};\\n        int row = index[0];\\n        int col = (int) (m-sum[index[1]]);\\n        long rem = sum[index[1]]-k;\\n        update(0,0,leaves-1,row,row,rem);\\n        return new int[]{row,col};\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        int[] index = queryScatter(0,0,leaves-1,maxRow,k);\\n        if(index[0]==-1){\\n            return false;\\n        }\\n        int l = index[0];\\n        if(l>0){\\n            update(0,0,leaves-1,0,l-1,0);\\n        }\\n        long nvl = sum[index[1]]-index[2];\\n        update(0,0,leaves-1,l,l,nvl);\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass BookMyShow {\\n    \\n    long[] lazy;\\n    long[] max;\\n    long[] sum;\\n    long n,m;\\n    int leaves;\\n\\n    public BookMyShow(int n, int m) {\\n        this.n=n;\\n        this.m=m;\\n        leaves = (Integer.highestOneBit(n)==n) ? n : (Integer.highestOneBit(n)<<1); //next power of two\\n        int tnodes = leaves*2-1;\\n        lazy = new long[tnodes];\\n        Arrays.fill(lazy,-1);\\n        max = new long[tnodes];\\n        sum = new long[tnodes];\\n        update(0,0,leaves-1,0,n-1,m);\\n    }\\n    \\n    void set(int idx, int l, int r, long v){\\n        lazy[idx]=v;\\n        max[idx]=v;\\n        sum[idx]=v*(r-l+1);\\n    }\\n    \\n    void lazyProp(int idx, int l, int r){\\n        int mid = (l+r)/2;\\n        if(lazy[idx]!=-1){\\n            set(idx*2+1,l,mid,lazy[idx]);\\n            set(idx*2+2,mid+1,r,lazy[idx]);\\n            lazy[idx]=-1;\\n        }\\n    }\\n    \\n    void update(int idx, int l, int r, int ql, int qr, long v){\\n        if(ql<=l && qr>=r){\\n            set(idx,l,r,v);\\n            return ;\\n        }\\n        int mid = (l+r)/2;\\n        lazyProp(idx,l,r);\\n        if(ql<=mid){\\n            update(idx*2+1,l,mid,ql,qr,v);\\n        }\\n        if(qr>mid){\\n            update(idx*2+2,mid+1,r,ql,qr,v);\\n        }\\n        max[idx]=Math.max(max[idx*2+1],max[idx*2+2]);\\n        sum[idx]=sum[idx*2+1]+sum[idx*2+2];\\n    }\\n    \\n    int[] queryGather(int idx, int l, int r, int maxRow, int k){\\n        if(max[idx]<k){\\n            return new int[]{-1,-1};\\n        }\\n        if(l==r){\\n            return new int[]{l,idx};\\n        }\\n        lazyProp(idx,l,r);\\n        int mid = (l+r)/2;\\n        if(max[idx*2+1]>=k){\\n            return queryGather(idx*2+1,l,mid,maxRow, k);\\n        }\\n        if(maxRow>mid && max[idx*2+2]>=k){\\n            return queryGather(idx*2+2,mid+1,r,maxRow,k);\\n        }\\n        return new int[]{-1,-1};\\n    }\\n    \\n    int[] queryScatter(int idx, int l, int r, int maxRow, int k){\\n        if(sum[idx]<k){\\n            return new int[]{-1,-1,-1};\\n        }\\n        if(l==r){\\n            return new int[]{l,idx,k};\\n        }\\n        lazyProp(idx,l,r);\\n        int mid = (l+r)/2;\\n        if(sum[idx*2+1]>=k){\\n            return queryScatter(idx*2+1, l, mid, maxRow, k);\\n        }\\n        k-=sum[idx*2+1];\\n        if(maxRow>mid && sum[idx*2+2]>=k){\\n            return queryScatter(idx*2+2,mid+1,r,maxRow,k);\\n        }\\n        return new int[]{-1,-1,-1};\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        int[] index = queryGather(0,0,leaves-1,maxRow,k);\\n        if(index[0]==-1) return new int[]{};\\n        int row = index[0];\\n        int col = (int) (m-sum[index[1]]);\\n        long rem = sum[index[1]]-k;\\n        update(0,0,leaves-1,row,row,rem);\\n        return new int[]{row,col};\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        int[] index = queryScatter(0,0,leaves-1,maxRow,k);\\n        if(index[0]==-1){\\n            return false;\\n        }\\n        int l = index[0];\\n        if(l>0){\\n            update(0,0,leaves-1,0,l-1,0);\\n        }\\n        long nvl = sum[index[1]]-index[2];\\n        update(0,0,leaves-1,l,l,nvl);\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092134,
                "title": "why-does-my-approach-of-using-a-nested-list-to-track-the-seat-availability-not-work",
                "content": "[Here](https://leetcode.com/submissions/detail/710734738/) is my submission that was wrong.  self.seat_chart is not persisted after the first gather() call.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "[Here](https://leetcode.com/submissions/detail/710734738/) is my submission that was wrong.  self.seat_chart is not persisted after the first gather() call.",
                "codeTag": "Unknown"
            },
            {
                "id": 2091611,
                "title": "binary-index-tree-for-scatter-segment-tree-for-gather",
                "content": "```\\nclass BookMyShow {\\npublic:\\n    struct BIT {\\n        vector<long> arr;\\n        long N;\\n        \\n        BIT() {}\\n        \\n        BIT(int n) {\\n            N = long(n) + 1;\\n            arr = vector<long>(N, 0);\\n        }\\n        \\n        void add(long i, long val) {\\n            i += 1;\\n            while (i < N) {\\n                arr[i] += val;\\n                i += i & (-i);\\n            }\\n        }\\n        \\n        long query(long i) {\\n            long ret = 0;\\n            i += 1;\\n            while (i > 0) {\\n                ret += arr[i];\\n                i &= (i - 1);\\n            }\\n            return ret;\\n        }\\n    };\\n    \\n    struct SegTree {\\n        vector<int> arr;\\n        int n;\\n        \\n        void init(const vector<int>& vec, int v, int tl, int tr) {\\n            if (tl == tr) {\\n                arr[v] = vec[tl];\\n                return;\\n            }\\n            int mid = tl + (tr - tl) / 2;\\n            init(vec, 2 * v + 1, tl, mid);\\n            init(vec, 2 * v + 2, mid + 1, tr);\\n            arr[v] = max(arr[2 * v + 1], arr[2 * v + 2]);\\n        }\\n        \\n        SegTree() {}\\n        \\n        SegTree(const vector<int>& vec, const int& len) {\\n            n = len;\\n            arr = vector<int>(4 * n, 0);\\n            init(vec, 0, 0, n - 1);\\n        }\\n        \\n        void update(int v, int tl, int tr, const int& pos, const int& new_val) {\\n            if (tl == tr) {\\n                arr[v] = new_val;\\n                return;\\n            }\\n            int mid = tl + (tr - tl) / 2;\\n            if (pos <= mid) {\\n                update(2 * v + 1, tl, mid, pos, new_val);\\n                arr[v] = max(arr[2 * v + 1], arr[2 * v + 2]);\\n            }\\n            else {\\n                update(2 * v + 2, mid + 1, tr, pos, new_val);\\n                arr[v] = max(arr[2 * v + 1], arr[2 * v + 2]);\\n            }\\n        }\\n        \\n        int query(int v, int tl, int tr, int l, int r, const int& val) {\\n            if (l > r || arr[v] < val) return n;\\n            if (tl == tr) {\\n                if (arr[v] >= val) return tl;\\n                else return n;\\n            }\\n            int mid = tl + (tr - tl) / 2;\\n            int ret = query(2 * v + 1, tl, mid, l, min(r, mid), val);\\n            if (ret < n) return ret;\\n            ret = min(ret, query(2 * v + 2, mid + 1, tr, max(l, mid + 1), r, val));\\n            return ret;\\n        }\\n    };\\n    \\n    BookMyShow(int n, int m) : bit(n), st(vector<int>(n, m), n) {\\n        n_ = n;\\n        m_ = m;\\n        last_free = 0;\\n        capacity = vector<int>(n_, m_);\\n    }\\n    \\n    void decRow(int r, int k) {\\n        capacity[r] -= k;\\n        st.update(0, 0, n_ - 1, r, capacity[r]);\\n        bit.add(long(r), long(k));\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int pr = st.query(0, 0, n_ - 1, 0, maxRow, k);\\n        if (pr == n_) return vector<int>();\\n        int pc = capacity[pr];\\n        decRow(pr, k);\\n        return vector<int>{pr, m_ - pc};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long avail = long(maxRow + 1) * long(m_) - bit.query(long(maxRow));\\n        if (long(k) > avail) return false;\\n        while (true) {\\n            if (capacity[last_free] == 0) last_free++;\\n            else {\\n                if (k > capacity[last_free]) {\\n                    k -= capacity[last_free];\\n                    decRow(last_free, capacity[last_free]);\\n                    last_free++;\\n                }\\n                else {\\n                    decRow(last_free, k);\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    vector<int> capacity;\\n    BIT bit;\\n    SegTree st;\\n    int n_, m_, last_free;\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    struct BIT {\\n        vector<long> arr;\\n        long N;\\n        \\n        BIT() {}\\n        \\n        BIT(int n) {\\n            N = long(n) + 1;\\n            arr = vector<long>(N, 0);\\n        }\\n        \\n        void add(long i, long val) {\\n            i += 1;\\n            while (i < N) {\\n                arr[i] += val;\\n                i += i & (-i);\\n            }\\n        }\\n        \\n        long query(long i) {\\n            long ret = 0;\\n            i += 1;\\n            while (i > 0) {\\n                ret += arr[i];\\n                i &= (i - 1);\\n            }\\n            return ret;\\n        }\\n    };\\n    \\n    struct SegTree {\\n        vector<int> arr;\\n        int n;\\n        \\n        void init(const vector<int>& vec, int v, int tl, int tr) {\\n            if (tl == tr) {\\n                arr[v] = vec[tl];\\n                return;\\n            }\\n            int mid = tl + (tr - tl) / 2;\\n            init(vec, 2 * v + 1, tl, mid);\\n            init(vec, 2 * v + 2, mid + 1, tr);\\n            arr[v] = max(arr[2 * v + 1], arr[2 * v + 2]);\\n        }\\n        \\n        SegTree() {}\\n        \\n        SegTree(const vector<int>& vec, const int& len) {\\n            n = len;\\n            arr = vector<int>(4 * n, 0);\\n            init(vec, 0, 0, n - 1);\\n        }\\n        \\n        void update(int v, int tl, int tr, const int& pos, const int& new_val) {\\n            if (tl == tr) {\\n                arr[v] = new_val;\\n                return;\\n            }\\n            int mid = tl + (tr - tl) / 2;\\n            if (pos <= mid) {\\n                update(2 * v + 1, tl, mid, pos, new_val);\\n                arr[v] = max(arr[2 * v + 1], arr[2 * v + 2]);\\n            }\\n            else {\\n                update(2 * v + 2, mid + 1, tr, pos, new_val);\\n                arr[v] = max(arr[2 * v + 1], arr[2 * v + 2]);\\n            }\\n        }\\n        \\n        int query(int v, int tl, int tr, int l, int r, const int& val) {\\n            if (l > r || arr[v] < val) return n;\\n            if (tl == tr) {\\n                if (arr[v] >= val) return tl;\\n                else return n;\\n            }\\n            int mid = tl + (tr - tl) / 2;\\n            int ret = query(2 * v + 1, tl, mid, l, min(r, mid), val);\\n            if (ret < n) return ret;\\n            ret = min(ret, query(2 * v + 2, mid + 1, tr, max(l, mid + 1), r, val));\\n            return ret;\\n        }\\n    };\\n    \\n    BookMyShow(int n, int m) : bit(n), st(vector<int>(n, m), n) {\\n        n_ = n;\\n        m_ = m;\\n        last_free = 0;\\n        capacity = vector<int>(n_, m_);\\n    }\\n    \\n    void decRow(int r, int k) {\\n        capacity[r] -= k;\\n        st.update(0, 0, n_ - 1, r, capacity[r]);\\n        bit.add(long(r), long(k));\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int pr = st.query(0, 0, n_ - 1, 0, maxRow, k);\\n        if (pr == n_) return vector<int>();\\n        int pc = capacity[pr];\\n        decRow(pr, k);\\n        return vector<int>{pr, m_ - pc};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long avail = long(maxRow + 1) * long(m_) - bit.query(long(maxRow));\\n        if (long(k) > avail) return false;\\n        while (true) {\\n            if (capacity[last_free] == 0) last_free++;\\n            else {\\n                if (k > capacity[last_free]) {\\n                    k -= capacity[last_free];\\n                    decRow(last_free, capacity[last_free]);\\n                    last_free++;\\n                }\\n                else {\\n                    decRow(last_free, k);\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    vector<int> capacity;\\n    BIT bit;\\n    SegTree st;\\n    int n_, m_, last_free;\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091303,
                "title": "easy-segtree-faster-than-100",
                "content": "```\\nclass BookMyShow {\\n    #define ll long long\\npublic:\\n    struct SegTree {\\n        vector<int> pre_max, row_cap; \\n        vector<ll> pre_sum;\\n        void build(int seg_i, int seg_l, int seg_r) {\\n            if (seg_r - seg_l == 1) return;\\n            int seg_m = seg_l + (seg_r - seg_l) / 2;\\n            int seg_li = seg_i * 2 + 1;\\n            int seg_ri = seg_i * 2 + 2;\\n            build(seg_li, seg_l, seg_m);\\n            build(seg_ri, seg_m, seg_r);\\n            pre_sum[seg_i] = pre_sum[seg_li] + pre_sum[seg_ri];\\n        }\\n        void init(int rows, int row_seats){\\n            pre_max.resize(rows * 4 + 5, row_seats);\\n            pre_sum.resize(rows * 4 + 5, row_seats);\\n            row_cap.resize(rows, row_seats);\\n            build(0, 0, rows);\\n        }\\n        ll get_pre_sum_k(int seg_i, int seg_l, int seg_r, int &k) {\\n            if (k < seg_l) return 0;\\n            if (seg_r - 1 <= k) return pre_sum[seg_i];\\n            int seg_m = seg_l + (seg_r - seg_l) / 2;\\n            int seg_li = 2 * seg_i + 1;\\n            int seg_ri = 2 * seg_i + 2;\\n            return get_pre_sum_k(seg_li, seg_l, seg_m, k) + get_pre_sum_k(seg_ri, seg_m, seg_r, k);            \\n        }\\n        \\n        int find_first_greater(int seg_i, int seg_l, int seg_r, int &k) {\\n            if (k > pre_max[seg_i]) return -1;\\n            if (seg_r - seg_l == 1) return seg_l;\\n            int seg_m = seg_l + (seg_r - seg_l) / 2;\\n            int seg_li = 2 * seg_i + 1;\\n            int seg_ri = 2 * seg_i + 2;\\n            if (pre_max[seg_li] >= k) {\\n                return find_first_greater(seg_li, seg_l, seg_m, k);\\n            }\\n            return find_first_greater(seg_ri, seg_m, seg_r, k);\\n        }\\n        \\n        void update(int seg_i, int seg_l, int seg_r, int row, int val) {\\n            if (seg_r - seg_l == 1) {\\n                pre_max[seg_i] = val;\\n                pre_sum[seg_i] = val;\\n                row_cap[seg_l] = val;\\n                return;\\n            }\\n            int seg_m = seg_l + (seg_r - seg_l) / 2;\\n            int seg_li = 2 * seg_i + 1;\\n            int seg_ri = 2 * seg_i + 2;\\n            if (row < seg_m) {\\n                update(seg_li, seg_l, seg_m, row, val);\\n            } else {\\n                update(seg_ri, seg_m, seg_r, row, val);\\n            }\\n            pre_max[seg_i] = max(pre_max[seg_li], pre_max[seg_ri]);\\n            pre_sum[seg_i] = pre_sum[seg_li] + pre_sum[seg_ri];\\n\\n        }\\n    };\\n    ll cap_;\\n    int siz_, first_non_empty_, seats_;\\n    SegTree st_;\\n    BookMyShow(int n, int m) {\\n        siz_ = n;\\n        cap_ = (ll)m * n;\\n        first_non_empty_ = 0;\\n        seats_ = m;\\n        st_.init(siz_, seats_);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int first_row = st_.find_first_greater(0, 0, siz_, k);\\n        if (first_row == -1 || first_row > maxRow)  return vector<int> ();\\n        cap_ -= k;\\n        st_.update(0, 0, siz_, first_row, st_.row_cap[first_row] - k);\\n        return {first_row, seats_ - st_.row_cap[first_row] - k};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if (st_.get_pre_sum_k(0, 0, siz_, maxRow) < k)    return false;\\n        int tot = 0;\\n        while (first_non_empty_ <= maxRow && tot < k) {\\n            int taken = min(st_.row_cap[first_non_empty_], k - tot);\\n            st_.update(0, 0, siz_, first_non_empty_, st_.row_cap[first_non_empty_] - taken);\\n            tot += taken;\\n            if (!st_.row_cap[first_non_empty_]) first_non_empty_++;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\n    #define ll long long\\npublic:\\n    struct SegTree {\\n        vector<int> pre_max, row_cap; \\n        vector<ll> pre_sum;\\n        void build(int seg_i, int seg_l, int seg_r) {\\n            if (seg_r - seg_l == 1) return;\\n            int seg_m = seg_l + (seg_r - seg_l) / 2;\\n            int seg_li = seg_i * 2 + 1;\\n            int seg_ri = seg_i * 2 + 2;\\n            build(seg_li, seg_l, seg_m);\\n            build(seg_ri, seg_m, seg_r);\\n            pre_sum[seg_i] = pre_sum[seg_li] + pre_sum[seg_ri];\\n        }\\n        void init(int rows, int row_seats){\\n            pre_max.resize(rows * 4 + 5, row_seats);\\n            pre_sum.resize(rows * 4 + 5, row_seats);\\n            row_cap.resize(rows, row_seats);\\n            build(0, 0, rows);\\n        }\\n        ll get_pre_sum_k(int seg_i, int seg_l, int seg_r, int &k) {\\n            if (k < seg_l) return 0;\\n            if (seg_r - 1 <= k) return pre_sum[seg_i];\\n            int seg_m = seg_l + (seg_r - seg_l) / 2;\\n            int seg_li = 2 * seg_i + 1;\\n            int seg_ri = 2 * seg_i + 2;\\n            return get_pre_sum_k(seg_li, seg_l, seg_m, k) + get_pre_sum_k(seg_ri, seg_m, seg_r, k);            \\n        }\\n        \\n        int find_first_greater(int seg_i, int seg_l, int seg_r, int &k) {\\n            if (k > pre_max[seg_i]) return -1;\\n            if (seg_r - seg_l == 1) return seg_l;\\n            int seg_m = seg_l + (seg_r - seg_l) / 2;\\n            int seg_li = 2 * seg_i + 1;\\n            int seg_ri = 2 * seg_i + 2;\\n            if (pre_max[seg_li] >= k) {\\n                return find_first_greater(seg_li, seg_l, seg_m, k);\\n            }\\n            return find_first_greater(seg_ri, seg_m, seg_r, k);\\n        }\\n        \\n        void update(int seg_i, int seg_l, int seg_r, int row, int val) {\\n            if (seg_r - seg_l == 1) {\\n                pre_max[seg_i] = val;\\n                pre_sum[seg_i] = val;\\n                row_cap[seg_l] = val;\\n                return;\\n            }\\n            int seg_m = seg_l + (seg_r - seg_l) / 2;\\n            int seg_li = 2 * seg_i + 1;\\n            int seg_ri = 2 * seg_i + 2;\\n            if (row < seg_m) {\\n                update(seg_li, seg_l, seg_m, row, val);\\n            } else {\\n                update(seg_ri, seg_m, seg_r, row, val);\\n            }\\n            pre_max[seg_i] = max(pre_max[seg_li], pre_max[seg_ri]);\\n            pre_sum[seg_i] = pre_sum[seg_li] + pre_sum[seg_ri];\\n\\n        }\\n    };\\n    ll cap_;\\n    int siz_, first_non_empty_, seats_;\\n    SegTree st_;\\n    BookMyShow(int n, int m) {\\n        siz_ = n;\\n        cap_ = (ll)m * n;\\n        first_non_empty_ = 0;\\n        seats_ = m;\\n        st_.init(siz_, seats_);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int first_row = st_.find_first_greater(0, 0, siz_, k);\\n        if (first_row == -1 || first_row > maxRow)  return vector<int> ();\\n        cap_ -= k;\\n        st_.update(0, 0, siz_, first_row, st_.row_cap[first_row] - k);\\n        return {first_row, seats_ - st_.row_cap[first_row] - k};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if (st_.get_pre_sum_k(0, 0, siz_, maxRow) < k)    return false;\\n        int tot = 0;\\n        while (first_non_empty_ <= maxRow && tot < k) {\\n            int taken = min(st_.row_cap[first_non_empty_], k - tot);\\n            st_.update(0, 0, siz_, first_non_empty_, st_.row_cap[first_non_empty_] - taken);\\n            tot += taken;\\n            if (!st_.row_cap[first_non_empty_]) first_non_empty_++;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090972,
                "title": "python-segment-tree-for-max-and-sum-easier-solution-100-time-and-space",
                "content": "```\\nclass SegmentTree():\\n    #construct a segment tree\\n    #l,r denote the range [l,r], both inclusive\\n    def __init__(self, l, r):\\n        mid = (l + r) // 2\\n        self.l = l\\n        self.r = r\\n        self.left, self.right = None, None\\n        self.max = 0\\n        self.sums = 0\\n        if l != r:\\n            self.left = SegmentTree(l, mid)\\n            self.right = SegmentTree(mid + 1, r)\\n    \\n    #update the value(the number of unreserved seats) at index(row) i to val\\n    def update(self, i, val):\\n        if self.l == i == self.r:\\n            self.max = val\\n            self.sums = val\\n            return val, val\\n        mid = (self.l + self.r)//2\\n        if self.l <= i <= mid:\\n            left_max, left_sums = self.left.update(i, val)\\n            self.max, self.sums = max(left_max, self.right.max), left_sums + self.right.sums\\n        else:\\n            right_max, right_sums = self.right.update(i, val)\\n            self.max, self.sums = max(self.left.max, right_max), self.left.sums + right_sums\\n        return self.max, self.sums\\n\\n    #return the max and sum of unreserved seats in rows in range [l,r]\\n    def query(self, l, r):\\n        if r < self.l or self.r < l:\\n            return 0, 0\\n        elif l <= self.l and self.r <= r:\\n            return self.max, self.sums\\n        else:\\n            left_max, left_sums = self.left.query(l,r)\\n            right_max, right_sums = self.right.query(l,r)\\n            return max(left_max, right_max), left_sums + right_sums\\n\\n    #return the smallest row index that has unreserved seats greater than or equal to k\\n    def queryLowestGreaterEqual(self, k):\\n        if self.max < k:\\n            return -1\\n        if self.l == self.r:\\n            return -1 if self.max < k else self.l\\n        if self.left.max >= k:\\n            return self.left.queryLowestGreaterEqual(k)\\n        return self.right.queryLowestGreaterEqual(k)\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.st = SegmentTree(0,n-1)\\n        for i in range(n):\\n            self.st.update(i, m)\\n        self.m = m\\n        #beginning row to check scatter reservation, that is, the rows with index less than self.scatter_row already become full\\n        self.scatter_row = 0 \\n        self.n = n\\n\\n\\n    def gather(self, k: int, maxRow: int):\\n        i = self.st.queryLowestGreaterEqual(k)\\n        if i < 0 or i > maxRow:\\n            return []\\n        v, _ = self.st.query(i,i)\\n        self.st.update(i, v-k)\\n        return [i,self.m-v]\\n\\n    def scatter(self, k: int, maxRow: int):\\n        if self.st.query(0, maxRow)[1] >= k:\\n            while self.scatter_row <self.n and k>0:\\n                v, _ = self.st.query(self.scatter_row, self.scatter_row)\\n                self.st.update(self.scatter_row, v-min(v,k))\\n                if v > k:\\n                    #k = 0\\n                    break\\n                else:\\n                    k -= v\\n                    self.scatter_row += 1\\n            return True\\n        return False",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass SegmentTree():\\n    #construct a segment tree\\n    #l,r denote the range [l,r], both inclusive\\n    def __init__(self, l, r):\\n        mid = (l + r) // 2\\n        self.l = l\\n        self.r = r\\n        self.left, self.right = None, None\\n        self.max = 0\\n        self.sums = 0\\n        if l != r:\\n            self.left = SegmentTree(l, mid)\\n            self.right = SegmentTree(mid + 1, r)\\n    \\n    #update the value(the number of unreserved seats) at index(row) i to val\\n    def update(self, i, val):\\n        if self.l == i == self.r:\\n            self.max = val\\n            self.sums = val\\n            return val, val\\n        mid = (self.l + self.r)//2\\n        if self.l <= i <= mid:\\n            left_max, left_sums = self.left.update(i, val)\\n            self.max, self.sums = max(left_max, self.right.max), left_sums + self.right.sums\\n        else:\\n            right_max, right_sums = self.right.update(i, val)\\n            self.max, self.sums = max(self.left.max, right_max), self.left.sums + right_sums\\n        return self.max, self.sums\\n\\n    #return the max and sum of unreserved seats in rows in range [l,r]\\n    def query(self, l, r):\\n        if r < self.l or self.r < l:\\n            return 0, 0\\n        elif l <= self.l and self.r <= r:\\n            return self.max, self.sums\\n        else:\\n            left_max, left_sums = self.left.query(l,r)\\n            right_max, right_sums = self.right.query(l,r)\\n            return max(left_max, right_max), left_sums + right_sums\\n\\n    #return the smallest row index that has unreserved seats greater than or equal to k\\n    def queryLowestGreaterEqual(self, k):\\n        if self.max < k:\\n            return -1\\n        if self.l == self.r:\\n            return -1 if self.max < k else self.l\\n        if self.left.max >= k:\\n            return self.left.queryLowestGreaterEqual(k)\\n        return self.right.queryLowestGreaterEqual(k)\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.st = SegmentTree(0,n-1)\\n        for i in range(n):\\n            self.st.update(i, m)\\n        self.m = m\\n        #beginning row to check scatter reservation, that is, the rows with index less than self.scatter_row already become full\\n        self.scatter_row = 0 \\n        self.n = n\\n\\n\\n    def gather(self, k: int, maxRow: int):\\n        i = self.st.queryLowestGreaterEqual(k)\\n        if i < 0 or i > maxRow:\\n            return []\\n        v, _ = self.st.query(i,i)\\n        self.st.update(i, v-k)\\n        return [i,self.m-v]\\n\\n    def scatter(self, k: int, maxRow: int):\\n        if self.st.query(0, maxRow)[1] >= k:\\n            while self.scatter_row <self.n and k>0:\\n                v, _ = self.st.query(self.scatter_row, self.scatter_row)\\n                self.st.update(self.scatter_row, v-min(v,k))\\n                if v > k:\\n                    #k = 0\\n                    break\\n                else:\\n                    k -= v\\n                    self.scatter_row += 1\\n            return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2089191,
                "title": "segmenttree-python-with-lazy-tag",
                "content": "My first idea was Binary Search to find the first index which satisfy the max of [0, index] >= k.\\nAnd the complexity will be n * log(n) * log(n), it can\\'t pass the test case with python.\\nThen by thinking of the detail of segment tree udpate and query,  I found out I can do the pruning during the update process. (easy to prune left child if left child has a max < k).\\n```\\nclass SegmentTree:\\n    \\n    def __init__(self, n):\\n        k = 4 *n + 4\\n        self.a = [0] *k\\n        self.ma = [0] * k\\n        self.su = [0] * k\\n        self.lazy = [-1] * k\\n    \\n    def left(self, id):\\n        return id * 2 + 1\\n    \\n    def right(self,id):\\n        return self.left(id) + 1\\n    \\n    def push_up(self, id):\\n        lc, rc = self.left(id), self.right(id)\\n        self.ma[id] = max(self.ma[lc], self.ma[rc])\\n        self.su[id] = self.su[lc] + self.su[rc]\\n    \\n    def push_down(self, l, r, id):\\n        lc, rc = self.left(id), self.right(id)\\n        if l != r and self.lazy[id] != - 1:\\n            self.lazy[lc] = self.lazy[rc] = self.lazy[id]\\n            self.lazy[id] = -1\\n            self.ma[lc] = self.ma[rc] = self.lazy[lc]\\n            mid = (l + r) // 2\\n            self.su[lc] = (mid - l + 1) * self.lazy[lc]\\n            self.su[rc] = (r - mid) * self.lazy[lc]\\n            \\n    \\n    def build_tree(self, l, r, id, m):\\n        if l == r:\\n            self.ma[id] = m\\n            self.su[id] = self.a[id] = m\\n            return\\n        lc, rc = self.left(id), self.right(id)\\n        mid = (l + r) // 2\\n        self.build_tree(l, mid, lc, m)\\n        self.build_tree(mid + 1, r, rc, m)\\n        self.push_up(id)\\n    \\n    def update_range(self, l, r, id, ul, ur, v):\\n        if ul <= l and ur >= r:\\n            self.lazy[id] = v\\n            self.ma[id] = v\\n            self.su[id] = v * ( r- l + 1)\\n            return\\n        lc, rc = self.left(id), self.right(id)\\n        mid = (l + r) //2\\n        self.push_down(l, r, id)\\n        if ul <= mid:\\n            self.update_range(l, mid, lc, ul, ur, v)\\n        if ur >= mid + 1:\\n            self.update_range(mid + 1, r, rc, ul, ur, v)\\n        self.push_up(id)\\n        \\n    \\n    def update(self, l, r, id, k, v):\\n        self.update_range(l, r, id, k, k, v)\\n    \\n    def query(self, l, r, id, ql, qr, flag):\\n        if ql <= l and qr >= r:\\n            if flag == \"sum\":\\n                return self.su[id]\\n            else:\\n                return self.ma[id]\\n        mid = (l + r) //2\\n        lc, rc = self.left(id), self.right(id)\\n        self.push_down(l, r, id)\\n        ans = 0 if flag == \"sum\" else -1<<31\\n        if ql <= mid:\\n            res_l = self.query(l, mid, lc, ql, qr, flag)\\n            if flag == \"sum\":\\n                ans += res_l\\n            else:\\n                ans = max(ans, res_l)\\n        if qr >= mid + 1:\\n            res_r = self.query(mid + 1, r, rc,ql, qr, flag)\\n            if flag == \"sum\":\\n                ans += res_r\\n            else:\\n                ans = max(ans, res_r)\\n        return ans\\n    \\n    def gather(self, l, r, id, mr, k):\\n        if l > mr:\\n            return []\\n        if self.ma[id] < k:\\n            return []\\n        if l == r:\\n            self.su[id] -= k\\n            self.ma[id] -= k\\n            return [l, self.su[id] + k]\\n        mid = (l + r) //2\\n        self.push_down(l, r, id)\\n        lc, rc = self.left(id), self.right(id)\\n        ans_l = self.gather(l, mid, lc, mr, k)\\n        if not ans_l:\\n            ans_l = self.gather(mid + 1, r, rc, mr, k)\\n        self.push_up(id)\\n        return ans_l\\n    \\n    def scatter(self, l, r, id, mr, k):\\n        if l > mr:\\n            return 0\\n        if r <= mr:\\n            if self.su[id] <= k:\\n                t = self.su[id]\\n                self.su[id] = self.lazy[id] = self.ma[id] = 0\\n                return t\\n            elif l == r:\\n                t = self.su[id]\\n                self.su[id] = t -k\\n                self.ma[id] = t - k\\n                return k\\n        if not k:\\n            return 0\\n        mid = (l + r) //2\\n        self.push_down(l, r, id)\\n        lc, rc = self.left(id), self.right(id)\\n        ans_l = self.scatter(l, mid, lc, mr, k)\\n        if ans_l >= k:\\n            self.push_up(id)\\n            return k\\n        self.scatter(mid + 1, r, rc, mr, k - ans_l)\\n        self.push_up(id)\\n        return k\\n\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.seg = SegmentTree(n)\\n        self.seg.build_tree(0, n -1, 0, m)\\n        self.n = n\\n        self.m = m\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        t = self.seg.query(0, self.n - 1, 0, 0, maxRow, \"max\")\\n        if t < k:\\n            return []\\n        ans = self.seg.gather(0, self.n - 1, 0, maxRow, k)\\n        return [ans[0], self.m - ans[1]]\\n\\n        \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        t = self.seg.query(0, self.n - 1, 0, 0, maxRow, \"sum\")\\n        if t < k:\\n            return False\\n        self.seg.scatter(0, self.n - 1, 0, maxRow, k)\\n        return True\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass SegmentTree:\\n    \\n    def __init__(self, n):\\n        k = 4 *n + 4\\n        self.a = [0] *k\\n        self.ma = [0] * k\\n        self.su = [0] * k\\n        self.lazy = [-1] * k\\n    \\n    def left(self, id):\\n        return id * 2 + 1\\n    \\n    def right(self,id):\\n        return self.left(id) + 1\\n    \\n    def push_up(self, id):\\n        lc, rc = self.left(id), self.right(id)\\n        self.ma[id] = max(self.ma[lc], self.ma[rc])\\n        self.su[id] = self.su[lc] + self.su[rc]\\n    \\n    def push_down(self, l, r, id):\\n        lc, rc = self.left(id), self.right(id)\\n        if l != r and self.lazy[id] != - 1:\\n            self.lazy[lc] = self.lazy[rc] = self.lazy[id]\\n            self.lazy[id] = -1\\n            self.ma[lc] = self.ma[rc] = self.lazy[lc]\\n            mid = (l + r) // 2\\n            self.su[lc] = (mid - l + 1) * self.lazy[lc]\\n            self.su[rc] = (r - mid) * self.lazy[lc]\\n            \\n    \\n    def build_tree(self, l, r, id, m):\\n        if l == r:\\n            self.ma[id] = m\\n            self.su[id] = self.a[id] = m\\n            return\\n        lc, rc = self.left(id), self.right(id)\\n        mid = (l + r) // 2\\n        self.build_tree(l, mid, lc, m)\\n        self.build_tree(mid + 1, r, rc, m)\\n        self.push_up(id)\\n    \\n    def update_range(self, l, r, id, ul, ur, v):\\n        if ul <= l and ur >= r:\\n            self.lazy[id] = v\\n            self.ma[id] = v\\n            self.su[id] = v * ( r- l + 1)\\n            return\\n        lc, rc = self.left(id), self.right(id)\\n        mid = (l + r) //2\\n        self.push_down(l, r, id)\\n        if ul <= mid:\\n            self.update_range(l, mid, lc, ul, ur, v)\\n        if ur >= mid + 1:\\n            self.update_range(mid + 1, r, rc, ul, ur, v)\\n        self.push_up(id)\\n        \\n    \\n    def update(self, l, r, id, k, v):\\n        self.update_range(l, r, id, k, k, v)\\n    \\n    def query(self, l, r, id, ql, qr, flag):\\n        if ql <= l and qr >= r:\\n            if flag == \"sum\":\\n                return self.su[id]\\n            else:\\n                return self.ma[id]\\n        mid = (l + r) //2\\n        lc, rc = self.left(id), self.right(id)\\n        self.push_down(l, r, id)\\n        ans = 0 if flag == \"sum\" else -1<<31\\n        if ql <= mid:\\n            res_l = self.query(l, mid, lc, ql, qr, flag)\\n            if flag == \"sum\":\\n                ans += res_l\\n            else:\\n                ans = max(ans, res_l)\\n        if qr >= mid + 1:\\n            res_r = self.query(mid + 1, r, rc,ql, qr, flag)\\n            if flag == \"sum\":\\n                ans += res_r\\n            else:\\n                ans = max(ans, res_r)\\n        return ans\\n    \\n    def gather(self, l, r, id, mr, k):\\n        if l > mr:\\n            return []\\n        if self.ma[id] < k:\\n            return []\\n        if l == r:\\n            self.su[id] -= k\\n            self.ma[id] -= k\\n            return [l, self.su[id] + k]\\n        mid = (l + r) //2\\n        self.push_down(l, r, id)\\n        lc, rc = self.left(id), self.right(id)\\n        ans_l = self.gather(l, mid, lc, mr, k)\\n        if not ans_l:\\n            ans_l = self.gather(mid + 1, r, rc, mr, k)\\n        self.push_up(id)\\n        return ans_l\\n    \\n    def scatter(self, l, r, id, mr, k):\\n        if l > mr:\\n            return 0\\n        if r <= mr:\\n            if self.su[id] <= k:\\n                t = self.su[id]\\n                self.su[id] = self.lazy[id] = self.ma[id] = 0\\n                return t\\n            elif l == r:\\n                t = self.su[id]\\n                self.su[id] = t -k\\n                self.ma[id] = t - k\\n                return k\\n        if not k:\\n            return 0\\n        mid = (l + r) //2\\n        self.push_down(l, r, id)\\n        lc, rc = self.left(id), self.right(id)\\n        ans_l = self.scatter(l, mid, lc, mr, k)\\n        if ans_l >= k:\\n            self.push_up(id)\\n            return k\\n        self.scatter(mid + 1, r, rc, mr, k - ans_l)\\n        self.push_up(id)\\n        return k\\n\\n\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.seg = SegmentTree(n)\\n        self.seg.build_tree(0, n -1, 0, m)\\n        self.n = n\\n        self.m = m\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        t = self.seg.query(0, self.n - 1, 0, 0, maxRow, \"max\")\\n        if t < k:\\n            return []\\n        ans = self.seg.gather(0, self.n - 1, 0, maxRow, k)\\n        return [ans[0], self.m - ans[1]]\\n\\n        \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        t = self.seg.query(0, self.n - 1, 0, 0, maxRow, \"sum\")\\n        if t < k:\\n            return False\\n        self.seg.scatter(0, self.n - 1, 0, maxRow, k)\\n        return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088902,
                "title": "c-segment-tree-beats-100-time-and-space",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\n\\nclass BookMyShow {\\n    vector<pair<ll, ll>> tree;\\n    int n;\\n    int m;\\n\\n    void buildTree(int lo, int hi, int index, int m) {\\n        if (lo == hi) {\\n            tree[index] = {m, m};\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        buildTree(lo, mid, 2 * index, m);\\n        buildTree(mid + 1, hi, 2 * index + 1, m);\\n        tree[index] = {max(tree[2 * index].first, tree[2 * index + 1].first),\\n                       tree[2 * index].second + tree[2 * index + 1].second};\\n    }\\n\\npublic:\\n    BookMyShow(int n, int m) {\\n        tree.resize(4 * n + 1);\\n        this->n = n;\\n        this->m = m;\\n        buildTree(0, n - 1, 1, m);\\n    }\\n\\n    void updateGather(int lo, int hi, int index, int maxRow, int k, vector<int> &res) {\\n        if (lo > maxRow) return;\\n        if (tree[index].first < k) return;\\n        if (lo == hi) {\\n            res = {lo, m - (int)tree[index].second};\\n            tree[index] = {tree[index].second - k,\\n                           tree[index].second - k};\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        if (tree[2 * index].first >= k)\\n            updateGather(lo, mid, 2 * index, maxRow, k, res);\\n        else\\n            updateGather(mid + 1, hi, 2 * index + 1, maxRow, k, res);\\n        tree[index] = {max(tree[2 * index].first, tree[2 * index + 1].first),\\n                       tree[2 * index].second + tree[2 * index + 1].second};\\n    }\\n    vector<int> gather(int k, int maxRow) {\\n        vector<int> res;\\n        updateGather(0, n - 1, 1, maxRow, k, res);\\n        return res;\\n    }\\n\\n    ll queryScatter(int lo, int hi, int index, int maxRow) {\\n        if (lo > maxRow) return 0;\\n        if (hi <= maxRow) return tree[index].second;\\n        int mid = lo + (hi - lo) / 2;\\n        ll left = queryScatter(lo, mid, 2 * index, maxRow);\\n        ll right = queryScatter(mid + 1, hi, 2 * index + 1, maxRow);\\n        return left + right;\\n    }\\n\\n    void updateScatter(int lo, int hi, int index, int maxRow, int k) {\\n        if (k <= 0) return;\\n        if (lo > maxRow) return;\\n\\n        if (lo == hi) {\\n            tree[index].second -= k;\\n            tree[index].first = tree[index].second;\\n            return;\\n        }\\n\\n        int mid = lo + (hi - lo) / 2;\\n\\n        ll toPassToLeft = min((ll)k, tree[2 * index].second);\\n        ll toPassToRight = max(0ll, k - toPassToLeft);\\n        updateScatter(lo, mid, 2 * index, maxRow, toPassToLeft);\\n        updateScatter(mid + 1, hi, 2 * index + 1, maxRow, toPassToRight);\\n        tree[index] = {max(tree[2 * index].first, tree[2 * index + 1].first),\\n                       tree[2 * index].second + tree[2 * index + 1].second};\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        if (k > queryScatter(0, n - 1, 1, maxRow)) return false;\\n        updateScatter(0, n - 1, 1, maxRow, k);\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\n\\nclass BookMyShow {\\n    vector<pair<ll, ll>> tree;\\n    int n;\\n    int m;\\n\\n    void buildTree(int lo, int hi, int index, int m) {\\n        if (lo == hi) {\\n            tree[index] = {m, m};\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        buildTree(lo, mid, 2 * index, m);\\n        buildTree(mid + 1, hi, 2 * index + 1, m);\\n        tree[index] = {max(tree[2 * index].first, tree[2 * index + 1].first),\\n                       tree[2 * index].second + tree[2 * index + 1].second};\\n    }\\n\\npublic:\\n    BookMyShow(int n, int m) {\\n        tree.resize(4 * n + 1);\\n        this->n = n;\\n        this->m = m;\\n        buildTree(0, n - 1, 1, m);\\n    }\\n\\n    void updateGather(int lo, int hi, int index, int maxRow, int k, vector<int> &res) {\\n        if (lo > maxRow) return;\\n        if (tree[index].first < k) return;\\n        if (lo == hi) {\\n            res = {lo, m - (int)tree[index].second};\\n            tree[index] = {tree[index].second - k,\\n                           tree[index].second - k};\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        if (tree[2 * index].first >= k)\\n            updateGather(lo, mid, 2 * index, maxRow, k, res);\\n        else\\n            updateGather(mid + 1, hi, 2 * index + 1, maxRow, k, res);\\n        tree[index] = {max(tree[2 * index].first, tree[2 * index + 1].first),\\n                       tree[2 * index].second + tree[2 * index + 1].second};\\n    }\\n    vector<int> gather(int k, int maxRow) {\\n        vector<int> res;\\n        updateGather(0, n - 1, 1, maxRow, k, res);\\n        return res;\\n    }\\n\\n    ll queryScatter(int lo, int hi, int index, int maxRow) {\\n        if (lo > maxRow) return 0;\\n        if (hi <= maxRow) return tree[index].second;\\n        int mid = lo + (hi - lo) / 2;\\n        ll left = queryScatter(lo, mid, 2 * index, maxRow);\\n        ll right = queryScatter(mid + 1, hi, 2 * index + 1, maxRow);\\n        return left + right;\\n    }\\n\\n    void updateScatter(int lo, int hi, int index, int maxRow, int k) {\\n        if (k <= 0) return;\\n        if (lo > maxRow) return;\\n\\n        if (lo == hi) {\\n            tree[index].second -= k;\\n            tree[index].first = tree[index].second;\\n            return;\\n        }\\n\\n        int mid = lo + (hi - lo) / 2;\\n\\n        ll toPassToLeft = min((ll)k, tree[2 * index].second);\\n        ll toPassToRight = max(0ll, k - toPassToLeft);\\n        updateScatter(lo, mid, 2 * index, maxRow, toPassToLeft);\\n        updateScatter(mid + 1, hi, 2 * index + 1, maxRow, toPassToRight);\\n        tree[index] = {max(tree[2 * index].first, tree[2 * index + 1].first),\\n                       tree[2 * index].second + tree[2 * index + 1].second};\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        if (k > queryScatter(0, n - 1, 1, maxRow)) return false;\\n        updateScatter(0, n - 1, 1, maxRow, k);\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2088890,
                "title": "c-bottom2top-static-segment-tree-binary-search",
                "content": "```\\npublic int N;\\npublic int M;\\npublic Node[] tree;\\n\\npublic class QueryRes {\\n\\tpublic long cnt;\\n\\tpublic int idx;\\n\\n\\tpublic QueryRes(long cnt, int idx) {\\n\\t\\tthis.cnt = cnt;\\n\\t\\tthis.idx = idx;\\n\\t}\\n}\\n\\npublic class Node {\\n\\tpublic int max;     // max remaining seats in one row\\n\\tpublic long cnt;    // total remaining seats in all rows\\n\\tpublic int m_idx;   // index for $max\\n\\tpublic int c_idx;   // starting index for $cnt\\n\\n\\tpublic void calc(Node n1, Node n2) {\\n\\t\\tmax = Math.Max(n1.max, n2.max);\\n\\t\\tcnt = n1.cnt + n2.cnt;\\n\\t\\tm_idx = n1.max >= n2.max ? n1.m_idx : n2.m_idx;\\n\\t\\tc_idx = Math.Min(n1.c_idx, n2.c_idx);            \\n\\t}\\n\\n\\tpublic int book(int bcnt) {\\n\\t\\tint r = Math.Max(0, bcnt - (int)cnt);\\n\\t\\tcnt = Math.Max(0, (int)cnt - bcnt);\\n\\t\\tmax = (int)cnt;\\n\\t\\tif (cnt == 0) {\\n\\t\\t\\tm_idx = int.MaxValue;\\n\\t\\t\\tc_idx = int.MaxValue;\\n\\t\\t}\\n\\t\\treturn r;\\n\\t}\\n}\\n\\nint updateTreeNode(int idx, int needCnt) {\\n\\tint res = tree[idx + N].book(needCnt);\\n\\t// move upward and update parents\\n\\tfor (int i = idx + N; i > 1; i >>= 1) {\\n\\t\\ttree[i >> 1].calc(tree[i], tree[i^1]);\\n\\t}\\n\\treturn res;\\n}\\n\\nvoid buildTree() {\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\ttree[N + i] = new Node();\\n\\t\\ttree[N + i].max = M; tree[N + i].cnt = M;\\n\\t\\ttree[N + i].m_idx = i; tree[N + i].c_idx = i;\\n\\t}\\n\\t// build the tree by calculating parents\\n\\tfor (int i = N - 1; i > 0; --i) {\\n\\t\\ttree[i] = new Node();\\n\\t\\ttree[i].calc(tree[i << 1], tree[i << 1 | 1]);\\n\\t}\\n}\\n\\nQueryRes query(int l, int r, Action<Node, QueryRes> f) {\\n\\tQueryRes res = new QueryRes(0, int.MaxValue);\\n\\tfor (l += N, r += N; l < r; l >>= 1, r >>= 1) {\\n\\t\\tif ((l&1) > 0) { f(tree[l++], res); }\\n\\t\\tif ((r&1) > 0) { f(tree[--r], res); }\\n\\t}\\n\\treturn res;\\n}\\n\\npublic BookMyShow(int n, int m) {\\n\\tN = 1; M = m;\\n\\twhile(N < n) { N *= 2; }\\n\\ttree = new Node[2 * N];\\n\\tbuildTree();\\n}\\n\\npublic int[] Gather(int k, int maxRow) {        \\n\\tQueryRes res = binarySearch(k, 0, maxRow, MaxFunc);\\n\\tif ((int)res.cnt < k) return (new List<int>()).ToArray();\\n\\n\\tint r1 = res.idx;\\n\\tint r2 = M - (int)res.cnt;\\n\\tupdateTreeNode(res.idx, k);\\n\\treturn new int[2] {r1, r2};\\n}\\n\\npublic bool Scatter(int k, int maxRow) {\\n\\tQueryRes res = binarySearch(k, 0, maxRow, SumFunc);\\n\\tif ((int)res.cnt < k) return false;\\n\\n\\twhile(k > 0) { k = updateTreeNode(res.idx++, k); }\\n\\treturn true;\\n}\\n\\n// query range [l, r)\\npublic QueryRes binarySearch(int k, int l, int r, Action<Node, QueryRes> f) {\\n\\tQueryRes res;\\n\\twhile(l<r) {\\n\\t\\tint m = (l + r)/2;\\n\\t\\tres = query(0, m+1, f);\\n\\t\\tif (res.cnt >= k) { r = m; }\\n\\t\\telse { l = m+1; }\\n\\t}\\n\\tres = query(0, r+1, f);\\n\\treturn res;\\n}\\n\\npublic void MaxFunc(Node node, QueryRes res) {\\n\\tif (node.max > res.cnt) { res.idx = node.m_idx; } \\n\\telse if(node.max == res.cnt && node.m_idx < res.idx) { res.idx = node.m_idx; }\\n\\tres.cnt = Math.Max(res.cnt, node.max);\\n}\\n\\npublic void SumFunc(Node node, QueryRes res) {\\n\\tres.cnt += node.cnt;\\n\\tres.idx = Math.Min(res.idx, node.c_idx);\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\npublic int N;\\npublic int M;\\npublic Node[] tree;\\n\\npublic class QueryRes {\\n\\tpublic long cnt;\\n\\tpublic int idx;\\n\\n\\tpublic QueryRes(long cnt, int idx) {\\n\\t\\tthis.cnt = cnt;\\n\\t\\tthis.idx = idx;\\n\\t}\\n}\\n\\npublic class Node {\\n\\tpublic int max;     // max remaining seats in one row\\n\\tpublic long cnt;    // total remaining seats in all rows\\n\\tpublic int m_idx;   // index for $max\\n\\tpublic int c_idx;   // starting index for $cnt\\n\\n\\tpublic void calc(Node n1, Node n2) {\\n\\t\\tmax = Math.Max(n1.max, n2.max);\\n\\t\\tcnt = n1.cnt + n2.cnt;\\n\\t\\tm_idx = n1.max >= n2.max ? n1.m_idx : n2.m_idx;\\n\\t\\tc_idx = Math.Min(n1.c_idx, n2.c_idx);            \\n\\t}\\n\\n\\tpublic int book(int bcnt) {\\n\\t\\tint r = Math.Max(0, bcnt - (int)cnt);\\n\\t\\tcnt = Math.Max(0, (int)cnt - bcnt);\\n\\t\\tmax = (int)cnt;\\n\\t\\tif (cnt == 0) {\\n\\t\\t\\tm_idx = int.MaxValue;\\n\\t\\t\\tc_idx = int.MaxValue;\\n\\t\\t}\\n\\t\\treturn r;\\n\\t}\\n}\\n\\nint updateTreeNode(int idx, int needCnt) {\\n\\tint res = tree[idx + N].book(needCnt);\\n\\t// move upward and update parents\\n\\tfor (int i = idx + N; i > 1; i >>= 1) {\\n\\t\\ttree[i >> 1].calc(tree[i], tree[i^1]);\\n\\t}\\n\\treturn res;\\n}\\n\\nvoid buildTree() {\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\ttree[N + i] = new Node();\\n\\t\\ttree[N + i].max = M; tree[N + i].cnt = M;\\n\\t\\ttree[N + i].m_idx = i; tree[N + i].c_idx = i;\\n\\t}\\n\\t// build the tree by calculating parents\\n\\tfor (int i = N - 1; i > 0; --i) {\\n\\t\\ttree[i] = new Node();\\n\\t\\ttree[i].calc(tree[i << 1], tree[i << 1 | 1]);\\n\\t}\\n}\\n\\nQueryRes query(int l, int r, Action<Node, QueryRes> f) {\\n\\tQueryRes res = new QueryRes(0, int.MaxValue);\\n\\tfor (l += N, r += N; l < r; l >>= 1, r >>= 1) {\\n\\t\\tif ((l&1) > 0) { f(tree[l++], res); }\\n\\t\\tif ((r&1) > 0) { f(tree[--r], res); }\\n\\t}\\n\\treturn res;\\n}\\n\\npublic BookMyShow(int n, int m) {\\n\\tN = 1; M = m;\\n\\twhile(N < n) { N *= 2; }\\n\\ttree = new Node[2 * N];\\n\\tbuildTree();\\n}\\n\\npublic int[] Gather(int k, int maxRow) {        \\n\\tQueryRes res = binarySearch(k, 0, maxRow, MaxFunc);\\n\\tif ((int)res.cnt < k) return (new List<int>()).ToArray();\\n\\n\\tint r1 = res.idx;\\n\\tint r2 = M - (int)res.cnt;\\n\\tupdateTreeNode(res.idx, k);\\n\\treturn new int[2] {r1, r2};\\n}\\n\\npublic bool Scatter(int k, int maxRow) {\\n\\tQueryRes res = binarySearch(k, 0, maxRow, SumFunc);\\n\\tif ((int)res.cnt < k) return false;\\n\\n\\twhile(k > 0) { k = updateTreeNode(res.idx++, k); }\\n\\treturn true;\\n}\\n\\n// query range [l, r)\\npublic QueryRes binarySearch(int k, int l, int r, Action<Node, QueryRes> f) {\\n\\tQueryRes res;\\n\\twhile(l<r) {\\n\\t\\tint m = (l + r)/2;\\n\\t\\tres = query(0, m+1, f);\\n\\t\\tif (res.cnt >= k) { r = m; }\\n\\t\\telse { l = m+1; }\\n\\t}\\n\\tres = query(0, r+1, f);\\n\\treturn res;\\n}\\n\\npublic void MaxFunc(Node node, QueryRes res) {\\n\\tif (node.max > res.cnt) { res.idx = node.m_idx; } \\n\\telse if(node.max == res.cnt && node.m_idx < res.idx) { res.idx = node.m_idx; }\\n\\tres.cnt = Math.Max(res.cnt, node.max);\\n}\\n\\npublic void SumFunc(Node node, QueryRes res) {\\n\\tres.cnt += node.cnt;\\n\\tres.idx = Math.Min(res.idx, node.c_idx);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088139,
                "title": "python-segment-tree-beats-100",
                "content": "Straight forward solution using segment tree, a node coresponding to range `[l,r]` would hold the total seats and the maximum number of empty seats of any row in range `[l,r]`\\n\\n- `add()` function would help us increase the number of seats in a particular row `i`\\n-  `find()` function would help us to find the first row which has the number of empty seats greater than or equal to `k`\\n-  `get()` function would help us to find the total number of seats and maximum number of empty seats of any row in range `[l,r]`\\n\\n1. To gather `k` people with`maxRow`  just `find()` the first row that has the number of empty seats >= `k`, if there exists one, return and update the number of seats in that row\\n2. To scatter `k` peopole with `maxRow`, first check if the total number of seats in range `[0,maxRow]`, if it is greater than or equal than `k` then we can allocate enough seats for the spectators, just traverse rows which still has empty seats in increasing order and update the rows with needed seats (here we can use an array to keep tracks of rows with empty seats or use find funciton to find the first row with empty seats to update, the later is slower by log(n) time but more convenient to implement because we can reuse the `find()` function) \\n\\n```python\\ndef merge(a,b):\\n    return (a[0]+b[0], max(a[1], b[1]))\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.n = n \\n        self.m = m \\n        self.t = [(0,m) for _ in range(4*n)] \\n\\n        \\n    def get(self,i,l,r,s, e):\\n        if l > e or r < s:\\n            return (0,0)\\n        if s <= l <= r <= e:\\n            return self.t[i]\\n        m = l+r>>1\\n        return merge(self.get(i<<1,l,m,s,e), self.get(i<<1|1,m+1,r,s,e)) \\n    \\n    def add(self,i,l,r,idx, v):\\n        if l == r:\\n            self.t[i] = (self.t[i][0] + v, self.t[i][1]-v) \\n        else:\\n            m = l+r>>1\\n            if idx <= m:\\n                self.add(i<<1,l,m,idx,v)\\n            else:\\n                self.add(i<<1|1,m+1,r,idx,v)\\n            self.t[i]= merge(self.t[i<<1], self.t[i<<1|1])\\n            \\n    def find(self,i,l,r,v, maxRow):\\n        if self.t[i][1] < v:\\n            return []\\n      \\n        if l == r :\\n            return  [l, self.get(1, 0, self.n-1, l, l)[0]] \\n        m = l + r >> 1\\n        if m >= maxRow or self.t[i<<1][1] >= v:\\n            return self.find(i<<1,l,m,v,maxRow)\\n        else:\\n            return self.find(i<<1|1,m+1,r,v,maxRow)\\n            \\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        res = self.find(1,0,self.n-1,k,maxRow)\\n        if res:\\n            self.add(1,0,self.n-1,res[0], k) \\n        return res\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        res = self.m * (maxRow+1) - self.get(1,0,self.n-1, 0, maxRow)[0]\\n        if res >= k:\\n            while k:\\n                i = self.find(1,0,self.n-1,1,self.n-1)[0]\\n                v = min(self.get(1,0,self.n-1, i, i)[1], k)\\n                self.add(1,0,self.n-1,i,v)\\n                k -= v \\n            return True\\n        return False\\n\\t\\t\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```python\\ndef merge(a,b):\\n    return (a[0]+b[0], max(a[1], b[1]))\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.n = n \\n        self.m = m \\n        self.t = [(0,m) for _ in range(4*n)] \\n\\n        \\n    def get(self,i,l,r,s, e):\\n        if l > e or r < s:\\n            return (0,0)\\n        if s <= l <= r <= e:\\n            return self.t[i]\\n        m = l+r>>1\\n        return merge(self.get(i<<1,l,m,s,e), self.get(i<<1|1,m+1,r,s,e)) \\n    \\n    def add(self,i,l,r,idx, v):\\n        if l == r:\\n            self.t[i] = (self.t[i][0] + v, self.t[i][1]-v) \\n        else:\\n            m = l+r>>1\\n            if idx <= m:\\n                self.add(i<<1,l,m,idx,v)\\n            else:\\n                self.add(i<<1|1,m+1,r,idx,v)\\n            self.t[i]= merge(self.t[i<<1], self.t[i<<1|1])\\n            \\n    def find(self,i,l,r,v, maxRow):\\n        if self.t[i][1] < v:\\n            return []\\n      \\n        if l == r :\\n            return  [l, self.get(1, 0, self.n-1, l, l)[0]] \\n        m = l + r >> 1\\n        if m >= maxRow or self.t[i<<1][1] >= v:\\n            return self.find(i<<1,l,m,v,maxRow)\\n        else:\\n            return self.find(i<<1|1,m+1,r,v,maxRow)\\n            \\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        res = self.find(1,0,self.n-1,k,maxRow)\\n        if res:\\n            self.add(1,0,self.n-1,res[0], k) \\n        return res\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        res = self.m * (maxRow+1) - self.get(1,0,self.n-1, 0, maxRow)[0]\\n        if res >= k:\\n            while k:\\n                i = self.find(1,0,self.n-1,1,self.n-1)[0]\\n                v = min(self.get(1,0,self.n-1, i, i)[1], k)\\n                self.add(1,0,self.n-1,i,v)\\n                k -= v \\n            return True\\n        return False\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088069,
                "title": "beat-segment-tree-solution-sorteddict-sortedlist",
                "content": "As python public library supports sorded dict and sorted list, I try to write out another straightfoward and efficient method.\\n\\n* **trick 1:** Use sorded dict to track different num of seats in each row. SortedDict(seats num: SortedList(row index)). Then, we can use binary search to find the close possible min index.\\n* **trick 2:** Use list to track remaining seats and record the lower bound of the row of available seats.\\n\\n```\\nfrom bisect import bisect_left\\nfrom sortedcontainers import SortedList, SortedDict\\n\\nclass BookMyShow: # best 1002 ms\\n    def __init__(self, n: int, m: int):\\n        self.num_seats = m\\n        self.rows = n\\n        self.all_seats = [m] * n\\n        self.min_ok_row = 0\\n\\n        rows = SortedList([*range(n)])\\n        self.max_seats = SortedDict()\\n        self.max_seats[m] = rows\\n        \\n    def pop_max_seats(self, seats):\\n        self.max_seats[seats].pop(0)\\n        if not self.max_seats[seats]:\\n            del self.max_seats[seats]\\n    \\n    def update_max_seats(self, seats, row):\\n        if seats in self.max_seats:\\n            self.max_seats[seats].add(row)\\n        else:\\n            self.max_seats[seats] = SortedList([row])\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        keys = self.max_seats.keys()\\n        if not keys or k > self.num_seats: return []\\n        \\n        # find the closest or equal num of seats of k\\n        i = bisect_left(keys, k)\\n        \\n        # there may be large num of seats in a smaller row\\n        min_row = self.rows \\n        seats = 0\\n        for j in range(i, len(keys)):\\n            if self.max_seats[keys[j]][0] < min_row:\\n                min_row = self.max_seats[keys[j]][0]\\n                seats = keys[j]\\n                \\n        if min_row > maxRow:\\n            return []\\n        \\n        seats_num = self.num_seats - seats\\n        # remove the found node of min row\\n        self.pop_max_seats(seats)\\n        \\n        seats -= k\\n        \\n        if seats: # remaining seats in this row\\n            # add the new node\\n            self.update_max_seats(seats, min_row)\\n        \\n        self.all_seats[min_row] -= k\\n\\n        return [min_row, seats_num]\\n\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        # the edge case\\n        if (maxRow+1) * self.num_seats < k: \\n            return False\\n        \\n        # cusum from min row of available seats\\n        cusum = 0\\n        r = self.min_ok_row\\n        for i in range(r, maxRow+1):           \\n            seats = self.all_seats[i]\\n            cusum += seats\\n            if cusum < k: continue\\n                \\n            # find out all available seats until i row \\n            # clean nodes in self.max_seats\\n            for j in range(r, i+1):\\n                seats = self.all_seats[j]\\n                if not seats: \\n                    continue\\n                self.pop_max_seats(seats)\\n\\n            seats = cusum - k\\n            if seats:\\n                self.min_ok_row = i\\n                self.all_seats[i] = seats\\n                self.update_max_seats(seats, i)\\n            else: \\n                self.min_ok_row = i + 1\\n            return True\\n\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\nfrom sortedcontainers import SortedList, SortedDict\\n\\nclass BookMyShow: # best 1002 ms\\n    def __init__(self, n: int, m: int):\\n        self.num_seats = m\\n        self.rows = n\\n        self.all_seats = [m] * n\\n        self.min_ok_row = 0\\n\\n        rows = SortedList([*range(n)])\\n        self.max_seats = SortedDict()\\n        self.max_seats[m] = rows\\n        \\n    def pop_max_seats(self, seats):\\n        self.max_seats[seats].pop(0)\\n        if not self.max_seats[seats]:\\n            del self.max_seats[seats]\\n    \\n    def update_max_seats(self, seats, row):\\n        if seats in self.max_seats:\\n            self.max_seats[seats].add(row)\\n        else:\\n            self.max_seats[seats] = SortedList([row])\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        keys = self.max_seats.keys()\\n        if not keys or k > self.num_seats: return []\\n        \\n        # find the closest or equal num of seats of k\\n        i = bisect_left(keys, k)\\n        \\n        # there may be large num of seats in a smaller row\\n        min_row = self.rows \\n        seats = 0\\n        for j in range(i, len(keys)):\\n            if self.max_seats[keys[j]][0] < min_row:\\n                min_row = self.max_seats[keys[j]][0]\\n                seats = keys[j]\\n                \\n        if min_row > maxRow:\\n            return []\\n        \\n        seats_num = self.num_seats - seats\\n        # remove the found node of min row\\n        self.pop_max_seats(seats)\\n        \\n        seats -= k\\n        \\n        if seats: # remaining seats in this row\\n            # add the new node\\n            self.update_max_seats(seats, min_row)\\n        \\n        self.all_seats[min_row] -= k\\n\\n        return [min_row, seats_num]\\n\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        # the edge case\\n        if (maxRow+1) * self.num_seats < k: \\n            return False\\n        \\n        # cusum from min row of available seats\\n        cusum = 0\\n        r = self.min_ok_row\\n        for i in range(r, maxRow+1):           \\n            seats = self.all_seats[i]\\n            cusum += seats\\n            if cusum < k: continue\\n                \\n            # find out all available seats until i row \\n            # clean nodes in self.max_seats\\n            for j in range(r, i+1):\\n                seats = self.all_seats[j]\\n                if not seats: \\n                    continue\\n                self.pop_max_seats(seats)\\n\\n            seats = cusum - k\\n            if seats:\\n                self.min_ok_row = i\\n                self.all_seats[i] = seats\\n                self.update_max_seats(seats, i)\\n            else: \\n                self.min_ok_row = i + 1\\n            return True\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087204,
                "title": "tle-94-94-test-cases-passed-bit",
                "content": "```\\nclass BookMyShow {\\npublic:\\n    long long int BIT[100000] = {};\\n    long long int row[100000] = {};\\n    int lo = 0;\\n    long long int M;\\n    long long int N;\\n    BookMyShow(int n, int m) {\\n        M = m;\\n        N = n;\\n        \\n        for(int i=0;i<n;i++) update(i, M);\\n    }\\n    \\n    long long int tot(int n){\\n        n++;\\n        long long int sum = 0;\\n        while(n > 0){\\n            sum += BIT[n];\\n            n -= n&(-n);\\n        }\\n        return sum;\\n    }\\n    \\n    void update(int n, int val){\\n        n++;\\n        while(n <= N){\\n            BIT[n] += val;\\n            n += n&(-n);\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        if(lo > maxRow) return {};\\n        long long int sum = tot(maxRow);\\n        if(sum < k) return {};\\n        int ind = lo;\\n        while(ind <= maxRow){\\n            long long int seat = M - row[ind];\\n            if(seat >= k){\\n                update(ind, -1*k);\\n                row[ind] += k;\\n                return {ind, (int)(M - seat)};\\n            }\\n            ind++;\\n        }\\n        return {};\\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        \\n        if(lo > maxRow) return false; \\n        long long int seat = tot(maxRow);\\n        if(seat < k) return false;\\n        while(k){\\n            long long int seat = M - row[lo];\\n            update(lo, -1*min({seat, k*1ll}));\\n            if(k >= seat) row[lo] = M;\\n            else row[lo] += k;\\n            k -= min({seat, k*1ll});\\n            if(k == 0) break;\\n            lo++;\\n            if(lo > maxRow) break;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    long long int BIT[100000] = {};\\n    long long int row[100000] = {};\\n    int lo = 0;\\n    long long int M;\\n    long long int N;\\n    BookMyShow(int n, int m) {\\n        M = m;\\n        N = n;\\n        \\n        for(int i=0;i<n;i++) update(i, M);\\n    }\\n    \\n    long long int tot(int n){\\n        n++;\\n        long long int sum = 0;\\n        while(n > 0){\\n            sum += BIT[n];\\n            n -= n&(-n);\\n        }\\n        return sum;\\n    }\\n    \\n    void update(int n, int val){\\n        n++;\\n        while(n <= N){\\n            BIT[n] += val;\\n            n += n&(-n);\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        if(lo > maxRow) return {};\\n        long long int sum = tot(maxRow);\\n        if(sum < k) return {};\\n        int ind = lo;\\n        while(ind <= maxRow){\\n            long long int seat = M - row[ind];\\n            if(seat >= k){\\n                update(ind, -1*k);\\n                row[ind] += k;\\n                return {ind, (int)(M - seat)};\\n            }\\n            ind++;\\n        }\\n        return {};\\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        \\n        if(lo > maxRow) return false; \\n        long long int seat = tot(maxRow);\\n        if(seat < k) return false;\\n        while(k){\\n            long long int seat = M - row[lo];\\n            update(lo, -1*min({seat, k*1ll}));\\n            if(k >= seat) row[lo] = M;\\n            else row[lo] += k;\\n            k -= min({seat, k*1ll});\\n            if(k == 0) break;\\n            lo++;\\n            if(lo > maxRow) break;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087119,
                "title": "scala-bruteforce-version-is-accepted",
                "content": "During the contest I tried to solve the problem in O(log*(n)) and failed to complete it in time. After the contest I read the discussions and found out that bruteforce approach was accepted. So that\\'s the bruteforce version:\\n\\n```scala\\nclass BookMyShow(_n: Int, _m: Int) {\\n\\n  val nonPossible = Array.empty[Int]\\n\\n  val arr = Array.fill(_n)(_m)\\n\\n  def gather(k: Int, maxRow: Int): Array[Int] = {\\n    val ind = arr.indexWhere(_ >= k)\\n    if(ind == -1) nonPossible\\n    else if(ind > maxRow) nonPossible\\n    else {\\n      arr(ind) = arr(ind) - k\\n      Array(ind, _m - arr(ind) - k)\\n    }\\n  }\\n\\n  def scatter(k: Int, maxRow: Int): Boolean = {\\n    def checkScatter(i: Int, acc: Int): Boolean =\\n      if(i > maxRow) false\\n      else {\\n        val nAcc = acc + arr(i)\\n        if(nAcc >= k) true else checkScatter(i + 1, nAcc)\\n      }\\n\\n    val check = checkScatter(0, 0)\\n    if(check) book(0, k)\\n    check\\n  }\\n\\n  def book(i: Int, k: Int): Unit =\\n    if(k > 0) {\\n      val subtr = math.min(arr(i), k)\\n      arr(i) -= subtr\\n      book(i + 1, k - subtr)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nclass BookMyShow(_n: Int, _m: Int) {\\n\\n  val nonPossible = Array.empty[Int]\\n\\n  val arr = Array.fill(_n)(_m)\\n\\n  def gather(k: Int, maxRow: Int): Array[Int] = {\\n    val ind = arr.indexWhere(_ >= k)\\n    if(ind == -1) nonPossible\\n    else if(ind > maxRow) nonPossible\\n    else {\\n      arr(ind) = arr(ind) - k\\n      Array(ind, _m - arr(ind) - k)\\n    }\\n  }\\n\\n  def scatter(k: Int, maxRow: Int): Boolean = {\\n    def checkScatter(i: Int, acc: Int): Boolean =\\n      if(i > maxRow) false\\n      else {\\n        val nAcc = acc + arr(i)\\n        if(nAcc >= k) true else checkScatter(i + 1, nAcc)\\n      }\\n\\n    val check = checkScatter(0, 0)\\n    if(check) book(0, k)\\n    check\\n  }\\n\\n  def book(i: Int, k: Int): Unit =\\n    if(k > 0) {\\n      val subtr = math.min(arr(i), k)\\n      arr(i) -= subtr\\n      book(i + 1, k - subtr)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086958,
                "title": "tle-91-94-passed-c",
                "content": "```\\nclass BookMyShow {\\nprivate:\\n    int n,m;\\n    vector<long long> row_seats;\\npublic:\\n    BookMyShow(int N, int M) {\\n        n = N;\\n        m = M;\\n        vector<long long> seats(n, m);\\n        row_seats = seats;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        \\n        for(int i=0;i<=maxRow;i++)\\n        {\\n            if(row_seats[i] >= k)\\n            {\\n                int first = m - row_seats[i];\\n                row_seats[i] -= k;\\n                return {i,first};\\n            }\\n        }\\n        return {};\\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long sum = 0;\\n        for(int i=0;i<=maxRow;i++)\\n            sum += row_seats[i];\\n        if(sum < k)\\n            return false;\\n        for(int i=0;i<=maxRow;i++)\\n        {\\n            if(row_seats[i] < k)\\n            {\\n                k = k - row_seats[i];\\n                row_seats[i] = 0;\\n            }\\n            else\\n            {\\n                row_seats[i] -= k;\\n                break;\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass BookMyShow {\\nprivate:\\n    int n,m;\\n    vector<long long> row_seats;\\npublic:\\n    BookMyShow(int N, int M) {\\n        n = N;\\n        m = M;\\n        vector<long long> seats(n, m);\\n        row_seats = seats;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        \\n        for(int i=0;i<=maxRow;i++)\\n        {\\n            if(row_seats[i] >= k)\\n            {\\n                int first = m - row_seats[i];\\n                row_seats[i] -= k;\\n                return {i,first};\\n            }\\n        }\\n        return {};\\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long sum = 0;\\n        for(int i=0;i<=maxRow;i++)\\n            sum += row_seats[i];\\n        if(sum < k)\\n            return false;\\n        for(int i=0;i<=maxRow;i++)\\n        {\\n            if(row_seats[i] < k)\\n            {\\n                k = k - row_seats[i];\\n                row_seats[i] = 0;\\n            }\\n            else\\n            {\\n                row_seats[i] -= k;\\n                break;\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086947,
                "title": "c-max-sum-seg-beat-100-700ms",
                "content": "```\\nnamespace myleetcode{\\ntypedef long long ll;\\nstatic long long pow10[18] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, (ll)(1e+9), (ll)1e+10, (ll)1e+11, (ll)1e+12, (ll)1e+13, (ll)1e+14, (ll)1e+15, (ll)1e+16, (ll)1e+17 }; \\n#define gcd(x_,y_) __gcd(x_,y_)\\n//bit mask related\\n#define cnt1(x_) __builtin_popcount(x_)\\n#define first1(x_)  31-__builtin_clz(x_)\\n#define last1 (x_)  __builtin_ffs(x_)-1\\n#define pari1(x_)  __builtin_parity(x_)\\n//digit mask related\\n#define first10(x_) (int)(log10(x_))\\n#define dig10(x_,i_) (ll)(x_/pow10[i_])%10 \\n// string, char related\\n#define sub_s(s_,i_,j_) s_.substr( (i_), (j_)-(i_)+1)\\n#define c2i(c_ )   ((islower(c_))? (int)( (c_)-\\'a\\'):(int)( (c_)-\\'A\\'))\\n#define s2i(s_ )    (stoi((s_),0,10))\\n#define s2l(s_ )    (stoll( (s_),0,10))\\n#define i2s(i_ )    (to_string((i_)))\\n#define is_d(c_ )   isdigit(c_)\\n#define is_l(c_ )   islower(c_)\\n#define is_u(c_ )   isupper(c_)\\n#define to_u(s_ )   for(auto& c_:s_){c_=toupper(c_)}\\n#define to_l(s_ )   for(auto& c_:s_){c_=tolower(c_)}\\n#define gt(t_, i_) get<i_>(t_)\\n//vector,map, set container related\\n#define rand_shuffle(v_) random_shuffle(v_.begin(), v_.end())\\n#define min_e(v_) *min_element(v_.begin(), v_.end())\\n#define max_e(v_) *max_element(v_.begin(), v_.end())\\n#define acc(v_) accumulate(v_.begin(), v_.end(),0L)\\n#define in_v(v_,x_) (v_.size()>0 && (x_)!=(v_).end())\\n#define ubd(t_) upper_bound( (t_))\\n#define lbd(t_) lower_bound( (t_))\\n#define lbdv(v_, t_) lower_bound(v_.begin(), v_.end(), (t_))\\n#define ubdv(v_, t_) upper_bound(v_.begin(), v_.end(), (t_))\\n#define smallv(v_,t_) (sz(v_)==0|| v_[0]>=t_)? v_.end():--lbdv(v_,t_)\\n#define smallm(m_,t_) (sz(m_)==0|| (*m_.begin()).first>=t_)? m_.end():--m_.lbd(t_)\\n#define smalls(s_,t_) (sz(s_)==0|| (*s_.begin())>=t_)? s_.end():--s_.lbd(t_)\\n#define small(s_,t_)  smalls(s_,t_)\\n#define small_eqv(v_,t_) ({auto tmp= v_.end(); (sz(v_)==0|| v_[0]>t_)? tmp :((*(tmp=lbdv(v_,t_))==t_)? tmp: --tmp);})\\n#define small_eqs(s_,t_) ((s_).count(t_))? (s_).find(t_): (smalls(s_,t_))\\n#define small_eqm(m_,t_) ((m_).count(t_))? (m_).find(t_): (smallm(m_,t_))\\n#define small_eq(m_,t_) small_eqm(m_, t_)\\n#define bigv(v_,t_) ubdv(v_,t_)\\n#define big_eqv(v_,t_) lbdv(v_,t_)\\n#define big(v_,t_) v_.ubd(t_)\\n#define big_eq(v_,t_) v_.lbd(t_)\\n#define bigs(v_,t_) v_.ubd(t_)\\n#define big_eqs(v_,t_) v_.lbd(t_)\\n#define bigm(v_,t_) v_.ubd(t_)\\n#define big_eqm(v_,t_) v_.lbd(t_)\\n#define srt(v_) sort(v_.begin(), v_.end())\\n#define srt_(v_, cmp_) sort(v_.begin(), v_.end(), (cmp_))\\n// control related\\n#define rep(i_, a_, b_) for(int i_ = a_; (i_) <= (b_); (i_)++)\\n#define repv(x_, v_) for(auto x_ = v_.begin(); x_!=v_.end(); x_++)\\n#define perv(x_, v_) for(auto x_ = -\\u2014v_.end(); ; x_\\u2014-)\\n#define per(i_,b_,a_) for(int i_=(b_);i_>=(a_);(i_--))\\n#define pri_1d(v_) for(auto& x:v_){cout<<x<<\" \";}cout<<endl;\\n#define pri_2d(v_) for(auto& x:v_){for(auto& y:x){cout<<y<<\" \";} cout<<endl;}\\n#define pri_pii(v_) for(auto& x:v_){cout<<x.fi<<\" \"<<x.se<<endl;}\\n#define iff(C1_, C2_, a_, b_, c_) ((C1_))? (a_):( (C2_)? (b_):(c_)) //if(C1) a_, else if(C2) b_, else c_\\n#define ifff(C1_, C2_, C3_, a_, b_, c_, d_) ((C1_))? (a_):( (C2_)? (b_):( (C3_)? (c_):(d_)))   \\n// useful constant or condition\\n#define MOD (long long)((1e+9)+7)\\n#define PRIM (10007)\\n#define IN_REC (xx>=0&&yy>=0&&xx<N&&yy<M)\\n#define PI 3.1415926\\n#define NPO (string::npos)\\n#define trav(a_, x_) for(auto& a_ : x_)\\n#define sz(x_) ((int)((x_).size()))\\n// useful abbreviation\\n#define mt make_tuple\\n#define em emplace\\n#define ffo find_first_of\\n#define pb push_back\\n#define pu_b push_back\\n#define eb emplace_back\\n#define pu_f push_front\\n#define po_b pop_back\\n#define po_f pop_front\\n#define pu push\\n#define po pop\\n#define ins insert\\n#define era erase\\n#define fi first\\n#define se second\\n#define nl nullptr\\n// error function\\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), \\',\\', \\' \\'); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\\nvoid err(istream_iterator<string> it) {}\\ntemplate<typename T, typename... Args>\\nvoid err(istream_iterator<string> it, T a, Args... args) {cout << *it << \" = \" << a << endl;err(++it, args...);}\\n// abbreviation of class type\\ntypedef enum {AND, OR, XOR, SUM, MAX, MIN, MAJ} merge_method;\\ntypedef queue<int> qi;\\ntypedef queue<pair<int,int>> qpii;\\ntypedef deque<int> dqi;\\ntypedef deque<pair<int,int>> dqpii;\\n//typedef long long ll;\\ntypedef pair<int, int> pii;\\ntypedef tuple<int,int> t2i;\\ntypedef tuple<int,int,int> t3i;\\ntypedef pair<ll, ll> pll;\\ntypedef vector<int> vi;\\ntypedef vector<ll> vl;\\ntypedef vector<t2i> vt2i;\\ntypedef vector<string> vs;\\ntypedef vector<vs> vss;\\ntypedef vector<bool> vb;\\ntypedef vector<pair<int,int>> vpii;\\ntypedef vector<vector<int>> vii;\\ntypedef vector<vector<long long>> vll;\\ntypedef vector<vector<bool>> vbb;\\ntypedef unordered_map<int,string> ump_is;\\ntypedef unordered_map<string, int> ump_si;\\ntypedef unordered_map<int,int> ump_ii;\\ntypedef unordered_map<string,string> ump_ss;\\ntypedef map<string,string> mp_ss;\\ntypedef map<int,int> mp_ii;\\ntypedef map<int,string> mp_is;\\ntypedef unordered_set<int> ust_i;\\ntypedef unordered_set<string> ust_s;\\ntypedef tuple<ll,ll,ll> t3l;\\ntypedef tuple<ll,ll> t2l;   \\ntypedef tuple<ll,ll,ll,ll> t4l;\\ntypedef set<pair<int,int>> st_pii;\\ntypedef set<t3l> st_t3l;  \\ntypedef set<int> st_i;\\ntypedef set<string> st_s;\\ntypedef tuple<string, int, int> my_tu; // for multi objective sorting \\nvii nb={{-1,0},{1,0},{0,-1},{0,1}}; \\nvii nb8={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\nint M, N, ANS; \\nstruct cmp{ bool operator()(const vi& a, const vi& b)const {return (a[0]== b[0])? a[1]>b[1]: a[0]<b[0];}} cmp_obj;\\nint inv(ll x){ll t= MOD-2;  ll ans=1; while(t>0){ if(t%2) ans= ((ans)*x)%MOD;   x=(x*x)%MOD; t= t>>1;} return (int)ans;}\\nll pow_mod(ll x, ll y){ll ans=1; while(y>0){if(y%2) ans=(ans*x)%MOD;  x=(x*x)%MOD; y=y>>1;} return ans; }\\nbool eq_db(double x, double y){ return abs(x-y)<0.0001;}\\ntemplate<typename T > inline void amin(T &x, T y) { if (y<x) x=y;}\\n /// debeg   \\ntemplate<typename T, typename... Args > inline void amin(T &x, T y,Args... args) { if (y<x) x=y; amin(x, args...); }\\ntemplate<typename T > inline void amax(T &x, T y) { if (y>x) x=y;}\\ntemplate<typename T, typename... Args > inline void amax(T &x, T y,Args... args) { if (y>x) x=y; amax(x, args...); }\\ntemplate<class T>  inline ll md(T x, T y) { ll tmp=x%y; return (tmp<0)? tmp+y:tmp;}\\n//output for debugging\\n\\ntemplate<typename T1, typename T2 >\\nostream& operator<<(ostream& os, pair<T1,T2> p) {os<<p.first<<\" \"<<p.second<<\" \"; return os;}\\ntemplate<typename T1, typename T2 >\\nostream& operator<<(ostream& os, unordered_map<T1,T2> mp) { for(auto& x:mp) os<<x.first<<\" \"<<x.second<<endl; return os;}\\ntemplate<typename T1, typename T2 >\\nostream& operator<<(ostream& os, map<T1,T2> mp) { for(auto& x:mp) os<<x.first<<\" \"<<x.second<<endl; return os;}\\ntemplate<typename T1 >\\nostream& operator<<(ostream& os, vector<T1> v) { for(auto&x:v) os<<x<<\" \"; return os;}\\ntemplate<typename T1 >\\nostream& operator<<(ostream& os, set<T1> v) { for(auto&x:v) os<<x<<\" \"; return os;}\\ntemplate<typename T1 >\\nostream& operator<<(ostream& os, unordered_set<T1> v) { for(auto&x:v) os<<x<<\" \"; return os;}\\ntemplate<typename T1 >\\nostream& operator<<(ostream& os, vector<vector<T1>> v) { for(auto& x:v) {for(auto& y:x) {os<<y<<\" \";} os<<endl;} return os;}\\n}\\nusing namespace myleetcode;\\n\\nclass BookMyShow {\\npublic:\\n \\n    mp_ii row;\\n    int  m,n;\\n      struct SEGT {\\n          vl tree; vi cnt; int len; merge_method meth; vi ori; SEGT(){;}\\n\\tSEGT(int n, merge_method m, int ini){ tree=vl(4*(n+1), ini); ori=vi(n,ini); meth=m; len=n;}\\n\\tSEGT(merge_method m, vi& v){ int n=v.size(); tree=vl(4*(n+1), 0);  meth=m; len=n; ori=vi(v); \\n                                 if(meth==MAJ) {cnt=vi(4*(n+1), 1);}\\n\\t  construct(0, n-1,0);\\n\\t}\\n        void construct(int left, int right, int indx){\\n\\t\\tif(left==right) { tree[indx]=ori[left]; if(meth==MAJ) cnt[left]=1;}\\n\\t\\telse{ int mid=(right-left)/2+left;  construct(left, mid, indx*2+1); construct(mid+1, right,indx*2+2); \\n\\t\\t\\tif(meth!=MAJ) tree[indx]=merge(tree[indx*2+1], tree[indx*2+2]); \\n\\t\\t\\telse{ cnt[indx]= (tree[indx*2+1]!=tree[indx*2+2])? abs(cnt[indx*2+1]- cnt[indx*2+2]): cnt[indx*2+1]+cnt[indx*2+2];\\n\\t\\t\\t\\ttree[indx]=merge(tree[indx*2+1], tree[indx*2+2], cnt[indx*2+1], cnt[indx*2+2] ); \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvoid update(int target, ll val){ ori[target]=(int)val; update(target, 0, len-1, 0);}\\n    ll   query(int front, int end){ if(meth!=MAJ) return query(front, end, 0,len-1,0); \\n                                     else         return query_maj(front, end,0,len-1,0).fi;}\\n    ll merge(ll a, ll b, int a_more=0, int b_more=0 ){\\n        if(meth==XOR) { if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a^b; }\\n        else if(meth==OR) { if(a==INT_MIN) return b; else if(b==INT_MIN) return a;  else return a|b;}\\n        else if(meth==AND) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a&b;}\\n        else if(meth==SUM) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a+b;}\\n        else if(meth==MAX) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return max(a,b);}\\n        else if(meth==MIN)  {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return min(a,b); }\\n       else if(meth==MAJ)  {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else { return (a_more>=b_more)? a:b; } }\\n        return 0;\\n    }\\n    void update(int target, int left, int right, int indx){\\n            if(target<left||target>right) return ;\\n            if(left==right) {if(left==target) tree[indx]=ori[target]; return;}\\n             int mid= (right-left)/2+left; \\n             if(target<=mid) update(target,left,mid,indx*2+1); \\n             else            update(target,mid+1,right,indx*2+2);\\n             if(meth!=MAJ) tree[indx]= merge(tree[indx*2+1], tree[indx*2+2]);\\n            else { cnt[indx]= (tree[indx*2+1]!=tree[indx*2+2])?abs(cnt[indx*2+1]- cnt[indx*2+2]): cnt[indx*2+1]+cnt[indx*2+2];\\n                     tree[indx]= merge(tree[indx*2+1], tree[indx*2+2], cnt[indx*2+1], cnt[indx*2+2]);\\n\\t\\t}     \\n      }\\n   pii query_maj(int front, int end, int left, int right, int indx){\\n\\tif(end<left|| front>right) return {INT_MIN,0};\\n        if(left==right){ if(left>=front&& end>=left) return {ori[left],1}; else return {INT_MIN,0};}\\n        else if( front<=left&& right<=end) return {(int)tree[indx], (int)cnt[indx]};\\n        else{  int mid= (right-left)/2+left; \\n             pii f1=   query_maj(front, end,left,mid,indx*2+1);  pii f2= query_maj(front,end,mid+1,right,indx*2+2);\\n\\t    if(f1.fi==f2.fi) return {f1.fi, f1.se+f2.se};\\n            else{ return {  (f1.se>f2.se)? f1.fi: f2.fi, abs(f1.se-f2.se)}; }\\n        }\\n    }\\n    ll query(int front, int end, int left,int right,int indx){\\n        if(end<left|| front>right) return INT_MIN;\\n        if(left==right){ if(left>=front&& end>=left) return tree[indx]; else return INT_MIN;}\\n        else if( front<=left&& right<=end) return tree[indx];\\n        else{  int mid= (right-left)/2+left; \\n               ll f1=   query(front, end,left,mid,indx*2+1);  ll f2= query(front,end,mid+1,right,indx*2+2);\\n             return merge(f1,f2);\\n        }\\n    }\\n }; // binary index tree \\n    SEGT maxSeg, sumSeg;\\n    bool isLE(int r, int target){  return maxSeg.query(0, r)>=target;}\\n    BookMyShow(int nn, int mm) { m=mm; n=nn; vi tmp(n,m);\\n                                maxSeg=SEGT(MAX, tmp); sumSeg=SEGT(SUM, tmp);\\n                                for(int i=0;i<n;i++) { row[i]=m; }\\n                               }\\n    \\n    // (false , false,true)\\n    vector<int> gather(int k, int maxRow) {\\n        int left=0; int right= maxRow;\\n        int target=left;\\n        while(right>=left){ int mid=(right-left)/2+left;\\n            if(right==left){ if(isLE(left,k)){target=left;break;} else {return {}; }}\\n            else if(right-left==1){ if(isLE(left,k)){target=left;break;} \\n                                    if(isLE(right,k)){target=right;break;}\\n                               if(right==maxRow){ return {}; } else {target=right+1; break;}\\n                             }\\n            else{ if(isLE(mid,k)) right=mid;  else left=mid;}\\n        }\\n        row[target]-=k; int tmp=row[target]; \\n        maxSeg.update(target, tmp); sumSeg.update(target,tmp);\\n        vi ans={target,m-tmp-k};\\n        if(tmp==0) row.era(target);\\n        \\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) { int tmp=0; vi cand;\\n        if((ll)k>sumSeg.query(0,maxRow)) return false;\\n        for(auto&x:row){\\n            if(x.fi>maxRow) break;\\n            tmp+=x.se; cand.pb(x.fi); sumSeg.update(x.fi,0); maxSeg.update(x.fi,0); if(tmp>=k) break;\\n        }\\n        for(int i=0;i<sz(cand)-1;i++) {row.era(cand[i]); }\\n        row[cand.back()]=tmp-k;     \\n        if(row[cand.back()]==0) row.era(cand.back());\\n        else { sumSeg.update(cand.back(),tmp-k); maxSeg.update(cand.back(), tmp-k); }\\n        //cout<<row<<endl;\\n        return true;                             \\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nnamespace myleetcode{\\ntypedef long long ll;\\nstatic long long pow10[18] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, (ll)(1e+9), (ll)1e+10, (ll)1e+11, (ll)1e+12, (ll)1e+13, (ll)1e+14, (ll)1e+15, (ll)1e+16, (ll)1e+17 }; \\n#define gcd(x_,y_) __gcd(x_,y_)\\n//bit mask related\\n#define cnt1(x_) __builtin_popcount(x_)\\n#define first1(x_)  31-__builtin_clz(x_)\\n#define last1 (x_)  __builtin_ffs(x_)-1\\n#define pari1(x_)  __builtin_parity(x_)\\n//digit mask related\\n#define first10(x_) (int)(log10(x_))\\n#define dig10(x_,i_) (ll)(x_/pow10[i_])%10 \\n// string, char related\\n#define sub_s(s_,i_,j_) s_.substr( (i_), (j_)-(i_)+1)\\n#define c2i(c_ )   ((islower(c_))? (int)( (c_)-\\'a\\'):(int)( (c_)-\\'A\\'))\\n#define s2i(s_ )    (stoi((s_),0,10))\\n#define s2l(s_ )    (stoll( (s_),0,10))\\n#define i2s(i_ )    (to_string((i_)))\\n#define is_d(c_ )   isdigit(c_)\\n#define is_l(c_ )   islower(c_)\\n#define is_u(c_ )   isupper(c_)\\n#define to_u(s_ )   for(auto& c_:s_){c_=toupper(c_)}\\n#define to_l(s_ )   for(auto& c_:s_){c_=tolower(c_)}\\n#define gt(t_, i_) get<i_>(t_)\\n//vector,map, set container related\\n#define rand_shuffle(v_) random_shuffle(v_.begin(), v_.end())\\n#define min_e(v_) *min_element(v_.begin(), v_.end())\\n#define max_e(v_) *max_element(v_.begin(), v_.end())\\n#define acc(v_) accumulate(v_.begin(), v_.end(),0L)\\n#define in_v(v_,x_) (v_.size()>0 && (x_)!=(v_).end())\\n#define ubd(t_) upper_bound( (t_))\\n#define lbd(t_) lower_bound( (t_))\\n#define lbdv(v_, t_) lower_bound(v_.begin(), v_.end(), (t_))\\n#define ubdv(v_, t_) upper_bound(v_.begin(), v_.end(), (t_))\\n#define smallv(v_,t_) (sz(v_)==0|| v_[0]>=t_)? v_.end():--lbdv(v_,t_)\\n#define smallm(m_,t_) (sz(m_)==0|| (*m_.begin()).first>=t_)? m_.end():--m_.lbd(t_)\\n#define smalls(s_,t_) (sz(s_)==0|| (*s_.begin())>=t_)? s_.end():--s_.lbd(t_)\\n#define small(s_,t_)  smalls(s_,t_)\\n#define small_eqv(v_,t_) ({auto tmp= v_.end(); (sz(v_)==0|| v_[0]>t_)? tmp :((*(tmp=lbdv(v_,t_))==t_)? tmp: --tmp);})\\n#define small_eqs(s_,t_) ((s_).count(t_))? (s_).find(t_): (smalls(s_,t_))\\n#define small_eqm(m_,t_) ((m_).count(t_))? (m_).find(t_): (smallm(m_,t_))\\n#define small_eq(m_,t_) small_eqm(m_, t_)\\n#define bigv(v_,t_) ubdv(v_,t_)\\n#define big_eqv(v_,t_) lbdv(v_,t_)\\n#define big(v_,t_) v_.ubd(t_)\\n#define big_eq(v_,t_) v_.lbd(t_)\\n#define bigs(v_,t_) v_.ubd(t_)\\n#define big_eqs(v_,t_) v_.lbd(t_)\\n#define bigm(v_,t_) v_.ubd(t_)\\n#define big_eqm(v_,t_) v_.lbd(t_)\\n#define srt(v_) sort(v_.begin(), v_.end())\\n#define srt_(v_, cmp_) sort(v_.begin(), v_.end(), (cmp_))\\n// control related\\n#define rep(i_, a_, b_) for(int i_ = a_; (i_) <= (b_); (i_)++)\\n#define repv(x_, v_) for(auto x_ = v_.begin(); x_!=v_.end(); x_++)\\n#define perv(x_, v_) for(auto x_ = -\\u2014v_.end(); ; x_\\u2014-)\\n#define per(i_,b_,a_) for(int i_=(b_);i_>=(a_);(i_--))\\n#define pri_1d(v_) for(auto& x:v_){cout<<x<<\" \";}cout<<endl;\\n#define pri_2d(v_) for(auto& x:v_){for(auto& y:x){cout<<y<<\" \";} cout<<endl;}\\n#define pri_pii(v_) for(auto& x:v_){cout<<x.fi<<\" \"<<x.se<<endl;}\\n#define iff(C1_, C2_, a_, b_, c_) ((C1_))? (a_):( (C2_)? (b_):(c_)) //if(C1) a_, else if(C2) b_, else c_\\n#define ifff(C1_, C2_, C3_, a_, b_, c_, d_) ((C1_))? (a_):( (C2_)? (b_):( (C3_)? (c_):(d_)))   \\n// useful constant or condition\\n#define MOD (long long)((1e+9)+7)\\n#define PRIM (10007)\\n#define IN_REC (xx>=0&&yy>=0&&xx<N&&yy<M)\\n#define PI 3.1415926\\n#define NPO (string::npos)\\n#define trav(a_, x_) for(auto& a_ : x_)\\n#define sz(x_) ((int)((x_).size()))\\n// useful abbreviation\\n#define mt make_tuple\\n#define em emplace\\n#define ffo find_first_of\\n#define pb push_back\\n#define pu_b push_back\\n#define eb emplace_back\\n#define pu_f push_front\\n#define po_b pop_back\\n#define po_f pop_front\\n#define pu push\\n#define po pop\\n#define ins insert\\n#define era erase\\n#define fi first\\n#define se second\\n#define nl nullptr\\n// error function\\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), \\',\\', \\' \\'); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\\nvoid err(istream_iterator<string> it) {}\\ntemplate<typename T, typename... Args>\\nvoid err(istream_iterator<string> it, T a, Args... args) {cout << *it << \" = \" << a << endl;err(++it, args...);}\\n// abbreviation of class type\\ntypedef enum {AND, OR, XOR, SUM, MAX, MIN, MAJ} merge_method;\\ntypedef queue<int> qi;\\ntypedef queue<pair<int,int>> qpii;\\ntypedef deque<int> dqi;\\ntypedef deque<pair<int,int>> dqpii;\\n//typedef long long ll;\\ntypedef pair<int, int> pii;\\ntypedef tuple<int,int> t2i;\\ntypedef tuple<int,int,int> t3i;\\ntypedef pair<ll, ll> pll;\\ntypedef vector<int> vi;\\ntypedef vector<ll> vl;\\ntypedef vector<t2i> vt2i;\\ntypedef vector<string> vs;\\ntypedef vector<vs> vss;\\ntypedef vector<bool> vb;\\ntypedef vector<pair<int,int>> vpii;\\ntypedef vector<vector<int>> vii;\\ntypedef vector<vector<long long>> vll;\\ntypedef vector<vector<bool>> vbb;\\ntypedef unordered_map<int,string> ump_is;\\ntypedef unordered_map<string, int> ump_si;\\ntypedef unordered_map<int,int> ump_ii;\\ntypedef unordered_map<string,string> ump_ss;\\ntypedef map<string,string> mp_ss;\\ntypedef map<int,int> mp_ii;\\ntypedef map<int,string> mp_is;\\ntypedef unordered_set<int> ust_i;\\ntypedef unordered_set<string> ust_s;\\ntypedef tuple<ll,ll,ll> t3l;\\ntypedef tuple<ll,ll> t2l;   \\ntypedef tuple<ll,ll,ll,ll> t4l;\\ntypedef set<pair<int,int>> st_pii;\\ntypedef set<t3l> st_t3l;  \\ntypedef set<int> st_i;\\ntypedef set<string> st_s;\\ntypedef tuple<string, int, int> my_tu; // for multi objective sorting \\nvii nb={{-1,0},{1,0},{0,-1},{0,1}}; \\nvii nb8={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};\\nint M, N, ANS; \\nstruct cmp{ bool operator()(const vi& a, const vi& b)const {return (a[0]== b[0])? a[1]>b[1]: a[0]<b[0];}} cmp_obj;\\nint inv(ll x){ll t= MOD-2;  ll ans=1; while(t>0){ if(t%2) ans= ((ans)*x)%MOD;   x=(x*x)%MOD; t= t>>1;} return (int)ans;}\\nll pow_mod(ll x, ll y){ll ans=1; while(y>0){if(y%2) ans=(ans*x)%MOD;  x=(x*x)%MOD; y=y>>1;} return ans; }\\nbool eq_db(double x, double y){ return abs(x-y)<0.0001;}\\ntemplate<typename T > inline void amin(T &x, T y) { if (y<x) x=y;}\\n /// debeg   \\ntemplate<typename T, typename... Args > inline void amin(T &x, T y,Args... args) { if (y<x) x=y; amin(x, args...); }\\ntemplate<typename T > inline void amax(T &x, T y) { if (y>x) x=y;}\\ntemplate<typename T, typename... Args > inline void amax(T &x, T y,Args... args) { if (y>x) x=y; amax(x, args...); }\\ntemplate<class T>  inline ll md(T x, T y) { ll tmp=x%y; return (tmp<0)? tmp+y:tmp;}\\n//output for debugging\\n\\ntemplate<typename T1, typename T2 >\\nostream& operator<<(ostream& os, pair<T1,T2> p) {os<<p.first<<\" \"<<p.second<<\" \"; return os;}\\ntemplate<typename T1, typename T2 >\\nostream& operator<<(ostream& os, unordered_map<T1,T2> mp) { for(auto& x:mp) os<<x.first<<\" \"<<x.second<<endl; return os;}\\ntemplate<typename T1, typename T2 >\\nostream& operator<<(ostream& os, map<T1,T2> mp) { for(auto& x:mp) os<<x.first<<\" \"<<x.second<<endl; return os;}\\ntemplate<typename T1 >\\nostream& operator<<(ostream& os, vector<T1> v) { for(auto&x:v) os<<x<<\" \"; return os;}\\ntemplate<typename T1 >\\nostream& operator<<(ostream& os, set<T1> v) { for(auto&x:v) os<<x<<\" \"; return os;}\\ntemplate<typename T1 >\\nostream& operator<<(ostream& os, unordered_set<T1> v) { for(auto&x:v) os<<x<<\" \"; return os;}\\ntemplate<typename T1 >\\nostream& operator<<(ostream& os, vector<vector<T1>> v) { for(auto& x:v) {for(auto& y:x) {os<<y<<\" \";} os<<endl;} return os;}\\n}\\nusing namespace myleetcode;\\n\\nclass BookMyShow {\\npublic:\\n \\n    mp_ii row;\\n    int  m,n;\\n      struct SEGT {\\n          vl tree; vi cnt; int len; merge_method meth; vi ori; SEGT(){;}\\n\\tSEGT(int n, merge_method m, int ini){ tree=vl(4*(n+1), ini); ori=vi(n,ini); meth=m; len=n;}\\n\\tSEGT(merge_method m, vi& v){ int n=v.size(); tree=vl(4*(n+1), 0);  meth=m; len=n; ori=vi(v); \\n                                 if(meth==MAJ) {cnt=vi(4*(n+1), 1);}\\n\\t  construct(0, n-1,0);\\n\\t}\\n        void construct(int left, int right, int indx){\\n\\t\\tif(left==right) { tree[indx]=ori[left]; if(meth==MAJ) cnt[left]=1;}\\n\\t\\telse{ int mid=(right-left)/2+left;  construct(left, mid, indx*2+1); construct(mid+1, right,indx*2+2); \\n\\t\\t\\tif(meth!=MAJ) tree[indx]=merge(tree[indx*2+1], tree[indx*2+2]); \\n\\t\\t\\telse{ cnt[indx]= (tree[indx*2+1]!=tree[indx*2+2])? abs(cnt[indx*2+1]- cnt[indx*2+2]): cnt[indx*2+1]+cnt[indx*2+2];\\n\\t\\t\\t\\ttree[indx]=merge(tree[indx*2+1], tree[indx*2+2], cnt[indx*2+1], cnt[indx*2+2] ); \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvoid update(int target, ll val){ ori[target]=(int)val; update(target, 0, len-1, 0);}\\n    ll   query(int front, int end){ if(meth!=MAJ) return query(front, end, 0,len-1,0); \\n                                     else         return query_maj(front, end,0,len-1,0).fi;}\\n    ll merge(ll a, ll b, int a_more=0, int b_more=0 ){\\n        if(meth==XOR) { if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a^b; }\\n        else if(meth==OR) { if(a==INT_MIN) return b; else if(b==INT_MIN) return a;  else return a|b;}\\n        else if(meth==AND) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a&b;}\\n        else if(meth==SUM) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a+b;}\\n        else if(meth==MAX) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return max(a,b);}\\n        else if(meth==MIN)  {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return min(a,b); }\\n       else if(meth==MAJ)  {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else { return (a_more>=b_more)? a:b; } }\\n        return 0;\\n    }\\n    void update(int target, int left, int right, int indx){\\n            if(target<left||target>right) return ;\\n            if(left==right) {if(left==target) tree[indx]=ori[target]; return;}\\n             int mid= (right-left)/2+left; \\n             if(target<=mid) update(target,left,mid,indx*2+1); \\n             else            update(target,mid+1,right,indx*2+2);\\n             if(meth!=MAJ) tree[indx]= merge(tree[indx*2+1], tree[indx*2+2]);\\n            else { cnt[indx]= (tree[indx*2+1]!=tree[indx*2+2])?abs(cnt[indx*2+1]- cnt[indx*2+2]): cnt[indx*2+1]+cnt[indx*2+2];\\n                     tree[indx]= merge(tree[indx*2+1], tree[indx*2+2], cnt[indx*2+1], cnt[indx*2+2]);\\n\\t\\t}     \\n      }\\n   pii query_maj(int front, int end, int left, int right, int indx){\\n\\tif(end<left|| front>right) return {INT_MIN,0};\\n        if(left==right){ if(left>=front&& end>=left) return {ori[left],1}; else return {INT_MIN,0};}\\n        else if( front<=left&& right<=end) return {(int)tree[indx], (int)cnt[indx]};\\n        else{  int mid= (right-left)/2+left; \\n             pii f1=   query_maj(front, end,left,mid,indx*2+1);  pii f2= query_maj(front,end,mid+1,right,indx*2+2);\\n\\t    if(f1.fi==f2.fi) return {f1.fi, f1.se+f2.se};\\n            else{ return {  (f1.se>f2.se)? f1.fi: f2.fi, abs(f1.se-f2.se)}; }\\n        }\\n    }\\n    ll query(int front, int end, int left,int right,int indx){\\n        if(end<left|| front>right) return INT_MIN;\\n        if(left==right){ if(left>=front&& end>=left) return tree[indx]; else return INT_MIN;}\\n        else if( front<=left&& right<=end) return tree[indx];\\n        else{  int mid= (right-left)/2+left; \\n               ll f1=   query(front, end,left,mid,indx*2+1);  ll f2= query(front,end,mid+1,right,indx*2+2);\\n             return merge(f1,f2);\\n        }\\n    }\\n }; // binary index tree \\n    SEGT maxSeg, sumSeg;\\n    bool isLE(int r, int target){  return maxSeg.query(0, r)>=target;}\\n    BookMyShow(int nn, int mm) { m=mm; n=nn; vi tmp(n,m);\\n                                maxSeg=SEGT(MAX, tmp); sumSeg=SEGT(SUM, tmp);\\n                                for(int i=0;i<n;i++) { row[i]=m; }\\n                               }\\n    \\n    // (false , false,true)\\n    vector<int> gather(int k, int maxRow) {\\n        int left=0; int right= maxRow;\\n        int target=left;\\n        while(right>=left){ int mid=(right-left)/2+left;\\n            if(right==left){ if(isLE(left,k)){target=left;break;} else {return {}; }}\\n            else if(right-left==1){ if(isLE(left,k)){target=left;break;} \\n                                    if(isLE(right,k)){target=right;break;}\\n                               if(right==maxRow){ return {}; } else {target=right+1; break;}\\n                             }\\n            else{ if(isLE(mid,k)) right=mid;  else left=mid;}\\n        }\\n        row[target]-=k; int tmp=row[target]; \\n        maxSeg.update(target, tmp); sumSeg.update(target,tmp);\\n        vi ans={target,m-tmp-k};\\n        if(tmp==0) row.era(target);\\n        \\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) { int tmp=0; vi cand;\\n        if((ll)k>sumSeg.query(0,maxRow)) return false;\\n        for(auto&x:row){\\n            if(x.fi>maxRow) break;\\n            tmp+=x.se; cand.pb(x.fi); sumSeg.update(x.fi,0); maxSeg.update(x.fi,0); if(tmp>=k) break;\\n        }\\n        for(int i=0;i<sz(cand)-1;i++) {row.era(cand[i]); }\\n        row[cand.back()]=tmp-k;     \\n        if(row[cand.back()]==0) row.era(cand.back());\\n        else { sumSeg.update(cand.back(),tmp-k); maxSeg.update(cand.back(), tmp-k); }\\n        //cout<<row<<endl;\\n        return true;                             \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2086933,
                "title": "a-segmentated-tree-for-all-operations-max-min-add-and-or-xor-majority",
                "content": "usage:  v is the vector<int> vector\\n// construct\\nusing SUM, MAX, MIN, AND,OR, XOR, MAJ for type specification\\nSEGT sumSeg( SUM, v);  // for sum segement tree;\\nSEGT maxSeg( MAX, v);  // for max segement tree;\\nSEGT majSeg( MAJ, v);  // for majaority segement tree;\\n\\n// update\\nsumSeg.update( target, value) // update v[target] to value and update the sumSeg tree\\n// query\\nsumSeg.query( int start, int end) // get the sum of v[start] to v[end]\\n\\n```\\n#define fi first;\\n#define se second;\\ntypedef long long ll;\\ntypedef vector<int> vi;\\ntypedef vector<ll>   vl;\\ntypedef enum {AND, OR, XOR, SUM, MAX, MIN, MAJ} merge_method;\\nstruct SEGT {\\n     vl tree; vi cnt; int len; merge_method meth; vi ori; SEGT(){;}\\n\\t//SEGT(int n, merge_method m, int ini){ tree=vl(4*(n+1), ini); ori=vi(n,ini); meth=m; len=n;}\\n\\tSEGT(merge_method m, vi& v){ int n=v.size(); tree=vl(4*(n+1), 0);  meth=m; len=n; ori=vi(v); \\n                                 if(meth==MAJ) {cnt=vi(4*(n+1), 1);}\\n\\t  construct(0, n-1,0);\\n\\t}\\n        void construct(int left, int right, int indx){\\n\\t\\tif(left==right) { tree[indx]=ori[left]; if(meth==MAJ) cnt[left]=1;}\\n\\t\\telse{ int mid=(right-left)/2+left;  construct(left, mid, indx*2+1); construct(mid+1, right,indx*2+2); \\n\\t\\t\\tif(meth!=MAJ) tree[indx]=merge(tree[indx*2+1], tree[indx*2+2]); \\n\\t\\t\\telse{ cnt[indx]= (tree[indx*2+1]!=tree[indx*2+2])? abs(cnt[indx*2+1]- cnt[indx*2+2]): cnt[indx*2+1]+cnt[indx*2+2];\\n\\t\\t\\t\\ttree[indx]=merge(tree[indx*2+1], tree[indx*2+2], cnt[indx*2+1], cnt[indx*2+2] ); \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvoid update(int target, ll val){ ori[target]=(int)val; update(target, 0, len-1, 0);}\\n    ll   query(int front, int end){ if(meth!=MAJ) return query(front, end, 0,len-1,0); \\n                                     else         return query_maj(front, end,0,len-1,0).fi;}\\n    ll merge(ll a, ll b, int a_more=0, int b_more=0 ){\\n        if(meth==XOR) { if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a^b; }\\n        else if(meth==OR) { if(a==INT_MIN) return b; else if(b==INT_MIN) return a;  else return a|b;}\\n        else if(meth==AND) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a&b;}\\n        else if(meth==SUM) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a+b;}\\n        else if(meth==MAX) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return max(a,b);}\\n        else if(meth==MIN)  {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return min(a,b); }\\n       else if(meth==MAJ)  {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else { return (a_more>=b_more)? a:b; } }\\n        return 0;\\n    }\\n    void update(int target, int left, int right, int indx){\\n            if(target<left||target>right) return ;\\n            if(left==right) {if(left==target) tree[indx]=ori[target]; return;}\\n             int mid= (right-left)/2+left; \\n             if(target<=mid) update(target,left,mid,indx*2+1); \\n             else            update(target,mid+1,right,indx*2+2);\\n             if(meth!=MAJ) tree[indx]= merge(tree[indx*2+1], tree[indx*2+2]);\\n            else { cnt[indx]= (tree[indx*2+1]!=tree[indx*2+2])?abs(cnt[indx*2+1]- cnt[indx*2+2]): cnt[indx*2+1]+cnt[indx*2+2];\\n                     tree[indx]= merge(tree[indx*2+1], tree[indx*2+2], cnt[indx*2+1], cnt[indx*2+2]);\\n\\t\\t}     \\n      }\\n   pii query_maj(int front, int end, int left, int right, int indx){\\n\\tif(end<left|| front>right) return {INT_MIN,0};\\n        if(left==right){ if(left>=front&& end>=left) return {ori[left],1}; else return {INT_MIN,0};}\\n        else if( front<=left&& right<=end) return {(int)tree[indx], (int)cnt[indx]};\\n        else{  int mid= (right-left)/2+left; \\n             pii f1=   query_maj(front, end,left,mid,indx*2+1);  pii f2= query_maj(front,end,mid+1,right,indx*2+2);\\n\\t    if(f1.fi==f2.fi) return {f1.fi, f1.se+f2.se};\\n            else{ return {  (f1.se>f2.se)? f1.fi: f2.fi, abs(f1.se-f2.se)}; }\\n        }\\n    }\\n    ll query(int front, int end, int left,int right,int indx){\\n        if(end<left|| front>right) return INT_MIN;\\n        if(left==right){ if(left>=front&& end>=left) return tree[indx]; else return INT_MIN;}\\n        else if( front<=left&& right<=end) return tree[indx];\\n        else{  int mid= (right-left)/2+left; \\n               ll f1=   query(front, end,left,mid,indx*2+1);  ll f2= query(front,end,mid+1,right,indx*2+2);\\n             return merge(f1,f2);\\n        }\\n    }\\n }; \\n```\\n",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n#define fi first;\\n#define se second;\\ntypedef long long ll;\\ntypedef vector<int> vi;\\ntypedef vector<ll>   vl;\\ntypedef enum {AND, OR, XOR, SUM, MAX, MIN, MAJ} merge_method;\\nstruct SEGT {\\n     vl tree; vi cnt; int len; merge_method meth; vi ori; SEGT(){;}\\n\\t//SEGT(int n, merge_method m, int ini){ tree=vl(4*(n+1), ini); ori=vi(n,ini); meth=m; len=n;}\\n\\tSEGT(merge_method m, vi& v){ int n=v.size(); tree=vl(4*(n+1), 0);  meth=m; len=n; ori=vi(v); \\n                                 if(meth==MAJ) {cnt=vi(4*(n+1), 1);}\\n\\t  construct(0, n-1,0);\\n\\t}\\n        void construct(int left, int right, int indx){\\n\\t\\tif(left==right) { tree[indx]=ori[left]; if(meth==MAJ) cnt[left]=1;}\\n\\t\\telse{ int mid=(right-left)/2+left;  construct(left, mid, indx*2+1); construct(mid+1, right,indx*2+2); \\n\\t\\t\\tif(meth!=MAJ) tree[indx]=merge(tree[indx*2+1], tree[indx*2+2]); \\n\\t\\t\\telse{ cnt[indx]= (tree[indx*2+1]!=tree[indx*2+2])? abs(cnt[indx*2+1]- cnt[indx*2+2]): cnt[indx*2+1]+cnt[indx*2+2];\\n\\t\\t\\t\\ttree[indx]=merge(tree[indx*2+1], tree[indx*2+2], cnt[indx*2+1], cnt[indx*2+2] ); \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvoid update(int target, ll val){ ori[target]=(int)val; update(target, 0, len-1, 0);}\\n    ll   query(int front, int end){ if(meth!=MAJ) return query(front, end, 0,len-1,0); \\n                                     else         return query_maj(front, end,0,len-1,0).fi;}\\n    ll merge(ll a, ll b, int a_more=0, int b_more=0 ){\\n        if(meth==XOR) { if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a^b; }\\n        else if(meth==OR) { if(a==INT_MIN) return b; else if(b==INT_MIN) return a;  else return a|b;}\\n        else if(meth==AND) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a&b;}\\n        else if(meth==SUM) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return a+b;}\\n        else if(meth==MAX) {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return max(a,b);}\\n        else if(meth==MIN)  {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else return min(a,b); }\\n       else if(meth==MAJ)  {  if(a==INT_MIN) return b; else if(b==INT_MIN) return a; else { return (a_more>=b_more)? a:b; } }\\n        return 0;\\n    }\\n    void update(int target, int left, int right, int indx){\\n            if(target<left||target>right) return ;\\n            if(left==right) {if(left==target) tree[indx]=ori[target]; return;}\\n             int mid= (right-left)/2+left; \\n             if(target<=mid) update(target,left,mid,indx*2+1); \\n             else            update(target,mid+1,right,indx*2+2);\\n             if(meth!=MAJ) tree[indx]= merge(tree[indx*2+1], tree[indx*2+2]);\\n            else { cnt[indx]= (tree[indx*2+1]!=tree[indx*2+2])?abs(cnt[indx*2+1]- cnt[indx*2+2]): cnt[indx*2+1]+cnt[indx*2+2];\\n                     tree[indx]= merge(tree[indx*2+1], tree[indx*2+2], cnt[indx*2+1], cnt[indx*2+2]);\\n\\t\\t}     \\n      }\\n   pii query_maj(int front, int end, int left, int right, int indx){\\n\\tif(end<left|| front>right) return {INT_MIN,0};\\n        if(left==right){ if(left>=front&& end>=left) return {ori[left],1}; else return {INT_MIN,0};}\\n        else if( front<=left&& right<=end) return {(int)tree[indx], (int)cnt[indx]};\\n        else{  int mid= (right-left)/2+left; \\n             pii f1=   query_maj(front, end,left,mid,indx*2+1);  pii f2= query_maj(front,end,mid+1,right,indx*2+2);\\n\\t    if(f1.fi==f2.fi) return {f1.fi, f1.se+f2.se};\\n            else{ return {  (f1.se>f2.se)? f1.fi: f2.fi, abs(f1.se-f2.se)}; }\\n        }\\n    }\\n    ll query(int front, int end, int left,int right,int indx){\\n        if(end<left|| front>right) return INT_MIN;\\n        if(left==right){ if(left>=front&& end>=left) return tree[indx]; else return INT_MIN;}\\n        else if( front<=left&& right<=end) return tree[indx];\\n        else{  int mid= (right-left)/2+left; \\n               ll f1=   query(front, end,left,mid,indx*2+1);  ll f2= query(front,end,mid+1,right,indx*2+2);\\n             return merge(f1,f2);\\n        }\\n    }\\n }; \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2086901,
                "title": "currently-fastest-solution",
                "content": "![image](https://assets.leetcode.com/users/images/3a0bf2a3-f4e7-4ddb-a7a9-9c24a9f411e2_1653813231.3706937.png)\\n\\n```\\nclass BookMyShow {\\n    struct SegmentInfo {\\n        int row_free_place;\\n        int64_t whole_free_place;\\n    };\\n\\n    int n_;\\n    int m_;\\n    std::vector<SegmentInfo> segmentation_index_;\\n\\n    int size_;\\n    int first_row_index_;\\n\\n    int allocate(int row, int places)\\n    {\\n        int segment_index = row + first_row_index_;\\n        auto& row_segment = segmentation_index_[segment_index];\\n        const int prev_places = row_segment.row_free_place;\\n\\n        row_segment.row_free_place -= places;\\n        row_segment.whole_free_place -= places;\\n        assert(row_segment.row_free_place >= 0);\\n\\n        while (segment_index > 0)\\n        {\\n            segment_index = (segment_index - 1) / 2;\\n            auto& segment = segmentation_index_[segment_index];\\n            segment.whole_free_place -= places;\\n            segment.row_free_place = std::max(segmentation_index_[segment_index * 2 + 1].row_free_place, segmentation_index_[segment_index * 2 + 2].row_free_place);\\n        }\\n\\n        return m_ - prev_places;\\n    }\\n\\n    void build(int beg, int binary_end, int end, int segment)\\n    {\\n        auto& info = segmentation_index_[segment];\\n        info.row_free_place = m_;\\n\\n        if (beg == binary_end)\\n        { \\n            info.whole_free_place = m_;\\n        }\\n        else\\n        {\\n            info.whole_free_place = int64_t(end - beg + 1)* m_;\\n            int middle = beg + (binary_end - beg + 1) / 2;\\n\\n            if (end >= middle)\\n            {\\n                build(beg, middle - 1, middle - 1, segment * 2 + 1);\\n                build(middle, binary_end, end, segment * 2 + 2);\\n            }\\n            else\\n            {\\n                build(beg, middle - 1, end, segment * 2 + 1);\\n            }\\n        }\\n    }\\n\\n    int64_t get_common_free(int beg, int binary_end, int end, int seg) const\\n    {\\n        if (binary_end == end)\\n        {\\n            return segmentation_index_[seg].whole_free_place;\\n        }\\n\\n        const int middle = beg + (binary_end - beg + 1) / 2;\\n\\n        if (end < middle)\\n        {\\n            return get_common_free(beg, middle - 1, end, seg * 2 + 1);\\n        }\\n\\n        return segmentation_index_[seg * 2 + 1].whole_free_place + get_common_free(middle, binary_end, end, seg * 2 + 2);\\n    }\\n\\n    int get_row_free(int beg, int binary_end, int end, int seg, int places)\\n    {\\n        const auto& info = segmentation_index_[seg];\\n        \\n        if (info.row_free_place < places)\\n        {\\n            return -1;\\n        }\\n\\n        if (beg == binary_end)\\n        {\\n            return info.row_free_place >= places ? beg : -1;\\n        }\\n\\n        const int middle = beg + (binary_end - beg + 1) / 2;\\n        const int first_bottom = get_row_free(beg, middle - 1, end, seg * 2 + 1, places);\\n\\n        if (first_bottom != -1 || end < middle)\\n        {\\n            return first_bottom;\\n        }\\n        \\n        return get_row_free(middle, binary_end, end, seg * 2 + 2, places);\\n    }\\n\\npublic:\\n    BookMyShow(int n, int m) : n_(n), m_(m) {\\n        size_ = 1;\\n\\n        while (size_ < n)\\n            size_ *= 2;\\n\\n        segmentation_index_.resize(size_ * 2 - 1);\\n        memset(segmentation_index_.data(), 0, segmentation_index_.size() * sizeof(SegmentInfo));\\n        first_row_index_ = size_ - 1;\\n\\n        build(0, size_ - 1, n - 1, 0);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        const int first_free = get_row_free(0, size_ - 1, maxRow, 0, k);\\n        if (first_free != -1)\\n        {\\n            return std::vector<int>{first_free, allocate(first_free, k)};\\n        }\\n        \\n        return std::vector<int>{};\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        if (get_common_free(0, size_ - 1, maxRow, 0) >= k)\\n        {\\n            int free_row = get_row_free(0, size_ - 1, maxRow, 0, 1);\\n            assert(free_row != -1);\\n\\n            while (k > 0)\\n            {\\n                int free_places = std::min(segmentation_index_[free_row + first_row_index_].row_free_place, k);\\n                allocate(free_row, free_places);\\n                k -= free_places;\\n                ++free_row;\\n            }\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass BookMyShow {\\n    struct SegmentInfo {\\n        int row_free_place;\\n        int64_t whole_free_place;\\n    };\\n\\n    int n_;\\n    int m_;\\n    std::vector<SegmentInfo> segmentation_index_;\\n\\n    int size_;\\n    int first_row_index_;\\n\\n    int allocate(int row, int places)\\n    {\\n        int segment_index = row + first_row_index_;\\n        auto& row_segment = segmentation_index_[segment_index];\\n        const int prev_places = row_segment.row_free_place;\\n\\n        row_segment.row_free_place -= places;\\n        row_segment.whole_free_place -= places;\\n        assert(row_segment.row_free_place >= 0);\\n\\n        while (segment_index > 0)\\n        {\\n            segment_index = (segment_index - 1) / 2;\\n            auto& segment = segmentation_index_[segment_index];\\n            segment.whole_free_place -= places;\\n            segment.row_free_place = std::max(segmentation_index_[segment_index * 2 + 1].row_free_place, segmentation_index_[segment_index * 2 + 2].row_free_place);\\n        }\\n\\n        return m_ - prev_places;\\n    }\\n\\n    void build(int beg, int binary_end, int end, int segment)\\n    {\\n        auto& info = segmentation_index_[segment];\\n        info.row_free_place = m_;\\n\\n        if (beg == binary_end)\\n        { \\n            info.whole_free_place = m_;\\n        }\\n        else\\n        {\\n            info.whole_free_place = int64_t(end - beg + 1)* m_;\\n            int middle = beg + (binary_end - beg + 1) / 2;\\n\\n            if (end >= middle)\\n            {\\n                build(beg, middle - 1, middle - 1, segment * 2 + 1);\\n                build(middle, binary_end, end, segment * 2 + 2);\\n            }\\n            else\\n            {\\n                build(beg, middle - 1, end, segment * 2 + 1);\\n            }\\n        }\\n    }\\n\\n    int64_t get_common_free(int beg, int binary_end, int end, int seg) const\\n    {\\n        if (binary_end == end)\\n        {\\n            return segmentation_index_[seg].whole_free_place;\\n        }\\n\\n        const int middle = beg + (binary_end - beg + 1) / 2;\\n\\n        if (end < middle)\\n        {\\n            return get_common_free(beg, middle - 1, end, seg * 2 + 1);\\n        }\\n\\n        return segmentation_index_[seg * 2 + 1].whole_free_place + get_common_free(middle, binary_end, end, seg * 2 + 2);\\n    }\\n\\n    int get_row_free(int beg, int binary_end, int end, int seg, int places)\\n    {\\n        const auto& info = segmentation_index_[seg];\\n        \\n        if (info.row_free_place < places)\\n        {\\n            return -1;\\n        }\\n\\n        if (beg == binary_end)\\n        {\\n            return info.row_free_place >= places ? beg : -1;\\n        }\\n\\n        const int middle = beg + (binary_end - beg + 1) / 2;\\n        const int first_bottom = get_row_free(beg, middle - 1, end, seg * 2 + 1, places);\\n\\n        if (first_bottom != -1 || end < middle)\\n        {\\n            return first_bottom;\\n        }\\n        \\n        return get_row_free(middle, binary_end, end, seg * 2 + 2, places);\\n    }\\n\\npublic:\\n    BookMyShow(int n, int m) : n_(n), m_(m) {\\n        size_ = 1;\\n\\n        while (size_ < n)\\n            size_ *= 2;\\n\\n        segmentation_index_.resize(size_ * 2 - 1);\\n        memset(segmentation_index_.data(), 0, segmentation_index_.size() * sizeof(SegmentInfo));\\n        first_row_index_ = size_ - 1;\\n\\n        build(0, size_ - 1, n - 1, 0);\\n    }\\n\\n    vector<int> gather(int k, int maxRow) {\\n        const int first_free = get_row_free(0, size_ - 1, maxRow, 0, k);\\n        if (first_free != -1)\\n        {\\n            return std::vector<int>{first_free, allocate(first_free, k)};\\n        }\\n        \\n        return std::vector<int>{};\\n    }\\n\\n    bool scatter(int k, int maxRow) {\\n        if (get_common_free(0, size_ - 1, maxRow, 0) >= k)\\n        {\\n            int free_row = get_row_free(0, size_ - 1, maxRow, 0, 1);\\n            assert(free_row != -1);\\n\\n            while (k > 0)\\n            {\\n                int free_places = std::min(segmentation_index_[free_row + first_row_index_].row_free_place, k);\\n                allocate(free_row, free_places);\\n                k -= free_places;\\n                ++free_row;\\n            }\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086711,
                "title": "c-solution-based-on-sqrt-decomp",
                "content": "```\\n\\nclass BookMyShow {\\npublic:\\n    \\nvector<vector<long long>> avail ;\\nvector<long long > mx ;\\nvector<long long > sum ;\\n    \\n    int N , M ;\\n    int root , sz ;\\n    \\n    BookMyShow(int n, int m) {\\n        N = n ;\\n        M = m ;\\n        root = sqrt(N) ;\\n        sz = (N+root-1)/root ;\\n        \\n        int rem = N  ;\\n        avail.resize(sz+5) ;\\n        mx.resize(sz+5) ;\\n        sum.resize(sz+5) ;\\n        \\n        for(int i = 0 ; i<sz; i++ ){\\n            int k = root ;\\n            while(k>0 and rem>0 ){\\n                avail[i].push_back(M) ;\\n                mx[i] = M ;\\n                sum[i] += M ;\\n                k-- ;\\n                rem-- ;\\n            }\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        if(k>M) return {} ;\\n        int  id = 0 ;\\n        \\n        for(int i = 0 ; id<=maxRow ; i++ ){\\n            \\n            if(mx[i]>=k){\\n                \\n                for(int j = 0 ; j<avail[i].size() ;j++ ){\\n                    \\n                    if(avail[i][j]>=k){\\n                        \\n                        if(id>maxRow) return {} ;\\n                        \\n                        int kk = M - avail[i][j] ;\\n                        vector<int> ans = {id , kk } ;\\n                        \\n                        avail[i][j]-=k ;\\n\\n                        // update i ;\\n                        long long  mxs = 0 , sm = 0 ;\\n                        for(int k = 0 ; k<avail[i].size() ; k++ ){\\n                            sm+=avail[i][k];\\n                            mxs = max(mxs , avail[i][k] ) ;\\n                        }\\n                        sum[i] = sm ;\\n                        mx[i] = mxs ;\\n                        \\n                        return ans ;\\n                    }\\n                    id++;\\n                }\\n            }\\n            id+=root ;\\n        }\\n        \\n        return {} ;\\n    }\\n    \\n    bool scatter(int kk, int maxRow) {\\n        long long k = kk ;\\n        long long totsum = 0 ;\\n        long long  id = 0 ; \\n        \\n        for(int i = 0 ; id<=maxRow ; i++ ){\\n            if(id+root-1<=maxRow){\\n                totsum+=sum[i] ;\\n            }\\n            else{\\n                for(int j = 0 ; j<avail[i].size() and id<=maxRow ;j++ ){\\n                    totsum+=avail[i][j] ;\\n                    id++;\\n                }\\n                break ;\\n            }\\n            id+=root ;\\n        }\\n\\n        if(k > totsum ) return false ;\\n\\n        for(int i = 0 ; i<sum.size() ; i++ ){\\n            \\n            if(sum[i]<k ){\\n                k-=sum[i] ;\\n                sum[i] = 0 ;\\n                mx[i] = 0 ;\\n                for(int j=0;j<avail[i].size();j++){\\n                    avail[i][j] =0;\\n                }\\n            }\\n            else{\\n                for(int j = 0 ; j<avail[i].size(); j++ ){\\n                    long long  here = min(k , avail[i][j] ) ;\\n                    avail[i][j]-= here ;\\n                    k -= here ;\\n                }\\n                // update i ;\\n                long long  mxs = 0 , sm = 0 ;\\n                for(int k = 0 ; k<avail[i].size() ; k++ ){\\n                    sm+=avail[i][k];\\n                    mxs = max(mxs , avail[i][k] ) ;\\n                }\\n                sum[i] = sm ;\\n                mx[i] = mxs ;\\n\\n                return true ;\\n\\n            }\\n        }\\n        return false ;\\n\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass BookMyShow {\\npublic:\\n    \\nvector<vector<long long>> avail ;\\nvector<long long > mx ;\\nvector<long long > sum ;\\n    \\n    int N , M ;\\n    int root , sz ;\\n    \\n    BookMyShow(int n, int m) {\\n        N = n ;\\n        M = m ;\\n        root = sqrt(N) ;\\n        sz = (N+root-1)/root ;\\n        \\n        int rem = N  ;\\n        avail.resize(sz+5) ;\\n        mx.resize(sz+5) ;\\n        sum.resize(sz+5) ;\\n        \\n        for(int i = 0 ; i<sz; i++ ){\\n            int k = root ;\\n            while(k>0 and rem>0 ){\\n                avail[i].push_back(M) ;\\n                mx[i] = M ;\\n                sum[i] += M ;\\n                k-- ;\\n                rem-- ;\\n            }\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        if(k>M) return {} ;\\n        int  id = 0 ;\\n        \\n        for(int i = 0 ; id<=maxRow ; i++ ){\\n            \\n            if(mx[i]>=k){\\n                \\n                for(int j = 0 ; j<avail[i].size() ;j++ ){\\n                    \\n                    if(avail[i][j]>=k){\\n                        \\n                        if(id>maxRow) return {} ;\\n                        \\n                        int kk = M - avail[i][j] ;\\n                        vector<int> ans = {id , kk } ;\\n                        \\n                        avail[i][j]-=k ;\\n\\n                        // update i ;\\n                        long long  mxs = 0 , sm = 0 ;\\n                        for(int k = 0 ; k<avail[i].size() ; k++ ){\\n                            sm+=avail[i][k];\\n                            mxs = max(mxs , avail[i][k] ) ;\\n                        }\\n                        sum[i] = sm ;\\n                        mx[i] = mxs ;\\n                        \\n                        return ans ;\\n                    }\\n                    id++;\\n                }\\n            }\\n            id+=root ;\\n        }\\n        \\n        return {} ;\\n    }\\n    \\n    bool scatter(int kk, int maxRow) {\\n        long long k = kk ;\\n        long long totsum = 0 ;\\n        long long  id = 0 ; \\n        \\n        for(int i = 0 ; id<=maxRow ; i++ ){\\n            if(id+root-1<=maxRow){\\n                totsum+=sum[i] ;\\n            }\\n            else{\\n                for(int j = 0 ; j<avail[i].size() and id<=maxRow ;j++ ){\\n                    totsum+=avail[i][j] ;\\n                    id++;\\n                }\\n                break ;\\n            }\\n            id+=root ;\\n        }\\n\\n        if(k > totsum ) return false ;\\n\\n        for(int i = 0 ; i<sum.size() ; i++ ){\\n            \\n            if(sum[i]<k ){\\n                k-=sum[i] ;\\n                sum[i] = 0 ;\\n                mx[i] = 0 ;\\n                for(int j=0;j<avail[i].size();j++){\\n                    avail[i][j] =0;\\n                }\\n            }\\n            else{\\n                for(int j = 0 ; j<avail[i].size(); j++ ){\\n                    long long  here = min(k , avail[i][j] ) ;\\n                    avail[i][j]-= here ;\\n                    k -= here ;\\n                }\\n                // update i ;\\n                long long  mxs = 0 , sm = 0 ;\\n                for(int k = 0 ; k<avail[i].size() ; k++ ){\\n                    sm+=avail[i][k];\\n                    mxs = max(mxs , avail[i][k] ) ;\\n                }\\n                sum[i] = sm ;\\n                mx[i] = mxs ;\\n\\n                return true ;\\n\\n            }\\n        }\\n        return false ;\\n\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086138,
                "title": "time-out-error",
                "content": "unable to submit my solution",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2085603,
                "title": "rust-bit-but-help-improve-code-readiablity",
                "content": "I wrote BIT in python but TLE, so I rewrote it in Rust and it accepted. But I struggled in type conversion between i64 ans usize, is there some way use either i64 or usize only convert happen in first line of each method?\\n\\n```rust\\nuse std::cmp::min;\\nstruct BookMyShow {\\n    first: Vec<usize>,\\n    bitArr: Vec<usize>,\\n    n: i64,\\n    m: i64,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl BookMyShow {\\n    fn update(&mut self, mut idx: i64, delta: i64) {\\n        idx += 1;\\n        while ((idx as usize) < self.bitArr.len()) {\\n            self.bitArr[idx as usize] += delta as usize;\\n            idx += (idx & -idx);\\n        }\\n    }\\n    fn prefix_sum(&mut self, mut idx: i64) -> i64 {\\n        idx += 1;\\n        let mut ans: i64 = 0;\\n        while (idx > 0) {\\n            ans += self.bitArr[idx as usize] as i64;\\n            idx -= (idx & -idx);\\n        }\\n        ans\\n    }\\n    fn new(n: i32, m: i32) -> Self {\\n        BookMyShow {\\n            first: vec![0; 50001],\\n            bitArr: vec![0; 50001],\\n            n: n as i64,\\n            m: m as i64,\\n        }\\n    }\\n    \\n    fn gather(&mut self, k_: i32, max_row_: i32) -> Vec<i32> {\\n        let k: i64 = k_ as i64;\\n        let max_row: i64 = max_row_ as i64;\\n        if (max_row+1) * self.m - (self.prefix_sum(max_row)) < k {\\n            return vec![];\\n        }\\n        for i in 0..=max_row {\\n            if self.m - self.first[i as usize] as i64 >= k {\\n                self.first[i as usize] += k as usize;\\n                self.update(i as i64, k);\\n                return vec![i as i32, self.first[i as usize] as i32 - k as i32];\\n            }\\n        }\\n        vec![]\\n    }\\n    \\n    fn scatter(&mut self, k_: i32, max_row_: i32) -> bool {\\n        let mut k: i64 = k_ as i64;\\n        let max_row: i64 = max_row_ as i64;\\n        if (max_row+1) * self.m - self.prefix_sum(max_row) < k {\\n            return false;\\n        }\\n        for i in 0..=max_row {\\n            let rest = min(k, self.m - self.first[i as usize] as i64);\\n            self.first[i as usize] += rest as usize;\\n            self.update(i as i64, rest);\\n            k -= rest;\\n            if k == 0 {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::min;\\nstruct BookMyShow {\\n    first: Vec<usize>,\\n    bitArr: Vec<usize>,\\n    n: i64,\\n    m: i64,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl BookMyShow {\\n    fn update(&mut self, mut idx: i64, delta: i64) {\\n        idx += 1;\\n        while ((idx as usize) < self.bitArr.len()) {\\n            self.bitArr[idx as usize] += delta as usize;\\n            idx += (idx & -idx);\\n        }\\n    }\\n    fn prefix_sum(&mut self, mut idx: i64) -> i64 {\\n        idx += 1;\\n        let mut ans: i64 = 0;\\n        while (idx > 0) {\\n            ans += self.bitArr[idx as usize] as i64;\\n            idx -= (idx & -idx);\\n        }\\n        ans\\n    }\\n    fn new(n: i32, m: i32) -> Self {\\n        BookMyShow {\\n            first: vec![0; 50001],\\n            bitArr: vec![0; 50001],\\n            n: n as i64,\\n            m: m as i64,\\n        }\\n    }\\n    \\n    fn gather(&mut self, k_: i32, max_row_: i32) -> Vec<i32> {\\n        let k: i64 = k_ as i64;\\n        let max_row: i64 = max_row_ as i64;\\n        if (max_row+1) * self.m - (self.prefix_sum(max_row)) < k {\\n            return vec![];\\n        }\\n        for i in 0..=max_row {\\n            if self.m - self.first[i as usize] as i64 >= k {\\n                self.first[i as usize] += k as usize;\\n                self.update(i as i64, k);\\n                return vec![i as i32, self.first[i as usize] as i32 - k as i32];\\n            }\\n        }\\n        vec![]\\n    }\\n    \\n    fn scatter(&mut self, k_: i32, max_row_: i32) -> bool {\\n        let mut k: i64 = k_ as i64;\\n        let max_row: i64 = max_row_ as i64;\\n        if (max_row+1) * self.m - self.prefix_sum(max_row) < k {\\n            return false;\\n        }\\n        for i in 0..=max_row {\\n            let rest = min(k, self.m - self.first[i as usize] as i64);\\n            self.first[i as usize] += rest as usize;\\n            self.update(i as i64, rest);\\n            k -= rest;\\n            if k == 0 {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085480,
                "title": "c-square-root-decomposition-short-code",
                "content": "```\\n#define N 50176\\n#define M 224\\n#define headIndex(x) (x/M)\\ntypedef long long ll;\\nclass BookMyShow {\\n    int n, m, start = 0;\\n    vector<ll> headMax, headSum;\\n    vector<int> detail;\\n    long long totalAvailable;\\npublic:\\n    BookMyShow(int n, int m): n(n), m(m) {\\n        headMax.resize(M, m);\\n        headSum.resize(M, (ll)m*M);\\n        detail.resize(N, m);\\n        totalAvailable = (ll)n*m;\\n    }\\n    \\n    tuple<int, int, ll> search(int k, int maxRow, vector<ll> &source, function<ll(ll, ll)> combine) {\\n        int i = headIndex(start);\\n        ll initial = 0, temp;\\n        while(i < headIndex(n) && (temp = combine(initial, source[i])) < k) {\\n            initial = temp;\\n            i++;\\n        }\\n        for(int j = M*i, endIndex = min(min(M*(i+1), n), maxRow+1); j < endIndex; j++)\\n            if((initial = combine(initial, detail[j])) >= k)\\n                return {j+1, i, initial};\\n        return {-1, 0, 0};\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        auto [j, i, ignore] = search(k, maxRow, headMax, [](auto a, auto b) { return max(a, b); });\\n        if(j == -1) return {};\\n        detail[j-1] -= k;\\n        headSum[i] -= k;\\n        totalAvailable -= k;\\n        int startIndex = M*i, endIndex = min(M*(i+1), n);\\n        headMax[i] = *max_element(detail.begin()+startIndex, detail.begin()+endIndex);\\n        return {j-1, m-detail[j-1]-k};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if(totalAvailable < k) return false;\\n        auto [found, i, available] = search(k, maxRow, headSum, [](auto a, auto b) { return a+b; });\\n        if(found == -1) return false;\\n        for(int j = headIndex(start); j <= i; j++) headMax[j] = headSum[j] = 0;\\n        fill(detail.begin()+start, detail.begin()+found, 0);\\n        detail[found-1] = available-k;\\n        int startIndex = M*i, endIndex = min(M*(i+1), n);\\n        headMax[i] = *max_element(detail.begin()+startIndex, detail.begin()+endIndex);\\n        headSum[i] = accumulate(detail.begin()+startIndex, detail.begin()+endIndex, 0ll);\\n        start = found - (detail[found-1] != 0);\\n        totalAvailable -= k;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define N 50176\\n#define M 224\\n#define headIndex(x) (x/M)\\ntypedef long long ll;\\nclass BookMyShow {\\n    int n, m, start = 0;\\n    vector<ll> headMax, headSum;\\n    vector<int> detail;\\n    long long totalAvailable;\\npublic:\\n    BookMyShow(int n, int m): n(n), m(m) {\\n        headMax.resize(M, m);\\n        headSum.resize(M, (ll)m*M);\\n        detail.resize(N, m);\\n        totalAvailable = (ll)n*m;\\n    }\\n    \\n    tuple<int, int, ll> search(int k, int maxRow, vector<ll> &source, function<ll(ll, ll)> combine) {\\n        int i = headIndex(start);\\n        ll initial = 0, temp;\\n        while(i < headIndex(n) && (temp = combine(initial, source[i])) < k) {\\n            initial = temp;\\n            i++;\\n        }\\n        for(int j = M*i, endIndex = min(min(M*(i+1), n), maxRow+1); j < endIndex; j++)\\n            if((initial = combine(initial, detail[j])) >= k)\\n                return {j+1, i, initial};\\n        return {-1, 0, 0};\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        auto [j, i, ignore] = search(k, maxRow, headMax, [](auto a, auto b) { return max(a, b); });\\n        if(j == -1) return {};\\n        detail[j-1] -= k;\\n        headSum[i] -= k;\\n        totalAvailable -= k;\\n        int startIndex = M*i, endIndex = min(M*(i+1), n);\\n        headMax[i] = *max_element(detail.begin()+startIndex, detail.begin()+endIndex);\\n        return {j-1, m-detail[j-1]-k};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        if(totalAvailable < k) return false;\\n        auto [found, i, available] = search(k, maxRow, headSum, [](auto a, auto b) { return a+b; });\\n        if(found == -1) return false;\\n        for(int j = headIndex(start); j <= i; j++) headMax[j] = headSum[j] = 0;\\n        fill(detail.begin()+start, detail.begin()+found, 0);\\n        detail[found-1] = available-k;\\n        int startIndex = M*i, endIndex = min(M*(i+1), n);\\n        headMax[i] = *max_element(detail.begin()+startIndex, detail.begin()+endIndex);\\n        headSum[i] = accumulate(detail.begin()+startIndex, detail.begin()+endIndex, 0ll);\\n        start = found - (detail[found-1] != 0);\\n        totalAvailable -= k;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085399,
                "title": "python-3-segment-tree-binary-search-graphically-explained",
                "content": "Mine TLE during contest, following is revised based upon [https://leetcode.com/problems/booking-concert-tickets-in-groups/discuss/2084835/Python-3-Sum-and-Max-segment-trees-%2B-Binary-Search](https://leetcode.com/problems/booking-concert-tickets-in-groups/discuss/2084835/Python-3-Sum-and-Max-segment-trees-%2B-Binary-Search)\\n\\n![image](https://assets.leetcode.com/users/images/5b4c4d9a-203b-4c2c-a9de-30e9bd1eae38_1653787861.5326602.png)\\n\\nExample\\n```\\n[\"BookMyShow\",\"gather\",\"scatter\",\"gather\",\"scatter\"]\\n[[8,5],[4,7],[5,7],[4,7],[15,7]]\\n```\\n\\nMaintain two segment trees for segment sum and max, and a tracker of the lowest indexed row with empty seat for segment query starting point.\\n\\nGather, binary search (querying max tree) to find which row x to place the group of k. If the x == start row and row becomes full after placement, skip tree update and start += 1.\\n\\nScatter, binary search (querying sum tree) to find the last row x impacted to situate k people. All rows 0 to x - 1 will be full, so skip their tree updates. For row x, if it becomes full, skip update and move start to x + 1, otherwise, set start = x, and update tree only for row x.\\n\\nFollowing diagram shows rows becoming full, their tree update skipped, and movement of start pointer.\\n\\n![image](https://assets.leetcode.com/users/images/087275ab-d5d2-42c5-8779-83baeeaa4dd9_1653790689.0054588.png)\\n\\n\\n```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m = m\\n        self.n = n\\n        self._sum = [0] * (2 * n)\\n        self._max = [0] * (2 * n)\\n        for i in range(n, 2 * n):\\n            self._sum[i] = m\\n            self._max[i] = m\\n        for i in range(n - 1, -1, -1):\\n            self._sum[i] = self._sum[2 * i] + self._sum[2 * i + 1]\\n            self._max[i] = max(self._max[2 * i], self._max[2 * i + 1])\\n        self.start = 0 # query starting row, i.e. lowest row with empty seats\\n    \\n    def query_sum(self, l, r):\\n        res = 0\\n        l = self.n + l\\n        r = self.n + r\\n        while l <= r:\\n            if l % 2:\\n                res += self._sum[l]\\n                l += 1\\n            l //= 2\\n            if not r % 2:\\n                res += self._sum[r]\\n                r -= 1\\n            r //= 2\\n        return res\\n    \\n    def query_max(self, l, r, tar):\\n        l += self.n\\n        r += self.n\\n        res = -1\\n        while l <= r:\\n            if l % 2:\\n                res = max(res, self._max[l])\\n                l += 1\\n            l //= 2\\n            if not r % 2:\\n                res = max(res, self._max[r])\\n                r -= 1\\n            r //= 2\\n            if res >= tar: # early return once a valid segment found\\n                return True\\n        return False\\n        \\n    def update(self, val, i):\\n        i += self.n\\n        self._sum[i] = val\\n        self._max[i] = val\\n        while i:\\n            l = r = i\\n            if not l % 2:\\n                r += 1\\n            else:\\n                l -= 1\\n            i //= 2\\n            self._sum[i] = self._sum[l] + self._sum[r]\\n            self._max[i] = max(self._max[l], self._max[r])\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if self.start == self.n or maxRow < self.start:\\n            return []\\n        if not self.query_max(self.start, maxRow, k): # do not check [1], may not be updated\\n            return []\\n        \\n        # binary search _max tree to find the row with lowest index\\n        l = self.start\\n        r = maxRow\\n        while l < r:\\n            mid = (l + r) // 2\\n            if self.query_max(self.start, mid, k):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        row = l\\n        row_tr = row + self.n\\n        col = self.m - self._sum[row_tr]\\n        if row == self.start and self._sum[row_tr] == k:\\n            # if row is the current starting row, and becomes full after gather\\n            # increase start by 1, and skip tree update\\n            self.start += 1\\n        else:\\n            # row self.start not full yet, update the trees\\n            self.update(self._sum[row_tr] - k, row)\\n        return [row, col]\\n        \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.start == self.n or maxRow < self.start:\\n            return False\\n        if self.query_sum(self.start, maxRow) < k: # do not check [1], may not be updated\\n            return False\\n        \\n        # binary search _sum tree to find the row with lowest index\\n        l = self.start\\n        r = maxRow\\n        while l < r:\\n            mid = (l + r) // 2\\n            if self.query_sum(self.start, mid) >= k:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        tot = self.query_sum(self.start, l)\\n        if tot == k:\\n            # all rows before 0 to l full, next search starts l + 1\\n            # there is no need to update the trees, since rows 0 to l wont be included in future queries\\n            self.start = l + 1 \\n        else:\\n            # rows 0 to (l - 1) full, next search starts l\\n            # update trees for row l, since it is not full yet\\n            self.start = l\\n            self.update(tot - k, l)\\n        return True\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n[\"BookMyShow\",\"gather\",\"scatter\",\"gather\",\"scatter\"]\\n[[8,5],[4,7],[5,7],[4,7],[15,7]]\\n```\n```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.m = m\\n        self.n = n\\n        self._sum = [0] * (2 * n)\\n        self._max = [0] * (2 * n)\\n        for i in range(n, 2 * n):\\n            self._sum[i] = m\\n            self._max[i] = m\\n        for i in range(n - 1, -1, -1):\\n            self._sum[i] = self._sum[2 * i] + self._sum[2 * i + 1]\\n            self._max[i] = max(self._max[2 * i], self._max[2 * i + 1])\\n        self.start = 0 # query starting row, i.e. lowest row with empty seats\\n    \\n    def query_sum(self, l, r):\\n        res = 0\\n        l = self.n + l\\n        r = self.n + r\\n        while l <= r:\\n            if l % 2:\\n                res += self._sum[l]\\n                l += 1\\n            l //= 2\\n            if not r % 2:\\n                res += self._sum[r]\\n                r -= 1\\n            r //= 2\\n        return res\\n    \\n    def query_max(self, l, r, tar):\\n        l += self.n\\n        r += self.n\\n        res = -1\\n        while l <= r:\\n            if l % 2:\\n                res = max(res, self._max[l])\\n                l += 1\\n            l //= 2\\n            if not r % 2:\\n                res = max(res, self._max[r])\\n                r -= 1\\n            r //= 2\\n            if res >= tar: # early return once a valid segment found\\n                return True\\n        return False\\n        \\n    def update(self, val, i):\\n        i += self.n\\n        self._sum[i] = val\\n        self._max[i] = val\\n        while i:\\n            l = r = i\\n            if not l % 2:\\n                r += 1\\n            else:\\n                l -= 1\\n            i //= 2\\n            self._sum[i] = self._sum[l] + self._sum[r]\\n            self._max[i] = max(self._max[l], self._max[r])\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        if self.start == self.n or maxRow < self.start:\\n            return []\\n        if not self.query_max(self.start, maxRow, k): # do not check [1], may not be updated\\n            return []\\n        \\n        # binary search _max tree to find the row with lowest index\\n        l = self.start\\n        r = maxRow\\n        while l < r:\\n            mid = (l + r) // 2\\n            if self.query_max(self.start, mid, k):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        row = l\\n        row_tr = row + self.n\\n        col = self.m - self._sum[row_tr]\\n        if row == self.start and self._sum[row_tr] == k:\\n            # if row is the current starting row, and becomes full after gather\\n            # increase start by 1, and skip tree update\\n            self.start += 1\\n        else:\\n            # row self.start not full yet, update the trees\\n            self.update(self._sum[row_tr] - k, row)\\n        return [row, col]\\n        \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        if self.start == self.n or maxRow < self.start:\\n            return False\\n        if self.query_sum(self.start, maxRow) < k: # do not check [1], may not be updated\\n            return False\\n        \\n        # binary search _sum tree to find the row with lowest index\\n        l = self.start\\n        r = maxRow\\n        while l < r:\\n            mid = (l + r) // 2\\n            if self.query_sum(self.start, mid) >= k:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        tot = self.query_sum(self.start, l)\\n        if tot == k:\\n            # all rows before 0 to l full, next search starts l + 1\\n            # there is no need to update the trees, since rows 0 to l wont be included in future queries\\n            self.start = l + 1 \\n        else:\\n            # rows 0 to (l - 1) full, next search starts l\\n            # update trees for row l, since it is not full yet\\n            self.start = l\\n            self.update(tot - k, l)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085258,
                "title": "100-segment-tree-c",
                "content": "One thing that diffs this problem from a typical memory allocation problem is that \\nthis problem **does not return any of the seats back** to the system, so this problem avoided **creating holes** in the system.\\n\\nAddtionally, The time constraint on this problem is pretty strict.  We need to apply branch cut logic to speed up.  \\nAlso need to mind the int overflow issue.\\n\\n\\n```\\nclass BookMyShow {\\npublic:\\n    // 0 max 1 sum,\\n    vector<array<long long, 2>> tree;\\n    vector<int> index;\\n    int m;\\n    int n;\\n    inline int lc(int o) { return (o << 1) ; }\\n    inline int rc(int o) { return (o << 1) + 1; }\\n    \\n    void build(int o, int l, int r) {\\n        if (l == r) {\\n            tree[o][1] = m;\\n            tree[o][0] = m;\\n            return;\\n        } \\n        int mid = (l + r) >> 1;\\n        build(lc(o), l, mid);\\n        build(rc(o), mid + 1, r);\\n        update(o, l, r);\\n    }\\n    inline void update(int o, int l, int r) {\\n        int lo = lc(o);\\n        int ro = rc(o);\\n        tree[o][1] = tree[lo][1] + tree[ro][1];\\n        tree[o][0] = max(tree[lo][0], tree[ro][0]);\\n    }\\n    \\n    void querymax(int o, int l, int r, long long& k, int maxr, vector<int>& ans) {\\n        if (l > maxr || k == 0) return;\\n        if (tree[o][0] < k) {\\n            return;\\n        }\\n        if (l == r) {\\n            ans = {l, (int)(index[l])};\\n            k = 0;\\n            return;\\n        } \\n        int mid = (l + r) >> 1;\\n        querymax(lc(o), l, mid, k, maxr, ans);\\n        querymax(rc(o), mid + 1, r, k, maxr, ans);\\n    }\\n    \\n    void updatemax(int o, int l, int r, long long& k, int maxr) {\\n        if (l > maxr || k <= 0) return;\\n        if (tree[o][0] < k) return;\\n        if (l == r) {\\n                index[l] += k;\\n                tree[o][1] -= k;\\n                tree[o][0] -= k;\\n                k = 0;\\n            return;\\n        }\\n        int mid = (l + r) >> 1;\\n        updatemax(lc(o), l, mid, k, maxr);\\n        updatemax(rc(o), mid + 1, r, k, maxr);\\n        update(o, l, r);\\n    }\\n    \\n    void querysum(int o, int l, int r, long long& k, int& maxr) {\\n        if (l > maxr || k == 0) return;\\n        if (r <= maxr) {\\n            long long mn = min(tree[o][1], k);\\n            k -= mn;\\n            return;\\n        }\\n        int mid = (l + r) >> 1;\\n        querysum(lc(o), l, mid, k, maxr);\\n        querysum(rc(o), mid + 1, r, k, maxr);\\n    }\\n    \\n    void updatesum(int o, int l, int r, long long& k, int& maxr) {\\n        if (l > maxr || k <= 0) return;\\n        if (l == r) {\\n            int mn = min((tree[o][1]), k);\\n            k -= mn;\\n            index[l] += mn;\\n            tree[o][1] -= mn;\\n            tree[o][0] -= mn;\\n            return;\\n        }\\n        int mid = (l + r) >> 1;\\n        updatesum(lc(o), l, mid, k, maxr);\\n        updatesum(rc(o), mid + 1, r, k, maxr);\\n        update(o, l, r);\\n    }\\n    static const int base = 1;\\n    BookMyShow(int n1, int m1) {\\n        n = n1;\\n        m = m1;\\n        index = vector<int>(n, 0);\\n        tree.resize(n * 4 + 1);\\n        build(base, 0, n -1);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        long long k1 = k;\\n        vector<int> ans;\\n        querymax(base, 0, n - 1, k1, maxRow, ans);\\n        if (k1 == 0) {\\n            long long k2 = k;\\n            updatemax(base, 0, n - 1, k2, maxRow);\\n        }\\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long k1 = k;\\n        querysum(base, 0, n - 1, k1, maxRow);\\n        if (k1 > 0) return false;\\n        long long k2 = k;\\n        updatesum(base, 0, n - 1, k2, maxRow);\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    // 0 max 1 sum,\\n    vector<array<long long, 2>> tree;\\n    vector<int> index;\\n    int m;\\n    int n;\\n    inline int lc(int o) { return (o << 1) ; }\\n    inline int rc(int o) { return (o << 1) + 1; }\\n    \\n    void build(int o, int l, int r) {\\n        if (l == r) {\\n            tree[o][1] = m;\\n            tree[o][0] = m;\\n            return;\\n        } \\n        int mid = (l + r) >> 1;\\n        build(lc(o), l, mid);\\n        build(rc(o), mid + 1, r);\\n        update(o, l, r);\\n    }\\n    inline void update(int o, int l, int r) {\\n        int lo = lc(o);\\n        int ro = rc(o);\\n        tree[o][1] = tree[lo][1] + tree[ro][1];\\n        tree[o][0] = max(tree[lo][0], tree[ro][0]);\\n    }\\n    \\n    void querymax(int o, int l, int r, long long& k, int maxr, vector<int>& ans) {\\n        if (l > maxr || k == 0) return;\\n        if (tree[o][0] < k) {\\n            return;\\n        }\\n        if (l == r) {\\n            ans = {l, (int)(index[l])};\\n            k = 0;\\n            return;\\n        } \\n        int mid = (l + r) >> 1;\\n        querymax(lc(o), l, mid, k, maxr, ans);\\n        querymax(rc(o), mid + 1, r, k, maxr, ans);\\n    }\\n    \\n    void updatemax(int o, int l, int r, long long& k, int maxr) {\\n        if (l > maxr || k <= 0) return;\\n        if (tree[o][0] < k) return;\\n        if (l == r) {\\n                index[l] += k;\\n                tree[o][1] -= k;\\n                tree[o][0] -= k;\\n                k = 0;\\n            return;\\n        }\\n        int mid = (l + r) >> 1;\\n        updatemax(lc(o), l, mid, k, maxr);\\n        updatemax(rc(o), mid + 1, r, k, maxr);\\n        update(o, l, r);\\n    }\\n    \\n    void querysum(int o, int l, int r, long long& k, int& maxr) {\\n        if (l > maxr || k == 0) return;\\n        if (r <= maxr) {\\n            long long mn = min(tree[o][1], k);\\n            k -= mn;\\n            return;\\n        }\\n        int mid = (l + r) >> 1;\\n        querysum(lc(o), l, mid, k, maxr);\\n        querysum(rc(o), mid + 1, r, k, maxr);\\n    }\\n    \\n    void updatesum(int o, int l, int r, long long& k, int& maxr) {\\n        if (l > maxr || k <= 0) return;\\n        if (l == r) {\\n            int mn = min((tree[o][1]), k);\\n            k -= mn;\\n            index[l] += mn;\\n            tree[o][1] -= mn;\\n            tree[o][0] -= mn;\\n            return;\\n        }\\n        int mid = (l + r) >> 1;\\n        updatesum(lc(o), l, mid, k, maxr);\\n        updatesum(rc(o), mid + 1, r, k, maxr);\\n        update(o, l, r);\\n    }\\n    static const int base = 1;\\n    BookMyShow(int n1, int m1) {\\n        n = n1;\\n        m = m1;\\n        index = vector<int>(n, 0);\\n        tree.resize(n * 4 + 1);\\n        build(base, 0, n -1);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        long long k1 = k;\\n        vector<int> ans;\\n        querymax(base, 0, n - 1, k1, maxRow, ans);\\n        if (k1 == 0) {\\n            long long k2 = k;\\n            updatemax(base, 0, n - 1, k2, maxRow);\\n        }\\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        long long k1 = k;\\n        querysum(base, 0, n - 1, k1, maxRow);\\n        if (k1 > 0) return false;\\n        long long k2 = k;\\n        updatesum(base, 0, n - 1, k2, maxRow);\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085140,
                "title": "javascript-segment-tree-range-min-query-fenwick-query-prefix-sum-560ms",
                "content": "improved from this version: https://leetcode.com/problems/booking-concert-tickets-in-groups/discuss/2084983/javascript-BITfenwick-tree-4665ms\\n```\\n////////////////////////////////////////////////// Template ////////////////////////////////////////////////////////////////////\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) { // [0, i] prefix sum\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nfunction SegmentTreeRMQ(A) {\\n    let n = A.length, h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(Number.MAX_SAFE_INTEGER);\\n    h = 2 ** h;\\n    initializeFromArray();\\n    return { update, minx, indexOf, tree }\\n    function initializeFromArray() {\\n        for (let i = 0; i < n; i++) a[h + i] = A[i];\\n        for (let i = h - 1; i >= 1; i--) propagate(i);\\n    }\\n    function update(pos, v) {\\n        a[h + pos] = v;\\n        for (let i = parent(h + pos); i >= 1; i = parent(i)) propagate(i);\\n    }\\n    function propagate(i) {\\n        a[i] = Math.min(a[left(i)], a[right(i)]);\\n    }\\n    function minx(l, r) {\\n        let min = Number.MAX_SAFE_INTEGER;\\n        if (l >= r) return min;\\n        l += h;\\n        r += h;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) min = Math.min(min, a[l++]);\\n            if (r & 1) min = Math.min(min, a[--r]);\\n        }\\n        return min;\\n    }\\n    function indexOf(l, v) {\\n        if (l >= h) return -1;\\n        let cur = h + l;\\n        while (1) {\\n            if (a[cur] <= v) {\\n                if (cur >= h) return cur - h;\\n                cur = left(cur);\\n            } else {\\n                cur++;\\n                if ((cur & cur - 1) == 0) return -1;\\n                if (cur % 2 == 0) cur = parent(cur);\\n            }\\n        }\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfunction BookMyShow(n, m) {\\n    let a = Array(n).fill(0), st = new SegmentTreeRMQ(a), fen = new Fenwick(n + 3);\\n    for (let i = 0; i < n; i++) fen.update(i, m);\\n    return { gather, scatter }\\n    function gather(k, maxRow) {\\n        let idx = st.indexOf(0, m - k);\\n        if (idx == -1 || idx > maxRow) return [];\\n        let min = st.minx(idx, idx + 1);\\n        st.update(idx, min + k);\\n        fen.update(idx, -k);\\n        return [idx, min];\\n    }\\n    function scatter(k, maxRow) {\\n        let totToMaxRow = fen.query(maxRow);\\n        if (totToMaxRow < k) return false;\\n        while (k > 0) {\\n            let idx = st.indexOf(0, m - 1);\\n            if (idx == -1 || idx > maxRow) break;\\n            let min = st.minx(idx, idx + 1);\\n            let use = Math.min(k, m - min);\\n            k -= use;\\n            st.update(idx, min + use);\\n            fen.update(idx, -use);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n////////////////////////////////////////////////// Template ////////////////////////////////////////////////////////////////////\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) { // [0, i] prefix sum\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nfunction SegmentTreeRMQ(A) {\\n    let n = A.length, h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(Number.MAX_SAFE_INTEGER);\\n    h = 2 ** h;\\n    initializeFromArray();\\n    return { update, minx, indexOf, tree }\\n    function initializeFromArray() {\\n        for (let i = 0; i < n; i++) a[h + i] = A[i];\\n        for (let i = h - 1; i >= 1; i--) propagate(i);\\n    }\\n    function update(pos, v) {\\n        a[h + pos] = v;\\n        for (let i = parent(h + pos); i >= 1; i = parent(i)) propagate(i);\\n    }\\n    function propagate(i) {\\n        a[i] = Math.min(a[left(i)], a[right(i)]);\\n    }\\n    function minx(l, r) {\\n        let min = Number.MAX_SAFE_INTEGER;\\n        if (l >= r) return min;\\n        l += h;\\n        r += h;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) min = Math.min(min, a[l++]);\\n            if (r & 1) min = Math.min(min, a[--r]);\\n        }\\n        return min;\\n    }\\n    function indexOf(l, v) {\\n        if (l >= h) return -1;\\n        let cur = h + l;\\n        while (1) {\\n            if (a[cur] <= v) {\\n                if (cur >= h) return cur - h;\\n                cur = left(cur);\\n            } else {\\n                cur++;\\n                if ((cur & cur - 1) == 0) return -1;\\n                if (cur % 2 == 0) cur = parent(cur);\\n            }\\n        }\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfunction BookMyShow(n, m) {\\n    let a = Array(n).fill(0), st = new SegmentTreeRMQ(a), fen = new Fenwick(n + 3);\\n    for (let i = 0; i < n; i++) fen.update(i, m);\\n    return { gather, scatter }\\n    function gather(k, maxRow) {\\n        let idx = st.indexOf(0, m - k);\\n        if (idx == -1 || idx > maxRow) return [];\\n        let min = st.minx(idx, idx + 1);\\n        st.update(idx, min + k);\\n        fen.update(idx, -k);\\n        return [idx, min];\\n    }\\n    function scatter(k, maxRow) {\\n        let totToMaxRow = fen.query(maxRow);\\n        if (totToMaxRow < k) return false;\\n        while (k > 0) {\\n            let idx = st.indexOf(0, m - 1);\\n            if (idx == -1 || idx > maxRow) break;\\n            let min = st.minx(idx, idx + 1);\\n            let use = Math.min(k, m - min);\\n            k -= use;\\n            st.update(idx, min + use);\\n            fen.update(idx, -use);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085071,
                "title": "simpler-without-any-trees-o-sqrt-n-beats-100",
                "content": "If you are interested, please ask questions and I\\'ll answer them. If requested, will add comments to the code and more explanation of the solution.\\n\\n`seats` is square root decomposed list of number of available seats in each row;\\n`sums[i]` denotes sum of total available seats in bucket `i`-th;\\n`maxs[i]` denotes maximum number of available seats in any row in `i`-th bucket;\\n```\\n#define ll long long\\nclass BookMyShow {\\n    ll n, m;\\n    ll n_left;\\n    ll bucket_size;\\n    vector<vector<ll>> seats;\\n    vector<long long> maxs;\\n    vector<long long> sums;\\n    \\npublic:\\n    \\n    BookMyShow(int _n, int _m) {\\n        n = _n;\\n        m = _m;\\n        bucket_size = sqrt(n) + 1;\\n        n_left = n * m;\\n        seats = vector<vector<ll>>(bucket_size, vector<ll>(bucket_size, m));\\n        maxs = vector<ll>(bucket_size, m);\\n        sums = vector<ll>(bucket_size, m*bucket_size);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        // print(\"gather k=\" + to_string(k) + \" maxRow=\" + to_string(maxRow));\\n        if (n_left < k) {\\n            return {};\\n        }\\n        for (int i = 0; i < bucket_size; i++) {\\n            if (i * bucket_size > maxRow) {\\n                return {};\\n            }\\n            if (maxs[i] < k) {\\n                continue;\\n            }\\n            for (int j = 0; j < bucket_size; j++) {\\n                const int row = i * bucket_size + j;\\n                if (row > maxRow) {\\n                    return {};\\n                }\\n                if (seats[i][j] < k) {\\n                    continue;\\n                }\\n                const int col = m - seats[i][j];\\n                seats[i][j] -= k;\\n                maxs[i] = 0;\\n                sums[i] = 0;\\n                for (const ll& s : seats[i]) {\\n                    maxs[i] = max(maxs[i], s);\\n                    sums[i] += s;\\n                }\\n                n_left -= k;\\n                return {row, col};\\n            }\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        // print(\"scatter k=\" + to_string(k) + \" maxRow=\" + to_string(maxRow));\\n        if (n_left < k) {\\n            return false;\\n        }\\n        ll n_available = 0;\\n        for (int i = 0; i < bucket_size; i++) {\\n            if (i * bucket_size > maxRow) {\\n                goto Outer;\\n            }\\n            if (n_available + sums[i] >= k) {\\n                for (int j = 0; j < bucket_size; j++) {\\n                    const int row = i * bucket_size + j;\\n                    if (row > maxRow) {\\n                        goto Outer;\\n                    }\\n                    n_available += seats[i][j];\\n                }\\n                goto Outer;\\n            } else {\\n                n_available += sums[i];\\n            }\\n        }\\n        Outer:\\n        if (n_available < k) {\\n            return false;\\n        }\\n        n_left -= k;\\n        for (int i = 0; i < bucket_size and k > 0; i++) {\\n            if (sums[i] >= k) {\\n                for (int j = 0; j < bucket_size; j++) {\\n                    const int row = i * bucket_size + j;\\n                    ll able = min(seats[i][j], (ll)k);\\n                    seats[i][j] -= able;\\n                    k -= able;\\n                    if (k == 0) {\\n                        sums[i] = 0;\\n                        maxs[i] = 0;\\n                        for (const ll& s : seats[i]) {\\n                            maxs[i] = max(maxs[i], s);\\n                            sums[i] += (ll)s;\\n                        } \\n                        return true;\\n                    }\\n                }\\n            } else {\\n                k -= sums[i];\\n                sums[i] = 0;\\n                maxs[i] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    void print(string prelude=\"\") {\\n        cout << \"----------------------------------------------------------------------------------\" << endl;\\n        if (not prelude.empty()) {\\n            cout << prelude << endl;\\n        }\\n        cout << \"n=\" << n << \" m=\" << m << \" bucket_size=\" << bucket_size << \" n_left=\" << n_left << endl;\\n        cout << \"maxs=[ \";\\n        for (const ll& m : maxs) {\\n            cout << m << \" \";\\n        }\\n        cout << \"]\" << endl;\\n        cout << \"sums=[ \";\\n        for (const ll& s : sums) {\\n            cout << s << \" \";\\n        }\\n        cout << \"]\" << endl;\\n        cout << \"seats=[\" << endl;\\n        for (const auto& bucket : seats) {\\n            cout << \"\\\\t[ \";\\n            for (const ll& b : bucket) {\\n                cout << b << \" \";\\n            }\\n            cout << \"]\" << endl;\\n        }\\n        cout << endl << \"]\" << endl;\\n        cout << \"----------------------------------------------------------------------------------\" << endl;\\n    }\\n    \\n};\\n#undef ll\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass BookMyShow {\\n    ll n, m;\\n    ll n_left;\\n    ll bucket_size;\\n    vector<vector<ll>> seats;\\n    vector<long long> maxs;\\n    vector<long long> sums;\\n    \\npublic:\\n    \\n    BookMyShow(int _n, int _m) {\\n        n = _n;\\n        m = _m;\\n        bucket_size = sqrt(n) + 1;\\n        n_left = n * m;\\n        seats = vector<vector<ll>>(bucket_size, vector<ll>(bucket_size, m));\\n        maxs = vector<ll>(bucket_size, m);\\n        sums = vector<ll>(bucket_size, m*bucket_size);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        // print(\"gather k=\" + to_string(k) + \" maxRow=\" + to_string(maxRow));\\n        if (n_left < k) {\\n            return {};\\n        }\\n        for (int i = 0; i < bucket_size; i++) {\\n            if (i * bucket_size > maxRow) {\\n                return {};\\n            }\\n            if (maxs[i] < k) {\\n                continue;\\n            }\\n            for (int j = 0; j < bucket_size; j++) {\\n                const int row = i * bucket_size + j;\\n                if (row > maxRow) {\\n                    return {};\\n                }\\n                if (seats[i][j] < k) {\\n                    continue;\\n                }\\n                const int col = m - seats[i][j];\\n                seats[i][j] -= k;\\n                maxs[i] = 0;\\n                sums[i] = 0;\\n                for (const ll& s : seats[i]) {\\n                    maxs[i] = max(maxs[i], s);\\n                    sums[i] += s;\\n                }\\n                n_left -= k;\\n                return {row, col};\\n            }\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        // print(\"scatter k=\" + to_string(k) + \" maxRow=\" + to_string(maxRow));\\n        if (n_left < k) {\\n            return false;\\n        }\\n        ll n_available = 0;\\n        for (int i = 0; i < bucket_size; i++) {\\n            if (i * bucket_size > maxRow) {\\n                goto Outer;\\n            }\\n            if (n_available + sums[i] >= k) {\\n                for (int j = 0; j < bucket_size; j++) {\\n                    const int row = i * bucket_size + j;\\n                    if (row > maxRow) {\\n                        goto Outer;\\n                    }\\n                    n_available += seats[i][j];\\n                }\\n                goto Outer;\\n            } else {\\n                n_available += sums[i];\\n            }\\n        }\\n        Outer:\\n        if (n_available < k) {\\n            return false;\\n        }\\n        n_left -= k;\\n        for (int i = 0; i < bucket_size and k > 0; i++) {\\n            if (sums[i] >= k) {\\n                for (int j = 0; j < bucket_size; j++) {\\n                    const int row = i * bucket_size + j;\\n                    ll able = min(seats[i][j], (ll)k);\\n                    seats[i][j] -= able;\\n                    k -= able;\\n                    if (k == 0) {\\n                        sums[i] = 0;\\n                        maxs[i] = 0;\\n                        for (const ll& s : seats[i]) {\\n                            maxs[i] = max(maxs[i], s);\\n                            sums[i] += (ll)s;\\n                        } \\n                        return true;\\n                    }\\n                }\\n            } else {\\n                k -= sums[i];\\n                sums[i] = 0;\\n                maxs[i] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    void print(string prelude=\"\") {\\n        cout << \"----------------------------------------------------------------------------------\" << endl;\\n        if (not prelude.empty()) {\\n            cout << prelude << endl;\\n        }\\n        cout << \"n=\" << n << \" m=\" << m << \" bucket_size=\" << bucket_size << \" n_left=\" << n_left << endl;\\n        cout << \"maxs=[ \";\\n        for (const ll& m : maxs) {\\n            cout << m << \" \";\\n        }\\n        cout << \"]\" << endl;\\n        cout << \"sums=[ \";\\n        for (const ll& s : sums) {\\n            cout << s << \" \";\\n        }\\n        cout << \"]\" << endl;\\n        cout << \"seats=[\" << endl;\\n        for (const auto& bucket : seats) {\\n            cout << \"\\\\t[ \";\\n            for (const ll& b : bucket) {\\n                cout << b << \" \";\\n            }\\n            cout << \"]\" << endl;\\n        }\\n        cout << endl << \"]\" << endl;\\n        cout << \"----------------------------------------------------------------------------------\" << endl;\\n    }\\n    \\n};\\n#undef ll\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2084983,
                "title": "javascript-bit-fenwick-tree-4665ms",
                "content": "improved from brute force version https://leetcode.com/problems/booking-concert-tickets-in-groups/discuss/2084492/javascript-brute-force-7460ms\\n```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) { // [0, i] prefix sum\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nfunction BookMyShow(n, m) {\\n    let used = Array(n).fill(0), fen = new Fenwick(n + 3);\\n    for (let i = 0; i < n; i++) fen.update(i, m); // original set each node with m seats\\n    return { gather, scatter }\\n    function gather(k, maxRow) {\\n        for (let i = 0; i <= maxRow; i++) {\\n            let seat = m - used[i];\\n            if (seat >= k) {\\n                let first = used[i];\\n                used[i] += k;\\n                fen.update(i, -k); // remove k seats in tree node\\n                return [i, first];\\n            }\\n        }\\n        return [];\\n    }\\n    function scatter(k, maxRow) {\\n        let totToMaxRow = fen.query(maxRow); // use fenwick to query [0, maxRow] range sum\\n        if (totToMaxRow < k) return false;\\n        for (let i = 0; i <= maxRow; i++) {\\n            let seat = m - used[i];\\n            if (seat >= k) {\\n                used[i] += k;\\n                fen.update(i, -k);\\n                k = 0;\\n            } else {\\n                k -= seat;\\n                fen.update(i, -seat);\\n                used[i] = m;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) { // [0, i] prefix sum\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nfunction BookMyShow(n, m) {\\n    let used = Array(n).fill(0), fen = new Fenwick(n + 3);\\n    for (let i = 0; i < n; i++) fen.update(i, m); // original set each node with m seats\\n    return { gather, scatter }\\n    function gather(k, maxRow) {\\n        for (let i = 0; i <= maxRow; i++) {\\n            let seat = m - used[i];\\n            if (seat >= k) {\\n                let first = used[i];\\n                used[i] += k;\\n                fen.update(i, -k); // remove k seats in tree node\\n                return [i, first];\\n            }\\n        }\\n        return [];\\n    }\\n    function scatter(k, maxRow) {\\n        let totToMaxRow = fen.query(maxRow); // use fenwick to query [0, maxRow] range sum\\n        if (totToMaxRow < k) return false;\\n        for (let i = 0; i <= maxRow; i++) {\\n            let seat = m - used[i];\\n            if (seat >= k) {\\n                used[i] += k;\\n                fen.update(i, -k);\\n                k = 0;\\n            } else {\\n                k -= seat;\\n                fen.update(i, -seat);\\n                used[i] = m;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084954,
                "title": "help-heap-overflow-error-getting-heap-overflow-error-while-example-test-case-passes",
                "content": "Can someone plz help me what am I missing? TIA```\\nclass BookMyShow {\\npublic:\\n    vector<int> sm {50000,0};\\n    int totalSeatInRow;\\n    BookMyShow(int n, int m) {\\n        int i=0;\\n        totalSeatInRow=m;\\n        for(i=0;i<n;i++) {\\n            sm[i]=m;\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int i;\\n         vector<int> ans;\\n        if(k>totalSeatInRow)\\n            return ans;\\n        for(i=0;i<=maxRow;i++){\\n            \\n            if(sm[i]>=k){\\n                ans.push_back(i);\\n                ans.push_back(totalSeatInRow-sm[i]);\\n                sm[i]-=k;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int i;\\n        int emptySeat=0;\\n        for(i=0;i<=maxRow;i++){\\n            emptySeat+=sm[i];\\n            //cout<<emptySeat<<\"\\\\t\";\\n            if(emptySeat>=k)\\n                break;\\n        }\\n        \\n        if(emptySeat<k)\\n            return false;\\n        emptySeat=k;\\n        for(i=0;i<=maxRow;i++){\\n            if(emptySeat>sm[i])\\n            {\\n                emptySeat-=sm[i];\\n                sm[i]=0;\\n            }\\n            else{\\n                sm[i]-=emptySeat;\\n                break;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    vector<int> sm {50000,0};\\n    int totalSeatInRow;\\n    BookMyShow(int n, int m) {\\n        int i=0;\\n        totalSeatInRow=m;\\n        for(i=0;i<n;i++) {\\n            sm[i]=m;\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        int i;\\n         vector<int> ans;\\n        if(k>totalSeatInRow)\\n            return ans;\\n        for(i=0;i<=maxRow;i++){\\n            \\n            if(sm[i]>=k){\\n                ans.push_back(i);\\n                ans.push_back(totalSeatInRow-sm[i]);\\n                sm[i]-=k;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int i;\\n        int emptySeat=0;\\n        for(i=0;i<=maxRow;i++){\\n            emptySeat+=sm[i];\\n            //cout<<emptySeat<<\"\\\\t\";\\n            if(emptySeat>=k)\\n                break;\\n        }\\n        \\n        if(emptySeat<k)\\n            return false;\\n        emptySeat=k;\\n        for(i=0;i<=maxRow;i++){\\n            if(emptySeat>sm[i])\\n            {\\n                emptySeat-=sm[i];\\n                sm[i]=0;\\n            }\\n            else{\\n                sm[i]-=emptySeat;\\n                break;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2084939,
                "title": "booking-concert-tickets-in-groups-o-log-n-per-query-using-two-segment-trees",
                "content": "```\\nlong long m1;\\nclass segTree {\\npublic:\\n    long long n;\\n    long long* S;\\n    segTree(long long n) {\\n        this->n = n;\\n        S = new long long[4 * n + 1];\\n        for (long long i = 0; i < 4 * n + 1; ++i)\\n        {\\n            S[i] = m1;\\n        }\\n    }\\n    segTree() {\\n        \\n    }\\n\\n     long long buildTree(long long index, long long srt, long long end, long long k) {\\n        if(S[index] < k) {\\n            return -1;\\n        }\\n        if(srt == end) {\\n            return srt;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        if(S[2 * index + 1] >= k) {\\n            return buildTree(2 * index + 1, srt, mid, k);\\n        } else if(S[2 * index + 2] >= k) {\\n            return  buildTree(2 * index + 2, mid + 1, end, k);\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    void update_Tree(long long index, long long srt, long long end, long long i, long long val) {\\n        if(i < srt || i > end) {\\n            return;\\n        }\\n        if(srt == end) {\\n            S[index] = val;\\n            return;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        update_Tree(2 * index + 1, srt, mid, i, val);\\n        update_Tree(2 * index + 2, mid + 1, end, i, val);\\n        S[index] = max(S[2 * index + 1], S[2 * index + 2]);\\n    }\\n\\n    long long minimum_query(long long index, long long q_srt, long long q_end, long long srt, long long end) {\\n        if(q_srt <= srt && end <= q_end) {\\n            return S[index];\\n        }\\n        if(q_end < srt || q_srt > end) {\\n            return 0;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        long long leftVal = minimum_query(2 * index + 1, q_srt, q_end, srt, mid);\\n        long long rightVal = minimum_query(2 * index + 2, q_srt, q_end, mid + 1, end);\\n        return max(leftVal, rightVal);\\n    }\\n};\\n\\n\\nclass segTree1 {\\npublic:\\n    long long n;\\n    long long* S;\\n    segTree1(long long n) {\\n        this->n = n;\\n        S = new long long[4 * n + 1];\\n        for (long long i = 0; i < 4 * n + 1; ++i)\\n        {\\n            S[i] = m1;\\n        }\\n    }\\n    segTree1() {\\n        \\n    }\\n\\n    void update_Tree(long long index, long long srt, long long end, long long i, long long val) {\\n        if(i < srt || i > end) {\\n            return;\\n        }\\n        if(srt == end) {\\n            S[index] = val;\\n            return;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        update_Tree(2 * index + 1, srt, mid, i, val);\\n        update_Tree(2 * index + 2, mid + 1, end, i, val);\\n        S[index] = S[2 * index + 1] + S[2 * index + 2];\\n    }\\n\\n    long long minimum_query(long long index, long long q_srt, long long q_end, long long srt, long long end) {\\n        if(q_srt <= srt && end <= q_end) {\\n            return S[index];\\n        }\\n        if(q_end < srt || q_srt > end) {\\n            return 0;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        long long leftVal = minimum_query(2 * index + 1, q_srt, q_end, srt, mid);\\n        long long rightVal = minimum_query(2 * index + 2, q_srt, q_end, mid + 1, end);\\n        return leftVal + rightVal;\\n    }\\n};\\n\\n\\nclass BookMyShow {\\npublic:\\n    segTree Smax;\\n    segTree1 Ssum;\\n    long long n, m;\\n    vector<long long> vec;\\n    long long cur = 0;\\n    BookMyShow(long long n, long long m) {\\n        m1 = m;\\n        this->n = n;\\n        this->m = m;\\n        vec.clear();\\n        vec.resize(n);\\n        for(long long i = 0; i < n; ++i) {\\n            vec[i] = m;\\n        }\\n        Smax = segTree(n);\\n        Ssum = segTree1(n);\\n        for(int i = 0; i < n; ++i) {\\n             Ssum.update_Tree(0, 0, n - 1, i, m1);\\n        }\\n    }\\n    \\n    vector<long long> gather(long long k, long long maxRow) {\\n        long long ind = Smax.buildTree(0, 0, n - 1, k);\\n        if(ind == -1 || ind > maxRow) {\\n            return {};\\n        }\\n        long long val = vec[ind] - k;\\n        vector<long long> ans = {ind, m - vec[ind]};\\n        Smax.update_Tree(0, 0, n - 1, ind, val);\\n        Ssum.update_Tree(0, 0, n - 1, ind, val);\\n        vec[ind] = val;\\n        return ans;\\n    }\\n    \\n    bool scatter(long long k, long long maxRow) {\\n        if(maxRow < cur) {\\n            return false;\\n        }\\n        long long sum = Ssum.minimum_query(0, 0, maxRow, 0, n - 1);\\n       // cout << sum << endl;\\n        if(sum < k) {\\n            return false;\\n        }\\n        while(k > 0) {\\n            long long minm = min(vec[cur], k);\\n            k -= minm;\\n            long long val = vec[cur] - minm;\\n            Smax.update_Tree(0, 0, n - 1, cur, val);\\n            Ssum.update_Tree(0, 0, n - 1, cur, val);\\n            vec[cur] = val;\\n            if(vec[cur] == 0)\\n                cur++;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<long long> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */ ``\\n```",
                "solutionTags": [],
                "code": "```\\nlong long m1;\\nclass segTree {\\npublic:\\n    long long n;\\n    long long* S;\\n    segTree(long long n) {\\n        this->n = n;\\n        S = new long long[4 * n + 1];\\n        for (long long i = 0; i < 4 * n + 1; ++i)\\n        {\\n            S[i] = m1;\\n        }\\n    }\\n    segTree() {\\n        \\n    }\\n\\n     long long buildTree(long long index, long long srt, long long end, long long k) {\\n        if(S[index] < k) {\\n            return -1;\\n        }\\n        if(srt == end) {\\n            return srt;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        if(S[2 * index + 1] >= k) {\\n            return buildTree(2 * index + 1, srt, mid, k);\\n        } else if(S[2 * index + 2] >= k) {\\n            return  buildTree(2 * index + 2, mid + 1, end, k);\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    void update_Tree(long long index, long long srt, long long end, long long i, long long val) {\\n        if(i < srt || i > end) {\\n            return;\\n        }\\n        if(srt == end) {\\n            S[index] = val;\\n            return;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        update_Tree(2 * index + 1, srt, mid, i, val);\\n        update_Tree(2 * index + 2, mid + 1, end, i, val);\\n        S[index] = max(S[2 * index + 1], S[2 * index + 2]);\\n    }\\n\\n    long long minimum_query(long long index, long long q_srt, long long q_end, long long srt, long long end) {\\n        if(q_srt <= srt && end <= q_end) {\\n            return S[index];\\n        }\\n        if(q_end < srt || q_srt > end) {\\n            return 0;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        long long leftVal = minimum_query(2 * index + 1, q_srt, q_end, srt, mid);\\n        long long rightVal = minimum_query(2 * index + 2, q_srt, q_end, mid + 1, end);\\n        return max(leftVal, rightVal);\\n    }\\n};\\n\\n\\nclass segTree1 {\\npublic:\\n    long long n;\\n    long long* S;\\n    segTree1(long long n) {\\n        this->n = n;\\n        S = new long long[4 * n + 1];\\n        for (long long i = 0; i < 4 * n + 1; ++i)\\n        {\\n            S[i] = m1;\\n        }\\n    }\\n    segTree1() {\\n        \\n    }\\n\\n    void update_Tree(long long index, long long srt, long long end, long long i, long long val) {\\n        if(i < srt || i > end) {\\n            return;\\n        }\\n        if(srt == end) {\\n            S[index] = val;\\n            return;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        update_Tree(2 * index + 1, srt, mid, i, val);\\n        update_Tree(2 * index + 2, mid + 1, end, i, val);\\n        S[index] = S[2 * index + 1] + S[2 * index + 2];\\n    }\\n\\n    long long minimum_query(long long index, long long q_srt, long long q_end, long long srt, long long end) {\\n        if(q_srt <= srt && end <= q_end) {\\n            return S[index];\\n        }\\n        if(q_end < srt || q_srt > end) {\\n            return 0;\\n        }\\n        long long mid = (srt + end)/ 2;\\n        long long leftVal = minimum_query(2 * index + 1, q_srt, q_end, srt, mid);\\n        long long rightVal = minimum_query(2 * index + 2, q_srt, q_end, mid + 1, end);\\n        return leftVal + rightVal;\\n    }\\n};\\n\\n\\nclass BookMyShow {\\npublic:\\n    segTree Smax;\\n    segTree1 Ssum;\\n    long long n, m;\\n    vector<long long> vec;\\n    long long cur = 0;\\n    BookMyShow(long long n, long long m) {\\n        m1 = m;\\n        this->n = n;\\n        this->m = m;\\n        vec.clear();\\n        vec.resize(n);\\n        for(long long i = 0; i < n; ++i) {\\n            vec[i] = m;\\n        }\\n        Smax = segTree(n);\\n        Ssum = segTree1(n);\\n        for(int i = 0; i < n; ++i) {\\n             Ssum.update_Tree(0, 0, n - 1, i, m1);\\n        }\\n    }\\n    \\n    vector<long long> gather(long long k, long long maxRow) {\\n        long long ind = Smax.buildTree(0, 0, n - 1, k);\\n        if(ind == -1 || ind > maxRow) {\\n            return {};\\n        }\\n        long long val = vec[ind] - k;\\n        vector<long long> ans = {ind, m - vec[ind]};\\n        Smax.update_Tree(0, 0, n - 1, ind, val);\\n        Ssum.update_Tree(0, 0, n - 1, ind, val);\\n        vec[ind] = val;\\n        return ans;\\n    }\\n    \\n    bool scatter(long long k, long long maxRow) {\\n        if(maxRow < cur) {\\n            return false;\\n        }\\n        long long sum = Ssum.minimum_query(0, 0, maxRow, 0, n - 1);\\n       // cout << sum << endl;\\n        if(sum < k) {\\n            return false;\\n        }\\n        while(k > 0) {\\n            long long minm = min(vec[cur], k);\\n            k -= minm;\\n            long long val = vec[cur] - minm;\\n            Smax.update_Tree(0, 0, n - 1, cur, val);\\n            Ssum.update_Tree(0, 0, n - 1, cur, val);\\n            vec[cur] = val;\\n            if(vec[cur] == 0)\\n                cur++;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<long long> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */ ``\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2084759,
                "title": "c-correct-solution-but-gives-tle-optimization-required",
                "content": "**This solution gives TLE as it is not an efficient algorithm for large number of queries.**\\n**However you can go through this solution :)**\\n\\n```\\nusing ll_t = long long;\\ntemplate<class T1>\\nusing vv_t = vector<T1>;\\n\\nclass BookMyShow {\\n        vector<ll_t> emptySeatIndex;\\n        ll_t n, m;\\npublic:\\n    \\n    BookMyShow(int n, int m) {\\n        this->n = (long long)n;\\n        this->m = (long long)m;\\n        emptySeatIndex = vector<ll_t>(n, 0); // first empty seat index of every row\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        ll_t row = 0, col = 0;\\n        bool seatAllocationPossible = false;\\n        \\n        for(int i=0; i<=maxRow; ++i){\\n            ll_t currRowEmptySeats = m - emptySeatIndex[i]; // compute total empty seats in current row\\n            if(currRowEmptySeats >= k){// seat can be allocated\\n                row = i;\\n                col = emptySeatIndex[i];\\n                emptySeatIndex[i] += k; // empty seat allocated, update start of empty seat in curr row\\n                seatAllocationPossible = true; // seat allocation possible\\n                break;\\n            }\\n        }\\n        \\n        \\n        if(seatAllocationPossible){\\n            return { (int)row, (int)col};\\n        }\\n        return {}; // seat allocation not possible\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        bool seatAllocationPossible = false;\\n        vector<ll_t> temp(emptySeatIndex.begin(), emptySeatIndex.end());\\n        \\n         for(int i=0; i<=maxRow; ++i){\\n            ll_t currRowEmptySeats = m - temp[i]; // compute total empty seats in current row\\n             \\n            if(currRowEmptySeats > 0){ // we can allocate some seats in curr row\\n                if(k > currRowEmptySeats){ // all k members are cannot be allocated in curr row\\n                    k = k - currRowEmptySeats; \\n                    temp[i] = m;// all seats in curr row allocated\\n                }else{\\n                    temp[i] += k; // all k members are allocated in curr row\\n                    k = 0;\\n                    seatAllocationPossible = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(seatAllocationPossible == true){\\n            for(int i=0; i<temp.size(); ++i){\\n                emptySeatIndex[i] = temp[i];\\n            }\\n        }\\n        return seatAllocationPossible;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nusing ll_t = long long;\\ntemplate<class T1>\\nusing vv_t = vector<T1>;\\n\\nclass BookMyShow {\\n        vector<ll_t> emptySeatIndex;\\n        ll_t n, m;\\npublic:\\n    \\n    BookMyShow(int n, int m) {\\n        this->n = (long long)n;\\n        this->m = (long long)m;\\n        emptySeatIndex = vector<ll_t>(n, 0); // first empty seat index of every row\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        ll_t row = 0, col = 0;\\n        bool seatAllocationPossible = false;\\n        \\n        for(int i=0; i<=maxRow; ++i){\\n            ll_t currRowEmptySeats = m - emptySeatIndex[i]; // compute total empty seats in current row\\n            if(currRowEmptySeats >= k){// seat can be allocated\\n                row = i;\\n                col = emptySeatIndex[i];\\n                emptySeatIndex[i] += k; // empty seat allocated, update start of empty seat in curr row\\n                seatAllocationPossible = true; // seat allocation possible\\n                break;\\n            }\\n        }\\n        \\n        \\n        if(seatAllocationPossible){\\n            return { (int)row, (int)col};\\n        }\\n        return {}; // seat allocation not possible\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        bool seatAllocationPossible = false;\\n        vector<ll_t> temp(emptySeatIndex.begin(), emptySeatIndex.end());\\n        \\n         for(int i=0; i<=maxRow; ++i){\\n            ll_t currRowEmptySeats = m - temp[i]; // compute total empty seats in current row\\n             \\n            if(currRowEmptySeats > 0){ // we can allocate some seats in curr row\\n                if(k > currRowEmptySeats){ // all k members are cannot be allocated in curr row\\n                    k = k - currRowEmptySeats; \\n                    temp[i] = m;// all seats in curr row allocated\\n                }else{\\n                    temp[i] += k; // all k members are allocated in curr row\\n                    k = 0;\\n                    seatAllocationPossible = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(seatAllocationPossible == true){\\n            for(int i=0; i<temp.size(); ++i){\\n                emptySeatIndex[i] = temp[i];\\n            }\\n        }\\n        return seatAllocationPossible;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084730,
                "title": "detailed-video-explanation",
                "content": "[Video Link](https://www.youtube.com/watch?v=31jwXVbmatw)",
                "solutionTags": [
                    "Tree"
                ],
                "code": "[Video Link](https://www.youtube.com/watch?v=31jwXVbmatw)",
                "codeTag": "Unknown"
            },
            {
                "id": 2084701,
                "title": "kotlin-solution",
                "content": "```\\nimport kotlin.math.min\\n\\nclass BookMyShow(n: Int, m: Int) {\\n    private val hall = ArrayList<ArrayList<IntRange>>(n)\\n        .apply { repeat(n) { add(ArrayList<IntRange>().also { it.add(0 until m) }) } }\\n    private var freeInRow = IntArray(n) { m }\\n    private var firstFreeRow = 0\\n\\n    fun gather(k: Int, maxRow: Int): IntArray {\\n        for (i in firstFreeRow..maxRow) {\\n            if (freeInRow[i] < k) continue\\n            hall[i].forEachIndexed { j, range ->\\n                if (range.last - range.first + 1 >= k) {\\n                    freeInRow[i] -= k\\n                    if (range.last - range.first < k) hall[i].removeAt(j)\\n                    else hall[i][j] = range.first + k..range.last\\n                    return intArrayOf(i, range.first)\\n                }\\n            }\\n        }\\n        return intArrayOf()\\n    }\\n\\n    fun scatter(k: Int, maxRow: Int): Boolean {\\n        var freeCount = 0\\n        for (i in firstFreeRow..maxRow) {\\n            freeCount += freeInRow[i]\\n            if (freeCount >= k) break\\n        }\\n        if (k > freeCount) return false\\n        var left = k\\n        for (i in firstFreeRow..maxRow) {\\n            val take = min(left, freeInRow[i])\\n            if (take == 0) {\\n                firstFreeRow = i + 1\\n                continue\\n            }\\n            if (freeInRow[i] > take) {\\n                var l = take\\n                for (j in hall[i].indices) {\\n                    val range = hall[i][j]\\n                    l -= range.last - range.first + 1\\n                    if (l >= 0) hall[i].removeAt(j) else hall[i][j] = range.last + l + 1..range.last\\n                }\\n            } else {\\n                hall[i].clear()\\n            }\\n            freeInRow[i] -= take\\n            left -= take\\n            if (left == 0) return true\\n        }\\n        return false\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport kotlin.math.min\\n\\nclass BookMyShow(n: Int, m: Int) {\\n    private val hall = ArrayList<ArrayList<IntRange>>(n)\\n        .apply { repeat(n) { add(ArrayList<IntRange>().also { it.add(0 until m) }) } }\\n    private var freeInRow = IntArray(n) { m }\\n    private var firstFreeRow = 0\\n\\n    fun gather(k: Int, maxRow: Int): IntArray {\\n        for (i in firstFreeRow..maxRow) {\\n            if (freeInRow[i] < k) continue\\n            hall[i].forEachIndexed { j, range ->\\n                if (range.last - range.first + 1 >= k) {\\n                    freeInRow[i] -= k\\n                    if (range.last - range.first < k) hall[i].removeAt(j)\\n                    else hall[i][j] = range.first + k..range.last\\n                    return intArrayOf(i, range.first)\\n                }\\n            }\\n        }\\n        return intArrayOf()\\n    }\\n\\n    fun scatter(k: Int, maxRow: Int): Boolean {\\n        var freeCount = 0\\n        for (i in firstFreeRow..maxRow) {\\n            freeCount += freeInRow[i]\\n            if (freeCount >= k) break\\n        }\\n        if (k > freeCount) return false\\n        var left = k\\n        for (i in firstFreeRow..maxRow) {\\n            val take = min(left, freeInRow[i])\\n            if (take == 0) {\\n                firstFreeRow = i + 1\\n                continue\\n            }\\n            if (freeInRow[i] > take) {\\n                var l = take\\n                for (j in hall[i].indices) {\\n                    val range = hall[i][j]\\n                    l -= range.last - range.first + 1\\n                    if (l >= 0) hall[i].removeAt(j) else hall[i][j] = range.last + l + 1..range.last\\n                }\\n            } else {\\n                hall[i].clear()\\n            }\\n            freeInRow[i] -= take\\n            left -= take\\n            if (left == 0) return true\\n        }\\n        return false\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084700,
                "title": "java-segment-tree",
                "content": "```\\nclass BookMyShow {\\n    int n, m;\\n    Seg seg;\\n    Queue<Integer> pq = new LinkedList<>();\\n    public BookMyShow(int n, int m) {\\n        this.n = n;\\n        this.m = m;\\n        seg = new Seg(0, n - 1);\\n        for(int i = 0; i < n; i++) {\\n            pq.add(i);\\n        }\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        int x = m - k;\\n        int mn = seg.query(0, maxRow);\\n        if(mn > x) {\\n            return new int[]{};\\n        }\\n        \\n        int index = dfs(seg, maxRow, x);\\n        int old =  seg.query(index, index);\\n        seg.update(index, old + k);\\n        return new int[]{index, old};\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        if(pq.size() == 0) return false;\\n        \\n        int index = pq.peek();\\n        if(index > maxRow) {\\n            return false;\\n        }\\n        \\n        long sum = seg.query1(0, maxRow);\\n        if((m + 0l) * (maxRow + 1) - sum < k) return false;\\n        \\n        while(k > 0) {\\n            int peek = pq.peek();\\n            int old = (int)(seg.query1(peek, peek));\\n            int remain = m - old;\\n            if(remain > k) {\\n                seg.update(peek, old + k);\\n                k = 0;\\n            } else {\\n                k -= remain;\\n                pq.poll();\\n                seg.update(peek, m);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int dfs(Seg root, int bound, int x) {\\n        int l = root.l, r = root.r;\\n        if(l == r) {\\n            return l;\\n        }\\n        int mid = l + (r - l) / 2;\\n        \\n        \\n        if(bound <= mid) {\\n            return dfs(root.left, bound, x);\\n        } else {\\n            if(root.left.min <= x) {\\n                return dfs(root.left, bound, x);\\n            } else {\\n                return dfs(root.right, bound, x);\\n            }\\n        }\\n    }\\n    \\n    class Seg{\\n        int l,r;\\n        int min = 0;\\n        long sum = 0;\\n        Seg left=null,right=null;\\n        public Seg(int l,int r){\\n            this.l=l;\\n            this.r=r;\\n            if(l!=r){\\n                int mid=l+(r-l)/2;\\n                if(l<=mid)left=new Seg(l,mid);\\n                if(r>=mid+1)right=new Seg(mid+1,r);\\n            }else{\\n            \\n            }\\n        }\\n        public int query(int s,int e){//query min\\n            if(e<0||s<0)return 0;\\n            if(l==s&&r==e){\\n                return min;\\n            }\\n            int mid=l+(r-l)/2; //left :  to mid-1,\\n            if(e<=mid){\\n                return left.query(s,e);\\n            }\\n            else if(s>=mid+1){\\n                return right.query(s,e);\\n            }else{\\n                return Math.min(left.query(s,mid),right.query(mid+1,e));\\n            }\\n        }\\n        \\n        public long query1(int s,int e){ //query sum\\n            if(l==s&&r==e){\\n                return this.sum;\\n            }\\n            \\n            int mid=l+(r-l)/2; //left :  to mid-1,\\n            if(e<=mid){\\n                return left.query1(s,e);\\n            }\\n            else if(s>=mid+1){\\n                return right.query1(s,e);\\n            }else{\\n                return left.query1(s,mid) + right.query1(mid+1,e);\\n            }\\n        }\\n\\n        public void update(int index,int val){\\n            if(l==r){\\n                this.min=val;\\n                this.sum = val;\\n                return;\\n            }\\n            int mid=l+(r-l)/2;\\n            if(index<=mid){\\n                left.update(index,val);\\n            }else{\\n                right.update(index,val);\\n            }\\n            \\n            this.min=Math.min(left.min,right.min);\\n            this.sum = left.sum + right.sum;\\n        }\\n    \\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\n    int n, m;\\n    Seg seg;\\n    Queue<Integer> pq = new LinkedList<>();\\n    public BookMyShow(int n, int m) {\\n        this.n = n;\\n        this.m = m;\\n        seg = new Seg(0, n - 1);\\n        for(int i = 0; i < n; i++) {\\n            pq.add(i);\\n        }\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        int x = m - k;\\n        int mn = seg.query(0, maxRow);\\n        if(mn > x) {\\n            return new int[]{};\\n        }\\n        \\n        int index = dfs(seg, maxRow, x);\\n        int old =  seg.query(index, index);\\n        seg.update(index, old + k);\\n        return new int[]{index, old};\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        if(pq.size() == 0) return false;\\n        \\n        int index = pq.peek();\\n        if(index > maxRow) {\\n            return false;\\n        }\\n        \\n        long sum = seg.query1(0, maxRow);\\n        if((m + 0l) * (maxRow + 1) - sum < k) return false;\\n        \\n        while(k > 0) {\\n            int peek = pq.peek();\\n            int old = (int)(seg.query1(peek, peek));\\n            int remain = m - old;\\n            if(remain > k) {\\n                seg.update(peek, old + k);\\n                k = 0;\\n            } else {\\n                k -= remain;\\n                pq.poll();\\n                seg.update(peek, m);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int dfs(Seg root, int bound, int x) {\\n        int l = root.l, r = root.r;\\n        if(l == r) {\\n            return l;\\n        }\\n        int mid = l + (r - l) / 2;\\n        \\n        \\n        if(bound <= mid) {\\n            return dfs(root.left, bound, x);\\n        } else {\\n            if(root.left.min <= x) {\\n                return dfs(root.left, bound, x);\\n            } else {\\n                return dfs(root.right, bound, x);\\n            }\\n        }\\n    }\\n    \\n    class Seg{\\n        int l,r;\\n        int min = 0;\\n        long sum = 0;\\n        Seg left=null,right=null;\\n        public Seg(int l,int r){\\n            this.l=l;\\n            this.r=r;\\n            if(l!=r){\\n                int mid=l+(r-l)/2;\\n                if(l<=mid)left=new Seg(l,mid);\\n                if(r>=mid+1)right=new Seg(mid+1,r);\\n            }else{\\n            \\n            }\\n        }\\n        public int query(int s,int e){//query min\\n            if(e<0||s<0)return 0;\\n            if(l==s&&r==e){\\n                return min;\\n            }\\n            int mid=l+(r-l)/2; //left :  to mid-1,\\n            if(e<=mid){\\n                return left.query(s,e);\\n            }\\n            else if(s>=mid+1){\\n                return right.query(s,e);\\n            }else{\\n                return Math.min(left.query(s,mid),right.query(mid+1,e));\\n            }\\n        }\\n        \\n        public long query1(int s,int e){ //query sum\\n            if(l==s&&r==e){\\n                return this.sum;\\n            }\\n            \\n            int mid=l+(r-l)/2; //left :  to mid-1,\\n            if(e<=mid){\\n                return left.query1(s,e);\\n            }\\n            else if(s>=mid+1){\\n                return right.query1(s,e);\\n            }else{\\n                return left.query1(s,mid) + right.query1(mid+1,e);\\n            }\\n        }\\n\\n        public void update(int index,int val){\\n            if(l==r){\\n                this.min=val;\\n                this.sum = val;\\n                return;\\n            }\\n            int mid=l+(r-l)/2;\\n            if(index<=mid){\\n                left.update(index,val);\\n            }else{\\n                right.update(index,val);\\n            }\\n            \\n            this.min=Math.min(left.min,right.min);\\n            this.sum = left.sum + right.sum;\\n        }\\n    \\n    }\\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084608,
                "title": "c-tle-javascript-accepted-discrepancy-should-we-not-use-c-and-switch-to-js-python-java",
                "content": "Accepted : Javascript\\n```\\nvar BookMyShow = function(n, m) {\\n    this.rem = Array(n).fill(m);\\n    this.m = m;\\n    this.n = n;\\n    this.start = 0;\\n};\\n\\nBookMyShow.prototype.gather = function(k, maxRow) {\\n    for (let i = this.start; i <= maxRow; i += 1) {\\n        if (this.rem[i] >= k) {\\n            let rem = this.rem[i];\\n            this.rem[i] -= k;\\n            return [i, this.m-rem];\\n        }\\n    }\\n    \\n    return [];\\n};\\n\\n\\nBookMyShow.prototype.scatter = function(k, maxRow) {\\n    let temp = k;\\n    \\n    for (let i = this.start; i <= maxRow; i += 1) {\\n        temp -= this.rem[i];\\n    }\\n    \\n    if (temp > 0) return false;\\n    \\n    for (let i = this.start; i <= maxRow; i += 1) {\\n        if (k <= 0) break;\\n        \\n        let val = Math.min(k, this.rem[i]);\\n        \\n        k-=val;\\n        this.rem[i] -= val;\\n        if (this.rem[i] == 0) this.start = i + 1;\\n    }\\n    \\n    \\n    return true;\\n};\\n\\n```\\n\\nTLE : C++ (same as above)\\n```\\nclass BookMyShow {\\n    vector<int> s;\\n    int m, n;\\n    int start=0;\\npublic:\\n    BookMyShow(int n, int m) {\\n        this->n = n;\\n        this->m = m;\\n        s = vector<int>(n, m);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        for(int i=start; i<=maxRow; ++i)\\n            if(s[i]>=k)\\n            {   \\n                int c = s[i];\\n                s[i]-=k;\\n                return {i, m - c};\\n            }\\n        return {};\\n    }\\n\\n    \\n    bool scatter(int k, int maxRow) {\\n        int temp=k;\\n        for(int i=start; i<=maxRow && temp > 0; ++i) \\n            temp -= s[i];\\n        if(temp>0) return false;\\n        for(int i=start; i<= maxRow; ++i) {\\n            if (k<=0) break;\\n            int v = min(k, s[i]);\\n            k-=v;\\n            s[i]-=v;\\n            if(s[i]==0) start = i+1;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nis the evalutation correct ?",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nvar BookMyShow = function(n, m) {\\n    this.rem = Array(n).fill(m);\\n    this.m = m;\\n    this.n = n;\\n    this.start = 0;\\n};\\n\\nBookMyShow.prototype.gather = function(k, maxRow) {\\n    for (let i = this.start; i <= maxRow; i += 1) {\\n        if (this.rem[i] >= k) {\\n            let rem = this.rem[i];\\n            this.rem[i] -= k;\\n            return [i, this.m-rem];\\n        }\\n    }\\n    \\n    return [];\\n};\\n\\n\\nBookMyShow.prototype.scatter = function(k, maxRow) {\\n    let temp = k;\\n    \\n    for (let i = this.start; i <= maxRow; i += 1) {\\n        temp -= this.rem[i];\\n    }\\n    \\n    if (temp > 0) return false;\\n    \\n    for (let i = this.start; i <= maxRow; i += 1) {\\n        if (k <= 0) break;\\n        \\n        let val = Math.min(k, this.rem[i]);\\n        \\n        k-=val;\\n        this.rem[i] -= val;\\n        if (this.rem[i] == 0) this.start = i + 1;\\n    }\\n    \\n    \\n    return true;\\n};\\n\\n```\n```\\nclass BookMyShow {\\n    vector<int> s;\\n    int m, n;\\n    int start=0;\\npublic:\\n    BookMyShow(int n, int m) {\\n        this->n = n;\\n        this->m = m;\\n        s = vector<int>(n, m);\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        for(int i=start; i<=maxRow; ++i)\\n            if(s[i]>=k)\\n            {   \\n                int c = s[i];\\n                s[i]-=k;\\n                return {i, m - c};\\n            }\\n        return {};\\n    }\\n\\n    \\n    bool scatter(int k, int maxRow) {\\n        int temp=k;\\n        for(int i=start; i<=maxRow && temp > 0; ++i) \\n            temp -= s[i];\\n        if(temp>0) return false;\\n        for(int i=start; i<= maxRow; ++i) {\\n            if (k<=0) break;\\n            int v = min(k, s[i]);\\n            k-=v;\\n            s[i]-=v;\\n            if(s[i]==0) start = i+1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084492,
                "title": "javascript-brute-force-7460ms",
                "content": "in the edge of TLE and AC, submitted twice AC, first time TLE 93/94\\n```\\nfunction BookMyShow(n, m) {\\n    let used = Array(n).fill(0);\\n    return { gather, scatter }\\n    function gather(k, maxRow) {\\n        for (let i = 0; i <= maxRow; i++) {\\n            let seat = m - used[i];\\n            if (seat >= k) { // for gathering only current row has more than or equal to k seat, can operate\\n                let first = used[i];\\n                used[i] += k;\\n                return [i, first];\\n            }\\n        }\\n        return [];\\n    }\\n    function scatter(k, maxRow) { // arrange k to [0, maxRow], if possible, update used array\\n        let totToMaxRow = 0;\\n        for (let i = 0; i <= maxRow; i++) totToMaxRow += m - used[i];\\n        if (totToMaxRow < k) return false;\\n        for (let i = 0; i <= maxRow; i++) {\\n            let seat = m - used[i];\\n            if (seat >= k) {\\n                used[i] += k;\\n                k = 0;\\n            } else {\\n                k -= seat;\\n                used[i] = m;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/093a463d-9329-4ca3-861a-46900dc9df24_1653760309.1680558.png)\\n![image](https://assets.leetcode.com/users/images/0cf8fb6e-8596-4de9-9a76-38d41702735a_1653760547.9137313.png)\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction BookMyShow(n, m) {\\n    let used = Array(n).fill(0);\\n    return { gather, scatter }\\n    function gather(k, maxRow) {\\n        for (let i = 0; i <= maxRow; i++) {\\n            let seat = m - used[i];\\n            if (seat >= k) { // for gathering only current row has more than or equal to k seat, can operate\\n                let first = used[i];\\n                used[i] += k;\\n                return [i, first];\\n            }\\n        }\\n        return [];\\n    }\\n    function scatter(k, maxRow) { // arrange k to [0, maxRow], if possible, update used array\\n        let totToMaxRow = 0;\\n        for (let i = 0; i <= maxRow; i++) totToMaxRow += m - used[i];\\n        if (totToMaxRow < k) return false;\\n        for (let i = 0; i <= maxRow; i++) {\\n            let seat = m - used[i];\\n            if (seat >= k) {\\n                used[i] += k;\\n                k = 0;\\n            } else {\\n                k -= seat;\\n                used[i] = m;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084440,
                "title": "c-fenwick-tree-bit-and-brute-force-approach-easy-tc-qlogn",
                "content": "***Logic* -: \\nFor Gather :** we need to find first rows which have total vacant seat >=K , and row number <= maxRow. So we can iterate till maxRow and check for each row vacant seat availability.\\n\\n**For Scatter** : we need to find first rows where prefix sum of vacant seat till that rows is >= K and row number <= maxRow. So for this we will again iterate till maxRow and cumulative sum vacant seat , If any iteration we get cumulative sum == k we return true, also remember to while iterating we also allocating vacant seat so decrement seat availability by allocated seat count.\\n\\n**Brute Force** (TC Passed 91 /94 , TLE)\\n```\\nclass BookMyShow {\\n public:\\n  vector<long long int> prefix, ind;\\n  // long long total = 0;\\n  int mm;\\n  BookMyShow(int n, int m) {\\n    prefix.clear();\\n    ind.clear();\\n\\n    // prefix will store no of seat available at ith Row\\n    // ind will store vacant seat start from\\n    prefix.resize(n, m);\\n    ind.resize(n, 0);\\n    mm = m;\\n  }\\n\\n  vector<int> gather(int k, int maxRow) {\\n    vector<int> ans;\\n\\n    //search for first row whose total vacant seat >= k\\n    for (int i = 0; i <= maxRow; i++) {\\n      if (prefix[i] >= k) {\\n        ans.push_back(i);\\n        ans.push_back(ind[i]);\\n\\n        prefix[i] -= k;\\n        ind[i] = ind[i] + k;\\n\\n        break;\\n        // total -= k;\\n      }\\n    }\\n    return ans;\\n  }\\n\\n  bool scatter(int k, int maxRow) {\\n    int total = 0;\\n\\n    // first check where K seat avalable or not in entire prefix array if available then allocate start from first row\\n    for (int i = 0; i <= maxRow; i++) {\\n      if (prefix[i] > 0) total += prefix[i];\\n\\n      if (total >= k) {\\n        int cnt = k;\\n        for (int j = 0; j <= i; j++) {\\n          if (prefix[j] <= cnt) {\\n            cnt -= prefix[j];\\n            ind[j] = mm;\\n            prefix[j] = 0;\\n          } else {\\n            prefix[j] = prefix[j] - cnt;\\n\\n            ind[j] = mm - prefix[j];\\n            cnt = 0;\\n          }\\n\\n          if (cnt == 0) {\\n            return true;\\n          }\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n};\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```\\n\\nTime Complexity -> Q*N where Q is total queries and N is total Rows\\nSpace Complexity -> O(N)\\n\\n**Optimized using Fenwick Tree (Binary Index Tree)**\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass BookMyShow {\\n public:\\n  long long BIT[50001] = {};\\n  int rowCnt[50001] = {}, n = 0, m = 0, start = 0;\\n  BookMyShow(int n, int m) {\\n    this->n = n;\\n    this->m = m;\\n  }\\n\\n  long long BIT_PrefixSum(int i) {\\n    long long sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i)) sum += BIT[i];\\n    return sum;\\n  }\\n\\n  void add(int i, int val) {\\n    for (i = i + 1; i <= 50000; i += i & (-i)) BIT[i] += val;\\n  }\\n  vector<int> gather(int k, int maxRow) {\\n    // find total occupied place till maxRow\\n    long long total = BIT_PrefixSum(maxRow);\\n\\n    if (total + k > ((long long)maxRow + 1) * m) return {};\\n\\n    for (int i = start; i <= maxRow; ++i) {\\n      if (rowCnt[i] + k > m) continue;\\n      rowCnt[i] += k;\\n      add(i, k);\\n      return {i, rowCnt[i] - k};\\n    }\\n    return {};\\n  }\\n  bool scatter(int k, int maxRow) {\\n    long long total = BIT_PrefixSum(maxRow);\\n\\n    if (total + k > ((long long)maxRow + 1) * m) return false;\\n\\n    for (int i = start; k && i <= maxRow; ++i) {\\n      if (m - rowCnt[i]) {\\n        // take partial\\n        int seatOccupied = min(m - rowCnt[i], k);\\n\\n        // remaining seats\\n        k -= seatOccupied;\\n\\n        // add Occupied Seat to BIT till index i\\n        add(i, seatOccupied);\\n\\n        // Store occupied seat to rowCnt\\n        rowCnt[i] += seatOccupied;\\n      } else {\\n        // take full\\n        start = i + 1;\\n      }\\n    }\\n    return true;\\n  }\\n};\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```\\n\\nTime Complexity Q*logN\\nSpace Complexity O(N) where N is total rows",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass BookMyShow {\\n public:\\n  vector<long long int> prefix, ind;\\n  // long long total = 0;\\n  int mm;\\n  BookMyShow(int n, int m) {\\n    prefix.clear();\\n    ind.clear();\\n\\n    // prefix will store no of seat available at ith Row\\n    // ind will store vacant seat start from\\n    prefix.resize(n, m);\\n    ind.resize(n, 0);\\n    mm = m;\\n  }\\n\\n  vector<int> gather(int k, int maxRow) {\\n    vector<int> ans;\\n\\n    //search for first row whose total vacant seat >= k\\n    for (int i = 0; i <= maxRow; i++) {\\n      if (prefix[i] >= k) {\\n        ans.push_back(i);\\n        ans.push_back(ind[i]);\\n\\n        prefix[i] -= k;\\n        ind[i] = ind[i] + k;\\n\\n        break;\\n        // total -= k;\\n      }\\n    }\\n    return ans;\\n  }\\n\\n  bool scatter(int k, int maxRow) {\\n    int total = 0;\\n\\n    // first check where K seat avalable or not in entire prefix array if available then allocate start from first row\\n    for (int i = 0; i <= maxRow; i++) {\\n      if (prefix[i] > 0) total += prefix[i];\\n\\n      if (total >= k) {\\n        int cnt = k;\\n        for (int j = 0; j <= i; j++) {\\n          if (prefix[j] <= cnt) {\\n            cnt -= prefix[j];\\n            ind[j] = mm;\\n            prefix[j] = 0;\\n          } else {\\n            prefix[j] = prefix[j] - cnt;\\n\\n            ind[j] = mm - prefix[j];\\n            cnt = 0;\\n          }\\n\\n          if (cnt == 0) {\\n            return true;\\n          }\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n};\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass BookMyShow {\\n public:\\n  long long BIT[50001] = {};\\n  int rowCnt[50001] = {}, n = 0, m = 0, start = 0;\\n  BookMyShow(int n, int m) {\\n    this->n = n;\\n    this->m = m;\\n  }\\n\\n  long long BIT_PrefixSum(int i) {\\n    long long sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i)) sum += BIT[i];\\n    return sum;\\n  }\\n\\n  void add(int i, int val) {\\n    for (i = i + 1; i <= 50000; i += i & (-i)) BIT[i] += val;\\n  }\\n  vector<int> gather(int k, int maxRow) {\\n    // find total occupied place till maxRow\\n    long long total = BIT_PrefixSum(maxRow);\\n\\n    if (total + k > ((long long)maxRow + 1) * m) return {};\\n\\n    for (int i = start; i <= maxRow; ++i) {\\n      if (rowCnt[i] + k > m) continue;\\n      rowCnt[i] += k;\\n      add(i, k);\\n      return {i, rowCnt[i] - k};\\n    }\\n    return {};\\n  }\\n  bool scatter(int k, int maxRow) {\\n    long long total = BIT_PrefixSum(maxRow);\\n\\n    if (total + k > ((long long)maxRow + 1) * m) return false;\\n\\n    for (int i = start; k && i <= maxRow; ++i) {\\n      if (m - rowCnt[i]) {\\n        // take partial\\n        int seatOccupied = min(m - rowCnt[i], k);\\n\\n        // remaining seats\\n        k -= seatOccupied;\\n\\n        // add Occupied Seat to BIT till index i\\n        add(i, seatOccupied);\\n\\n        // Store occupied seat to rowCnt\\n        rowCnt[i] += seatOccupied;\\n      } else {\\n        // take full\\n        start = i + 1;\\n      }\\n    }\\n    return true;\\n  }\\n};\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2084355,
                "title": "c-list-of-int-solution",
                "content": "Not a efficient way after I saw other solution in the discussion, but this will work.\\nHmm need to pay attenion on TLE, so some if is to prevent it.\\nAnd maybe _seats can use dictionary to save memory.\\n_seats we define it as each row remain seats\\n\\nAnother point to prevent TLE, is remember the filled rows, so we wont need to start from 0 every time.\\nFilled rows only able to update on doing scatter, due to gather may pass a not filled row and reach next row.\\nScatter must fill the row then go to next one.\\n```\\npublic class BookMyShow\\n{\\n    private List<int> _seats;\\n    private int _seatsPerRow;\\n\\n    private int _filledRow;\\n\\n\\n    public BookMyShow(int n, int m)\\n    {\\n        _seats = new List<int>();\\n        _seatsPerRow = m;\\n        _filledRow = -1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            _seats.Add(_seatsPerRow);\\n        }\\n    }\\n\\n    public int[] Gather(int k, int maxRow)\\n    {\\n        for(var i = _filledRow + 1; i <= maxRow; i++)\\n        {\\n            var emptySeats = _seats[i];\\n            if(emptySeats >= k)\\n            {\\n                var firstPlace = _seatsPerRow - _seats[i];\\n                _seats[i] -= k;\\n                return new[] {i, firstPlace};\\n            }\\n        }\\n\\n        return new int[] { };\\n    }\\n\\n    public bool Scatter(int k, int maxRow)\\n    {\\n        long totalSeats = 0;\\n        long maxSeatCount = (long)(maxRow + 1) * (long)_seatsPerRow;\\n        if(maxSeatCount < k)\\n        {\\n            return false;\\n        }\\n\\n        for(var i = 0; i <= maxRow; i++)\\n        {\\n            var rowRemainSeats = _seats[i];\\n            totalSeats += rowRemainSeats;\\n        }\\n\\n\\n        if(totalSeats >= k)\\n        {\\n            for(var i = _filledRow + 1; i <= maxRow; i++)\\n            {\\n                var remainSeats = _seats[i];\\n                if(remainSeats == 0)\\n                {\\n                    _filledRow = i;\\n                    continue;\\n                }\\n\\n                if(k - remainSeats >= 0)\\n                {\\n                    _seats[i] = 0;\\n                    k -= remainSeats;\\n                }\\n                else\\n                {\\n                    _seats[i] -= k;\\n                    k = 0;\\n                }\\n\\n                if(k == 0)\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class BookMyShow\\n{\\n    private List<int> _seats;\\n    private int _seatsPerRow;\\n\\n    private int _filledRow;\\n\\n\\n    public BookMyShow(int n, int m)\\n    {\\n        _seats = new List<int>();\\n        _seatsPerRow = m;\\n        _filledRow = -1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            _seats.Add(_seatsPerRow);\\n        }\\n    }\\n\\n    public int[] Gather(int k, int maxRow)\\n    {\\n        for(var i = _filledRow + 1; i <= maxRow; i++)\\n        {\\n            var emptySeats = _seats[i];\\n            if(emptySeats >= k)\\n            {\\n                var firstPlace = _seatsPerRow - _seats[i];\\n                _seats[i] -= k;\\n                return new[] {i, firstPlace};\\n            }\\n        }\\n\\n        return new int[] { };\\n    }\\n\\n    public bool Scatter(int k, int maxRow)\\n    {\\n        long totalSeats = 0;\\n        long maxSeatCount = (long)(maxRow + 1) * (long)_seatsPerRow;\\n        if(maxSeatCount < k)\\n        {\\n            return false;\\n        }\\n\\n        for(var i = 0; i <= maxRow; i++)\\n        {\\n            var rowRemainSeats = _seats[i];\\n            totalSeats += rowRemainSeats;\\n        }\\n\\n\\n        if(totalSeats >= k)\\n        {\\n            for(var i = _filledRow + 1; i <= maxRow; i++)\\n            {\\n                var remainSeats = _seats[i];\\n                if(remainSeats == 0)\\n                {\\n                    _filledRow = i;\\n                    continue;\\n                }\\n\\n                if(k - remainSeats >= 0)\\n                {\\n                    _seats[i] = 0;\\n                    k -= remainSeats;\\n                }\\n                else\\n                {\\n                    _seats[i] -= k;\\n                    k = 0;\\n                }\\n\\n                if(k == 0)\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084337,
                "title": "similar-problem-hotel-queries",
                "content": "https://cses.fi/problemset/task/1143",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2084255,
                "title": "python-tle",
                "content": "Got 43/94 Test cases passed.\\n\\n````\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.n = n\\n        self.m = m\\n        self.seats = [[None for i in range(m)] for i in range(n)]\\n        self.rowfill = [-1 for i in range(n)]\\n        \\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        for i in range(self.n):\\n            rowfill = self.rowfill[i]\\n            if i > maxRow:\\n                return([])\\n            if self.m - rowfill - 1 >= k:\\n                    self.rowfill[i] += k \\n                    return ([i, rowfill + 1])\\n        \\n        \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        saveops = dict()\\n        \\n        for i in range(self.n + 1):\\n            \\n            if i > maxRow:\\n                return(False)\\n            \\n            rowfill = self.rowfill[i]\\n            \\n            if rowfill == self.m - 1:\\n                continue\\n            \\n            leftSpace = self.m - rowfill - 1 \\n            if k <= leftSpace:\\n                saveops[i] = k #self.rowfill[i] += k\\n                k -= leftSpace\\n                break\\n            else:\\n                saveops[i] = leftSpace #self.rowfill[i] = self.m - 1\\n                k -= leftSpace\\n        \\n        for i in iter(saveops):\\n            k = saveops[i]\\n            self.rowfill[i] += k\\n        return True\\n        \\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n\\n````\\n\\nPlease suggest Optimizations, Thanks in advance!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "````\\n\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.n = n\\n        self.m = m\\n        self.seats = [[None for i in range(m)] for i in range(n)]\\n        self.rowfill = [-1 for i in range(n)]\\n        \\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        for i in range(self.n):\\n            rowfill = self.rowfill[i]\\n            if i > maxRow:\\n                return([])\\n            if self.m - rowfill - 1 >= k:\\n                    self.rowfill[i] += k \\n                    return ([i, rowfill + 1])\\n        \\n        \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        saveops = dict()\\n        \\n        for i in range(self.n + 1):\\n            \\n            if i > maxRow:\\n                return(False)\\n            \\n            rowfill = self.rowfill[i]\\n            \\n            if rowfill == self.m - 1:\\n                continue\\n            \\n            leftSpace = self.m - rowfill - 1 \\n            if k <= leftSpace:\\n                saveops[i] = k #self.rowfill[i] += k\\n                k -= leftSpace\\n                break\\n            else:\\n                saveops[i] = leftSpace #self.rowfill[i] = self.m - 1\\n                k -= leftSpace\\n        \\n        for i in iter(saveops):\\n            k = saveops[i]\\n            self.rowfill[i] += k\\n        return True\\n        \\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084249,
                "title": "python-time-limit-exceeded-91-94-cases-passed",
                "content": "\\'\\'\\'\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.d =[0 for i in range(n)]\\n        self.m = m\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        r,out=0,[]\\n        while r<=maxRow:\\n            if self.m-self.d[r] >=k:\\n                out=[r,self.d[r]]\\n                self.d[r]+=k\\n                return out\\n            r+=1\\n        return []\\n    \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        r=0\\n        if self.m*(maxRow+1) - sum(self.d[:maxRow+1]) >=k:\\n            while r<=maxRow:\\n                cnt = self.m-self.d[r]\\n                if cnt>=k:\\n                    self.d[r]+=k\\n                    return True\\n                else: \\n                    self.d[r]+=cnt\\n                    k -= cnt\\n                r+=1\\n            \\n        return False\\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.d =[0 for i in range(n)]\\n        self.m = m\\n        \\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        r,out=0,[]\\n        while r<=maxRow:\\n            if self.m-self.d[r] >=k:\\n                out=[r,self.d[r]]\\n                self.d[r]+=k\\n                return out\\n            r+=1\\n        return []\\n    \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        r=0\\n        if self.m*(maxRow+1) - sum(self.d[:maxRow+1]) >=k:\\n            while r<=maxRow:\\n                cnt = self.m-self.d[r]\\n                if cnt>=k:\\n                    self.d[r]+=k\\n                    return True\\n                else: \\n                    self.d[r]+=cnt\\n                    k -= cnt\\n                r+=1\\n            \\n        return False\\n\\n\\n# Your BookMyShow object will be instantiated and called as such:\\n# obj = BookMyShow(n, m)\\n# param_1 = obj.gather(k,maxRow)\\n# param_2 = obj.scatter(k,maxRow)\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2084242,
                "title": "o-n2-time-complexity",
                "content": "accepted 1210ms :(\\n```\\nclass BookMyShow {\\n    private long[] seatsLeft;\\n    private long[] availBefore;\\n    private long numsInAColumn;\\n    private int notFullFrom = 0;\\n    private static final int[] EMPTY = new int[]{};\\n    public BookMyShow(int n, int m) {\\n        seatsLeft = new long[n];\\n        availBefore = new long[n];\\n        for(int i = 0; i < n;i++) {\\n            availBefore[i] = (long)(i + 1) * (long)m;\\n        }\\n        Arrays.fill(seatsLeft, (long)m);\\n        numsInAColumn = m;\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        if(k > numsInAColumn) {\\n            return EMPTY;\\n        }\\n        for(int i = notFullFrom; i <= maxRow; i++) {\\n            long seatsLeftThisRow = seatsLeft[i];\\n            if(seatsLeftThisRow >= k) {\\n                seatsLeft[i] -= k;\\n                for(int j = i; j < availBefore.length; j++) {\\n                    availBefore[j] -= k;\\n                }\\n                return new int[]{i, (int)(numsInAColumn - seatsLeftThisRow)};\\n            }\\n        }\\n        //System.out.println(Arrays.toString(availBefore));\\n        return EMPTY;\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        long totalAvail = availBefore[maxRow];\\n        if(totalAvail < k) {\\n            //System.out.println(Arrays.toString(availBefore));\\n            return false;\\n        }\\n        int left = k;\\n        int finalRow = notFullFrom;\\n        int notFullStart = notFullFrom;\\n        for(int i = 0; i <= maxRow && left > 0; i++) {\\n            if(left >= seatsLeft[i]) {\\n                left -= seatsLeft[i];\\n                seatsLeft[i] = 0;\\n                notFullFrom++;\\n            } else {\\n                seatsLeft[i] -= left;\\n                left = 0;\\n            }\\n        }\\n        for(int i = notFullStart; i < availBefore.length; i++) {\\n            availBefore[i] -= k;\\n        }\\n        //System.out.println(Arrays.toString(availBefore));\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\n    private long[] seatsLeft;\\n    private long[] availBefore;\\n    private long numsInAColumn;\\n    private int notFullFrom = 0;\\n    private static final int[] EMPTY = new int[]{};\\n    public BookMyShow(int n, int m) {\\n        seatsLeft = new long[n];\\n        availBefore = new long[n];\\n        for(int i = 0; i < n;i++) {\\n            availBefore[i] = (long)(i + 1) * (long)m;\\n        }\\n        Arrays.fill(seatsLeft, (long)m);\\n        numsInAColumn = m;\\n    }\\n    \\n    public int[] gather(int k, int maxRow) {\\n        if(k > numsInAColumn) {\\n            return EMPTY;\\n        }\\n        for(int i = notFullFrom; i <= maxRow; i++) {\\n            long seatsLeftThisRow = seatsLeft[i];\\n            if(seatsLeftThisRow >= k) {\\n                seatsLeft[i] -= k;\\n                for(int j = i; j < availBefore.length; j++) {\\n                    availBefore[j] -= k;\\n                }\\n                return new int[]{i, (int)(numsInAColumn - seatsLeftThisRow)};\\n            }\\n        }\\n        //System.out.println(Arrays.toString(availBefore));\\n        return EMPTY;\\n    }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n        long totalAvail = availBefore[maxRow];\\n        if(totalAvail < k) {\\n            //System.out.println(Arrays.toString(availBefore));\\n            return false;\\n        }\\n        int left = k;\\n        int finalRow = notFullFrom;\\n        int notFullStart = notFullFrom;\\n        for(int i = 0; i <= maxRow && left > 0; i++) {\\n            if(left >= seatsLeft[i]) {\\n                left -= seatsLeft[i];\\n                seatsLeft[i] = 0;\\n                notFullFrom++;\\n            } else {\\n                seatsLeft[i] -= left;\\n                left = 0;\\n            }\\n        }\\n        for(int i = notFullStart; i < availBefore.length; i++) {\\n            availBefore[i] -= k;\\n        }\\n        //System.out.println(Arrays.toString(availBefore));\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084233,
                "title": "accurate-and-small-solution-but-getting-tle",
                "content": "Small Solution that i made in Time , BUT Getting TLE\\nI just have a vector row to track index of empty seat and a variable filling to track smallest unfilled row  ;\\n\\n\\n```\\n  vector<int>row; int seat;\\n    int filling ;\\n    BookMyShow(int n, int m) {\\n        filling=0;\\n        row= vector<int>(n,0);\\n        seat= m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        for(int i=filling;i<=maxRow;i++){\\n            if(row[i]+k-1 <seat){\\n                row[i] += k;\\n                return {i,row[i]-k} ;\\n            }\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        for(int i=filled;i<=maxRow;i++){\\n            if(row[i]<seat){\\n                if(row[i]+k-1<seat){\\n                    row[i]+=k;\\n                    filling =i;\\n                    return true;\\n                }\\n                else {\\n                    k-= seat-row[i];\\n                }\\n            }\\n            else filling =i+1;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<int>row; int seat;\\n    int filling ;\\n    BookMyShow(int n, int m) {\\n        filling=0;\\n        row= vector<int>(n,0);\\n        seat= m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        for(int i=filling;i<=maxRow;i++){\\n            if(row[i]+k-1 <seat){\\n                row[i] += k;\\n                return {i,row[i]-k} ;\\n            }\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        for(int i=filled;i<=maxRow;i++){\\n            if(row[i]<seat){\\n                if(row[i]+k-1<seat){\\n                    row[i]+=k;\\n                    filling =i;\\n                    return true;\\n                }\\n                else {\\n                    k-= seat-row[i];\\n                }\\n            }\\n            else filling =i+1;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084188,
                "title": "c-segment-tree-for-rangemax-queries-fenwicktree-for-prefix-sum",
                "content": "```\\n#define ll long long\\nclass BookMyShow {\\n    vector<ll> dp,fen;\\n    vector<int> nums; int n,m,st; \\n   void fenupdate(int i,int x){  // O(Log(N))\\n        while(i<=n){\\n            fen[i] = fen[i] + x;\\n            i = i + (i&-i);\\n        }\\n    }\\n    ll fensum(int i){  // O(Log(N))\\n        ll s = 0;\\n        while(i>0){\\n            s+=fen[i]; i = i-(i&-i);\\n        }\\n        return s;\\n    }\\n    void update(int l,int h,int n,int i,int val){ // O(Log(N))\\n        if(l<=h){\\n            if(l==h){\\n                if(i==l) dp[n] = val;\\n                return;\\n            }\\n            int mid = (l+h)/2;\\n            if(i>mid) update(mid+1,h,2*n+2,i,val);\\n            else update(l,mid,2*n+1,i,val);\\n            dp[n] = max(dp[2*n+1],dp[2*n+2]);\\n        }\\n    }\\n    int query(int l,int h,int n,int i,int j){   // O(Log(N))\\n        if(l<=h){\\n            if(l>j || h<i) return -1;\\n            else if(l>=i && h<=j) return dp[n];\\n            int mid = (l+h)/2;\\n            return max(query(l,mid,2*n+1,i,j),query(mid+1,h,2*n+2,i,j));\\n        }\\n        else return -1;\\n    }\\n    int find(int x,int val){  // O(Log(N)*Log(N))\\n        int l = 0, h = x,re = -1;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            int k = query(0,n-1,0,0,m);\\n            if(k>=val){ \\n               re = m; h=m-1;\\n            }\\n            else l = m+1;\\n        }\\n        return re;\\n    }\\npublic:\\n    BookMyShow(int n, int m) {\\n        this->n = n; this->m = m; st = 0;\\n        dp = vector<ll>(4*n+1,0);\\n        nums = vector<int>(n+1,0);\\n        fen =  vector<ll>(n+2,0);\\n        for(int i = 0; i<n;++i){\\n            nums[i] = 0; \\n            update(0,n-1,0,i,m);\\n            fenupdate(i+1,m);\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {  // O(Log(N)*Log(N))\\n        int in = find(maxRow,k);\\n        if(in==-1) return {};\\n        int ans = nums[in];\\n        nums[in]+=k; \\n        update(0,n-1,0,in,m-nums[in]);\\n        fenupdate(in+1,-k);\\n        return {in,ans};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {   \\n        if(fensum(maxRow+1)<k) return 0;\\n        for(int i = st; i<n && k;++i){\\n            if(nums[i]==m) {st = i+1; continue;}\\n            int j = nums[i];\\n            nums[i] = min(m,nums[i]+k);\\n            update(0,n-1,0,i,m-nums[i]);\\n            fenupdate(i+1,j-nums[i]);\\n            if(nums[i]==m) st = i+1;\\n            k = k - min(k,m-j);\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n#define ll long long\\nclass BookMyShow {\\n    vector<ll> dp,fen;\\n    vector<int> nums; int n,m,st; \\n   void fenupdate(int i,int x){  // O(Log(N))\\n        while(i<=n){\\n            fen[i] = fen[i] + x;\\n            i = i + (i&-i);\\n        }\\n    }\\n    ll fensum(int i){  // O(Log(N))\\n        ll s = 0;\\n        while(i>0){\\n            s+=fen[i]; i = i-(i&-i);\\n        }\\n        return s;\\n    }\\n    void update(int l,int h,int n,int i,int val){ // O(Log(N))\\n        if(l<=h){\\n            if(l==h){\\n                if(i==l) dp[n] = val;\\n                return;\\n            }\\n            int mid = (l+h)/2;\\n            if(i>mid) update(mid+1,h,2*n+2,i,val);\\n            else update(l,mid,2*n+1,i,val);\\n            dp[n] = max(dp[2*n+1],dp[2*n+2]);\\n        }\\n    }\\n    int query(int l,int h,int n,int i,int j){   // O(Log(N))\\n        if(l<=h){\\n            if(l>j || h<i) return -1;\\n            else if(l>=i && h<=j) return dp[n];\\n            int mid = (l+h)/2;\\n            return max(query(l,mid,2*n+1,i,j),query(mid+1,h,2*n+2,i,j));\\n        }\\n        else return -1;\\n    }\\n    int find(int x,int val){  // O(Log(N)*Log(N))\\n        int l = 0, h = x,re = -1;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            int k = query(0,n-1,0,0,m);\\n            if(k>=val){ \\n               re = m; h=m-1;\\n            }\\n            else l = m+1;\\n        }\\n        return re;\\n    }\\npublic:\\n    BookMyShow(int n, int m) {\\n        this->n = n; this->m = m; st = 0;\\n        dp = vector<ll>(4*n+1,0);\\n        nums = vector<int>(n+1,0);\\n        fen =  vector<ll>(n+2,0);\\n        for(int i = 0; i<n;++i){\\n            nums[i] = 0; \\n            update(0,n-1,0,i,m);\\n            fenupdate(i+1,m);\\n        }\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {  // O(Log(N)*Log(N))\\n        int in = find(maxRow,k);\\n        if(in==-1) return {};\\n        int ans = nums[in];\\n        nums[in]+=k; \\n        update(0,n-1,0,in,m-nums[in]);\\n        fenupdate(in+1,-k);\\n        return {in,ans};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {   \\n        if(fensum(maxRow+1)<k) return 0;\\n        for(int i = st; i<n && k;++i){\\n            if(nums[i]==m) {st = i+1; continue;}\\n            int j = nums[i];\\n            nums[i] = min(m,nums[i]+k);\\n            update(0,n-1,0,i,m-nums[i]);\\n            fenupdate(i+1,j-nums[i]);\\n            if(nums[i]==m) st = i+1;\\n            k = k - min(k,m-j);\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084082,
                "title": "c-storing-occupied-seats-for-each-row-gives-tle-o-n-space-o-n-tc-query",
                "content": "For each row, we use a count vector to store the count of number of seats that have already been occupied. This approach will give TLE for the given constraints in the question.\\n\\n```\\nclass BookMyShow {\\n    int rows,columns;\\n    vector<long long>cnt_occupied; // no of seats occupied in each row;\\n    int min_avaliable_row = 0; // stores the minimum index of row which contains at least one empty seat. (Used just to make the search space smaller)\\n\\npublic:\\n    \\n    BookMyShow(int n, int m) {\\n        rows=n, columns = m;\\n        cnt_occupied = vector<long long>(n); \\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n\\t// finds the row with smallest index, that has >=k seats\\n\\t\\n        vector<int>ans;\\n        for(int i=min_avaliable_row;i<=maxRow;i++){\\n            if(columns-cnt_occupied[i]>=k){\\n                ans.push_back(i);\\n                ans.push_back(cnt_occupied[i]);\\n                cnt_occupied[i]+=k;\\n                return ans;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        //greedily assigns seats\\n        int prevIndex= -1, i=min_avaliable_row;\\n        int left = k;\\n\\t\\tint min_start = min_avaliable_row;\\n        while(i<=maxRow&& left>0){\\n            int row_left = columns - cnt_occupied[i]; // number  of unoccupied seats in row[i]\\n            if(row_left>=left){\\n\\t\\t\\t\\t//It\\'s possible that we can get K seats.\\n                cnt_occupied[i]+=left;\\n                prevIndex = i-1;\\n                min_avaliable_row = i;\\n                left = 0;\\n            }else if(row_left>0){\\n                left-=row_left;\\n            }\\n            i++;\\n        }\\n        \\n        if(left==0){\\n           while(prevIndex>=min_start){\\n\\t\\t   // set all prev row\\'s seats to occupied\\n                cnt_occupied[prevIndex] =columns;\\n                prevIndex--;\\n            }\\n            return true;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass BookMyShow {\\n    int rows,columns;\\n    vector<long long>cnt_occupied; // no of seats occupied in each row;\\n    int min_avaliable_row = 0; // stores the minimum index of row which contains at least one empty seat. (Used just to make the search space smaller)\\n\\npublic:\\n    \\n    BookMyShow(int n, int m) {\\n        rows=n, columns = m;\\n        cnt_occupied = vector<long long>(n); \\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n\\t// finds the row with smallest index, that has >=k seats\\n\\t\\n        vector<int>ans;\\n        for(int i=min_avaliable_row;i<=maxRow;i++){\\n            if(columns-cnt_occupied[i]>=k){\\n                ans.push_back(i);\\n                ans.push_back(cnt_occupied[i]);\\n                cnt_occupied[i]+=k;\\n                return ans;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        //greedily assigns seats\\n        int prevIndex= -1, i=min_avaliable_row;\\n        int left = k;\\n\\t\\tint min_start = min_avaliable_row;\\n        while(i<=maxRow&& left>0){\\n            int row_left = columns - cnt_occupied[i]; // number  of unoccupied seats in row[i]\\n            if(row_left>=left){\\n\\t\\t\\t\\t//It\\'s possible that we can get K seats.\\n                cnt_occupied[i]+=left;\\n                prevIndex = i-1;\\n                min_avaliable_row = i;\\n                left = 0;\\n            }else if(row_left>0){\\n                left-=row_left;\\n            }\\n            i++;\\n        }\\n        \\n        if(left==0){\\n           while(prevIndex>=min_start){\\n\\t\\t   // set all prev row\\'s seats to occupied\\n                cnt_occupied[prevIndex] =columns;\\n                prevIndex--;\\n            }\\n            return true;\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084078,
                "title": "segment-tree-and-bit-tree",
                "content": "```\\n#define ll long long\\nclass sg{\\n\\n    public:\\n    vector<ll> seg;\\n    int N;\\n    void merge(ll & cur,ll & left,ll & right){\\n              cur=max(left,right);\\n    }\\n    ll Query(int qs,int qe,int si,int ss,int se){ \\n         if(ss>qe||se<qs||ss>se)\\n              return -1 ;\\n             if(ss>=qs&&se<=qe)\\n              return seg[si];\\n             int mid=(se+ss)/2;\\n             ll le=Query(qs,qe,2*si+1,ss,mid);\\n             ll ri=Query(qs,qe,2*si+2,mid+1,se);\\n             ll res;\\n             merge(res,le,ri);\\n             return res;\\n    }\\n    void Update(int qs,int qe,int diff,int si,int ss,int se)\\n    {\\n                if(ss>qe||se<qs||ss>se)\\n                    return ;\\n                if(ss>=qs&&se<=qe)\\n                 {\\n                   seg[si]=diff;\\n                   return ;\\n                 }\\n\\n            int mid=(se+ss)/2;\\n\\n            Update(qs,qe,diff,2*si+1,ss,mid);\\n            Update(qs,qe,diff,2*si+2,mid+1,se);\\n\\n            merge(seg[si],seg[2*si+1],seg[2*si+2]);\\n    }\\n    void Build(ll val,int si,int ss,int se)\\n    {        if(ss>se) return;\\n             if(ss==se){\\n             seg[si]=val;return ;}\\n             int mid=(ss+se)/2;\\n             Build(val,2*si+1,ss,mid);\\n             Build(val,2*si+2,mid+1,se);\\n             merge(seg[si],seg[2*si+1],seg[2*si+2]);\\n    }\\n    void build(ll val){ Build(val,0,0,N-1);}\\n    ll query(ll qs,ll qe){ return Query(qs,qe,0,0,N-1);}\\n    void update(ll qs,ll qe,ll val){ Update(qs,qe,val,0,0,N-1);}\\n};\\n\\nclass BookMyShow {\\npublic:\\n    sg ss;\\n    int left;\\n    vector<ll> val;\\n    vector<ll> BIT;    \\n    ll N,M;\\n    ll get(ll ix)\\n    {\\n        ll sum=0;\\n        while(ix)\\n        {\\n             sum+=BIT[ix];\\n             ix-=ix&(-ix);\\n        }\\n        return sum;\\n    }\\n    void update(ll ix, ll val)\\n    {   \\n            while(ix<=N)  \\n            {\\n                 BIT[ix]+=val;\\n                ix+=ix&(-ix);\\n            }\\n    }\\n    BookMyShow(int n, int m) {\\n           ss.seg=vector<ll>(4*n);\\n           ss.N=n;\\n           ss.build(m);\\n           N=n;\\n           M=m;\\n           left=0;\\n           val.clear();\\n           val.resize(n);\\n           for(int i=0;i<n;i++) val[i]=m;\\n           BIT.resize(n+1);\\n           for(int i=0;i<=n;i++) BIT[i]=0;\\n           for(int i=1;i<=n;i++)\\n               update(i,m);\\n           \\n    }\\n    vector<int> gather(int k, int maxRow) {\\n         vector<int> res;\\n        \\n        ll l=left,h=maxRow;\\n        ll ix=-1;\\n        while(l<=h)\\n        {\\n             ll mid=(l+h)/2;\\n             if(ss.query(l,mid)>=k)\\n             {\\n                 ix=mid;\\n                 h=mid-1;\\n             }\\n             else\\n             {\\n                 l=mid+1;\\n             }\\n        }\\n        if(ix==-1)\\n            return res;\\n        else\\n        {\\n             res.push_back(ix);\\n             res.push_back(M-val[ix]);\\n             val[ix]-=k;\\n             update(ix+1,-k);\\n             ss.update(ix,ix,val[ix]);\\n        }\\n        return res;\\n        \\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n         \\n          ll here=get(maxRow+1);\\n    \\n          if(here<k)\\n              return false;\\n        \\n          while(left<=maxRow)\\n          {\\n               if(val[left]>k)\\n               {\\n                    val[left]-=k;\\n                    update(left+1,-k);\\n                    ss.update(left,left,val[left]);\\n        \\n                    return true;\\n               }\\n               else\\n               {\\n                    \\n                    update(left+1,-val[left]);\\n                    k-=val[left]; \\n                    val[left]=0;\\n                    \\n                    left++;\\n               }\\n          }\\n        \\n        return (k==0);\\n              \\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n#define ll long long\\nclass sg{\\n\\n    public:\\n    vector<ll> seg;\\n    int N;\\n    void merge(ll & cur,ll & left,ll & right){\\n              cur=max(left,right);\\n    }\\n    ll Query(int qs,int qe,int si,int ss,int se){ \\n         if(ss>qe||se<qs||ss>se)\\n              return -1 ;\\n             if(ss>=qs&&se<=qe)\\n              return seg[si];\\n             int mid=(se+ss)/2;\\n             ll le=Query(qs,qe,2*si+1,ss,mid);\\n             ll ri=Query(qs,qe,2*si+2,mid+1,se);\\n             ll res;\\n             merge(res,le,ri);\\n             return res;\\n    }\\n    void Update(int qs,int qe,int diff,int si,int ss,int se)\\n    {\\n                if(ss>qe||se<qs||ss>se)\\n                    return ;\\n                if(ss>=qs&&se<=qe)\\n                 {\\n                   seg[si]=diff;\\n                   return ;\\n                 }\\n\\n            int mid=(se+ss)/2;\\n\\n            Update(qs,qe,diff,2*si+1,ss,mid);\\n            Update(qs,qe,diff,2*si+2,mid+1,se);\\n\\n            merge(seg[si],seg[2*si+1],seg[2*si+2]);\\n    }\\n    void Build(ll val,int si,int ss,int se)\\n    {        if(ss>se) return;\\n             if(ss==se){\\n             seg[si]=val;return ;}\\n             int mid=(ss+se)/2;\\n             Build(val,2*si+1,ss,mid);\\n             Build(val,2*si+2,mid+1,se);\\n             merge(seg[si],seg[2*si+1],seg[2*si+2]);\\n    }\\n    void build(ll val){ Build(val,0,0,N-1);}\\n    ll query(ll qs,ll qe){ return Query(qs,qe,0,0,N-1);}\\n    void update(ll qs,ll qe,ll val){ Update(qs,qe,val,0,0,N-1);}\\n};\\n\\nclass BookMyShow {\\npublic:\\n    sg ss;\\n    int left;\\n    vector<ll> val;\\n    vector<ll> BIT;    \\n    ll N,M;\\n    ll get(ll ix)\\n    {\\n        ll sum=0;\\n        while(ix)\\n        {\\n             sum+=BIT[ix];\\n             ix-=ix&(-ix);\\n        }\\n        return sum;\\n    }\\n    void update(ll ix, ll val)\\n    {   \\n            while(ix<=N)  \\n            {\\n                 BIT[ix]+=val;\\n                ix+=ix&(-ix);\\n            }\\n    }\\n    BookMyShow(int n, int m) {\\n           ss.seg=vector<ll>(4*n);\\n           ss.N=n;\\n           ss.build(m);\\n           N=n;\\n           M=m;\\n           left=0;\\n           val.clear();\\n           val.resize(n);\\n           for(int i=0;i<n;i++) val[i]=m;\\n           BIT.resize(n+1);\\n           for(int i=0;i<=n;i++) BIT[i]=0;\\n           for(int i=1;i<=n;i++)\\n               update(i,m);\\n           \\n    }\\n    vector<int> gather(int k, int maxRow) {\\n         vector<int> res;\\n        \\n        ll l=left,h=maxRow;\\n        ll ix=-1;\\n        while(l<=h)\\n        {\\n             ll mid=(l+h)/2;\\n             if(ss.query(l,mid)>=k)\\n             {\\n                 ix=mid;\\n                 h=mid-1;\\n             }\\n             else\\n             {\\n                 l=mid+1;\\n             }\\n        }\\n        if(ix==-1)\\n            return res;\\n        else\\n        {\\n             res.push_back(ix);\\n             res.push_back(M-val[ix]);\\n             val[ix]-=k;\\n             update(ix+1,-k);\\n             ss.update(ix,ix,val[ix]);\\n        }\\n        return res;\\n        \\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n         \\n          ll here=get(maxRow+1);\\n    \\n          if(here<k)\\n              return false;\\n        \\n          while(left<=maxRow)\\n          {\\n               if(val[left]>k)\\n               {\\n                    val[left]-=k;\\n                    update(left+1,-k);\\n                    ss.update(left,left,val[left]);\\n        \\n                    return true;\\n               }\\n               else\\n               {\\n                    \\n                    update(left+1,-val[left]);\\n                    k-=val[left]; \\n                    val[left]=0;\\n                    \\n                    left++;\\n               }\\n          }\\n        \\n        return (k==0);\\n              \\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084051,
                "title": "correct-solution-tle-91pass-out-of-94-testcases",
                "content": "```\\nclass BookMyShow {\\npublic:\\n    vector<int>row,col;\\n    int n,m;\\n    BookMyShow(int nn, int mm) {\\n        n=nn;m=mm;\\n        row.resize(nn,0);\\n        \\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        \\n        for(int i=0;i<=maxRow;i++)\\n        {\\n            if(m-row[i]>=k) {\\n                int x=row[i];\\n                row[i]+=k;\\n                return {i,x};\\n            }\\n        }\\n        return {};\\n         \\n        \\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int z=k;\\n        for(int i=0;i<=maxRow;i++)\\n        {\\n             if(row[i]<m)\\n             {\\n                 if(k==0) break;\\n                 \\n                 if(k>= m-row[i])\\n                 {\\n                     k-= m-row[i];\\n                      \\n                 }\\n                 else if(k < m-row[i])\\n                 {\\n                     \\n                     k=0;\\n                 }\\n                 \\n             }\\n             \\n            \\n        }\\n        if(k==0){\\n            k=z;\\n             for(int i=0;i<=maxRow;i++)\\n                {\\n              if(row[i]<m)\\n              {\\n                 if(k==0) break;\\n                 \\n                 if(k>= m-row[i])\\n                 {\\n                     k-= m-row[i];\\n                     row[i]=m;\\n                 }\\n                 else if(k < m-row[i])\\n                 {\\n                     row[i]+=k;\\n                     k=0;\\n                 }\\n                 \\n             }\\n             \\n            \\n        }\\n            \\n            \\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BookMyShow {\\npublic:\\n    vector<int>row,col;\\n    int n,m;\\n    BookMyShow(int nn, int mm) {\\n        n=nn;m=mm;\\n        row.resize(nn,0);\\n        \\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        \\n        for(int i=0;i<=maxRow;i++)\\n        {\\n            if(m-row[i]>=k) {\\n                int x=row[i];\\n                row[i]+=k;\\n                return {i,x};\\n            }\\n        }\\n        return {};\\n         \\n        \\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        int z=k;\\n        for(int i=0;i<=maxRow;i++)\\n        {\\n             if(row[i]<m)\\n             {\\n                 if(k==0) break;\\n                 \\n                 if(k>= m-row[i])\\n                 {\\n                     k-= m-row[i];\\n                      \\n                 }\\n                 else if(k < m-row[i])\\n                 {\\n                     \\n                     k=0;\\n                 }\\n                 \\n             }\\n             \\n            \\n        }\\n        if(k==0){\\n            k=z;\\n             for(int i=0;i<=maxRow;i++)\\n                {\\n              if(row[i]<m)\\n              {\\n                 if(k==0) break;\\n                 \\n                 if(k>= m-row[i])\\n                 {\\n                     k-= m-row[i];\\n                     row[i]=m;\\n                 }\\n                 else if(k < m-row[i])\\n                 {\\n                     row[i]+=k;\\n                     k=0;\\n                 }\\n                 \\n             }\\n             \\n            \\n        }\\n            \\n            \\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084041,
                "title": "python-memory-limit-exceeded-with-heap",
                "content": "```python\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n\\n        self.allocations = defaultdict(list)\\n\\n        for r in range(n):\\n            for c in range(m):\\n                heappush(self.allocations[r], c)\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        # Find row with enough seats\\n        startRow = 0\\n        while len(self.allocations[startRow]) < k:\\n            startRow += 1\\n\\n        # Exceed max row\\n        if startRow > maxRow:\\n            return []\\n\\n        # Not continuous\\n        startSeat = self.allocations[startRow][0]\\n        endSeat = self.allocations[startRow][k - 1]\\n        if endSeat - startSeat != k - 1:\\n            return []\\n\\n        # Allocate the seats\\n        for i in range(k):\\n            heappop(self.allocations[startRow])\\n\\n        return [startRow, startSeat]\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        startRow = 0\\n\\n        while len(self.allocations[startRow]) < k:\\n            startRow += 1\\n\\n        if startRow > maxRow:\\n            return False\\n\\n        # Allocate the seats\\n        for i in range(k):\\n            heappop(self.allocations[startRow])\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n\\n        self.allocations = defaultdict(list)\\n\\n        for r in range(n):\\n            for c in range(m):\\n                heappush(self.allocations[r], c)\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        # Find row with enough seats\\n        startRow = 0\\n        while len(self.allocations[startRow]) < k:\\n            startRow += 1\\n\\n        # Exceed max row\\n        if startRow > maxRow:\\n            return []\\n\\n        # Not continuous\\n        startSeat = self.allocations[startRow][0]\\n        endSeat = self.allocations[startRow][k - 1]\\n        if endSeat - startSeat != k - 1:\\n            return []\\n\\n        # Allocate the seats\\n        for i in range(k):\\n            heappop(self.allocations[startRow])\\n\\n        return [startRow, startSeat]\\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        startRow = 0\\n\\n        while len(self.allocations[startRow]) < k:\\n            startRow += 1\\n\\n        if startRow > maxRow:\\n            return False\\n\\n        # Allocate the seats\\n        for i in range(k):\\n            heappop(self.allocations[startRow])\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084027,
                "title": "python-memory-limit-exceeded-any-tips",
                "content": "Couldn\\'t figure out how to improve for a scenerio that the max seats in the row was 9999999\\n\\n```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.seats = [[0] * m for i in range(n)]        \\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        counter = 0\\n        start = None\\n        for r in range(maxRow + 1):\\n            for c in range(len(self.seats[0])):\\n                \\n                # If the seat is empty, try to fill the row with people sitting\\n                # side by side\\n                if self.seats[r][c] == 0:\\n                    counter += 1\\n                    \\n                    if start is None:\\n                        start = c\\n                    \\n                    if counter == k:\\n                        for chair in range(start + k):\\n                            self.seats[r][chair] = 1\\n                            \\n                        return [r, start]\\n                else:\\n                    continue\\n            \\n            # We need to reset where the first chair is because the row\\n            # Did not fit everyone\\n            counter = 0\\n            start = None\\n        \\n        return []\\n                    \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        counter = 0\\n        temp = copy.deepcopy(self.seats)\\n        \\n        for r in range(maxRow + 1):\\n            for c in range(len(self.seats[0])):\\n                \\n                # If the seat is empty, fill it\\n                if temp[r][c] == 0:\\n                    counter += 1\\n                    temp[r][c] = 1\\n                    \\n                    if counter == k:\\n                        self.seats = temp\\n                        return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.seats = [[0] * m for i in range(n)]        \\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        counter = 0\\n        start = None\\n        for r in range(maxRow + 1):\\n            for c in range(len(self.seats[0])):\\n                \\n                # If the seat is empty, try to fill the row with people sitting\\n                # side by side\\n                if self.seats[r][c] == 0:\\n                    counter += 1\\n                    \\n                    if start is None:\\n                        start = c\\n                    \\n                    if counter == k:\\n                        for chair in range(start + k):\\n                            self.seats[r][chair] = 1\\n                            \\n                        return [r, start]\\n                else:\\n                    continue\\n            \\n            # We need to reset where the first chair is because the row\\n            # Did not fit everyone\\n            counter = 0\\n            start = None\\n        \\n        return []\\n                    \\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        counter = 0\\n        temp = copy.deepcopy(self.seats)\\n        \\n        for r in range(maxRow + 1):\\n            for c in range(len(self.seats[0])):\\n                \\n                # If the seat is empty, fill it\\n                if temp[r][c] == 0:\\n                    counter += 1\\n                    temp[r][c] = 1\\n                    \\n                    if counter == k:\\n                        self.seats = temp\\n                        return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084017,
                "title": "memory-limit-exceeded-how-to-debug",
                "content": "\\n\\n\\n\\n\\nclass BookMyShow {\\npublic:\\n    vector<vector<long long int>> v;\\n    \\n    BookMyShow(int n, int m) {\\n       v.resize(n, vector<long long int>(m));\\n        \\n        \\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        \\n        vector<int> ans;\\n       \\n        int c=v[0].size();\\n        \\n        int seat=0;\\n        \\n     \\n        \\n        for(int i=0;i<=maxRow;i++){\\n            int start=0;\\n            seat=0;\\n            for(int j=0;j<c;j++){\\n                \\n              //  cout<<v[i][j]<<\" \";\\n               if(v[i][j]==0) seat++;\\n              else if(v[i][j]==1){\\n                   seat=0;\\n                   start=j+1;\\n                  cout<<start<<\" \";\\n               }\\n                \\n                if(seat==k){\\n                    \\n                    for(int q=start;q<start+k;q++)v[i][q]=1;\\n                    ans.push_back(i);\\n                    ans.push_back(start);\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return {};\\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n     \\n        int seat=0;\\n        \\n          vector<vector<long long int>> dp;\\n          dp=v;\\n        \\n       // if(maxRow>=v.size())maxRow=v.size()-1;\\n        \\n        for(int i=0;i<=maxRow;i++){\\n            for(int j=0;j<v[0].size();j++){\\n                \\n                if(dp[i][j]==0){\\n                    seat++;\\n                    dp[i][j]=1;\\n                }\\n                if(seat==k){\\n                    v=dp;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */",
                "solutionTags": [],
                "code": "\\n\\n\\n\\n\\nclass BookMyShow {\\npublic:\\n    vector<vector<long long int>> v;\\n    \\n    BookMyShow(int n, int m) {\\n       v.resize(n, vector<long long int>(m));\\n        \\n        \\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        \\n        vector<int> ans;\\n       \\n        int c=v[0].size();\\n        \\n        int seat=0;\\n        \\n     \\n        \\n        for(int i=0;i<=maxRow;i++){\\n            int start=0;\\n            seat=0;\\n            for(int j=0;j<c;j++){\\n                \\n              //  cout<<v[i][j]<<\" \";\\n               if(v[i][j]==0) seat++;\\n              else if(v[i][j]==1){\\n                   seat=0;\\n                   start=j+1;\\n                  cout<<start<<\" \";\\n               }\\n                \\n                if(seat==k){\\n                    \\n                    for(int q=start;q<start+k;q++)v[i][q]=1;\\n                    ans.push_back(i);\\n                    ans.push_back(start);\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return {};\\n        \\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n     \\n        int seat=0;\\n        \\n          vector<vector<long long int>> dp;\\n          dp=v;\\n        \\n       // if(maxRow>=v.size())maxRow=v.size()-1;\\n        \\n        for(int i=0;i<=maxRow;i++){\\n            for(int j=0;j<v[0].size();j++){\\n                \\n                if(dp[i][j]==0){\\n                    seat++;\\n                    dp[i][j]=1;\\n                }\\n                if(seat==k){\\n                    v=dp;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow* obj = new BookMyShow(n, m);\\n * vector<int> param_1 = obj->gather(k,maxRow);\\n * bool param_2 = obj->scatter(k,maxRow);\\n */",
                "codeTag": "C++"
            },
            {
                "id": 2083969,
                "title": "accepted-both-functions-o-log-n-segment-tree-bit-binary-search",
                "content": "\\n\\tclass BookMyShow {\\n\\tpublic:\\n\\t\\tvector<long long> arr;\\n\\t\\tvector<long long> tree;\\n\\t\\tvoid buildtree(int s, int e, int idx, vector<long long> &arr, vector<long long> &tree){\\n\\t\\t  if(s == e){\\n\\t\\t\\ttree[idx] = arr[s];\\n\\t\\t\\treturn;\\n\\t\\t  }\\n\\t\\t  int mid = (s + e)/2;\\n\\t\\t  buildtree(s, mid, 2*idx, arr, tree);\\n\\t\\t  buildtree(mid + 1, e, 2*idx + 1, arr, tree);\\n\\t\\t  tree[idx] = max(tree[2*idx] , tree[2*idx + 1]);\\n\\t\\t  return;\\n\\t\\t}\\n\\n\\t\\tlong long query(int ss, int se, int qs ,int qe,int idx, vector<long long> &tree){\\n\\t\\t  if(ss >= qs && se <= qe){\\n\\t\\t\\treturn tree[idx];\\n\\t\\t  }\\n\\n\\t\\t  if(se < qs || qe < ss){\\n\\t\\t\\treturn LLONG_MIN;\\n\\t\\t  }\\n\\n\\t\\t  int mid = (ss + se) /2;\\n\\t\\t  long long la = query(ss, mid , qs, qe, 2*idx, tree);\\n\\t\\t  long long ra = query(mid + 1, se, qs, qe, 2*idx + 1, tree);\\n\\t\\t  return max(la, ra);\\n\\t\\t}\\n\\n\\t\\tvoid update(long long ss, int se, int i, int idx,int increment, vector<long long> &tree){\\n\\t\\t  if(i < ss || i > se) return;\\n\\t\\t  if(ss == se){\\n\\t\\t\\ttree[idx] = increment;\\n\\t\\t\\treturn;\\n\\t\\t  }\\n\\t\\t  int mid = (ss + se) /2;\\n\\t\\t  update(ss, mid, i, 2*idx,increment, tree);\\n\\t\\t  update(mid + 1, se, i , 2*idx + 1, increment, tree);\\n\\t\\t  tree[idx] = max(tree[2*idx], tree[2*idx + 1]);\\n\\t\\t  return; \\n\\t\\t}\\n\\t\\tint curr;\\n\\t\\tint prev;\\n\\t\\tint nn;\\n\\t\\tint mm;\\n\\t\\tvector<long long> bit;\\n\\t\\tvoid updatebit(long long idx, long long incr){\\n\\t\\t\\twhile(idx < bit.size()){\\n\\t\\t\\t\\tbit[idx] += incr;\\n\\t\\t\\t\\tidx += (idx & (-idx));\\n\\t\\t\\t}\\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\t\\tlong long querybit(int idx){\\n\\t\\t\\tlong long res = 0;\\n\\t\\t\\twhile(idx >0 ){\\n\\t\\t\\t\\tres += bit[idx];\\n\\t\\t\\t\\tidx -= (idx & (-idx));\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tBookMyShow(int n, int m) {\\n\\t\\t\\tcurr = 0;\\n\\t\\t\\tprev = 0;\\n\\t\\t\\tnn = n;\\n\\t\\t\\tmm = m;\\n\\t\\t\\tarr.resize(n+1, m);\\n\\t\\t\\ttree.resize(4*n, LLONG_MIN);\\n\\t\\t\\tbit.resize(n+1, 0);\\n\\t\\t\\tbuildtree(0, n-1, 1, arr, tree);\\n\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\tupdatebit(i, m);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<long long> gather(int k, int maxRow) {\\n\\t\\t\\tif(k > mm) return{};\\n\\t\\t\\tint lo = 0;\\n\\t\\t\\tint hi = maxRow;\\n\\t\\t\\tint idx = -1;\\n\\t\\t\\twhile(lo <=hi ){\\n\\t\\t\\t\\tint mid = (lo + hi)/2;\\n\\t\\t\\t\\tlong long val = query(0, nn-1, 0, mid, 1, tree);\\n\\t\\t\\t\\tif(val >= k){\\n\\t\\t\\t\\t\\tidx = mid;\\n\\t\\t\\t\\t\\thi = mid-1;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tvector<long long> ans;\\n\\t\\t\\tif(idx == -1){\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans.push_back(idx);\\n\\t\\t\\t\\tans.push_back(mm- arr[idx]);\\n\\t\\t\\t\\tarr[idx] -= k;\\n\\t\\t\\t\\tupdate(0, nn-1, idx, 1, arr[idx], tree);\\n\\t\\t\\t\\tupdatebit(idx+1, -k);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tbool scatter(int k, int maxRow) {\\n\\t\\t\\tlong long sum = querybit(maxRow + 1);\\n\\t\\t\\tif(sum < k)return false;\\n\\t\\t\\twhile(k){\\n\\t\\t\\t\\tlong long val = min(1ll*k,1ll*arr[curr]);\\n\\t\\t\\t\\tk-=val;\\n\\t\\t\\t\\tarr[curr] -= val;\\n\\n\\t\\t\\t\\tupdatebit(curr+1, -val);\\n\\t\\t\\t\\tupdate(0, nn-1, curr, 1,arr[curr], tree);\\n\\t\\t\\t\\tif(k == 0) break;\\n\\t\\t\\t\\tcurr++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your BookMyShow object will be instantiated and called as such:\\n\\t * BookMyShow* obj = new BookMyShow(n, m);\\n\\t * vector<int> param_1 = obj->gather(k,maxRow);\\n\\t * bool param_2 = obj->scatter(k,maxRow);\\n\\t */",
                "solutionTags": [
                    "Tree",
                    "Binary Indexed Tree",
                    "Binary Tree"
                ],
                "code": "\\n\\tclass BookMyShow {\\n\\tpublic:\\n\\t\\tvector<long long> arr;\\n\\t\\tvector<long long> tree;\\n\\t\\tvoid buildtree(int s, int e, int idx, vector<long long> &arr, vector<long long> &tree){\\n\\t\\t  if(s == e){\\n\\t\\t\\ttree[idx] = arr[s];\\n\\t\\t\\treturn;\\n\\t\\t  }\\n\\t\\t  int mid = (s + e)/2;\\n\\t\\t  buildtree(s, mid, 2*idx, arr, tree);\\n\\t\\t  buildtree(mid + 1, e, 2*idx + 1, arr, tree);\\n\\t\\t  tree[idx] = max(tree[2*idx] , tree[2*idx + 1]);\\n\\t\\t  return;\\n\\t\\t}\\n\\n\\t\\tlong long query(int ss, int se, int qs ,int qe,int idx, vector<long long> &tree){\\n\\t\\t  if(ss >= qs && se <= qe){\\n\\t\\t\\treturn tree[idx];\\n\\t\\t  }\\n\\n\\t\\t  if(se < qs || qe < ss){\\n\\t\\t\\treturn LLONG_MIN;\\n\\t\\t  }\\n\\n\\t\\t  int mid = (ss + se) /2;\\n\\t\\t  long long la = query(ss, mid , qs, qe, 2*idx, tree);\\n\\t\\t  long long ra = query(mid + 1, se, qs, qe, 2*idx + 1, tree);\\n\\t\\t  return max(la, ra);\\n\\t\\t}\\n\\n\\t\\tvoid update(long long ss, int se, int i, int idx,int increment, vector<long long> &tree){\\n\\t\\t  if(i < ss || i > se) return;\\n\\t\\t  if(ss == se){\\n\\t\\t\\ttree[idx] = increment;\\n\\t\\t\\treturn;\\n\\t\\t  }\\n\\t\\t  int mid = (ss + se) /2;\\n\\t\\t  update(ss, mid, i, 2*idx,increment, tree);\\n\\t\\t  update(mid + 1, se, i , 2*idx + 1, increment, tree);\\n\\t\\t  tree[idx] = max(tree[2*idx], tree[2*idx + 1]);\\n\\t\\t  return; \\n\\t\\t}\\n\\t\\tint curr;\\n\\t\\tint prev;\\n\\t\\tint nn;\\n\\t\\tint mm;\\n\\t\\tvector<long long> bit;\\n\\t\\tvoid updatebit(long long idx, long long incr){\\n\\t\\t\\twhile(idx < bit.size()){\\n\\t\\t\\t\\tbit[idx] += incr;\\n\\t\\t\\t\\tidx += (idx & (-idx));\\n\\t\\t\\t}\\n\\t\\t\\treturn ;\\n\\t\\t}\\n\\t\\tlong long querybit(int idx){\\n\\t\\t\\tlong long res = 0;\\n\\t\\t\\twhile(idx >0 ){\\n\\t\\t\\t\\tres += bit[idx];\\n\\t\\t\\t\\tidx -= (idx & (-idx));\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tBookMyShow(int n, int m) {\\n\\t\\t\\tcurr = 0;\\n\\t\\t\\tprev = 0;\\n\\t\\t\\tnn = n;\\n\\t\\t\\tmm = m;\\n\\t\\t\\tarr.resize(n+1, m);\\n\\t\\t\\ttree.resize(4*n, LLONG_MIN);\\n\\t\\t\\tbit.resize(n+1, 0);\\n\\t\\t\\tbuildtree(0, n-1, 1, arr, tree);\\n\\t\\t\\tfor(int i=1; i<=n; i++){\\n\\t\\t\\t\\tupdatebit(i, m);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<long long> gather(int k, int maxRow) {\\n\\t\\t\\tif(k > mm) return{};\\n\\t\\t\\tint lo = 0;\\n\\t\\t\\tint hi = maxRow;\\n\\t\\t\\tint idx = -1;\\n\\t\\t\\twhile(lo <=hi ){\\n\\t\\t\\t\\tint mid = (lo + hi)/2;\\n\\t\\t\\t\\tlong long val = query(0, nn-1, 0, mid, 1, tree);\\n\\t\\t\\t\\tif(val >= k){\\n\\t\\t\\t\\t\\tidx = mid;\\n\\t\\t\\t\\t\\thi = mid-1;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tvector<long long> ans;\\n\\t\\t\\tif(idx == -1){\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tans.push_back(idx);\\n\\t\\t\\t\\tans.push_back(mm- arr[idx]);\\n\\t\\t\\t\\tarr[idx] -= k;\\n\\t\\t\\t\\tupdate(0, nn-1, idx, 1, arr[idx], tree);\\n\\t\\t\\t\\tupdatebit(idx+1, -k);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tbool scatter(int k, int maxRow) {\\n\\t\\t\\tlong long sum = querybit(maxRow + 1);\\n\\t\\t\\tif(sum < k)return false;\\n\\t\\t\\twhile(k){\\n\\t\\t\\t\\tlong long val = min(1ll*k,1ll*arr[curr]);\\n\\t\\t\\t\\tk-=val;\\n\\t\\t\\t\\tarr[curr] -= val;\\n\\n\\t\\t\\t\\tupdatebit(curr+1, -val);\\n\\t\\t\\t\\tupdate(0, nn-1, curr, 1,arr[curr], tree);\\n\\t\\t\\t\\tif(k == 0) break;\\n\\t\\t\\t\\tcurr++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your BookMyShow object will be instantiated and called as such:\\n\\t * BookMyShow* obj = new BookMyShow(n, m);\\n\\t * vector<int> param_1 = obj->gather(k,maxRow);\\n\\t * bool param_2 = obj->scatter(k,maxRow);\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 2083962,
                "title": "iterate-each-row-why-i-get-accepted-i-don-t-even-use-segment-tree",
                "content": "```\\ntype BookMyShow struct {\\n    seats []int\\n    row int\\n    col int // maximum number of seats that a row has\\n}\\n\\n\\nfunc Constructor(n int, m int) BookMyShow {\\n    return BookMyShow{\\n        seats : make([]int,n),\\n        row : n,\\n        col : m,\\n    }\\n}\\n\\n\\nfunc (this *BookMyShow) Gather(k int, maxRow int) []int {\\n    for i:=0;i<=maxRow;i++{\\n        if this.seats[i] + k <= this.col{\\n            ans := []int{i,this.seats[i]}\\n            this.seats[i] = this.seats[i] + k\\n            return ans\\n        }\\n    }\\n    \\n    return []int{}\\n}\\n\\n\\nfunc (this *BookMyShow) Scatter(k int, maxRow int) bool {\\n    availableSeats := 0\\n    for i:=0;i<=maxRow;i++{\\n        availableSeats += this.col - this.seats[i]\\n    }\\n    \\n    // do not fill the seats if it is insufficient\\n    if availableSeats < k{\\n        return false\\n    }\\n    \\n    // if the seats sufficient\\n    for i:=0;i<=maxRow;i++{\\n        // fill the smallest row first\\n        currFillRow := min(this.col-this.seats[i],k)\\n        this.seats[i] += currFillRow\\n        k -= currFillRow\\n        if k == 0{\\n            break\\n        }\\n    }\\n    \\n    return true\\n}\\n\\nfunc min(a int,b int) int{\\n    if a < b{\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype BookMyShow struct {\\n    seats []int\\n    row int\\n    col int // maximum number of seats that a row has\\n}\\n\\n\\nfunc Constructor(n int, m int) BookMyShow {\\n    return BookMyShow{\\n        seats : make([]int,n),\\n        row : n,\\n        col : m,\\n    }\\n}\\n\\n\\nfunc (this *BookMyShow) Gather(k int, maxRow int) []int {\\n    for i:=0;i<=maxRow;i++{\\n        if this.seats[i] + k <= this.col{\\n            ans := []int{i,this.seats[i]}\\n            this.seats[i] = this.seats[i] + k\\n            return ans\\n        }\\n    }\\n    \\n    return []int{}\\n}\\n\\n\\nfunc (this *BookMyShow) Scatter(k int, maxRow int) bool {\\n    availableSeats := 0\\n    for i:=0;i<=maxRow;i++{\\n        availableSeats += this.col - this.seats[i]\\n    }\\n    \\n    // do not fill the seats if it is insufficient\\n    if availableSeats < k{\\n        return false\\n    }\\n    \\n    // if the seats sufficient\\n    for i:=0;i<=maxRow;i++{\\n        // fill the smallest row first\\n        currFillRow := min(this.col-this.seats[i],k)\\n        this.seats[i] += currFillRow\\n        k -= currFillRow\\n        if k == 0{\\n            break\\n        }\\n    }\\n    \\n    return true\\n}\\n\\nfunc min(a int,b int) int{\\n    if a < b{\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083959,
                "title": "can-someone-tell-where-i-went-wrong",
                "content": "class BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.theatre=[0 for _ in range(n)]\\n        self.rows=n\\n        self.seats=m\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        r=-1\\n        c=-1\\n        for i in range(maxRow+1):\\n            if self.seats-self.theatre[i]>=k:\\n                c=self.theatre[i]\\n                self.theatre[i]+=k\\n                r=i\\n                \\n                break\\n            else:\\n                continue\\n        if r==-1:\\n            return []\\n        return [r,c]\\n            \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        r=-1\\n        c=-1\\n        prev=self.theatre.copy()\\n        for i in range(maxRow+1):\\n            if self.seats-self.theatre[i]<k:\\n                if self.theatre[i]<self.seats:\\n                    x=self.seats-self.theatre[i]\\n                    self.theatre[i]+=x\\n                    k=k-x\\n                \\n            else:\\n                self.theatre[i]+=k\\n                k-=k\\n                break\\n        if k==0:\\n            return True\\n        else:\\n            self.theatre=prev\\n            return False\\n",
                "solutionTags": [],
                "code": "class BookMyShow:\\n\\n    def __init__(self, n: int, m: int):\\n        self.theatre=[0 for _ in range(n)]\\n        self.rows=n\\n        self.seats=m\\n\\n    def gather(self, k: int, maxRow: int) -> List[int]:\\n        r=-1\\n        c=-1\\n        for i in range(maxRow+1):\\n            if self.seats-self.theatre[i]>=k:\\n                c=self.theatre[i]\\n                self.theatre[i]+=k\\n                r=i\\n                \\n                break\\n            else:\\n                continue\\n        if r==-1:\\n            return []\\n        return [r,c]\\n            \\n\\n    def scatter(self, k: int, maxRow: int) -> bool:\\n        r=-1\\n        c=-1\\n        prev=self.theatre.copy()\\n        for i in range(maxRow+1):\\n            if self.seats-self.theatre[i]<k:\\n                if self.theatre[i]<self.seats:\\n                    x=self.seats-self.theatre[i]\\n                    self.theatre[i]+=x\\n                    k=k-x\\n                \\n            else:\\n                self.theatre[i]+=k\\n                k-=k\\n                break\\n        if k==0:\\n            return True\\n        else:\\n            self.theatre=prev\\n            return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2083936,
                "title": "javascript-brute-force",
                "content": "```js\\n/**\\n * @param {number} n\\n * @param {number} m\\n */\\nconst BookMyShow = function (n, m) {\\n  this.row = n - 1\\n  this.column = m - 1\\n  this.used = new Array(n).fill(-1)\\n}\\n\\n/**\\n * @param {number} k\\n * @param {number} maxRow\\n * @return {number[]}\\n */\\nBookMyShow.prototype.gather = function (k, maxRow) {\\n  for (let i = 0; i <= maxRow; i++) {\\n    // console.log(i, this.used[i], this.column - this.used[i], k)\\n    if (this.column - this.used[i] >= k) {\\n      const startColumn = this.used[i] + 1\\n      this.used[i] = this.used[i] + k\\n      console.log([i, startColumn])\\n      return [i, startColumn]\\n    }\\n  }\\n  console.log([])\\n  return []\\n}\\n\\n/**\\n * @param {number} k\\n * @param {number} maxRow\\n * @return {boolean}\\n */\\nBookMyShow.prototype.scatter = function (k, maxRow) {\\n  let remain = 0\\n  for (let i = 0; i <= maxRow; i++) {\\n    remain += this.column - this.used[i]\\n  }\\n  if (remain < k) {\\n    console.log(false)\\n    return false\\n  }\\n  let row = 0\\n  while (k > 0) {\\n    if (this.column - this.used[row] <= k) {\\n      k -= this.column - this.used[row]\\n      this.used[row] = this.column\\n    } else {\\n      this.used[row] += k\\n      k = 0\\n    }\\n    row += 1\\n  }\\n  console.log(true)\\n  return true\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number} n\\n * @param {number} m\\n */\\nconst BookMyShow = function (n, m) {\\n  this.row = n - 1\\n  this.column = m - 1\\n  this.used = new Array(n).fill(-1)\\n}\\n\\n/**\\n * @param {number} k\\n * @param {number} maxRow\\n * @return {number[]}\\n */\\nBookMyShow.prototype.gather = function (k, maxRow) {\\n  for (let i = 0; i <= maxRow; i++) {\\n    // console.log(i, this.used[i], this.column - this.used[i], k)\\n    if (this.column - this.used[i] >= k) {\\n      const startColumn = this.used[i] + 1\\n      this.used[i] = this.used[i] + k\\n      console.log([i, startColumn])\\n      return [i, startColumn]\\n    }\\n  }\\n  console.log([])\\n  return []\\n}\\n\\n/**\\n * @param {number} k\\n * @param {number} maxRow\\n * @return {boolean}\\n */\\nBookMyShow.prototype.scatter = function (k, maxRow) {\\n  let remain = 0\\n  for (let i = 0; i <= maxRow; i++) {\\n    remain += this.column - this.used[i]\\n  }\\n  if (remain < k) {\\n    console.log(false)\\n    return false\\n  }\\n  let row = 0\\n  while (k > 0) {\\n    if (this.column - this.used[row] <= k) {\\n      k -= this.column - this.used[row]\\n      this.used[row] = this.column\\n    } else {\\n      this.used[row] += k\\n      k = 0\\n    }\\n    row += 1\\n  }\\n  console.log(true)\\n  return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083928,
                "title": "c-avoiding-tle-then-getting-wa-needs-help",
                "content": "Solution 1 : TLE.\\n```\\ntypedef long long ll;\\n\\n\\nclass BookMyShow {\\npublic:\\n    vector<ll> row;\\n    ll seats;\\n    ll M;\\n    BookMyShow(int n, int m) {\\n        row.resize(n,0);\\n        seats = (ll)n*m;\\n        M = m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        for(int i = 0; i <= maxRow; i++){\\n            if(row[i] + k <= M){\\n                int ind = row[i];\\n                row[i] += k;\\n                seats -= k;\\n                return {i, ind};\\n            }\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        ll booked = accumulate(row.begin(), row.begin()+maxRow+1, 0LL);\\n        ll total = (ll)maxRow * M + M;\\n        if(total - booked < k) return false;\\n        seats -= k;\\n        for(int i = 0; i <= maxRow; i++){\\n            ll left = M - row[i];\\n            if(left <= k){\\n                row[i] = M;\\n                k -= left;\\n            }\\n            else{\\n                row[i] += k;\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nTo avoid TLE i used DP ans prefix sum. but getting WA for some testcases.\\nSolution 2 : WA\\n```\\ntypedef long long ll;\\n\\n\\nclass BookMyShow {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<ll> row, dp;\\n    ll seats;\\n    ll M;\\n    BookMyShow(int n, int m) {\\n        row.resize(n,0);\\n        dp.resize(n,0);\\n        seats = (ll)n*m;\\n        M = m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        for(int i = 0; i <= maxRow; i++){\\n            if(row[i] + k <= M){\\n                int ind = row[i];\\n                row[i] += k;\\n                dp[i] = ((ll)k + dp[i])%mod;\\n                seats -= k;\\n                return {i, ind};\\n            }\\n            if(i > 0)dp[i] = (dp[i]%mod +  dp[i-1]) % mod;\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        ll booked = dp[maxRow];\\n        ll total = (ll)maxRow * M + M;\\n        if(total - booked < k) return false;\\n        seats -= k;\\n        for(int i = 0; i <= maxRow; i++){\\n            ll left = M - row[i];\\n            if(left <= k){\\n                row[i] = M;\\n                dp[i] = ((ll)row[i]%mod + (i > 0 ? dp[i-1] : 0)) % mod;\\n                k -= left;\\n            }\\n            else{\\n                row[i] += k;\\n                dp[i] = ((ll)k % mod + dp[i]) % mod;\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\n\\n\\nclass BookMyShow {\\npublic:\\n    vector<ll> row;\\n    ll seats;\\n    ll M;\\n    BookMyShow(int n, int m) {\\n        row.resize(n,0);\\n        seats = (ll)n*m;\\n        M = m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        for(int i = 0; i <= maxRow; i++){\\n            if(row[i] + k <= M){\\n                int ind = row[i];\\n                row[i] += k;\\n                seats -= k;\\n                return {i, ind};\\n            }\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        ll booked = accumulate(row.begin(), row.begin()+maxRow+1, 0LL);\\n        ll total = (ll)maxRow * M + M;\\n        if(total - booked < k) return false;\\n        seats -= k;\\n        for(int i = 0; i <= maxRow; i++){\\n            ll left = M - row[i];\\n            if(left <= k){\\n                row[i] = M;\\n                k -= left;\\n            }\\n            else{\\n                row[i] += k;\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\ntypedef long long ll;\\n\\n\\nclass BookMyShow {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<ll> row, dp;\\n    ll seats;\\n    ll M;\\n    BookMyShow(int n, int m) {\\n        row.resize(n,0);\\n        dp.resize(n,0);\\n        seats = (ll)n*m;\\n        M = m;\\n    }\\n    \\n    vector<int> gather(int k, int maxRow) {\\n        for(int i = 0; i <= maxRow; i++){\\n            if(row[i] + k <= M){\\n                int ind = row[i];\\n                row[i] += k;\\n                dp[i] = ((ll)k + dp[i])%mod;\\n                seats -= k;\\n                return {i, ind};\\n            }\\n            if(i > 0)dp[i] = (dp[i]%mod +  dp[i-1]) % mod;\\n        }\\n        return {};\\n    }\\n    \\n    bool scatter(int k, int maxRow) {\\n        ll booked = dp[maxRow];\\n        ll total = (ll)maxRow * M + M;\\n        if(total - booked < k) return false;\\n        seats -= k;\\n        for(int i = 0; i <= maxRow; i++){\\n            ll left = M - row[i];\\n            if(left <= k){\\n                row[i] = M;\\n                dp[i] = ((ll)row[i]%mod + (i > 0 ? dp[i-1] : 0)) % mod;\\n                k -= left;\\n            }\\n            else{\\n                row[i] += k;\\n                dp[i] = ((ll)k % mod + dp[i]) % mod;\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083858,
                "title": "java-solution-easy-to-understand",
                "content": "/**\\n * A concert hall has n rows numbered from 0 to n - 1, each with m seats, numbered from 0 to m - 1.\\n * You need to design a ticketing system that can allocate seats in the following cases:\\n *\\n * If a group of k spectators can sit together in a row.\\n * If every member of a group of k spectators can get a seat. They may or may not sit together.\\n * Note that the spectators are very picky. Hence:\\n *\\n * They will book seats only if each member of their group can get a seat with row number\\n * less than or equal to maxRow. maxRow can vary from group to group.\\n * In case there are multiple rows to choose from, the row with the smallest number is chosen.\\n * If there are multiple seats to choose in the same row, the seat with the smallest number is chosen.\\n * Implement the BookMyShow class:\\n *\\n * BookMyShow(int n, int m) Initializes the object with n as number of rows and m as number of seats per row.\\n *\\n * int[] gather(int k, int maxRow) Returns an array of length 2 denoting the row and seat number (respectively)\\n * of the first seat being allocated to the k members of the group, who must sit together.\\n * In other words, it returns the smallest possible r and c such that all [c, c + k - 1] seats\\n * are valid and empty in row r, and r <= maxRow. Returns [] in case it is not\\n * possible to allocate seats to the group.\\n *\\n * boolean scatter(int k, int maxRow) Returns true if all k members of the group can be\\n * allocated seats in rows 0 to maxRow, who may or may not sit together.\\n * If the seats can be allocated, it allocates k seats to the group with the smallest row numbers,\\n * and the smallest possible seat numbers in each row. Otherwise, returns false.\\n */\\n```\\nclass BookMyShow {\\n\\n      private int lo = 0;\\n        private final int m;\\n        private final int[] sits;\\n\\n    public BookMyShow(int n, int m) {\\n        this.m = m; sits = new int[n]; Arrays.fill(sits, m);\\n    }\\n    \\n    public int[] gather(int k, int maxRow)  {\\n            for (int i = lo; i <= maxRow; i++) {\\n                if (k <= sits[i]) {\\n                    sits[i] -= k;\\n                    return new int[]{i, m - sits[i] - k};\\n                }\\n            }\\n            return new int[]{};\\n        }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n            int idx = lo;\\n            while (idx <= maxRow && k > sits[idx]) k -= sits[idx++];\\n            if (idx > maxRow && k > 0) return false;\\n\\n            sits[idx] -= k;\\n            lo = idx;\\n\\n            return true;\\n        }\\n    \\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "/**\\n * A concert hall has n rows numbered from 0 to n - 1, each with m seats, numbered from 0 to m - 1.\\n * You need to design a ticketing system that can allocate seats in the following cases:\\n *\\n * If a group of k spectators can sit together in a row.\\n * If every member of a group of k spectators can get a seat. They may or may not sit together.\\n * Note that the spectators are very picky. Hence:\\n *\\n * They will book seats only if each member of their group can get a seat with row number\\n * less than or equal to maxRow. maxRow can vary from group to group.\\n * In case there are multiple rows to choose from, the row with the smallest number is chosen.\\n * If there are multiple seats to choose in the same row, the seat with the smallest number is chosen.\\n * Implement the BookMyShow class:\\n *\\n * BookMyShow(int n, int m) Initializes the object with n as number of rows and m as number of seats per row.\\n *\\n * int[] gather(int k, int maxRow) Returns an array of length 2 denoting the row and seat number (respectively)\\n * of the first seat being allocated to the k members of the group, who must sit together.\\n * In other words, it returns the smallest possible r and c such that all [c, c + k - 1] seats\\n * are valid and empty in row r, and r <= maxRow. Returns [] in case it is not\\n * possible to allocate seats to the group.\\n *\\n * boolean scatter(int k, int maxRow) Returns true if all k members of the group can be\\n * allocated seats in rows 0 to maxRow, who may or may not sit together.\\n * If the seats can be allocated, it allocates k seats to the group with the smallest row numbers,\\n * and the smallest possible seat numbers in each row. Otherwise, returns false.\\n */\\n```\\nclass BookMyShow {\\n\\n      private int lo = 0;\\n        private final int m;\\n        private final int[] sits;\\n\\n    public BookMyShow(int n, int m) {\\n        this.m = m; sits = new int[n]; Arrays.fill(sits, m);\\n    }\\n    \\n    public int[] gather(int k, int maxRow)  {\\n            for (int i = lo; i <= maxRow; i++) {\\n                if (k <= sits[i]) {\\n                    sits[i] -= k;\\n                    return new int[]{i, m - sits[i] - k};\\n                }\\n            }\\n            return new int[]{};\\n        }\\n    \\n    public boolean scatter(int k, int maxRow) {\\n            int idx = lo;\\n            while (idx <= maxRow && k > sits[idx]) k -= sits[idx++];\\n            if (idx > maxRow && k > 0) return false;\\n\\n            sits[idx] -= k;\\n            lo = idx;\\n\\n            return true;\\n        }\\n    \\n}\\n\\n/**\\n * Your BookMyShow object will be instantiated and called as such:\\n * BookMyShow obj = new BookMyShow(n, m);\\n * int[] param_1 = obj.gather(k,maxRow);\\n * boolean param_2 = obj.scatter(k,maxRow);\\n */",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565341,
                "content": [
                    {
                        "username": "mr_scott",
                        "content": "I see there are a bunch of answers with linear time query for gather and scatter functions and some of them are accepted. I hope Leetcode will correct these in their additional test cases. Linear time query is pretty straigtforward to implement and most of us just did not do it after seeing the constraints."
                    },
                    {
                        "username": "Msey",
                        "content": "decided to start solving Hard questions, picked that random one\\nhow lucky am I?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You again."
                    },
                    {
                        "username": "rubiconXL",
                        "content": "literally as unlucky you can be"
                    },
                    {
                        "username": "Finesse",
                        "content": "> `1 <= n <= 5 * 10⁴`\n> `1 <= m <= 10⁹`\n\nWhat a giant hall. I'm not sure whether a present or a past band can fill it with spectators."
                    },
                    {
                        "username": "pappu_bhai",
                        "content": "Lowest acceptance rate for any LC question by far."
                    }
                ]
            },
            {
                "id": 1801325,
                "content": [
                    {
                        "username": "mr_scott",
                        "content": "I see there are a bunch of answers with linear time query for gather and scatter functions and some of them are accepted. I hope Leetcode will correct these in their additional test cases. Linear time query is pretty straigtforward to implement and most of us just did not do it after seeing the constraints."
                    },
                    {
                        "username": "Msey",
                        "content": "decided to start solving Hard questions, picked that random one\\nhow lucky am I?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You again."
                    },
                    {
                        "username": "rubiconXL",
                        "content": "literally as unlucky you can be"
                    },
                    {
                        "username": "Finesse",
                        "content": "> `1 <= n <= 5 * 10⁴`\n> `1 <= m <= 10⁹`\n\nWhat a giant hall. I'm not sure whether a present or a past band can fill it with spectators."
                    },
                    {
                        "username": "pappu_bhai",
                        "content": "Lowest acceptance rate for any LC question by far."
                    }
                ]
            },
            {
                "id": 1887064,
                "content": [
                    {
                        "username": "mr_scott",
                        "content": "I see there are a bunch of answers with linear time query for gather and scatter functions and some of them are accepted. I hope Leetcode will correct these in their additional test cases. Linear time query is pretty straigtforward to implement and most of us just did not do it after seeing the constraints."
                    },
                    {
                        "username": "Msey",
                        "content": "decided to start solving Hard questions, picked that random one\\nhow lucky am I?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You again."
                    },
                    {
                        "username": "rubiconXL",
                        "content": "literally as unlucky you can be"
                    },
                    {
                        "username": "Finesse",
                        "content": "> `1 <= n <= 5 * 10⁴`\n> `1 <= m <= 10⁹`\n\nWhat a giant hall. I'm not sure whether a present or a past band can fill it with spectators."
                    },
                    {
                        "username": "pappu_bhai",
                        "content": "Lowest acceptance rate for any LC question by far."
                    }
                ]
            },
            {
                "id": 1576816,
                "content": [
                    {
                        "username": "mr_scott",
                        "content": "I see there are a bunch of answers with linear time query for gather and scatter functions and some of them are accepted. I hope Leetcode will correct these in their additional test cases. Linear time query is pretty straigtforward to implement and most of us just did not do it after seeing the constraints."
                    },
                    {
                        "username": "Msey",
                        "content": "decided to start solving Hard questions, picked that random one\\nhow lucky am I?"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "You again."
                    },
                    {
                        "username": "rubiconXL",
                        "content": "literally as unlucky you can be"
                    },
                    {
                        "username": "Finesse",
                        "content": "> `1 <= n <= 5 * 10⁴`\n> `1 <= m <= 10⁹`\n\nWhat a giant hall. I'm not sure whether a present or a past band can fill it with spectators."
                    },
                    {
                        "username": "pappu_bhai",
                        "content": "Lowest acceptance rate for any LC question by far."
                    }
                ]
            }
        ]
    }
]